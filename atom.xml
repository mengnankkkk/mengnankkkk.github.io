<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mengnankkのblog</title>
  <icon>https://mengnankk.asia/icon.png</icon>
  <subtitle>不要走捏</subtitle>
  <link href="https://mengnankk.asia/atom.xml" rel="self"/>
  <link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
  <link href="https://mengnankk.asia/"/>
  <updated>2024-12-10T06:21:57.179Z</updated>
  <id>https://mengnankk.asia/</id>
  
  <author>
    <name>mengnankkzhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python期末复习</title>
    <link href="https://mengnankk.asia/2024/12/10/python2/"/>
    <id>https://mengnankk.asia/2024/12/10/python2/</id>
    <published>2024-12-09T16:00:00.000Z</published>
    <updated>2024-12-10T06:21:57.179Z</updated>
    
    <content type="html"><![CDATA[<h1>正则表达式</h1><p>Python 的正则表达式通过 <code>re</code> 模块实现，用于处理复杂的字符串匹配和提取操作。</p><ul><li>常用函数：<ul><li><code>re.match(pattern, string)</code><br>从字符串的开头匹配，返回匹配对象或 <code>None</code>。</li><li><code>re.search(pattern, string)</code><br>搜索整个字符串，找到第一个匹配。</li><li><code>re.findall(pattern, string)</code><br>返回所有匹配的结果（列表形式）。</li><li><code>re.finditer(pattern, string)</code><br>返回所有匹配结果的迭代器。</li><li><code>re.sub(pattern, repl, string)</code><br>替换匹配的内容。</li><li><code>re.split(pattern, string)</code><br>根据模式分割字符串。</li></ul></li></ul><h3 id="2-常用正则表达式语法"><strong>2. 常用正则表达式语法</strong></h3><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意单个字符（除换行符）。</td></tr><tr><td><code>^</code></td><td>匹配字符串的开头。</td></tr><tr><td><code>$</code></td><td>匹配字符串的结尾。</td></tr><tr><td><code>*</code></td><td>匹配前面的字符 0 次或多次。</td></tr><tr><td><code>+</code></td><td>匹配前面的字符 1 次或多次。</td></tr><tr><td><code>?</code></td><td>匹配前面的字符 0 次或 1 次。</td></tr><tr><td><code>&#123;n&#125;</code></td><td>匹配前面的字符恰好 n 次。</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>匹配前面的字符至少 n 次。</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>匹配前面的字符至少 n 次，至多 m 次。</td></tr><tr><td><code>[]</code></td><td>匹配字符集合中的任意一个，例如 <code>[a-z]</code> 匹配小写字母。</td></tr><tr><td>`</td><td>`</td></tr><tr><td><code>()</code></td><td>分组，用于提取子模式。</td></tr><tr><td><code>\</code></td><td>转义字符，用于匹配特殊字符。</td></tr></tbody></table><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">email = &quot;example@domain.com&quot;</span><br><span class="line">pattern = r&quot;^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$&quot;</span><br><span class="line">if re.match(pattern, email):</span><br><span class="line">    print(&quot;有效的邮箱地址&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无效的邮箱地址&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th><code>\d</code></th><th>匹配任意数字，等价于 <code>[0-9]</code>。</th></tr></thead><tbody><tr><td><code>\D</code></td><td>匹配任意非数字。</td></tr><tr><td><code>\w</code></td><td>匹配任意字母、数字、下划线，等价于 <code>[a-zA-Z0-9_]</code>。</td></tr><tr><td><code>\W</code></td><td>匹配任意非字母、数字、下划线。</td></tr><tr><td><code>\s</code></td><td>匹配任意空白字符（包括空格、制表符等）。</td></tr><tr><td><code>\S</code></td><td>匹配任意非空白字符。</td></tr></tbody></table><p>对于需要多次使用的正则表达式，可以通过 <code>re.compile()</code> 提前编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python复制代码import re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(r&quot;\d+&quot;)</span><br><span class="line">result = pattern.findall(&quot;订单号123，总金额456元&quot;)</span><br><span class="line">print(result)  # 输出 [&#x27;123&#x27;, &#x27;456&#x27;]</span><br></pre></td></tr></table></figure><p>编译时可以指定标志（flags）：</p><ul><li><code>re.IGNORECASE</code> (<code>re.I</code>)：忽略大小写。</li><li><code>re.MULTILINE</code> (<code>re.M</code>)：多行模式。</li><li><code>re.DOTALL</code> (<code>re.S</code>)：使 <code>.</code> 匹配换行符。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&quot;hello&quot;, re.IGNORECASE)</span><br><span class="line">print(pattern.findall(&quot;Hello, hello, HELLO&quot;))  # 输出 [&#x27;Hello&#x27;, &#x27;hello&#x27;, &#x27;HELLO&#x27;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;正则表达式&lt;/h1&gt;
&lt;p&gt;Python 的正则表达式通过 &lt;code&gt;re&lt;/code&gt; 模块实现，用于处理复杂的字符串匹配和提取操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用函数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;re.match(pattern,</summary>
        
      
    
    
    
    <category term="python" scheme="https://mengnankk.asia/categories/python/"/>
    
    
    <category term="python" scheme="https://mengnankk.asia/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>大数据期末复习</title>
    <link href="https://mengnankk.asia/2024/12/08/bigdata/"/>
    <id>https://mengnankk.asia/2024/12/08/bigdata/</id>
    <published>2024-12-07T16:00:00.000Z</published>
    <updated>2024-12-14T13:04:39.464Z</updated>
    
    <content type="html"><![CDATA[<h1>基本概念</h1><p>大数据的四个特点：数据量大，数据类型繁多，处理速度快和价值密度低。</p><p>大数据对科学研究的影响：</p><p>第一种范式：实验科学， 第二种范式：理论科学，第三种范式：计算科学，第 四种范式：数据密集型科学。</p><p>云计算的关键技术包括虚拟化，分布式存储，分布式计算和多租户等</p><p>大数据和云计算物联网之间的关系：</p><p>大数据、云计算和物联网（IoT）紧密相关，互为支撑：</p><ol><li><strong>物联网与大数据</strong>：物联网设备生成海量数据，需要大数据技术进行存储、处理和分析，提取有价值的信息。</li><li><strong>物联网与云计算</strong>：云计算提供弹性计算和存储资源，支持物联网设备的数据存储、实时分析和处理。</li><li><strong>大数据与云计算</strong>：云计算为大数据提供基础设施支持，提供存储、计算能力和弹性扩展，使大数据处理更加高效。</li></ol><h1>简答题</h1><h2 id="1-MapReduce工作流程的描述">1. <strong>MapReduce工作流程的描述</strong></h2><p>MapReduce工作流程主要分为两个阶段：Map阶段和Reduce阶段。</p><ul><li><strong>Map阶段</strong>：在Map阶段，输入数据被分为多个片段，每个片段由一个Map任务处理。Map任务将输入数据（键值对）映射为中间结果（也为键值对）。每个Map任务输出的中间结果都会被按键进行分组，分组后的结果会被传递给Reduce阶段。</li><li><strong>Shuffle阶段</strong>：Map阶段完成后，Shuffle阶段会按照键对Map的输出进行排序和分组，确保同一键的值被发送到同一台Reducer机器上。此过程是MapReduce中的一个重要过程，称为Shuffle。</li><li><strong>Reduce阶段</strong>：在Reduce阶段，系统会接收到Map输出的分组结果，并对每个键的所有值进行处理，通常是进行聚合操作，如求和、求平均等，最后输出结果。</li></ul><h2 id="2-Flink核心组件栈的层次及具体内容">2. <strong>Flink核心组件栈的层次及具体内容</strong></h2><ul><li><p><strong>Flink Runtime</strong>：执行任务调度和资源管理。</p></li><li><p><strong>Flink API</strong>：包括流处理的DataStream API和批处理的DataSet API，Table API/SQL支持声明性查询。</p></li><li><p><strong>Connectors</strong>：用于连接外部数据源和数据接收端（如Kafka、HDFS等）。</p></li><li><p><strong>State &amp; Time Layer</strong>：用于处理有状态计算及时间处理（如事件时间和窗口操作）。</p></li><li><p><strong>Fault Tolerance &amp; Checkpointing</strong>：确保作业容错性和状态一致性。</p><ul><li><p>内部容错机制包括：</p><ul><li>at-least-once 至少执行一次</li><li>exactully-once 仅执行一次（跟storm一样）</li></ul><p>还有手动的checkpoint检查机制（spark streaming一样）</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+     +-------------------+      +-------------------+</span><br><span class="line">|    Client         |----&gt;|    JobManager     |-----&gt;|   TaskManager     |</span><br><span class="line">+-------------------+     +-------------------+      +-------------------+</span><br><span class="line">       |                        |                        |</span><br><span class="line">       v                        v                        v</span><br><span class="line">+-------------------+    +-------------------+     +-------------------+</span><br><span class="line">|   Data Source     |    |    Task Execution  |     |   State &amp; Fault    |</span><br><span class="line">|  (Kafka, HDFS,    |    |   (Map, Reduce)    |     |   Tolerance       |</span><br><span class="line">|    DB, etc.)      |    |                    |     |                   |</span><br><span class="line">+-------------------+    +-------------------+     +-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-YARN架构及MapReduce程序执行过程">3. <strong>YARN架构及MapReduce程序执行过程</strong></h2><ul><li><p><strong>YARN架构</strong>： YARN（Yet Another Resource Negotiator）是<strong>Hadoop的资源管理层</strong>，负责资源调度和管理。YARN的主要组件有：</p><ul><li><strong>ResourceManager</strong>：负责集群资源的管理和调度。</li><li><strong>NodeManager</strong>：每个节点上的代理，负责向ResourceManager汇报节点的资源使用情况，并管理任务的执行。</li><li><strong>ApplicationMaster</strong>：每个应用程序（例如MapReduce）会有一个独立的ApplicationMaster，负责与ResourceManager协作，获取资源并管理作业的生命周期。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+        +-------------------+       +-------------------+</span><br><span class="line">|    Client         |-------&gt;|  ResourceManager  |&lt;-----&gt;|  NodeManager      |</span><br><span class="line">|  (Submit Job)     |        |   (Resource Mgmt) |       |   (Task Execution)|</span><br><span class="line">+-------------------+        +-------------------+       +-------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                          +---------------------+</span><br><span class="line">                          |   ApplicationMaster |</span><br><span class="line">                          |    (App Life Cycle) |</span><br><span class="line">                          +---------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                         +------------------------+</span><br><span class="line">                         |   Task Execution       |</span><br><span class="line">                         |   (Map/Reduce Tasks)   |</span><br><span class="line">                         +------------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                          +---------------------+</span><br><span class="line">                          |    Shuffle &amp; Sort   |</span><br><span class="line">                          +---------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                           +---------------------+</span><br><span class="line">                           |   HDFS Output       |</span><br><span class="line">                           +---------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>MapReduce程序执行过程</strong>：</p><ol><li><p><strong>提交作业</strong>：用户提交MapReduce作业，JobClient与ResourceManager通信，申请资源。</p></li><li><p><strong>资源分配</strong>：ResourceManager分配资源，启动ApplicationMaster。</p></li><li><p><strong>Map阶段</strong>：ApplicationMaster向NodeManager请求启动Map任务，Map任务处理输入数据并生成中间结果。</p></li><li><p><strong>Shuffle阶段</strong>：Map任务完成后，进行数据的shuffle和排序，保证每个Reduce任务处理的数据是同一键的所有值。</p></li><li><p><strong>Reduce阶段</strong>：Reducer处理Map输出的中间结果，完成最终的数据计算。</p></li><li><p><strong>作业完成</strong>：所有任务完成后，ResourceManager会收集任务的状态，标记作业结束。</p><p>总结：YARN架构包括ResourceManager、NodeManager、ApplicationMaster三个主要组件。</p></li></ol><p>ResourceManager负责资源调度，NodeManager负责管理节点资源，ApplicationMaster负责管理每个应用的生命周期。</p><p>MapReduce作业执行时，ApplicationMaster请求资源并启动Map、Shuffle、Reduce任务，NodeManager负责执行具体任务。</p></li></ul><h2 id="4-Hadoop系统要求、安装准备和配置文件介绍">4. <strong>Hadoop系统要求、安装准备和配置文件介绍</strong></h2><ul><li><strong>系统要求</strong>： Hadoop运行在分布式环境下，通常需要多个节点。每个节点至少需要安装Java（推荐使用JDK 8或更高版本）。节点之间需要通过SSH进行通信。</li><li><strong>安装准备</strong>：<ul><li>下载并解压Hadoop发行包。</li><li>配置Java环境变量。</li><li>配置Hadoop配置文件，如<code>core-site.xml</code>、<code>hdfs-site.xml</code>、<code>mapred-site.xml</code>和<code>yarn-site.xml</code>。</li></ul></li><li><strong>配置文件介绍</strong>：<ul><li><code>core-site.xml</code>：配置Hadoop核心服务，如HDFS文件系统的URI。</li><li><code>hdfs-site.xml</code>：配置HDFS的具体设置，如数据存储路径、副本数等。</li><li><code>mapred-site.xml</code>：配置MapReduce作业的相关设置。</li><li><code>yarn-site.xml</code>：配置YARN的资源管理和任务调度。</li></ul></li></ul><h1>大数据概念</h1><h3 id="三次信息浪潮及核心问题：">三次信息浪潮及核心问题：</h3><ol><li><strong>第一次浪潮</strong>：计算机引入，解决了自动化数据处理问题。</li><li><strong>第二次浪潮</strong>：互联网普及，解决了信息传递和共享问题。</li><li><strong>第三次浪潮</strong>：大数据、物联网、云计算兴起，解决了数据存储、处理、分析和价值提取问题。</li></ol><h3 id="大数据4V：">大数据4V：</h3><ol><li><strong>Volume</strong>：数据量大。</li><li><strong>Velocity</strong>：数据生成速度快。</li><li><strong>Variety</strong>：数据种类多。</li><li><strong>Veracity</strong>：数据真实性。</li></ol><h2 id="大数据特点">大数据特点</h2><ol><li><strong>数据量大</strong>：数据规模庞大，通常以TB、PB为单位。</li><li><strong>数据类型繁多</strong>：包括结构化、半结构化和非结构化数据。</li><li><strong>处理速度快</strong>：实时处理或近实时处理数据。</li><li><strong>价值密度低</strong>：数据中的有用信息较少。</li></ol><h3 id="大数据技术层面：">大数据技术层面：</h3><ol><li><strong>数据采集层</strong>：获取原始数据。</li><li><strong>数据存储层</strong>：存储数据，常用HDFS、NoSQL。</li><li><strong>数据处理层</strong>：数据清洗与分析，使用MapReduce、Spark。</li><li><strong>数据分析层</strong>：高级分析与建模，使用机器学习等。</li><li><strong>数据应用层</strong>：业务应用，如推荐系统、预测分析。</li></ol><h3 id="典型计算模式：">典型计算模式：</h3><ol><li><strong>批处理模式</strong>：Hadoop MapReduce。</li><li><strong>流处理模式</strong>：Kafka、Flink。</li><li><strong>混合处理模式</strong>：Spark。</li></ol><h3 id="三者关系：">三者关系：</h3><ul><li><strong>物联网</strong>生成数据。</li><li><strong>大数据</strong>处理、分析数据。</li><li><strong>云计算</strong>提供存储和计算资源。</li></ul><h2 id="云计算的关键：">云计算的关键：</h2><p>包括<strong>虚拟化</strong>、<strong>分布式存储</strong>、<strong>分布式计算</strong>和<strong>多租户</strong>技术。</p><h1>Hadoop</h1><h3 id="Hadoop项目架构图-（画图）">Hadoop项目架构图 （画图）</h3><p><strong>这个感觉必考</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------+</span><br><span class="line">|        Client Application  |</span><br><span class="line">+----------------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------------------------+</span><br><span class="line">|      ResourceManager        |  </span><br><span class="line">+----------------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">|        NodeManager         | &lt;--&gt; |         HDFS            |</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">           |                                 |</span><br><span class="line">           v                                 v</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">|     JobHistoryServer       | &lt;--&gt; |       HDFS NameNode      |</span><br><span class="line">+----------------------------+       +-------------------------+</span><br></pre></td></tr></table></figure><h3 id="Hadoop组件功能：-必考">Hadoop组件功能：(必考)</h3><ol><li><strong>HDFS</strong>：分布式文件系统，存储大数据。</li><li><strong>MapReduce</strong>：处理大规模数据集，基于分布式计算。</li><li><strong>YARN (Yet Another Resource Negotiator)</strong>：资源管理框架，管理集群资源。</li><li><strong>JobHistoryServer</strong>：存储和查看MapReduce任务的历史信息。</li><li><strong>ResourceManager</strong>：负责资源调度和分配。</li><li><strong>NodeManager</strong>：管理单个节点的资源，执行任务。</li><li><strong>Zookeeper</strong>：协调分布式系统中的分布式应用。</li><li><strong>HBase</strong>：一个分布式、可扩展的NoSQL数据库。</li><li><strong>Hive</strong>：基于Hadoop的数据仓库，支持SQL查询。</li><li><strong>Pig</strong>：为大数据处理提供更高层次的抽象，类似SQL。</li><li><strong>Mahout</strong>：机器学习算法库。</li><li><strong>Sqoop</strong>：用于在Hadoop与关系型数据库之间传输数据。</li><li><strong>Flume</strong>：用于数据流的采集、聚合和传输。</li><li><strong>Ambari</strong>：Hadoop集群的管理工具。</li><li><strong>MapReduce</strong>：分布式数据处理框架。</li></ol><h3 id="Hadoop特性：">Hadoop特性：</h3><ol><li><strong>可扩展性</strong>：支持PB级别的数据存储。</li><li><strong>容错性</strong>：数据复制，节点失败时数据不丢失。</li><li><strong>高性能</strong>：支持并行计算，大数据处理效率高。</li><li><strong>经济性</strong>：开源，低成本。</li></ol><h3 id="Hadoop集群节点类型：">Hadoop集群节点类型：</h3><ol><li><p><strong>NameNode</strong>：管理HDFS元数据，负责文件系统的命名和目录管理。</p></li><li><p><strong>DataNode</strong>：存储实际数据，执行数据读取和写入操作。</p></li><li><p><strong>ResourceManager</strong>：管理和调度集群资源。</p></li><li><p><strong>NodeManager</strong>：管理每个节点上的资源和任务执行。</p></li><li><p><strong>JobHistoryServer</strong>：保存MapReduce作业的历史信息。</p><h2 id="Hadoop伪分布式安装过程："><strong>Hadoop伪分布式安装过程</strong>：</h2></li></ol><ul><li><strong>core-site.xml</strong>：配置Hadoop的核心设置，如文件系统、默认的文件路径等。</li><li><strong>hdfs-site.xml</strong>：配置HDFS的设置，如块大小、复制因子、NameNode和DataNode的地址等。</li></ul><h3 id="SecondaryNameNode："><strong>SecondaryNameNode</strong>：</h3><ul><li>解决EditLog过大问题，通过定期合并EditLog和FsImage，减少EditLog大小。</li></ul><h3 id="SecondaryNameNode工作原理：">SecondaryNameNode工作原理：</h3><ol><li><strong>合并过程</strong>：SecondaryNameNode定期检查EditLog文件。如果EditLog有新的内容，它会将EditLog与当前的FsImage合并，并生成一个新的FsImage文件。</li><li><strong>更新FsImage</strong>：合并后，新的FsImage会被传回给NameNode，更新HDFS的元数据。</li><li><strong>清空EditLog</strong>：完成合并后，EditLog文件被清空，防止其过大。</li></ol><h1>Hdfs</h1><h2 id="hdfs结构">hdfs结构</h2><ul><li><strong>块</strong>：大数据文件被切分为多个固定大小的块。</li><li><strong>名称节点（NameNode）</strong>：管理文件系统的元数据。</li><li><strong>数据节点（DataNode）</strong>：实际存储数据块的节点。</li><li><strong>第二名称节点（SecondaryNameNode）</strong>：帮助减轻NameNode的负担，通过定期合并编辑日志来创建文件系统的检查点。</li></ul><h2 id="HDFS冗余数据保存策略："><strong>HDFS冗余数据保存策略</strong>：</h2><p>默认复制因子为3，确保数据冗余存储，避免丢失。</p><ul><li><strong>数据复制策略</strong>：第一个副本存储在写请求发起的DataNode上，第二个副本存储在<strong>不同机架</strong>的DataNode上，第三个副本存储在<strong>另一个机架</strong>的DataNode上。</li></ul><h2 id="HDFS的写数据流程："><strong>HDFS的写数据流程</strong>：</h2><p>采用流水线方式进行数据写入，数据从客户端开始依次写入多个DataNode，直到所有副本都完成写入。</p><h3 id="HDFS读写过程：（画图）（感觉必考）">HDFS读写过程：（画图）（感觉必考）</h3><h4 id="写过程：">写过程：</h4><ol><li>客户端与NameNode通信，获取文件块的存储位置。</li><li>客户端将数据分块，并发送到DataNode。</li><li>DataNode接收数据并存储，同时向客户端确认。</li></ol><p><strong>写过程示意图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client ----&gt; NameNode ----&gt; DataNode1 ----&gt; DataNode2 ----&gt; DataNode3</span><br><span class="line">       获取存储位置            存储数据块            存储数据块           存储数据块</span><br></pre></td></tr></table></figure><h4 id="读过程：">读过程：</h4><ol><li>客户端向NameNode请求文件的块位置。</li><li>NameNode返回文件块的位置信息。</li><li>客户端直接从相应的DataNode读取数据。</li></ol><p><strong>读过程示意图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client ----&gt; NameNode ----&gt; DataNode1 ----&gt; DataNode2</span><br><span class="line">        获取块位置              读取数据                读取数据</span><br></pre></td></tr></table></figure><h3 id="判断文件是否存在（HDFS编程实现）：（编程）">判断文件是否存在（HDFS编程实现）：（编程）</h3><p><strong>这个感觉也会考</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = new Configuration();</span><br><span class="line">FileSystem fs = FileSystem.get(conf);</span><br><span class="line">Path filePath = new Path(&quot;/user/hadoop/hdfsfle.txt&quot;);</span><br><span class="line"></span><br><span class="line">if (fs.exists(filePath)) &#123;</span><br><span class="line">    System.out.println(&quot;File exists.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;File does not exist.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>fs.exists(filePath)</strong>：检查指定路径的文件是否存在。</li></ul><h1>HBase</h1><h3 id="HBase-三级寻址与Region个数计算：（计算）（必考）">HBase 三级寻址与Region个数计算：（计算）（必考）</h3><ol><li></li><li>三级寻址<ul><li><strong>RowKey</strong> → <strong>RegionServer</strong> → <strong>HRegion</strong></li></ul></li><li>Region个数计算<ul><li>初始情况下，HBase有一个默认Region，随着数据增长，Region会自动分裂，Region数目与数据量和Region大小有关。</li><li>计算公式：Region数量=数据总量/每个Region的最大大小</li></ul></li></ol><h3 id="HBase系统架构及组件功能：">HBase系统架构及组件功能：</h3><ol><li><strong>HMaster</strong>：管理RegionServer的调度与分配，负责Region的分裂和负载均衡。</li><li><strong>RegionServer</strong>：处理客户端请求，存储数据。</li><li><strong>Zookeeper</strong>：协调HBase集群的节点，确保一致性和监控。</li><li><strong>HRegion</strong>：存储HBase的数据表分区。</li><li><strong>HBase Client</strong>：与HBase交互的客户端程序，执行读写操作。</li><li><strong>表</strong>：数据存储的基本单元。</li><li><strong>行键</strong>：唯一标识每一行的数据。</li><li><strong>列族</strong>：列的集合。</li><li><strong>列限定符</strong>：列族下的具体列名。</li><li><strong>单元格</strong>：数据存储的位置。</li><li><strong>时间戳</strong>：每个数据的版本标识。</li></ol><h2 id="HBase运行机制："><strong>HBase运行机制</strong>：</h2><ul><li><strong>RegionServe</strong>：处理数据表的分区，负责存储与读写。</li><li><strong>Store</strong>：物理存储的数据结构。</li><li><strong>HLog</strong>：记录所有变更的日志。</li></ul><h3 id="HBase-Shell命令操作：">HBase Shell命令操作：</h3><ol><li><p>创建表</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x27;my_table&#x27;, &#x27;cf1&#x27;, &#x27;cf2&#x27;</span><br></pre></td></tr></table></figure></li><li><p>添加数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put &#x27;my_table&#x27;, &#x27;row1&#x27;, &#x27;cf1:col1&#x27;, &#x27;value1&#x27;</span><br></pre></td></tr></table></figure></li><li><p>浏览数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;my_table&#x27;</span><br></pre></td></tr></table></figure></li><li><p>获得单元格数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#x27;my_table&#x27;, &#x27;row1&#x27;</span><br></pre></td></tr></table></figure></li><li><p>删除表格</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable &#x27;my_table&#x27;</span><br><span class="line">drop &#x27;my_table&#x27;</span><br></pre></td></tr></table></figure></li></ol><h1>Nosql</h1><h3 id="CAP理论的含义：">CAP理论的含义：</h3><ol><li><strong>Consistency</strong>（一致性）：所有节点的数据保持一致。</li><li><strong>Availability</strong>（可用性）：每个请求都会收到响应，不管数据是否最新。</li><li><strong>Partition Tolerance</strong>（分区容错性）：系统在网络分区的情况下仍然能够继续工作。</li></ol><h3 id="处理CAP问题的选择：">处理CAP问题的选择：</h3><ul><li><strong>CP</strong>（一致性 + 分区容错）：如HBase。</li><li><strong>AP</strong>（可用性 + 分区容错）：如Cassandra。</li><li><strong>CA</strong>（一致性 + 可用性）：适用于单机系统，无法容忍分区。</li></ul><p>NoSQL数据库提供灵活的数据模型，适用于大数据场景，相较于传统关系数据库，NoSQL在横向扩展和高并发上有优势。</p><h3 id="NoSQL数据库的四大类型：">NoSQL数据库的四大类型：</h3><ol><li><p>键值存储（Key-Value Stores）</p><p>：存储数据以键值对的形式，如Redis。</p><ul><li><strong>特征</strong>：高效查询、可扩展性强，适合存储简单的数据。</li></ul></li><li><p>列族存储（Column-Family Stores）</p><p>：数据按列存储，如HBase、Cassandra。</p><ul><li><strong>特征</strong>：适合高吞吐量、高并发的场景，存储稀疏数据。</li></ul></li><li><p>文档存储（Document Stores）</p><p>：数据以JSON、XML等文档格式存储，如MongoDB。</p><ul><li><strong>特征</strong>：适合存储复杂的结构化数据，灵活性高。</li></ul></li><li><p>图数据库（Graph Databases）</p><p>：用于存储图结构数据，如Neo4j。</p><ul><li><strong>特征</strong>：适合复杂的关系数据，查询效率高。</li></ul></li></ol><h2 id="BASE理论："><strong>BASE理论</strong>：</h2><ul><li><strong>基本可用</strong>：部分系统可用。</li><li><strong>软状态</strong>：系统状态可能暂时不一致。</li><li><strong>最终一致性</strong>：系统最终会达到一致状态。</li></ul><h1>MyReduce</h1><h3 id="MapReduce体系架构图-画图-感觉必考哈">MapReduce体系架构图(画图)感觉必考哈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       +-------------------+</span><br><span class="line">       |   Client          |</span><br><span class="line">       +-------------------+</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">       +-------------------+</span><br><span class="line">       |   JobTracker      |     (Resource Management)</span><br><span class="line">       +-------------------+</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">+--------------------------+  +--------------------------+</span><br><span class="line">|   TaskTracker (Map Task)  |  |   TaskTracker (Reduce Task)|</span><br><span class="line">+--------------------------+  +--------------------------+</span><br><span class="line">                |                       |</span><br><span class="line">                v                       v</span><br><span class="line">        +-------------------+    +-------------------+</span><br><span class="line">        |   HDFS Storage    |    |   HDFS Storage    |</span><br><span class="line">        +-------------------+    +-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MapReduce流程：">MapReduce流程：</h3><ol><li><strong>Map端</strong>：输入数据（如文件）被切分成多个块，分配给不同的Map任务处理。</li><li><strong>Shuffle过程</strong>：Map任务的输出会根据键进行分组，并被传输到相应的Reduce任务。</li><li><strong>Reduce端</strong>：根据分组的键，Reduce任务聚合数据，输出最终结果。</li></ol><h3 id="MapReduce实现两个数据库表的自然连接：">MapReduce实现两个数据库表的自然连接：</h3><ol><li><strong>Map端</strong>：将两个表的数据按主键进行映射。</li><li><strong>Reduce端</strong>：对相同主键的数据进行连接。</li></ol><h3 id="MapReduce实现WordCount：（编程）">MapReduce实现WordCount：（编程）</h3><ol><li><p><strong>Map函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String[] words = value.toString().split(&quot;\\s+&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            context.write(new Text(word), new IntWritable(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Reduce函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">    public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (IntWritable val : values) &#123;</span><br><span class="line">            sum += val.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, new IntWritable(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>简短总结：</p><ul><li><strong>MapReduce架构</strong>：分为Map任务、Shuffle过程、Reduce任务。</li><li><strong>连接过程</strong>：Map端根据主键映射，Reduce端进行连接。</li><li><strong>WordCount</strong>：Map函数分词计数，Reduce函数汇总计数。</li></ul><h1>Storm</h1><h3 id="Storm中的各个组件及功能：">Storm中的各个组件及功能：</h3><ol><li><strong>Topology</strong>：整个Storm应用，包含所有的spouts和bolts。</li><li><strong>Spout</strong>：数据源，负责向Storm系统发送原始数据。</li><li><strong>Bolt</strong>：处理数据的单元，接收数据并进行处理后输出。</li><li><strong>Nimbus</strong>：集群的主控节点，负责任务调度、分配。</li><li><strong>Supervisors</strong>：工作节点，负责运行bolts和spouts。</li></ol><h3 id="Storm的工作流程：">Storm的工作流程：</h3><ol><li>Spout从外部系统读取数据。</li><li>数据经过Bolt处理。</li><li>数据通过Storm集群进行分发和处理。</li></ol><h3 id="Storm的特点：">Storm的特点：</h3><ul><li><strong>实时性</strong>：低延迟处理。</li><li><strong>可扩展性</strong>：能够处理大规模数据流。</li><li><strong>容错性</strong>：自动处理失败任务，保证数据处理完整。</li></ul><h3 id="编写Storm代码示例（Topology-Bolt）：">编写Storm代码示例（Topology &amp; Bolt）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyBolt extends BaseBasicBolt &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Tuple input, BasicOutputCollector collector) &#123;</span><br><span class="line">        String word = input.getStringByField(&quot;word&quot;);</span><br><span class="line">        collector.emit(new Values(word, 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTopology &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TopologyBuilder builder = new TopologyBuilder();</span><br><span class="line">        builder.setSpout(&quot;spout&quot;, new MySpout(), 1);</span><br><span class="line">        builder.setBolt(&quot;bolt&quot;, new MyBolt(), 1).shuffleGrouping(&quot;spout&quot;);</span><br><span class="line"></span><br><span class="line">        Config conf = new Config();</span><br><span class="line">        StormSubmitter.submitTopology(&quot;my-topology&quot;, conf, builder.createTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Spark</h1><h3 id="Spark-Streaming和Storm的区别：感觉必考哈">Spark Streaming和Storm的区别：感觉必考哈</h3><ul><li><strong>实时性</strong>：Storm是基于流的实时处理，适合低延迟需求；Spark Streaming是基于微批处理，延迟相对较高。</li><li><strong>容错</strong>：Storm具有内建的容错机制，Spark Streaming通过checkpoint机制。</li><li><strong>架构</strong>：Storm的架构较为简洁，直接处理数据流，Spark Streaming依赖于Spark的批处理架构，支持复杂操作。</li></ul><h3 id="Spark中RDD的理解和运用：">Spark中RDD的理解和运用：</h3><ul><li><p><strong>RDD（Resilient Distributed Dataset）</strong>：分布式数据集，Spark的核心抽象，支持并行计算、容错和分布式存储。</p></li><li><p>RDD的操作</p><p>：</p><ul><li><strong>转换操作</strong>：如<code>map</code>、<code>filter</code>、<code>flatMap</code>，懒执行。</li><li><strong>行动操作</strong>：如<code>collect</code>、<code>count</code>、<code>reduce</code>，触发实际计算。</li></ul><p>区别</p><p>：转换操作会返回新的RDD，行动操作会触发实际的计算和结果返回。</p></li></ul><h3 id="窄依赖和宽依赖的区别：">窄依赖和宽依赖的区别：</h3><ul><li><strong>窄依赖</strong>：每个父RDD的分区对应着子RDD的一个分区（如<code>map</code>、<code>filter</code>）。</li><li><strong>宽依赖</strong>：父RDD的一个分区可能会对应子RDD的多个分区（如<code>groupByKey</code>、<code>reduceByKey</code>）。</li></ul><h3 id="如何进行stage划分：">如何进行stage划分：</h3><ul><li>根据<strong>宽依赖</strong>进行Stage划分，不同Stage之间的数据需要shuffle操作（如<code>groupByKey</code>）。</li><li>每个Stage的操作会在同一节点内部进行，不需要跨节点的数据传输。</li></ul><h3 id="park-shell命令解读：">park shell命令解读：</h3><ul><li><code>spark-shell</code>：启动Spark交互式shell。</li><li><code>sc.textFile(&quot;path&quot;)</code>：加载文本文件。</li><li><code>rdd.map(func)</code>：对每个元素应用<code>func</code>。</li><li><code>rdd.collect()</code>：获取RDD的所有数据。</li><li><code>rdd.reduce(func)</code>：对RDD数据进行聚合。</li></ul><h3 id="Spark编程实现统计字符个数：">Spark编程实现统计字符个数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val textFile = sc.textFile(&quot;path/to/file.txt&quot;)</span><br><span class="line">val charCount = textFile.flatMap(line =&gt; line.split(&quot;&quot;)).map(char =&gt; (char, 1)).reduceByKey(_ + _)</span><br><span class="line">charCount.collect().foreach(println)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>RDD</strong>：Spark的核心数据结构，支持转换和行动操作。</li><li><strong>窄/宽依赖</strong>：窄依赖跨分区小，宽依赖跨分区大。</li><li><strong>Stage划分</strong>：宽依赖会引起Stage划分</li></ul><h1>概念</h1><h3 id="可视化的基本概念：">可视化的基本概念：</h3><ul><li><strong>数据可视化</strong>：通过图形、图表、地图等方式呈现数据，帮助理解、分析和展示数据。</li><li><strong>目的</strong>：将复杂的数据转化为易于理解的形式，揭示数据中的模式、趋势和关系。</li><li>类型：<ul><li><strong>静态可视化</strong>：如条形图、折线图、饼图等。</li><li><strong>动态可视化</strong>：交互式图表，能够实时更新数据。</li></ul></li><li><strong>常用工具</strong>：如Tableau、Power BI、D3.js等。</li></ul><p>简短总结： 数据可视化通过图形化展示数据，帮助更直观地理解信息。</p><h3 id="基于商品和基于用户的协同过滤算法：">基于商品和基于用户的协同过滤算法：</h3><ol><li><p><strong>基于商品的协同过滤（Item-based CF）</strong>：</p><ul><li><p><strong>原理</strong>：根据用户对商品的评分，找到相似商品并推荐给用户。</p></li><li><p>步骤</p><p>：</p><ul><li>计算商品之间的相似度（如余弦相似度）。</li><li>根据用户历史评分，推荐相似商品。</li></ul></li><li><p><strong>优点</strong>：相对稳定，推荐的商品相似度较高。</p></li><li><p><strong>缺点</strong>：冷启动问题（新商品推荐困难）。</p></li></ul></li><li><p><strong>基于用户的协同过滤（User-based CF）</strong>：</p><ul><li><p><strong>原理</strong>：根据用户之间的相似度，推荐其他相似用户喜欢的商品。</p></li><li><p>步骤</p><p>：</p><ul><li>计算用户之间的相似度。</li><li>根据相似用户的评分，推荐商品。</li></ul></li><li><p><strong>优点</strong>：个性化较强，易于理解。</p></li><li><p><strong>缺点</strong>：计算复杂度高，冷启动问题。</p></li></ul></li></ol><h3 id="Pregel求最大值-最小值计算过程：（画图）">Pregel求最大值/最小值计算过程：（画图）</h3><ol><li><p><strong>基本思想</strong>：Pregel通过“顶点”的消息传递来处理大规模图数据，适用于图计算任务，如最大值/最小值计算。</p></li><li><p><strong>计算过程</strong>：</p><ul><li><strong>初始化</strong>：每个顶点初始化为其自身的值（最大值或最小值）。</li><li><strong>迭代</strong>：每个顶点将其当前值传递给相邻的顶点。每个接收到消息的顶点更新自己的值为当前值和收到的值中的最大值或最小值。</li><li><strong>终止条件</strong>：当图中所有顶点的值不再发生变化时，算法结束。</li></ul><p><strong>图示说明</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C</span><br><span class="line"> /     \</span><br><span class="line">D       E</span><br></pre></td></tr></table></figure><p>初始状态：顶点A、B、C、D、E的值分别为其初始值。通过迭代传递消息，直到最大值或最小值稳定。</p></li></ol><h3 id="迪杰斯特拉算法求解单源最短路径问题：">迪杰斯特拉算法求解单源最短路径问题：</h3><ol><li><strong>基本思想</strong>：从源顶点出发，逐步更新每个顶点的最短路径值，直到所有顶点的最短路径值确定。</li><li><strong>算法步骤</strong>：<ul><li><strong>初始化</strong>：将源顶点的最短路径值设为0，其余顶点设为无穷大。</li><li><strong>选择最短路径</strong>：选择尚未确定最短路径的顶点中最短的一个，更新其相邻顶点的最短路径。</li><li><strong>迭代</strong>：重复选择顶点并更新路径，直到所有顶点的最短路径确定。</li></ul></li></ol><h3 id="利用Pregel实现单源最短路径计算过程：">利用Pregel实现单源最短路径计算过程：</h3><ol><li><p><strong>初始化</strong>：</p><ul><li>源顶点的最短路径为0，其他顶点初始化为无穷大。</li></ul></li><li><p><strong>消息传递</strong>：</p><ul><li>每个顶点将其当前最短路径值传递给相邻的顶点。</li><li>接收到消息的顶点更新最短路径值，取当前值和从邻居收到的值的较小值。</li></ul></li><li><p><strong>迭代</strong>：</p><ul><li>继续进行消息传递，直到最短路径值不再变化。</li></ul></li><li><p><strong>计算过程</strong>（表格形式）：</p><table><thead><tr><th>顶点</th><th>当前最短路径值</th><th>邻居</th><th>接收到的消息</th><th>更新后的最短路径值</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>B, D</td><td>∞, ∞</td><td>0</td></tr><tr><td>B</td><td>∞</td><td>A, C</td><td>0, ∞</td><td>1</td></tr><tr><td>C</td><td>∞</td><td>B, E</td><td>1, ∞</td><td>2</td></tr><tr><td>D</td><td>∞</td><td>A, E</td><td>0, ∞</td><td>1</td></tr><tr><td>E</td><td>∞</td><td>C, D</td><td>2, 1</td><td>2</td></tr></tbody></table></li><li><p><strong>终止条件</strong>：当所有顶点的最短路径值稳定，算法结束。</p></li></ol><h1>Hive</h1><h3 id="Hive中SQL语句转换成MapReduce的基本原理：">Hive中SQL语句转换成MapReduce的基本原理：</h3><ul><li><p><strong>原理</strong>：Hive使用HiveQL语言查询数据，查询语句会被转换为一系列的MapReduce任务。<strong>Hive的查询处理器将SQL解析为一个逻辑执行计划，然后通过优化转换成物理执行计划（MapReduce作业）。</strong></p></li><li><p>过程</p><p>：</p><ol><li><strong>解析</strong>：HiveQL语句被解析成抽象语法树（AST）。</li><li><strong>优化</strong>：对AST进行优化，去除冗余操作。</li><li><strong>生成MapReduce作业</strong>：根据查询逻辑生成MapReduce作业，并执行。</li></ol></li></ul><h3 id="Hive中SQL查询转换成MapReduce作业的过程：">Hive中SQL查询转换成MapReduce作业的过程：</h3><ol><li><p>SQL查询</p><p>：例如查询表中某字段的总和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT SUM(amount) FROM transactions;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析阶段</strong>：Hive将此SQL语句转换为一个抽象的查询计划。</p></li><li><p><strong>优化阶段</strong>：Hive进行查询优化，合并某些操作。</p></li><li><p><strong>生成MapReduce作业</strong>：Hive将最终的查询计划转化为MapReduce作业。Map任务执行数据扫描，Reduce任务聚合计算结果。</p></li><li><p><strong>执行</strong>：Hive提交MapReduce作业到Hadoop集群执行。</p></li></ol><h3 id="Hive中Shell环境下常用操作代码：">Hive中Shell环境下常用操作代码：</h3><p><strong>就是Mysql的语法</strong></p><ol><li><p><strong>创建数据库</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE DATABASE mydb;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT,</span><br><span class="line">    name STRING,</span><br><span class="line">    salary DOUBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE employees ADD COLUMNS (address STRING);</span><br></pre></td></tr></table></figure></li><li><p><strong>查看表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure></li><li><p><strong>描述表结构</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DESCRIBE employees;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入数据</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO TABLE employees VALUES (1, &#x27;John&#x27;, 5000.0);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;p&gt;大数据的四个特点：数据量大，数据类型繁多，处理速度快和价值密度低。&lt;/p&gt;
&lt;p&gt;大数据对科学研究的影响：&lt;/p&gt;
&lt;p&gt;第一种范式：实验科学， 第二种范式：理论科学，第三种范式：计算科学，第</summary>
        
      
    
    
    
    <category term="java" scheme="https://mengnankk.asia/categories/java/"/>
    
    
    <category term="java" scheme="https://mengnankk.asia/tags/java/"/>
    
    <category term="Hadoop" scheme="https://mengnankk.asia/tags/Hadoop/"/>
    
    <category term="BigData" scheme="https://mengnankk.asia/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>English十二月篇</title>
    <link href="https://mengnankk.asia/2024/12/01/en4/"/>
    <id>https://mengnankk.asia/2024/12/01/en4/</id>
    <published>2024-11-30T16:00:00.000Z</published>
    <updated>2024-12-15T08:55:49.720Z</updated>
    
    <content type="html"><![CDATA[<h1>每日一话+单词遗忘表12.1</h1><p>Working hard is important, but there is something that matters even more: believing in yourself</p><ul><li>forest 森林</li><li>forge 熔炉</li><li>explore 探寻</li><li>formal 正式的</li><li>former 从前的</li><li><strong>formula</strong> 公式</li><li><strong>formulate</strong> 构想出</li><li>forth 向前</li><li>forthcoming 即将到来的</li><li>fortune 运气</li><li>forum 论坛</li><li>fossil 化石</li><li>fountain 喷泉</li><li>fraction 小部分</li><li>fragment 碎片</li><li>frame 构架</li><li>explicit 详细的</li></ul><h1>每日一话+单词遗忘表12.2</h1><p>A man may well bring a horse to the water, but he cannot make him drink.</p><ul><li>freight 运送</li><li>contempt 轻蔑</li><li>frog 青蛙</li><li><strong>frontier</strong> 边境</li><li>frost 结霜</li><li><strong>frustrate</strong> 挫败</li><li>fry 油炸</li><li>fuel 燃料</li><li>fulfil 履行</li><li>fulfill 履行实践</li><li>fundamental 基本的</li><li>contrary 相反的</li><li>funeral 葬礼</li><li>fur 皮毛</li><li>furnace 火炉</li></ul><h1>每日一话+单词遗忘表12.3</h1><p>Mistakes are an essential part of education.</p><ul><li>furnish 提供</li><li>furniture 家具</li><li>furthermore 而且</li><li>fuss 小题大作</li><li>gadget 小玩意</li><li>gallery 走廊</li><li>gamble 赌博</li><li>gang 一伙</li><li>gap 缺口</li><li>garage 车库</li><li>frustrate 阻止</li><li>garden 花园</li><li><strong>garment</strong> 衣服</li><li>gasoline 汽油</li><li>gaze 注视</li><li>gear 齿轮</li><li>gene 基因</li></ul><h1>每日一话+单词遗忘表12.4</h1><p>A man never discloses his own character so clearly as when he describes another’s.</p><ul><li>generous 慷慨的</li><li>genius 天才</li><li>gentle 温和的</li><li>genuine 真实的</li><li>germ 细菌</li><li>gesture 姿态</li><li>ghost 鬼</li><li><strong>giant</strong> 巨人</li><li>glance 一瞥</li><li><strong>glimpse</strong> 一瞥</li><li>glory 光荣的</li><li>glow 发热</li><li></li></ul><h1>每日一话+单词遗忘表12.5</h1><p>I think probably kindness is my number one attribute in a human being. I’ll put it before any of the things like courage or bravery or generosity or anything else.</p><ul><li>goodness 善良</li><li>goods商品</li><li><strong>gorgeous</strong> 华丽的</li><li>gossip 随笔</li><li>govern 统治</li><li>gown 长袍</li><li>gradual 逐渐的</li><li><strong>grain</strong> 粮食</li><li>gram 克</li><li>gramme 克</li><li>grant 授予</li><li><strong>grasp</strong> 抓住</li><li>gloom 悲伤的</li></ul><h1>每日一话+单词遗忘表12.6</h1><p>Snowflakes are one of nature’s most fragile things, but just look what they can do when they stick together.</p><ul><li>grave 严肃的</li><li>gravitation吸引力</li><li>gravity 重力</li><li>gray 灰色的</li><li><strong>greet</strong> 欢迎</li><li><strong>grief</strong> 悲伤</li><li>grin 笑</li><li><strong>grind</strong> 磨碎</li><li>grip 紧握</li><li>gross 总共的</li><li>guarantee 保证</li><li>guard 警戒</li><li><strong>guilt</strong> 内疚</li><li>guitar 吉他</li><li>gulf 海湾</li><li>gum 树胶</li></ul><h1>每日一话+单词遗忘表12.7</h1><p>When obstacles arise, you change your direction to reach your goal; you do not change your decision to get there.</p><ul><li><strong>gut</strong> 内脏内情</li><li>hack 砍出租</li><li>guy 男人</li><li>gymnasium 健身房</li><li>hail 招呼</li><li>hall 走廊</li><li><strong>halt</strong> 停止</li><li>ham 火腿</li><li>hammer 敲打</li><li>handicap 障碍</li><li>handle 把手</li><li>gum 牙龈</li><li>harbor 海港</li><li>harbour 藏匿</li><li>hardship 困苦的</li></ul><h1>每日一话+单词遗忘表12.8</h1><p>If one cannot enjoy reading a book over and over again, there is no use in reading it at all.</p><ul><li><strong>hardware</strong> 计算机硬件</li><li>harmony 协调</li><li>harness 马具</li><li>harsh 粗糙</li><li>harvest 收获</li><li>halt 停止</li><li>haste 匆忙</li><li>hatch 孵化</li><li>haul 拖拉</li><li>haunt 经常出没</li><li>hazard 冒险，危险</li><li>haze 疑惑，雾霾</li></ul><h1>每日一话+单词遗忘表12.9</h1><p>Anyone who conducts an argument by appealing to authority is not using his intelligence; he is just using his memory.</p><ul><li>heaven 天堂</li><li>hectare 公顷</li><li>hedge 避免正面回答</li><li>helicopter 直升机</li><li>hell 地狱</li><li>hence 因此</li><li><strong>heritage</strong> 遗产</li><li>hesitate 犹豫</li><li>hijack 抢劫</li></ul><h1>每日一话+单词遗忘表12.10</h1><p>The most efficient way to live reasonably is every morning to make a plan of one’s day and every night to examine the results obtained.</p><ul><li>hill 小山丘</li><li>hinder 阻碍</li><li><strong>hint</strong> 暗示</li><li>hip 臀部</li><li>hollow 空的</li><li>holy 神圣的</li><li>homeland 祖国</li><li>homosexual 同性恋的</li><li>honest 诚实的</li><li>horror 惊骇</li></ul><h1>每日一话+单词遗忘表12.11</h1><p>Heaven has made us talents, we’re not made in vain. A thousand gold coins spent, more will turn up again.</p><ul><li>horsepower 马力</li><li>hospitable 好客的</li><li>hotdog 卖弄</li><li>hammer 敲打</li><li>humble 谦逊的</li><li>humor 幽默的</li><li>hundred 一百</li></ul><p>题目词汇：</p><ul><li>renovate 修复</li><li>deserted 荒芜的</li><li>desperate 绝望的</li><li>interaction 合作活动</li><li>fulfilled 履行</li><li>embrace 拥护</li><li>contradictory 矛盾的</li><li>detailed 详细的</li><li>dipping 蘸</li><li>distinction 区别</li><li>involves 包含</li><li>moderate 中等的</li><li>vigorous 强有力的</li><li>notifiled 通知的</li><li>falling 下降的</li><li>optimum 最佳选择</li><li>constitutes 由…组成</li><li>prisoner 监狱</li></ul><h1>每日一话+单词遗忘表12.12</h1><p>Regret is an appalling waste of energy. You can’t build on it. It’s only good for wallowing in.</p><ul><li>hyphen 连字号</li><li>ill 坏的</li><li>illusion 幻觉</li><li>illustrate 说明</li><li>imitate 模仿</li><li>immediate 立即的</li><li><strong>immense</strong> 巨大的</li><li>immigrate 移入</li><li>immune 免疫</li><li>impatient 不耐烦的</li><li>imperial 皇帝的</li><li>implement 使生效</li><li><strong>implicit</strong> 盲目的</li></ul><h1>每日一话+单词遗忘表12.13</h1><ul><li>impose 强加</li><li><strong>impulse</strong> 冲动</li><li>incentive 刺激的</li><li>incidence 发生率</li><li>incident 事件</li><li>incline 倾斜</li><li>income 收入</li><li>indeed 真正的</li><li>industry 工业</li><li><strong>infant</strong> 未成年的</li></ul><h1>四级高频词汇</h1><ul><li>resident 居民</li><li>direction 方向</li><li>sheet 床单一张纸</li><li>correspond 符合</li><li>accounted  解释</li><li>counterprouductive 适得其反</li><li>translate 转化</li><li>varous measures 多种举措</li><li>rational nutrition 合理的营养</li><li>vigorous 强有力的</li><li><strong>circumstance</strong> 环境</li><li>resume 简历</li><li>total 总计</li><li>identify 鉴定</li><li>digital 数码的</li><li>rate 速度，价格</li><li>feature 特征</li><li>individual 个人的</li><li>academic 学院的</li><li>obesity 肥胖的</li><li>recession 经济衰退的</li><li>regulation 章程</li><li>relsease 发布</li><li>pose 引起</li><li>compound 合成物</li><li>occasion 场合</li><li>derive 起源</li><li>divorce 离婚</li><li>association 协会</li><li>potential 潜在的</li><li>participate 参加</li><li>motivate 激发</li><li><strong>ingredient</strong> 成分</li><li>previous 先前的</li><li>boost 提高</li><li>emission 排放</li><li>document 文件</li><li>excellent 优秀的</li><li>budget 预算</li><li>commercial 贸易的</li><li>secretary 秘书</li><li>alternative 可供选择的</li><li>ultimately 最终</li><li>tobacco 烟草</li><li>revolution 革命</li><li>appetite 食欲</li><li>princiiple 原则</li><li>suspect 嫌疑犯</li><li>spouse 配偶</li><li>prospect 前景</li><li>pursue 追求</li><li>corporate 团体的</li><li>journal 日志</li><li>contract 合同</li><li>penalty 惩罚</li><li>perception 感知</li><li>vulnerable 脆弱的</li><li>conference 大型会议</li><li>restrict 限制</li><li>portion 部分</li><li>sustain 支撑</li><li>estate 庄园</li><li><strong>grasffti</strong> 涂鸦</li><li><strong>perspective</strong> 观点</li><li><strong>elementary</strong> 初级的</li><li>revenue 税收</li><li>interity 完整</li><li>margin 边缘的</li><li>tunnel 隧道</li><li>nurition 营养</li><li>counterpart 对应的人</li><li>heritage 遗产</li><li>suffcient 足够的</li><li>interpret 口译</li><li>institute 学院</li><li>demonstrate 展示</li><li>dramatic 戏剧性的</li><li>fulfill 履行</li><li>episode 一集</li><li>density 密度</li><li>cognitive 认知的</li><li>disorder 混乱的</li><li>relieve 减轻</li><li>negotiate 谈判</li><li>pediatrician 儿科医生</li><li>gadget 小物件</li><li>marvelous 极好的</li><li><strong>contaminat</strong>e 污染</li><li>restict 限制</li></ul><h1>单词遗忘表+每日一话12.14</h1><p>Water is a pioneer which the settler follows, taking advantage of its improvements.</p><ul><li>infer 推断</li><li>inferior 下级</li><li>infinite 无线的</li><li><strong>inflate</strong> 使充气</li><li>influenza 流行性感冒</li><li>ingredient 配料</li><li>inherit 继承</li><li>initial 最初的</li><li><strong>ink</strong> 墨水</li><li>impose 欺骗</li><li>innocent 无罪的</li><li><strong>inquiry</strong> 调查</li><li>insane 精神病的</li><li>infant 婴儿</li></ul><h1>单词遗忘表+每日一话12.15</h1><p>There is no greater agony than bearing an untold story inside you.</p><ul><li>instant 立即的</li><li>instead 反而</li><li>instinct 本能</li><li>institute 建立</li><li>instrument 仪器</li><li><strong>insult</strong> 侮辱</li><li>inferior 下级的</li><li><strong>intact</strong> 原装的</li><li>intangible 难以捉摸的</li><li><strong>integrity</strong> 正直</li><li>intellectual 智力的</li><li>haul 拖拉</li><li>intense 紧张的</li><li>interfere 干预</li><li>interior 内部的</li><li></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;每日一话+单词遗忘表12.1&lt;/h1&gt;
&lt;p&gt;Working hard is important, but there is something that matters even more: believing in</summary>
        
      
    
    
    
    <category term="English" scheme="https://mengnankk.asia/categories/English/"/>
    
    
    <category term="English" scheme="https://mengnankk.asia/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>Linux编程基础期末复习</title>
    <link href="https://mengnankk.asia/2024/11/25/linux11/"/>
    <id>https://mengnankk.asia/2024/11/25/linux11/</id>
    <published>2024-11-24T16:00:00.000Z</published>
    <updated>2024-12-02T10:07:11.838Z</updated>
    
    <content type="html"><![CDATA[<h1>真题在现</h1><h2 id="概述题">概述题</h2><p>1、简述 GNU、GPL 的含义，及其对 Linux 的影响。</p><p>GNU 计划开始于 1984 年 1 月。其创始人是理查德•马修•斯托曼（Richard Matthew<br>Stallman）。“GNU”是“GNU’s Not UNIX”的递归首字母缩写词。“GNU”的发音为 g’noo。<br>GNU 计划的目的是开发一个完全类似于 UNIX 的免费操作系统。其内核 Hurd 的开发工作始于<br>1990 年，但是至今尚未成熟。GNU 计划代表性的产品包括 GCC、Emacs、Bash Shell、GLIBC<br>等，这些都在 Linux 中被广泛使用。（3 分）<br>GPL（GNU General Public License，GNU 通用公共许可证）于 1985 年被提出。GPL 试<br>图保证您共享和修改自由软件的自由。GPL 适用于大多数自由软件基金会的软件。GNU 计划<br>一共提出了 3 个协议条款：GPL，LGPL（GNU Lesser General Public License，GNU 较宽松<br>公共许可证），GFDL（GNU Free Documentation License，GNU 自由文档许可证）。（4 分）</p><p><strong>这个题真就是概念的问题，真的很难记</strong></p><p>2.简述进程状态及其转换。</p><p>运行（running）态：进程占有处理器正在运行。<br>就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行。<br>等待（wait）态：又称为阻塞（blocked）态或睡眠（sleep）态，指进程不具备运行条件，正<br>在等待某个事件的完成。（4 分）</p><p>还要画个图</p><p><strong>wait状态可以变成ready状态，然后再变成running状态，或者是由running状态转换成wait或者ready状态</strong></p><p>3、Linux 目录结构与 Windows 有何不同？</p><p>(1). Linux 中文件名是区分大小写的，所有的 UNIX 系列操作系统都遵循这个规则。（2<br>分）<br>(2). Linux 文件通常没有扩展名。给 Linux 文件设置扩展名通常是为了方便用户使用。<br>Linux 文件的扩展名和它的种类没有任何关系。例如，zp.exe 可以是文本文件，而 zp.txt<br>也可以是可执行文件。（2 分）<br>2<br>(3). Linux 中没有盘符的概念（如 Windows 下的 C 盘）。Linux 的目录结构为树状结构，<br>顶级的目录为根目录“/”。其他目录通过挂载可以将它们添加到目录树中。例如，对于文件<br>zp.txt，它在 Linux 中的绝对路径可能是/home/john/zp.txt，而在 Windows 中的绝对路径<br>可能是 E:\document\zp.txt。（3 分）</p><p>4.用户账户的配置文件有哪些？它们各自用途如何？（7 分）<br>参考答案：<br>用户账户管理主要涉及 passwd 和 shadow 两个配置文件（3 分）。<br>passwd 是系统识别用户的一个重要文件，Linux 操作系统中所有的用户都记录在该文件<br>中（2 分）。<br>文件 shadow 是文件 passwd 的影子文件。主要保存用户密码配置情况（2 分）。</p><p>5.若使用 rmdir 命令来删除某个目录，但无法成功，请说明可能的原因。（7 分）</p><p>此目录可能不存在，（2 分）<br>或者目录不为空，（2 分）<br>或者目录中有隐含文件存在，（1 分）<br>或者目录被设置了权限，（1 分）<br>解决方法就是先修改权限，在使用 rm -r 命令删除。（1 分）</p><p><strong>桀桀桀，或者是直接rm -rf直接强制删除，管他啥呢</strong></p><h2 id="实操题">实操题</h2><p>1、 完成以下进程管理操作（5 分）<br>（1）用 vi 编辑 test.txt 文件，然后使用 ctrl+z 将其挂起。<br>（2）查看当前进程的状态。<br>（3）将 test.txt 进程（假设进程 pid 为 36357）的优先级设置为 8，再终止该进程。<br>（4）查看 CPU 和内存的使用情况和进程状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt ctrl+z</span><br><span class="line">ps -l</span><br><span class="line">renice 8 pid</span><br><span class="line">kill -9 pid</span><br><span class="line">top</span><br></pre></td></tr></table></figure><p>2、当前用户为管理员，且在根目录下，完成以下文件和目录操作（5 分）<br>（1）在/mnt 目录下创建三个文件夹，dir1、dir2、dir3，并查看是否创建成功；<br>（2）在 dir1 文件夹内创建 <a href="http://test.sh">test.sh</a> 文件，并查看是否创建成功；<br>（3）将/mnt/dir1 下 <a href="http://test.sh">test.sh</a> 文件复制到 dir2 目录下，复制后的新文件名为 <a href="http://newtest.sh">newtest.sh</a>,并查看<br>是否复制成功；<br>（4）给文件 <a href="http://newtest.sh">newtest.sh</a> 添加可执行权限。<br>（5）删除文件 <a href="http://newtest.sh">newtest.sh</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/dir&#123;1..3&#125;</span><br><span class="line">ls /mnt</span><br><span class="line">touch /mnt/dir1/test.sh</span><br><span class="line">ls /mnt/dir1</span><br><span class="line">cp /mnt/dir1/test.sh /mnt/dir2/newtest.sh</span><br><span class="line">ls /mnt/dir2</span><br><span class="line">chmod 700 /mnt/dir2/newtest.sh</span><br><span class="line">rm -rf /mnt/dir2/newtest.sh</span><br></pre></td></tr></table></figure><p>3、请写出以下操作的完整指令（包括命令选项及参数）：假设你是系统管理员，需要增加一<br>个新的用户账号 Jack，为新用户设置初始密码，锁定用户账号 Jerry，并删除用户账号 Kate。<br>（5 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd Jack</span><br><span class="line">passwd Jack</span><br><span class="line">passwd -1 Jack</span><br><span class="line">usedel Jack</span><br></pre></td></tr></table></figure><p>4 、执行命令 ls -1 时，某行显示如下:<br>-rw-r–r-- 1 teacher teacher 744 3 月 18 11:58 studentdata<br>(1)用户 teacher 对该文件具有什么权限?<br>(2)执行命令 useradd student 后，用户 student 对该文件具有什么权限?<br>(3)如何使任何用户都可以读写执行该文件?<br>(4)如何把该文件所有者改为用户 root ?<br>（5 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">读写</span><br><span class="line"></span><br><span class="line">只读</span><br><span class="line">chmod 777 stduentdata</span><br><span class="line">chown root studentdata</span><br></pre></td></tr></table></figure><p>5、叙述 Linux 虚拟机如何增加一块硬盘（设备名为/dev/sdb，文件系统格式 ext4)，如何<br>实现开机自动挂载硬盘。写出详细的步骤和相关命令。（10 分）<br>参考答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先虚拟机新建一块硬盘</span><br><span class="line">分区fdisk /dev/sdb</span><br><span class="line">格式化 mkfs -t ext4 /dev/sdb1</span><br><span class="line">挂载挂载， 先创建一个/home/newdisk,挂载 mount /dev/sdb1 /home/newdisk </span><br><span class="line">然后设置自动挂载</span><br><span class="line">设置自动挂载，打开/etc/fstab 添加一行 </span><br><span class="line">/dev/sdb1 /home/newdisk ext4 defaults 0 0 </span><br></pre></td></tr></table></figure><h2 id="编程题">编程题</h2><p>1.创建一个 shell 脚本，它从用户那里接收 20 个数，并显示已输入的最小的数。（10 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">min=2147483647</span><br><span class="line">for((count=0;count&lt;20;count=count+1))</span><br><span class="line">do</span><br><span class="line">echo -n &quot;输入数字:&quot;</span><br><span class="line">read value</span><br><span class="line">if [ $min -gt $value ]</span><br><span class="line">then</span><br><span class="line">min=$value</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol start="2"><li>编写 shell 脚本程序来分析某班某一课程平均成绩，从键盘输入若干个考试分数（分数为<br>整数），计算并输出所有分数的平均值。要求如下：<br>（1）使用 while 或 until 循环实现整数输入，如果输入为字符 q，则退出键盘输入；<br>（2）如果输入分数不在 0—100 范围内，提示用户输入有误；<br>（3）平均值计算不需要考虑小数部分，只需要得到整数部分即可。<br>（10 分）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">sum=0</span><br><span class="line">count=0</span><br><span class="line">while true;</span><br><span class="line">do</span><br><span class="line">read -p &quot;输入一个整数&quot; score</span><br><span class="line">if [[ $score==&quot;q&quot; ]];then</span><br><span class="line">break</span><br><span class="line">elif [[ !&quot;$score&quot; =~^[0-9]+$ ]];then</span><br><span class="line">echo &quot;输入错误&quot;</span><br><span class="line">elif(( score &lt;0|| score &gt;100 ));then</span><br><span class="line">echo &quot;输入错误&quot;</span><br><span class="line">else</span><br><span class="line">sum=$((sum+score))</span><br><span class="line">count=$((count+1))</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">if((count == 0));then</span><br><span class="line">echo &quot;没有输入&quot;</span><br><span class="line">else</span><br><span class="line">avg=$((sum/count))</span><br><span class="line">echo &quot;平均分为&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h1>作业再现复习</h1><p>1.什么是shell? 它有什么作用?<br>2.简述管道的用途.<br>3.重定向是什么?有哪些常见类型?<br>4.获取Linux命令行帮助信息的方法有哪些?<br>5.简述命令行命令的语法格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shell是一个用户和操作系统内核之间的一个接口，类似与命令解释器，</span><br><span class="line">输入命令，shell负责解析命令，启动程序和进程等操作</span><br><span class="line">作用：</span><br><span class="line">命令执行</span><br><span class="line">脚本编程</span><br><span class="line">文件操作</span><br><span class="line">进程管理</span><br><span class="line"></span><br><span class="line">|管道符号</span><br><span class="line">将多个命令连接起来，前面命令的输出作为下一个命令的输入，用来连接两个或者更多的命令。也可以用来过滤数据</span><br><span class="line"></span><br><span class="line">重定向是将命令的输入和输出重定向到文件或者设备中，有&gt;&gt; &lt;&lt; &gt; &lt; 2&gt;&gt;</span><br><span class="line">2&gt;这些等</span><br><span class="line"></span><br><span class="line">获取帮助</span><br><span class="line">man ls</span><br><span class="line">ls --help</span><br><span class="line">info ls</span><br><span class="line">whatis ls</span><br><span class="line"></span><br><span class="line">格式是：</span><br><span class="line">命令 选项 参数</span><br></pre></td></tr></table></figure><p>1.常见的Linux文件类型有哪些?<br>2.用户账户的配置文件有哪些?各有什么用途?<br>3.简述用户账户配置文件的记录格式。<br>4.组账户的配置文件有哪些?它们各自有什么用途?<br>5.简述组账户配置文件的记录格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">普通文件，目录，符号连接，字符设备文件，管道文件，块设备文件</span><br><span class="line"></span><br><span class="line">/etc/passwd 基本信息</span><br><span class="line">/etc/shadow 密码等</span><br><span class="line">/etc/group 组的信息</span><br><span class="line"></span><br><span class="line">/etc/passwd</span><br><span class="line">用户名:密码:UID:GID:描述:家目录:默认Shell</span><br><span class="line">/etc/shadow</span><br><span class="line">用户名:密码:最后修改时间:最小密码年龄:最大密码年龄:警告期:不活动期:过期时间</span><br><span class="line">/etc/group</span><br><span class="line">组名:密码:GID:成员列表</span><br><span class="line"></span><br><span class="line">/etc/group：存储组的信息，包括组名、GID 和组成员列表。</span><br><span class="line">/etc/gshadow：存储与组相关的密码信息（通常为空）。</span><br><span class="line"></span><br><span class="line">/etc/group 的记录格式为：</span><br><span class="line">组名:密码:GID:成员列表</span><br><span class="line">/etc/gshadow 的记录格式为：</span><br><span class="line">组名:密码:管理员列表:成员列表</span><br></pre></td></tr></table></figure><p>1.简述Linux软件包管理的发展历史。<br>2.常见的软件包安装方法有哪些?<br>3.简述apt命令的基本用法。<br>4.简述基于源代码的程序安装流程<br>5.使用apt命令安装apache。<br>6.使用apt命令安装vim。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Linux 软件包管理工具相对简单，用户通常需要手动下载并编译源代码。</span><br><span class="line">二进制包管理：随着 Debian 和 Red Hat 的出现，二进制包管理系统（如 .deb 和 .rpm）得到了广泛采用。</span><br><span class="line">现代化管理：如 apt、yum 和 zypper 等工具使得软件包管理更加简化，支持自动更新和依赖关系管理。</span><br><span class="line"></span><br><span class="line">源代码编译</span><br><span class="line">.deb或者是rpm安装</span><br><span class="line">第三方安装工具</span><br><span class="line"></span><br><span class="line">apt install 包名</span><br><span class="line">apt update 更新</span><br><span class="line">apt grade 升级</span><br><span class="line">apt remove 包名</span><br><span class="line"></span><br><span class="line">下载源代码</span><br><span class="line">解压</span><br><span class="line">cd进入</span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br><span class="line">如果少包的话，那就进行安装</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install vim</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.Shell的变量类型有哪几种?<br>2.简述Shel1脚本的常见方式。<br>3.简述She11分支结构的实现方式。<br>4.简述She1l循环结构的实现方式。<br>5.设计一个Shell程序，添加一个新组group1，然后添加个组的50个用户，用户名的形式为stu**，**从01-50。</p><p>6.设计一个Shel1程序，该程序能接收用户从键盘输入的数，然后求出其总和、最大值和最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">位置参数，环境变量，局部变量，特殊变量，只读变量</span><br><span class="line"></span><br><span class="line">直接执行，交互执行，脚本中嵌入命令，解释器执行</span><br><span class="line"></span><br><span class="line">if-elif-else</span><br><span class="line">case</span><br><span class="line"></span><br><span class="line">for,while,until</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">sudo groupadd group1</span><br><span class="line">for i in $(seq -f &quot;%02g&quot; 1 50)</span><br><span class="line">do </span><br><span class="line">sudo useradd stu$i -g group1</span><br><span class="line">sudo passwd -d stu$i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">sum=0</span><br><span class="line">max=-9999999</span><br><span class="line">min=9999999</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">    read -p &quot;请输入数字 (或输入&#x27;q&#x27;退出): &quot; num</span><br><span class="line">    </span><br><span class="line">    if [ &quot;$num&quot; == &quot;q&quot; ]; then</span><br><span class="line">        break</span><br><span class="line">    elif ! [[ &quot;$num&quot; =~ ^[0-9]+$ ]]; then</span><br><span class="line">        echo &quot;无效输入，请输入一个数字！&quot;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    sum=$((sum + num))</span><br><span class="line">    </span><br><span class="line">    if [ $num -gt $max ]; then</span><br><span class="line">        max=$num</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    if [ $num -lt $min ]; then</span><br><span class="line">        min=$num</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;总和: $sum&quot;</span><br><span class="line">echo &quot;最大值: $max&quot;</span><br><span class="line">echo &quot;最小值: $min&quot;</span><br></pre></td></tr></table></figure><p>1.使用mkdir创建一个父目录不存在的目录时，需添加什么参数?<br>2.Linux操作系统中有哪些常见的文件类型?<br>3.使用什么命令可以删除包括子目录的目录?<br>4.Linux目录结构和windows目录结构有何不同?<br>5.简述软链接文件和硬链接文件的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/memgnankk/aaa</span><br><span class="line"></span><br><span class="line">普通文件</span><br><span class="line">块设备文件</span><br><span class="line">目录文件</span><br><span class="line">符号链接</span><br><span class="line">管道文件</span><br><span class="line">字符设备文件</span><br><span class="line">套接字文件</span><br><span class="line"></span><br><span class="line">rm -rf /home/mengnankk/temp</span><br><span class="line"></span><br><span class="line">Linux的根目录/，所有的文件都从/开始</span><br><span class="line">windows有各个驱动器分区，而Linux只有一个跟目录</span><br><span class="line">Linux分隔符是/</span><br><span class="line">windows是\</span><br><span class="line"></span><br><span class="line">软链接是一个指向原文件的链接，删除原文件后失效,ln- s创建</span><br><span class="line">硬链接是指向文件数据块的，相对于另一个名字，删除原文件后不会失效，直到硬数据全部删除</span><br><span class="line">使用ln创建</span><br></pre></td></tr></table></figure><p>1.简述进程的分类。<br>2.PID是什么，如何查看进程的pid?<br>3.如何向进程发送信号?如何结束进程?<br>4.如何调整进程的优先级?<br>5.常见的进程启动方式有哪些?<br>6.如何使用top命令监控进程的运行状态?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">前台进程，后台进程，守护进程</span><br><span class="line"></span><br><span class="line">Pid是操作系统给每个进程分配的唯一进程符号，用ps aus 或者top查看</span><br><span class="line"></span><br><span class="line">kill pid 删除进程 kill -9 强制删除 -15优雅的删除</span><br><span class="line"></span><br><span class="line">renice -n 10 -p pid直接调整</span><br><span class="line">修改正在进行的程序的优先级</span><br><span class="line">nice -n 10 command 命令的优先级</span><br><span class="line"></span><br><span class="line">命令直接启动</span><br><span class="line">命令 &amp;来启动</span><br><span class="line">nohup 命令来启动</span><br><span class="line"></span><br><span class="line">top直接查看包括 CPU 使用率、内存占用等信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.请解释磁盘分区的含义?<br>2.请解释格式化的含义?<br>3.新磁盘在可以进行文件存取之前需要经过哪些操作?<br>4.简述Linux磁盘设备命名方法。<br>5.简述Linux磁盘分区命令方法。<br>6.简述MBR和GPT的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">磁盘分区是指将一个物理硬盘分割成多个逻辑区域，每个区域可以作为一个独立的磁盘来使用。每个分区可以用于存储不同类型的数据（如操作系统、数据文件、备份等），从而提高磁盘的管理效率和数据安全性。分区还可以帮助操作系统更好地管理硬盘资源，如文件系统的创建、文件存取等。</span><br><span class="line"></span><br><span class="line">格式化是对磁盘或者分区进行初始化的的过程，在磁盘上创建一个文件系统，然后情空之前的其他数据</span><br><span class="line"></span><br><span class="line">先虚拟机新建一块硬盘</span><br><span class="line">分区fdisk /dev/sdb</span><br><span class="line">格式化 mkfs -t ext4 /dev/sdb1</span><br><span class="line">挂载挂载， 先创建一个/home/newdisk,挂载 mount /dev/sdb1 /home/newdisk </span><br><span class="line">然后设置自动挂载</span><br><span class="line">设置自动挂载，打开/etc/fstab 添加一行 </span><br><span class="line">/dev/sdb1 /home/newdisk ext4 defaults 0 0 </span><br><span class="line"></span><br><span class="line">dev/sda、/dev/sdb：表示SATA、SCSI或USB等磁盘设备，a、b、c等字母表示磁盘的顺序。</span><br><span class="line">/dev/sda1、/dev/sda2：表示 /dev/sda 磁盘上的第一个和第二个分区。</span><br><span class="line">/dev/nvme0n1：表示 NVMe 固态硬盘（SSD）设备，n1 是该设备的标识符。</span><br><span class="line">/dev/loop0、/dev/loop1：表示环回设备，通常用于挂载ISO文件等。</span><br><span class="line"></span><br><span class="line">fdisk/parted/lsblk</span><br><span class="line"></span><br><span class="line">MBR 主要用于旧版操作系统（如Windows 7之前的版本），且支持的磁盘容量有限（最大2TB）。</span><br><span class="line">GPT 是现代磁盘的标准，支持大容量磁盘，并且支持更多的分区，适用于较新版本的操作系统（如Windows 10、Linux等）。</span><br></pre></td></tr></table></figure><h1>补充</h1><p><code>lsof</code>（List Open Files）是一个用于列出进程打开的文件的命令，可以显示哪些文件被哪些进程占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br><span class="line">lsof /path/to/file  # 查看某个文件被哪个进程打开</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Linux系统中，用于将标准输出和标准错误重定向到文件的符号是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&gt;</span><br></pre></td></tr></table></figure><p>Linux系统中，将标准错误重定向到文件里的符号是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&gt;</span><br></pre></td></tr></table></figure><p><strong>free命令可以显示系统的内存使用情况</strong></p><p><strong>df是查看硬盘的使用情况</strong></p><p><code>diff</code> 是用于比较文件内容差异的命令，它会显示两个文件之间的不同之处。常用于源代码管理、配置文件比较等场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff file1.txt file2.txt  # 比较 file1.txt 和 file2.txt 文件的差异</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ls -i</code> 命令用于显示文件或目录的 inode 信息。它会在文件名旁边显示该文件的 inode 号</p><p>stat令用于显示文件的详细信息，包括文件的大小、权限、时间戳、inode 等，但它并不是专门用于查看 inode 信息的命令。</p><p><code>lscpu</code> 是一个用于显示 CPU 架构信息的命令，它提供了有关 CPU 的简明概览，包括架构类型、核心数、线程数、CPU 架构、时钟速度等信息。</p><h2 id="补充简答">补充简答</h2><p>在 Linux 中查看设备信息，可以通过多种命令来查看不同类型的硬件设备信息，如 CPU、内存、硬盘、网络设备等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lscup</span><br><span class="line">free -h</span><br><span class="line">lsblk</span><br><span class="line">df -h </span><br><span class="line">sudo fdisk -l </span><br><span class="line">ipconfig</span><br><span class="line">ip addr </span><br><span class="line">lspci -v</span><br><span class="line">lsusb</span><br><span class="line">sudo lshw</span><br><span class="line">uname -a</span><br><span class="line">sudo dimidcode</span><br><span class="line">lspci |grep VGA</span><br><span class="line">ls /dev</span><br><span class="line">sudo parted -l</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简述 Linux 中文件系统的卸载选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux 中，卸载文件系统使用 `umount` 命令</span><br><span class="line">其实就是取消挂载</span><br><span class="line">-l是懒卸载，就是自动卸载</span><br><span class="line">-f是强制卸载</span><br><span class="line">-a 是卸载所有</span><br></pre></td></tr></table></figure><p>怎样在 Linux 中为内核模块传递参数?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 Linux 中，可以通过 `modprobe` 命令或在 `/etc/modules-load.d/` 配置文件中为内核模块传递参数。</span><br><span class="line">sudo modprobe my_module param=5</span><br><span class="line">options my_module param=5</span><br><span class="line">也可以将模块参数配置在系统文件中，以便在系统启动时自动传递。将配置写入 /etc/modprobe.d/ 目录下的某个文件，如 my_module.conf。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;真题在现&lt;/h1&gt;
&lt;h2 id=&quot;概述题&quot;&gt;概述题&lt;/h2&gt;
&lt;p&gt;1、简述 GNU、GPL 的含义，及其对 Linux 的影响。&lt;/p&gt;
&lt;p&gt;GNU 计划开始于 1984 年 1 月。其创始人是理查德•马修•斯托曼（Richard</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="Linux" scheme="https://mengnankk.asia/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="https://mengnankk.asia/2024/11/11/data6/"/>
    <id>https://mengnankk.asia/2024/11/11/data6/</id>
    <published>2024-11-10T16:00:00.000Z</published>
    <updated>2024-11-21T06:08:36.391Z</updated>
    
    <content type="html"><![CDATA[<p>查找算法主要用于在集合（如数组、列表、树等）中寻找特定的元素。以下是几种常见的查找算法以及相应的代码示例。</p><h1>线性查找</h1><p>线性查找是一种简单的查找方法，它逐个检查每个元素，直到找到目标元素或遍历完整个集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LinearSearch &#123;</span><br><span class="line">    public static int linearSearch(int[] arr, int target) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] == target) &#123;</span><br><span class="line">                return i;  // 返回目标元素的索引</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;  // 如果找不到，返回-1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;2, 5, 8, 3, 6, 9&#125;;</span><br><span class="line">        int target = 3;</span><br><span class="line">        int result = linearSearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><strong>二分查找</strong></h1><p>二分查找是对已经排序的数组进行查找的有效算法。每次通过中间元素来缩小查找范围，直到找到目标元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static int binarysearch(int[] arr,int target)&#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = arr.length - 1;</span><br><span class="line">        while (left&lt;=right)&#123;</span><br><span class="line">            int mid = left + (right - left)/2;</span><br><span class="line">            if (arr[mid] == target)&#123;</span><br><span class="line">                return  mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[mid]&lt;target)&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 3, 5, 7, 9, 11&#125;;</span><br><span class="line">        int target = 7;</span><br><span class="line">        int result = binarysearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>哈希查找</h1><p>哈希查找通过使用哈希表来进行查找，时间复杂度通常为 O(1)，是查找速度最快的方法之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">public class HashSearch &#123;</span><br><span class="line">    public static boolean hashSearch(HashSet&lt;Integer&gt; set,int target)&#123;</span><br><span class="line">        return set.contains(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(1);</span><br><span class="line">        set.add(5);</span><br><span class="line">        set.add(3);</span><br><span class="line">        set.add(6);</span><br><span class="line">        set.add(7);</span><br><span class="line">        int target  = 3;</span><br><span class="line">        if (hashSearch(set,target))&#123;</span><br><span class="line">            System.out.println(target+&quot;yes&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(target+&quot;no&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hash查找主要是看该数据的hash值，hash值一般是不相同的，所以能通过hash值来进行查找</p><h1>dfs</h1><p>是一种遍历或查找图、树的算法，常用于图形和树形结构的查找。它通过尽可能深入地访问每个分支来遍历整个结构。</p><p>主要是用递归来解决</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class DFS &#123;</span><br><span class="line">    static class TreeNode &#123;</span><br><span class="line">        int value;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        TreeNode(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean dfs(TreeNode node, int target) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.value == target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 递归地搜索左子树和右子树</span><br><span class="line">        return dfs(node.left, target) || dfs(node.right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        root.left = new TreeNode(2);</span><br><span class="line">        root.right = new TreeNode(3);</span><br><span class="line">        root.left.left = new TreeNode(4);</span><br><span class="line">        root.left.right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">        int target = 4;</span><br><span class="line">        if (dfs(root, target)) &#123;</span><br><span class="line">            System.out.println(&quot;找到了目标元素 &quot; + target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;未找到目标元素 &quot; + target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>bfs</h1><p>用于查找图或树结构中的元素。与深度优先搜索不同，广度优先搜索逐层扫描，首先访问每一层的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class BFS &#123;</span><br><span class="line">    static class TreeNode &#123;</span><br><span class="line">        int value;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        TreeNode(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean bfs(TreeNode root, int target) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.value == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        root.left = new TreeNode(2);</span><br><span class="line">        root.right = new TreeNode(3);</span><br><span class="line">        root.left.left = new TreeNode(4);</span><br><span class="line">        root.left.right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">        int target = 5;</span><br><span class="line">        if (bfs(root, target)) &#123;</span><br><span class="line">            System.out.println(&quot;找到了目标元素 &quot; + target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;未找到目标元素 &quot; + target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>插入查找</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class InterpolationSearch &#123;</span><br><span class="line">    public static int interpolationSearch(int[] arr,int target)&#123;</span><br><span class="line">        int left = 0,right = arr.length - 1;</span><br><span class="line">        while (left&lt;=right&amp;&amp;target&gt;=arr[left]&amp;&amp;target&lt;=arr[right])&#123;</span><br><span class="line">            if (arr[right] == arr[left])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            int mid = left + ((target - arr[left]*(right-left))/(arr[right]-arr[left]));</span><br><span class="line">            if(arr[mid] == target)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[mid]&lt;target)&#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&#125;;</span><br><span class="line">        int target = 70;</span><br><span class="line">        int result = interpolationSearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实现</p><h1>选择排序</h1><p>每次在未排序部分选择最小（或最大）元素，然后与未排序部分的第一个元素交换，直到整个数组有序。</p><p>每次只进行一次交换操作。</p><p>时间复杂度：O(n^2)，无论数据是否已经有序。</p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void selectionSort(int[] arr) &#123;</span><br><span class="line">        int comparisons = 0;</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                comparisons++;</span><br><span class="line">                if (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;！：&quot; + comparisons);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;5, 2, 9, 1, 5, 6&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        for (int num : arr) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>起泡排序</h1><p>每次比较相邻的两个元素，如果顺序错误则交换它们，经过一轮比较后，最大（或最小）元素会“浮”到数组的末端。重复这个过程，直到数组有序。</p><p>其实可以也叫做冒泡排序</p><p>时间复杂度：O(n^2)，如果数据已经有序，可以优化为 O(n)。</p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void bubbleSort(int[] arr)&#123;</span><br><span class="line">        int comparisons =0;</span><br><span class="line">        for (int i =0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            for ( int j = 0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">                comparisons++;</span><br><span class="line">                if (arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                    int temp =  arr[j];</span><br><span class="line">                    arr[j] = arr[j+1];</span><br><span class="line">                    arr[j+1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(comparisons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;查找算法主要用于在集合（如数组、列表、树等）中寻找特定的元素。以下是几种常见的查找算法以及相应的代码示例。&lt;/p&gt;
&lt;h1&gt;线性查找&lt;/h1&gt;
&lt;p&gt;线性查找是一种简单的查找方法，它逐个检查每个元素，直到找到目标元素或遍历完整个集合。&lt;/p&gt;
&lt;figure</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="数据结构" scheme="https://mengnankk.asia/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://mengnankk.asia/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>English十一月篇</title>
    <link href="https://mengnankk.asia/2024/11/01/en3/"/>
    <id>https://mengnankk.asia/2024/11/01/en3/</id>
    <published>2024-10-31T16:00:00.000Z</published>
    <updated>2024-12-01T02:57:44.195Z</updated>
    
    <content type="html"><![CDATA[<h1>每日一话+单词遗忘表11.1</h1><p>Who partakes in another’s joys is a more humane character than he who partakes in his griefs.</p><ul><li>counsel 忠告</li><li>counterpart 相当的</li><li>coupon 卷</li><li>coward 胆小的</li><li>crab 螃蟹</li><li>crane 吊车</li><li>crawl 爬行</li></ul><h1>每日一话+单词遗忘表11.2</h1><p>The highest possible stage in moral culture is when we recognize that we ought to control thoughts.</p><ul><li>creep 爬行</li><li>crew 组</li><li>crisis 危机</li><li><strong>criterion</strong> 准则</li><li>crocodile 鳄鱼</li><li>crop 农作物</li><li>crucial 决定性的</li><li>cruise 巡游</li><li>crustal 水晶</li><li>cucumber 黄瓜</li><li><strong>cultivate</strong> 耕种</li><li>crub 遏制</li></ul><h1>每日一话+单词遗忘表11.4</h1><p>Do the best you can, until you know better. Then when you know better, do better.</p><ul><li><strong>curse</strong> 诅咒</li><li>curtain 窗帘</li><li>curve 曲线</li><li>cushion 垫子</li><li>bait 引诱</li><li>cyberspace 数字空间</li><li>damp 潮湿</li><li>crown 王冠</li></ul><h1>每日一话+单词遗忘表11.7</h1><p>Winter is the time for comfort, for good food and warmth, for the touch of a friendly hand and for a talk beside the fire: it is the time for home.</p><ul><li>dawn 黎明</li><li>deaf 聋的</li><li>dean 院长</li><li><strong>decay</strong> 腐烂</li><li><strong>deceive</strong> 欺骗</li><li>currency 货币</li><li><strong>decent</strong> 得体的</li><li>deck 甲板</li><li><strong>deed</strong> 行动</li><li><strong>deem</strong> 认为</li><li>curriculum 课程</li></ul><h1>每日一话+单词遗忘表11.9</h1><p>It is silly of you, for there is only one thing in the world worse than being talked about, and that is not being talked about.</p><ul><li>defend 防守</li><li>deficient 有缺点的</li><li>deficit 赤字</li><li>definite 确切的</li><li>defy 蔑视</li><li><strong>delegate</strong> 代表</li><li>deliberate 从容不错的</li><li>delicate 精妙的</li><li>democracy 民主的</li><li>demonstrate 证明</li><li>dense 浓厚的</li><li>deposit 放置</li><li><strong>deprive</strong> 使丧失</li><li></li></ul><h1>每日一话+单词遗忘表11.10</h1><p>In the first 30 years of your life, you make your habits. For the last 30 years of your life, your habits make you.</p><ul><li>deputy 代理人</li><li>derive 源于</li><li>descend 下降</li><li>desert 遗弃</li><li><strong>deserve</strong> 应得的</li><li>despair 绝望</li><li>despatch 派遣</li><li>despite 尽管</li><li>detect 发现</li><li>deteriorate 恶化</li><li>dew 露水</li><li>diabetes 糖尿病</li><li>dial 打电话</li><li>devil 魔鬼</li><li></li></ul><h1>每日一话+单词遗忘表11.13</h1><p>Most of the change we think we see in life is due to truths being in and out of favor.</p><ul><li>dialect 方言</li><li>dialog 对话</li><li>deed 行动</li><li>diameter 直径</li><li>dictate 命令</li><li>curse 诅咒</li><li>dignity 尊严</li><li>dilemma 困境</li><li>diligent 勤勉的</li><li>dim 模糊的</li><li>dimension 尺寸</li><li>diplomat 外交家</li><li></li></ul><h1>每日一话+单词遗忘表11.14</h1><p>I do not think the forest would be so bright, nor the water so warm, nor love so sweet, if there were no danger in the lakes.</p><ul><li>disaster 不幸的</li><li>discadrd 丢弃</li><li>dischange 排出</li><li>discipline 纪律</li><li>discriminate 分别</li><li>disguise 假装</li><li><strong>disgust</strong> 厌恶</li><li>disintegrate 使分裂</li><li>delegate 代表</li><li>dispute 争论</li><li>disrupt 分裂</li><li><strong>disslove</strong> 使溶解</li><li>distinct 清楚的</li><li></li></ul><h1>每日一话+单词遗忘表11.15</h1><p>We must be willing to get rid of the life we’ve planned, so as to have the life that is waiting for us. The old skin has to be shed before the new one can come.</p><ul><li>distingguish 辨别</li><li>distract 分心</li><li>distress 忧虑</li><li><strong>district</strong> 区域</li><li>disturb 打扰</li><li><strong>ditch</strong> 丢弃</li><li>dive 跳水</li><li>dizzy 眩晕的</li><li>dock 码头</li><li>domestic 国内的</li><li>doominate 支配</li></ul><h1>每日一话+单词遗忘表11.16</h1><p>Love is an untamed force.</p><ul><li>dove 鸽子</li><li>dozen 一打</li><li>draft 草稿</li><li>drain 流水</li><li>drastic 激烈的</li><li>drawer 抽屉</li><li><strong>drift</strong> 漂流</li><li><strong>drill</strong> 钻子</li><li>drip 滴下</li><li>dropout 中途退学</li><li>dose 一剂量</li><li></li></ul><h1>每日一话+单词遗忘表11.18</h1><p>The great thing in this world is not so much where we are, but in what direction we are going.</p><ul><li><p>dual 双的</p></li><li><p>dull 钝的</p></li><li><p>dumb 哑的</p></li><li><p><strong>durable</strong> 耐用的</p></li><li><p><strong>duration</strong> 持续</p></li><li><p>dye 染料</p></li><li><p>decay 腐烂</p></li><li><p>ease 减轻</p></li></ul><h1>每日一话+单词遗忘表11.20</h1><p>A man who dares to waste one hour of time has not discovered the value of life.</p><ul><li>economy 节约</li><li>editorial 编辑的</li><li>eggplant 茄子</li><li>elbow 肘</li><li>elect 选出</li><li>elegant 高雅的</li><li>elevate 举起</li></ul><h1>每日一话+单词遗忘表11.21</h1><p>When everything seems to be going against you, remember that the airplane takes off against the wind, not with it.</p><ul><li>eliminate 消除</li><li>elite 精英</li><li>embrace 包含</li><li>emerge 浮现</li><li>emit 发出</li><li>emphasis 强调</li><li>encounter 遇到</li><li>enforce 强迫</li></ul><h1>每日一话+单词遗忘表11.22</h1><p>To travel hopefully is a better thing than to arrive.</p><ul><li>enlarge 扩大</li><li>enlighten 启发</li><li>enormous 庞大的</li><li>enrol 登记</li><li>enroll 登记</li><li>enterprise 事业</li><li>entertain 娱乐</li><li>entrepreneur 企业家</li><li>envelope 信封</li><li>envy 羡慕</li><li>episode 插曲</li><li>equip 装备</li><li>equivalent 等同的</li><li>essay 散文</li></ul><h1>每日一话+单词遗忘表11.23</h1><p>Fate fears the brave and bullies the timid.</p><ul><li>estimate 估计</li><li>eternal 永恒的</li><li>ethic 道德规范</li><li>ethnic 种族的</li><li>evident 明白的</li><li>evil 邪恶的</li><li>evolve 发展</li><li>exact 精确的</li><li>exceed 胜过</li><li>exceed 超过</li></ul><h1>每日一话+单词遗忘表11.24</h1><p>Since olden days there’s never been a man but dies; I’d leave a loyalist’s name in history only.</p><ul><li><strong>excess</strong> 超过</li><li>excite 刺激</li><li>exclaim 呼喊</li><li>exclude 排除</li><li>excursion 远足</li><li>excuse 理由</li><li>exert 运用</li><li>exhaust 耗尽</li><li>exile 流放</li><li>expel 驱逐</li><li>expense 开支</li><li><strong>expertise</strong> 专业知识</li><li>explicit 清楚的</li><li>explode 爆发</li><li>exploit 开发</li></ul><h1>每日一话+单词遗忘表11.25</h1><p>Time flies over us, but leaves its shadow behind.</p><ul><li>expose 使曝光</li><li>expel 开除</li><li>extent 范围</li><li>exterior 外表的</li><li>external 外部的</li><li>extingguish 熄灭</li><li>extraordinary 非常奇怪的</li><li>eyebrow 眉毛</li><li>faabric 布</li><li>facility 设备</li><li>faculty 能力</li><li>faint 头晕的</li><li>faith 信心</li></ul><h1>每日一话+单词遗忘表11.26</h1><p>Happiness always looks small while you hold it in your hands, but let it go, and you learn at once how big and precious it is.</p><ul><li>fame 名声</li><li><strong>famine</strong> 饥荒</li><li>fancy 想象力</li><li>fantasy 幻想</li><li>fare 票</li><li>farewell 告别</li><li>fascinate 使着迷</li><li>fasten 扎牢</li><li>fatal 致命的</li><li><strong>fatigue</strong> 疲劳</li><li>fault 故障</li><li>feasible 可行的</li><li>feather 羽毛</li></ul><h1>每日一话+单词遗忘表11.27</h1><p>Perhaps the best cure for the fear of death is to reflect that life has a beginning as well as an end.</p><ul><li>federal 联邦的</li><li>feed 喂养</li><li>ferry 渡口</li><li>fertile 富饶的</li><li>fever 发烧</li><li><strong>fiber</strong> 纤维</li><li>field 领域</li><li>fierce 凶猛的</li><li><strong>figure</strong> 图形</li><li><strong>filter</strong> 过滤</li></ul><h1>每日一话+单词遗忘表11.28</h1><p>We can be knowledgeable with other men’s knowledge, but we can not be wise with other men’s wisdom.</p><ul><li>finance 财经</li><li>fingerprint 指纹</li><li>fireplace 壁炉</li><li>flat 平坦的</li><li>flavor 滋味</li><li>flaw 瑕疵</li><li>fleet 快速的</li><li>flesh 肉体</li><li>flock 群</li></ul><h1>每日一话+单词遗忘表11.29</h1><p>it is a true great man whom no money and rank can confuse, no poverty and hardship can shake, and no power and force can suffocate.</p><ul><li>flour 面粉</li><li>flourish 兴盛</li><li>fluctuate 波动</li><li>fluent 流畅的</li><li>fluid 流动的</li><li>focus 中心</li><li>fog 雾</li><li>fold 折叠</li><li>forbid 禁止</li><li>forecast 预测</li><li>foresee 预知</li><li></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;每日一话+单词遗忘表11.1&lt;/h1&gt;
&lt;p&gt;Who partakes in another’s joys is a more humane character than he who partakes in his</summary>
        
      
    
    
    
    <category term="English" scheme="https://mengnankk.asia/categories/English/"/>
    
    
    <category term="English" scheme="https://mengnankk.asia/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 图</title>
    <link href="https://mengnankk.asia/2024/10/30/data5/"/>
    <id>https://mengnankk.asia/2024/10/30/data5/</id>
    <published>2024-10-29T16:00:00.000Z</published>
    <updated>2024-11-11T11:23:00.460Z</updated>
    
    <content type="html"><![CDATA[<h1>定义-各种分类</h1><p><strong>图（Graph）</strong>：由顶点的非空有限集合 V<em>V</em> （由 n&gt;0<em>n</em>&gt;0 个顶点组成）与边的集合 E<em>E</em>（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)<em>G</em>=(<em>V</em>,<em>E</em>)。</p><ul><li><strong>顶点（Vertex）</strong>：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。</li><li><strong>边（Edge）</strong>：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=⟨u,v⟩<em>e</em>=⟨<em>u</em>,<em>v</em>⟩，表示从 u<em>u</em> 到 v<em>v</em> 的一条边，其中 u<em>u</em> 称为起始点，v<em>v</em> 称为终止点。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220307145142.png" alt=""></p><p>特别的，根据定义，G<em>G</em> 也是其自身的子图。</p><p><img src="https://qcdn.itcharge.cn/images/20220317163120.png" alt=""></p><ul><li><strong>无向图（Undirected Graph）</strong>：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。</li><li><strong>有向图（Directed Graph）</strong>：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220307160017.png" alt=""></p><p>如果无向图中有 n<em>n</em> 个顶点，则无向图中最多有 n×(n−1)/2<em>n</em>×(<em>n</em>−1)/2 条边。而具有 n×(n−1)/2<em>n</em>×(<em>n</em>−1)/2 条边的无向图称为 <strong>「完全无向图（Completed Undirected Graph）」</strong>。</p><p>如果有向图中有 n<em>n</em> 个顶点，则有向图中最多有 n×(n−1)<em>n</em>×(<em>n</em>−1) 条弧。而具有 n×(n−1)<em>n</em>×(<em>n</em>−1) 条弧的有向图称为 <strong>「完全有向图（Completed Directed Graph）」</strong>。</p><p><strong>说白了就是全都连起来了</strong></p><p><img src="https://qcdn.itcharge.cn/images/20220308151436.png" alt=""></p><ul><li><strong>顶点的度</strong>：与该顶点 vi<em>v**i</em> 相关联的边的条数，记为 TD(vi)<em>T**D</em>(<em>v**i</em>)。</li></ul><p>例如上图左侧的完全无向图中，顶点 v3的度为 3。</p><p>而对于有向图，我们可以将顶点的度分为 <strong>「顶点的出度」</strong> 和 <strong>「顶点的入度」</strong>。</p><ul><li><strong>顶点的出度</strong>：以该顶点 vi<em>v**i</em> 为出发点的边的条数，记为 OD(vi)<em>O**D</em>(<em>v**i</em>)。</li><li><strong>顶点的入度</strong>：以该顶点 vi<em>v**i</em> 为终止点的边的条数，记为 ID(vi)<em>I**D</em>(<em>v**i</em>)。</li><li>有向图中某顶点的度 = 该顶点的出度 + 该顶点的入度，即 TD(vi)=OD(vi)+ID(vi)<em>T**D</em>(<em>v**i</em>)=<em>O**D</em>(<em>v**i</em>)+<em>I**D</em>(<em>v**i</em>)。</li></ul><p><strong>例如顶点v3的度就是6，3+3=6</strong></p><ul><li><p><strong>环（Circle）</strong>：如果一条路径的起始点和终止点相同（即 vi0==vim<em>v**i</em>0==<em>v<strong>i</strong>m</em> ），则称这条路径为「回路」或者「环」。</p></li><li><p><strong>简单路径</strong>：顶点序列中顶点不重复出现的路径称为「简单路径」。</p></li></ul><p>而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。</p><ul><li><strong>环形图（Circular Graph）</strong>：如果图中存在至少一条环路，则该图称为「环形图」。</li><li><strong>无环图（Acyclic Graph）</strong>：如果图中不存在环路，则该图称为「无环图」。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317115641.png" alt=""></p><p>在无向图中，如果从顶点 vi<em>v**i</em> 到顶点 vj<em>v**j</em> 有路径，则称顶点 vi<em>v**i</em> 和 vj<em>v**j</em> 是连通的。</p><ul><li><strong>连通无向图</strong>：在无向图中，如果图中任意两个顶点之间都是连通的，则称该图为连通无向图。</li><li><strong>非连通无向图</strong>：在无向图中，如果图中至少存在一对顶点之间不存在任何路径，则该图称为非连通无向图。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317163249.png" alt=""></p><p>有些无向图可能不是连通无向图，但是其子图可能是连通的。这些子图称为原图的连通子图。而无向图的一个极大连通子图（不存在包含它的更大的连通子图）则称为该图的「连通分量」。</p><ul><li><p><strong>连通子图</strong>：如果无向图的子图是连通无向图，则该子图称为原图的连通子图。</p></li><li><p><strong>连通分量</strong>：无向图中的一个极大连通子图（不存在包含它的更大的连通子图）称为该图的连通分量。</p></li><li><p><strong>极⼤连通⼦图</strong>：无向图中的一个连通子图，并且不存在包含它的更大的连通子图。</p></li><li><p><strong>强连通有向图</strong>：如果图中任意两个顶点 vi<em>v**i</em> 和 vj<em>v**j</em>，从 vi<em>v**i</em> 到 vj<em>v**j</em> 和从 vj<em>v**j</em> 到 vi<em>v**i</em> 都有路径，则称该图为强连通有向图。</p></li><li><p><strong>非强连通有向图</strong>：如果图中至少存在一对顶点之间不存在任何路径，则该图称为非强连通有向图。</p></li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317133500.png" alt=""></p><p>与无向图类似，有向图的一个极大强连通子图称为该图的 <strong>强连通分量</strong>。</p><ul><li><strong>强连通子图</strong>：如果有向图的子图是连通有向图，则该子图称为原图的强连通子图。</li><li><strong>强连通分量</strong>：有向图中的一个极⼤强连通⼦图，称为该图的强连通分量。</li><li><strong>极⼤强连通⼦图</strong>：有向图中的一个强连通子图，并且不存在包含它的更大的强连通子图。</li></ul><p>有时，图不仅需要表示顶点之间是否存在某种关系，还需要表示这一关系的具体细节。这时候我们需要在边上带一些数据信息，这些数据信息被称为 <strong>权</strong>。在具体应用中，权值可以具有某种具体意义，比如权值可以代表距离、时间以及价格等不同属性。</p><ul><li><strong>带权图</strong>：如果图的每条边都被赋以⼀个权值，这种图称为带权图。</li><li><strong>网络</strong>：带权的连通⽆向图称为⽹络。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317135207.png" alt=""></p><p>根据图中边的稀疏程度，我们可以将图分为「稠密图」和「稀疏图」。这是一个模糊的概念，目前为止还没有给出一个量化的定义。</p><ul><li><strong>稠密图（Dense Graph）</strong>：有很多条边或弧（边的条数 e<em>e</em> 接近于完全图的边数）的图称为稠密图。</li><li><strong>稀疏图（Sparse Graph）</strong>：有很少条边或弧（边的条数 e<em>e</em> 远小于完全图的边数，如 e&lt;n×log⁡2n<em>e</em>&lt;<em>n</em>×log2<em>n</em>）的图称为稀疏图。</li></ul><h1>存储结构</h1><p>我们在实现图的存储时，重点需要关注边与顶点之间的关联关系，这是图的存储的关键。</p><p>图的存储可以通过「顺序存储结构」和「链式存储结构」来实现。其中顺序存储结构包括邻接矩阵和边集数组。链式存储结构包括邻接表、链式前向星、十字链表和邻接多重表。</p><h2 id="邻接矩阵">邻接矩阵</h2><p><strong>邻接矩阵（Adjacency Matrix）</strong>：使用一个二维数组 adj‾matrix<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em> 来存储顶点之间的邻接关系。</p><ul><li>对于无权图来说，如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 11，则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 存在边，如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 00，则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 不存在边。</li><li>对于带权图来说，如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 w<em>w</em>，并且 w≠∞<em>w</em>\=∞（即 <code>w != float('inf')</code>），则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 的权值为 w<em>w</em>。如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 ∞∞（即 <code>float('inf')</code>），则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 不存在边。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317144826.png" alt=""></p><p>邻接矩阵的特点：</p><ul><li><p>优点：实现简单，并且可以直接查询顶点 vi<em>v**i</em> 与 vj<em>v**j</em> 之间是否有边存在，还可以直接查询边的权值。</p></li><li><p>缺点：初始化效率和遍历效率较低，空间开销大，空间利用率低，并且不能存储重复边，也不便于增删节点。如果当顶点数目过大（比如当 n&gt;105<em>n</em>&gt;105）时，使用邻接矩阵建立一个 n×n<em>n</em>×<em>n</em> 的二维数组不太现实。</p></li><li><p><strong>时间复杂度</strong>：</p><ul><li><strong>初始化操作</strong>：O(n2)<em>O</em>(<em>n</em>2)。</li><li><strong>查询、添加或删除边操作</strong>：O(1)<em>O</em>(1)。</li><li><strong>获取某个点的所有边操作</strong>：O(n)<em>O</em>(<em>n</em>)。</li><li><strong>图的遍历操作</strong> ：O(n2)<em>O</em>(<em>n</em>2)。</li></ul></li><li><p><strong>空间复杂度</strong>：O(n2)<em>O</em>(<em>n</em>2)。</p></li></ul><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Graph &#123;</span><br><span class="line">    private int verCount;</span><br><span class="line">    private Integer[][] adjMatrix;</span><br><span class="line">    public Graph(int verCount)&#123;</span><br><span class="line">        this.verCount = verCount;</span><br><span class="line">        adjMatrix = new Integer[verCount][verCount];</span><br><span class="line">        for (Integer[] row:adjMatrix)&#123;</span><br><span class="line">            Arrays.fill(row,null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isValid(int v) &#123;</span><br><span class="line">        return 0 &lt;= v &amp;&amp; v &lt; verCount; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createGraph(int[][] edges)&#123;</span><br><span class="line">        for (int[] edge:edges)&#123;</span><br><span class="line">            addEdge(edge[0],edge[1],edge[2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addEdge(int vi,int vj,int val)&#123;</span><br><span class="line">        if (!isValid(vi) || !isValid(vj))&#123;</span><br><span class="line">            throw new IllegalArgumentException(vi+&quot;or&quot;+vj+&quot;is not&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMatrix[vi][vj] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getEdge(int vi,int vj)&#123;</span><br><span class="line">        if (!isValid(vi) || !isValid(vj))&#123;</span><br><span class="line">            throw new IllegalArgumentException(vi+&quot;or&quot;+vj+&quot;is not&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return adjMatrix[vi][vj];</span><br><span class="line">    &#125;</span><br><span class="line">    public void printGraph()&#123;</span><br><span class="line">        for (int vi=0;vi&lt;verCount;vi++)&#123;</span><br><span class="line">            for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">                Integer val = getEdge(vi,vj);</span><br><span class="line">                if (val!=null)&#123;</span><br><span class="line">                    System.out.println(vi + &quot;-&quot; + vj + &quot;-&quot; + val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Graph graph = new Graph(5);</span><br><span class="line">        int[][] edges = &#123;</span><br><span class="line">                &#123;1, 2, 5&#125;,</span><br><span class="line">                &#123;2, 1, 5&#125;,</span><br><span class="line">                &#123;1, 3, 30&#125;,</span><br><span class="line">                &#123;3, 1, 30&#125;,</span><br><span class="line">                &#123;2, 3, 14&#125;,</span><br><span class="line">                &#123;3, 2, 14&#125;,</span><br><span class="line">                &#123;2, 4, 26&#125;,</span><br><span class="line">                &#123;4, 2, 26&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        graph.createGraph(edges);</span><br><span class="line">        graph.getEdge(3,4);</span><br><span class="line">        graph.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在写代码的时候，出现了一些小小的问题</p><p>主要是异常处理没完成的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!isValid(vi) || !isValid(vj)) </span><br></pre></td></tr></table></figure><p>应该是这个逻辑，我写错了，大家注意</p><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">1-2-5</span><br><span class="line">1-3-30</span><br><span class="line">2-1-5</span><br><span class="line">2-3-14</span><br><span class="line">2-4-26</span><br><span class="line">3-1-30</span><br><span class="line">3-2-14</span><br><span class="line">4-2-26</span><br></pre></td></tr></table></figure><p>稍微修改了下，把检测权给输出出来了</p><h2 id="边集数组">边集数组</h2><p><strong>边集数组（Edgeset Array）</strong>：使用一个数组来存储存储顶点之间的邻接关系。数组中每个元素都包含一条边的起点 vi<em>v**i</em>、终点 vj<em>v**j</em> 和边的权值 val<em>v<strong>a</strong>l</em>（如果是带权图）。</p><p><img src="https://qcdn.itcharge.cn/images/20220317161454.png" alt=""></p><p>边集数组的时间复杂度：</p><ul><li>图的初始化和创建操作：O(m)<em>O</em>(<em>m</em>)。</li><li>查询是否存在某条边：O(m)<em>O</em>(<em>m</em>)。</li><li>遍历某个点的所有边：O(m)<em>O</em>(<em>m</em>)。</li><li>遍历整张图：O(nm)<em>O</em>(<em>nm</em>)。</li></ul><p>边集数组的空间复杂度：</p><ul><li>空间复杂度：O(m)<em>O</em>(<em>m</em>)。</li></ul><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class EdgeNode&#123;</span><br><span class="line">    int vi;</span><br><span class="line">    int vj;</span><br><span class="line">    int val;</span><br><span class="line"></span><br><span class="line">    public EdgeNode(int vi, int vj, int val) &#123;</span><br><span class="line">        this.vi = vi;</span><br><span class="line">        this.vj = vj;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class EdgeListGraph &#123;</span><br><span class="line">    private List&lt;EdgeNode&gt; edges;</span><br><span class="line">    public EdgeListGraph()&#123;</span><br><span class="line">        edges = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public void  createGraph(int[][] edgesArray)&#123;</span><br><span class="line">        for (int[] edge:edgesArray)&#123;</span><br><span class="line">            addEdge(edge[0],edge[1],edge[2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addEdge(int vi,int vj,int val)&#123;</span><br><span class="line">        EdgeNode edge = new EdgeNode(vi,vj,val);</span><br><span class="line">        edges.add(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getEdge(int vi,int vj)&#123;</span><br><span class="line">        for (EdgeNode edge:edges)&#123;</span><br><span class="line">            if (vi==edge.vi&amp;&amp;vj==edge.vj)&#123;</span><br><span class="line">                return edge.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void printGraph()&#123;</span><br><span class="line">        for (EdgeNode edge:edges)&#123;</span><br><span class="line">            System.out.println(edge.vi + &quot;-&quot; + edge.vj + &quot;-&quot; + edge.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EdgeListGraph graph = new EdgeListGraph();</span><br><span class="line">        int[][] edgesArray = &#123;</span><br><span class="line">                &#123;1, 2, 5&#125;,</span><br><span class="line">                &#123;1, 5, 6&#125;,</span><br><span class="line">                &#123;2, 4, 7&#125;,</span><br><span class="line">                &#123;4, 3, 9&#125;,</span><br><span class="line">                &#123;3, 1, 2&#125;,</span><br><span class="line">                &#123;5, 6, 8&#125;,</span><br><span class="line">                &#123;6, 4, 3&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        graph.createGraph(edgesArray);</span><br><span class="line">        System.out.println(graph.getEdge(3, 4));</span><br><span class="line">        graph.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">1-2-5</span><br><span class="line">1-5-6</span><br><span class="line">2-4-7</span><br><span class="line">4-3-9</span><br><span class="line">3-1-2</span><br><span class="line">5-6-8</span><br><span class="line">6-4-3</span><br></pre></td></tr></table></figure><p>一般来说，边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任何一条边的运算。</p><h1>图的遍历</h1><h2 id="深度优先搜索">深度优先搜索</h2><p><strong>深度优先搜索算法（Depth First Search）</strong>：英文缩写为 DFS，是一种用于搜索树或图结构的算法。深度优先搜索算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void depthFirstSearch(int start)&#123;</span><br><span class="line">        boolean[] visited = new boolean[verCount];</span><br><span class="line">        System.out.println(&quot;Dfs&quot; + start + &quot;:&quot;);</span><br><span class="line">        dfsHelper(start,visited);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    private void  dfsHelper(int vertex,boolean[] visited)&#123;</span><br><span class="line">        visited[vertex] = true;</span><br><span class="line">        System.out.println(vertex + &quot; &quot;);</span><br><span class="line">        for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">            if (adjMatrix[vertex][vj]!=null&amp;&amp;!visited[vj])&#123;</span><br><span class="line">                dfsHelper(vj,visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dfs4:</span><br><span class="line">4 </span><br><span class="line">2 </span><br><span class="line">1 </span><br><span class="line">3 </span><br></pre></td></tr></table></figure><p>但是一般使用递归的时候会出现不可控的错误</p><p>所以我们使用另一种方法</p><p>采用栈堆实现</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void DfsStack(int start)&#123;</span><br><span class="line">        boolean[] visited = new boolean[verCount];</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(start);</span><br><span class="line">        System.out.println(&quot;DFS is &quot; + start + &quot;:&quot;);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            int vertex = stack.pop();</span><br><span class="line">            if (!visited[vertex])&#123;</span><br><span class="line">                visited[vertex] = true;</span><br><span class="line">                System.out.println(vertex + &quot; &quot;);</span><br><span class="line">                for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">                    if (adjMatrix[vertex][vj]!=null&amp;&amp;!visited[vj])&#123;</span><br><span class="line">                        stack.push(vj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索">广度优先搜索</h2><p><strong>广度优先搜索算法（Breadth First Search）</strong>：英文缩写为 BFS，又译作宽度优先搜索 / 横向优先搜索，是一种用于搜索树或图结构的算法。广度优先搜索算法从起始节点开始，逐层扩展，先访问离起始节点最近的节点，后访问离起始节点稍远的节点。以此类推，直到完成整个搜索过程。</p><p><strong>就是一层一层的访问呗</strong></p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void bfs(int start)&#123;</span><br><span class="line">        boolean[] visited = new boolean[verCount];</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        visited[start] = true;</span><br><span class="line">        System.out.println(&quot;Bfs&quot; + start + &quot; :&quot;);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            int vertex = queue.poll();</span><br><span class="line">            System.out.println(vertex + &quot; &quot;);</span><br><span class="line">            for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">                if (adjMatrix[vertex][vj]!=null&amp;&amp;!visited[vj])&#123;</span><br><span class="line">                    visited[vj] = true;</span><br><span class="line">                    queue.add(vj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以借助队列来实现</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;定义-各种分类&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;图（Graph）&lt;/strong&gt;：由顶点的非空有限集合 V&lt;em&gt;V&lt;/em&gt; （由 n&amp;gt;0&lt;em&gt;n&lt;/em&gt;&amp;gt;0 个顶点组成）与边的集合 E&lt;em&gt;E&lt;/em&gt;（顶点之间的关系）构成的结构。其形式化定义为</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="数据结构" scheme="https://mengnankk.asia/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 练习金秋篇</title>
    <link href="https://mengnankk.asia/2024/10/26/javatest2/"/>
    <id>https://mengnankk.asia/2024/10/26/javatest2/</id>
    <published>2024-10-25T16:00:00.000Z</published>
    <updated>2024-11-07T07:05:08.638Z</updated>
    
    <content type="html"><![CDATA[<h1>1.leetcode <a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>'='</code>，要么是 <code>'!'</code></li><li><code>equations[i][2]</code> 是 <code>'='</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class UF &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    private int[] parent;</span><br><span class="line">    private int[] size;</span><br><span class="line">    public UF(int n)&#123;</span><br><span class="line">        this.count = n;</span><br><span class="line">        parent = new int[n];</span><br><span class="line">        size = new int[n];</span><br><span class="line">        for (int i =0;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i] =i;</span><br><span class="line">            size[i] =1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int p,int q)&#123;</span><br><span class="line">        int rootP = find(p);</span><br><span class="line">        int rootQ = find(q);</span><br><span class="line">        if (rootQ==rootP)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (size[rootP]&gt;size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] +=size[rootQ];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] +=size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean connected(int p,int q)&#123;</span><br><span class="line">        int rootQ = find(q);</span><br><span class="line">        int rootP = find(p);</span><br><span class="line">        return rootP ==rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    private int find(int x)&#123;</span><br><span class="line">        while (parent[x]!=x)&#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    public int count()&#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Solution&#123;</span><br><span class="line">    public boolean equationsPossible(String[] equations) &#123;</span><br><span class="line">        UF uf = new UF(26);</span><br><span class="line">        for (String eq : equations) &#123;</span><br><span class="line">            if (eq.charAt(1) == &#x27;=&#x27;) &#123;</span><br><span class="line">                char x = eq.charAt(0);</span><br><span class="line">                char y = eq.charAt(3);</span><br><span class="line">                uf.union(x - &#x27;a&#x27;, y - &#x27;a&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (String eq : equations) &#123;</span><br><span class="line">            if (eq.charAt(1) == &#x27;!&#x27;) &#123;</span><br><span class="line">                char x = eq.charAt(0);</span><br><span class="line">                char y = eq.charAt(3);</span><br><span class="line">                if (uf.connected(x - &#x27;a&#x27;, y - &#x27;a&#x27;)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接使用并查集秒了喵喵喵</p><h1>2.leetcode <a href="https://leetcode.cn/problems/number-of-provinces/description/">省份数量</a></h1><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n == isConnected.length</code></li><li><code>n == isConnected[i].length</code></li><li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li><li><code>isConnected[i][i] == 1</code></li><li><code>isConnected[i][j] == isConnected[j][i]</code></li></ul><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DFS &#123;</span><br><span class="line">    private void dfs(int[] [] isConnected,boolean[] visited,int i)&#123;</span><br><span class="line">        for (int j=0;j&lt;isConnected.length;j++)&#123;</span><br><span class="line">            if (isConnected[i][j]==1&amp;&amp;!visited[j])&#123;</span><br><span class="line">                visited[j] = true;</span><br><span class="line">                dfs(isConnected,visited,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Solution&#123;</span><br><span class="line">        public int findCircleNUm(int[][] isconnected)&#123;</span><br><span class="line">            int n = isconnected.length;</span><br><span class="line">            boolean[] visited = new boolean[n];</span><br><span class="line">            int provinces = 0;</span><br><span class="line">            for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">                if (!visited[i])&#123;</span><br><span class="line">                    dfs(isconnected,visited,i);</span><br><span class="line">                    provinces++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return provinces;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>遍历矩阵 isConnected<em>i<strong>s</strong>C<strong>o</strong>nn<strong>ec</strong>t<strong>e</strong>d</em>。如果 <code>isConnected[i][j] = 1</code>，将 i<em>i</em> 节点和 j<em>j</em> 节点相连。</li><li>然后判断每个城市节点的根节点，然后统计不重复的根节点有多少个，也就是集合个数，即为「省份」的数量。</li></ul><h1>3.leetcode 200. <a href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></h1><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li></ul><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class dfs_leetcode &#123;</span><br><span class="line">    private void dfs(char[][] grid,int i ,int j)&#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int m = grid[0].length;</span><br><span class="line">        if (i&lt;0||i&gt;=n||j&lt;0||j&gt;=m||grid[i][j]==&#x27;0&#x27;)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=&#x27;0&#x27;;</span><br><span class="line">        dfs(grid, i + 1, j); // 向下</span><br><span class="line">        dfs(grid, i - 1, j); // 向上</span><br><span class="line">        dfs(grid, i, j + 1); // 向右</span><br><span class="line">        dfs(grid, i, j - 1); // 向左</span><br><span class="line">    &#125;</span><br><span class="line">    public int numIslands(char[][] grid)&#123;</span><br><span class="line">        if (grid==null||grid.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i=0;i&lt;grid.length;i++)&#123;</span><br><span class="line">            for (int j=0;j&lt;grid[0].length;j++)&#123;</span><br><span class="line">                if (grid[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要就是运用了递归，然后一点一点去找，这个过程就是深度搜索</p><ul><li><strong>时间复杂度</strong>：O(m×n)<em>O</em>(<em>m</em>×<em>n</em>)。其中 m<em>m</em> 和 n<em>n</em> 分别为行数和列数。</li><li><strong>空间复杂度</strong>：O(m×n)<em>O</em>(<em>m</em>×<em>n</em>)。</li></ul><h1>4.leetcode <a href="https://leetcode.cn/problems/clone-graph/">133. 克隆图</a></h1><p>给你无向 <strong><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>这张图中的节点数在 <code>[0, 100]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 100</code></li><li>每个节点值 <code>Node.val</code> 都是唯一的，</li><li>图中没有重复的边，也没有自环。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ul><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Node&#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">    public Node()&#123;</span><br><span class="line">        val = 0;</span><br><span class="line">        neighbors = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    public Node(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        neighbors = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(int val, List&lt;Node&gt; neighbors) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.neighbors = neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class cloneGraph &#123;</span><br><span class="line">    public Node cloneGraph(Node node)&#123;</span><br><span class="line">        Map&lt;Node,Node&gt; lookup = new HashMap&lt;&gt;();</span><br><span class="line">        if (node ==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        Node clone  = new Node(node.val,new ArrayList&lt;&gt;());</span><br><span class="line">        lookup.put(node,clone);</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            Node curr = queue.poll();</span><br><span class="line">            for (Node neighbor:curr.neighbors)&#123;</span><br><span class="line">                if (!lookup.containsKey(neighbor))&#123;</span><br><span class="line">                    Node neighborClone = new Node(neighbor.val,new ArrayList&lt;&gt;());</span><br><span class="line">                    lookup.put(neighbor,neighborClone);</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                lookup.get(curr).neighbors.add(lookup.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(V + E)，其中 V 是图中节点的数量，E 是图中边的数量。每个节点和每条边都会被访问一次。</p><p><strong>空间复杂度</strong>：O(V)，用于存储 <code>lookup</code> 映射表和 BFS 队列。</p><p><strong><code>lookup</code> Map</strong>：这个 <code>HashMap</code> 用于存储原图中的每个节点及其对应的克隆节点。通过这个映射，我们可以避免多次克隆相同的节点。</p><p><strong>空图处理</strong>：如果输入的 <code>node</code> 为 <code>null</code>，则直接返回 <code>null</code>，因为图为空不需要进行克隆。</p><p><strong><code>clone</code></strong>：首先克隆起始节点。克隆时创建了一个新的 <code>Node</code> 对象，并将它放入 <code>lookup</code> 映射中，将原节点 <code>node</code> 和它的克隆节点 <code>clone</code> 关联起来。</p><p><strong>队列初始化</strong>：创建一个队列 <code>queue</code>，用于广度优先搜索（BFS）。把原图的起始节点 <code>node</code> 加入队列中。</p><p><strong>BFS 循环</strong>：当队列非空时，继续从队列中取出节点 <code>curr</code>，并访问它的邻居。</p><ul><li><p>访问邻居节点</p><p>：对于当前节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curr</span><br></pre></td></tr></table></figure><p>的每个邻居</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neighbor</span><br></pre></td></tr></table></figure><p>，检查它是否已经被克隆过：</p><ul><li>如果该邻居尚未被克隆，则创建一个新节点 <code>neighborClone</code>，并将其加入到 <code>lookup</code> 中。</li><li>如果该邻居已经被克隆过，直接通过 <code>lookup.get(neighbor)</code> 获取该邻居的克隆节点。</li></ul></li><li><p><strong>建立邻接关系</strong>：无论邻居节点是否是第一次被克隆，都要将克隆的邻居节点添加到当前节点 <code>curr</code> 的克隆节点的 <code>neighbors</code> 列表中。</p></li></ul><p>通过这个过程，我们逐渐构建出图的克隆，且保证每个节点和邻居关系都能被正确地克隆出来。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;1.leetcode &lt;a href=&quot;https://leetcode.cn/problems/satisfiability-of-equality-equations/&quot;&gt;990.</summary>
        
      
    
    
    
    <category term="java" scheme="https://mengnankk.asia/categories/java/"/>
    
    
    <category term="java" scheme="https://mengnankk.asia/tags/java/"/>
    
    <category term="数据结构" scheme="https://mengnankk.asia/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux shell编程进阶</title>
    <link href="https://mengnankk.asia/2024/10/18/linux10/"/>
    <id>https://mengnankk.asia/2024/10/18/linux10/</id>
    <published>2024-10-17T16:00:00.000Z</published>
    <updated>2024-10-27T07:33:23.591Z</updated>
    
    <content type="html"><![CDATA[<h1>基本脚本</h1><h3 id="echo-使用">echo 使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出普通字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="comment"># Output: hello, world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含变量的字符串</span></span><br><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, \&quot;<span class="variable">$&#123;name&#125;</span>\&quot;&quot;</span></span><br><span class="line"><span class="comment"># Output: hello, &quot;zp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;YES\nNO&quot;</span> </span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># YES</span></span><br><span class="line"><span class="comment"># NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容定向至文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出执行结果</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment"># Output: (当前目录路径)</span></span><br></pre></td></tr></table></figure><p>示例脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;aaa,mmmmmmmm&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;aaaa\naaaa&quot;</span></span><br><span class="line">name=woshini</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;name is <span class="variable">$&#123;name&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaa,mmmmmmmm</span><br><span class="line">aaaa</span><br><span class="line">name is woshini</span><br><span class="line">/home/mengnankk/shellcode</span><br></pre></td></tr></table></figure><h3 id="exit">exit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">var1=4</span><br><span class="line">var2=6</span><br><span class="line">var3=$((<span class="variable">$var1</span> + <span class="variable">$var2</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var3</span>&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 5</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="printf">printf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%d %s\n&#x27;</span> 1 <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment"># Output: 1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 姓名 性别 体重kg</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br></pre></td></tr></table></figure><h3 id="expr">expr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">r=$[2+3]</span><br><span class="line">temp=`<span class="built_in">expr</span> 2 + 4`</span><br><span class="line">res=`<span class="built_in">expr</span> <span class="variable">$temp</span> \* 4`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ress=<span class="variable">$res</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ress=24</span><br></pre></td></tr></table></figure><h3 id="bc">bc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=`<span class="built_in">echo</span> <span class="string">&quot;scale=4; <span class="variable">$var1</span> / <span class="variable">$var2</span>&quot;</span> | bc`</span><br><span class="line"><span class="built_in">echo</span> The answer <span class="keyword">for</span> this is <span class="variable">$var3</span></span><br></pre></td></tr></table></figure><h3 id="字符串操作">字符串操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;qinjx&quot;</span></span><br><span class="line">greeting=<span class="string">&quot;hello, <span class="variable">$&#123;your_name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span></span><br><span class="line"><span class="comment"># 获取字符串长度</span></span><br><span class="line">string=<span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment"># 输出：4</span></span><br><span class="line"><span class="comment"># 提取子字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment"># 输出：liba</span></span><br></pre></td></tr></table></figure><h3 id="数组">数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums=( [2]=2 [0]=0 [1]=1 )</span><br><span class="line">colors=( red yellow <span class="string">&quot;dark blue&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问数组的单个元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span> <span class="comment"># Output: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span> <span class="comment"># Output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向数组中添加元素</span></span><br><span class="line">colors=( white <span class="string">&quot;<span class="variable">$&#123;colors[@]&#125;</span>&quot;</span> green black )</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span> <span class="comment"># Output: white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure><h1>信号</h1><h2 id="捕捉信号">捕捉信号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;sorry&#x27;&quot;</span> SIGINT SIGTERM</span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 10 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;loop #<span class="variable">$count</span>&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> 5</span><br><span class="line">    count=$((count + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="捕捉脚本的退出">捕捉脚本的退出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo bybyb&quot;</span> EXIT</span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Loop #<span class="variable">$count</span>&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> 3</span><br><span class="line">    count=$((count + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1>操作符</h1><h2 id="关系运算符">关系运算符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="comment"># 10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="comment"># 10 -gt 20: x 大于 y</span></span><br><span class="line"><span class="comment"># 10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="comment"># 10 -ge 20: x 大于或等于 y</span></span><br><span class="line"><span class="comment"># 10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure><h2 id="字符串运算符">字符串运算符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ -n string ]] <span class="comment"># 判断字符串非空</span></span><br><span class="line">[[ -z string ]] <span class="comment"># 判断字符串为空</span></span><br><span class="line">[[ string1 = string2 ]] <span class="comment"># 判断字符串相等</span></span><br><span class="line">[[ string1 != string2 ]] <span class="comment"># 判断字符串不相等</span></span><br></pre></td></tr></table></figure><h2 id="文件测试运算符">文件测试运算符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-r <span class="comment"># 检测文件是否可读</span></span><br><span class="line">-w <span class="comment"># 检测文件是否可写</span></span><br><span class="line">-x <span class="comment"># 检测文件是否可执行</span></span><br><span class="line">-f <span class="comment"># 检测是否为普通文件</span></span><br><span class="line">-d <span class="comment"># 检测是否为目录</span></span><br><span class="line">-s <span class="comment"># 检测是否非空</span></span><br><span class="line">-e <span class="comment"># 检测文件是否存在</span></span><br></pre></td></tr></table></figure><p>这份内容结构更加清晰，方便阅读和理解！如果需要进一步修改或添加，请告诉我。</p><h2 id="逻辑运算符">逻辑运算符</h2><p>主要还是&amp;&amp;和||</p><p>除了这些还有</p><p><strong>!表示非</strong></p><p><strong><code>-o</code> 和 <code>-a</code></strong>：在 <code>[ ... ]</code> 或 <code>test</code> 命令中使用，分别表示逻辑或和逻辑与（不推荐使用，建议使用 <code>||</code> 和 <code>&amp;&amp;</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码[ condition1 -o condition2 ]  # condition1 或 condition2</span><br><span class="line">[ condition1 -a condition2 ]  # condition1 和 condition2</span><br></pre></td></tr></table></figure><h1>文件操作</h1><h2 id="创建临时文件">创建临时文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">tempFile=`mktemp test.XXXXXX`</span><br><span class="line">exec 3&gt;$&#123;tempFile&#125;</span><br><span class="line">echo &quot;This is the first line&quot; &gt;&amp;3</span><br><span class="line">echo &quot;This is the second line&quot; &gt;&amp;3</span><br><span class="line">echo &quot;This is the last line&quot; &gt;&amp;3</span><br><span class="line">exec 3&gt;&amp;-</span><br><span class="line">cat $&#123;tempFile&#125;</span><br><span class="line">rm -f $&#123;tempFile&#125; 2&gt; /dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ ./file.sh</span><br><span class="line">This is the first line</span><br><span class="line">This is the second line</span><br><span class="line">This is the last line</span><br></pre></td></tr></table></figure><p>注意mktemp 命令创建临时文件的时候</p><p><strong>mktemp<code>命令要求模板中包含至少 6 个</code>X</strong></p><h2 id="创建临时目录">创建临时目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">tempFile=mktemp -d dir.XXXXXX</span><br><span class="line">cd $&#123;tempFile&#125;|exit 1</span><br><span class="line">tempFile1=mktemp temp.XXXXXX</span><br><span class="line">tempFile2=mktemp temp2.XXXXXX</span><br><span class="line">exec 7&gt; $&#123;tempFile1&#125;</span><br><span class="line">exec 8&gt; $&#123;tempFile2&#125;</span><br><span class="line">echo &quot;This is a test line of data for $tempFile1&quot; &gt;&amp;7</span><br><span class="line">echo &quot;This is a test line of data for $tempFile2&quot; &gt;&amp;8</span><br></pre></td></tr></table></figure><p>return</p><p>创建成功</p><p>还有一个改进版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line"></span><br><span class="line"># 创建一个临时目录</span><br><span class="line">tempFile=$(mktemp -d dir.XXXXXX)</span><br><span class="line"></span><br><span class="line"># 切换到临时目录</span><br><span class="line">cd &quot;$&#123;tempFile&#125;&quot; || exit 1</span><br><span class="line"></span><br><span class="line"># 在临时目录中创建临时文件</span><br><span class="line">tempFile1=$(mktemp temp.XXXXXX)</span><br><span class="line">tempFile2=$(mktemp temp2.XXXXXX)</span><br><span class="line"></span><br><span class="line"># 打开文件描述符并向临时文件写入数据</span><br><span class="line">exec 7&gt; &quot;$&#123;tempFile1&#125;&quot;</span><br><span class="line">exec 8&gt; &quot;$&#123;tempFile2&#125;&quot;</span><br><span class="line">echo &quot;This is a test line of data for $tempFile1&quot; &gt;&amp;7</span><br><span class="line">echo &quot;This is a test line of data for $tempFile2&quot; &gt;&amp;8</span><br><span class="line"></span><br><span class="line"># 关闭文件描述符</span><br><span class="line">exec 7&gt;&amp;-</span><br><span class="line">exec 8&gt;&amp;-</span><br><span class="line"></span><br><span class="line"># 显示临时文件内容</span><br><span class="line">echo &quot;Contents of $tempFile1:&quot;</span><br><span class="line">cat &quot;$&#123;tempFile1&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Contents of $tempFile2:&quot;</span><br><span class="line">cat &quot;$&#123;tempFile2&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 删除临时文件</span><br><span class="line">rm -f &quot;$&#123;tempFile1&#125;&quot; &quot;$&#123;tempFile2&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 删除临时目录</span><br><span class="line">rmdir &quot;$&#123;tempFile&#125;&quot; || echo &quot;Failed to remove directory $&#123;tempFile&#125;: It may not be empty.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;基本脚本&lt;/h1&gt;
&lt;h3 id=&quot;echo-使用&quot;&gt;echo 使用&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="Linux" scheme="https://mengnankk.asia/tags/Linux/"/>
    
    <category term="shell" scheme="https://mengnankk.asia/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>瑞吉外卖解析</title>
    <link href="https://mengnankk.asia/2024/10/18/reggie/"/>
    <id>https://mengnankk.asia/2024/10/18/reggie/</id>
    <published>2024-10-17T16:00:00.000Z</published>
    <updated>2024-12-11T07:12:58.388Z</updated>
    
    <content type="html"><![CDATA[<h1>公共字段解析</h1><p>在使用的时候，有一些字段是一直在使用的。我们为了方便会使用MyBatis-Plus 提供的注解来完成这个功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 创建时间 *公共字段要进行加注解/</span><br><span class="line">   @TableField(fill = FieldFill.INSERT) // 自动填充，插入时自动填充</span><br><span class="line">   private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">   /** 更新时间 */</span><br><span class="line">   @TableField(fill = FieldFill.INSERT_UPDATE) // 自动填充，插入和更新时自动填充</span><br><span class="line">   private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">   @TableField(fill = FieldFill.INSERT) // 自动填充，插入时自动填充</span><br><span class="line">   private Long createUser;</span><br><span class="line"></span><br><span class="line">   @TableField(fill = FieldFill.INSERT_UPDATE) // 自动填充，插入和更新时自动填充</span><br><span class="line">   private Long updateUser;</span><br></pre></td></tr></table></figure><p>比如这四个是经常使用的公共字段</p><p>给他们加上注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@TableField(fill = FieldFill.INSERT)</span><br></pre></td></tr></table></figure><p>前面是注解，后面fill后面的是文件填充的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum FieldFill &#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    INSERT,</span><br><span class="line">    UPDATE,</span><br><span class="line">    INSERT_UPDATE;</span><br><span class="line"></span><br><span class="line">    private FieldFill() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看源码就会发现他有四种填充的方式</p><p><strong><code>DEFAULT</code></strong>: 不进行自动填充。</p><p><strong><code>INSERT</code></strong>: 仅在插入时自动填充。</p><p><strong><code>UPDATE</code></strong>: 仅在更新时自动填充。</p><p><strong><code>INSERT_UPDATE</code></strong>: 在插入和更新时都会自动填充。</p><p>然后我们在common包下加入一个类用来实现这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br></pre></td></tr></table></figure><p>使用这两个注解</p><p>分别使用日志和Spring的注解</p><p>分别实现两个方法</p><p>一个是insertFill</p><p>一个是updateFill</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;公共字段自动填充[insert]...&quot;);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line">        metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(&quot;createUser&quot;, BaseContext.getCurrentId());     // 从 ThreadLocal 中获取当前用户的 id</span><br><span class="line">        metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId());     // 从 ThreadLocal 中获取当前用户的 id</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;公共字段自动填充[update]...&quot;);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line"></span><br><span class="line">        long id = Thread.currentThread().getId();                            // 获取当前线程的id</span><br><span class="line">        log.info(&quot;当前线程id=&#123;&#125;&quot;, id);                                        // Slf4j的日志输出</span><br><span class="line"></span><br><span class="line">        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId());  // 从ThreadLocal中获取当前线程的用户id</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1>菜品分类解析</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;添加分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @PostMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&lt;Category&gt;&gt; page(int page, int pageSize) &#123;</span><br><span class="line">        Page&lt;Category&gt; categoryPage = new Page&lt;&gt;(page, pageSize);</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        // 通过实例调用 page 方法</span><br><span class="line">        categoryService.page(categoryPage, queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(categoryPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>要做一个新的Controller</p><p>必须有一个类，然后里面定义各种数据</p><p>然后有一个Serivice接口</p><p>一个Serviceimpl类</p><p>一个Mapper接口</p><p>然后在Controller 里写具体的方法</p><h2 id="1-添加分类">1.添加分类</h2><p>先设计一个Api请求的方法</p><p>然后定义</p><p><strong><code>@Autowired private CategoryService categoryService;</code></strong>：使用 <code>@Autowired</code> 注解，将 <code>CategoryService</code> 服务自动注入到控制器中。<code>CategoryService</code> 包含保存 <code>Category</code> 对象的逻辑。</p><p>然后开始写具体的方法，save作为添加方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public R&lt;String&gt; save(@RequestBody Category category)</span><br></pre></td></tr></table></figure><p><strong><code>@PostMapping</code></strong>：标注该方法为 HTTP POST 请求的映射。客户端通过发送 POST 请求来触发该方法。就是接受浏览器的post请求</p><p><strong><code>public R&lt;String&gt; save</code></strong>：方法返回类型为 <code>R&lt;String&gt;</code>，其中 <code>R</code> 是一个泛型响应包装类，返回一个包含字符串信息的响应。</p><p><strong><code>@RequestBody Category category</code></strong>：使用 <code>@RequestBody</code> 注解，将请求中的 JSON 数据反序列化为一个 <code>Category</code> 对象，作为 <code>save</code> 方法的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;添加分类成功&quot;);</span><br></pre></td></tr></table></figure><p>首先是日志提示</p><p>然后**<code>categoryService.save(category);</code>**：调用 <code>CategoryService</code> 的 <code>save</code> 方法，将 <code>category</code> 对象存储到数据库中。这个 <code>save</code> 方法通常由 MyBatis-Plus 框架提供，<code>CategoryService</code> 通过继承 <code>IService&lt;Category&gt;</code> 或实现相关接口来提供该方法。这个需要在接口的时候继承</p><p>然后返回响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return R.success(&quot;添加分类成功&quot;);</span><br></pre></td></tr></table></figure><p>总体代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;添加分类成功&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-分页查询">2.分页查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/page&quot;)</span><br></pre></td></tr></table></figure><p>接受post请求，然后url栏中做出响应的回应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public R&lt;Page&lt;Category&gt;&gt; page(int page, int pageSize)</span><br></pre></td></tr></table></figure><p>定义page方法</p><p>里面加入page和pageSize参数，注意要使用大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;Category&gt; categoryPage = new Page&lt;&gt;(page, pageSize);</span><br></pre></td></tr></table></figure><p>新建一个Page构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br></pre></td></tr></table></figure><p>这里面是条件过滤，按照升序进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过实例调用 page 方法</span><br><span class="line">        categoryService.page(categoryPage, queryWrapper);</span><br></pre></td></tr></table></figure><p>调用接口的page方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return R.success(categoryPage);</span><br></pre></td></tr></table></figure><p>返回数据</p><p>一般的分页查询都是这样做的</p><p>例如：</p><p>之前的Employee</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&lt;Employee&gt;&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line">        log.info(&quot;分页查询，page=&#123;&#125;, pageSize=&#123;&#125;, name=&#123;&#125;&quot;, page, pageSize, name);</span><br><span class="line"></span><br><span class="line">        // 分页构造器</span><br><span class="line">        com.baomidou.mybatisplus.extension.plugins.pagination.Page&lt;Employee&gt; pageInfo = new Page&lt;&gt;(page, pageSize);</span><br><span class="line"></span><br><span class="line">        // 条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        if (StringUtils.hasText(name)) &#123;  // 修正为 hasText 以避免空白字符串的情况</span><br><span class="line">            queryWrapper.like(Employee::getName, name);</span><br><span class="line">        &#125;</span><br><span class="line">        queryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        // 执行查询</span><br><span class="line">        employeeService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        // 返回分页结果</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>差不多都是一个模板</p><h2 id="3-删除分类">3.删除分类</h2><p>首先还是和之前的controller一样，先新建mapper 和Service和ServiceImpl</p><p>因为需要检测是不是和其他的东西（例如菜品，菜单有关联）所以他们的mapper和Service和Serviceimpl也需要新建</p><p>然后controller调用的时候需要一个remove方法</p><p>所以在CategoryService下需要实现一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ublic void remove(Long id);</span><br></pre></td></tr></table></figure><p>remove方法</p><p>在CategoryServiceimpl写具体的remove方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param id</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Long id) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);</span><br><span class="line">        int count1 =  dishService.count(dishLambdaQueryWrapper);</span><br><span class="line">        if (count1&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了菜品，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);</span><br><span class="line">        int count2 = setmealService.count();</span><br><span class="line">        if (count2&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        super.removeById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先新建remove方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br></pre></td></tr></table></figure><p>条件过滤器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);</span><br></pre></td></tr></table></figure><p>通过等于id来过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count1 =  dishService.count(dishLambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>然后记录次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (count1&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了菜品，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>非0的时候不能删除</p><p>然后下面的相似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);</span><br><span class="line">        int count2 = setmealService.count();</span><br><span class="line">        if (count2&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>最后如果上面的都没成立的话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.removeById(id);</span><br></pre></td></tr></table></figure><p>再去调用父类的remove方法，就是mybatisplus所提供的removeById的方法</p><p>然后最后在controller里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@DeleteMapping//注意是ids哦</span><br><span class="line">   public R&lt;String&gt; delete(Long ids)&#123;</span><br><span class="line">       log.info(&quot;删除id为&#123;&#125;&quot;,ids);</span><br><span class="line">       categoryService.remove(ids);</span><br><span class="line">       return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用上面自定义的remove方法</p><h1>文件上传和下载</h1><p>文件上传和下载是一个重要的功能</p><p>直接创建一个commonController.java</p><p>然后注解为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br></pre></td></tr></table></figure><p>代表是controller</p><p>然后页面为./common</p><p>日志</p><p>然后导入文件地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">   private String basePath;</span><br></pre></td></tr></table></figure><p>注意@value是spring包下面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reggie:</span><br><span class="line">  # 文件存储位置信息|必填</span><br><span class="line">  path: C:\Users\river\code\work\javaProjects\rikky-takeaway\img\</span><br></pre></td></tr></table></figure><p>application配置</p><h2 id="upload方法">upload方法</h2><p>然后开始写upload方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file) &#123;</span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        String orginname = file.getOriginalFilename();//原始文件名</span><br><span class="line">        String suffix = orginname.substring(orginname.lastIndexOf(&quot;.&quot;));</span><br><span class="line">        String uuidname = UUID.randomUUID().toString()+suffix;</span><br><span class="line"></span><br><span class="line">        File dir  = new File(basePath);</span><br><span class="line">        if (!dir.exists())&#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.transferTo(new File(basePath+uuidname));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        return R.success(uuidname);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>文件上传在浏览器中以post请求来实现</p><p>所以注解为postMapping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String orginname = file.getOriginalFilename();//原始文件名</span><br><span class="line">String suffix = orginname.substring(orginname.lastIndexOf(&quot;.&quot;));</span><br><span class="line">String uuidname = UUID.randomUUID().toString()+suffix;</span><br></pre></td></tr></table></figure><p>suffix代表 的是文件的后缀名</p><p>uuid生成一个uuid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File dir  = new File(basePath);</span><br><span class="line">if (!dir.exists())&#123;</span><br><span class="line">    dir.mkdirs(</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一下是否存在</p><p>不存在创建</p><p>]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.transferTo(new File(basePath+uuidname));</span><br></pre></td></tr></table></figure><p>最后上传，为地址加上uuid的Name</p><p>然后返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return R.success(uuidname);</span><br></pre></td></tr></table></figure><h2 id="download方法">download方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/download&quot;)</span><br><span class="line">    public void download(String name, HttpServletResponse response) &#123;</span><br><span class="line">        try (FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));</span><br><span class="line">             ServletOutputStream servletOutputStream = response.getOutputStream()) &#123;</span><br><span class="line"></span><br><span class="line">            response.setContentType(&quot;image/jpeg&quot;);</span><br><span class="line">            byte[] bytes = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line"></span><br><span class="line">            while ((len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">                servletOutputStream.write(bytes, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            servletOutputStream.flush();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            // 文件未找到的处理逻辑</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            log.error(&quot;File not found: &quot; + name, e);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // 其他I/O异常处理</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">            log.error(&quot;Error occurred during file download&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>download就是get方法了</p><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));</span><br><span class="line">             ServletOutputStream servletOutputStream = response.getOutputStream())</span><br></pre></td></tr></table></figure><p>去读取这个文件</p><p>设置类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;image/jpeg&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] bytes = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line"></span><br><span class="line">            while ((len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">                servletOutputStream.write(bytes, 0, len);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>去讲文件内的内容给读取出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servletOutputStream.flush();</span><br></pre></td></tr></table></figure><p>刷新流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catch (FileNotFoundException e) &#123;</span><br><span class="line">            // 文件未找到的处理逻辑</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            log.error(&quot;File not found: &quot; + name, e);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // 其他I/O异常处理</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">            log.error(&quot;Error occurred during file download&quot;, e);</span><br></pre></td></tr></table></figure><p>异常处理</p><p>使用这个结构的时候，流会自动关闭所以不用了</p><h1>新建菜品</h1><p>还是跟之前的一样，先新建Mapping，然后新建Service，然后再新建ServiceImpl</p><p>最后写Controller</p><h2 id="所选分类">所选分类</h2><p>这个和分类有关，所以放在Categorycontroller下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据条件查询数据</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Category&gt;&gt; list(Category category)&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.eq(category.getType()!=null,Category::getType,category.getType());</span><br><span class="line">    lambdaQueryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line">    categoryService.list(lambdaQueryWrapper);</span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">    return R.success(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/list&quot;)</span><br></pre></td></tr></table></figure><p>和前端像对应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Category&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaQueryWrapper.eq(category.getType()!=null,Category::getType,category.getType());</span><br><span class="line">lambdaQueryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br></pre></td></tr></table></figure><p>条件过滤一下啊</p><p>瞎看type是不是等于空，然后按sort来升序，再按更新时间来降序排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categoryService.list(lambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>然后Service列出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Category&gt; list = categoryService.list(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br></pre></td></tr></table></figure><p>把结果放List里面然后返回结果</p><h2 id="提交数据">提交数据</h2><p>想要把前端所写的数据提交到后端，对数据库进行更改就要将其用json格式提交</p><p>就要导入dto类型</p><p>在项目的包下新建dto包，然后导入类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.mengnankk.dto;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.mengnankk.entity.Dish;</span><br><span class="line">import com.mengnankk.entity.DishFlavor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private String categoryName;</span><br><span class="line"></span><br><span class="line">    private Integer copies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为是新增菜品，所以要在DishController下新增方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorServiceImpl dishFlavorService;</span><br><span class="line"></span><br><span class="line">@PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto)&#123;</span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;新增成功&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>新增save方法，将其转为类型后回显</p><p>然后还涉及到菜品的口味，所以DishFlavor相关的Service和ServiceImpl都要建立对应的实现</p><p>Service建立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface DishFlavorService extends IService&lt;DishFlavor&gt; &#123;</span><br><span class="line">    // 保存菜品及其口味</span><br><span class="line">    R&lt;String&gt; saveWithFlavor(DishDto dishDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Impl进行具体方法的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private DishService dishService;  // 注入 DishService 用于保存菜品</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public R&lt;String&gt; saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        log.info(&quot;开始录入信息&quot;);</span><br><span class="line">        // 1. 保存菜品信息</span><br><span class="line">        Dish dish = new Dish();</span><br><span class="line">        // 假设 DishDto 中有名称、类别等属性，复制到 Dish 实体</span><br><span class="line">        dish.setName(dishDto.getName());</span><br><span class="line">        dish.setCategoryId(dishDto.getCategoryId());</span><br><span class="line">        // 其他属性的复制...</span><br><span class="line"></span><br><span class="line">        // 保存菜品实体</span><br><span class="line">        dishService.save(dish);  // 调用 DishService 保存菜品</span><br><span class="line"></span><br><span class="line">        // 2. 获取保存后的菜品 ID</span><br><span class="line">        Long dishID = dish.getId();</span><br><span class="line">        if (dishID == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;保存菜品时未能生成 ID&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 保存口味数据</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors().stream().map(item -&gt; &#123;</span><br><span class="line">            item.setDishId(dishID);  // 设置每个口味的菜品 ID</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        // 批量保存口味</span><br><span class="line">        this.saveBatch(flavors);</span><br><span class="line">        return R.success(&quot;新增成功&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体的注释上都写了</p><p>然后这项功能算是这样就写完了</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;公共字段解析&lt;/h1&gt;
&lt;p&gt;在使用的时候，有一些字段是一直在使用的。我们为了方便会使用MyBatis-Plus 提供的注解来完成这个功能&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
        
      
    
    
    
    <category term="java" scheme="https://mengnankk.asia/categories/java/"/>
    
    <category term="项目" scheme="https://mengnankk.asia/categories/java/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="java" scheme="https://mengnankk.asia/tags/java/"/>
    
    <category term="springboot" scheme="https://mengnankk.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Linux 运维篇</title>
    <link href="https://mengnankk.asia/2024/10/14/linux9/"/>
    <id>https://mengnankk.asia/2024/10/14/linux9/</id>
    <published>2024-10-13T16:00:00.000Z</published>
    <updated>2024-10-17T13:38:17.978Z</updated>
    
    <content type="html"><![CDATA[<h1>网络运维</h1><h2 id="无法访问外网的域名">无法访问外网的域名</h2><p>应该就是dns解析出了问题</p><p>我们就要在hosts解析里进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;192.168.0.1 hostname&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><p>在文件中添加本机ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ hostname</span><br><span class="line">mengnankk-linux</span><br></pre></td></tr></table></figure><p>配置信赖的 DNS 服务器</p><p>执行 <code>vi /etc/resolv.conf</code> ，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>一个是国内老牌的</p><p>一个是谷歌的dns解析</p><p>然后ping一下是不是能ping通</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">❯ ping mengnankk.asia</span><br><span class="line">PING mengnankk.asia (76.76.21.93) 56(84) bytes of data.</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=1 ttl=128 time=95.4 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=2 ttl=128 time=121 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=3 ttl=128 time=118 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=4 ttl=128 time=106 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=5 ttl=128 time=149 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=6 ttl=128 time=97.2 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=7 ttl=128 time=125 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=8 ttl=128 time=116 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=9 ttl=128 time=103 ms</span><br><span class="line">^C</span><br><span class="line">--- mengnankk.asia ping statistics ---</span><br><span class="line">9 packets transmitted, 9 received, 0% packet loss, time 8015ms</span><br><span class="line">rtt min/avg/max/mdev = 95.444/114.418/148.506/15.561 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok了可以ping通说明我们已经配置成功了</p><h2 id="网卡配置">网卡配置</h2><p>使用root权限编辑</p><p><code>/etc/sysconfig/network-scripts/ifcfg-eno16777736X</code> 文件</p><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet                        # 网络类型：Ethernet以太网</span><br><span class="line">BOOTPROTO=none                       # 引导协议：自动获取、static静态、none不指定</span><br><span class="line">DEFROUTE=yes                         # 启动默认路由</span><br><span class="line">IPV4_FAILURE_FATAL=no                # 不启用IPV4错误检测功能</span><br><span class="line">IPV6INIT=yes                         # 启用IPV6协议</span><br><span class="line">IPV6_AUTOCONF=yes                    # 自动配置IPV6地址</span><br><span class="line">IPV6_DEFROUTE=yes                    # 启用IPV6默认路由</span><br><span class="line">IPV6_FAILURE_FATAL=no                # 不启用IPV6错误检测功能</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_PRIVACY=&quot;no&quot;</span><br><span class="line"></span><br><span class="line">NAME=eno16777736                     # 网卡设备的别名（需要和文件名同名）</span><br><span class="line">UUID=90528772-9967-46da-b401-f82b64b4acbc  # 网卡设备的UUID唯一标识号</span><br><span class="line">DEVICE=eno16777736                   # 网卡的设备名称</span><br><span class="line">ONBOOT=yes                           # 开机自动激活网卡</span><br><span class="line">IPADDR=192.168.1.199                 # 网卡的固定IP地址</span><br><span class="line">PREFIX=24                            # 子网掩码</span><br><span class="line">GATEWAY=192.168.1.1                  # 默认网关IP地址</span><br><span class="line">DNS1=8.8.8.8                         # DNS域名解析服务器的IP地址</span><br></pre></td></tr></table></figure><p>修改完后，执行 <code>systemctl restart network.service</code> 重启网卡服务。</p><h2 id="系统维护">系统维护</h2><h3 id="Linux-开机自启动脚本">Linux 开机自启动脚本</h3><p><strong>（1）在 <code>/etc/rc.local</code> 文件中添加命令</strong></p><p>如果不想将脚本粘来粘去，或创建链接，可以在 <code>/etc/rc.local</code> 文件中添加启动命令</p><ol><li>先修改好脚本，使其所有模块都能在任意目录启动时正常执行;</li><li>再在 <code>/etc/rc.local</code> 的末尾添加一行以绝对路径启动脚本的行;</li></ol><p>例：</p><p>执行 <code>vim /etc/rc.local</code> 命令，输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line"># This script will be executed *after* all the other init scripts.</span><br><span class="line"># You can put your own initialization stuff in here if you don&#x27;t</span><br><span class="line"># want to do the full Sys V style init stuff.</span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/opt/pjt_test/test.pl</span><br></pre></td></tr></table></figure><p>这个感觉比较舒服</p><p><strong>（2）在 <code>/etc/rc.d/init.d</code> 目录下添加自启动脚本</strong></p><p>Linux 在 <code>/etc/rc.d/init.d</code> 下有很多的文件，每个文件都是可以看到内容的，其实都是一些 shell 脚本或者可执行二进制文件。</p><p>Linux 开机的时候，会加载运行 <code>/etc/rc.d/init.d</code> 目录下的程序，因此我们可以把想要自动运行的脚本放到这个目录下即可。系统服务的启动就是通过这种方式实现的。</p><p><strong>(3)现在新使用systemctl服务来添加自启动的脚本</strong></p><p>先保存好要使用的脚本，然后确定对脚本有可执行权限</p><p><strong>创建一个 <code>systemd</code> 服务文件</strong>： 在 <code>/etc/systemd/system/</code> 目录下创建一个服务文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo nano /etc/systemd/system/clashvpn.service</span><br></pre></td></tr></table></figure><p>然后对文件进行编辑</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Run the shell script at startup</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/zsh /home/mengnankk/shellcoode/clash.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后重新加载，设置自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">❯ sudo systemctl enable clashvpn.service</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/clashvpn.service → /etc/systemd/system/clashvpn.service.</span><br></pre></td></tr></table></figure><p>然后查看启动，查看当前状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo systemctl start clashvpn.service</span><br><span class="line">❯ sudo systemctl status clashvpn.service</span><br><span class="line">● clashvpn.service - Run the clash shell script at startup</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/clashvpn.service; enabled; vendor pres&gt;</span><br><span class="line">     Active: active (running) since Wed 2024-10-16 18:31:28 CST; 20s ago</span><br><span class="line">   Main PID: 18080 (zsh)</span><br><span class="line">      Tasks: 12 (limit: 4551)</span><br></pre></td></tr></table></figure><p>ps和查看一下自启动是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ ps -aux|rg clash</span><br><span class="line">mengnan+   11952  0.0  0.0  13712  3840 pts/0    S+   18:24   0:00 /bin/zsh ./shclash.sh</span><br><span class="line">root       18080  0.0  0.0  13708  3840 ?        Ss   18:31   0:00 /bin/zsh /home/mengnankk/shellcode/shclash.sh</span><br><span class="line">mengnan+   18339  0.0  0.1   8456  5888 pts/1    S+   18:32   0:00 rg clash</span><br><span class="line">❯ sudo systemctl is-enabled clashvpn.service</span><br><span class="line">enabled</span><br></pre></td></tr></table></figure><p>发现成功了捏</p><p>我们重新启动一下，看看是不能用上哈</p><h1>环境配置</h1><h2 id="maven的安装">maven的安装</h2><p>进入官网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://maven.apache.org/download.cgi</span><br></pre></td></tr></table></figure><p>然后下载合适的版本</p><p>然后解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo tar -xzvf apache-maven-3.9.9-bin.tar.gz -C /opt/maven --strip-components=1</span><br></pre></td></tr></table></figure><p>输入 <code>vim /etc/profile</code> ，添加环境变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/opt/maven/apache-maven-3.9.9</span><br><span class="line">export PATH=$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>编辑然后执行生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo vim /etc/profile</span><br><span class="line">❯ source /etc/profile</span><br></pre></td></tr></table></figure><p>mvn -v 查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ mvn -v</span><br><span class="line">Apache Maven 3.9.9 (8e8579a9e76f7d015ee5ec7bfcdc97d260186937)</span><br><span class="line">Maven home: /opt/maven</span><br><span class="line">Java version: 11.0.24, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;6.8.0-47-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure><h2 id="nodejs安装">nodejs安装</h2><p>执行安装脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">❯ rm -rf ~/.nvm</span><br><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br><span class="line">. ~/.nvm/nvm.sh</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 12540  100 12540    0     0  14905      0 --:--:-- --:--:-- --:--:-- 14928</span><br><span class="line">=&gt; Downloading nvm from git to &#x27;/home/mengnankk/.nvm&#x27;</span><br><span class="line">=&gt; 正克隆到 &#x27;/home/mengnankk/.nvm&#x27;...</span><br><span class="line">remote: Enumerating objects: 264, done.</span><br><span class="line">remote: Counting objects: 100% (264/264), done.</span><br><span class="line">remote: Compressing objects: 100% (230/230), done.</span><br><span class="line">remote: Total 264 (delta 31), reused 102 (delta 24), pack-reused 0 (from 0)</span><br><span class="line">接收对象中: 100% (264/264), 116.38 KiB | 384.00 KiB/s, 完成.</span><br><span class="line">处理 delta 中: 100% (31/31), 完成.</span><br><span class="line">注意：正在切换到 &#x27;7ad6d98cedde01809e32d56ab8ced064f6f28175&#x27;。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 false 来关闭此建议</span><br><span class="line"></span><br><span class="line">=&gt; Compressing and cleaning up git repository</span><br><span class="line"></span><br><span class="line">=&gt; Appending nvm source string to /home/mengnankk/.zshrc</span><br><span class="line">=&gt; Appending bash_completion source string to /home/mengnankk/.zshrc</span><br><span class="line">=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:</span><br><span class="line"></span><br><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br><span class="line">❯  nvm --version</span><br><span class="line">0.33.8</span><br></pre></td></tr></table></figure><p>然后查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 8.9.4</span><br><span class="line">nvm use 8.9.4</span><br></pre></td></tr></table></figure><p>使用指令安装指定版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ nvm install 8.9.4</span><br><span class="line">nvm use 8.9.4</span><br><span class="line">Version &#x27;8.9.4&#x27; not found - try `nvm ls-remote` to browse available versions.</span><br><span class="line">N/A: version &quot;8.9.4 -&gt; N/A&quot; is not yet installed.</span><br><span class="line"></span><br><span class="line">You need to run &quot;nvm install 8.9.4&quot; to install it before using it.</span><br></pre></td></tr></table></figure><p>但我折腾了半天，还是不能使用npm来下载</p><p>所以就是用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   ~  sudo apt install -y nodejs   </span><br></pre></td></tr></table></figure><p>这个来直接下载了</p><p>检查一下版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line"></span><br><span class="line">v3.3.1</span><br><span class="line">4.6.1</span><br></pre></td></tr></table></figure><p>ok完成</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;网络运维&lt;/h1&gt;
&lt;h2 id=&quot;无法访问外网的域名&quot;&gt;无法访问外网的域名&lt;/h2&gt;
&lt;p&gt;应该就是dns解析出了问题&lt;/p&gt;
&lt;p&gt;我们就要在hosts解析里进行修改&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="Linux" scheme="https://mengnankk.asia/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 备份恢复篇</title>
    <link href="https://mengnankk.asia/2024/10/11/linux8/"/>
    <id>https://mengnankk.asia/2024/10/11/linux8/</id>
    <published>2024-10-10T16:00:00.000Z</published>
    <updated>2024-10-11T04:44:47.496Z</updated>
    
    <content type="html"><![CDATA[<h1>备份和恢复需要的工具</h1><p>在使用虚拟机的时候我们可以使用快照进行恢复，但是在实体机的时候，我们不能使用快照</p><p>那我们就要掌握备份恢复的技术操作</p><p><strong>dump</strong>指令和<strong>restore</strong>指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-fast install dump</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-fast install restorecond   </span><br></pre></td></tr></table></figure><h1>dump</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump [options] file</span><br></pre></td></tr></table></figure><p>dump指令的基本语法</p><p>选项解析：</p><ul><li>-0~-9代表存储的级别，0代表完全备份，1-9代表增量备份（增量备份就是备份上次备份修改或者增加的备份）</li><li>-f 指定备份的文件或者设备，不指定默认使用磁带</li><li>-u 显示备份更新的时间 在/etc/dumpupdates文件夹内</li><li>-v 显示详细的信息</li><li>-b 修改数据块的大小，默认是kb</li><li>-s 磁带的大小</li><li>-j 使用压缩</li></ul><p>完全备份整个文件系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -0uf /backup/full_backup.dump /dev/sda1</span><br></pre></td></tr></table></figure><p>增量备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -1uf /backup/full1_backup.dump /dev/sda1</span><br></pre></td></tr></table></figure><p>不仅仅可以备份整个文件，还可以备份某个文件夹或者是文件</p><h1>restore</h1><p>restore的基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restore [options] file</span><br></pre></td></tr></table></figure><p>详细的选项：</p><ul><li>-i 进入交互模式</li><li>-r 完全恢复</li><li>-R 恢复增量备份</li><li>-t 显示详细信息</li><li>-C 切换指定的目录</li><li>-f 指定备份的文件</li></ul><p>恢复完全</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restore -rf /backup/full_backup.dump</span><br></pre></td></tr></table></figure><p>即可</p><h1>使用守则</h1><p>为了保证数据的安全，尽量使用定时备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e </span><br></pre></td></tr></table></figure><p>比如这样备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2 * * * dump -1uf /backup/incremental_backup.dump /dev/sda1</span><br></pre></td></tr></table></figure><p>在使用 <code>dump</code> 进行备份时，确保文件系统是处于一致的状态非常重要。可以使用以下几种方法：</p><ul><li><strong>单用户模式</strong>：在备份之前进入单用户模式，以确保系统不会发生并发修改。</li><li><strong>只读挂载</strong>：将文件系统挂载为只读，防止在备份期间进行写操作。</li><li>在恢复时，如果你有增量备份和完全备份，恢复顺序是：<ol><li>先恢复最新的完全备份。</li><li>依次应用所有增量备份（按顺序从低到高的增量级别恢复）。</li></ol></li></ul><h1>压缩备份</h1><p>使用 <code>-j</code> 选项（启用压缩），可以减少备份文件的大小。你还可以结合 Linux 的压缩工具进行备份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -0uf - /dev/sda1 | gzip &gt; /backup/full_backup.gz</span><br></pre></td></tr></table></figure><p>恢复时，使用解压命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip -c /backup/full_backup.gz | restore -rf -</span><br></pre></td></tr></table></figure><h1>跨设备备份</h1><h3 id="5-跨设备备份">5. <strong>跨设备备份</strong></h3><p>如果你需要将备份存储在远程服务器上，可以使用 <code>ssh</code> 和 <code>dump</code> 结合将备份传输到远程设备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -0uf - /dev/sda1 | ssh user@remote_server &quot;cat &gt; /remote_backup/full_backup.dump&quot;</span><br></pre></td></tr></table></figure><p>恢复时，同样可以通过 SSH 进行数据传输：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@remote_server &quot;cat /remote_backup/full_backup.dump&quot; | restore -rf -</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;备份和恢复需要的工具&lt;/h1&gt;
&lt;p&gt;在使用虚拟机的时候我们可以使用快照进行恢复，但是在实体机的时候，我们不能使用快照&lt;/p&gt;
&lt;p&gt;那我们就要掌握备份恢复的技术操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dump&lt;/strong&gt;指令和&lt;strong&gt;restore&lt;/stro</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="Linux" scheme="https://mengnankk.asia/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 树篇</title>
    <link href="https://mengnankk.asia/2024/10/09/data4/"/>
    <id>https://mengnankk.asia/2024/10/09/data4/</id>
    <published>2024-10-08T16:00:00.000Z</published>
    <updated>2024-11-04T11:59:33.812Z</updated>
    
    <content type="html"><![CDATA[<h1>树的概念</h1><p>树是一个<strong>有限</strong>的集合</p><p>我们的linux文件目录就是树状的</p><p>「树」具有以下的特点：</p><ul><li><p>有且仅有一个节点没有前驱节点，该节点被称为树的 <strong>「根节点（Root）」</strong> 。</p></li><li><p>除了根节点以之，每个节点有且仅有一个直接前驱节点。</p></li><li><p>包括根节点在内，每个节点可以有多个后继节点。</p></li><li><p>当 n&gt;1<em>n</em>&gt;1 时，除了根节点之外的其他节点，可分为 m(m&gt;0)<em>m</em>(<em>m</em>&gt;0) 个互不相交的有限集合 T1,T2,…,Tm<em>T</em>1,<em>T</em>2,…,<em>T**m</em>，其中每一个集合本身又是一棵树，并且被称为根的 <strong>「子树（SubTree）」</strong>。</p><img src="https://qcdn.itcharge.cn/images/20240511171233.png" alt="a" style="zoom:80%;" /></li></ul><p>节点所含有的子树的个数就是节点的度</p><p>度为0的叫做叶子节点</p><p>度不为0的叫做分支节点</p><p>树中各节点的最大度数称为 <strong>「树的度」</strong>。</p><p><img src="https://qcdn.itcharge.cn/images/20240511171300.png" alt=""></p><h2 id="节点之间的关系">节点之间的关系</h2><p><img src="https://qcdn.itcharge.cn/images/20240511171311.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20240511171325.png" alt=""></p><p>兄弟节点，孩子节点，父子节点…</p><ul><li><strong>节点的层次</strong>：从根节点开始定义，根为第 11 层，根的子节点为第 22 层，以此类推。</li><li><strong>树的深度（高度）</strong>：所有节点中最大的层数。例如图中树的深度为 44。</li><li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟。例如图中 J<em>J</em>、K<em>K</em> 互为堂兄弟节点。</li><li><strong>路径</strong>：树中两个节点之间所经过的节点序列。例如图中 E<em>E</em> 到 G<em>G</em> 的路径为 E−B−A−D−G<em>E</em>−<em>B</em>−<em>A</em>−<em>D</em>−<em>G</em>。</li><li><strong>路径长度</strong>：两个节点之间路径上经过的边数。例如图中 E<em>E</em> 到 G<em>G</em> 的路径长度为 44。</li><li><strong>节点的祖先</strong>：从该节点到根节点所经过的所有节点，被称为该节点的祖先。例如图中 H<em>H</em> 的祖先为 E<em>E</em>、B<em>B</em>、A<em>A</em>。</li><li><strong>节点的子孙</strong>：节点的子树中所有节点被称为该节点的子孙。例如图中 D<em>D</em> 的子孙为 F<em>F</em>、G<em>G</em>、K<em>K</em>。</li></ul><h2 id="树的分类">树的分类</h2><ul><li><strong>有序树</strong>：节点的各个⼦树从左⾄右有序， 不能互换位置。</li><li><strong>无序树</strong>：节点的各个⼦树可互换位置。</li></ul><h1>二叉树</h1><p>二叉树的简单实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = null;</span><br><span class="line">        this.right = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BinaryTree&#123;</span><br><span class="line">    TreeNode root;</span><br><span class="line">    public BinaryTree()&#123;</span><br><span class="line">        root = null;</span><br><span class="line">    &#125;</span><br><span class="line">    public  void insert(int val)&#123;</span><br><span class="line">        root = insertRec(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    private TreeNode insertRec(TreeNode root,int val)&#123;</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            root = new TreeNode(val);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if (val&lt;root.val)&#123;</span><br><span class="line">            root.left = insertRec(root.left,val);</span><br><span class="line">        &#125; else if (val&gt;root.val)&#123;</span><br><span class="line">            root.right = insertRec(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preOrder()&#123;</span><br><span class="line">        preOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line">    private void preOrderRec(TreeNode root)&#123;</span><br><span class="line">        if (root!=null)&#123;</span><br><span class="line">            System.out.println(root.val + &quot; &quot;);</span><br><span class="line">            preOrderRec(root.left);</span><br><span class="line">            preOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void inOrder()&#123;</span><br><span class="line">        inOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line">    private void inOrderRec(TreeNode root)&#123;</span><br><span class="line">        if (root != null)&#123;</span><br><span class="line">            inOrderRec(root.left);</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">            inOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void postOrder()&#123;</span><br><span class="line">        postOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line">    private void postOrderRec(TreeNode root)&#123;</span><br><span class="line">        if (root!=null)&#123;</span><br><span class="line">            postOrderRec(root.left);</span><br><span class="line">            postOrderRec(root.right);</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean search(int val)&#123;</span><br><span class="line">        return search(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean searchRec(TreeNode root,int val)&#123;</span><br><span class="line">        if (root==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.val ==val)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return val&lt;root.val ? searchRec(root.left,val) : searchRec(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class tree_1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BinaryTree tree = new BinaryTree();</span><br><span class="line">        tree.insert(50);</span><br><span class="line">        tree.insert(30);</span><br><span class="line">        tree.insert(20);</span><br><span class="line">        tree.insert(40);</span><br><span class="line">        tree.insert(70);</span><br><span class="line">        tree.insert(60);</span><br><span class="line">        tree.insert(80);</span><br><span class="line">        tree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后遍历输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 40 30 60 80 70 50</span><br></pre></td></tr></table></figure><p>当然这个是print的结果，我懒得改了宝贝们</p><p>二叉树还有许许多多的分类。完全满不满的很多种</p><p><img src="https://qcdn.itcharge.cn/images/20220218173007.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20220218174000.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20220221103552.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20240511171423.png" alt=""></p><h2 id="二叉树的遍历">二叉树的遍历</h2><p><strong>二叉树的遍历</strong>：指的是从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。</p><p>一共有三种遍历方式</p><p><strong>「二叉树的前序遍历」</strong>、<strong>「二叉树的中序遍历」</strong> 和 <strong>「二叉树的后续遍历」</strong></p><p>前序遍历规则</p><ul><li>如果二叉树为空，则返回。</li><li>如果二叉树不为空，则：<ol><li>访问根节点。</li><li>以前序遍历的方式遍历根节点的左子树。</li><li>以前序遍历的方式遍历根节点的右子树。</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void preOrder()&#123;</span><br><span class="line">        preOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line">    private void preOrderRec(TreeNode root)&#123;</span><br><span class="line">        if (root!=null)&#123;</span><br><span class="line">            System.out.println(root.val + &quot; &quot;);</span><br><span class="line">            preOrderRec(root.left);</span><br><span class="line">            preOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码实现</p><p>中序遍历规则</p><ul><li>如果二叉树为空，则返回。</li><li>如果二叉树不为空，则：<ol><li>以中序遍历的方式遍历根节点的左子树。</li><li>访问根节点。</li><li>以中序遍历的方式遍历根节点的右子树。</li></ol></li></ul><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void inOrder()&#123;</span><br><span class="line">        inOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line">    private void inOrderRec(TreeNode root)&#123;</span><br><span class="line">        if (root != null)&#123;</span><br><span class="line">            inOrderRec(root.left);</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">            inOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后序遍历实现</p><ul><li>如果二叉树为空，则返回。</li><li>如果二叉树不为空，则：<ol><li>以后序遍历的方式遍历根节点的左子树。</li><li>以后序遍历的方式遍历根节点的右子树。</li><li>访问根节点。</li></ol></li></ul><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void postOrder()&#123;</span><br><span class="line">        postOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line">    private void postOrderRec(TreeNode root)&#123;</span><br><span class="line">        if (root!=null)&#123;</span><br><span class="line">            postOrderRec(root.left);</span><br><span class="line">            postOrderRec(root.right);</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>层序遍历的实现</p><ul><li>如果二叉树为空，则返回。</li><li>如果二叉树不为空，则：<ol><li>先依次访问二叉树第 11 层的节点。</li><li>然后依次访问二叉树第 22 层的节点。</li><li>……</li><li>依次下去，最后依次访问二叉树最下面一层的节点。</li></ol></li></ul><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void levelOrder()&#123;</span><br><span class="line">        if (root ==null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.println(node.val);</span><br><span class="line">            if (node.left!=null)&#123;</span><br><span class="line">                queue.add((node.left));</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right!=null)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的还原">二叉树的还原</h2><p><strong>二叉树的还原</strong>：指的是通过二叉树的遍历序列，还原出对应的二叉树。</p><p>还原唯一性的确定：</p><p><strong>如果已知一棵二叉树的前序序列和中序序列，可以唯一地确定这棵二叉树。</strong></p><p><strong>如果已知一棵二叉树的中序序列和后序序列，也可以唯一地确定这棵二叉树</strong></p><p><strong>已知二叉树的「中序遍历序列」和「层序遍历序列」，也可以唯一地确定一棵二叉树。</strong></p><p>注意：</p><p>!!!</p><p><strong>如果已知二叉树的「前序遍历序列」和「后序遍历序列」，是不能唯一地确定一棵二叉树的。</strong> 这是因为没有中序遍历序列无法确定左右部分，也就无法进行子序列的分割。</p><h2 id="二叉搜索树">二叉搜索树</h2><p><strong>二叉搜索树（Binary Search Tree）</strong>：也叫做二叉查找树、有序二叉树或者排序二叉树。是指一棵空树或者具有下列性质的二叉树：</p><ul><li>如果任意节点的左子树不为空，则左子树上所有节点的值均小于等于它的根节点的值。</li><li>如果任意节点的右子树不为空，则右子树上所有节点的值均大于等于它的根节点的值。</li><li>任意节点的左子树、右子树均为二叉搜索树。</li></ul><p>注意：</p><p>一般来说二叉搜索树中没有值相等的点，为了增加相等的点</p><p>可以加上等于的条件</p><p>查找算法的分析：</p><p>最好：<em>O</em>(log2<em>n</em>)</p><p>最坏：<em>O</em>(<em>n</em>)</p><p>平均：</p><p>在平均情况下，二叉搜索树的平均查找长度为 ASL=[(n+1)/n]∗/log2(n+1)−1<em>A<strong>S</strong>L</em>=[(<em>n</em>+1)/<em>n</em>]∗/<em>l<strong>o</strong>g</em>2(<em>n</em>+1)−1。所以二分搜索树的查找平均时间复杂度为 O(log2n)<em>O</em>(<em>l<strong>o</strong>g</em>2<em>n</em>)。</p><p>二叉搜索树的代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">class TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = null;</span><br><span class="line">        this.right = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BinaryTree &#123;</span><br><span class="line">    TreeNode root;</span><br><span class="line"></span><br><span class="line">    public BinaryTree() &#123;</span><br><span class="line">        root = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insert(int val) &#123;</span><br><span class="line">        root = insertRec(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode insertRec(TreeNode root, int val) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            root = new TreeNode(val);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if (val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertRec(root.left, val);</span><br><span class="line">        &#125; else if (val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertRec(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        preOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void preOrderRec(TreeNode root) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            System.out.println(root.val + &quot; &quot;);</span><br><span class="line">            preOrderRec(root.left);</span><br><span class="line">            preOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inOrder() &#123;</span><br><span class="line">        inOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void inOrderRec(TreeNode root) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            inOrderRec(root.left);</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">            inOrderRec(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        postOrderRec(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void postOrderRec(TreeNode root) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            postOrderRec(root.left);</span><br><span class="line">            postOrderRec(root.right);</span><br><span class="line">            System.out.println(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void levelOrder() &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.println(node.val);</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.add((node.left));</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean search(int val) &#123;</span><br><span class="line">        return search(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean searchRec(TreeNode root, int val) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.val == val) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return val &lt; root.val ? searchRec(root.left, val) : searchRec(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int findMin(TreeNode root) &#123;</span><br><span class="line">        int min = root.val;</span><br><span class="line">        while (root.left != null) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            min = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete(int val) &#123;</span><br><span class="line">        root = deleteRec(root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode deleteRec(TreeNode root, int val) &#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        if (val &lt; root.val) &#123;</span><br><span class="line">            root.left = deleteRec(root.left, val);</span><br><span class="line">        &#125; else if (val &gt; root.val) &#123;</span><br><span class="line">            root.right = deleteRec(root.right, val);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (root.left == null) return root.right;</span><br><span class="line">            if (root.right == null) return root.left;</span><br><span class="line">            root.val = findMin(root.right);</span><br><span class="line">            root.right = deleteRec(root.right, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class tree_1 &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            BinaryTree tree = new BinaryTree();</span><br><span class="line">            tree.insert(50);</span><br><span class="line">            tree.insert(30);</span><br><span class="line">            tree.insert(20);</span><br><span class="line">            tree.insert(40);</span><br><span class="line">            tree.insert(70);</span><br><span class="line">            tree.insert(60);</span><br><span class="line">            tree.insert(80);</span><br><span class="line">            tree.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整的代码实现</p><h2 id="线段树">线段树</h2><p>一种基于分治思想的二叉树，用于在区间上进行信息统计。它的每一个节点都对应一个区间 [left,right][<em>l<strong>e</strong>f**t</em>,<em>r<strong>i</strong>g<strong>h</strong>t</em>] ，left<em>l<strong>e</strong>f**t</em>、right<em>r<strong>i</strong>g<strong>h</strong>t</em> 通常是整数。每一个叶子节点表示了一个单位区间（长度为 11），叶子节点对应区间上 left==right<em>l<strong>e</strong>f**t</em>==<em>r<strong>i</strong>g<strong>h</strong>t</em>。每一个非叶子节点 [left,right][<em>l<strong>e</strong>f**t</em>,<em>r<strong>i</strong>g<strong>h</strong>t</em>] 的左子节点表示的区间都为 [left,(left+right)/2][<em>l<strong>e</strong>f**t</em>,(<em>l<strong>e</strong>f**t</em>+<em>r<strong>i</strong>g<strong>h</strong>t</em>)/2]，右子节点表示的的区间都为 [(left+right)/2+1,right][(<em>l<strong>e</strong>f**t</em>+<em>r<strong>i</strong>g<strong>h</strong>t</em>)/2+1,<em>r<strong>i</strong>g<strong>h</strong>t</em>]。</p><p>例如：</p><p><img src="https://qcdn.itcharge.cn/images/20240511173328.png" alt=""></p><p>线段树的特点</p><ol><li>线段树的每个节点都代表一个区间。</li><li>线段树具有唯一的根节点，代表的区间是整个统计范围，比如 [1,n][1,<em>n</em>]。</li><li>线段树的每个叶子节点都代表一个长度为 11 的单位区间 [x,x][<em>x</em>,<em>x</em>]。</li><li>对于每个内部节点 [left,right][<em>l<strong>e</strong>f**t</em>,<em>r<strong>i</strong>g<strong>h</strong>t</em>]，它的左子节点是 [left,mid][<em>l<strong>e</strong>f**t</em>,<em>mi**d</em>]，右子节点是 [mid+1,right][<em>mi**d</em>+1,<em>r<strong>i</strong>g<strong>h</strong>t</em>]。其中 mid=(left+right)/2<em>mi**d</em>=(<em>l<strong>e</strong>f**t</em>+<em>r<strong>i</strong>g<strong>h</strong>t</em>)/2（向下取整）。</li></ol><p>由于线段树近乎是完全二叉树，所以很适合用「顺序存储结构」来实现。</p><p>比如</p><p><img src="https://qcdn.itcharge.cn/images/20240511173417.png" alt=""></p><ol><li>如果是叶子节点（left==right<em>l<strong>e</strong>f**t</em>==<em>r<strong>i</strong>g<strong>h</strong>t</em>），则节点的值就是对应位置的元素值。</li><li>如果是非叶子节点，则递归创建左子树和右子树。</li><li>节点的区间值（区间和、区间最大值、区间最小值）等于该节点左右子节点元素值的对应计算结果。</li></ol><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class SegmentTree &#123;</span><br><span class="line">    private int tree[];</span><br><span class="line">    private int data[];</span><br><span class="line"></span><br><span class="line">    public SegmentTree(int[] nums) &#123;</span><br><span class="line">        if (nums.length &gt; 0) &#123;</span><br><span class="line">            int n = nums.length;</span><br><span class="line">            data = nums;</span><br><span class="line">            tree = new int[4 * n];</span><br><span class="line">            buildTree(0, 0, n - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void buildTree(int node, int start, int end) &#123;</span><br><span class="line">        if (start == end) &#123;</span><br><span class="line">            tree[node] = data[start];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int mid = (start + end) / 2;</span><br><span class="line">            int leftChild = 2 * node + 1;</span><br><span class="line">            int rightChild = 2 * node + 2;</span><br><span class="line">            buildTree(leftChild, start, mid);</span><br><span class="line">            buildTree(rightChild, mid + 1, end);</span><br><span class="line">            tree[node] = tree[leftChild] + tree[rightChild];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int query(int L, int R) &#123;</span><br><span class="line">        return queryRec(0, 0, data.length - 1, L, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int queryRec(int node, int start, int end, int L, int R) &#123;</span><br><span class="line">        if (R &lt; start || L &gt; end) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (L &lt;= start &amp;&amp; end &lt;= R) &#123;</span><br><span class="line">            return tree[node];</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (start + end) / 2;</span><br><span class="line">        int leftChild = 2 * node + 1;</span><br><span class="line">        int rightChild = 2 * node + 2;</span><br><span class="line">        int leftSum = queryRec(leftChild, start, mid, L, R);</span><br><span class="line">        int rightSum = queryRec(rightChild, mid + 1, end, L, R);</span><br><span class="line">        return leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line">    public void update(int index,int val)&#123;</span><br><span class="line">        updateRec(0,0,data.length-1,index,val);</span><br><span class="line">    &#125;</span><br><span class="line">    private void updateRec(int node,int start,int end,int index,int val) &#123;</span><br><span class="line">        if (start == end) &#123;</span><br><span class="line">            data[index] = val;</span><br><span class="line">            tree[node] = val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int mid = (start + end) / 2;</span><br><span class="line">            int leftChild = 2 * node + 1;</span><br><span class="line">            int rightChild = 2 * node + 2;</span><br><span class="line">            if (index &lt;= mid) &#123;</span><br><span class="line">                // 更新左子树</span><br><span class="line">                updateRec(leftChild, start, mid, index, val);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 更新右子树</span><br><span class="line">                updateRec(rightChild, mid + 1, end, index, val);</span><br><span class="line">            &#125;</span><br><span class="line">            tree[node] = tree[leftChild] + tree[rightChild];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="红黑树">红黑树</h2><p>红黑树（Red-Black Tree）是一种<strong>自平衡二叉搜索树</strong>，在插入和删除节点时通过一些规则保持树的平衡，避免树的高度过高，从而保证增删查的时间复杂度为 O(log n)。</p><p>红黑树的性质：</p><p><strong>每个节点要么是红色的，要么是黑色的。</strong></p><p><strong>根节点必须是黑色的。</strong></p><p><strong>每个叶节点（NIL节点，虚拟节点）是黑色的。</strong></p><p><strong>如果一个节点是红色的，那么它的两个子节点必须是黑色的</strong>（不能有两个连续的红色节点）。</p><p><strong>从任意一个节点到其每个叶节点的路径都包含相同数目的黑色节点</strong>（黑高，即从根到叶子所有路径上的黑色节点数量相同）。</p><p>其最坏时间复杂度就是O(log n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> class RedBlackTree &#123;</span><br><span class="line">    private static final boolean RED = true;</span><br><span class="line">    private static final boolean BLACK  = false;</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        int key;</span><br><span class="line">        Node left,right,parent;</span><br><span class="line">        boolean color;</span><br><span class="line">        Node(int key)&#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private Node root;</span><br><span class="line">    private void leftRotate(Node x)&#123;//左旋</span><br><span class="line">        Node y =x.right;</span><br><span class="line">        x.right =y.left;</span><br><span class="line">        if (y.left!=null)&#123;</span><br><span class="line">            y.left.parent=x;</span><br><span class="line">        &#125;</span><br><span class="line">        y.parent = x.parent;</span><br><span class="line">        if (x.parent==null)&#123;</span><br><span class="line">            root=y;</span><br><span class="line">        &#125;else if (x==x.parent.left)&#123;</span><br><span class="line">            x.parent.left = y;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            x.parent.right = y;</span><br><span class="line">        &#125;</span><br><span class="line">        y.left = x;</span><br><span class="line">        x.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>红黑树左旋代码实现（（（好难啊）））</p><h1>并查集</h1><p>一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。不交集指的是一系列没有重复元素的集合。</p><p>并查集主要支持两种操作：</p><ul><li><strong>合并（Union）</strong>：将两个集合合并成一个集合。</li><li><strong>查找（Find）</strong>：确定某个元素属于哪个集合。通常是返回集合内的一个「代表元素」。</li></ul><p>代码实现：</p><p><strong>使用快速查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class UnionFind &#123;</span><br><span class="line">    private int[] parent;</span><br><span class="line">    private int[] rank;</span><br><span class="line"></span><br><span class="line">    public UnionFind(int size) &#123;</span><br><span class="line">        parent = new int[size];</span><br><span class="line">        rank = new int[size];</span><br><span class="line">        for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] =1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find(int p)&#123;</span><br><span class="line">        if (parent[p]!=p)&#123;</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int p,int q)&#123;</span><br><span class="line">        int rootP = find(p);</span><br><span class="line">        int rootQ = find(q);</span><br><span class="line">        if (rootQ!=rootP)&#123;</span><br><span class="line">            if (rank[rootP]&gt;rank[rootQ])&#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">            &#125;else if (rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean connected(int p,int q)&#123;</span><br><span class="line">        return find(p) ==find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnionFind unionFind = new UnionFind(10);</span><br><span class="line">        unionFind.union(1,2);</span><br><span class="line">        unionFind.union(2,3);</span><br><span class="line">        System.out.println(unionFind.connected(1, 3));</span><br><span class="line">        System.out.println(unionFind.connected(1, 4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>说明1.3和1,2有交集</p><p>而2,3和1,4没有交集</p><p>在find 方法里运用了路径压缩的知识</p><p><strong>路径压缩</strong>: 在查找的过程中，使用递归方式将当前节点的父节点指向根节点，以降低树的深度，提高查找效率。这一步骤可以将树的高度压缩为接近常数，极大地优化查询操作的效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int find(int p)&#123;</span><br><span class="line">    if (parent[p]!=p)&#123;</span><br><span class="line">        parent[p] = find(parent[p]); // 路径压缩</span><br><span class="line">    &#125;</span><br><span class="line">    return parent[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>union</code> 方法用于将两个元素 <code>p</code> 和 <code>q</code> 所属的集合进行合并。</p><p>首先使用 <code>find</code> 方法找到两个元素的根节点 <code>rootP</code> 和 <code>rootQ</code>。</p><p>如果这两个元素的根节点不同，则说明它们属于不同的集合，需要将它们合并：</p><ul><li>根据两个根节点的 <code>rank</code> 来决定合并方向：将<strong>rank</strong>较小的树连接到<strong>rank</strong>较大的树上，从而保持树的扁平。</li><li>如果两个集合的 <code>rank</code> 相等，则任选一个作为父节点，同时将它的 <code>rank</code> 值加一。</li></ul><p>联通来比较他们的根节点是不是相同</p><p>最后来一个main的测试方法</p><p>来了两种路径压缩的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class UninFind &#123;</span><br><span class="line">    private int[] parent;</span><br><span class="line">    private int[] rank;</span><br><span class="line"></span><br><span class="line">    public UninFind(int size) &#123;</span><br><span class="line">        parent = new int[size];</span><br><span class="line">        rank = new int[size];</span><br><span class="line">        for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] =1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find1(int p)&#123;//完全压缩</span><br><span class="line">        if (parent[p]!=p)&#123;</span><br><span class="line">            parent[p] = find1(parent[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    public int find2(int p)&#123;//隔代压缩</span><br><span class="line">        if (parent[p]!=p)&#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int p,int q)&#123;</span><br><span class="line">        int rootP = find1(p);</span><br><span class="line">        int rootQ = find1(q);</span><br><span class="line">        if (rootQ!=rootP)&#123;</span><br><span class="line">            if (rank[rootP]&gt;rank[rootQ])&#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">            &#125;else if (rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean connected(int p,int q)&#123;</span><br><span class="line">        return find1(p) ==find1(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UninFind unionFind = new UninFind(10);</span><br><span class="line">        unionFind.union(1,2);</span><br><span class="line">        unionFind.union(2,3);</span><br><span class="line">        System.out.println(unionFind.connected(1, 3));</span><br><span class="line">        System.out.println(unionFind.connected(1, 4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示意图如下</p><p><img src="https://qcdn.itcharge.cn/images/20240513154745.png" alt=""></p><p>隔代压缩</p><p><img src="https://qcdn.itcharge.cn/images/20240513154759.png" alt=""></p><p>完全压缩</p><h2 id="按秩合并">按秩合并</h2><p>因为路径压缩只在查询时进行，并且只压缩一棵树上的路径，所以并查集最终的结构仍然可能是比较复杂的。为了避免这种情况，另一个优化方式是「按秩合并」</p><p>指的是在每次合并操作时，都把「秩」较小的树根节点指向「秩」较大的树根节点。</p><p>一种叫做「按深度合并」；另一种叫做「按大小合并」。</p><p>按秩合并的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class UninFind &#123;</span><br><span class="line">    private int[] parent;</span><br><span class="line">    private int[] rank;</span><br><span class="line">    private int[] size;</span><br><span class="line"></span><br><span class="line">    public UninFind(int size) &#123;</span><br><span class="line">        parent = new int[size];</span><br><span class="line">        rank = new int[size];</span><br><span class="line">        this.size = new int[size];</span><br><span class="line">        for (int i=0;i&lt;size;i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] =1;</span><br><span class="line">            this.size[i] =1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int find1(int p)&#123;//完全压缩</span><br><span class="line">        if (parent[p]!=p)&#123;</span><br><span class="line">            parent[p] = find1(parent[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        return parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    public int find2(int p)&#123;//隔代压缩</span><br><span class="line">        if (parent[p]!=p)&#123;</span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unionBySize(int p,int q)&#123;//按大小合并</span><br><span class="line">        int rootP = find1(p);</span><br><span class="line">        int rootQ = find1(q);</span><br><span class="line">        if (rootP!=rootP)&#123;</span><br><span class="line">            if (size[rootP]&gt;size[rootQ])&#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                size[rootP]+=size[rootQ];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parent[rootP] =rootQ;</span><br><span class="line">                size[rootQ] +=size[rootP];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unionByRank(int p,int q)&#123;//按深度合并</span><br><span class="line">        int rootP = find1(p);</span><br><span class="line">        int rootQ = find1(q);</span><br><span class="line">        if (rootQ!=rootP)&#123;</span><br><span class="line">            if (rank[rootP]&gt;rank[rootQ])&#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">            &#125;else if (rank[rootP]&lt;rank[rootQ])&#123;</span><br><span class="line">                parent[rootP] = rootQ;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                parent[rootQ] = rootP;</span><br><span class="line">                rank[rootP]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean connected(int p,int q)&#123;</span><br><span class="line">        return find1(p) ==find1(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UninFind unionFind = new UninFind(10);</span><br><span class="line">        unionFind.unionByRank(1,2);</span><br><span class="line">        unionFind.unionByRank(2,3);</span><br><span class="line">        System.out.println(unionFind.connected(1, 3));</span><br><span class="line">        System.out.println(unionFind.connected(1, 4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://qcdn.itcharge.cn/images/20240513154814.png" alt="按深度合并"></p><p>按深度合并</p><p><img src="https://qcdn.itcharge.cn/images/20240513154835.png" alt=""></p><p>按大小合并</p><p>综上：</p><ul><li>并查集的空间复杂度：O(n)<em>O</em>(<em>n</em>)。</li><li>并查集的时间复杂度：O(m×α(n))<em>O</em>(<em>m</em>×<em>α</em>(<em>n</em>))。</li></ul><h1>霍夫曼树</h1><p>设二叉树具有 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="n"> 个带权叶结点，从根结点到各叶结点的路径长度与相应叶节点权值的乘积之和称为 <strong>树的带权路径长度</strong></p><p>设 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="w_i"> 为二叉树第 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="i"> 个叶结点的权值，<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="l_i"> 为从根结点到第 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="i"> 个叶结点的路径长度，则 WPL 计算公式如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt=" WPL=um_{i=1}^nw_il_i "></p><p><img src="https://oi-wiki.org/ds/images/huffman-tree-1.svg" alt="img"></p><p>如上图所示，其 WPL 计算过程与结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2*2+3*2+4*2+7*2=32</span><br></pre></td></tr></table></figure><p>对于给定一组具有确定权值的叶结点，可以构造出不同的二叉树，其中，<strong>WPL 最小的二叉树</strong> 称为 <strong>霍夫曼树（Huffman Tree）</strong>。</p><p>对于霍夫曼树来说，其叶结点权值越小，离根越远，叶结点权值越大，离根越近，此外其仅有叶结点的度为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="0">，其他结点度均为 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="2">。</p><p>霍夫曼树可用于构造 <strong>最短的前缀编码</strong>，即 <strong>霍夫曼编码（Huffman Code）</strong>，其构造步骤如下：</p><ol><li>设需要编码的字符集为：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="d_1,d_2,ots,d_n">，他们在字符串中出现的频率为：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="w_1,w_2,ots,w_n">。</li><li>以 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="d_1,d_2,ots,d_n"> 作为叶结点，<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="w_1,w_2,ots,w_n"> 作为叶结点的权值，构造一棵霍夫曼树。</li><li>规定哈夫曼编码树的左分支代表 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="0">，右分支代表 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="1">，则从根结点到每个叶结点所经过的路径组成的 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="0">、<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="1"> 序列即为该叶结点对应字符的编码。</li></ol><p><img src="https://oi-wiki.org/ds/images/huffman-tree-3.svg" alt=""></p><p>霍夫曼树的构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">class HuffmanNode implements Comparable&lt;HuffmanNode&gt; &#123;</span><br><span class="line">    char ch;</span><br><span class="line">    int frequency;</span><br><span class="line">    HuffmanNode left;</span><br><span class="line">    HuffmanNode right;</span><br><span class="line"></span><br><span class="line">    public HuffmanNode(char ch, int frequency) &#123;</span><br><span class="line">        this.ch = ch;</span><br><span class="line">        this.frequency = frequency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(HuffmanNode node) &#123;</span><br><span class="line">        return this.frequency - node.frequency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HuffmanTree &#123;</span><br><span class="line"></span><br><span class="line">    public static HuffmanNode buildHuffmanTree(char[] chars, int[] frequencies) &#123;</span><br><span class="line">        PriorityQueue&lt;HuffmanNode&gt; priorityQueue = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 构造初始节点并加入优先队列</span><br><span class="line">        for (int i = 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">            priorityQueue.add(new HuffmanNode(chars[i], frequencies[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 构建霍夫曼树</span><br><span class="line">        while (priorityQueue.size() &gt; 1) &#123;</span><br><span class="line">            HuffmanNode left = priorityQueue.poll();</span><br><span class="line">            HuffmanNode right = priorityQueue.poll();</span><br><span class="line"></span><br><span class="line">            // 新节点频率为左右子节点之和，字符设为占位符（如&#x27;-&#x27;）</span><br><span class="line">            HuffmanNode parent = new HuffmanNode(&#x27;-&#x27;, left.frequency + right.frequency);</span><br><span class="line">            parent.left = left;</span><br><span class="line">            parent.right = right;</span><br><span class="line"></span><br><span class="line">            priorityQueue.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return priorityQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printHuffmanCodes(HuffmanNode root, String code) &#123;</span><br><span class="line">        if (root == null) &#123; // 修正条件：若root为null，则直接返回</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前节点是叶子节点，打印编码</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            System.out.println(root.ch + &quot;: &quot; + code);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 递归遍历左、右子树</span><br><span class="line">        printHuffmanCodes(root.left, code + &quot;0&quot;);</span><br><span class="line">        printHuffmanCodes(root.right, code + &quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[] chars = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;;</span><br><span class="line">        int[] frequencies = &#123;5, 9, 12, 13, 16, 45&#125;;</span><br><span class="line"></span><br><span class="line">        // 构建霍夫曼树</span><br><span class="line">        HuffmanNode root = buildHuffmanTree(chars, frequencies);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;霍夫曼编码：&quot;);</span><br><span class="line">        printHuffmanCodes(root, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">霍夫曼编码：</span><br><span class="line">f: 0</span><br><span class="line">c: 100</span><br><span class="line">d: 101</span><br><span class="line">a: 1100</span><br><span class="line">b: 1101</span><br><span class="line">e: 111</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;树的概念&lt;/h1&gt;
&lt;p&gt;树是一个&lt;strong&gt;有限&lt;/strong&gt;的集合&lt;/p&gt;
&lt;p&gt;我们的linux文件目录就是树状的&lt;/p&gt;
&lt;p&gt;「树」具有以下的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有且仅有一个节点没有前驱节点，该节点被称为树的</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="数据结构" scheme="https://mengnankk.asia/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>字符串刷题 十月篇</title>
    <link href="https://mengnankk.asia/2024/10/09/datatest1/"/>
    <id>https://mengnankk.asia/2024/10/09/datatest1/</id>
    <published>2024-10-08T16:00:00.000Z</published>
    <updated>2024-10-09T11:12:13.608Z</updated>
    
    <content type="html"><![CDATA[<p>暂时没找到题目，此文章暂时作废</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;暂时没找到题目，此文章暂时作废&lt;/p&gt;
</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="数据结构" scheme="https://mengnankk.asia/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Mysql练习 十月篇</title>
    <link href="https://mengnankk.asia/2024/10/09/sqltest2/"/>
    <id>https://mengnankk.asia/2024/10/09/sqltest2/</id>
    <published>2024-10-08T16:00:00.000Z</published>
    <updated>2024-10-13T13:04:07.801Z</updated>
    
    <content type="html"><![CDATA[<h1>if结构</h1><h2 id="1-VQ22-判断其是否有过购买记录">1.<a href="https://www.nowcoder.com/practice/5cddad8995974b0c915ab89961428ee0?tpId=341&amp;tqId=10100101&amp;ru=/exam/oj&amp;qru=/ta/vip-sql/question-ranking&amp;sourceUrl=%2Fexam%2Foj"><strong>VQ22</strong> <strong>判断其是否有过购买记录</strong></a></h2><p>现有牛客顾客购买信息表customers_info，请查询客户id并新增一列判断该客户是否有过购买记录(<code>latest_place_order_date</code> 1为有 0为没有)</p><p><img src="https://uploadfiles.nowcoder.com/images/20220816/0_1660618848686/F8BAD4BF0D08CAA5EC5E3E28353944E4" alt=""></p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">    customer_id,</span><br><span class="line">    if (latest_place_order_date, 1, 0) as if_placed_order</span><br><span class="line">from</span><br><span class="line">    customers_info</span><br></pre></td></tr></table></figure><p>直接使用if语句</p><p>注意：</p><p><strong>if语句的使用</strong></p><p>if(condition1,0)</p><p>条件判断成功则为1，判断失败则为0</p><h2 id="2-VQ23-请按城市对客户进行排序-如果城市为空，则按国家排序">2.<a href="https://www.nowcoder.com/practice/c1b1d5bd008b4797ab2ef53a3afc4aba?tpId=341&amp;tqId=10100109&amp;ru=/exam/oj&amp;qru=/ta/vip-sql/question-ranking&amp;sourceUrl=%2Fexam%2Foj"><strong>VQ23</strong> <strong>请按城市对客户进行排序,如果城市为空，则按国家排序</strong></a></h2><p>这个题目和上一个题目共用一个表，所以我们直接写题解</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select customer_id, gender, city, country, age, latest_place_order_date</span><br><span class="line">from customers_info</span><br><span class="line">order by</span><br><span class="line">    case</span><br><span class="line">        when city is null then country</span><br><span class="line">        else city</span><br><span class="line">    end;</span><br></pre></td></tr></table></figure><p>我们主要是使用了order的分组，然后设置了第一个和第二个的比较条件</p><p>然后end就可以了捏</p><h2 id="3-VQ24-分群并计算群体人数">3.<a href="https://www.nowcoder.com/practice/24319fd5c03e482c935783107114933d?tpId=341&amp;tqId=10100113&amp;ru=/exam/oj&amp;qru=/ta/vip-sql/question-ranking&amp;sourceUrl=%2Fexam%2Foj"><strong>VQ24</strong> <strong>分群并计算群体人数</strong></a></h2><p>这个题目仍然和上一个一样，所以我们直接写题解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">    case</span><br><span class="line">        when age &lt; 20 then &#x27;20以下&#x27;</span><br><span class="line">        when age &lt; 50 then &#x27;20-50&#x27;</span><br><span class="line">        when age &gt; 50 then &#x27;50以上&#x27;</span><br><span class="line">        when age is null then &#x27;未填写&#x27;</span><br><span class="line">    end</span><br><span class="line">    age_group,</span><br><span class="line">    count(customer_id) as user_count</span><br><span class="line">from customers_info</span><br><span class="line">group by age_group;</span><br></pre></td></tr></table></figure><p>主要就是用了case+when进行分组，然后其他的照常理来捏</p><h1>某音面试题目</h1><h2 id="4-SQL156-各个视频的平均完播率">4.<a href="https://www.nowcoder.com/practice/96263162f69a48df9d84a93c71045753?tpId=268&amp;tqId=2285032&amp;ru=/exam/intelligent&amp;qru=/ta/sql-factory-interview/question-ranking&amp;sourceUrl=%2Fexam%2Fintelligent%3Ftype%3Dvip"><strong>SQL156</strong> <strong>各个视频的平均完播率</strong></a></h2><p>用户-视频互动表tb_user_video_log</p><table><thead><tr><th>id</th><th>uid</th><th>video_id</th><th>start_time</th><th>end_time</th><th>if_follow</th><th>if_like</th><th>if_retweet</th><th>comment_id</th></tr></thead><tbody><tr><td>1</td><td>101</td><td>2001</td><td>2021-10-01 10:00:00</td><td>2021-10-01 10:00:30</td><td>0</td><td>1</td><td>1</td><td>NULL</td></tr><tr><td>2</td><td>102</td><td>2001</td><td>2021-10-01 10:00:00</td><td>2021-10-01 10:00:24</td><td>0</td><td>0</td><td>1</td><td>NULL</td></tr><tr><td>3</td><td>103</td><td>2001</td><td>2021-10-01 11:00:00</td><td>2021-10-01 11:00:34</td><td>0</td><td>1</td><td>0</td><td>1732526</td></tr><tr><td>4</td><td>101</td><td>2002</td><td>2021-09-01 10:00:00</td><td>2021-9-01 10:00:42</td><td>1</td><td>0</td><td>1</td><td>NULL</td></tr><tr><td>5</td><td>102</td><td>2002</td><td>2021-10-01 11:00:00</td><td>2021-10-01 10:00:30</td><td>1</td><td>0</td><td>1</td><td>NULL</td></tr></tbody></table><p>（uid-用户ID, video_id-视频ID, start_time-开始观看时间, end_time-结束观看时间, if_follow-是否关注, if_like-是否点赞, if_retweet-是否转发, comment_id-评论ID）</p><p>短视频信息表tb_video_info</p><table><thead><tr><th>id</th><th>video_id</th><th>author</th><th>tag</th><th>duration</th><th>release_time</th></tr></thead><tbody><tr><td>1</td><td>2001</td><td>901</td><td>影视</td><td>30</td><td>2021-01-01 07:00:00</td></tr><tr><td>2</td><td>2002</td><td>901</td><td>美食</td><td>60</td><td>2021-01-01 07:00:00</td></tr><tr><td>3</td><td>2003</td><td>902</td><td>旅游</td><td>90</td><td>2021-01-01 07:00:00</td></tr></tbody></table><p>（video_id-视频ID, author-创作者ID, tag-类别标签, duration-视频时长（秒）, release_time-发布时间）</p><p><strong>问题</strong>：计算2021年里有播放记录的每个视频的完播率(结果保留三位小数)，并按完播率降序排序</p><p><strong>注</strong>：视频完播率是指完成播放次数占总播放次数的比例。简单起见，结束观看时间与开始播放时间的差&gt;=视频时长时，视为完成播放。</p><p>题解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select video_id,ROUND(AVG(IF(TIMESTAMPDIFF(SECOND,start_time,end_time)&gt;=duration,1,0)),3) as avg_comp_play_rate</span><br><span class="line">from tb_user_video_log</span><br><span class="line">join tb_video_info USING(video_id)</span><br><span class="line">where YEAR(start_time)=2021</span><br><span class="line">group by video_id</span><br><span class="line">order by avg_comp_play_rate desc;</span><br></pre></td></tr></table></figure><ul><li>关联用户-视频互动记录和短视频信息表：JOIN tb_video_info USING(video_id)；</li><li>筛选2021年的记录：WHERE YEAR(start_time)=2021</li><li>按视频id分组：GROUP BY video_id</li><li>计算每条播放记录是否完成播放：<code>IF(TIMESTAMPDIFF(SECOND, start_time, end_time)&gt;=duration, 1, 0)</code></li><li>计算完播率，完成播放为1，未完成播放为0，取平均即为完播率AVG()</li><li>保留3位小数：ROUND(x, 3)</li></ul><p>注意：</p><p>！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p><p>在 SQL 中，<code>ROUND()</code> 和 <code>AVG()</code> 这两个函数常用于数值计算：</p><ol><li><strong><code>AVG()</code></strong>: 计算一组数值的平均值。</li><li><strong><code>ROUND()</code></strong>: 对数值进行四舍五入到指定的小数位。</li></ol><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ROUND(AVG(price), 2) AS avg_price</span><br><span class="line">FROM sales;</span><br></pre></td></tr></table></figure><p>求price的平均值，保留两位小数，作为<strong>avg_price</strong></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;if结构&lt;/h1&gt;
&lt;h2 id=&quot;1-VQ22-判断其是否有过购买记录&quot;&gt;1.&lt;a</summary>
        
      
    
    
    
    <category term="sql" scheme="https://mengnankk.asia/categories/sql/"/>
    
    
    <category term="mysql" scheme="https://mengnankk.asia/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>English十月篇</title>
    <link href="https://mengnankk.asia/2024/10/08/en2/"/>
    <id>https://mengnankk.asia/2024/10/08/en2/</id>
    <published>2024-10-07T16:00:00.000Z</published>
    <updated>2024-11-01T03:28:53.987Z</updated>
    
    <content type="html"><![CDATA[<h1>每日一话+单词遗忘表10.8</h1><p>I have committed the worst sin of all that a man can commit. I have not been happy.</p><ul><li>blueprint 蓝图</li><li>blur 涂上，玷污</li><li>boast 自夸</li><li><strong>bold</strong> 大胆的</li><li>bolt 门闩</li><li>bonus 奖金</li><li>blend 混合</li></ul><h1>每日一话+单词遗忘表10.9</h1><p>Man never made any material as resilient as the human spirit.</p><ul><li>boost 促进支援</li><li><strong>booth</strong> 货摊</li><li>blossom 开花</li><li>bay 海湾</li><li>bound 跳</li><li>boundary 分界线</li></ul><h1>每日一话+单词遗忘表10.10</h1><p>今天是澳大利亚vs国足的五个小时前，能不能平啊！</p><p>A work of art must be full of adult dust before anyone can comprehend it.</p><ul><li>bracket 支架</li><li>brag 吹牛</li><li>brake 刹车</li><li>brand 商标</li><li>brand-new 崭新的</li><li>brandy 白兰地酒</li><li>brass 黄铜</li><li>breakdown 损坏</li><li>breakthrough 突破</li><li>boast 自夸</li></ul><h1>每日一话+单词遗忘表10.11</h1><p>I know my brothers would, with dogwood spray in hand, climb up mountain and miss me so far away.</p><ul><li>breed 繁殖</li><li>breeze 微风</li><li>bribe 贿赂</li><li>brick 砖块</li><li>bride 新娘</li><li>brief 简短的</li><li>briefcase 公文包</li><li>broker 经纪人</li><li>brow 眉毛</li></ul><h1>每日一话+单词遗忘表10.12</h1><p>Trees, when they are lopped and cut, grow up again in short time, but men, being once lost, cannot easily be recovered.</p><ul><li>brutal 残忍的</li><li>buckle 扣住</li><li>bud 萌芽</li><li>buddy 小伙伴</li><li>buffet 自助餐</li><li>bulb 电灯泡</li><li>broom 扫把</li><li>bull 牛</li><li>bulletin 公告</li></ul><h1>每日一话+单词遗忘表10.13</h1><p>The promised land always lies on the other side of a wilderness.</p><ul><li>bully 欺凌弱小者</li><li>bump 肿块 碰撞</li><li>bumper 丰富的</li><li>bundle 捆</li><li>burden 负担</li><li>bureau 局</li><li>burn 燃烧</li><li>burst 爆炸</li><li>bury 隐藏</li><li>butter 黄油</li><li>broker 经纪人</li><li>bulk 体积</li></ul><h1>每日一话+单词遗忘表10.14</h1><p>Some people succeed because they are destined to, but most people succeed because they are determined to.</p><ul><li><strong>bystander</strong> 旁观者</li><li>bud 萌芽</li><li>cabin 小屋</li><li>cabinet 内阁</li><li><strong>cable</strong> 电缆</li><li>cage 笼子</li><li>bury 埋葬</li><li>calf 牛犊</li></ul><h1>每日一话+单词遗忘表10.15</h1><p>You run from one place to another, but you are still you. You can’t escape from your body.</p><ul><li>camel 骆驼</li><li>camera 照相机</li><li>campaign 运动</li><li>bully 欺凌弱小</li><li><strong>cane 手杖</strong></li><li>canteen 小食堂</li><li>capacity 能力，容量</li><li>capture 夺得</li></ul><h1>每日一话+单词遗忘表10.16</h1><p>He who is of a calm and happy nature will hardly feel the pressure of age, but to him who is of an opposite disposition, youth and age are equally a burden.</p><ul><li>cargo  货船</li><li>carpenter 木工</li><li>cart 二轮装甲货车</li><li>castle 城堡</li><li><strong>cast</strong> 投掷</li></ul><h1>每日一话+单词遗忘表10.17</h1><p>The trees are in their autumn beauty. The woodland paths are dry. Under the October twilight the water Mirrors a still sky.</p><ul><li>casual 偶然的</li><li>catalog 目录</li><li>cater 迎合满足</li><li>caution 小心</li><li>cave 塌陷</li><li>cease 停止</li><li>ceiliing 天花板</li><li>cement 粘合物</li></ul><h1>每日一话+单词遗忘表10.18</h1><p>If you doubt yourself, then indeed you stand on shaky ground.</p><ul><li>centigrade 摄氏度</li><li>cereal 谷类</li><li><strong>ceremony</strong> 典礼</li><li>certain 某一</li><li>certficate 执照</li><li>chain 链子</li><li>chalk 粉笔</li><li>champagne 香槟</li><li>channel 频道</li><li>chaos 混乱</li><li>caution 小心</li></ul><h1>每日一话+单词遗忘表10.19</h1><p>When your will is ready, your feet are light.</p><ul><li>charity 慈善</li><li>chef 厨师</li><li>cherish 珍爱</li><li>chest 胸部</li></ul><h1>每日一话+单词遗忘表10.20</h1><p>He who rides and keeps the beaten track studies the fences chiefly.</p><ul><li>chief 领袖</li><li>chill 寒冷</li><li>chimney 烟囱</li><li>chin 下巴</li><li><strong>choke</strong> 窒息</li><li>cholestaerol 胆固醇</li><li>chop 排骨</li><li>chorus 合唱</li><li>chirist 基督</li><li>church 教堂</li><li>chore 家务</li></ul><h1>每日一话+单词遗忘表10.21</h1><p>The longer we dwell on our misfortunes, the greater is their power to harm us.</p><ul><li>circuit 巡回</li><li>circulate 循环</li><li>circumstance 环境</li><li>circus 马戏团</li><li>cite 引用</li><li>civil 公民的</li><li>clap 鼓掌</li><li>clarity 清楚</li></ul><h1>每日一话+单词遗忘表10.22</h1><p>We are what we repeatedly do. Excellence, then, is not an act but a habit.</p><ul><li>clause 条款</li><li>claw 爪子</li><li>clay 粘土</li><li>clerk 职员</li><li>cliff 悬崖</li><li>climax 高潮</li><li>cling 紧贴</li></ul><h1>每日一话+单词遗忘表10.23</h1><p>Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul.</p><ul><li>chart 图表</li><li>clue 线索</li><li>clumsy 笨拙的</li><li>coarse 粗糙的</li><li>cock 雄鸡</li><li><strong>coherent</strong> 连贯的</li><li>cohesion 凝聚力</li></ul><h1>每日一话+单词遗忘表10.24</h1><p>Happy are the families where the government of parents is the reign of affection, and obedience of the children the submission of love.</p><ul><li>coil 盘绕</li><li>cellar 地窖</li><li>collaborate 合作</li><li>collapse 倒坍</li><li>collar 项圈</li><li><strong>colon</strong> 冒号</li><li><strong>colony</strong> 殖民队</li><li>column 圆柱</li><li></li></ul><h1>每日一话+单词遗忘表10.25</h1><p>Delicious autumn! My very soul is wedded to it, and if I were a bird I would fly about the earth seeking the successive autumns.</p><ul><li>comma 逗号</li><li>commence 开始</li><li>commerce 贸易</li><li><strong>commission</strong> 委托</li><li>commodity 商品</li><li>commonplace 平凡的</li><li>commune 公社</li><li>commute 通勤</li><li><strong>compact</strong> 合同</li><li>companion 同伴</li></ul><h1>每日一话+单词遗忘表10.26</h1><p>That man is the richest whose pleasures are the cheapest.</p><ul><li>compatible 并存的</li><li>compel 强迫</li><li><strong>competent</strong> 有能力的</li><li>complicate 使复杂化</li><li><strong>compensate</strong> 补偿</li><li><strong>component</strong> 元件</li><li>compound 合成</li><li><strong>comprehend</strong> 理解</li><li><strong>comprehensive</strong> 广泛的</li><li>comprise 由。。。组成</li><li><strong>compulsory</strong> 强制性的</li><li></li></ul><h1>每日一话+单词遗忘表10.27</h1><p>Nature gives you the face you have at twenty; it is up to you to merit the face you have at fifty.</p><ul><li>conceal 隐藏</li><li>concentrate 专心</li><li>conclude 作出决议</li><li>concreate 实在的</li><li>condense 浓缩</li><li>conduct 行为</li><li><strong>conference</strong> 会议</li><li>confess 承认</li><li><strong>confine</strong> 限制</li></ul><h1>单词遗忘表10.28</h1><ul><li>Confucian 孔子的</li><li>confuse 使混乱</li><li>congress 国会</li><li>conjunction 结合</li><li>conquer 战胜</li><li><strong>conscience</strong> 良心</li><li><strong>conscientious</strong> 认真的</li><li>conscious 意识到</li><li>consensus 一致</li><li><strong>consent</strong> 同意</li><li>consequence 结果</li><li>conservative 保守的</li><li>consolidate 巩固</li><li></li></ul><h1>每日一话+单词遗忘表10.29</h1><p>We must not cease from exploration and the end of all our exploring will be to arrive where we began and to know the place for the first time.</p><ul><li><strong>constitute</strong> 构成</li><li>constitution 宪法</li><li><strong>consult</strong> 查阅</li><li>contaminate 污染</li><li><strong>contempt</strong> 轻视</li><li><strong>contradict</strong> 反驳</li><li>contrary 相反的</li></ul><h1>每日一话+单词遗忘表10.30</h1><p>Sometimes our fate resembles a fruit tree in winter. Who would think that those branches would turn green and blossom, but we hope it, we know it.</p><ul><li><strong>controversy</strong> 辩论</li><li>converse 相反的</li><li>convey 传达</li><li>convince 说服</li><li><strong>cooridinate</strong> 一致</li><li>cop 抓住，警官</li></ul><h1>每日一话+单词遗忘表10.31</h1><p>Halloween, celebrated on October 31 every year, gets millions of people around the world to wear their scariest costume while partying or trick or treating.</p><p>哦~今天正好是万圣节，感觉不如我们自己的鬼节(七月十五)！</p><ul><li>collective 集体的</li><li>corner 角落</li><li>cornerstone 奠定基石基础</li><li>corporation 公司</li><li>corps 兵团</li><li><strong>correspond</strong> 相符合</li><li>corridor 走廊</li><li>corrupt 腐败的</li><li>cosmos 宇宙</li><li>council 会议</li><li></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;每日一话+单词遗忘表10.8&lt;/h1&gt;
&lt;p&gt;I have committed the worst sin of all that a man can commit. I have not been happy.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;blueprint</summary>
        
      
    
    
    
    <category term="English" scheme="https://mengnankk.asia/categories/English/"/>
    
    
    <category term="English" scheme="https://mengnankk.asia/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 进阶</title>
    <link href="https://mengnankk.asia/2024/10/07/reg-exp2/"/>
    <id>https://mengnankk.asia/2024/10/07/reg-exp2/</id>
    <published>2024-10-06T16:00:00.000Z</published>
    <updated>2024-10-08T07:47:44.194Z</updated>
    
    <content type="html"><![CDATA[<h1>非贪婪匹配</h1><p>给定一个字符串表示的数字，判断该数字末尾<code>0</code>的个数。例如：</p><ul><li><code>&quot;123000&quot;</code>：3个<code>0</code></li><li><code>&quot;10100&quot;</code>：2个<code>0</code></li><li><code>&quot;1001&quot;</code>：0个<code>0</code></li></ul><p>可以很容易地写出该正则表达式：<code>(\d+)(0*)</code></p><p>这是因为正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(\\d+?)(<span class="number">0</span>*)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就代表非贪婪匹配，不会让\d少匹配，0*多匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d??)(9*)</span><br></pre></td></tr></table></figure><p>我们再来看这个正则表达式<code>(\d??)(9*)</code>，注意<code>\d?</code>表示匹配0个或1个数字，后面第二个<code>?</code>表示非贪婪匹配，因此，给定字符串<code>&quot;9999&quot;</code>，匹配到的两个子串分别是<code>&quot;&quot;</code>和<code>&quot;9999&quot;</code>，因为对于<code>\d?</code>来说，可以匹配1个<code>9</code>，也可以匹配0个<code>9</code>，但是因为后面的<code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个<code>9</code></p><h1>搜索和替换</h1><p>使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;a b c&quot;.split(&quot;\\s&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span><br><span class="line">&quot;a b  c&quot;.split(&quot;\\s&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span><br><span class="line">&quot;a, b ;; c&quot;.split(&quot;[\\,\\;\\s]+&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure><h2 id="搜索">搜索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.*;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;the quick brown fox jumps over the lazy dog.&quot;;</span><br><span class="line">        Pattern p = Pattern.compile(&quot;\\wo\\w&quot;);</span><br><span class="line">        Matcher m = p.matcher(s);</span><br><span class="line">        while (m.find()) &#123;</span><br><span class="line">            String sub = s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码就是找中间有前面一个字符后面一个。中间有个o的字符</p><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">row</span><br><span class="line">fox</span><br><span class="line">dog</span><br></pre></td></tr></table></figure><h2 id="替换">替换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// regex</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;;</span><br><span class="line">        String r = s.replaceAll(&quot;\\s+&quot;, &quot; &quot;);</span><br><span class="line">        System.out.println(r); // &quot;The quick brown fox jumps over the lazy dog.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><h2 id="反向引用">反向引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// regex</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;the quick brown fox jumps over the lazy dog.&quot;;</span><br><span class="line">        String r = s.replaceAll(&quot;\\s([a-z]&#123;4&#125;)\\s&quot;, &quot; &lt;b&gt;$1&lt;/b&gt; &quot;);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.</span><br></pre></td></tr></table></figure><p>它实际上把任何4字符单词的前后用<code>&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于<code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串<code>([a-z]&#123;4&#125;)</code>替换了<code>$1</code>。</p><p>方法：</p><p>使用正则表达式可以：</p><ul><li>分割字符串：<code>String.split()</code></li><li>搜索子串：<code>Matcher.find()</code></li><li>替换字符串：<code>String.replaceAll()</code></li></ul><h1>练习</h1><p>模板引擎是指，定义一个字符串作为模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, $&#123;name&#125;! You are learning $&#123;lang&#125;!</span><br></pre></td></tr></table></figure><p>其中，以<code>$&#123;key&#125;</code>表示的是变量，也就是将要被替换的内容。</p><p>当传入一个<code>Map&lt;String, String&gt;</code>给模板后，需要把对应的key替换为Map的value。</p><p>例如，传入<code>Map</code>为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lang&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Java&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后，<code>$&#123;name&#125;</code>被替换为<code>Map</code>对应的值<code>Bob</code>，<code>$&#123;lang&#125;</code>被替换为<code>Map</code>对应的值<code>Java</code>，最终输出的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Bob! You are learning Java!</span><br></pre></td></tr></table></figure><p>请编写一个简单的模板引擎，利用正则表达式实现这个功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Map;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class reg_exp &#123;</span><br><span class="line">    public static String render(String template, Map&lt;String, String&gt; values) &#123;</span><br><span class="line">        // 定义匹配 $&#123;key&#125; 的正则表达式</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;\\$\\&#123;(\\w+)&#125;&quot;);</span><br><span class="line">        Matcher matcher = pattern.matcher(template);</span><br><span class="line"></span><br><span class="line">        // 使用 StringBuffer 来高效拼接替换后的字符串</span><br><span class="line">        StringBuffer result = new StringBuffer();</span><br><span class="line"></span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            String key = matcher.group(1);  // 获取 $&#123;key&#125; 中的 key</span><br><span class="line">            String replacement = values.getOrDefault(key, &quot;&quot;);  // 从 Map 中获取 key 对应的值</span><br><span class="line">            matcher.appendReplacement(result, replacement);  // 替换 $&#123;key&#125; 为对应的值</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        matcher.appendTail(result);  // 添加剩余的部分</span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义模板</span><br><span class="line">        String template = &quot;Hello, $&#123;name&#125;! You are learning $&#123;lang&#125;!&quot;;</span><br><span class="line"></span><br><span class="line">        // 定义替换内容的 Map</span><br><span class="line">        Map&lt;String, String&gt; values = Map.of(</span><br><span class="line">                &quot;name&quot;, &quot;Bob&quot;,</span><br><span class="line">                &quot;lang&quot;, &quot;Java&quot;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>还有很多正则表达式的内容，可以在<a href="https://regex101.com/">https://regex101.com/</a></p><p>在线查看</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;非贪婪匹配&lt;/h1&gt;
&lt;p&gt;给定一个字符串表示的数字，判断该数字末尾&lt;code&gt;0&lt;/code&gt;的个数。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;123000&amp;quot;&lt;/code&gt;：3个&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;qu</summary>
        
      
    
    
    
    <category term="java" scheme="https://mengnankk.asia/categories/java/"/>
    
    
    <category term="正则表达式" scheme="https://mengnankk.asia/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux log日志篇</title>
    <link href="https://mengnankk.asia/2024/10/05/linux7/"/>
    <id>https://mengnankk.asia/2024/10/05/linux7/</id>
    <published>2024-10-04T16:00:00.000Z</published>
    <updated>2024-10-06T04:27:54.552Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>是重要的系统信息文件，记录了重要的系统事件</p><p>一般保存在/var/log目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vmware-vmsvc-root.1.log</span><br><span class="line">.rw-------  root              root            4.9 KB Sat Oct  5 08:53:43 2024  vmware-vmsvc-root.2.log</span><br><span class="line">.rw-------  root              root            3.6 KB Fri Oct  4 21:03:05 2024  vmware-vmsvc-root.3.log</span><br><span class="line">.rw-------  root              root            3.4 KB Sat Oct  5 09:15:19 2024  vmware-vmsvc-root.log</span><br><span class="line">.rw-------  root              hadoop          1.1 KB Sun Sep 29 19:47:23 2024  vmware-vmtoolsd-hadoop.log</span><br><span class="line">.rw-------  root              mengnankk        34 KB Sat Oct  5 09:15:36 2024  vmware-vmtoolsd-mengnankk.log</span><br><span class="line">.rw-------  root              root             34 KB Sat Oct  5 09:15:18 2024  vmware-vmtoolsd-root.log</span><br><span class="line">.rw-------  root              hadoop          4.7 KB Sun Sep 29 20:48:11 2024  vmware-vmusr-hadoop.log</span><br><span class="line">.rw-------  root              mengnankk       118 KB Sat Oct  5 09:15:40 2024  vmware-vmusr-mengnankk.log</span><br><span class="line">drwxrwxrwx  root              root            4.0 KB Mon Sep 30 21:39:40 2024  </span><br></pre></td></tr></table></figure><h2 id="lastlog">lastlog</h2><p>直接使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastlog</span><br></pre></td></tr></table></figure><p>查看最后登录用户的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ lastlog</span><br><span class="line">用户名           端口     来自             最后登录时间</span><br><span class="line">root             pts/6    127.0.0.1        二 9月 24 19:06:43 +0800 2024</span><br><span class="line">daemon                                     **从未登录过**</span><br><span class="line">bin                                        **从未登录过**</span><br><span class="line">sys                                        **从未登录过**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为是二进制文件，所以不要用cat打印了</p><p>直接使用指令就行</p><h2 id="boot-log">boot.log</h2><p>这里面是系统启动的一些日志</p><h2 id="cron">cron</h2><p>这里面是关于系统定时任务的一些日志记录</p><h2 id="message">message</h2><p>系统出现故障，首先找这个日志，用来记录系统故障的日志</p><h2 id="secure">secure</h2><p>这里面主要是安全性问题，系统登录ssh等一些列的有关安全的问题，包括密码等</p><h2 id="utmp">utmp</h2><p>记录当前登录用户的信息</p><p>w who等命令就是记录的他的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ w</span><br><span class="line"> 10:53:25 up  1:38,  1 user,  load average: 0.42, 0.15, 0.06</span><br><span class="line">USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">mengnank tty2     tty2             09:15    1:38m  0.03s  0.03s /usr/libexec/gn</span><br></pre></td></tr></table></figure><h1>日志管理服务</h1><p>我的localhost使用的是rsyslog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ps aux | rg &quot;rsyslog&quot;</span><br><span class="line">syslog      1022  0.0  0.1 222404  6528 ?        Ssl  09:15   0:00 /usr/sbin/rsyslogd -n -iNONE</span><br><span class="line">mengnan+   42697  0.0  0.1   8456  5888 pts/0    S+   10:58   0:00 rg rsyslog</span><br></pre></td></tr></table></figure><p>使用该命令查看是否在运行</p><p>rsyslog是一个后台程序，就是一个日志</p><p>/etc/rsyslog.conf</p><p>在这个文件里记录要管理的日志有哪些</p><p>还有一些规则，日志类型等一系列的东西</p><p><strong>在进行这个日志管理的时候，这个服务必须在运行才可以捏</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ps aux | rg &quot;rsyslog&quot;|rg -v &quot;rg&quot;</span><br><span class="line">syslog      1017  0.0  0.1 222404  5760 ?        Ssl  17:24   0:00 /usr/sbin/rsyslogd -n -iNONE</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反向再过滤一下，就只有我们</p><p><strong>rg -v 是反向匹配（挑选出前面不包含的）</strong></p><p>其实就相对于非</p><p>查看rsyslog服务是否是自启动的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ systemctl list-unit-files | rg &quot;rsyslog&quot;</span><br><span class="line"></span><br><span class="line">rsyslog.service                                enabled         enabled</span><br></pre></td></tr></table></figure><p>发现他是的捏</p><h2 id="配置文件">配置文件</h2><p>/etc/rsyslog.conf这个文件</p><ul><li>debug</li><li>info</li><li>notice</li><li>warning</li><li>err</li><li>crit</li><li>alert</li><li>emerg</li><li>none</li></ul><p>从下面上面，级别是由高到低的，记录的信息越来越多</p><p>emerg就是内核都崩溃了</p><p>none就是什么也不给记录</p><p>实例</p><p>修改配置文件</p><p>在/var/log/hsp.log下添加文件，看重启是否有信息显示</p><h2 id="分类">分类</h2><p><strong><code>auth</code></strong> (Authentication Logs):</p><ul><li>文件：<code>/var/log/auth.log</code> (Debian/Ubuntu) 或 <code>/var/log/secure</code> (RHEL/CentOS)</li><li>作用：记录系统的认证事件，如用户登录、<code>sudo</code> 提权、SSH 登录尝试等。</li></ul><p><strong><code>syslog</code></strong> (System Logs):</p><ul><li>文件：<code>/var/log/syslog</code> (Debian/Ubuntu) 或 <code>/var/log/messages</code> (RHEL/CentOS)</li><li>作用：捕捉常规系统事件，除了认证信息外，记录各种系统进程输出的消息。</li></ul><p><strong><code>kern</code></strong> (Kernel Logs):</p><ul><li>文件：<code>/var/log/kern.log</code></li><li>作用：记录内核生成的日志信息，如硬件检测、模块加载、内核异常等。</li></ul><p><strong><code>cron</code></strong> (Cron Jobs Logs):</p><ul><li>文件：<code>/var/log/cron.log</code> (Debian/Ubuntu) 或 <code>/var/log/cron</code> (RHEL/CentOS)</li><li>作用：记录由 <code>cron</code> 调度的任务执行信息，包括定时任务的成功与失败。</li></ul><p><strong><code>boot</code></strong> (Boot Logs):</p><ul><li>文件：<code>/var/log/boot.log</code></li><li>作用：记录系统启动过程中的信息，帮助排查启动时发生的问题。</li></ul><p><strong><code>dmesg</code></strong> (Kernel Ring Buffer Logs):</p><ul><li>文件：通过命令 <code>dmesg</code> 查看</li><li>作用：显示内核环缓冲中的信息，特别是与设备驱动、硬件相关的信息。</li></ul><p><strong><code>apache</code>/<code>nginx</code></strong> (Web Server Logs):</p><ul><li>文件：<code>/var/log/apache2/access.log</code>, <code>/var/log/nginx/access.log</code>, <code>/var/log/apache2/error.log</code>, <code>/var/log/nginx/error.log</code></li><li>作用：记录 Web 服务器的访问日志、错误日志，包含每次客户端请求的详细信息。</li></ul><p><strong><code>mysql</code></strong> (MySQL Logs):</p><ul><li>文件：<code>/var/log/mysql.log</code> 或 <code>/var/log/mysqld.log</code></li><li>作用：记录 MySQL 数据库的查询日志、错误日志以及慢查询日志。</li></ul><p><strong><code>mail</code></strong> (Mail Logs):</p><ul><li>文件：<code>/var/log/mail.log</code></li><li>作用：记录邮件服务器的发送和接收信息，帮助管理员监控邮件通信。</li></ul><p><strong><code>Xorg</code></strong> (X Window System Logs):</p><ul><li>文件：<code>/var/log/Xorg.0.log</code></li><li>作用：记录与图形界面启动相关的信息，包括图形硬件的状态、驱动加载情况等。</li></ul><h1>日志轮替</h1><p>按照一定的策略。保留日志文件。旧的就是删除</p><p>使用的是logrotate</p><p>配置文件在/etc/logrotate.conf</p><p>是一个全局日志轮替规则，当然也可以给某个日志文件指定策略</p><p>配置文件中有<strong>dateext</strong>参数那么就会用日期来做日志文件的参数，只需要删除就可以</p><p>没有<strong>dateext</strong>参数的时候，就会自动改名</p><p>比如secure1 secure2</p><p>轮替的时候，1会变成2，2又会变成1以此轮替</p><p><strong>如果超过默认保存的个数，旧的就会删除掉</strong></p><p><strong>自定义的日志轮替规则是最高级的</strong></p><p>我们可以自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/var/log/wtemp&#123;</span><br><span class="line">monthly</span><br><span class="line">create 0664 root utmp</span><br><span class="line">minisize 1M</span><br><span class="line">retate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以某个日志文件的轮替规则写到</p><p>/etc/logrotate.d目录下单独设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ z /etc/logrotate.d</span><br><span class="line">❯ ls</span><br><span class="line">alternatives  cups-daemon   ppp           sane-utils           wtmp</span><br><span class="line">apport        dnf           preload       speech-dispatcher</span><br><span class="line">apt           dpkg          redis-server  ubuntu-pro-client</span><br><span class="line">bootlog       firewalld     rsyslog       ufw</span><br><span class="line">btmp          mysql-server  samba         unattended-upgrades</span><br></pre></td></tr></table></figure><p>查看例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">❯ bat bootlog</span><br><span class="line">───────┬────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: bootlog</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ /var/log/boot.log</span><br><span class="line">   2   │ &#123;</span><br><span class="line">   3   │     missingok</span><br><span class="line">   4   │     daily</span><br><span class="line">   5   │     copytruncate</span><br><span class="line">   6   │     rotate 7</span><br><span class="line">   7   │     notifempty</span><br><span class="line">   8   │ &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现了bootlog就是单独设置的捏</p><p>感觉一般写在这里是比较好的选择</p><h3 id="常见的-logrotate-配置参数">常见的 <code>logrotate</code> 配置参数</h3><ol><li><p><strong><code>daily</code> / <code>weekly</code> / <code>monthly</code> / <code>yearly</code></strong></p><ul><li>说明：指定日志文件轮替的频率。</li><li>示例：<code>daily</code> 表示每天轮替一次日志；<code>weekly</code> 表示每周轮替一次。</li></ul></li><li><p><strong><code>rotate &lt;count&gt;</code></strong></p><ul><li>说明：保留的旧日志文件数量，超出数量的日志文件将被删除。</li><li>示例：<code>rotate 5</code> 表示最多保留 5 个历史日志文件。</li></ul></li><li><p><strong><code>compress</code></strong></p><ul><li>说明：启用压缩功能，轮替后的日志文件会使用 <code>gzip</code> 进行压缩。</li><li>示例：<code>compress</code> 表示开启压缩，生成 <code>.gz</code> 文件。</li></ul></li><li><p><strong><code>compresscmd &lt;command&gt;</code></strong></p><ul><li>说明：指定压缩时使用的命令，默认是 <code>gzip</code>。</li><li>示例：<code>compresscmd bzip2</code> 可以指定使用 <code>bzip2</code> 进行压缩。</li></ul></li><li><p><strong><code>uncompresscmd &lt;command&gt;</code></strong></p><ul><li>说明：指定解压缩时使用的命令。</li><li>示例：<code>uncompresscmd bunzip2</code> 可以指定使用 <code>bunzip2</code> 进行解压缩。</li></ul></li><li><p><strong><code>delaycompress</code></strong></p><ul><li>说明：推迟日志压缩，只有在下次轮替时才压缩之前的日志。</li><li>示例：<code>delaycompress</code> 常与 <code>compress</code> 一起使用，表示日志轮替后不会立即压缩，而是等到下一次轮替时再压缩上一个日志文件。</li></ul></li><li><p><strong><code>create &lt;mode&gt; &lt;owner&gt; &lt;group&gt;</code></strong></p><ul><li>说明：在日志轮替后创建新的日志文件，并指定其权限、所有者和所属组。</li><li>示例：<code>create 644 root adm</code> 会创建一个权限为 <code>644</code>，所有者为 <code>root</code>，组为 <code>adm</code> 的新日志文件。</li></ul></li><li><p><strong><code>notifempty</code></strong></p><ul><li>说明：如果日志文件为空，则不进行轮替。</li><li>示例：<code>notifempty</code> 可避免对空日志文件进行轮替操作。</li></ul></li><li><p><strong><code>missingok</code></strong></p><ul><li>说明：如果日志文件不存在，则跳过而不报错。</li><li>示例：<code>missingok</code> 防止 <code>logrotate</code> 在找不到日志文件时产生错误。</li></ul></li><li><p><strong><code>size &lt;size&gt;</code></strong></p><ul><li>说明：当日志文件达到指定的大小时进行轮替。</li><li>示例：<code>size 100M</code> 表示日志文件达到 100MB 时轮替。</li></ul></li><li><p><strong><code>dateext</code></strong></p><ul><li>说明：在轮替的日志文件名中添加日期后缀。</li><li>示例：<code>dateext</code> 会让日志文件的后缀变为形如 <code>.20231005</code>。</li></ul></li><li><p><strong><code>dateformat &lt;format&gt;</code></strong></p><ul><li>说明：自定义日期后缀的格式（与 <code>dateext</code> 一起使用）。</li><li>示例：<code>dateformat -%Y%m%d</code> 可以将后缀格式设定为 <code>-YYYYMMDD</code>。</li></ul></li><li><p><strong><code>maxsize &lt;size&gt;</code></strong></p><ul><li>说明：指定日志文件的最大大小。如果文件超过此大小，会强制进行轮替。</li><li>示例：<code>maxsize 500M</code> 表示日志文件超过 500MB 时轮替。</li></ul></li><li><p><strong><code>postrotate</code> / <code>prerotate</code> / <code>endscript</code></strong></p><ul><li><p>说明：定义轮替前（<code>prerotate</code>）或轮替后（<code>postrotate</code>）执行的命令。<code>endscript</code> 用于结束 <code>postrotate</code> 或 <code>prerotate</code> 块。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码postrotate</span><br><span class="line">    systemctl reload nginx</span><br><span class="line">endscript</span><br></pre></td></tr></table></figure><p>表示在日志轮替之后，重新加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>服务。</p></li></ul></li><li><p><strong><code>copytruncate</code></strong></p><ul><li>说明：复制当前日志文件，并截断原日志文件，适用于那些在打开日志文件时不能关闭的进程。</li><li>示例：<code>copytruncate</code> 会在日志文件轮替时复制当前文件，然后将原文件截断为 0 字节。</li></ul></li><li><p><strong><code>olddir &lt;directory&gt;</code></strong></p><ul><li>说明：将轮替后的日志文件移动到指定的目录中。</li><li>示例：<code>olddir /var/log/old</code> 表示轮替后的旧日志文件会被移动到 <code>/var/log/old</code> 目录中。</li></ul></li><li><p><strong><code>mail &lt;address&gt;</code></strong></p><ul><li>说明：当日志文件轮替后，将该日志文件通过邮件发送到指定的电子邮箱。</li><li>示例：<code>mail admin@example.com</code> 会将轮替后的日志发送给 <code>admin@example.com</code>。</li></ul></li><li><p><strong><code>nomail</code></strong></p><ul><li>说明：禁用邮件功能。</li><li>示例：<code>nomail</code> 禁止发送日志文件邮件。</li></ul></li></ol><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/var/log/nginx/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    missingok</span><br><span class="line">    rotate 14</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    notifempty</span><br><span class="line">    create 640 www-data adm</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        systemctl reload nginx &gt; /dev/null 2&gt;/dev/null || true</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置的含义：</p><ul><li>每天轮替 <code>/var/log/nginx/</code> 目录下的日志文件。</li><li>如果日志文件不存在，跳过轮替，不报错。</li><li>最多保留 14 个日志文件。</li><li>轮替后的日志文件进行压缩，但推迟到下一次轮替时再压缩。</li><li>如果日志文件为空，则不轮替。</li><li>轮替后创建权限为 <code>640</code>，所有者为 <code>www-data</code>，所属组为 <code>adm</code> 的新日志文件。</li><li>轮替后执行 <code>systemctl reload nginx</code>，重新加载 nginx 配置。</li></ul><p>直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hsplog</span><br></pre></td></tr></table></figure><p>然后输入就可以了</p><h2 id="机制">机制</h2><p>依赖于定时任务机制<strong>crond</strong></p><p>在/etc/cron.daily下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ z /etc/cron.daily</span><br><span class="line">❯ ls</span><br><span class="line">0anacron  apt-compat        dpkg           locate     man-db  samba</span><br><span class="line">apport    cracklib-runtime  google-chrome  logrotate  ntp</span><br></pre></td></tr></table></figure><p>主要是执行logrotate这个</p><h1>内存日志</h1><p>是先写到内存里，没在日志文件里</p><p>重新启动的时候，内存日志会清空</p><p>journalctl</p><ul><li>无参数查看全部</li><li>-n num查看多少条</li><li>–sine 19:00 --until 19:10:10 起始时间</li><li>-o verbose 详细信息</li><li>PID=1245 _COMM=sshd 查看这些</li></ul><p>感觉直接筛选更好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">10月 05 08:54:03 mengnankk-linux sshd[1270]: Server listening on :: port 22.</span><br><span class="line">10月 05 09:14:54 mengnankk-linux sshd[1270]: Received signal 15; terminating.</span><br><span class="line">10月 05 09:15:19 mengnankk-linux sshd[1262]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">10月 05 09:15:19 mengnankk-linux sshd[1262]: Server listening on :: port 22.</span><br><span class="line">10月 05 17:24:44 mengnankk-linux sshd[1268]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">10月 05 17:24:44 mengnankk-linux sshd[1268]: Server listening on :: port 22.</span><br><span class="line">10月 05 19:08:11 mengnankk-linux sshd[1268]: Received signal 15; terminating.</span><br><span class="line">10月 05 19:08:33 mengnankk-linux sshd[1240]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">10月 05 19:08:33 mengnankk-linux sshd[1240]: Server listening on :: port 22.</span><br><span class="line">10月 06 09:04:07 mengnankk-linux sshd[1300]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">10月 06 09:04:07 mengnankk-linux sshd[1300]: Server listening on :: port 22.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接出现</p><p>over</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;是重要的系统信息文件，记录了重要的系统事件&lt;/p&gt;
&lt;p&gt;一般保存在/var/log目录下&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="Linux" scheme="https://mengnankk.asia/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 基础篇</title>
    <link href="https://mengnankk.asia/2024/10/03/reg-exp1/"/>
    <id>https://mengnankk.asia/2024/10/03/reg-exp1/</id>
    <published>2024-10-02T16:00:00.000Z</published>
    <updated>2024-10-06T11:03:26.157Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。</p><p>正则表达式是一套标准，它可以用于任何语言。Java标准库的<code>java.util.regex</code>包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。</p><p>举个例子：要判断用户输入的年份是否是<code>20##</code>年，我们先写出规则如下：</p><p>一共有4个字符，分别是：<code>2</code>，<code>0</code>，<code>0~9任意数字</code>，<code>0~9任意数字</code>。</p><p>对应的正则表达式就是：<code>20\d\d</code>，其中<code>\d</code>表示任意一个数字。</p><p>在java中就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20\\d\\d</span><br></pre></td></tr></table></figure><p><strong>注意Java字符串用<code>\\</code>表示<code>\</code>。</strong></p><h1>匹配规则</h1><p><strong>正则表达式的匹配规则是从左到右按规则匹配</strong></p><h2 id="">&amp;</h2><p>正则表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a\&amp;c</span><br></pre></td></tr></table></figure><p>它能精确匹配字符串<code>&quot;a&amp;c&quot;</code></p><p>但不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a-c&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>等</p><p>如果想匹配非ASCII字符，例如中文，那就用<code>\u####</code>的十六进制表示，例如：<code>a\u548cc</code>匹配字符串<code>&quot;a和c&quot;</code>，中文字符<code>和</code>的Unicode编码是<code>548c</code></p><p>这上面是精确匹配，但是用处不大。</p><p>因为我们可以直接String.equals()即可</p><h2 id="-2">.</h2><p>可以用<code>.</code>匹配一个任意字符。</p><p>例如，正则表达式<code>a.c</code>中间的<code>.</code>可以匹配一个任意字符，例如，下面的字符串都可以被匹配：</p><ul><li><code>&quot;abc&quot;</code>，因为<code>.</code>可以匹配字符<code>b</code>；</li><li><code>&quot;a&amp;c&quot;</code>，因为<code>.</code>可以匹配字符<code>&amp;</code>；</li><li><code>&quot;acc&quot;</code>，因为<code>.</code>可以匹配字符<code>c</code>。</li></ul><p><strong>但它不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>，因为<code>.</code>匹配一个字符且仅限一个字符。</strong></p><h2 id="d">\d</h2><p>如果我们只想匹配<code>0</code>~<code>9</code>这样的数字，可以用<code>\d</code>匹配。例如，正则表达式<code>00\d</code>可以匹配：</p><ul><li><code>&quot;007&quot;</code>，因为<code>\d</code>可以匹配字符<code>7</code>；</li><li><code>&quot;008&quot;</code>，因为<code>\d</code>可以匹配字符<code>8</code>。</li></ul><p>它不能匹配<code>&quot;00A&quot;</code>，<code>&quot;0077&quot;</code>，因为<code>\d</code>仅限单个数字字符。</p><h2 id="w">\w</h2><p>用<code>\w</code>可以匹配一个字母、数字或下划线，w的意思是word。例如，<code>java\w</code>可以匹配：</p><ul><li><code>&quot;javac&quot;</code>，因为<code>\w</code>可以匹配英文字符<code>c</code>；</li><li><code>&quot;java9&quot;</code>，因为<code>\w</code>可以匹配数字字符<code>9</code>；。</li><li><code>&quot;java_&quot;</code>，因为<code>\w</code>可以匹配下划线<code>_</code>。</li></ul><p>它不能匹配<code>&quot;java#&quot;</code>，<code>&quot;java &quot;</code>，因为<code>\w</code>不能匹配<code>#</code>、空格等字符。</p><h2 id="s">\s</h2><p>用<code>\s</code>可以匹配一个空格字符，注意空格字符不但包括空格<code> </code>，还包括tab字符（在Java中用<code>\t</code>表示）。例如，<code>a\sc</code>可以匹配：</p><ul><li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配空格字符<code> </code>；</li><li><code>&quot;a c&quot;</code>，因为<code>\s</code>可以匹配tab字符<code>\t</code>。</li></ul><p>它不能匹配<code>&quot;ac&quot;</code>，<code>&quot;abc&quot;</code>等。</p><h2 id="D">\D</h2><p>用<code>\d</code>可以匹配一个数字，而<code>\D</code>则匹配一个非数字。例如，<code>00\D</code>可以匹配：</p><ul><li><code>&quot;00A&quot;</code>，因为<code>\D</code>可以匹配非数字字符<code>A</code>；</li><li><code>&quot;00#&quot;</code>，因为<code>\D</code>可以匹配非数字字符<code>#</code>。</li></ul><p><code>00\d</code>可以匹配的字符串<code>&quot;007&quot;</code>，<code>&quot;008&quot;</code>等，<code>00\D</code>是不能匹配的。</p><p>类似的，<code>\W</code>可以匹配<code>\w</code>不能匹配的字符，<code>\S</code>可以匹配<code>\s</code>不能匹配的字符，这几个正好是反着来的。</p><h2 id="-3">*</h2><p>修饰符<code>*</code>可以匹配任意个字符，包括0个字符。我们用<code>A\d*</code>可以匹配：</p><ul><li><code>A</code>：因为<code>\d*</code>可以匹配0个数字；</li><li><code>A0</code>：因为<code>\d*</code>可以匹配1个数字<code>0</code>；</li><li><code>A380</code>：因为<code>\d*</code>可以匹配多个数字<code>380</code>。</li></ul><h2 id="-4">+</h2><p>修饰符<code>+</code>可以匹配至少一个字符。我们用<code>A\d+</code>可以匹配：</p><ul><li><code>A0</code>：因为<code>\d+</code>可以匹配1个数字<code>0</code>；</li><li><code>A380</code>：因为<code>\d+</code>可以匹配多个数字<code>380</code>。</li></ul><p>但它无法匹配<code>&quot;A&quot;</code>，因为修饰符<code>+</code>要求至少一个字符。</p><h2 id="？">？</h2><p>修饰符<code>?</code>可以匹配0个或一个字符。我们用<code>A\d?</code>可以匹配：</p><ul><li><code>A</code>：因为<code>\d?</code>可以匹配0个数字；</li><li><code>A0</code>：因为<code>\d?</code>可以匹配1个数字<code>0</code>。</li></ul><h2 id="-5">{}</h2><p>如果我们想精确指定n个字符怎么办？用修饰符<code>&#123;n&#125;</code>就可以。<code>A\d&#123;3&#125;</code>可以精确匹配：</p><ul><li><code>A380</code>：因为<code>\d&#123;3&#125;</code>可以匹配3个数字<code>380</code>。</li></ul><p>如果我们想指定匹配n~m个字符怎么办？用修饰符<code>&#123;n,m&#125;</code>就可以。<code>A\d&#123;3,5&#125;</code>可以精确匹配：</p><ul><li><code>A380</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配3个数字<code>380</code>；</li><li><code>A3800</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配4个数字<code>3800</code>；</li><li><code>A38000</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配5个数字<code>38000</code>。</li></ul><p>如果没有上限，那么修饰符<code>&#123;n,&#125;</code>就可以匹配至少n个字符。</p><h2 id="练习">练习</h2><p>请编写一个正则表达式匹配国内的电话号码规则：3~4位区号加7~8位电话，中间用-连接，例如：010-12345678。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;3,4&#125;-\d&#123;7,8&#125;$</span><br></pre></td></tr></table></figure><ul><li><code>^</code>：表示字符串的开始。</li><li><code>\d&#123;3,4&#125;</code>：匹配 3 到 4 位数字（区号）。</li><li><code>-</code>：匹配一个连接符 <code>-</code>。</li><li><code>\d&#123;7,8&#125;</code>：匹配 7 到 8 位数字（电话号码）。</li><li><code>$</code>：表示字符串的结束。</li></ul><h1>复杂匹配</h1><p>用正则表达式进行多行匹配时，我们用<code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\d&#123;3&#125;$</code>，可以匹配<code>&quot;A001&quot;</code>、<code>&quot;A380&quot;</code>。</p><h2 id="…">[…]</h2><p>如果我们规定一个7~8位数字的电话号码不能以<code>0</code>开头，应该怎么写匹配规则呢？<code>\d&#123;7,8&#125;</code>是不行的，因为第一个<code>\d</code>可以匹配到<code>0</code>。</p><p>使用<code>[...]</code>可以匹配范围内的字符，例如，<code>[123456789]</code>可以匹配<code>1</code>~<code>9</code>，这样就可以写出上述电话号码的规则：<code>[123456789]\d&#123;6,7&#125;</code>。</p><p>把所有字符全列出来太麻烦，<code>[...]</code>还有一种写法，直接写<code>[1-9]</code>就可以。</p><p>所以就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1-9]\d&#123;6,7&#125;</span><br></pre></td></tr></table></figure><p>要匹配大小写不限的十六进制数，比如<code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</p><ul><li><code>0-9</code>：字符<code>0</code>~<code>9</code>；</li><li><code>a-f</code>：字符<code>a</code>~<code>f</code>；</li><li><code>A-F</code>：字符<code>A</code>~<code>F</code>。</li></ul><p>如果要匹配6位十六进制数，前面讲过的<code>&#123;n&#125;</code>仍然可以继续配合使用：<code>[0-9a-fA-F]&#123;6&#125;</code></p><p><code>[...]</code>还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写<code>[^1-9]&#123;3&#125;</code>：</p><ul><li>可以匹配<code>&quot;ABC&quot;</code>，因为不包含字符<code>1</code>~<code>9</code>；</li><li>可以匹配<code>&quot;A00&quot;</code>，因为不包含字符<code>1</code>~<code>9</code>；</li><li>不能匹配<code>&quot;A01&quot;</code>，因为包含字符<code>1</code>；</li><li>不能匹配<code>&quot;A05&quot;</code>，因为包含字符<code>5</code>。</li></ul><h2 id="或匹配">或匹配</h2><p>用<code>|</code>连接的两个正则规则是<em>或</em>规则，例如，<code>AB|CD</code>表示可以匹配<code>AB</code>或<code>CD</code></p><p>现在我们想要匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code>怎么办？一个最简单的规则是<code>learn\sjava|learn\sphp|learn\sgo</code>，但是这个规则太复杂了，可以把公共部分提出来，然后用<code>(...)</code>把子规则括起来表示成<code>learn\s(java|php|go)</code>。</p><p>上面的规则仍然不能匹配<code>learn Java</code>、<code>learn Go</code>这样的字符串。试修改正则，使之能匹配大写字母开头的<code>learn Java</code>、<code>learn Php</code>、<code>learn Go</code>。这个要自己去进行修改</p><h1>分组匹配</h1><p>实际上<code>(...)</code>还有一个重要作用，就是分组匹配。</p><p>正确的方法是用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code>。就是先进行这个</p><p>现在我们没办法用<code>String.matches()</code>这样简单的判断方法了，必须引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class reg_exp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pattern p = Pattern.compile(&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;);</span><br><span class="line">        Matcher m = p.matcher(&quot;010-12345678&quot;);</span><br><span class="line">        if(m.matches())&#123;</span><br><span class="line">            String g1 = m.group(1);</span><br><span class="line">            String g2 = m.group(2);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，会得到两个匹配上的子串<code>010</code>和<code>12345678</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12345678</span><br><span class="line">010 </span><br></pre></td></tr></table></figure><p><strong>要特别注意，<code>Matcher.group(index)</code>方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是<code>010-12345678</code>，即整个正则匹配到的字符串。</strong></p><p><strong>这里面的括号就是用来进行分组的</strong></p><p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p><p>实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class reg_exp &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建正则表达式对象，匹配形如 &quot;1234-567890&quot; 的电话号码</span><br><span class="line">        Pattern p = Pattern.compile(&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;);</span><br><span class="line">        </span><br><span class="line">        // 定义要测试的字符串，可以包括多个电话号码</span><br><span class="line">        String[] phoneNumbers = &#123;&quot;010-1245678&quot;, &quot;210-5555555&quot;, &quot;7895-554446&quot;, &quot;040-12345678&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        // 遍历所有电话号码进行匹配</span><br><span class="line">        for (String phoneNumber : phoneNumbers) &#123;</span><br><span class="line">            Matcher matcher = p.matcher(phoneNumber);</span><br><span class="line">            </span><br><span class="line">            if (matcher.matches()) &#123;</span><br><span class="line">                // 获取匹配的整个字符串以及子组信息</span><br><span class="line">                String area = matcher.group(1); // 区号</span><br><span class="line">                String tel = matcher.group(2);  // 电话号码</span><br><span class="line">                System.out.println(&quot;Area Code: &quot; + area + &quot;, Tel: &quot; + tel);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;No match for: &quot; + phoneNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是建了一个数组，然后增强for然后匹配</p><p><strong>使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</strong></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。&lt;/p&gt;
&lt;p&gt;正则表达式是一套标准，它可以用于任何语言。Java标准库的&lt;code&gt;java.util.regex&lt;/cod</summary>
        
      
    
    
    
    <category term="java" scheme="https://mengnankk.asia/categories/java/"/>
    
    
    <category term="正则表达式" scheme="https://mengnankk.asia/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>实用shell脚本分享</title>
    <link href="https://mengnankk.asia/2024/10/03/shell1/"/>
    <id>https://mengnankk.asia/2024/10/03/shell1/</id>
    <published>2024-10-02T16:00:00.000Z</published>
    <updated>2024-10-04T09:45:12.544Z</updated>
    
    <content type="html"><![CDATA[<h1>1.批量修改文件的前缀和后缀</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">echo &quot;请输入重命名文件夹所在的目录&quot;</span><br><span class="line">read   dir</span><br><span class="line"></span><br><span class="line">if [ !-d &quot;$dir&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;目录不存在&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">echo &quot;前缀&quot;</span><br><span class="line">read   prefix</span><br><span class="line">echo &quot;后缀&quot;</span><br><span class="line">read  suffix</span><br><span class="line"></span><br><span class="line">cd &quot;$dir&quot;</span><br><span class="line"></span><br><span class="line">for file in * </span><br><span class="line">do</span><br><span class="line">if [ -d &quot;$file&quot; ]</span><br><span class="line">then</span><br><span class="line">continue</span><br><span class="line">fi</span><br><span class="line">ext=&quot;$&#123;file##*.&#125;&quot;</span><br><span class="line">base=&quot;$&#123;file%.*&#125;&quot;</span><br><span class="line"></span><br><span class="line">new_name=&quot;$&#123;prefix&#125;$&#123;base&#125;$&#123;suffix:+.$suffix&#125;&quot;</span><br><span class="line">mv &quot;$file&quot; &quot;$new_name&quot;</span><br><span class="line">echo &quot;重命名：$file-&gt;$new_name&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;完成!&quot;</span><br></pre></td></tr></table></figure><h1>2.onedrive上传脚本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">cd ~/app/onedrive-2.5.2</span><br><span class="line">./onedrive --sync</span><br><span class="line">echo &quot;onedrive同步成功&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>3.备份数据库</h1><p><strong>年月日和时分秒之间的_不能丢</strong></p><p><strong>变量可以用{}包围，用来界定范围</strong></p><p>脚本编写的第一部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line">DATATIME=$(date +%Y-%m-%d_%H:%M:%S)</span><br><span class="line">echo $DATATIME</span><br><span class="line"></span><br><span class="line">HOST=LOCALHOST</span><br><span class="line">DB_USER=root</span><br><span class="line">PASSWD=admin</span><br><span class="line">DB_NAME=test1</span><br><span class="line"></span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot; ] &amp;&amp; sudo mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot; ] &amp;&amp; sudo mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot;</span><br></pre></td></tr></table></figure><p>这句话用来创建目录</p><p>在这里面datatime只能被赋值一次，所以就是第一次的时间，不会存在其他的时间的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ./mysql_db_backup.sh</span><br><span class="line">2024-10-04_17-28-14</span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">2024-10-04_17-28-14/</span><br><span class="line">2024-10-04_17-28-14/2024-10-04_17-28-14.sql.gz</span><br><span class="line">数据库备份成功，备份文件为: /data/backup/db/2024-10-04_17-28-14/2024-10-04_17-28-14.sql.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行成功截图，中间的提示错误为密码的保护问题，可以先暂时不用管</p><p>完整代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line"></span><br><span class="line"># 备份路径</span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"></span><br><span class="line"># 当前时间，替换 &quot;:&quot; 为合法符号</span><br><span class="line">DATATIME=$(date +%Y-%m-%d_%H-%M-%S)</span><br><span class="line">echo $DATATIME</span><br><span class="line"></span><br><span class="line"># 数据库信息</span><br><span class="line">HOST=LOCALHOST</span><br><span class="line">DB_USER=root</span><br><span class="line">PASSWD=admin</span><br><span class="line">DB_NAME=test1</span><br><span class="line"></span><br><span class="line"># 检查并创建备份目录</span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot; ] &amp;&amp; sudo mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 使用 sudo 提升权限来执行备份</span><br><span class="line">sudo mysqldump -u$&#123;DB_USER&#125; -p$&#123;PASSWD&#125; --host=$&#123;HOST&#125; -q -R $&#123;DB_NAME&#125; | sudo gzip &gt; $&#123;BACKUP&#125;/$&#123;DATATIME&#125;/$DATATIME.sql.gz</span><br><span class="line"></span><br><span class="line">cd $&#123;BACKUP&#125;</span><br><span class="line">tar -zcvf $DATATIME.tar.gz $&#123;DATATIME&#125;</span><br><span class="line"># 检查备份是否成功</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo &quot;数据库备份成功，备份文件为: $&#123;BACKUP&#125;/$&#123;DATATIME&#125;/$&#123;DATATIME&#125;.sql.gz&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;数据库备份失败&quot;</span><br><span class="line">fi</span><br><span class="line">sudo rm -rf $&#123;BACKUP&#125;/$&#123;DATATIME&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样的话其实压缩包里面还有一个压缩包</p><p>但是不压缩两次的话，里面的东西会溢出来捏</p><p>这样我们还要把10天以前的文件给删除，否则会占满空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line"></span><br><span class="line"># 备份路径</span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"></span><br><span class="line"># 当前时间，替换 &quot;:&quot; 为合法符号</span><br><span class="line">DATATIME=$(date +%Y-%m-%d_%H-%M-%S)</span><br><span class="line">echo $DATATIME</span><br><span class="line"></span><br><span class="line"># 数据库信息</span><br><span class="line">HOST=LOCALHOST</span><br><span class="line">DB_USER=root</span><br><span class="line">PASSWD=admin</span><br><span class="line">DB_NAME=test1</span><br><span class="line"></span><br><span class="line"># 检查并创建备份目录#!/bin/zsh</span><br><span class="line"></span><br><span class="line"># 备份路径</span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"></span><br><span class="line"># 当前时间，替换 &quot;:&quot; 为合法符号</span><br><span class="line">DATATIME=$(date +%Y-%m-%d_%H-%M-%S)</span><br><span class="line">echo $DATATIME</span><br><span class="line"></span><br><span class="line"># 数据库信息</span><br><span class="line">HOST=LOCALHOST</span><br><span class="line">DB_USER=root</span><br><span class="line">PASSWD=admin</span><br><span class="line">DB_NAME=test1</span><br><span class="line"></span><br><span class="line"># 检查并创建备份目录</span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot; ] &amp;&amp; sudo mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 使用 sudo 提升权限来执行备份</span><br><span class="line">sudo mysqldump -u$&#123;DB_USER&#125; -p$&#123;PASSWD&#125; --host=$&#123;HOST&#125; -q -R $&#123;DB_NAME&#125; | sudo gzip &gt; $&#123;BACKUP&#125;/$&#123;DATATIME&#125;/$DATATIME.sql.gz</span><br><span class="line"></span><br><span class="line">cd $&#123;BACKUP&#125;</span><br><span class="line">tar -zcvf $DATATIME.tar.gz $&#123;DATATIME&#125;</span><br><span class="line"># 检查备份是否成功</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo &quot;数据库备份成功，备份文件为: $&#123;BACKUP&#125;/$&#123;DATATIME&#125;/$&#123;DATATIME&#125;.sql.gz&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;数据库备份失败&quot;</span><br><span class="line">fi</span><br><span class="line">sudo rm -rf $&#123;BACKUP&#125;/$&#123;DATATIME&#125;</span><br><span class="line"></span><br><span class="line">find $&#123;BACKUP&#125; -atime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">echo &quot;win&quot;</span><br></pre></td></tr></table></figure><p>得到完整代码</p><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo ./mysql_db_backup.sh</span><br><span class="line">2024-10-04_17-39-22</span><br><span class="line">2024-10-04_17-39-22</span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">2024-10-04_17-39-22/</span><br><span class="line">2024-10-04_17-39-22/2024-10-04_17-39-22.sql.gz</span><br><span class="line">数据库备份成功，备份文件为: /data/backup/db/2024-10-04_17-39-22/2024-10-04_17-39-22.sql.gz</span><br><span class="line">win</span><br></pre></td></tr></table></figure><p>最后的最后我们准备进行定时任务了</p><p>使用crontab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ crontab -e</span><br></pre></td></tr></table></figure><p>进入编辑</p><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 2 * * * ~/shellcode/mysql_db_backup.sh</span><br></pre></td></tr></table></figure><p>完成任务</p><p>在这里面最好使用绝对路径，我懒了就不该了哈哈</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h1&gt;1.批量修改文件的前缀和后缀&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
        
      
    
    
    
    <category term="408" scheme="https://mengnankk.asia/categories/408/"/>
    
    
    <category term="Linux" scheme="https://mengnankk.asia/tags/Linux/"/>
    
    <category term="shell" scheme="https://mengnankk.asia/tags/shell/"/>
    
  </entry>
  
</feed>
