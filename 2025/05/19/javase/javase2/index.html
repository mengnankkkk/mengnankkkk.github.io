<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>javase面试题目hot | mengnankkのblog</title><meta name="keywords" content="java"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="javase面试题目hot"><meta name="application-name" content="javase面试题目hot"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="javase面试题目hot"><meta property="og:url" content="https://blog.tokenlen.top/2025/05/19/javase/javase2/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="基础面试题目概念1.说一下Java的特点平台无关性：Java的编写一次，运无不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。面向对象：JaVa是一严格的面可对象编程语言，几乎一切都是对象。面可对象编程"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712175.jpg?_r_=6bc4dfd9-2b13-a123-945b-c0d30223e215"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712175.jpg?_r_=6bc4dfd9-2b13-a123-945b-c0d30223e215"><meta name="description" content="基础面试题目概念1.说一下Java的特点平台无关性：Java的编写一次，运无不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。面向对象：JaVa是一严格的面可对象编程语言，几乎一切都是对象。面可对象编程"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/05/19/javase/javase2/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: 'javase面试题目hot',
  postAI: '',
  pageFillDescription: '基础面试题目, 概念, 1.说一下Java的特点, 2.Java 的优势和劣势是什么？, 3.Java为什么是跨平台的？, 4.JVM、JDK、JRE三者关系？, 5.为什么Java解释和编译都有？, 6.jvm是什么, 7.编译型语言和解释型语言的区别？, 数据类型, 1.八种基本的数据类型, 2.int和long是多少位多少字节的？, 3.long和int可以互转吗 ？, 4.数据类型转换方式你知道哪些？, 5.类型互转会出现什么问题吗？, 6.为什么用bigDecimal 不用double ？, 7.装箱和拆箱是什么？, 8.Java为什么要有Integer？, 9.Integer相比int有什么优点？, 10.那为什么还要保留int类型？, 11.说一下 integer的缓存, 面向对象, 1.怎么理解面向对象？简单说说封装继承多态, 2.多态体现在哪几个方面？, 3.多态解决了什么问题？, 4.面向对象的设计原则你知道有哪些吗, 5.重载与重写有什么区别？, 6.抽象类和普通类区别？, 7.Java抽象类和接口的区别是什么？, 8.抽象类能加final修饰吗？, 9.接口里面可以定义哪些方法？, 10.抽象类可以被实例化吗？, 11.接口可以包含构造函数吗？, 12.解释Java中的静态变量和静态方法, 13.非静态内部类和静态内部类的区别？, 14.非静态内部类可以直接访问外部方法编译器是怎么做到的？, 关键词amp泛型amp反射, 1.Java 中 final 作用是什么？, 2.什么是泛型？, 3.什么是反射, 深拷贝和浅拷贝, 1.深拷贝和浅拷贝的区别, 2.实现深拷贝的方式, 对象, 1.创建对象的五种方式, 2.new出的对象什么时候回收, 3.如何获取私有对象？, 注解, 1.能讲一讲Java注解的原理吗？, 2.对注解解析的底层实现了解吗？, 3.Java注解的作用域呢？基础面试题目概念说一下的特点平台无关性的编写一次运无不在哲学是其最大的特点之一编译器将源代码编译成字节码该字节码可以在任何安装了虚拟机的系统上运行面向对象是一严格的面可对象编程语言几乎一切都是对象面可对象编程特性使得代码更易于维护和重用包括类对象继承多态抽象和封装内存管理有目己的垃圾回收机制目动管理内存和回收不再使用的对象这样开发者不需要手动管埋内存从而减少内存泄漏和其他内存相关的问题的优势和劣势是什么首先的优势我记得跨平台应该是一个大点因为的存在一次编写到处运行然后面向对象这个可能也是优势不过现在很多语言都支持面向对象但是的设计从一开始就是的还有强大的生态系统比如框架各种库和工具社区支持大企业应用广泛另外内存管理方面自动垃圾回收机制减少了内存泄漏的问题对开发者友好还有多线程支持内置的线程机制方便并发编程安全性方面有安全模型比如沙箱机制适合网络环境还有稳定性企业级应用长期使用版本更新也比较注重向后兼容劣势的话性能可能是一个虽然优化了很多但相比或者这种原生编译语言还是有一定开销特别是启动时间比如微服务场景下可能不如之类的快语法繁琐比如样板代码多之前没有的时候更麻烦现在有了但比起还是不够简洁内存消耗本身占内存对于资源有限的环境可能不太友好还有面向对象过于严格有时候写简单程序反而麻烦虽然引入了函数式编程但不如其他语言自然还有开发效率相比动态语言如需要更多代码编译过程也可能拖慢开发节奏为什么是跨平台的能支持跨平台主要依赖于关系比较大也是一个软件不同的平台有不同的版本我们编写的源码编译后会生成一种文件称为字节码文件虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行也就是说只要在不同平台上安装对应的就可以运行字节码文件运行我们编写的程序是一个桥梁是一个中间件是实现跨平台的关键代码首先被编译成字节码文件再由将字节码文件翻译成机器语言从而达到运行程序的目的编译的结果不是生成机器码而是生成字节码字节码不能直接运行必须通过翻译成机器码才能运行不同平台下编译生成的字节码是一样的但是由翻译成的机器码却不一样所以运行程序必须有的支持因为编译的结果不是机器码必须要经过的再次翻译才能执行即使你将程序打包成可执行文件例如仍然需要的支持三者关系是虚拟机是程序运行的环境它负责将字节码由编译器生成解释或编译成机器码并执行程序提供了内存管理垃圾回收安全性等功能使得程序具备跨平台性是开发工具包是开发程序所需的工具集合它包含了编译器调试器等开发工具以及一系列的类库如标准库和开发工具库提供了开发编译调试和运行程序所需的全部工具和环境是运行时环境是程序运行所需的最小环境它包含了和一组类库用于支持程序的执行不包含开发工具只提供程序运行所需的运行环境为什么解释和编译都有首先在经过编译之后生成字节码文件接下来进入中就有两个步骤编译和解释如下图编译性源代码首先被编译成字节码会把编译过的机器码保存起来以备下次使用解释性中一个方法调用计数器当累计计数大于一定值的时候就使用进行编译生成机器码文件否则就是用解释器进行解释执行然后字节码也是经过解释器进行解释运行的所以既是编译型也是解释性语言默认采用的是解释器和编译器混合的模式是什么是虚拟机主要工作是解释自己的指令集即字节码并映射到本地的指令集和的系统调用屏蔽了与操作系统平台相关的信息使得程序只需要生成在虚拟机上运行的目标代码字节码就可在多种平台上不加修改的运行这也是能够一次编译到处运行的原因编译型语言和解释型语言的区别编译型语言和解释型语言的区别在于编译型语言在程序执行之前整个源代码会被编译成机器码或者字节码生成可执行文件执行时直接运行编译后的代码速度快但跨平台性较差解释型语言在程序执行时逐行解释执行源代码不生成独立的可执行文件通常由解释器动态解释并执行代码跨平台性好但执行速度相对较慢典型的编译型语言如典型的解释型语言如数据类型八种基本的数据类型支持数据类型分为两类基本数据类型和引用数据类型基本数据类型共有种可以分为三类数值型整数类型和浮点类型字符型布尔型种基本数据类型的默认值位数取值范围如下表所示数据类型占用大小字节位数取值范围默认值描述到是最小的整数类型适合用于节省内存例如在处理文件或网络流时存储小范围整数数据到较少使用通常用于在需要节省内存且数值范围在该区间的场景到最常用的整数类型可满足大多数日常编程中整数计算的需求到用于表示非常大的整数当类型无法满足需求时使用定义时数值后需加或到单精度浮点数用于表示小数精度相对较低定义时数值后需加或到双精度浮点数精度比高是中表示小数的默认类型到用于表示单个字符采用编码可表示各种语言的字符无明确字节大小理论上位无明确位数或用于逻辑判断只有两个取值常用于条件判断和循环控制等逻辑场景八种基本数据类型的字节数字节字节字节字节浮点数的默认类型为如果需要声明一个常量为型则必须要在末尾加上或整数的默认类型为声明型在末尾加上或者八种基本数据类型的包装类除了的是类型的是其他都是首字母大写类型是无符号的不能为负所以是开始的和是多少位多少字节的类型是位占个字节是有符号整数类型其取值范围是从到例如在一个简单的计数器程序中如果使用类型来存储计数值它可以表示的最大正数是如果计数值超过这个范围就会发生溢出导致结果不符合预期类型是位占个字节类型也是有符号整数类型它的取值范围是从到在处理较大的整数数值时果类型的取值范围不够就需要使用类型例如在一个文件传输程序中文件的大小可能会很大使用类型可能无法准确表示而类型就可以很好地处理这种情况和可以互转吗可以的中的和可以相互转换由于类型的范围比类型大因此将转换为是安全的而将转换为可能会导致数据丢失或溢出将转换为可以通过直接赋值或强制类型转换来实现例如自动转换安全的将转换为需要使用强制类型转换但需要注意潜在的数据丢失或溢出问题在将转换为时如果的值超出了类型的范围转换结果将是截断后的低位部分因此在进行转换之前建议先检查的值是否在类型的范围内以避免数据丢失或溢出的问题低高直接转数据类型转换方式你知道哪些自动类型转换隐式转换当目标类型的范围大于源类型时会自动将源类型转换为目标类型不需要显式的类型转换例如将转换为将转换为等强制类型转换显式转换当目标类型的范围小于源类型时需要使用强制类型转换将源类型转换为目标类型这可能导致数据丢失或溢出例如将转换为将转换为等语法为目标类型变量名目标类型源类型字符串转换提供了将字符串表示的数据转换为其他类型数据的方法例如将字符串转换为整型可以使用方法将字符串转换为浮点型可以使用方法等数值之间的转换提供了一些数值类型之间的转换方法如将整型转换为字符型将字符型转换为整型等这些转换方式可以通过类型的包装类来实现例如类类等提供了相应的转换方法类型互转会出现什么问题吗数据丢失当将一个范围较大的数据类型转换为一个范围较小的数据类型时可能会发生数据丢失例如将一个类型的值转换为类型时如果值超出了类型的范围转换结果将是截断后的低位部分高位部分的数据将丢失数据溢出与数据丢失相反当将一个范围较小的数据类型转换为一个范围较大的数据类型时可能会发生数据溢出例如将一个类型的值转换为类型时转换结果会填充额外的高位空间但原始数据仍然保持不变精度损失在进行浮点数类型的转换时可能会发生精度损失由于浮点数的表示方式不同将一个单精度浮点数转换为双精度浮点数时精度可能会损失类型不匹配导致的错误在进行类型转换时需要确保源类型和目标类型是兼容的如果两者不兼容会导致编译错误或运行时错误为什么用不用会出现精度丢失的问题执行的是二进制浮点运算二进制有些情况下不能准确的表示一个小数就像十进制不能准确的表示也就是说二进制表示小数的时候只能够表示能够用的和的任意组合但是不能够精确表示因为它不能够表示成为的和的形式比如输出可以看到在中进行浮点数运算的时候会出现丢失精度的问题那么我们如果在进行商品价格计算的时候就会出现问题很有可能造成我们手中有元却无法购买一个元和一个元的商品因为如上所示他们两个的总和为这无疑是一个很严重的问题尤其是当电商网站的并发量上去的时候出现的问题将是巨大的可能会导致无法下单或者对账出现问题而是精确计算所以一般牵扯到金钱的计算都使用输出这样的使用可以确保精确的十进制数值计算避免了使用可能出现的舍入误差需要注意的是在创建对象时应该使用字符串作为参数而不是直接使用浮点数值以避免浮点数精度丢失装箱和拆箱是什么装箱和拆箱是将基本数据类型和对应的包装类之间进行转换的过程自动装箱主要发生在两种情况一种是赋值时另一种是在方法调用的时候赋值时这是最常见的一种情况在以前我们需要手动地进行转换才行而现在所有的转换都是由编译器来完成方法调用时当我们在方法调用时我们可以传入原始数据值或者对象同样编译器会帮我们进行转换方法接受对象作为参数当调用时会将值转换成对应的对象这就是所谓的自动装箱方法返回对象而中为类型所以这时候发生自动拆箱操作将方法的返回的对象转换成值自动装箱有一个问题那就是在一个循环中进行自动装箱操作的情况如下面的例子就会创建多余的对象影响程序的性能上面的代码可以看成但是这个操作符不适用于对象首先进行自动拆箱操作进行数值相加操作最后发生自动装箱操作转换成对象其内部变化如下由于我们这里声明的为类型在上面的循环中会创建将近个无用的对象在这样庞大的循环中会降低程序的性能并且加重了垃圾回收的工作量因此在我们编程时需要注意到这一点正确地声明变量类型避免因为自动装箱引起的性能问题为什么要有对应是类型的包装类就是把类型包装成对象对象封装有很多好处可以把属性也就是数据跟处理这些数据的方法结合在一起比如就有等方法来专门处理型相关的数据另一个非常重要的原因就是在中绝大部分方法或类都是用来处理类类型对象的如集合类就只能以类作为他的存储对象而这时如果想把一个型的数据存入是不可能的必须把它包装成类也就是才能被所接受所以的存在是很必要的在中泛型只能使用引用类型而不能使用基本类型因此如果要在泛型中使用类型必须使用包装类在中基本类型和引用类型不能直接进行转换必须使用包装类来实现例如将一个类型的值转换为类型必须首先将其转换为类型然后再转换为类型集合中只能存储对象而不能存储基本数据类型因此如果要将类型的数据存储在集合中必须使用包装类相比有什么优点是中的原始数据类型而是的包装类和的区别基本类型和引用类型首先是一种基本数据类型而是一种引用类型基本数据类型是中最基本的数据类型它们是预定义的不需要实例化就可以使用而引用类型则需要通过实例化对象来使用这意味着使用来存储一个整数时不需要任何额外的内存分配而使用时必须为对象分配内存在性能方面基本数据类型的操作通常比相应的引用类型快自动装箱和拆箱其次作为的包装类它可以实现自动装箱和拆箱自动装箱是指将基本类型转化为相应的包装类类型而自动拆箱则是将包装类类型转化为相应的基本类型这使得程序员更加方便地进行数据类型转换例如当我们需要将类型的值赋给变量时可以自动地将类型转换为类型同样地当我们需要将类型的值赋给变量时可以自动地将类型转换为类型空指针异常另外变量可以直接赋值为而变量必须通过实例化对象来赋值如果对一个未经初始化的变量进行操作就会出现空指针异常这是因为它被赋予了值而值是无法进行自动拆箱的那为什么还要保留类型包装类是引用类型对象的引用和对象本身是分开存储的而对于基本类型数据变量对应的内存块直接存储数据本身因此基本类型数据在读写效率方面要比包装类高效除此之外在位上在开启引用压缩的情况下一个对象占用个字节的内存空间而一个类型数据只占用字节的内存空间前者对空间的占用是后者的倍也就是说不管是读写效率还是存储效率基本类型都比包装类高效说一下的缓存的类内部实现了一个静态缓存池用于存储特定范围内的整数值对应的对象默认情况下这个范围是至当通过方法创建一个在这个范围内的整数对象时并不会每次都生成新的对象实例而是复用缓存中的现有对象会直接从内存中取出不需要新建一个对象但是你的话就是一个新的对象了面向对象怎么理解面向对象简单说说封装继承多态面向对象是一种编程范式它将现实世界中的事物抽象为对象对象具有属性称为字段或属性和行为称为方法面向对象编程的设计思想是以对象为中心通过对象之间的交互来完成程序的功能具有灵活性和可扩展性通过封装和继承可以更好地应对需求变化面向对象的三大特性包括封装继承多态封装封装是指将对象的属性数据和行为方法结合在一起对外隐藏对象的内部细节仅通过对象提供的接口与外界交互封装的目的是增强安全性和简化编程使得对象更加独立继承继承是一种可以使得子类自动共享父类数据结构和方法的机制它是代码复用的重要手段通过继承可以建立类与类之间的层次关系使得结构更加清晰多态多态是指允许不同类的对象对同一消息作出响应即同一个接口使用不同的实例而执行不同操作多态性可以分为编译时多态重载和运行时多态重写它使得程序具有良好的灵活性和扩展性多态体现在哪几个方面多态在面向对象编程中可以体现在以下几个方面方法重载方法重载是指同一类中可以有多个同名方法它们具有不同的参数列表参数类型数量或顺序不同虽然方法名相同但根据传入的参数不同编译器会在编译时确定调用哪个方法示例对于一个方法可以定义为和方法重写方法重写是指子类能够提供对父类中同名方法的具体实现在运行时会根据对象的实际类型确定调用哪个版本的方法这是实现多态的主要方式示例在一个动物类中定义一个方法子类可以重写该方法以实现而可以实现接口与实现多态也体现在接口的使用上多个类可以实现同一个接口并且用接口类型的引用来调用这些类的方法这使得程序在面对不同具体实现时保持一贯的调用方式示例多个类如都实现了一个接口当用类型的引用来调用方法时会触发对应的实现向上转型和向下转型在中可以使用父类类型的引用指向子类对象这是向上转型通过这种方式可以在运行时期采用不同的子类实现向下转型是将父类引用转回其子类类型但在执行前需要确认引用实际指向的对象类型以避免多态解决了什么问题多态是指子类可以替换父类在实际的代码运行过程中调用子类的方法实现多态这种特性也需要编程语言提供特殊的语法机制来实现比如继承接口类多态可以提高代码的扩展性和复用性是很多设计模式设计原则编程技巧的代码实现基础比如策略模式基于接口而非实现编程依赖倒置原则里式替换原则利用多态去掉冗长的语句等等面向对象的设计原则你知道有哪些吗面向对象编程中的六大原则单一职责原则一个类应该只有一个引起它变化的原因即一个类应该只负责一项职责例子考虑一个员工类它应该只负责管理员工信息而不应负责其他无关工作开放封闭原则软件实体应该对扩展开放对修改封闭例子通过制定接口来实现这一原则比如定义一个图形类然后让不同类型的图形继承这个类而不需要修改图形类本身里氏替换原则子类对象应该能够替换掉所有父类对象例子一个正方形是一个矩形但如果修改一个矩形的高度和宽度时正方形的行为应该如何改变就是一个违反里氏替换原则的例子接口隔离原则客户端不应该依赖那些它不需要的接口即接口应该小而专例子通过接口抽象层来实现底层和高层模块之间的解耦比如使用依赖注入依赖倒置原则高层模块不应该依赖低层模块二者都应该依赖于抽象抽象不应该依赖于细节细节应该依赖于抽象例子如果一个公司类包含部门类应该考虑使用合成聚合关系而不是将公司类继承自部门类最少知识原则一个对象应当对其他对象有最少的了解只与其直接的朋友交互重载与重写有什么区别重载指的是在同一个类中可以有多个同名方法它们具有不同的参数列表参数类型参数个数或参数顺序不同编译器根据调用时的参数类型来决定调用哪个方法重写指的是子类可以重新定义父类中的方法方法名参数列表和返回类型必须与父类中的方法一致通过注解来明确表示这是对父类方法的重写重载是指在同一个类中定义多个同名方法而重写是指子类重新定义父类中的方法抽象类和普通类区别实例化普通类可以直接实例化对象而抽象类不能被实例化只能被继承方法实现普通类中的方法可以有具体的实现而抽象类中的方法可以有实现也可以没有实现继承一个类可以继承一个普通类而且可以继承多个接口而一个类只能继承一个抽象类但可以同时实现多个接口实现限制普通类可以被其他类继承和使用而抽象类一般用于作为基类被其他类继承和扩展使用抽象类和接口的区别是什么两者的特点抽象类用于描述类的共同特性和行为可以有成员变量构造方法和具体方法适用于有明显继承关系的场景接口用于定义行为规范可以多实现只能有常量和抽象方法以后可以有默认方法和静态方法适用于定义类的能力或功能两者的区别实现方式实现接口的关键字为继承抽象类的关键字为一个类可以实现多个接口但一个类只能继承一个抽象类所以使用接口可以间接地实现多重继承方法方式接口只有定义不能有方法的实现中可以定义方法体而抽象类可以有定义与实现方法可在抽象类中实现访问修饰符接口成员变量默认为必须赋初值不能被修改其所有的成员方法都是的抽象类中成员变量默认可在子类中被重新定义也可被重新赋值抽象方法被修饰不能被和等修饰必须以分号结尾不带花括号变量抽象类可以包含实例变量和静态变量而接口只能包含常量即静态常量抽象类能加修饰吗不能中的抽象类是用来被继承的而修饰符用于禁止类被继承或方法被重写因此抽象类和修饰符是互斥的不能同时使用接口里面可以定义哪些方法抽象方法抽象方法是接口的核心部分所有实现接口的类都必须实现这些方法抽象方法默认是和这些修饰符可以省略默认方法默认方法是在中引入的允许接口提供具体实现实现类可以选择重写默认方法静态方法静态方法也是在中引入的它们属于接口本身可以通过接口名直接调用而不需要实现类的对象私有方法私有方法是在中引入的用于在接口中为默认方法或其他私有方法提供辅助功能这些方法不能被实现类访问只能在接口内部使用抽象类可以被实例化吗在中抽象类本身不能被实例化这意味着不能使用关键字直接创建一个抽象类的对象抽象类的存在主要是为了被继承它通常包含一个或多个抽象方法由关键字修饰且无方法体的方法这些方法需要在子类中被实现抽象类可以有构造器他可以有构造方法这些构造器在子类实例化时会被调用以便进行必要的初始化工作然而这个过程并不是直接实例化抽象类而是创建了子类的实例间接地使用了抽象类的构造器简而言之抽象类不能直接实例化但通过继承抽象类并实现所有抽象方法的子类是可以被实例化的接口可以包含构造函数吗在接口中不可以有构造方法在接口里写入构造方法时编译器提示因为接口不会有自己的实例的所以不需要有构造函数为什么呢构造函数就是初始化的属性或者方法在的一瞬间自动调用那么问题来了的接口都不能那么要构造函数干嘛呢根本就没法调用解释中的静态变量和静态方法在中静态变量和静态方法是与类本身关联的而不是与类的实例对象关联它们在内存中只存在一份可以被类的所有实例共享静态变量静态变量也称为类变量是在类中使用关键字声明的变量它们属于类而不是任何具体的对象主要的特点共享性所有该类的实例共享同一个静态变量如果一个实例修改了静态变量的值其他实例也会看到这个更改初始化静态变量在类被加载时初始化只会对其进行一次分配内存访问方式静态变量可以直接通过类名访问也可以通过实例访问但推荐使用类名静态方法静态方法是在类中使用关键字声明的方法类似于静态变量静态方法也属于类而不是任何具体的对象主要的特点无实例依赖静态方法可以在没有创建类实例的情况下调用对于静态方法来说不能直接访问非静态的成员变量或方法因为静态方法没有上下文的实例访问静态成员静态方法可以直接调用其他静态变量和静态方法但不能直接访问非静态成员多态性静态方法不支持重写但可以被隐藏非静态内部类和静态内部类的区别区别包括非静态内部类依赖于外部类的实例而静态内部类不依赖于外部类的实例非静态内部类可以访问外部类的实例变量和方法而静态内部类只能访问外部类的静态成员非静态内部类不能定义静态成员而静态内部类可以定义静态成员非静态内部类在外部类实例化后才能实例化而静态内部类可以独立实例化非静态内部类可以访问外部类的私有成员而静态内部类不能直接访问外部类的私有成员需要通过实例化外部类来访问总结来说一内一外非静态内部类可以直接访问外部方法编译器是怎么做到的非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用这个引用使得非静态内部类能够访问外部类的实例变量和方法编译器会在生成非静态内部类的构造方法时将外部类实例作为参数传入并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系从而实现直接访问外部方法的功能关键词泛型反射中作用是什么关键字主要有以下三个方面的作用用于修饰类方法和变量修饰类当修饰一个类时表示这个类不能被继承是类继承体系中的最终形态例如中的类就是用修饰的这保证了类的不可变性和安全性防止其他类通过继承来改变类的行为和特性修饰方法用修饰的方法不能在子类中被重写比如类中的方法就是的因为这个方法的行为是由虚拟机底层实现来保证的不应该被子类修改修饰变量当修饰基本数据类型的变量时该变量一旦被赋值就不能再改变例如这里的就是一个常量不能再对其进行重新赋值操作否则会导致编译错误对于引用数据类型修饰意味着这个引用变量不能再指向其他对象但对象本身的内容是可以改变的例如不能让再指向其他对象但可以通过来修改字符串的内容什么是泛型泛型是编程语言中的一个重要特性它允许类接口和方法在定义时使用一个或多个类型参数这些类型参数在使用时可以被指定为具体的类型泛型的主要目的是在编译时提供更强的类型检查并且在编译后能够保留类型信息避免了在运行时出现类型转换异常为什么需要泛型适用于多种数据类型执行相同的代码如果没有泛型要实现不同类型的加法每种类型都需要重载一个方法通过泛型我们可以复用为一个方法泛型中的类型在使用时指定不需要强制类型转换类型安全编译器会检查类型看下这个例子我们在使用上述中中的元素都是类型无法约束其中的类型所以在取出集合元素时需要人为的强制类型转化到具体的目标类型且很容易出现异常引入泛型它将提供类型的约束提供编译前的检查中只能放不能放其它类型的元素好处编译期类型检查提升代码安全性防止运行时类型转换异常编译时会自动装箱拆箱来配合基本类型的包装类避免强制类型转换代码更简洁清晰提高代码复用性同一份代码可以处理不同类型的数据他只能使用包装类不能用于基本的数据类型泛型采用类型擦除实现泛型信息在编译后被擦除泛型变量变为原始类型通常是或边界类型运行的时候是不能使用的比如不能创建泛型数组无法进行类型判断等什么是反射反射机制是在运行状态中对于任意一个类都能够知道这个类中的所有属性和方法对于任意一个对象都能够调用它的任意一个方法和属性这种动态获取的信息以及动态调用对象的方法的功能称为语言的反射机制反射具有以下特性运行时类信息访问反射机制允许程序在运行时获取类的完整结构信息包括类名包名父类实现的接口构造函数方法和字段等动态对象创建可以使用反射动态地创建对象实例即使在编译时不知道具体的类名这是通过类的方法或对象的方法实现的动态方法调用可以在运行时动态地调用对象的方法包括私有方法这通过类的方法实现允许你传入对象实例和参数值来执行方法访问和修改字段值反射还允许程序在运行时访问和修改对象的字段值即使是私有的这是通过类的和方法完成的使用实例加载数据库驱动我们的项目底层数据库有时是用有时用需要动态地根据实际情况加载驱动类这个时候反射就有用了假设这两个类我们要用这时候我们在使用连接数据库时使用通过反射加载数据库的驱动程序如果是则传入的驱动类而如果是则传入的参数就变成另一个了配置文件加载框架的动态加载管理通过配置文件配置各种各样的你需要用到哪些就配哪些容器就会根据你的需求去动态加载你的程序就能健壮地运行通过配置模式装载的过程将程序中所有或配置文件加载入内存类里面解析或者里面的内容得到对应实体类的字节码字符串以及相关的属性信息使用反射机制根据这个字符串获得某个类的实例动态配置实例的属性配置文件实体类解析配置文件内容解析或里面的内容得到对应实体类的字节码字符串以及属性信息利用反射获取实体类的实例创建实体类的实例对象调用方法使用反射机制根据这个字符串获得对象获取方法绕过安全检查创建实例对象调用方法判断对象所属类获取对象的对象加载类全类名动态加载类获取构造器并实例化对象访问类的成员变量和方法调用对象方法访问私有成员通过取消访问检查反射机制实际上会降低程序的性能因为它需要在运行时进行类型检查和解析同时反射也可能破坏封装性带来安全风险因为它可以访问私有成员优点缺点提高程序灵活性和扩展性支持动态加载类和调用性能较慢需要绕过优化存在额外开销支持框架工具实现通用逻辑和动态操作破坏封装性可访问私有成员可能导致安全风险支持动态代理注解解析等高级功能编译时缺乏类型检查错误只能运行时发现深拷贝和浅拷贝深拷贝和浅拷贝的区别浅拷贝是指只复制对象本身和其内部的值类型字段但不会复制对象内部的引用类型字段换句话说浅拷贝只是创建一个新的对象然后将原对象的字段值复制到新对象中但如果原对象内部有引用类型的字段只是将引用复制到新对象中两个对象指向的是同一个引用对象深拷贝是指在复制对象的同时将对象内部的所有引用类型字段的内容也复制一份而不是共享引用换句话说深拷贝会递归复制对象内部所有引用类型的字段生成一个全新的对象以及其内部的所有对象对比项浅拷贝深拷贝拷贝级别拷贝对象本身引用地址拷贝对象本身引用对象的内容引用对象原对象与副本共享引用对象副本拥有独立的引用对象默认实现默认是浅拷贝需手动实现递归复制影响改变副本的引用成员会影响原对象改变副本不影响原对象应用场景轻量对象复制性能优先要求对象完全独立互不干扰实现深拷贝的方式实现接口并重写方法这种方法要求对象及其所有引用类型字段都实现接口并且重写方法在方法中通过递归克隆引用类型字段来实现深拷贝深拷贝内部的引用对象使用序列化和反序列化通过将对象序列化为字节流再从字节流反序列化为对象来实现深拷贝要求对象及其所有引用类型字段都实现接口手动递归复制针对特定对象结构手动递归复制对象及其引用类型字段适用于对象结构复杂度不高的情况对象创建对象的五种方式使用关键字通过关键字直接调用类的构造方法来创建对象使用类的方法通过反射机制可以使用类的方法创建对象使用类的方法同样是通过反射机制可以使用类的方法创建对象一般跟反射一块用吧获取类的构造器之后新建对象使用方法如果类实现了接口可以使用方法复制对象这就是拷贝使用反序列化通过将对象序列化到文件或流中然后再进行反序列化来创建对象出的对象什么时候回收通过过关键字创建的对象由的垃圾回收器负责回收垃圾回收器的工作是在程序运行过程中自动进行的它会周期性地检测不再被引用的对象并将其回收释放内存具体来说对象的回收时机是由垃圾回收器根据一些算法来决定的主要有以下几种情况引用计数法某个对象的引用计数为时表示该对象不再被引用可以被回收可达性分析算法从根对象如方法区中的类静态属性方法中的局部变量等出发通过对象之间的引用链进行遍历如果存在一条引用链到达某个对象则说明该对象是可达的反之不可达不可达的对象将被回收终结器如果对象重写了方法垃圾回收器会在回收该对象之前调用方法对象可以在方法中进行一些清理操作然而终结器机制的使用不被推荐因为它的执行时间是不确定的可能会导致不可预测的性能问题这个类似于中的如何获取私有对象在中私有对象通常指的是类中被声明为的成员变量或方法由于访问修饰符的限制这些成员只能在其所在的类内部被访问不过可以通过下面两种方式来间接获取私有对象使用公共访问器方法方法如果类的设计者遵循良好的编程规范通常会为私有成员变量提供公共的访问器方法即方法通过调用这些方法可以安全地获取私有对象私有成员变量私有字段的值公共的方法通过调用方法获取私有对象反射机制反射机制允许在运行时检查和修改类方法字段等信息通过反射可以绕过访问修饰符的限制来获取私有对象但是却会破坏封装性安全不会得到保障私有字段的值获取对象获取私有字段设置可访问性获取私有字段的值注解能讲一讲注解的原理吗注解本质是一个继承了的特殊接口其具体实现类是运行时生成的动态代理类我们通过反射获取注解时返回的是运行时生成的动态代理对象通过代理对象调用自定义注解的方法会最终调用的方法该方法会从这个中索引出对应的值而的来源是常量池对注解解析的底层实现了解吗注解本质上是一种特殊的接口它继承自接口所以注解也叫声明式接口例如定义一个简单的注解编译后编译器会将其转换为一个继承自的接口并生成相应的字节码文件根据注解的作用范围注解可以分为以下几种类型源码级别注解仅存在于源码中编译后不会保留类文件级别注解保留在文件中但运行时不可见运行时注解保留在文件中并且可以通过反射在运行时访问只有运行时注解可以通过反射机制进行解析当注解被标记为时编译器会在生成的文件中保存注解信息这些信息存储在字节码的属性表中具体包括以下内容存储运行时可见的注解信息存储运行时不可见的注解信息和存储方法参数上的注解信息通过工具如可以查看文件中的注解信息注解的解析主要依赖于的反射机制以下是解析注解的基本流程获取注册信息通过反射可以获取类方法字段等元素上的注解例如底层原理反射机制的核心类是它是所有可以被注解修饰的元素如等的父接口该接口提供了以下方法获取指定类型的注解获取所有注解判断是否包含指定注解这些方法的底层实现依赖于提供的本地方法例如在加载类时会解析文件中的注解信息并将其存储在内存中供反射机制使用因此注解解析的底层实现主要依赖于的反射机制和字节码文件的存储通过元注解可以控制注解的保留策略当使用时可以在运行时通过反射来解析注解信息在层面会从字节码文件中读取注解信息并创建注解的代理对象来获取注解的属性值注解的作用域呢注解的作用域指的是注解可以应用在哪些程序元素上例如类方法字段等注解的作用域可以分为三种类级别作用域用于描述类的注解通常放置在类定义的上面可以用来指定类的一些属性如类的访问级别继承关系注释等方法级别作用域用于描述方法的注解通常放置在方法定义的上面可以用来指定方法的一些属性如方法的访问级别返回值类型异常类型注释等字段级别作用域用于描述字段的注解通常放置在字段定义的上面可以用来指定字段的一些属性如字段的访问级别默认值注释等除了这三种作用域还提供了其他一些注解作用域例如构造函数作用域和局部变量作用域这些注解作用域可以用来对构造函数和局部变量进行描述和注释',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-22 23:17:16',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 1.05rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 1.05rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/football/" style="font-size: 1.05rem;">football<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>33</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>4</sup></a><a href="/tags/paper/" style="font-size: 1.05rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 1.05rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>3</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>1</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>6</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>4</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>16</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 1.05rem;">毛选<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>8</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/javase/" itemprop="url">javase</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/javase/java/" itemprop="url">java</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a></span></div></div><h1 class="post-title" itemprop="name headline">javase面试题目hot</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-22T15:17:16.818Z" title="更新于 2025-05-22 23:17:16">2025-05-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">13.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="javase面试题目hot"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712175.jpg?_r_=6bc4dfd9-2b13-a123-945b-c0d30223e215"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/05/19/javase/javase2/"><header><a class="post-meta-categories" href="/categories/javase/" itemprop="url">javase</a><a class="post-meta-categories" href="/categories/javase/java/" itemprop="url">java</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><h1 id="CrawlerTitle" itemprop="name headline">javase面试题目hot</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time><time itemprop="dateCreated datePublished" datetime="2025-05-22T15:17:16.818Z" title="更新于 2025-05-22 23:17:16">2025-05-22</time></header><h1 id="基础面试题目"><a href="#基础面试题目" class="headerlink" title="基础面试题目"></a>基础面试题目</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="1-说一下Java的特点"><a href="#1-说一下Java的特点" class="headerlink" title="1.说一下Java的特点"></a>1.说一下Java的特点</h3><p><strong>平台无关性</strong>：Java的编写一次，运无不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。<br><strong>面向对象</strong>：JaVa是一严格的面可对象编程语言，几乎一切都是对象。面可对象编程（OOP）特性使得代码更易于维护和重用，包括类（class）、对象（object）、继承（inheritance）、多态　(polymorphism）、抽象（abstraction）和封装（encapsulation）。<br><strong>内存管理</strong>：JaVa有目己的垃圾回收机制，目动管理内存和回收不再使用的对象。这样，开发者不需要手动管埋内存，从而减少内存泄漏和其他内存相关的问题。</p>
<h3 id="2-Java-的优势和劣势是什么？"><a href="#2-Java-的优势和劣势是什么？" class="headerlink" title="2.Java 的优势和劣势是什么？"></a>2.Java 的优势和劣势是什么？</h3><p>首先，Java的优势，我记得<strong>跨平台</strong>应该是一个大点，因为<strong>JVM</strong>的存在，一次编写到处运行。然后<strong>面向对象</strong>，这个可能也是优势，不过现在很多语言都支持面向对象，但是Java的设计从一开始就是OOP的。还有<strong>强大的生态系统</strong>，比如Spring框架，Hibernate，各种库和工具，社区支持大，企业应用广泛。另外，<strong>内存管理方面</strong>，自动垃圾回收机制，减少了内存泄漏的问题，对开发者友好。<strong>还有多线程支持</strong>，内置的线程机制，方便并发编程。安全性方面，<strong>Java有安全模型</strong>，比如沙箱机制，适合网络环境。还有稳定性，企业级应用长期使用，版本更新也比较注重向后兼容。</p>
<p>劣势的话，<strong>性能</strong>可能是一个，虽然JVM优化了很多，但相比C++或者Rust这种原生编译语言，还是有一定开销。<strong>特别是启动时间</strong>，比如微服务场景下，可能不如Go之类的快。语法繁琐，比如样板代码多，之前没有lambda的时候更麻烦，现在有了但比起Python还是<strong>不够简洁</strong>。内存消耗，<strong>JVM本身占内存，对于资源有限的环境可能不太友好</strong>。<strong>还有面向对象过于严格</strong>，有时候写简单程序反而麻烦，虽然Java8引入了函数式编程，但不如其他语言自然。还有开发效率，相比动态语言如Python，<strong>Java需要更多代码，编译过程也可能拖慢开发节奏。</strong></p>
<h3 id="3-Java为什么是跨平台的？"><a href="#3-Java为什么是跨平台的？" class="headerlink" title="3.Java为什么是跨平台的？"></a>3.Java为什么是跨平台的？</h3><p> Java 能支持跨平台，主要依赖于 <strong>JVM</strong> 关系比较大。</p>
<p><strong>JVM也是一个软件，不同的平台有不同的版本</strong>。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。<strong>Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。</strong>也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p>
<p>JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。</p>
<p>编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</p>
<p>所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。</p>
<h3 id="4-JVM、JDK、JRE三者关系？"><a href="#4-JVM、JDK、JRE三者关系？" class="headerlink" title="4.JVM、JDK、JRE三者关系？"></a>4.JVM、JDK、JRE三者关系？</h3><ul>
<li><strong>JVM</strong>是Java虚拟机，<strong>是Java程序运行的环境</strong>。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li>
<li><strong>JDK</strong>是Java开发工具包，<strong>是开发Java程序所需的工具集合</strong>。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。<strong>JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</strong></li>
<li><strong>JRE</strong>是Java运行时环境，<strong>是Java程序运行所需的最小环境</strong>。它包含了JVM和一组Java类库，用于支持Java程序的执行。<strong>JRE不包含开发工具，只提供Java程序运行所需的运行环境。</strong></li>
</ul>
<h3 id="5-为什么Java解释和编译都有？"><a href="#5-为什么Java解释和编译都有？" class="headerlink" title="5.为什么Java解释和编译都有？"></a>5.为什么Java解释和编译都有？</h3><p>首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt=""></p>
<p><strong>编译性</strong>：</p>
<ul>
<li>Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。</li>
</ul>
<p><strong>解释性：</strong></p>
<ul>
<li>JVM中一个<strong>方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。</strong>否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。</li>
</ul>
<p>所以Java既是<strong>编译型也是解释性语言</strong>，默认采用的是解释器和编译器混合的模式。</p>
<h3 id="6-jvm是什么"><a href="#6-jvm是什么" class="headerlink" title="6.jvm是什么"></a>6.jvm是什么</h3><p>JVM是 <strong>java 虚拟机</strong>，主要工作是<strong>解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。</strong></p>
<p>JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“<strong>一次编译，到处运行的</strong>”原因。</p>
<h3 id="7-编译型语言和解释型语言的区别？"><a href="#7-编译型语言和解释型语言的区别？" class="headerlink" title="7.编译型语言和解释型语言的区别？"></a>7.<strong>编译型语言和解释型语言的区别？</strong></h3><p>编译型语言和解释型语言的区别在于：</p>
<ul>
<li>编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接<strong>运行编译后的代码，速度快，但跨平台性较差</strong>。</li>
<li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由<strong>解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。</strong></li>
<li>典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1-八种基本的数据类型"><a href="#1-八种基本的数据类型" class="headerlink" title="1.八种基本的数据类型"></a>1.八种基本的数据类型</h3><p>Java支持数据类型分为两类： 基本数据类型和引用数据类型。</p>
<p>基本数据类型共有8种，可以分为三类：</p>
<ul>
<li>数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
<p>8种基本数据类型的默认值、位数、取值范围，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用大小（字节）</th>
<th>位数</th>
<th>取值范围</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code></td>
<td>1</td>
<td>8</td>
<td>-128（-2^7） 到 127（2^7 - 1）</td>
<td>0</td>
<td>是最小的整数类型，适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据。</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td>16</td>
<td>-32768（-2^15） 到 32767（2^15 - 1）</td>
<td>0</td>
<td>较少使用，通常用于在需要节省内存且数值范围在该区间的场景。</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td>32</td>
<td>-2147483648（-2^31） 到 2147483647（2^31 - 1）</td>
<td>0</td>
<td>最常用的整数类型，可满足大多数日常编程中整数计算的需求。</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td>64</td>
<td>-9223372036854775808（-2^63） 到 9223372036854775807（2^63 - 1）</td>
<td>0L</td>
<td>用于表示非常大的整数，当 <code>int</code> 类型无法满足需求时使用，定义时数值后需加 <code>L</code> 或 <code>l</code>。</td>
</tr>
<tr>
<td><code>float</code></td>
<td>4</td>
<td>32</td>
<td>1.4E - 45 到 3.4028235E38</td>
<td>0.0f</td>
<td>单精度浮点数，用于表示小数，精度相对较低，定义时数值后需加 <code>F</code> 或 <code>f</code>。</td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td>64</td>
<td>4.9E - 324 到 1.7976931348623157E308</td>
<td>0.0d</td>
<td>双精度浮点数，精度比 <code>float</code> 高，是 Java 中表示小数的默认类型。</td>
</tr>
<tr>
<td><code>char</code></td>
<td>2</td>
<td>16</td>
<td>‘\u0000’（0） 到 ‘\uffff’（65535）</td>
<td>‘\u0000’</td>
<td>用于表示单个字符，采用 Unicode 编码，可表示各种语言的字符。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>无明确字节大小（理论上 1 位）</td>
<td>无明确位数</td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>false</code></td>
<td>用于逻辑判断，只有两个取值，常用于条件判断和循环控制等逻辑场景。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Java八种基本数据类型的字节数：1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)</li>
<li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）</li>
<li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li>
<li>八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写</li>
<li>char类型是无符号的，不能为负，所以是0开始的</li>
</ul>
<h3 id="2-int和long是多少位，多少字节的？"><a href="#2-int和long是多少位，多少字节的？" class="headerlink" title="2.int和long是多少位，多少字节的？"></a>2.int和long是多少位，多少字节的？</h3><ul>
<li><code>int</code>类型是 <strong>32 位（bit），占 4 个字节（byte）</strong>，int 是有符号整数类型，其取值范围是从 <strong>-2^31 到 2^31-1</strong> 。例如，在一个简单的计数器程序中，如果使用<code>int</code>类型来存储计数值，它可以表示的最大正数是 <strong>2,147,483,647</strong>。如果计数值超过这个范围，就会发生溢出，导致结果不符合预期。</li>
<li><code>long</code>类型是 <strong>64 位，占 8 个字节</strong>，<code>long</code>类型也是有符号整数类型，它的取值范围是从 <strong>-2^63 到 2^63 -1</strong> ，在处理较大的整数数值时，果<code>int</code>类型的取值范围不够，就需要使用<code>long</code>类型。例如，在一个文件传输程序中，文件的大小可能会很大，使用<code>int</code>类型可能无法准确表示，而<code>long</code>类型就可以很好地处理这种情况。</li>
</ul>
<h3 id="3-long和int可以互转吗-？"><a href="#3-long和int可以互转吗-？" class="headerlink" title="3.long和int可以互转吗 ？"></a>3.long和int可以互转吗 ？</h3><p>可以的，Java中的<code>long</code>和<code>int</code>可以相互转换。由于<code>long</code>类型的范围比<code>int</code>类型大，因此将<code>int</code>转换为<code>long</code>是安全的，而将<code>long</code>转换为<code>int</code>可能会导致数据丢失或溢出。</p>
<p>将<code>int</code>转换为<code>long</code>可以通过<strong>直接赋值或强制类型转换</strong>来实现。例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int intValue = 10;</span><br><span class="line">long longValue = intValue; // 自动转换，安全的</span><br></pre></td></tr></table></figure>
<p>将<code>long</code>转换为<code>int</code>需要使用<strong>强制类型转换</strong>，但需要注意潜在的数据丢失或溢出问题。</p>
<p>在将<code>long</code>转换为<code>int</code>时，如果<code>longValue</code>的值超出了<code>int</code>类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查<code>longValue</code>的值是否在<code>int</code>类型的范围内，以避免数据丢失或溢出的问题。</p>
<p><strong>低-&gt;高直接转</strong></p>
<h3 id="4-数据类型转换方式你知道哪些？"><a href="#4-数据类型转换方式你知道哪些？" class="headerlink" title="4.数据类型转换方式你知道哪些？"></a>4.数据类型转换方式你知道哪些？</h3><ul>
<li><strong>自动类型转换（隐式转换）</strong>：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将<code>int</code>转换为<code>long</code>、将<code>float</code>转换为<code>double</code>等。</li>
<li><strong>强制类型转换（显式转换）</strong>：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将<code>long</code>转换为<code>int</code>、将<code>double</code>转换为<code>int</code>等。语法为：目标类型 变量名 = (目标类型) 源类型。</li>
<li>字符串转换：<strong>Java提供了将字符串表示的数据转换为其他类型数据的方法</strong>。例如，将字符串转换为整型<code>int</code>，可以使用<code>Integer.parseInt()</code>方法；将字符串转换为浮点型<code>double</code>，可以使用<code>Double.parseDouble()</code>方法等。</li>
<li>数值之间的转换：<strong>Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。</strong>这些转换方式可以通过类型的包装类来实现，例如<code>Character</code>类、<code>Integer</code>类等提供了相应的转换方法。</li>
</ul>
<h3 id="5-类型互转会出现什么问题吗？"><a href="#5-类型互转会出现什么问题吗？" class="headerlink" title="5.类型互转会出现什么问题吗？"></a>5.类型互转会出现什么问题吗？</h3><ul>
<li>数据丢失：当将<strong>一个范围较大的数据类型转换为一个范围较小的数据类型时</strong>，可能会发生数据丢失。例如，将一个<code>long</code>类型的值转换为<code>int</code>类型时，如果<code>long</code>值超出了<code>int</code>类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。</li>
<li>数据溢出：与数据丢失相反，<strong>当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。</strong>例如，将一个<code>int</code>类型的值转换为<code>long</code>类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。</li>
<li>精度损失：<strong>在进行浮点数类型的转换时，可能会发生精度损失。</strong>由于浮点数的表示方式不同，将一个单精度浮点数(<code>float</code>)转换为双精度浮点数(<code>double</code>)时，精度可能会损失。</li>
<li>类型不匹配导致的错误：在进行类型转换时，<strong>需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误。</strong></li>
</ul>
<h3 id="6-为什么用bigDecimal-不用double-？"><a href="#6-为什么用bigDecimal-不用double-？" class="headerlink" title="6.为什么用bigDecimal 不用double ？"></a>6.为什么用bigDecimal 不用double ？</h3><p>double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1/3(1/3=0.3333…)，也就是说二进制表示小数的时候只能够表示能够用1/(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1/(2^n)的和的形式。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.05</span> + <span class="number">0.01</span>);</span><br><span class="line">System.out.println(<span class="number">1.0</span> - <span class="number">0.42</span>);</span><br><span class="line">System.out.println(<span class="number">4.015</span> * <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="number">123.3</span> / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0.060000000000000005</span></span><br><span class="line"><span class="number">0.5800000000000001</span></span><br><span class="line"><span class="number">401.49999999999994</span></span><br><span class="line"><span class="number">1.2329999999999999</span></span><br></pre></td></tr></table></figure>
<p>可以看到在<strong>Java中进行浮点数运算的时候，会出现丢失精度的问题。</strong>那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。</p>
<p><strong>而 Decimal 是精确计算 , 所以一般牵扯到金钱的计算 , 都使用 Decimal。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">sum</span> <span class="operator">=</span> num1.add(num2);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">product</span> <span class="operator">=</span> num1.multiply(num2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Sum: <span class="number">0.3</span></span><br><span class="line">Product: <span class="number">0.02</span></span><br></pre></td></tr></table></figure>
<p>这样的使用<code>BigDecimal</code>可以确保精确的十进制数值计算，避免了使用<code>double</code>可能出现的舍入误差。需要注意的是，在创建<code>BigDecimal</code>对象时，应该使用<strong>字符串作为参数</strong>，而不是直接使用浮点数值，以避免浮点数精度丢失。</p>
<h3 id="7-装箱和拆箱是什么？"><a href="#7-装箱和拆箱是什么？" class="headerlink" title="7.装箱和拆箱是什么？"></a>7.装箱和拆箱是什么？</h3><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。</p>
<p>自动装箱主要发生在两种情况，<strong>一种是赋值时，另一种是在方法调用的时候。</strong></p>
<blockquote>
<p>赋值时</p>
</blockquote>
<p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before autoboxing</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iObject</span> <span class="operator">=</span> Integer.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="type">Int</span> <span class="variable">iPrimitive</span> <span class="operator">=</span> iObject.intValue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//after java5</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iObject</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//autobxing - primitive to wrapper conversion</span></span><br><span class="line"><span class="type">int</span> <span class="variable">iPrimitive</span> <span class="operator">=</span> iObject; <span class="comment">//unboxing - object to primitive conversion</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法调用时</p>
</blockquote>
<p>当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;autoboxing example - method invocation i: &quot;</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure>
<p>show方法接受Integer对象作为参数，当调用<code>show(3)</code>时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而<code>int result = show(3);</code>中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。</p>
<p>自动装箱有一个问题，<strong>那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;   sum+=i; &#125; </span><br></pre></td></tr></table></figure>
<p>上面的代码<code>sum+=i</code>可以看成<code>sum = sum + i</code>，但是<code>+</code>这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i; <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result); </span><br></pre></td></tr></table></figure>
<p>由于我们这里声明的sum为Integer类型，<strong>在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。</strong>因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p>
<h3 id="8-Java为什么要有Integer？"><a href="#8-Java为什么要有Integer？" class="headerlink" title="8.Java为什么要有Integer？"></a>8.Java为什么要有Integer？</h3><p>Integer对应是int类型的包装类，就是把int类型包装成Object对象，<strong>对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起</strong>，比如Integer就有parseInt()等方法来专门处理int型相关的数据。</p>
<p>另一个非常重要的原因就是在<strong>Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，</strong>也就是Integer才能被List所接受。所以Integer的存在是很必要的。</p>
<p>在Java中，<strong>泛型只能使用引用类型</strong>，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。</p>
<p>在Java中，<strong>基本类型和引用类型不能直接进行转换，必须使用包装类来实现。</strong>例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。</p>
<p>Java<strong>集合中只能存储对象，而不能存储基本数据类型。</strong>因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。</p>
<h3 id="9-Integer相比int有什么优点？"><a href="#9-Integer相比int有什么优点？" class="headerlink" title="9.Integer相比int有什么优点？"></a>9.Integer相比int有什么优点？</h3><p>int是Java中的原始数据类型，而Integer是int的包装类。</p>
<p>Integer和 int 的区别：</p>
<ul>
<li>基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，<strong>它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。</strong>这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，<strong>基本数据类型的操作通常比相应的引用类型快。</strong></li>
<li>自动装箱和拆箱：其次，Integer作为int的包装类，<strong>它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。</strong>这使得Java程序员<strong>更加方便地进行数据类型转换。</strong>例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。</li>
<li>空指针异常：另外，<strong>int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。</strong>如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了<strong>null值</strong>，而null值是无法进行自动拆箱的。</li>
</ul>
<h3 id="10-那为什么还要保留int类型？"><a href="#10-那为什么还要保留int类型？" class="headerlink" title="10.那为什么还要保留int类型？"></a>10.那为什么还要保留int类型？</h3><p>包装类是引用类型，对象的引用和对象本身是分开存储的，<strong>而对于基本类型数据，变量对应的内存块直接存储数据本身。</strong></p>
<p>因此，基本类型数据在<strong>读写效率方面，要比包装类高效</strong>。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。</p>
<p>也就是说，<strong>不管是读写效率，还是存储效率，基本类型都比包装类高效。</strong></p>
<h3 id="11-说一下-integer的缓存"><a href="#11-说一下-integer的缓存" class="headerlink" title="11.说一下 integer的缓存"></a>11.说一下 integer的缓存</h3><p>Java的Integer类内部实现了一个<strong>静态缓存池</strong>，用于存储特定范围内的整数值对应的Integer对象。</p>
<p>默认情况下，<strong>这个范围是-128至127。</strong>当通过<strong>Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。</strong></p>
<p>但是你new的话就是一个新的对象了。</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-怎么理解面向对象？简单说说封装继承多态"><a href="#1-怎么理解面向对象？简单说说封装继承多态" class="headerlink" title="1.怎么理解面向对象？简单说说封装继承多态"></a>1.怎么理解面向对象？简单说说封装继承多态</h2><p>面向对象是一种编程范式，它<strong>将现实世界中的事物抽象为对象</strong>，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。</p>
<p>Java面向对象的三大特性包括：<strong>封装、继承、多态</strong>：</p>
<ul>
<li><strong>封装</strong>：封装是指将对象的<strong>属性（数据）和行为（方法）结合在一起</strong>，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。<strong>封装的目的是增强安全性和简化编程，使得对象更加独立。</strong></li>
<li><strong>继承</strong>：继承是一种可以使得<strong>子类自动共享父类数据结构和方法的机制</strong>。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。</li>
<li><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为<strong>编译时多态（重载）和运行时多态（重写）</strong>。它使得程序具有良好的灵活性和扩展性。</li>
</ul>
<h2 id="2-多态体现在哪几个方面？"><a href="#2-多态体现在哪几个方面？" class="headerlink" title="2.多态体现在哪几个方面？"></a>2.多态体现在哪几个方面？</h2><p>多态在面向对象编程中可以体现在以下几个方面：</p>
<ul>
<li>方法重载：<ul>
<li>方法重载是指同一类中可以有<strong>多个同名方法，它们具有不同的参数列表</strong>（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。</li>
<li>示例：对于一个 <code>add</code> 方法，可以定义为 <code>add(int a, int b)</code> 和 <code>add(double a, double b)</code>。</li>
</ul>
</li>
<li>方法重写：<ul>
<li>方法重写是<strong>指子类能够提供对父类中同名方法的具体实现</strong>。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。</li>
<li>示例：在一个动物类中，定义一个 <code>sound</code> 方法，子类 <code>Dog</code> 可以重写该方法以实现 <code>bark</code>，而 <code>Cat</code> 可以实现 <code>meow</code>。</li>
</ul>
</li>
<li>接口与实现：<ul>
<li>多态也体现在接口的使用上，<strong>多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。</strong></li>
<li>示例：多个类（如 <code>Dog</code>, <code>Cat</code>）都实现了一个 <code>Animal</code> 接口，当用 <code>Animal</code> 类型的引用来调用 <code>makeSound</code> 方法时，会触发对应的实现。</li>
</ul>
</li>
<li>向上转型和向下转型：<ul>
<li>在Java中，<strong>可以使用父类类型的引用指向子类对象，这是向上转型。</strong>通过这种方式，可以在运行时期采用不同的子类实现。</li>
<li>向下转型是将<strong>父类引用转回其子类类型</strong>，但在执行前需要确认引用实际指向的对象类型以避免 <code>ClassCastException</code>。</li>
</ul>
</li>
</ul>
<h2 id="3-多态解决了什么问题？"><a href="#3-多态解决了什么问题？" class="headerlink" title="3.多态解决了什么问题？"></a>3.多态解决了什么问题？</h2><p>多态是<strong>指子类可以替换父类，</strong>在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，<strong>比如继承、接口类</strong>。</p>
<p><strong>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</strong>比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等</p>
<h2 id="4-面向对象的设计原则你知道有哪些吗"><a href="#4-面向对象的设计原则你知道有哪些吗" class="headerlink" title="4.面向对象的设计原则你知道有哪些吗"></a>4.面向对象的设计原则你知道有哪些吗</h2><p>面向对象编程中的六大原则：</p>
<ul>
<li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li>
<li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li>
<li><strong>里氏替换原则（LSP）</strong>：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li>
<li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。</li>
<li><strong>最少知识原则 (Law of Demeter)</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。</li>
</ul>
<h2 id="5-重载与重写有什么区别？"><a href="#5-重载与重写有什么区别？" class="headerlink" title="5.重载与重写有什么区别？"></a>5.重载与重写有什么区别？</h2><ul>
<li>重载（Overloading）指的是在<strong>同一个类中，可以有多个同名方法，它们具有不同的参数列表</strong>（参数类型、参数个数或参数顺序不同），编译器根据调用时的参数类型来决定调用哪个方法。</li>
<li>重写（Overriding）指的是<strong>子类可以重新定义父类中的方法，</strong>方法名、参数列表和返回类型必须与父类中的方法一致，通过<strong>@override</strong>注解来明确表示这是对父类方法的重写。</li>
</ul>
<p>重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。</p>
<h2 id="6-抽象类和普通类区别？"><a href="#6-抽象类和普通类区别？" class="headerlink" title="6.抽象类和普通类区别？"></a>6.抽象类和普通类区别？</h2><ul>
<li>实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。</li>
<li>方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。</li>
<li>继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。</li>
<li>实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。</li>
</ul>
<h2 id="7-Java抽象类和接口的区别是什么？"><a href="#7-Java抽象类和接口的区别是什么？" class="headerlink" title="7.Java抽象类和接口的区别是什么？"></a>7.Java抽象类和接口的区别是什么？</h2><p><strong>两者的特点：</strong></p>
<ul>
<li>抽象类用于<strong>描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。</strong>适用于有明显<strong>继承</strong>关系的场景。</li>
<li>接口用于定义行为规范，可以多实现，<strong>只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。</strong>适用于定义类的能力或功能。</li>
</ul>
<p><strong>两者的区别：</strong></p>
<ul>
<li>实现方式：实现接口的关键字为<strong>implements</strong>，继承抽象类的关键字为<strong>extends</strong>。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li>
<li>方法方式：<strong>接口只有定义，不能有方法的实现</strong>，java 1.8中可以定义default方法体，而抽<strong>象类可以有定义与实现，方法可在抽象类中实现。</strong></li>
<li>访问修饰符：<strong>接口成员变量默认为public static final</strong>，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。<strong>抽象类中成员变量默认default</strong>，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li>
<li>变量：<strong>抽象类可以包含实例变量和静态变量，而接口只能包含常量（</strong>即静态常量）。</li>
</ul>
<h2 id="8-抽象类能加final修饰吗？"><a href="#8-抽象类能加final修饰吗？" class="headerlink" title="8.抽象类能加final修饰吗？"></a>8.抽象类能加final修饰吗？</h2><p><strong>不能</strong>，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。</p>
<h2 id="9-接口里面可以定义哪些方法？"><a href="#9-接口里面可以定义哪些方法？" class="headerlink" title="9.接口里面可以定义哪些方法？"></a>9.接口里面可以定义哪些方法？</h2><ul>
<li><strong>抽象方法</strong></li>
</ul>
<p>抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>默认方法</strong></li>
</ul>
<p>默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>静态方法</strong></li>
</ul>
<p>静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>私有方法</strong></li>
</ul>
<p>私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-抽象类可以被实例化吗？"><a href="#10-抽象类可以被实例化吗？" class="headerlink" title="10.抽象类可以被实例化吗？"></a>10.抽象类可以被实例化吗？</h2><p>在Java中，抽象类本身不能被实例化。</p>
<p>这意味着不能使用<code>new</code>关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由<code>abstract</code>关键字修饰且无方法体的方法），这些方法需要在子类中被实现。</p>
<p><strong>抽象类可以有构造器，他可以有构造方法，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。</strong>然而，这个过程并不是直接实例化抽象类，<strong>而是创建了子类的实例，间接地使用了抽象类的构造器。</strong></p>
<p>简而言之，抽象类不能直接实例化，但通过继承抽象类并实现所有抽象方法的子类是可以被实例化的。</p>
<h2 id="11-接口可以包含构造函数吗？"><a href="#11-接口可以包含构造函数吗？" class="headerlink" title="11.接口可以包含构造函数吗？"></a>11.接口可以包含构造函数吗？</h2><p><strong>在接口中，不可以有构造方法</strong>,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。</p>
<p>为什么呢？构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用，那么问题来了Java的接口，都不能new 那么要构造函数干嘛呢？根本就没法调用</p>
<h2 id="12-解释Java中的静态变量和静态方法"><a href="#12-解释Java中的静态变量和静态方法" class="headerlink" title="12.解释Java中的静态变量和静态方法"></a>12.解释Java中的静态变量和静态方法</h2><p>在Java中，<strong>静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。</strong></p>
<blockquote>
<p>静态变量</p>
</blockquote>
<p>静态变量（也称为类变量）是在类中使用<code>static</code>关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：</p>
<ul>
<li><strong>共享性</strong>：<strong>所有该类的实例共享同一个静态变量</strong>。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</li>
<li><strong>初始化</strong>：<strong>静态变量在类被加载时初始化，只会对其进行一次分配内存。</strong></li>
<li><strong>访问方式</strong>：静态变量可以直接通过<strong>类名访问</strong>，也可以通过实例访问，但推荐使用类名。</li>
</ul>
<blockquote>
<p>静态方法</p>
</blockquote>
<p>静态方法是在类中使用<code>static</code>关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：</p>
<ul>
<li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。<strong>对于静态方法来说，不能直接访问非静态的成员变量或方法</strong>，因为静态方法没有上下文的实例。</li>
<li><strong>访问静态成员</strong>：静态方法<strong>可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</strong></li>
<li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）。</li>
</ul>
<h2 id="13-非静态内部类和静态内部类的区别？"><a href="#13-非静态内部类和静态内部类的区别？" class="headerlink" title="13.非静态内部类和静态内部类的区别？"></a>13.非静态内部类和静态内部类的区别？</h2><p>区别包括：</p>
<ul>
<li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。</li>
<li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。</li>
<li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。</li>
<li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。</li>
<li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。</li>
</ul>
<p>总结来说<strong>一内一外</strong></p>
<h2 id="14-非静态内部类可以直接访问外部方法，编译器是怎么做到的？"><a href="#14-非静态内部类可以直接访问外部方法，编译器是怎么做到的？" class="headerlink" title="14.非静态内部类可以直接访问外部方法，编译器是怎么做到的？"></a>14.非静态内部类可以直接访问外部方法，编译器是怎么做到的？</h2><p>非静态内部类可以直接访问外部方法是因为<strong>编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</strong></p>
<p>这个引用使得非静态内部类能够访问外部类的实例变量和方法。<strong>编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</strong></p>
<h1 id="关键词-amp-泛型-amp-反射"><a href="#关键词-amp-泛型-amp-反射" class="headerlink" title="关键词&amp;泛型&amp;反射"></a>关键词&amp;泛型&amp;反射</h1><h2 id="1-Java-中-final-作用是什么？"><a href="#1-Java-中-final-作用是什么？" class="headerlink" title="1.Java 中 final 作用是什么？"></a>1.Java 中 final 作用是什么？</h2><p><code>final</code>关键字主要有以下三个方面的作用：用于修饰类、方法和变量。</p>
<ul>
<li>修饰类：当<code>final</code>修饰一个类时，<strong>表示这个类不能被继承</strong>，是类继承体系中的最终形态。例如，Java 中的<code>String</code>类就是用<code>final</code>修饰的，这保证了<code>String</code>类的不可变性和安全性，防止其他类通过继承来改变<code>String</code>类的行为和特性。</li>
<li>修饰方法：<strong>用<code>final</code>修饰的方法不能在子类中被重写</strong>。比如，<code>java.lang.Object</code>类中的<code>getClass</code>方法就是<code>final</code>的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。</li>
<li>修饰变量：<strong>当<code>final</code>修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。</strong>例如，<code>final int num = 10;</code>，这里的<code>num</code>就是一个常量，不能再对其进行重新赋值操作，否则会导致编译错误。<strong>对于引用数据类型，<code>final</code>修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。</strong>例如，<code>final StringBuilder sb = new StringBuilder(&quot;Hello&quot;);</code>，不能让<code>sb</code>再指向其他<code>StringBuilder</code>对象，但可以通过<code>sb.append(&quot; World&quot;);</code>来修改字符串的内容。</li>
</ul>
<h2 id="2-什么是泛型？"><a href="#2-什么是泛型？" class="headerlink" title="2.什么是泛型？"></a>2.什么是泛型？</h2><p>泛型是 Java 编程语言中的一个重要特性，<strong>它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</strong></p>
<p>泛型的主要目的是<strong>在编译时提供更强的类型检查，并且在编译后能够保留类型信息，</strong>避免了在运行时出现类型转换异常。</p>
<blockquote>
<p>为什么需要泛型？</p>
</blockquote>
<ul>
<li><strong>适用于多种数据类型执行相同的代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li>
</ul>
<p>看下这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure>
<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，<strong>且很容易出现java.lang.ClassCastException异常。</strong></p>
<p>引入泛型，它将提供类型的约束，<strong>提供编译前的检查：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure>
<p>好处：</p>
<p><strong>编译期类型检查</strong>，提升代码安全性，防止运行时类型转换异常（ClassCastException）。编译时会自动装箱拆箱来配合基本类型的包装类。</p>
<p><strong>避免强制类型转换</strong>，代码更简洁清晰。</p>
<p><strong>提高代码复用性</strong>，同一份代码可以处理不同类型的数据。</p>
<p>他只能使用包装类，不能用于基本的数据类型</p>
<p>Java 泛型采用<strong>类型擦除</strong>实现，泛型信息在编译后被擦除，泛型变量变为原始类型（通常是Object或边界类型）。</p>
<p>运行的时候是不能使用的，比如不能创建泛型数组，无法进行类型判断等</p>
<h2 id="3-什么是反射"><a href="#3-什么是反射" class="headerlink" title="3.什么是反射"></a>3.什么是反射</h2><p>Java 反射机制是<strong>在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；</strong>这种<strong>动态获取</strong>的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<p>反射具有以下特性：</p>
<ol>
<li><strong>运行时类信息访问</strong>：反射机制允许程序在<strong>运行时获取类的完整结构信息</strong>，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</li>
<li><strong>动态对象创建</strong>：可以使用<strong>反射API动态地创建对象实例</strong>，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。</li>
<li><strong>动态方法调用</strong>：可以在<strong>运行时动态地调用对象的方法</strong>，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</li>
<li><strong>访问和修改字段值</strong>：反射还允许<strong>程序在运行时访问和修改对象的字段值</strong>，即使是私有的。这是通过Field类的get()和set()方法完成的。</li>
</ol>
<p>使用实例：</p>
<blockquote>
<p>加载数据库驱动</p>
</blockquote>
<p>我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。</p>
<p>这时候我们在使用 <strong>JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，</strong>如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置文件加载</p>
</blockquote>
<p>Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>
<p>Spring通过XML配置模式装载Bean的过程：</p>
<ul>
<li>将程序中所有XML或properties配置文件加载入内存</li>
<li>Java类里面<strong>解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</strong></li>
<li>使用反射机制，根据这个字符串获得<strong>某个类的Class实例</strong></li>
<li>动态配置实例的属性</li>
</ul>
<p>配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=com.example.reflectdemo.TestInvoke</span><br><span class="line">methodName=printlnState</span><br></pre></td></tr></table></figure>
<p>实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析配置文件内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\IdeaProjects\AllDemos\language-specification\src\main\resources\application.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException &#123;</span><br><span class="line">    <span class="comment">// 使用反射机制，根据这个字符串获得Class对象</span></span><br><span class="line">    Class&lt;?&gt; c = Class.forName(getName(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">    System.out.println(c.getSimpleName());</span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getDeclaredMethod(getName(<span class="string">&quot;methodName&quot;</span>));</span><br><span class="line">    <span class="comment">// 绕过安全检查</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="type">TestInvoke</span> <span class="variable">testInvoke</span> <span class="operator">=</span> (TestInvoke)c.newInstance();</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    method.invoke(testInvoke);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>判断对象所属类</strong>：<code>obj.getClass()</code> 获取对象的 Class 对象。</li>
<li><strong>加载类</strong>：<code>Class.forName(&quot;全类名&quot;)</code> 动态加载类。</li>
<li><strong>获取构造器并实例化对象</strong>：<code>clazz.getConstructor(...)</code> + <code>constructor.newInstance(...)</code></li>
<li><strong>访问类的成员变量和方法</strong>：<code>clazz.getDeclaredFields()</code>, <code>clazz.getDeclaredMethods()</code></li>
<li><strong>调用对象方法</strong>：<code>method.invoke(obj, args...)</code></li>
<li><strong>访问私有成员</strong>：通过 <code>setAccessible(true)</code> 取消访问检查。</li>
</ul>
<p>反射机制<strong>实际上会降低程序的性能</strong>,因为它需要在运行时进行类型检查和解析。同时,反射也可能破坏封装性,带来安全风险,因为它可以访问私有成员</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>提高程序灵活性和扩展性</strong>，支持动态加载类和调用</td>
<td><strong>性能较慢</strong>，需要绕过 JVM 优化，存在额外开销</td>
</tr>
<tr>
<td>支持框架、工具实现通用逻辑和动态操作</td>
<td><strong>破坏封装性</strong>，可访问私有成员，可能导致安全风险</td>
</tr>
<tr>
<td>支持动态代理、注解解析等高级功能</td>
<td><strong>编译时缺乏类型检查</strong>，错误只能运行时发现</td>
</tr>
</tbody>
</table>
</div>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="1-深拷贝和浅拷贝的区别"><a href="#1-深拷贝和浅拷贝的区别" class="headerlink" title="1.深拷贝和浅拷贝的区别"></a>1.深拷贝和浅拷贝的区别</h2><ul>
<li>浅拷贝是指<strong>只复制对象本身和其内部的值类型字段</strong>，但不会复制对象内部的引用类型字段。换句话说，<strong>浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中</strong>，但如果原对象内部有引用类型的字段，<strong>只是将引用复制到新对象中</strong>，<strong>两个对象指向的是同一个引用对象。</strong></li>
<li>深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，<strong>生成一个全新的对象以及其内部的所有对象。</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>对比项</th>
<th>浅拷贝（Shallow Copy）</th>
<th>深拷贝（Deep Copy）</th>
</tr>
</thead>
<tbody>
<tr>
<td>拷贝级别</td>
<td>拷贝对象本身+<strong>引用地址</strong></td>
<td>拷贝对象本身+<strong>引用对象的内容</strong></td>
</tr>
<tr>
<td>引用对象</td>
<td>原对象与副本<strong>共享引用对象</strong></td>
<td>副本拥有独立的引用对象</td>
</tr>
<tr>
<td>默认实现</td>
<td>Object.clone() 默认是浅拷贝</td>
<td>需手动实现递归复制</td>
</tr>
<tr>
<td>影响</td>
<td>改变副本的引用成员，会影响原对象</td>
<td>改变副本不影响原对象</td>
</tr>
<tr>
<td>应用场景</td>
<td>轻量对象复制，性能优先</td>
<td>要求对象完全独立、互不干扰</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-实现深拷贝的方式"><a href="#2-实现深拷贝的方式" class="headerlink" title="2.实现深拷贝的方式"></a>2.实现深拷贝的方式</h2><blockquote>
<p>实现 Cloneable 接口并重写 clone() 方法</p>
</blockquote>
<p>这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用序列化和反序列化</p>
</blockquote>
<p>通过将<strong>对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝</strong>。要求对象及其所有引用类型字段都实现 <strong>Serializable</strong> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>手动递归复制</p>
</blockquote>
<p>针对特定对象结构，<strong>手动递归复制对象及其引用类型字段</strong>。适用于对象结构复杂度不高的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">        copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">        copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-创建对象的五种方式"><a href="#1-创建对象的五种方式" class="headerlink" title="1.创建对象的五种方式"></a>1.创建对象的五种方式</h2><p><strong>使用new关键字</strong>：通过new关键字直接调用类的构造方法来创建对象。</p>
<p><strong>使用Class类的newInstance()方法</strong>：通过反射机制，可以使用Class类的newInstance()方法创建对象。</p>
<p><strong>使用Constructor类的newInstance()方法</strong>：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。一般跟反射一块用吧，获取类的构造器之后新建对象</p>
<p><strong>使用clone()方法</strong>：如果类实现了<strong>Cloneable</strong>接口，可以使用clone()方法复制对象。</p>
<p>这就是<strong>拷贝</strong></p>
<p><strong>使用反序列化</strong>：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。</p>
<h2 id="2-new出的对象什么时候回收"><a href="#2-new出的对象什么时候回收" class="headerlink" title="2.new出的对象什么时候回收"></a>2.new出的对象什么时候回收</h2><p>通过过关键字<code>new</code>创建的对象，由<strong>Java的垃圾回收器</strong>（Garbage Collector）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。</p>
<p>具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：</p>
<ol>
<li>引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li>
<li><strong>可达性分析算法</strong>：<strong>从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，</strong>如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li>
<li><strong>终结器</strong>（Finalizer）：如果对象重写了<code>finalize()</code>方法，垃圾回收器会在回收该对象之前调用<code>finalize()</code>方法，对象可以在<code>finalize()</code>方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。这个类似于try-catch-finally中的finally</li>
</ol>
<h2 id="3-如何获取私有对象？"><a href="#3-如何获取私有对象？" class="headerlink" title="3.如何获取私有对象？"></a>3.如何获取私有对象？</h2><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code> 的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问。</p>
<p>不过，可以通过下面两种方式来间接获取私有对象。</p>
<ul>
<li><strong>使用公共访问器方法（getter 方法）</strong>：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（即 <code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共的 getter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrivateField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> privateField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="comment">// 通过调用 getter 方法获取私有对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> obj.getPrivateField();</span><br><span class="line">        System.out.println(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通<strong>过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。</strong>但是却会破坏封装性，安全不会得到保障</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="comment">// 获取 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">        <span class="comment">// 获取私有字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        privateField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取私有字段的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) privateField.get(obj);</span><br><span class="line">        System.out.println(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="1-能讲一讲Java注解的原理吗？"><a href="#1-能讲一讲Java注解的原理吗？" class="headerlink" title="1.能讲一讲Java注解的原理吗？"></a>1.能讲一讲Java注解的原理吗？</h2><p>注解本质是一个<strong>继承了Annotation的特殊接口</strong>，其具体实现类<strong>是Java运行时生成的动态代理类。</strong></p>
<p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的<strong>invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</strong></p>
<h2 id="2-对注解解析的底层实现了解吗？"><a href="#2-对注解解析的底层实现了解吗？" class="headerlink" title="2.对注解解析的底层实现了解吗？"></a>2.对注解解析的底层实现了解吗？</h2><p>注解本质上是一种<strong>特殊的接口</strong>，它继承自 <code>java.lang.annotation.Annotation</code> 接口，<strong>所以注解也叫声明式接口</strong>，例如，定义一个简单的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，Java 编译器会将其转换为一个继承自 <code>Annotation</code> 的接口，并生成相应的字节码文件。</p>
<p>根据注解的作用范围，Java 注解可以分为以下几种类型：</p>
<ul>
<li><strong>源码级别注解</strong> ：<strong>仅存在于源码中</strong>，编译后不会保留（<code>@Retention(RetentionPolicy.SOURCE)</code>）。</li>
<li><strong>类文件级别注解</strong> ：<strong>保留在 <code>.class</code> 文件中，但运行时不可见</strong>（<code>@Retention(RetentionPolicy.CLASS)</code>）。</li>
<li><strong>运行时注解</strong> ：保留在 <code>.class</code> 文件中，<strong>并且可以通过反射在运行时访问</strong>（<code>@Retention(RetentionPolicy.RUNTIME)</code>）。</li>
</ul>
<p>只有运行时注解可以通过反射机制进行解析。</p>
<p>当注解被标记为 <code>RUNTIME</code> 时，Java 编译器会在生成的 <code>.class</code> 文件中保存注解信息。这些信息存储在字节码的属性表（Attribute Table）中，具体包括以下内容：</p>
<ul>
<li><strong>RuntimeVisibleAnnotations</strong> ：存储运行时可见的注解信息。</li>
<li><strong>RuntimeInvisibleAnnotations</strong> ：存储运行时不可见的注解信息。</li>
<li><strong>RuntimeVisibleParameterAnnotations</strong> 和 <strong>RuntimeInvisibleParameterAnnotations</strong> ：存储方法参数上的注解信息。</li>
</ul>
<p>通过工具（如 <code>javap -v</code>）可以查看 <code>.class</code> 文件中的注解信息。</p>
<p>注解的解析主要依赖于 Java 的反射机制。以下是解析注解的基本流程：</p>
<p>1、获取注册信息：通过反射 API 可以获取类、方法、字段等元素上的注解。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(annotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、底层原理：反射机制的核心类是 <code>java.lang.reflect.AnnotatedElement</code>，它是所有可以被注解修饰的元素（如 <code>Class</code>、<code>Method</code>、<code>Field</code> 等）的父接口。该接口提供了以下方法：</p>
<ul>
<li><code>getAnnotation(Class&lt;T&gt; annotationClass)</code>：获取指定类型的注解。</li>
<li><code>getAnnotations()</code>：获取所有注解。</li>
<li><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>：判断是否包含指定注解。</li>
</ul>
<p>这些方法的底层实现依赖于 JVM 提供的本地方法（Native Method），例如：</p>
<ul>
<li><code>native Annotation[] getDeclaredAnnotations0(boolean publicOnly);</code></li>
<li><code>native &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass);</code></li>
</ul>
<p>JVM 在加载类时会解析 <strong><code>.class</code> 文件中的注解信息，并将其存储在内存中，供反射机制使用。</strong></p>
<p>因此，注解解析的底层实现主要<strong>依赖于 Java 的反射机制和字节码文件的存储</strong>。通过 <code>@Retention</code> 元注解可以控制注解的保留策略，当使用 <code>RetentionPolicy.RUNTIME</code> 时，可以在运行时通过<strong>反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值。</strong></p>
<h2 id="3-Java注解的作用域呢？"><a href="#3-Java注解的作用域呢？" class="headerlink" title="3.Java注解的作用域呢？"></a>3.Java注解的作用域呢？</h2><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p>
<ol>
<li><strong>类级别作用域</strong>：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，<strong>如类的访问级别、继承关系、注释等。</strong></li>
<li><strong>方法级别作用域</strong>：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，<strong>如方法的访问级别、返回值类型、异常类型、注释等。</strong></li>
<li><strong>字段级别作用域</strong>：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，<strong>如字段的访问级别、默认值、注释等。</strong></li>
</ol>
<p>除了这三种作用域，Java还提供了其他一些注解作用域，例如<strong>构造函数作用域和局部变量作用域</strong>。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/05/19/javase/javase2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/05/19/javase/javase2/')">javase面试题目hot</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/05/19/javase/javase2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=javase面试题目hot&amp;url=https://blog.tokenlen.top/2025/05/19/javase/javase2/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712175.jpg?_r_=6bc4dfd9-2b13-a123-945b-c0d30223e215" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/javase/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>javase<span class="categoryesPageCount">12</span></a><a class="post-meta__box__categoryes" href="/categories/javase/java/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>java<span class="categoryesPageCount">2</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">33</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg?_r_=2964651f-3d72-e6e0-c29e-6c7edb81cc53" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/15/java-stack/redis2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722380.jpg?_r_=79460498-abfe-beb9-935e-a93d6046901a" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">redis面试hot</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/19/javase/javase1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=f5e89497-0d02-c042-9165-da6f1c6378be" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">javase知识总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/04/01/leetcode/leetcodedayone/" title="Leetcode 每日一题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712180.jpg?_r_=41514339-5a83-a7d0-f338-3663be073f52" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-04-01</div><div class="title">Leetcode 每日一题</div></div></a></div><div><a href="/2025/03/02/leetcode/leetcodehot/" title="Leetcode HOT100题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=b3075670-bb57-526a-0f3f-7e00c5e60ff4" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-02</div><div class="title">Leetcode HOT100题</div></div></a></div><div><a href="/2025/05/22/java-stack/juc2/" title="JUC-线程池面试题hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg?_r_=2964651f-3d72-e6e0-c29e-6c7edb81cc53" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-22</div><div class="title">JUC-线程池面试题hot</div></div></a></div><div><a href="/2025/05/21/workmenu/tcpfile/" title="tcpfile上传"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712179.jpg?_r_=941a6515-ebaf-5247-bb62-1576bca4eb2f" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-21</div><div class="title">tcpfile上传</div></div></a></div><div><a href="/2025/05/19/javase/javase1/" title="javase知识总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=f5e89497-0d02-c042-9165-da6f1c6378be" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-19</div><div class="title">javase知识总结</div></div></a></div><div><a href="/2025/05/12/leetcode/leetcode3/" title="Leetcode双指针"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=0675e833-1506-7b60-c8ff-44c1647bdfd8" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-12</div><div class="title">Leetcode双指针</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">基础面试题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.说一下Java的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java-%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.Java 的优势和劣势是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Java%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.Java为什么是跨平台的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JVM%E3%80%81JDK%E3%80%81JRE%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.JVM、JDK、JRE三者关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88Java%E8%A7%A3%E9%87%8A%E5%92%8C%E7%BC%96%E8%AF%91%E9%83%BD%E6%9C%89%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.为什么Java解释和编译都有？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-jvm%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.jvm是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">7.编译型语言和解释型语言的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.八种基本的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-int%E5%92%8Clong%E6%98%AF%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%8C%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.int和long是多少位，多少字节的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-long%E5%92%8Cint%E5%8F%AF%E4%BB%A5%E4%BA%92%E8%BD%AC%E5%90%97-%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.long和int可以互转吗 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.数据类型转换方式你知道哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.类型互转会出现什么问题吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8bigDecimal-%E4%B8%8D%E7%94%A8double-%EF%BC%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.为什么用bigDecimal 不用double ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.装箱和拆箱是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Java%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89Integer%EF%BC%9F"><span class="toc-number">1.2.8.</span> <span class="toc-text">8.Java为什么要有Integer？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Integer%E7%9B%B8%E6%AF%94int%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.9.</span> <span class="toc-text">9.Integer相比int有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BF%9D%E7%95%99int%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.10.</span> <span class="toc-text">10.那为什么还要保留int类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AF%B4%E4%B8%80%E4%B8%8B-integer%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.11.</span> <span class="toc-text">11.说一下 integer的缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">1.怎么理解面向对象？简单说说封装继承多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%9A%E6%80%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.多态体现在哪几个方面？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3.多态解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%97"><span class="toc-number">2.4.</span> <span class="toc-text">4.面向对象的设计原则你知道有哪些吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.重载与重写有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%99%AE%E9%80%9A%E7%B1%BB%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6.抽象类和普通类区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">7.Java抽象类和接口的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E5%8A%A0final%E4%BF%AE%E9%A5%B0%E5%90%97%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8.抽象类能加final修饰吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%8E%A5%E5%8F%A3%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9.接口里面可以定义哪些方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%97%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">10.抽象类可以被实例化吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">11.接口可以包含构造函数吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%A7%A3%E9%87%8AJava%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.12.</span> <span class="toc-text">12.解释Java中的静态变量和静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">13.非静态内部类和静态内部类的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">14.非静态内部类可以直接访问外部方法，编译器是怎么做到的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D-amp-%E6%B3%9B%E5%9E%8B-amp-%E5%8F%8D%E5%B0%84"><span class="toc-number">3.</span> <span class="toc-text">关键词&amp;泛型&amp;反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-%E4%B8%AD-final-%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.Java 中 final 作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.什么是泛型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">3.3.</span> <span class="toc-text">3.什么是反射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.</span> <span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">1.深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">2.实现深拷贝的方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">1.创建对象的五种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-new%E5%87%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6"><span class="toc-number">5.2.</span> <span class="toc-text">2.new出的对象什么时候回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3.如何获取私有对象？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%BD%E8%AE%B2%E4%B8%80%E8%AE%B2Java%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1.能讲一讲Java注解的原理吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2.对注解解析的底层实现了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%91%A2%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.Java注解的作用域呢？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/22/java-stack/juc2/" title="JUC-线程池面试题hot"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg?_r_=2964651f-3d72-e6e0-c29e-6c7edb81cc53" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC-线程池面试题hot"/></a><div class="content"><a class="title" href="/2025/05/22/java-stack/juc2/" title="JUC-线程池面试题hot">JUC-线程池面试题hot</a><time datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/21/mysql/mysqlstack/" title="Mysql进阶技术栈"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=e2ea3193-365b-f703-6c2f-acdc01d7de01" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql进阶技术栈"/></a><div class="content"><a class="title" href="/2025/05/21/mysql/mysqlstack/" title="Mysql进阶技术栈">Mysql进阶技术栈</a><time datetime="2025-05-20T16:00:00.000Z" title="发表于 2025-05-21 00:00:00">2025-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/21/workmenu/tcpfile/" title="tcpfile上传"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712179.jpg?_r_=941a6515-ebaf-5247-bb62-1576bca4eb2f" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="tcpfile上传"/></a><div class="content"><a class="title" href="/2025/05/21/workmenu/tcpfile/" title="tcpfile上传">tcpfile上传</a><time datetime="2025-05-20T16:00:00.000Z" title="发表于 2025-05-21 00:00:00">2025-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/19/javase/javase1/" title="javase知识总结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=f5e89497-0d02-c042-9165-da6f1c6378be" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javase知识总结"/></a><div class="content"><a class="title" href="/2025/05/19/javase/javase1/" title="javase知识总结">javase知识总结</a><time datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/19/javase/javase2/" title="javase面试题目hot"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712175.jpg?_r_=6bc4dfd9-2b13-a123-945b-c0d30223e215" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javase面试题目hot"/></a><div class="content"><a class="title" href="/2025/05/19/javase/javase2/" title="javase面试题目hot">javase面试题目hot</a><time datetime="2025-05-18T16:00:00.000Z" title="发表于 2025-05-19 00:00:00">2025-05-19</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">115</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">18</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 0.88rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 0.88rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/football/" style="font-size: 0.88rem;">football<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>33</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>6</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>4</sup></a><a href="/tags/paper/" style="font-size: 0.88rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 0.88rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>3</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>1</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>6</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>4</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>16</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 0.88rem;">毛选<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>8</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>