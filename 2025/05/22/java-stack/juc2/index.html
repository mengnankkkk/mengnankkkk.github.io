<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JUC-线程池面试题hot | mengnankkのblog</title><meta name="keywords" content="java,juc,面试"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JUC-线程池面试题hot"><meta name="application-name" content="JUC-线程池面试题hot"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="JUC-线程池面试题hot"><meta property="og:url" content="https://blog.tokenlen.top/2025/05/22/java-stack/juc2/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="线程池1.线程池用过没有？ 说说他的核心参数？线程在正常执行或者异常中断时会被销毁，如果频繁的创建很多线程，不仅会消耗系统资源，还会降低系统的稳定性，一不小心把系统搞崩了。 使用线程池可以带来以下几个好处：  线程池内部的线程数是可控的，可以灵活的设置参数； 线程池内会保留部分线程，当提交新的任务可"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=c7a8c787-9b70-567b-45ae-27be096b2bc6"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=c7a8c787-9b70-567b-45ae-27be096b2bc6"><meta name="description" content="线程池1.线程池用过没有？ 说说他的核心参数？线程在正常执行或者异常中断时会被销毁，如果频繁的创建很多线程，不仅会消耗系统资源，还会降低系统的稳定性，一不小心把系统搞崩了。 使用线程池可以带来以下几个好处：  线程池内部的线程数是可控的，可以灵活的设置参数； 线程池内会保留部分线程，当提交新的任务可"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/05/22/java-stack/juc2/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: 'JUC-线程池面试题hot',
  postAI: '',
  pageFillDescription: '线程池, 1.线程池用过没有？ 说说他的核心参数？, 2.线程池的拒绝策略, 3.描述一下创建一个线程池提交任务的过程, 4.一个任务执行完后如果再往线程池中提交一个任务过程是什么样的, 5.执行完第二个任务后线程池里面还会有几个线程, 6.有线程池参数设置的经验吗？, 7.核心线程数设置为0可不可以？, 8.线程池种类有哪些？, 9.线程池一般是怎么用的？, 10.线程池中shutdown ()shutdownNow()这两个方法有什么作用？, 11.提交给线程池中的任务可以被撤回吗？, 12.Java 中为什么要使用线程池？线程池如何处理异常, 多线程, 1.java里面的线程和操作系统的线程一样吗？, 2.使用多线程要注意哪些问题？, 3.保证数据的一致性有哪些方案呢？, 4.线程的创建方式有哪些?, 5.怎么启动线程 ？, 6.如何停止一个线程的运行?, 7.调用 interrupt 是如何让线程抛出异常的?, 8.Java线程的状态有哪些？, 9.sleep 和 wait的区别是什么？, 10.sleep会释放cpu吗？, 11.blocked和waiting有啥区别, 12.wait 状态下的线程如何进行恢复到 running 状态?, 13.notify 和 notifyAll 的区别?, 14.notify 选择哪个线程?, 15.不同的线程之间如何通信？, 16.线程间通信方式有哪些？, 17.如何停止一个线程？, 并发, 1.juc包下你常用的类？, 2.怎么保证多线程安全？, 3.Java中有哪些常用的锁在什么场景下使用？, 4.怎么在实践中用锁的？, 5.Java 并发工具你知道哪些？, 6.CountDownLatch 是做什么的讲一讲？, 7.synchronized和reentrantlock及其应用场景？, 8.除了用synchronized还有什么方法可以实现线程同步？, 9.synchronized锁静态方法和普通方法区别？, 10.synchronized和reentrantlock区别？, 11.怎么理解可重入锁？, 12.synchronized 支持重入吗？如何实现的?, 13.syncronized锁升级的过程讲一下, 14.JVM对Synchornized的优化？, 15.介绍一下AQS, 16.CAS 和 AQS 有什么关系？, 17.如何用 AQS 实现一个可重入的公平锁？, 18.Threadlocal作用原理具体里面存的key value是啥会有什么问题如何解决?, 19.悲观锁和乐观锁的区别？, 20.Java中想实现一个乐观锁都有哪些方式？, 21.CAS 有什么缺点？, 22.为什么不能所有的锁都用CAS？, 23.CAS 有什么问题Java是怎么解决的？, 24.voliatle关键字有什么作用？, 25.指令重排序的原理是什么？, 26.volatile可以保证线程安全吗？, 27.volatile和sychronized比较？, 28.什么是公平锁和非公平锁？, 29.非公平锁吞吐量为什么比公平锁大？, 30.什么情况会产生死锁问题？如何解决？, 31.CAS的类型和使用, 场景, 1.多线程打印奇偶数怎么控制打印的顺序, 2.3个线程并发执行1个线程等待这三个线程全部执行完在执行怎么实现？, 3.单例模型既然已经用了synchronized为什么还要在加volatile？, 4.假设两个线程并发读写同一个整型变量初始值为零每个线程加 50 次结果可能是什么？线程池线程池用过没有说说他的核心参数线程在正常执行或者异常中断时会被销毁如果频繁的创建很多线程不仅会消耗系统资源还会降低系统的稳定性一不小心把系统搞崩了使用线程池可以带来以下几个好处线程池内部的线程数是可控的可以灵活的设置参数线程池内会保留部分线程当提交新的任务可以直接运行方便内部线程资源的管理调优和监控为了减少频繁的创建线程和销毁线程带来的性能损耗首先所有任务的调度都是由方法完成的这部分完成的工作是检查现在线程池的运行状态运行线程数运行策略决定接下来执行的流程是直接申请线程执行或是缓冲到队列中执行亦或是直接拒绝该任务其执行过程如下首先检测线程池运行状态如果不是则直接拒绝线程池要保证在的状态下执行任务如果则创建并启动一个线程来执行新提交的任务如果且线程池内的阻塞队列未满则将任务添加到该阻塞队列中如果且线程池内的阻塞队列已满则创建并启动一个线程来执行新提交的任务如果并且线程池内的阻塞队列已满则根据拒绝策略来处理该任务默认的处理方式是直接抛异常七大核心参数线程池核心线程数量如果设置为线程池初始化后默认保持个线程待命默认情况下线程池中线程的数量如果那么即使这些线程处于空闲状态那也不会被销毁线程池允许的最大线程数当任务队列已满且当前线程数小于时线程池会创建新的线程来处理任务直至线程数达到当线程池中线程的数量大于并且某个线程的空闲时间超过了那么这个线程就会被销毁就是时间的单位工作队列当没有空闲的线程执行新任务时该任务就会被放入工作队列中等待执行用于创建线程的工厂通过自定义线程工厂你可以为线程设置名称优先级等属性拒绝策略当一个新任务交给线程池如果此时线程池中有空闲的线程就会直接执行如果没有空闲的线程就会将该任务加入到阻塞队列中如果阻塞队列满了就会创建一个新线程从阻塞队列头部取出一个任务来执行并将新任务加入到阻塞队列末尾如果当前线程池中线程的数量等于就不会创建新线程就会去执行拒绝策略线程池的拒绝策略常用的四种拒绝策略包括此外还可以通过实现接口来自定义拒绝策略使用线程池的调用者所在的线程去执行被拒绝的任务除非线程池被停止或者线程池的任务队列已有空缺直接抛出一个任务被线程池拒绝的异常这个是默认的不做任何处理静默拒绝提交的任务抛弃最老的任务然后执行该任务自定义拒绝策略通过实现接口可以自定义任务拒绝策略实现描述一下创建一个线程池提交任务的过程我们创建线程池的时候需要使用到核心线程数最大线程数非核心线程最大空闲存活时间时间单位阻塞队列任务队列线程工厂创建线程的策略拒绝策略提交任务的过程调用判断线程数是否小于核心线程数如果当前线程数核心线程数直接创建线程执行任务立刻执行不入队列核心线程已满尝试将任务放入工作队列如果核心线程都在运行任务会尝试进入阻塞队列如果入队成功等待空闲线程从队列中取任务执行如果入队失败队列满了尝试创建非核心线程如果线程数最大线程数则创建非核心线程执行任务线程数也满了启动拒绝策略还包括一个方法是创建线程的核心方法使用线程工厂创建线程将线程封装为对象加入工作线程集合启动线程并执行任务每个工作线程在启动后会不断循环执行任务其中从阻塞队列中获取任务核心线程空闲时仍保留非核心线程如果超过未获取到任务则被销毁一个任务执行完后如果再往线程池中提交一个任务过程是什么样的如果线程池仍然存活此时再提交一个任务的过程与最初提交任务时几乎相同但会受到已有线程空闲可复用的影响线程池中已有线程执行完任务进入空闲状态此时再次提交一个新任务依旧会执行检查是否需要创建新线程一般是当前线程数已达到核心线程数上一个任务刚执行完线程处于空闲状态尝试将任务加入队列如果线程池使用的是有界队列任务直接入队等待空闲线程来取任务执行不再新建线程如果是进行下一步是否需要创建非核心线程如果队列失败线程数尚未超过最大线程数创建线程执行任务非核心线程否则进入拒绝策略队列满线程也满拒绝任务循环会尝试从队列中获取下一个任务如果任务队列中有新任务该线程继续执行新任务如果队列无任务核心线程一直等待非核心线程空闲超过会销毁如果线程池被则会拒绝任务执行完第二个任务后线程池里面还会有几个线程一般情况默认配置核心线程不回收执行两个任务后线程池中会保留两个核心线程若用非核心线程任务执行完后等待空闲执行完立即线程池中还有个线程核心非核心超过后只剩下核心线程有线程池参数设置的经验吗核心线程数设置的经验密集型核数避免过多线程竞争密集型核数或更高具体看等待时间场景一电商场景特点瞬时高并发任务处理时间短线程池的配置可设置如下假设核突发流量扩容非核心线程空闲秒回收不缓存任务直接扩容线程直接拒绝避免系统过载说明使用确保任务直达线程避免队列延迟拒绝策略快速失败前端返回活动火爆提示结合降级策略如缓存预热场景二后台数据处理服务特点稳定流量任务处理时间长秒级允许一定延迟线程池的配置可设置如下核禁止扩容避免资源耗尽不回收线程有界队列容量队列满后由调用线程执行说明固定线程数避免资源波动队列缓冲任务拒绝策略兜底配合监控告警如队列使用率触发扩容场景三微服务请求处理特点密集型依赖下游服务响应时间线程池的配置可设置如下核应对慢下游非核心线程空闲秒回收有界队列容量自定义拒绝策略重试或降级说明根据下游响应时间调整线程数队列防止瞬时峰值自定义拒绝策略将任务暂存异步重试核心线程数设置为可不可以可以当核心线程数为的时候会创建一个非核心线程进行执行从下面的源码也可以看到当核心线程数为时来了一个任务之后会先将任务添加到任务队列同时也会判断当前工作的线程数是否为如果为则会创建线程来执行线程池的任务线程池种类有哪些可以设置定期的执行任务它支持定时或周期性执行任务比如每隔秒钟执行一次任务我通过这个实现类设置定期执行任务的策略它的核心线程数和最大线程数是一样的所以可以把它看作是固定线程数的线程池它的特点是线程池中的线程数除了初始阶段需要从开始增加外之后的线程数量就是固定的就算任务数超过线程数线程池也不会再创建更多的线程来处理任务而是会把超出线程处理能力的任务放到任务队列中进行等待而且就算任务队列满了到了本该继续增加线程数的时候由于它的最大线程数和核心线程数是一样的所以也无法再增加新的线程了可以称作可缓存线程池它的特点在于线程数是几乎可以无限增加的实际最大可以达到为这个数非常大所以基本不可能达到而当线程闲置时还可以对线程进行回收也就是说该线程池的线程数量不是固定不变的当然它也有一个用于存储提交任务的队列但这个队列是队列的容量为实际不存储任何任务它只负责对任务进行中转和传递所以效率比较高它会使用唯一的线程去执行任务原理和是一样的只不过这里线程只有一个如果线程在执行任务的过程中发生异常线程池也会重新创建一个线程来执行后续的任务这种线程池由于只有一个线程所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序因为它们是多线程并行执行的它实际和线程池非常相似它只是的一个特例内部只有一个线程线程池一般是怎么用的中的类定义了一些快捷的工具方法来帮助我们快速创建线程池阿里巴巴开发手册中提到禁止使用这些方法来创建线程池而应该手动来创建线程池这一条规则的背后是大量血淋淋的生产事故最典型的就是和可能因为资源耗尽导致问题所以不建议使用提供的两种快捷的线程池原因如下我们需要根据自己的场景并发情况来评估线程池的几个核心参数包括核心线程数最大线程数线程回收策略工作队列的类型以及拒绝策略确保线程池的工作行为符合需求一般都需要设置有界的工作队列和可控的线程数任何时候都应该为自定义线程池指定有意义的名称以方便排查问题当出现线程数量暴增线程死锁线程占用大量线程执行出现异常等问题时我们往往会抓取线程栈此时有意义的线程名称就可以方便我们定位问题除了建议手动声明线程池以外我还建议用一些监控手段来观察线程池的状态线程池这个组件往往会表现得任劳任怨默默无闻除非是出现了拒绝策略否则压力再大都不会抛出一个异常如果我们能提前观察到线程池队列的积压或者线程数量的快速膨胀往往可以提早发现并解决问题线程池中这两个方法有什么作用从下面的源码高亮注释可以很清晰的看出两者的区别使用了以后会置状态为正在执行的任务会继续执行下去没有被执行的则中断此时则不能再往线程池中添加任何任务否则将会抛出异常比较平缓的关闭方式而为并试图停止所有正在执行的线程不再处理还在池队列中等待的任务当然它会返回那些未执行的任务它试图终止线程的方法是通过调用方法来实现的但是这种方法的作用有限如果线程中没有定时锁等应用方法是无法中断当前的线程的所以并不代表线程池就一定立即就能退出它可能必须要等待所有正在执行的任务都执行完成了才能退出源码高亮源码高亮高亮高亮提交给线程池中的任务可以被撤回吗可以当向线程池提交任务时会得到一个对象这个对象提供了几种方法来管理任务的执行包括取消任务取消任务的主要方法是接口中的方法这个方法尝试取消执行的任务参数指示是否允许中断正在执行的任务如果设置为则表示如果任务已经开始执行那么允许中断任务如果设置为任务已经开始执行则不会被中断是否取消线程的执行线程是否被取消线程是否执行完毕立即获得线程返回的结果延时时间后再获得线程返回的结果取消线程池中任务的方式代码如下通过对象的函数来定向取消特定的任务可能抛出异常终止任务的执行中为什么要使用线程池线程池如何处理异常线程池的核心优势系统化梳理资源复用避免频繁创建销毁线程创建线程耗时约复用可降低开销控制并发数防止并发过高导致的如秒杀场景限制线程数保护数据库统一管理统一设置线程名称优先级方便日志追踪和故障排查异步处理将耗时任务放入线程池避免主线程阻塞如日志异步写入比较单线程多线程和线程池异常处理使用包裹任务任务异常通过获取异常任务异常阻塞获取结果抛出异常任务异常拒绝策略会抛出需在提交任务时捕获任务被拒绝场景电商下单场景用线程池异步处理库存扣减积分计算等耗时任务主线程快速返回订单创建结果提升用户体验日志系统用线程池异步写入日志到避免阻塞影响业务接口响应时间多线程里面的线程和操作系统的线程一样吗底层会调用来创建线程所以本质上程序创建的线程就是和操作系统线程是一样的是对的线程模型使用多线程要注意哪些问题要保证多线程的程序是安全不要出现数据竞争造成的数据混乱的问题的线程安全在三个方面体现原子性提供互斥访问同一时刻只能有一个线程对数据进行操作在中使用了包这个包提供了一些支持原子操作的类这些类可以在多线程环境下保证操作的原子性和关键字来确保原子性比如可见性一个线程对主内存的修改可以及时地被其他线程看到在中使用了和这两个关键字确保可见性有序性一个线程观察其他线程中的指令执行顺序由于指令重排序该观察结果一般杂乱无序在中使用了原则来确保有序性比如保证数据的一致性有哪些方案呢事务管理使用数据库事务来确保一组数据库操作要么全部成功提交要么全部失败回滚通过原子性一致性隔离性持久性属性数据库事务可以保证数据的一致性锁机制使用锁来实现对共享资源的互斥访问在中可以使用关键字或其他锁机制来控制并发访问从而避免并发操作导致数据不一致版本控制通过乐观锁的方式在更新数据时记录数据的版本信息从而避免同时对同一数据进行修改进而保证数据的一致性线程的创建方式有哪些继承类这是最直接的一种方式用户自定义类继承类重写其方法方法中定义了线程执行的具体任务创建该类的实例后通过调用方法启动线程线程执行的代码采用继承类方式优点编写简单如果需要访问当前线程无需使用方法直接使用即可获得当前线程缺点因为线程类已经继承了类所以不能再继承其他的父类实现接口如果一个类已经继承了其他类就不能再继承类此时可以实现接口实现接口需要重写方法然后将此对象作为参数传递给类的构造器创建对象后调用其方法启动线程线程执行的代码采用实现接口方式优点线程类只是实现了接口还可以继承其他的类在这种方式下可以多个线程共享同一个目标对象所以非常适合多个相同线程来处理同一份资源的情况从而可以将代码和数据分开形成清晰的模型较好地体现了面向对象的思想缺点编程稍微复杂如果需要访问当前线程必须使用方法实现接口与接口类似于但的方法可以有返回值并且可以抛出异常要执行任务需将它包装进一个因为类的构造器只接受参数而实现了接口线程执行的代码这里返回一个整型结果获取线程执行结果采用实现接口方式缺点编程稍微复杂如果需要访问当前线程必须调用方法优点线程只是实现或实现接口还可以继承其他类这种方式下多个线程可以共享一个对象非常适合多线程处理同一份资源的情形使用线程池框架从开始引入的和相关类提供了线程池的支持这是一种更高效的线程管理方式避免了频繁创建和销毁线程的开销可以通过类的静态方法创建不同类型的线程池线程执行的代码创建固定大小的线程池提交任务到线程池执行关闭线程池采用线程池方式缺点程池增加了程序的复杂度特别是当涉及线程池参数调整和故障排查时错误的配置可能导致死锁资源耗尽等问题这些问题的诊断和修复可能较为复杂优点线程池可以重用预先创建的线程避免了线程创建和销毁的开销显著提高了程序的性能对于需要快速响应的并发请求线程池可以迅速提供线程来处理任务减少等待时间并且线程池能够有效控制运行的线程数量防止因创建过多线程导致的系统资源耗尽如内存溢出通过合理配置线程池大小可以最大化利用率和系统吞吐量提供的三个线程池不好使要实际应该还是应该自己设计一个线程池怎么启动线程启动线程的通过类的创建两个线程用启动线程新建线程调用方法后线程并不会立即进入运行状态线程的状态变化是新建就绪运行调用方法后线程会进入就绪状态等待调度才能进入运行状态这取决于线程调度器的调度策略方法会创建新的线程并执行方法而直接调用方法只会在当前线程中执行不会启动新线程如何停止一个线程的运行主要有这些方法异常法停止线程调用方法后在线程的方法中判断当前对象的状态如果是中断状态则抛出异常达到中断线程的效果在沉睡中停止先将线程然后调用标记中断状态会将阻塞状态的线程中断会抛出中断异常达到停止线程的效果暴力停止线程调用方法会被暴力停止方法已弃用该方法会有不好的后果强制让线程停止有可能使一些请理性的工作得不到完成可以使用方法使用停止线程调用标记为中断状态后在方法中判断当前线程状态如果为中断状态则能达到停止线程的效果调用是如何让线程抛出异常的每个线程都一个与之关联的布尔属性来表示其中断状态中断状态的初始值为当一个线程被其它线程调用方法中断时会根据实际情况做出响应如果该线程正在执行低级别的可中断方法如或则会解除阻塞并抛出异常否则仅设置线程的中断状态在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务线程的状态有哪些线程状态解释尚未启动的线程状态即线程创建还未调用方法就绪状态调用等待调度正在运行等待监视器锁时陷入阻塞状态等待状态的线程正在等待另一线程执行特定的操作如具有指定等待时间的等待状态线程完成执行终止状态和的区别是什么对比例表特性所属类类静态方法类实例方法锁释放使用前提任意位置调用必须在同步块内持有锁唤醒机制超时自动恢复需或超时设计用途暂停线程执行不涉及锁协作线程间协调释放锁让其他线程工作所属分类的不同是类的静态方法可以在任何地方直接通过调用无需依赖对象实例是类的实例方法这意味着必须通过对象实例来调用锁释放的情况在调用时线程会暂停执行指定的时间但不会释放持有的对象锁也就是说在期间其他线程无法获得该线程持有的锁调用该方法时线程会释放持有的对象锁进入等待状态直到其他线程调用相同对象的或方法唤醒它使用条件可在任意位置调用无需事先获取锁必须在同步块或同步方法内调用即线程需持有该对象的锁否则抛出唤醒机制休眠时间结束后线程自动恢复到就绪状态等待调度需要其他线程调用相同对象的或方法才能被唤醒会随机唤醒一个在该对象上等待的线程而会唤醒所有在该对象上等待的线程会释放吗是的调用时线程会释放但不会释放持有的锁当线程调用后会主动让出时间片进入状态此时操作系统会触发调度将分配给其他处于就绪状态的线程这样其他线程无论是需要同一锁的线程还是不相关线程便有机会执行不会释放线程已持有的任何锁如同步代码块或方法中获取的锁因此如果有其他线程试图获取同一把锁它们仍会被阻塞直到原线程退出同步代码块和有啥区别区别如下触发条件线程进入状态通常是因为试图获取一个对象的锁但该锁已经被另一个线程持有这通常发生在尝试进入块或方法时如果锁已被占用则线程将被阻塞直到锁可用线程进入状态是因为它正在等待另一个线程执行某些操作例如调用方法方法或方法在这种状态下线程将不会消耗资源并且不会参与锁的竞争唤醒机制当一个线程被阻塞等待锁时一旦锁被释放线程将有机会重新尝试获取锁如果锁此时未被其他线程获取那么线程可以从状态变为状态线程在状态中需要被显式唤醒例如如果线程调用了那么它必须等待另一个线程调用同一对象上的或方法才能被唤醒所以和两个状态最大的区别有两个是锁竞争失败后被被动触发的状态是人为的主动触发的状态的唤醒时自动触发的而状态是必须要通过特定的方法来主动唤醒状态下的线程如何进行恢复到状态程从等待状态恢复到运行状态的核心机制是通过外部事件触发或资源可用性变化比如等待的线程被其他线程对象唤醒和线程进入等待状态释放锁其他线程调用以下代码唤醒等待线程唤醒单个线程唤醒所有等待线程和的区别同样是唤醒等待的线程同样最多只有一个线程能获得锁同样不能控制哪个线程获得锁区别在于唤醒一个线程其他线程依然处于的等待唤醒状态如果被唤醒的线程结束时没调用其他线程就永远没人去唤醒只能等待超时或者被中断所有线程退出的状态开始竞争锁但只有一个线程能抢到这个线程执行完后其他线程又会有一个幸运儿脱颖而出得到锁选择哪个线程在源码的注释中说到选择唤醒的线程是任意的但是依赖于具体实现的有很多实现比较流行的就是对的实现并不是我们以为的随机唤醒而是先进先出的顺序唤醒不同的线程之间如何通信共享变量是最基本的线程间通信方式多个线程可以访问和修改同一个共享变量从而实现信息的传递为了保证线程安全通常需要使用关键字或关键字使用关键字保证变量的可见性生产者线程修改共享变量消费者线程等待共享变量被修改代码解释关键字确保了变量在多个线程之间的可见性即一个线程修改了的值其他线程能立即看到生产者线程在睡眠秒后将设置为消费者线程在为时一直等待直到变为才继续执行类中的和方法可以用于线程间的协作方法使当前线程进入等待状态方法唤醒在此对象监视器上等待的单个线程方法唤醒在此对象监视器上等待的所有线程生产者线程唤醒等待的线程消费者线程进入等待状态代码解释是一个用于同步的对象生产者和消费者线程都需要获取该对象的锁才能执行相应的操作消费者线程调用方法进入等待状态释放锁生产者线程执行完生产任务后调用方法唤醒等待的消费者线程包中的和接口提供了比更灵活的线程间通信方式接口的方法类似于方法方法类似于方法方法类似于方法生产者线程唤醒等待的线程消费者线程进入等待状态代码解释是接口的一个实现类是通过方法创建的消费者线程调用方法进入等待状态生产者线程执行完生产任务后调用方法唤醒等待的消费者线程包中的接口提供了线程安全的队列操作当队列满时插入元素的线程会被阻塞当队列为空时获取元素的线程会被阻塞生产者线程消费者线程代码解释是接口的一个实现类容量为生产者线程调用方法将元素插入队列如果队列已满线程会被阻塞消费者线程调用方法从队列中取出元素如果队列为空线程会被阻塞线程间通信方式有哪些类的和方法这是中最基础的线程间通信方式基于对象的监视器锁机制使当前线程进入等待状态直到其他线程调用该对象的或方法唤醒在此对象监视器上等待的单个线程唤醒在此对象监视器上等待的所有线程条件不满足执行相应操作执行相应操作或者和接口接口提供了比更灵活的锁机制接口则配合实现线程间的等待通知机制使当前线程进入等待状态直到被其他线程唤醒唤醒一个等待在该上的线程唤醒所有等待在该上的线程条件不满足执行相应操作执行相应操作或者关键字关键字用于保证变量的可见性即当一个变量被声明为时它会保证对该变量的写操作会立即刷新到主内存中而读操作会从主内存中读取最新的值等待执行相应操作是一个同步辅助类它允许一个或多个线程等待其他线程完成操作构造函数指定需要等待的线程数量减少计数器的值使当前线程等待直到计数器的值为执行任务完成任务所有线程任务完成是一个同步辅助类它允许一组线程相互等待直到所有线程都到达某个公共屏障点构造函数指定参与的线程数量和所有线程到达屏障点后要执行的操作使当前线程等待直到所有线程都到达屏障点所有线程都到达屏障点执行任务到达屏障点继续执行后续任务是一个计数信号量它可以控制同时访问特定资源的线程数量构造函数指定信号量的初始许可数量获取一个许可如果没有可用许可则阻塞释放一个许可获得许可执行任务释放许可如何停止一个线程在中停止线程的正确方式是通过协作式的逻辑控制线程终止而非强制暴力终止如已废弃的以下是实现安全停止线程的多种方法第一种方式通过共享标志位主动终止定义一个可见的状态变量由主线程控制其值工作线程循环检测该变量以决定是否退出使用保证可见性处理任务逻辑捕获中断异常后设置重新设置中断标志停止线程的方法由外部调用调用方式某个时刻调用停止第二种方式使用线程中断机制通过触发线程中断状态结合中断检测逻辑实现安全停止当阻塞时被中断抛出异常并清除中断状态重新设置中断标志调用方式中断线程不会立刻终止线程只是设置中断标志位线程需手动检查中断状态或触发可中断操作如响应中断阻塞操作中收到中断请求时会抛出并清除中断状态第三种方式通过取消任务使用线程池提交任务并通过停止线程依赖中断机制表示尝试中断任务线程第四种方式处理不可中断的阻塞操作某些或同步操作如无法通过中断直接响应此时需结合资源关闭操作比如关闭释放阻塞阻塞时无法响应中断处理连接特殊关闭方法销毁资源关闭资源使抛出异常调用方式调用方法关闭资源以解除阻塞线程停止的正确实践如下表格方法适用场景注意事项循环检测标志位简单无阻塞的逻辑确保标志位使用或通过锁保证可见性中断机制可中断的阻塞操作正确处理并恢复中断标志线程池管理任务需要线程池任务支持中断处理机制资源关闭不可中断的阻塞操作如显式关闭资源触发异常结合中断状态判断回滚避免使用以下已废弃方法暴力终止可能导致状态不一致易导致死锁并发包下你常用的类线程池相关最核心的线程池类用于创建和管理线程池通过它可以灵活地配置线程池的参数如核心线程数最大线程数任务队列等以满足不同的并发处理需求线程池工厂类提供了一系列静态方法来创建不同类型的线程池如创建固定线程数的线程池创建可缓存线程池创建单线程线程池等方便开发者快速创建线程池并发集合类线程安全的哈希映射表用于在多线程环境下高效地存储和访问键值对它采用了分段锁等技术允许多个线程同时访问不同的段提高了并发性能在高并发场景下比传统的性能更好线程安全的列表在对列表进行修改操作时会创建一个新的底层数组将修改操作应用到新数组上而读操作仍然可以在旧数组上进行从而实现了读写分离提高了并发读的性能适用于读多写少的场景同步工具类允许一个或多个线程等待其他一组线程完成操作后再继续执行它通过一个计数器来实现计数器初始化为线程的数量每个线程完成任务后调用方法将计数器减一当计数器为零时等待的线程可以继续执行常用于多个线程完成各自任务后再进行汇总或下一步操作的场景让一组线程互相等待直到所有线程都到达某个屏障点后再一起继续执行与不同的是可以重复使用当所有线程都通过屏障后计数器会重置可以再次用于下一轮的等待适用于多个线程需要协同工作在某个阶段完成后再一起进入下一个阶段的场景信号量用于控制同时访问某个资源的线程数量它维护了一个许可计数器线程在访问资源前需要获取许可如果有可用许可则获取成功并将许可计数器减一否则线程需要等待直到有其他线程释放许可常用于控制对有限资源的访问如数据库连接池线程池中的线程数量等原子类原子整数类提供了对整数类型的原子操作如自增自减比较并交换等通过硬件级别的原子指令来保证操作的原子性和线程安全性避免了使用锁带来的性能开销在多线程环境下对整数进行计数状态标记等操作非常方便原子引用类用于对对象引用进行原子操作可以保证在多线程环境下对对象的更新操作是原子性的即要么全部成功要么全部失败不会出现数据不一致的情况常用于实现无锁数据结构或需要对对象进行原子更新的场景怎么保证多线程安全关键字可以使用关键字来同步代码块或方法确保同一时刻只有一个线程可以访问这些代码对象锁是通过关键字锁定对象的监视器来实现的关键字关键字用于变量确保所有线程看到的是该变量的最新值而不是可能存储在本地寄存器中的副本接口和类接口提供了比更强大的锁定机制是一个实现该接口的例子提供了更灵活的锁管理和更高的性能原子类并发库提供了原子类如等这些类提供了原子操作可以用于更新基本类型的变量而无需额外的同步示例线程局部变量类可以为每个线程提供独立的变量副本这样每个线程都拥有自己的变量消除了竞争条件并发集合使用包中的线程安全集合如等这些集合内部已经实现了线程安全的逻辑工具类使用包中的一些工具类可以用于控制线程间的同步和协作例如和等中有哪些常用的锁在什么场景下使用中的锁是用于管理多线程并发访问共享资源的关键机制锁可以确保在任意给定时间内只有一个线程可以访问特定的资源从而避免数据竞争和不一致性提供了多种锁机制可以分为以下几类内置锁中的关键字是内置锁机制的基础可以用于方法或代码块当一个线程进入代码块或方法时它会获取关联对象的锁当线程离开该代码块或方法时锁会被释放如果其他线程尝试获取同一个对象的锁它们将被阻塞直到锁被释放其中加锁时有无锁偏向锁轻量级锁和重量级锁几个级别偏向锁用于当一个线程进入同步块时如果没有任何其他线程竞争就会使用偏向锁以减少锁的开销轻量级锁使用线程栈上的数据结构避免了操作系统级别的锁重量级锁则涉及操作系统级的互斥锁是一个显式的锁类提供了比更高级的功能如可中断的锁等待定时锁等待公平锁选项等使用和方法来获取和释放锁其中公平锁按照线程请求锁的顺序来分配锁保证了锁分配的公平性但可能增加锁的等待时间非公平锁不保证锁分配的顺序可以减少锁的竞争提高性能但可能造成某些线程的饥饿读写锁接口定义了一种锁允许多个读取者同时访问共享资源但只允许一个写入者读写锁通常用于读取远多于写入的情况以提高并发性乐观锁和悲观锁悲观锁通常指在访问数据前就锁定资源假设最坏的情况即数据很可能被其他线程修改和都是悲观锁的例子乐观锁通常不锁定资源而是在更新数据时检查数据是否已被其他线程修改乐观锁常使用版本号或时间戳来实现比如自旋锁自旋锁是一种锁机制线程在等待锁时会持续循环检查锁是否可用而不是放弃并阻塞通常可以使用来实现这在锁等待时间很短的情况下可以提高性能但过度自旋会浪费资源怎么在实践中用锁的提供了多种锁的实现包括关键字包下的接口及其具体实现如等下面我们来看看这些锁的使用方式关键字可以用于方法或代码块它是中最早的锁实现使用起来非常简单示例方法示例代码块使用接口接口提供了比更灵活的锁操作包括尝试锁可中断锁定时锁等是接口的一个实现示例使用使用接口提供了一种读写锁的实现允许多个读操作同时进行但写操作是独占的示例使用并发工具你知道哪些是一个同步辅助类它允许一个或多个线程等待其他线程完成操作它使用一个计数器进行初始化调用方法会使计数器减一当计数器的值减为时等待的线程会被唤醒可以把它想象成一个倒计时器当倒计时结束计数器为时等待的事件就会发生示例代码创建并启动三个工作线程正在工作模拟工作时间完成工作计数器减一完成工作主线程等待工作线程完成主线程等待直到计数器为所有工作线程已完成主线程继续执行允许一组线程互相等待直到到达一个公共的屏障点当所有线程都到达这个屏障点后它们可以继续执行后续操作并且这个屏障可以被重置循环使用与不同侧重于线程间的相互等待而不是等待某些操作完成示例代码所有线程都到达了屏障继续执行后续操作正在运行模拟运行时间等待其他线程已经通过屏障是一个计数信号量用于控制同时访问某个共享资源的线程数量通过方法获取许可使用方法释放许可如果没有许可可用线程将被阻塞直到有许可被释放可以用来限制对某些资源如数据库连接池文件操作等的并发访问量代码如下允许个线程同时访问获取许可获得了许可模拟资源使用释放了许可释放许可和是一个类似于的接口但它可以返回结果并且可以抛出异常用于表示一个异步计算的结果可以通过它来获取任务的执行结果或取消任务代码如下开始执行任务模拟耗时操作返回结果主线程继续执行其他任务等待任务完成并获取结果任务的结果是一个线程安全的哈希表它允许多个线程同时进行读操作在一定程度上支持并发的修改操作避免了在多线程环境下需要使用或进行同步的性能问题代码如下并发读操作并发写操作是做什么的讲一讲是并发包中的一个同步工具类用于让一个或多个线程等待其他线程完成操作后再继续执行其核心是通过一个计数器实现线程间的协调常用于多线程任务的分阶段控制或主线程等待多个子线程就绪的场景核心原理初始化计数器创建时指定一个初始计数值如等待线程阻塞调用的线程会被阻塞直到计数器变为任务完成通知其他线程完成任务后调用使计数器减唤醒等待线程当计数器减到时所有等待的线程会被唤醒主线程等待所有子线程就绪后启动代码例子如下主线程启动多个子线程执行任务等待全部完成后统计结果执行任务任务完成计数器主线程等待所有子线程完成任务所有任务已完成和及其应用场景工作原理是提供的原子性内置锁这种内置的并且使用者看不到的锁也被称为监视器锁使用之后会在编译之后在同步的代码块前后加上和字节码指令他依赖操作系统底层互斥锁实现他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题还有有序性会对代码进行重排导致输入和输出的顺序不一致这个时候使用内存屏障来进制重排执行指令时会尝试获取对象锁如果对象没有被锁定或者已经获得了锁锁的计数器此时其他竞争锁的线程则会进入等待队列中执行指令时则会把计数器当计数器值为时则锁释放处于等待队列中的线程再继续竞争锁是排它锁当一个线程获得锁之后其他线程必须等待该线程释放锁后才能获得锁而且由于中的线程和操作系统原生线程是一一对应的线程被阻塞或者唤醒时时会从用户态切换到内核态这种转换非常消耗性能从内存语义来说加锁的过程会清除工作内存中的共享变量再从主内存读取而释放锁的过程则是将工作内存中的共享变量写回主内存实际上大部分时候我认为说到就行了但是为了更清楚的描述还是再具体一点如果再深入到源码来说实际上有两个队列和池和锁池字当多个线程进入同步代码块时首先进入有一个线程获取到锁后就赋值给当前线程并且计数器如果线程调用方法将释放锁当前线程置为计数器同时进入等待被唤醒调用或者之后又会进入竞争锁如果线程执行完毕同样释放锁计数器当前线程置为或者是他进入了然后进入态然后如果的时候再进入工作原理的底层实现主要依赖于这个抽象类是一个提供了基本同步机制的框架其中包括了队列状态值等在的基础上通过内部类来实现具体的锁操作不同的子类实现了公平锁和非公平锁的不同逻辑可中断性实现了可中断性这意味着线程在等待锁的过程中可以被其他线程中断而提前结束等待在底层使用了与和相关的机制来实现可中断性设置超时时间支持在尝试获取锁时设置超时时间即等待一定时间后如果还未获得锁则放弃锁的获取这是通过内部的方法来实现的公平锁和非公平锁在直接创建对象时默认情况下是非公平锁公平锁是按照线程等待的顺序来获取锁而非公平锁则允许多个线程在同一时刻竞争锁不考虑它们申请锁的顺序公平锁可以通过在创建时传入来设置例如多个条件变量支持多个条件变量每个条件变量可以与一个关联这使得线程可以更灵活地进行等待和唤醒操作而不仅仅是基于对象监视器的和多个条件变量的实现依赖于接口例如使用下面方法进行等待和唤醒可重入性支持可重入性即同一个线程可以多次获得同一把锁而不会造成死锁这是通过内部的计数来实现的当一个线程多次获取锁时递增释放锁时递减只有当为零时其他线程才有机会获取锁应用场景的区别简单同步需求当你需要对代码块或方法进行简单的同步控制时是一个很好的选择它使用起来简单不需要额外的资源管理因为锁会在方法退出或代码块执行完毕后自动释放代码块同步如果你想对特定代码段进行同步而不是整个方法可以使用代码块这可以让你更精细地控制同步的范围从而减少锁的持有时间提高并发性能内置锁的使用关键字使用对象的内置锁也称为监视器锁这在需要使用对象作为锁对象的情况下很有用尤其是在对象状态与锁保护的代码紧密相关时高级锁功能需求提供了所不具备的高级功能如公平锁响应中断定时锁尝试以及多个条件变量当你需要这些功能时是更好的选择性能优化在高度竞争的环境中可以提供比更好的性能因为它提供了更细粒度的控制如尝试锁定和定时锁定可以减少线程阻塞的可能性复杂同步结构当你需要更复杂的同步结构如需要多个条件变量来协调线程之间的通信时及其配套的对象可以提供更灵活的解决方案综上适用于简单同步需求和不需要额外锁功能的场景而适用于需要更高级锁功能性能优化或复杂同步逻辑的情况选择哪种同步机制取决于具体的应用需求和性能考虑除了用还有什么方法可以实现线程同步使用类是一个可重入的互斥锁相比提供了更灵活的锁定和解锁操作它还支持公平锁和非公平锁以及可以响应中断的锁获取操作使用关键字虽然不是一种锁机制但它可以确保变量的可见性当一个变量被声明为后线程将直接从主内存中读取该变量的值这样就能保证线程间变量的可见性但它不具备原子性使用类提供了一系列的原子类例如等用于实现对单个变量的原子操作这些类在实现细节上利用了算法可以用来实现无锁的线程安全锁静态方法和普通方法区别锁的对象不同普通方法锁的是当前对象实例同一对象实例的普通方法同一时间只能被一个线程访问不同对象实例间互不影响可被不同线程同时访问各自的同步普通方法静态方法锁的是当前类的对象由于类的对象全局唯一无论多少个对象实例该静态同步方法同一时间只能被一个线程访问作用范围不同普通方法仅对同一对象实例的同步方法调用互斥不同对象实例的同步普通方法可并行执行静态方法对整个类的所有实例的该静态方法调用都互斥一个线程进入静态同步方法其他线程无法进入同一类任何实例的该方法多实例场景影响不同普通方法多线程访问不同对象实例的同步普通方法时可同时执行静态方法不管有多少对象实例同一时间仅一个线程能执行该静态同步方法和区别和都是中提供的可重入锁用法不同可用来修饰普通方法静态方法和代码块而只能用在代码块上获取锁和释放锁方式不同会自动加锁和释放锁当进入修饰的代码块之后会自动加锁当离开的代码段之后会自动释放锁而需要手动加锁和释放锁锁类型不同属于非公平锁而既可以是公平锁也可以是非公平锁响应中断不同可以响应中断解决死锁的问题而不能响应中断底层实现不同是层面通过监视器实现的而是基于实现的怎么理解可重入锁可重入锁是指同一个线程在获取了锁之后可以再次重复获取该锁而不会造成死锁或其他问题当一个线程持有锁时如果再次尝试获取该锁就会成功获取而不会被阻塞实现可重入锁的机制是基于线程持有锁的计数器当一个线程第一次获取锁时计数器会加表示该线程持有了锁在此之后如果同一个线程再次获取锁计数器会再次加每次线程成功获取锁时都会将计数器加当线程释放锁时计数器会相应地减只有当计数器减到时锁才会完全释放其他线程才有机会获取锁这种计数器的设计使得同一个线程可以多次获取同一个锁而不会造成死锁或其他问题每次获取锁时计数器加每次释放锁时计数器减只有当计数器减到时锁才会完全释放通过这种计数器的方式实现了可重入锁的机制它允许同一个线程多次获取同一个锁并且能够正确地处理锁的获取和释放避免了死锁和其他并发问题支持重入吗如何实现的是基于原子性的内部锁机制是可重入的因此在一个线程调用方法的同时在其方法体内部调用该对象另一个方法也就是说一个线程得到一个对象锁后再次请求该对象锁是允许的这就是的可重入性底层是利用计算机系统实现的每一个可重入锁都会关联一个线程和一个锁状态当一个线程请求方法时会去检查锁状态如果锁状态是代表该锁没有被占用使用操作获取锁将线程替换成自己的线程如果锁状态不是代表有线程在访问该方法此时如果线程是自己的线程如果是可重入锁会将自增然后获取到该锁进而执行相应的方法如果是非重入锁就会进入阻塞队列等待在释放锁时如果是可重入锁的每一次退出方法就会将减直至的值为最后释放该锁如果非可重入锁的线程退出方法直接就会释放该锁锁升级的过程讲一下在之前没有锁升级的时候的时候都一样的锁不足以应对不同时间的不同状态的并发操作具体的锁升级的过程是无锁偏向锁轻量级锁重量级锁无锁这是没有开启偏向锁的时候的状态在之后偏向锁的默认开启的但是有一个偏向延迟需要在启动之后的多少秒之后才能开启这个可以通过参数进行设置同时是否开启偏向锁也可以通过参数设置偏向锁这个是在偏向锁开启之后的锁的状态如果还没有一个线程拿到这个锁的话这个状态叫做匿名偏向当一个线程拿到偏向锁的时候下次想要竞争锁只需要拿线程跟当中存储的线程进行比较如果线程相同则直接获取锁相当于锁偏向于这个线程不需要进行操作和将线程挂起的操作适用于一个锁的时候轻量级锁在这个状态下线程主要是通过操作实现的将对象的存储到线程的虚拟机栈上然后通过将对象的的内容设置为指向的指针如果设置成功则获取锁在线程出临界区的时候也需要使用如果使用替换成功则同步成功如果失败表示有其他线程在获取锁那么就需要在释放锁之后将被挂起的线程唤醒一般就是两个线程取竞争锁他需要在这一直自旋去等待就是一直再循环执行直到抢到锁为止非常消耗重量级锁当有两个以上的线程获取锁的时候轻量级锁就会升级为重量级锁因为如果没有成功的话始终都在自旋进行循环操作这是非常消耗的但是在升级为重量级锁之后线程会被操作系统调度然后挂起这可以节约资源了解完种锁状态之后我们就可以整体的来看一下锁升级的过程了线程进入开始抢锁会判断当前是否是偏向锁的状态如果是就会根据中存储的线程来判断当前线程是否就是持有偏向锁的线程如果是则忽略线程直接执行临界区内的代码但如果里的线程不是线程就会通过自旋尝试获取锁如果获取到了就将中的线程改为自己的如果竞争失败就会立马撤销偏向锁膨胀为轻量级锁后续的竞争线程都会通过自旋来尝试获取锁如果自旋成功那么锁的状态仍然是轻量级锁然而如果竞争失败锁会膨胀为重量级锁后续等待的竞争的线程都会被阻塞线程阻塞与唤醒是操作系统层面的动作涉及线程调度需要进行线程上下文切换保存现场恢复现场线程状态变更因为从用户态转到内核态是非常消耗性能的所以只有重量级锁很多线程去竞争的时候才会使用一般的靠自旋解决就可以了对的优化核心优化方案主要包含以下个锁膨胀从无锁升级到偏向锁再到轻量级锁最后到重量级锁的过程它叫做锁膨胀也叫做锁升级之前是重量级锁也就是说在释放和获取锁时都会从用户态转换成内核态而转换的效率是比较低的但有了锁膨胀机制之后的状态就多了无锁偏向锁以及轻量级锁了这时候在进行并发操作时大部分的场景都不需要用户态到内核态的转换了这样就大幅的提升了的性能锁消除指的是在某些情况下虚拟机如果检测不到某段代码被共享和竞争的可能性就会将这段代码所属的同步锁消除掉从而到底提高程序性能的目的锁粗化将多个连续的加锁解锁操作连接在一起扩展成一个范围更大的锁自适应自旋锁指通过自身循环尝试获取锁的一种方式优点在于它避免一些线程的挂起和恢复操作因为挂起线程和恢复线程都需要从用户态转入内核态这个过程是比较慢的所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销介绍一下全称为是中的一个抽象类是一个用于构建锁同步器协作工具类的工具类框架核心思想是如果被请求的共享资源空闲那么就将当前请求资源的线程设置为有效的工作线程将共享资源设置为锁定状态如果共享资源被占用就需要一定的阻塞等待唤醒机制来保证锁分配这个机制主要用的是队列的变体实现的将暂时获取不到锁的线程加入到队列中队列是单向链表中的队列是变体的虚拟双向队列是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配主要原理图如下使用一个的类型的成员变量来表示同步状态通过内置的队列来完成资源获取的排队工作通过完成对值的修改广泛用于控制并发流程的类如下图其中是这些类中都有的内部类其结构如下可以看到是的实现主要完成的任务同步状态比如说计数器的原子性管理线程的阻塞和解除阻塞队列的管理原理最核心的就是三大部分状态控制线程抢锁和配合的队列双向链表期望协作工具类去实现的获取释放等重要方法重写状态这里的具体含义会根据具体实现类的不同而不同比如在里他表示剩余许可证的数量在里它表示还需要倒数的数量在中用来表示锁的占有情况包括可重入计数当的值为的时候标识该不被任何线程所占有是修饰的并被并发修改所以修改的方法都需要保证线程安全比如以及操作来读取和更新这个状态这些方法都依赖于类队列这个队列用来存放等待的线程就是排队管理器当多个线程争用同一把锁时必须有排队机制将那些没能拿到锁的线程串在一起当锁释放时锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁会维护一个等待的线程队列把线程都放到这个队列里这个队列是双向链表形式实现获取释放等方法这里的获取和释放方法是利用的协作工具类里最重要的方法是由协作类自己去实现的并且含义各不相同获取方法获取操作会以来变量经常会阻塞比如获取不到锁的时候在中获取就是方法作用是获取一个许可证而在里面获取就是方法作用是等待直到倒数结束释放方法在中释放就是方法作用是释放一个许可证在里面获取就是方法作用是将倒数的数减一需要每个实现类重写和等方法和有什么关系和两者的区别是一种乐观锁机制它包含三个操作数内存位置预期值和新值操作的逻辑是如果内存位置的值等于预期值则将其更新为新值否则不做任何操作整个过程是原子性的通常由硬件指令支持如在现代处理器上指令可以实现操作是一个用于构建锁和同步器的框架许多同步器如等都是基于构建的使用一个的整数变量来表示同步状态通过内置的队列来管理等待线程它提供了一些基本的操作如获取资源和释放资源这些操作会修改的值并根据的值来判断线程是否可以获取或释放资源的操作通常会先尝试获取资源如果失败线程将被添加到等待队列中并阻塞等待操作会释放资源并唤醒等待队列中的线程和两者的联系为提供原子操作支持内部使用操作来更新变量以实现线程安全的状态修改在操作中当线程尝试获取资源时会使用操作尝试将从一个值更新为另一个值如果更新失败说明资源已被占用线程会进入等待队列在操作中当线程释放资源时也会使用操作将恢复到相应的值以保证状态更新的原子性如何用实现一个可重入的公平锁实现一个可重入的公平锁的详细步骤继承创建一个内部类继承自重写等方法这些方法将用于实现锁的获取释放和判断锁是否被当前线程持有实现可重入逻辑在方法中检查当前线程是否已经持有锁如果是则增加锁的持有次数通过变量如果不是尝试使用操作来获取锁实现公平性在方法中按照队列顺序来获取锁即先检查等待队列中是否有线程在等待如果有当前线程必须进入队列等待而不是直接竞争锁创建锁的外部类创建一个外部类内部持有的子类对象并提供和方法这些方法将调用子类中的方法判断锁是否被当前线程持有尝试获取锁公平性检查检查队列中是否有前驱节点如果有则当前线程不能获取锁可重入逻辑如果是当前线程持有锁则增加持有次数尝试释放锁提供一个条件变量用于实现更复杂的同步需求这里只是简单实现加锁方法解锁方法判断当前线程是否持有锁提供一个条件变量用于实现更复杂的同步需求这里只是简单实现代码解释内部类使用方法检查当前锁是否被当前线程持有首先获取当前锁的状态如果为表示锁未被持有此时进行公平性检查通过检查是否有前驱节点在等待队列中如果没有使用尝试将状态设置为通常为并设置当前线程为锁的持有线程如果不为说明锁已被持有检查是否为当前线程持有如果是增加锁的持有次数可重入但要防止溢出先将状态减通常为检查当前线程是否为锁的持有线程如果不是抛出异常如果状态减为说明锁被完全释放将持有线程设为创建一个用于更复杂的同步操作如等待通知机制外部类方法调用尝试获取锁方法调用释放锁方法调用判断锁是否被当前线程持有方法调用提供条件变量作用原理具体里面存的是啥会有什么问题如何解决是中用于解决线程安全问题的一种机制它允许创建线程局部变量即每个线程都有自己独立的变量副本从而避免了线程间的资源共享和同步问题从内存结构图我们可以看到类中有个的成员变量内部维护了数组每个代表一个完整的对象是本身是的泛型对象值的作用线程隔离为每个线程提供了独立的变量副本这意味着线程之间不会相互影响可以安全地在多线程环境中使用这些变量而不必担心数据竞争或同步问题降低耦合度在同一个线程内的多个函数或组件之间使用可以减少参数的传递降低代码之间的耦合度使代码更加清晰和模块化性能优势由于避免了线程间的同步开销所以在大量线程并发执行时相比传统的锁机制它可以提供更好的性能的原理的实现依赖于类中的一个字段这是一个存储变量本身和对应值的映射每个线程都有自己的实例用于存储该线程所持有的所有变量的值当你创建一个变量时它实际上就是一个对象的实例每个对象都可以存储任意类型的值这个值对每个线程来说是独立的当调用的方法时会检查当前线程的中是否有与之关联的值如果有返回该值如果没有会调用方法如果重写了的话来初始化该值然后将其放入中并返回当调用方法时会将给定的值与当前线程关联起来即在当前线程的中存储一个键值对键是对象自身值是传入的值当调用方法时会从当前线程的中移除与该对象关联的条目可能存在的问题当一个线程结束时其也会随之销毁但是对象本身不会立即被垃圾回收直到没有其他引用指向它为止因此在使用时需要注意如果不显式调用方法或者线程结束时未正确清理变量可能会导致内存泄漏因为会持续持有变量的引用即使这些变量不再被其他地方引用因此实际应用中需要在使用完变量后调用方法释放资源悲观锁和乐观锁的区别乐观锁就像它的名字一样对于并发间操作产生的线程安全问题持乐观状态乐观锁认为竞争不总是会发生因此它不需要持有锁将比较替换这两个动作作为一个原子操作尝试去修改内存中的变量如果失败则表示发生冲突那么就应该有相应的重试逻辑悲观锁还是像它的名字一样对于并发间操作产生的线程安全问题持悲观状态悲观锁认为竞争总是会发生因此每次对某资源进行操作时都会持有一个独占的锁就像不管三七二十一直接上了锁就操作资源了中想实现一个乐观锁都有哪些方式操作是乐观锁的基础提供了包包含各种原子变量类如这些类使用操作实现了线程安全的原子操作可以用来实现乐观锁版本号控制增加一个版本号字段记录数据更新时候的版本每次更新时递增版本号在更新数据时同时比较版本号若当前版本号和更新前获取的版本号一致则更新成功否则失败时间戳使用时间戳记录数据的更新时间在更新数据时在比较时间戳如果当前时间戳大于数据的时间戳则说明数据已经被其他线程更新更新失败有什么缺点的缺点主要有点问题的问题指的是在更新的过程中当读取到的值是然后准备赋值的时候仍然是但是实际上有可能的值被改成了然后又被改回了这个更新的漏洞就叫做只是的问题大部分场景下都不影响并发的最终效果中有来解决这个问题他加入了预期标志和更新后标志两个字段更新时不光检查值还要检查当前的标志是否等于预期标志全部相等的话才会更新循环时间长开销大自旋的方式如果长时间不成功会给带来很大的开销只能保证一个共享变量的原子操作只对一个共享变量操作可以保证原子性但是多个则不行多个可以通过来处理或者使用锁实现为什么不能所有的锁都用操作是基于循环重试的机制如果操作一直未能成功线程会一直自旋重试占用资源在高并发情况下大量线程自旋会导致资源浪费有什么问题是怎么解决的会有的问题变量值在操作过程中先被其他线程从修改为又被改回无法感知中途变化导致操作误判为未变更比如线程读取变量为准备改为此时线程将变量线程的执行时发现仍是但状态已丢失中间变化提供的工具类会在操作中增加版本号或标记每次修改都更新版本号使得即使值相同也能识别变更历史比如可以用来解决问题通过比对值和版本号识别问题尝试修改值并更新版本号前提当前值且版本号才会更新为关键字有什么作用作用有个保证变量对所有线程的可见性当一个变量被声明为时它会保证对这个变量的写操作会立即刷新到主存中而对这个变量的读操作会直接从主存中读取从而确保了多线程环境下对该变量访问的可见性这意味着一个线程修改了变量的值其他线程能够立刻看到这个修改不会受到各自线程工作内存的影响禁止指令重排序优化关键字在中主要通过内存屏障来禁止特定类型的指令重排序写写屏障在对变量执行写操作之前会插入一个写屏障这确保了在该变量写操作之前的所有普通写操作都已完成防止了这些写操作被移到写操作之后读写屏障在对变量执行读操作之后会插入一个读屏障它确保了对变量的读操作之后的所有普通读操作都不会被提前到读之前执行保证了读取到的数据是最新的写读屏障这是最重要的一个屏障它发生在写之后和读之前这个屏障确保了写操作之前的所有内存操作包括写操作都不会被重排序到读之后同时也确保了读操作之后的所有内存操作包括读操作都不会被重排序到写之前指令重排序的原理是什么在执行程序时为了提高性能处理器和编译器常常会对指令进行重排序但是重排序要满足下面个条件才能进行在单线程环境下不能改变程序运行的结果存在数据依赖关系的不允许重排序所以重排序不会对单线程有影响只会破坏多线程的执行语义我们看这个例子和之间存在数据依赖关系同时和之间也存在数据依赖关系因此在最终执行的指令序列中不能被重排序到和的前面如果排到和的前面那么程序的结果将会被改变但和之间没有数据依赖关系编译器和处理器可以重排序和之间的执行顺序可以保证线程安全吗关键字可以保证可见性但不能保证原子性因此不能完全保证线程安全关键字用于修饰变量当一个线程修改了修饰的变量的值其他线程能够立即看到最新的值从而避免了线程之间的数据不一致但是并不能解决多线程并发下的复合操作问题比如这种操作不是原子操作如果多个线程同时对进行自增操作不能保证线程安全对于复合操作需要使用关键字或者来保证原子性和线程安全和比较解决了多线程访问共享资源时可能出现的竞态条件和数据不一致的问题保证了线程安全性解决了变量在多线程环境下的可见性和有序性问题确保了变量的修改对其他线程是可见的是一种排他性的同步机制保证了多个线程访问共享资源时的互斥性即同一时刻只允许一个线程访问共享资源通过对代码块或方法添加关键字来实现同步是一种轻量级的同步机制用来保证变量的可见性和禁止指令重排序当一个变量被声明为时线程在读取该变量时会直接从内存中读取而不会使用缓存同时对该变量的写操作会立即刷回主内存而不是缓存在本地内存中什么是公平锁和非公平锁公平锁指多个线程按照申请锁的顺序来获取锁线程直接进入队列中排队队列中的第一个线程才能获得锁公平锁的优点在于各个线程公平平等每个线程等待一段时间后都有执行的机会而它的缺点就在于整体执行速度更慢吞吐量更小非公平锁多个线程加锁时直接尝试获取锁能抢到锁到直接占有锁抢不到才会到等待队列的队尾等待非公平锁的优势就在于整体执行速度更快吞吐量更大但同时也可能产生线程饥饿问题也就是说如果一直有线程插队那么在等待队列中的线程可能长时间得不到运行非公平锁吞吐量为什么比公平锁大公平锁执行流程获取锁时先将线程自己添加到等待队列的队尾并休眠当某线程用完锁之后会去唤醒等待队列中队首的线程尝试去获取锁锁的使用顺序也就是队列中的先后顺序在整个过程中线程会从运行状态切换到休眠状态再从休眠状态恢复成运行状态但线程每次休眠和恢复都需要从用户态转换成内核态而这个状态的转换是比较慢的所以公平锁的执行速度会比较慢非公平锁执行流程当线程获取锁时会先通过尝试获取锁如果获取成功就直接拥有锁如果获取锁失败才会进入等待队列等待下次尝试获取锁这样做的好处是获取锁不用遵循先到先得的规则从而避免了线程休眠和恢复的操作这样就加速了程序的执行效率看出公平锁与非公平锁的方法唯一的区别就在于公平锁在获取锁时多了一个限制条件为这个方法就是判断在等待队列中是否已经有线程在排队了什么情况会产生死锁问题如何解决死锁只有同时满足以下四个条件才会发生互斥条件互斥条件是指多个线程不能同时使用同一个资源持有并等待条件持有并等待条件是指当线程已经持有了资源又想申请资源而资源已经被线程持有了所以线程就会处于等待状态但是线程在等待资源的同时并不会释放自己已经持有的资源不可剥夺条件不可剥夺条件是指当线程已经持有了资源在自己使用完之前不能被其他线程获取线程如果也想使用此资源则只能在线程使用完并释放后才能获取环路等待条件环路等待条件指的是在死锁发生的时候两个线程获取资源的顺序构成了环形链例如线程持有资源并试图获取资源而线程持有资源并试图获取资源此时两个线程相互等待对方释放资源从而导致死锁避免死锁问题就只需要破环其中一个条件就可以最常见的并且可行的就是使用资源有序分配法来破环环路等待条件那什么是资源有序分配法呢线程和线程获取资源的顺序要一样当线程是先尝试获取资源然后尝试获取资源的时候线程同样也是先尝试获取资源然后尝试获取资源也就是说线程和线程总是以相同的顺序申请自己想要的资源的类型和使用比较并交换是一种乐观锁技术广泛应用于并发编程中用来实现无锁算法它不通过传统的互斥锁来保证线程安全而是通过在操作共享数据前进行检查并在数据未被其他线程修改的情况下才执行更新被认为原子操作分为三个内存位置需要被更新的变量的内存地址预期原值线程希望该变量当前持有的值新值线程希望将变量更新成的值如果内存位置的值与预期原值相匹配那么处理器就会自动地将该位置的值更新为新值否则不做任何操作无论更新成功还是失败都会返回内存位置的最新值主要使用的是包下的原子类假设有一个共享的计数器多个线程同时调用内部使用实现原子性它会不断尝试读取当前值然后将当前值加作为新值再尝试用更新如果失败说明在它读取值之后有其他线程修改了它会重试直到成功为止自旋直到成功尝试设置新实例原子地更新一个对象引用时可以使用例如实现一个线程安全的单例模式但是存在问题一个变量初始值为线程读取到的值为在执行之前另一个线程将的值从改为然后又改回了此时再次执行操作发现的值仍然是认为没有被修改过于是成功地将更新为新值然而实际上已经被其他线程修改过对于某些场景问题可能导致逻辑上的错误例如在链表的头插法中如果头节点经历了的变化可能会成功但链表的结构可能已经被破坏我们可以引入时间戳和版本号或者是布尔标记来解决这个问题比如和引入了一个版本戳或时间戳每次修改变量时不仅更新值还更新版本戳操作时除了比较值还会比较版本戳引入了一个布尔标记表示对象是否被逻辑删除过场景多线程打印奇偶数怎么控制打印的顺序可以利用和来控制线程的执行顺序以下是一个基于这种方法的简单示例在上面的示例中通过一个共享的锁对象来控制两个线程的交替执行一个线程负责打印奇数另一个线程负责打印偶数通过和方法来在两个线程之间实现顺序控制当当前应该打印奇数时偶数线程会进入等待状态反之亦然个线程并发执行个线程等待这三个线程全部执行完在执行怎么实现创建个并发执行的线程在每个线程的任务结束时调用方法将计数器减创建第个线程使用方法等待计数器为即等待其他个线程完成任务创建一个初始计数为创建并启动个并发线程模拟线程执行任务任务完成后计数器减创建并启动第个线程等待其他个线程完成等待计数器为代码解释首先创建了一个对象并将其初始计数设置为然后使用循环创建并启动个线程每个线程会执行一些工作这里使用模拟在工作完成后会调用方法将的计数减最后创建第个线程这个线程在开始时调用方法它会阻塞直到的计数为即前面个线程都调用了方法一旦计数为该线程将继续执行后续任务单例模型既然已经用了为什么还要在加使用和一起可以创建一个既线程安全又能正确初始化的单例模式避免了多线程环境下的各种潜在问题这是一种比较完善的线程安全的单例模式实现方式尤其适用于高并发环境关键字的作用用于确保在多线程环境下只有一个线程能够进入同步块这里是在创建单例对象时通过保证了创建过程的线程安全性避免多个线程同时创建多个单例对象确保了对象引用的可见性和创建过程的有序性避免了由于指令重排序而导致的错误这行代码并不是一个原子操作它实际上可以分解为以下几个步骤分配内存空间实例化对象将对象引用赋值给由于内存模型允许编译器和处理器对指令进行重排序在没有的情况下可能会出现重排序例如先将对象引用赋值给但对象的实例化操作尚未完成这样其他线程在检查时会认为单例已经创建从而得到一个未完全初始化的对象导致错误可以保证变量的可见性和禁止指令重排序它确保对的修改对所有线程都是可见的并且保证了上述三个步骤按顺序执行避免了在单例创建过程中因指令重排序而导致的问题假设两个线程并发读写同一个整型变量初始值为零每个线程加次结果可能是什么在没有任何同步机制的情况下两个线程并发对同一个整型变量进行次加操作最终结果可能是也可能小于最坏的结果是也就是最终的结果可能是在小于情况的分析由于对整型变量的操作不是原子操作它实际上包含了三个步骤读取变量的值将值加将新值写回变量在多线程环境下可能会出现线程安全问题例如线程和线程同时读取了变量的当前值然后各自将其加最后都将相同的新值写回变量这就导致了一次加操作的丢失这种情况会多次发生最终结果就会小于最终结果第二种方式通过关键字或确保操作的互斥性代码如下最终结果',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-28 21:29:09',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 1.05rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 1.05rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 1.05rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>52</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>9</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>6</sup></a><a href="/tags/paper/" style="font-size: 1.05rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 1.05rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>3</sup></a><a href="/tags/rocketmq/" style="font-size: 1.05rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>2</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>13</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>19</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>17</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">17</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a><a class="article-meta__tags" href="/tags/juc/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>juc</span></a><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JUC-线程池面试题hot</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-28T13:29:09.428Z" title="更新于 2025-06-28 21:29:09">2025-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">27.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="JUC-线程池面试题hot"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=c7a8c787-9b70-567b-45ae-27be096b2bc6"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/05/22/java-stack/juc2/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><a href="/tags/juc/" tabindex="-1" itemprop="url">juc</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">JUC-线程池面试题hot</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-05-21T16:00:00.000Z" title="发表于 2025-05-22 00:00:00">2025-05-22</time><time itemprop="dateCreated datePublished" datetime="2025-06-28T13:29:09.428Z" title="更新于 2025-06-28 21:29:09">2025-06-28</time></header><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-线程池用过没有？-说说他的核心参数？"><a href="#1-线程池用过没有？-说说他的核心参数？" class="headerlink" title="1.线程池用过没有？ 说说他的核心参数？"></a>1.线程池用过没有？ 说说他的核心参数？</h2><p>线程在正常执行或者异常中断时会被销毁，如果频繁的创建很多线程，不仅会消耗系统资源，还会降低系统的稳定性，一不小心把系统搞崩了。</p>
<p>使用线程池可以带来以下几个好处：</p>
<ul>
<li>线程池内部的线程数是可控的，可以灵活的设置参数；</li>
<li>线程池内会保留部分线程，当提交新的任务可以直接运行；</li>
<li>方便内部线程资源的管理，调优和监控；</li>
</ul>
<p><strong>为了减少频繁的创建线程和销毁线程带来的性能损耗</strong></p>
<p>首先，所有任务的调度都是由<strong>execute</strong>方法完成的，这部分完成的工作是：检查现在线程池的<strong>运行状态、运行线程数、运行策略</strong>，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>
<p>首先检测线程池运行状态，如果不是<strong>RUNNING</strong>，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</p>
<p>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</p>
<p>如果workerCount &gt;= corePoolSize，且线程池内的<strong>阻塞队列</strong>未满，则将任务添加到该阻塞队列中。</p>
<p>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则<strong>创建并启动一个线程</strong>来执行新提交的任务。</p>
<p>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据<strong>拒绝策略</strong>来处理该任务, <strong>默认的处理方式是直接抛异常。</strong></p>
<p>七大核心参数：</p>
<p><strong>corePoolSize</strong>：线程池核心线程数量，如果设置为5，线程池初始化后默认保持5个线程待命。默认情况下，线程池中线程的数量如果 &lt;= corePoolSize，那么即使这些线程处于空闲状态，那也不会被销毁。</p>
<p><strong>maximumPoolSize</strong>：线程池允许的最大线程数。当任务队列已满，且当前线程数小于 <code>maximumPoolSize</code> 时，线程池会创建新的线程来处理任务，直至线程数达到 <code>maximumPoolSize</code>。</p>
<p><strong>keepAliveTime</strong>：当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过了keepAliveTime，那么这个线程就会被销毁。</p>
<p><strong>unit</strong>：就是keepAliveTime时间的单位。</p>
<p><strong>workQueue</strong>：工作队列。当没有空闲的线程执行新任务时，该任务就会被放入工作队列中，等待执行。</p>
<p><strong>threadFactory</strong>：用于创建线程的工厂。通过自定义线程工厂，你可以为线程设置名称、优先级等属性。</p>
<p><strong>handler</strong>：拒绝策略。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程，就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略</p>
<h2 id="2-线程池的拒绝策略"><a href="#2-线程池的拒绝策略" class="headerlink" title="2.线程池的拒绝策略"></a>2.线程池的拒绝策略</h2><p>常用的四种拒绝策略包括：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy，此外，还可以通过实现<strong>RejectedExecutionHandler</strong>接口来自定义拒绝策略。</p>
<p>CallerRunsPolicy，使用线程池的调用者所在的线程去执行被拒绝的任务，除非线程池被停止或者线程池的任务队列已有空缺。</p>
<p><strong>AbortPolicy，直接抛出一个任务被线程池拒绝的异常。</strong>这个是默认的</p>
<p>DiscardPolicy，不做任何处理，静默拒绝提交的任务。</p>
<p>DiscardOldestPolicy，抛弃最老的任务，然后执行该任务。</p>
<p>自定义拒绝策略，通过实现接口可以自定义任务拒绝策略。</p>
<p><strong>RejectedExecutionHandler实现</strong></p>
<h2 id="3-描述一下创建一个线程池，提交任务的过程"><a href="#3-描述一下创建一个线程池，提交任务的过程" class="headerlink" title="3.描述一下创建一个线程池，提交任务的过程"></a>3.描述一下创建一个线程池，提交任务的过程</h2><p>我们创建线程池的时候，需要使用到ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    corePoolSize,     <span class="comment">// 核心线程数</span></span><br><span class="line">    maximumPoolSize,  <span class="comment">// 最大线程数</span></span><br><span class="line">    keepAliveTime,    <span class="comment">// 非核心线程最大空闲存活时间</span></span><br><span class="line">    unit,             <span class="comment">// 时间单位</span></span><br><span class="line">    workQueue,        <span class="comment">// 阻塞队列（任务队列）</span></span><br><span class="line">    threadFactory,    <span class="comment">// 线程工厂（创建线程的策略）</span></span><br><span class="line">    handler           <span class="comment">// 拒绝策略</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提交任务的过程：</p>
<p>调用 <code>ThreadPoolExecutor.execute()</code> </p>
<p>判断线程数是否小于核心线程数</p>
<p>如果当前线程数 <strong>&lt; 核心线程数</strong>：</p>
<ul>
<li>直接创建线程执行任务（<strong>立刻执行，不入队列</strong>）</li>
</ul>
<p>核心线程已满 → 尝试将任务放入工作队列</p>
<p>如果核心线程都在运行，任务会尝试<strong>进入阻塞队列</strong>。</p>
<p>如果入队成功：</p>
<ul>
<li>等待空闲线程从队列中取任务执行</li>
</ul>
<p>如果入队失败（队列满了）：尝试创建非核心线程，如果线程数 &lt; 最大线程数，则创建非核心线程执行任务。</p>
<p>线程数也满了 → 启动拒绝策略</p>
<p>还包括一个addWorker()方法，是创建线程的核心方法</p>
<p>使用线程工厂创建线程</p>
<p>将线程封装为 <code>Worker</code> 对象</p>
<p>加入 <code>workers</code> 工作线程集合</p>
<p>启动线程并执行任务</p>
<p>每个工作线程在启动后会不断循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    task.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <code>getTask()</code> 从阻塞队列中获取任务。</p>
<p>核心线程：空闲时仍保留</p>
<p>非核心线程：如果超过 keepAliveTime 未获取到任务，则被销毁</p>
<h2 id="4-一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的"><a href="#4-一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的" class="headerlink" title="4.一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的"></a>4.一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的</h2><p>如果<strong>线程池仍然存活</strong>，此时<strong>再提交一个任务的过程</strong>，与最初提交任务时几乎相同，但会受到<strong>已有线程空闲可复用</strong>的影响.</p>
<p>线程池中已有线程执行完任务，进入<strong>空闲状态</strong>；</p>
<p>此时再次提交一个新任务。</p>
<p>依旧会执行 <code>ThreadPoolExecutor.execute(Runnable command)</code></p>
<p>检查是否需要创建新线程,一般是当前线程数已达到核心线程数；上一个任务刚执行完，线程处于空闲状态；</p>
<p>尝试将任务加入队列，如果线程池使用的是有界队列（LinkedBlockingQueue）任务直接入队；<strong>等待空闲线程来取任务执行</strong>，不再新建线程。</p>
<p>如果是 <code>SynchronousQueue</code>，进行下一步</p>
<p>是否需要创建非核心线程，，如果队列失败，线程数尚未超过最大线程数：，创建线程执行任务（非核心线程）</p>
<p>否则，进入拒绝策略，队列满、线程也满 → 拒绝任务</p>
<p>Woker循环</p>
<p>会尝试从队列中获取下一个任务；</p>
<p>如果任务队列中有新任务：</p>
<ul>
<li>该线程<strong>继续执行新任务</strong>；</li>
</ul>
<p>如果队列无任务：</p>
<ul>
<li>核心线程：一直等待；</li>
<li>非核心线程：空闲超过 <code>keepAliveTime</code> 会销毁。</li>
</ul>
<p>如果线程池被 shutdown，则 <code>execute()</code> 会拒绝任务；</p>
<h2 id="5-执行完第二个任务后，线程池里面还会有几个线程"><a href="#5-执行完第二个任务后，线程池里面还会有几个线程" class="headerlink" title="5.执行完第二个任务后，线程池里面还会有几个线程"></a>5.执行完第二个任务后，线程池里面还会有几个线程</h2><p>一般情况（默认配置、核心线程不回收）：</p>
<ul>
<li><strong>执行两个任务后，线程池中会保留两个核心线程</strong>。</li>
</ul>
<p>若用非核心线程、任务执行完后等待空闲：</p>
<ul>
<li>执行完立即：线程池中还有 2 个线程（核心 + 非核心）；</li>
<li>超过 <code>keepAliveTime</code> 后：只剩下核心线程；</li>
</ul>
<h2 id="6-有线程池参数设置的经验吗？"><a href="#6-有线程池参数设置的经验吗？" class="headerlink" title="6.有线程池参数设置的经验吗？"></a>6.有线程池参数设置的经验吗？</h2><p>核心线程数（corePoolSize）设置的经验：</p>
<ul>
<li>CPU密集型：corePoolSize = CPU核数 + 1（避免过多线程竞争CPU）</li>
<li>IO密集型：corePoolSize = CPU核数 x 2（或更高，具体看IO等待时间）</li>
</ul>
<p>场景一：电商场景，<strong>特点瞬时高并发、任务处理时间短</strong>，线程池的配置可设置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                     <span class="comment">// corePoolSize = 16（假设8核CPU × 2）</span></span><br><span class="line">    <span class="number">32</span>,                     <span class="comment">// maximumPoolSize = 32（突发流量扩容）</span></span><br><span class="line">    <span class="number">10</span>, TimeUnit.SECONDS,   <span class="comment">// 非核心线程空闲10秒回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), <span class="comment">// 不缓存任务，直接扩容线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>()       <span class="comment">// 直接拒绝，避免系统过载</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>使用<code>SynchronousQueue</code><strong>确保任务直达线程，避免队列延迟</strong>。</li>
<li>拒绝策略快速失败，前端返回“活动火爆”提示，结合降级策略（如缓存预热）。</li>
</ul>
<p>场景二：后台数据处理服务，特点稳定流量、任务处理时间长（秒级）、允许一定延迟，线程池的配置可设置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>,                      <span class="comment">// corePoolSize = 8（8核CPU）</span></span><br><span class="line">    <span class="number">8</span>,                      <span class="comment">// maximumPoolSize = 8（禁止扩容，避免资源耗尽）</span></span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS,    <span class="comment">// 不回收线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="comment">// 有界队列，容量1000</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CallerRunsPolicy</span>()  <span class="comment">// 队列满后由调用线程执行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>固定线程数避免资源波动，队列缓冲任务，拒绝策略兜底。</li>
<li>配合监控告警（如队列使用率&gt;80%触发扩容）。</li>
</ul>
<p>场景三：微服务HTTP请求处理，特点IO密集型、依赖下游服务响应时间，线程池的配置可设置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                     <span class="comment">// corePoolSize = 16（8核 × 2）</span></span><br><span class="line">    <span class="number">64</span>,                     <span class="comment">// maximumPoolSize = 64（应对慢下游）</span></span><br><span class="line">    <span class="number">60</span>, TimeUnit.SECONDS,   <span class="comment">// 非核心线程空闲60秒回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">200</span>), <span class="comment">// 有界队列容量200</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRetryPolicy</span>() <span class="comment">// 自定义拒绝策略（重试或降级）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>根据下游RT（响应时间）调整线程数，队列防止瞬时峰值。</li>
<li>自定义拒绝策略将任务暂存Redis，异步重试。</li>
</ul>
<h2 id="7-核心线程数设置为0可不可以？"><a href="#7-核心线程数设置为0可不可以？" class="headerlink" title="7.核心线程数设置为0可不可以？"></a>7.<strong>核心线程数设置为0可不可以？</strong></h2><p>可以，当核心线程数为0的时候，会创建一个非核心线程进行执行。</p>
<p>从下面的源码也可以看到，当核心线程数为 0 时，来了一个任务之后，会先将任务添加到任务队列，同时也会判断当前工作的线程数是否为 0，如果为 0，则会创建线程来执行线程池的任务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240820113849549.png" alt="image-20240820113849549"></p>
<h2 id="8-线程池种类有哪些？"><a href="#8-线程池种类有哪些？" class="headerlink" title="8.线程池种类有哪些？"></a>8.线程池种类有哪些？</h2><ul>
<li><strong>ScheduledThreadPool</strong>：可以<strong>设置定期的执行任务</strong>，它支持定时或周期性执行任务，比如每隔 10 秒钟执行一次任务，我通过这个实现类设置定期执行任务的策略。</li>
<li>FixedThreadPool：它的<strong>核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池</strong>，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</li>
<li>CachedThreadPool：可以称作<strong>可缓存线程池</strong>，<strong>它的特点在于线程数是几乎可以无限增加</strong>的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</li>
<li>SingleThreadExecutor：它会<strong>使用唯一的线程去执行任务</strong>，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，<strong>所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景</strong>，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</li>
<li>SingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。</li>
</ul>
<h2 id="9-线程池一般是怎么用的？"><a href="#9-线程池一般是怎么用的？" class="headerlink" title="9.线程池一般是怎么用的？"></a>9.线程池一般是怎么用的？</h2><p>Java 中的 Executors 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，<strong>而应该手动 new ThreadPoolExecutor 来创建线程池。</strong>这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 newFixedThreadPool 和 newCachedThreadPool，可能因为资源耗尽导致 OOM 问题。</p>
<p>所以，不建议使用 Executors 提供的两种快捷的线程池，原因如下：</p>
<ul>
<li>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。</li>
<li>任何时候，都应该为<strong>自定义线程池指定有意义的名称</strong>，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。</li>
</ul>
<p>除了建议手动声明线程池以外，我还建议用<strong>一些监控手段来观察线程池的状态</strong>。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p>
<h2 id="10-线程池中shutdown-，shutdownNow-这两个方法有什么作用？"><a href="#10-线程池中shutdown-，shutdownNow-这两个方法有什么作用？" class="headerlink" title="10.线程池中shutdown ()，shutdownNow()这两个方法有什么作用？"></a>10.线程池中shutdown ()，shutdownNow()这两个方法有什么作用？</h2><p>从下面的源码【高亮】注释可以很清晰的看出两者的区别：</p>
<ul>
<li>shutdown<strong>使用了以后会置状态为SHUTDOWN</strong>，正在执行的任务会继续执行下去，没有被执行的则中断。<strong>此时，则不能再往线程池中添加任何任务，否则将会抛出 RejectedExecutionException 异常</strong> 比较平缓的关闭方式</li>
<li>而 shutdownNow <strong>为STOP，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。</strong> 它试图终止线程的方法是通过调用 <strong>Thread.interrupt() 方法来实现的，</strong>但是这种方法的作用有限，<strong>如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。</strong>所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。</li>
</ul>
<p><strong>shutdown 源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">	mainLock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		checkShutdownAccess();</span><br><span class="line">		<span class="comment">// 高亮</span></span><br><span class="line">		advanceRunState(SHUTDOWN);</span><br><span class="line">		interruptIdleWorkers();</span><br><span class="line">		onShutdown();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		mainLock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>shutdownNow 源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">	List&lt;Runnable&gt; tasks;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">	mainLock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		checkShutdownAccess();</span><br><span class="line">		<span class="comment">// 高亮</span></span><br><span class="line">		advanceRunState(STOP);</span><br><span class="line">		interruptWorkers();</span><br><span class="line">		<span class="comment">// 高亮</span></span><br><span class="line">		tasks = drainQueue();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		mainLock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	tryTerminate();</span><br><span class="line">	<span class="comment">// 高亮</span></span><br><span class="line">	<span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-提交给线程池中的任务可以被撤回吗？"><a href="#11-提交给线程池中的任务可以被撤回吗？" class="headerlink" title="11.提交给线程池中的任务可以被撤回吗？"></a>11.提交给线程池中的任务可以被撤回吗？</h2><p>可以，当向线程池提交任务时，<strong>会得到一个<code>Future</code>对象。这个<code>Future</code>对象提供了几种方法来管理任务的执行，包括取消任务。</strong></p>
<p>取消任务的主要方法是<code>Future</code>接口中的<code>cancel(boolean mayInterruptIfRunning)</code>方法。这个方法尝试取消执行的任务。<strong>参数<code>mayInterruptIfRunning</code>指示是否允许中断正在执行的任务</strong>。如果设置为<code>true</code>，则表示如果任务已经开始执行，那么允许中断任务；如果设置为<code>false</code>，任务已经开始执行则不会被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 是否取消线程的执行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 线程是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//线程是否执行完毕</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">// 立即获得线程返回的结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">      <span class="comment">// 延时时间后再获得线程返回的结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消线程池中任务的方式，代码如下，通过 future 对象的 cancel(boolean) 函数来定向取消特定的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> service.submit(<span class="keyword">new</span> <span class="title class_">TheradDemo</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 可能抛出异常</span></span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//终止任务的执行</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-Java-中为什么要使用线程池？线程池如何处理异常"><a href="#12-Java-中为什么要使用线程池？线程池如何处理异常" class="headerlink" title="12.Java 中为什么要使用线程池？线程池如何处理异常"></a>12.Java 中为什么要使用线程池？线程池如何处理异常</h2><p><strong>线程池的核心优势系统化梳理</strong>：</p>
<ul>
<li><strong>资源复用</strong>：避免频繁创建销毁线程（创建线程耗时约 3ms，复用可降低开销）；</li>
<li><strong>控制并发数</strong>：防止并发过高导致的 OOM（如秒杀场景限制线程数保护数据库）；</li>
<li><strong>统一管理</strong>：统一设置线程名称、优先级，方便日志追踪和故障排查；</li>
<li><strong>异步处理</strong>：将耗时任务放入线程池，避免主线程阻塞（如日志异步写入）。</li>
</ul>
<p>比较单线程，多线程，和线程池</p>
<p>异常处理：</p>
<p>使用<code>try-catch</code>包裹任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doTask();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;任务异常&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过<code>Future</code>获取异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    future.get(); <span class="comment">// 阻塞获取结果，抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;任务异常&quot;</span>, e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拒绝策略<code>AbortPolicy</code>会抛出<code>RejectedExecutionException</code>，需在提交任务时捕获：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    executor.execute(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;任务被拒绝&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景：</p>
<ul>
<li><strong>电商下单场景</strong>：<br>用线程池异步处理库存扣减、积分计算等耗时任务，主线程快速返回订单创建结果，提升用户体验；</li>
<li><strong>日志系统</strong>：<br>用线程池异步写入日志到 Kafka，避免 IO 阻塞影响业务接口响应时间。</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-java里面的线程和操作系统的线程一样吗？"><a href="#1-java里面的线程和操作系统的线程一样吗？" class="headerlink" title="1.java里面的线程和操作系统的线程一样吗？"></a>1.java里面的线程和操作系统的线程一样吗？</h2><p>Java 底层会调用 pthread_create 来创建线程，所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。</p>
<h2 id="2-使用多线程要注意哪些问题？"><a href="#2-使用多线程要注意哪些问题？" class="headerlink" title="2.使用多线程要注意哪些问题？"></a>2.使用多线程要注意哪些问题？</h2><p>要保证多线程的程序是安全，不要出现数据竞争造成的数据混乱的问题。</p>
<p>Java的线程安全在三个方面体现：</p>
<ul>
<li><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了<strong>atomic</strong>包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和synchronized关键字来确保原子性；比如CAS</li>
<li><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了<strong>synchronized和volatile</strong>这两个关键字确保可见性；</li>
<li><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。比如volatile</li>
</ul>
<h2 id="3-保证数据的一致性有哪些方案呢？"><a href="#3-保证数据的一致性有哪些方案呢？" class="headerlink" title="3.保证数据的一致性有哪些方案呢？"></a>3.保证数据的一致性有哪些方案呢？</h2><ul>
<li><strong>事务管理</strong>：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。</li>
<li><strong>锁机制</strong>：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。</li>
<li><strong>版本控制</strong>：通过乐观锁的方式，在<strong>更新数据时记录数据的版本信息</strong>，从而避免同时对同一数据进行修改，进而保证数据的一致性。</li>
</ul>
<h2 id="4-线程的创建方式有哪些"><a href="#4-线程的创建方式有哪些" class="headerlink" title="4.线程的创建方式有哪些?"></a>4.线程的创建方式有哪些?</h2><blockquote>
<p>1.继承Thread类</p>
</blockquote>
<p>这是最直接的一种方式，用户自定义类继承java.lang.Thread类，<strong>重写其run()方法</strong>，run()方法中定义了线程执行的具体任务。创建该类的实例后，通过调用start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用继承Thread类方式</p>
<ul>
<li>优点: 编写简单，如果需要访问当前线程，无需使用Thread.currentThread ()方法，直接使用this，即可获得当前线程</li>
<li>缺点:因为线程类已经<strong>继承了Thread类，所以不能再继承其他的父类</strong></li>
</ul>
<blockquote>
<p>2.实现Runnable接口</p>
</blockquote>
<p>如果一个类已经继承了其他类，就不能再继承Thread类，此时可以实现java.lang.Runnable接口。<strong>实现Runnable接口需要重写run()方法</strong>，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其start()方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用实现Runnable接口方式：</p>
<ul>
<li>优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>缺点：<strong>编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</strong></li>
</ul>
<blockquote>
<ol>
<li>实现Callable接口与FutureTask</li>
</ol>
</blockquote>
<p>java.util.concurrent.Callable接口类似于Runnable，<strong>但Callable的call()方法可以有返回值并且可以抛出异常。</strong>要执行Callable任务，需将它包装进一个<strong>FutureTask</strong>，因为Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码，这里返回一个整型结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();  <span class="comment">// 获取线程执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用实现Callable接口方式：</p>
<ul>
<li>缺点：编程稍微复杂，如果需要访问当前线程，<strong>必须调用Thread.currentThread()方法。</strong></li>
<li>优点：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</li>
</ul>
<blockquote>
<ol>
<li>使用线程池（Executor框架）</li>
</ol>
</blockquote>
<p>从Java 5开始引入的java.util.concurrent.ExecutorService和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过<strong>Executors</strong>类的静态方法创建不同类型的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);  <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());  <span class="comment">// 提交任务到线程池执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();  <span class="comment">// 关闭线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用线程池方式：</p>
<ul>
<li>缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。<strong>错误的配置可能导致死锁、资源耗尽等问题</strong>，这些问题的诊断和修复可能较为复杂。</li>
<li>优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。</li>
</ul>
<p>Exectors提供的三个线程池不好使，要实际应该还是应该自己设计一个线程池</p>
<h2 id="5-怎么启动线程-？"><a href="#5-怎么启动线程-？" class="headerlink" title="5.怎么启动线程 ？"></a>5.怎么启动线程 ？</h2><p>启动线程的通过Thread类的<strong>start()</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个线程，用start启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();  </span><br></pre></td></tr></table></figure>
<p>新建线程调用<strong>start()方法后</strong>，线程并不会立即进入运行状态。线程的状态变化是：<strong>新建→就绪→运行</strong>。调用start()方法后，线程会进入就绪状态，等待CPU调度才能进入运行状态。这取决于线程调度器的调度策略。start()方法会<strong>创建新的线程并执行run()方法</strong>，而直接调用run()方法只会在<strong>当前线程中执行</strong>，不会启动新线程。</p>
<h2 id="6-如何停止一个线程的运行"><a href="#6-如何停止一个线程的运行" class="headerlink" title="6.如何停止一个线程的运行?"></a>6.如何停止一个线程的运行?</h2><p>主要有这些方法：</p>
<ul>
<li><strong>异常法停止</strong>：<strong>线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态</strong>，如果是中断状态则抛出异常，达到中断线程的效果。</li>
<li><strong>在沉睡中停止</strong>：先将<strong>线程sleep</strong>，然后<strong>调用interrupt标记中断状态</strong>，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果</li>
<li><strong>stop()暴力停止</strong>：线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些请理性的工作得不到完成。可以使用shutdown方法</li>
<li><strong>使用return停止线程</strong>：<strong>调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return</strong>，能达到停止线程的效果。</li>
</ul>
<h2 id="7-调用-interrupt-是如何让线程抛出异常的"><a href="#7-调用-interrupt-是如何让线程抛出异常的" class="headerlink" title="7.调用 interrupt 是如何让线程抛出异常的?"></a>7.调用 interrupt 是如何让线程抛出异常的?</h2><p>每个线程都一个与之关联的布尔属性来表示其中断状态，<strong>中断状态的初始值为false</strong>，当一个线程被其它线程调用<code>Thread.interrupt()</code>方法中断时，会根据实际情况做出响应。</p>
<ul>
<li>如果该线程正在执行低级别的可中断方法（如<code>Thread.sleep()</code>、<code>Thread.join()</code>或<code>Object.wait()</code>），则会<strong>解除阻塞</strong>并<strong>抛出<code>InterruptedException</code>异常</strong>。</li>
<li>否则<code>Thread.interrupt()</code>仅设置线程的中断状态，<strong>在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20250422/59_1745314586904/AB85F6C1A80F74538F959A181704EA92" alt=""></p>
<h2 id="8-Java线程的状态有哪些？"><a href="#8-Java线程的状态有哪些？" class="headerlink" title="8.Java线程的状态有哪些？"></a>8.Java线程的状态有哪些？</h2><div class="table-container">
<table>
<thead>
<tr>
<th>线程状态</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>尚未启动的线程状态，即线程创建，<strong>还未调用start方法</strong></td>
</tr>
<tr>
<td>RUNNABLE</td>
<td><strong>就绪状态</strong>（调用start，等待调度）+<strong>正在运行</strong></td>
</tr>
<tr>
<td>BLOCKED</td>
<td><strong>等待监视器锁</strong>时，陷入阻塞状态</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态的线程正在<strong>等待</strong>另一线程执行特定的操作（如notify）</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>具有<strong>指定等待时间</strong>的等待状态</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>线程完成执行，<strong>终止状态</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="9-sleep-和-wait的区别是什么？"><a href="#9-sleep-和-wait的区别是什么？" class="headerlink" title="9.sleep 和 wait的区别是什么？"></a>9.sleep 和 wait的区别是什么？</h2><p>对比例表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>sleep()</code></th>
<th><code>wait()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>所属类</td>
<td><code>Thread</code> 类（静态方法）</td>
<td><code>Object</code> 类（实例方法）</td>
</tr>
<tr>
<td>锁释放</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>使用前提</td>
<td>任意位置调用</td>
<td>必须在同步块内（持有锁）</td>
</tr>
<tr>
<td>唤醒机制</td>
<td>超时自动恢复</td>
<td>需 <code>notify()</code>/<code>notifyAll()</code> 或超时</td>
</tr>
<tr>
<td>设计用途</td>
<td>暂停线程执行，不涉及锁协作</td>
<td>线程间协调，释放锁让其他线程工作</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>所属分类的不同</strong>：sleep 是 <code>Thread</code> 类的静态方法，可以在任何地方直接通过 <code>Thread.sleep()</code> 调用，无需依赖对象实例。wait 是 <code>Object</code> 类的实例方法，这意味着必须通过对象实例来调用。</li>
<li><strong>锁释放的情况</strong>：<code>Thread.sleep()</code> 在调用时，线程会暂停执行指定的时间，但不会释放持有的对象锁。也就是说，在 <code>sleep</code> 期间，其他线程无法获得该线程持有的锁。<code>Object.wait()</code>：调用该方法时，<strong>线程会释放持有的对象锁，进入等待状态，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它</strong></li>
<li><strong>使用条件</strong>：sleep 可在任意位置调用，无需事先获取锁。 <strong>wait 必须在同步块或同步方法内调用（即线程需持有该对象的锁），否则抛出 <code>IllegalMonitorStateException</code>。</strong></li>
<li><strong>唤醒机制</strong>：sleep 休眠时间结束后，线程 自动恢复 到就绪状态，等待CPU调度。wait 需要其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法才能被唤醒。<code>notify()</code> 会随机唤醒一个在该对象上等待的线程，而 <code>notifyAll()</code> 会唤醒所有在该对象上等待的线程。</li>
</ul>
<h2 id="10-sleep会释放cpu吗？"><a href="#10-sleep会释放cpu吗？" class="headerlink" title="10.sleep会释放cpu吗？"></a>10.sleep会释放cpu吗？</h2><p>是的，调用 <code>Thread.sleep()</code> 时，线程会释放 CPU，但不会释放持有的锁。</p>
<p><strong>当线程调用</strong> <code>sleep()</code> <strong>后，会主动让出 CPU 时间片</strong>，进入 <code>TIMED_WAITING</code> 状态。此时操作系统会触发调度，将 CPU 分配给其他处于就绪状态的线程。这样其他线程（无论是需要同一锁的线程还是不相关线程）便有机会执行。</p>
<p><code>sleep()</code> <strong>不会释放线程已持有的任何锁</strong>（如 <code>synchronized</code> 同步代码块或方法中获取的锁）。因此，如果有其他线程试图获取同一把锁，它们仍会被阻塞，直到原线程退出同步代码块。</p>
<h2 id="11-blocked和waiting有啥区别"><a href="#11-blocked和waiting有啥区别" class="headerlink" title="11.blocked和waiting有啥区别"></a>11.blocked和waiting有啥区别</h2><p>区别如下：</p>
<ul>
<li><strong>触发条件</strong>:线程进入BLOCKED状态通常是<strong>因为试图获取一个对象的锁（monitor lock），但该锁已经被另一个线程持有。</strong>这通常发生在尝试进入synchronized块或方法时，如果锁已被占用，则线程将被阻塞直到锁可用。<strong>线程进入WAITING状态是因为它正在等待另一个线程执行某些操作</strong>，例如调用Object.wait()方法、Thread.join()方法或LockSupport.park()方法。在这种状态下，<strong>线程将不会消耗CPU资源，并且不会参与锁的竞争。</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/93a0d1531ea1271770686b9e91664a9c.png" alt="img"></p>
<ul>
<li><strong>唤醒机制</strong>:当一个线程被阻塞等待锁时，<strong>一旦锁被释放，线程将有机会重新尝试获取锁</strong>。如果锁此时未被其他线程获取，那么线程可以从BLOCKED状态变为RUNNABLE状态。线程在<strong>WAITING状态中需要被显式唤醒</strong>。例如，如果线程调用了Object.wait()，那么它必须等待另一个线程调用同一对象上的Object.notify()或Object.notifyAll()方法才能被唤醒。</li>
</ul>
<p>所以，BLOCKED和WAITING两个状态最大的区别有两个：</p>
<ul>
<li>BLOCKED是<strong>锁竞争失败后被被动触发的状态，WAITING是人为的主动触发的状态</strong></li>
<li>BLCKED的<strong>唤醒时自动触发</strong>的，而WAITING状态是必须要通过特定的方法来主动唤醒</li>
</ul>
<h2 id="12-wait-状态下的线程如何进行恢复到-running-状态"><a href="#12-wait-状态下的线程如何进行恢复到-running-状态" class="headerlink" title="12.wait 状态下的线程如何进行恢复到 running 状态?"></a>12.wait 状态下的线程如何进行恢复到 running 状态?</h2><p>程从 <code>等待（WAIT）</code> 状态恢复到 <code>运行（RUNNING）</code> 状态的核心机制是 <strong>通过外部事件触发或资源可用性变化</strong>，比如等待的线程<strong>被其他线程对象唤醒</strong>，<code>notify()</code>和<code>notifyAll()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 线程进入等待状态，释放锁</span></span><br><span class="line">    lock.wait(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他线程调用以下代码唤醒等待线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.notify();      <span class="comment">// 唤醒单个线程</span></span><br><span class="line">    <span class="comment">// lock.notifyAll(); // 唤醒所有等待线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-notify-和-notifyAll-的区别"><a href="#13-notify-和-notifyAll-的区别" class="headerlink" title="13.notify 和 notifyAll 的区别?"></a>13.notify 和 notifyAll 的区别?</h2><p>同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制哪个线程获得锁。</p>
<p>区别在于：</p>
<ul>
<li>notify：<strong>唤醒一个线程</strong>，其他线程依然处于wait的等待唤醒状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断</li>
<li>notifyAll：所有线程退出wait的状态，<strong>开始竞争锁</strong>，<strong>但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁</strong></li>
</ul>
<h2 id="14-notify-选择哪个线程"><a href="#14-notify-选择哪个线程" class="headerlink" title="14.notify 选择哪个线程?"></a>14.notify 选择哪个线程?</h2><p>notify在源码的注释中说到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240725230457096.png" alt="image-20240725230457096"></p>
<p>JVM有很多实现，比较流行的就是<strong>hotspot</strong>，hotspot对notofy()的实现并不是我们以为的随机唤醒,，<strong>而是“先进先出”的顺序唤醒。</strong></p>
<h2 id="15-不同的线程之间如何通信？"><a href="#15-不同的线程之间如何通信？" class="headerlink" title="15.不同的线程之间如何通信？"></a>15.不同的线程之间如何通信？</h2><p><strong>共享变量</strong>是最基本的线程间通信方式。多个线程可以访问和修改同一个共享变量，从而实现信息的传递。为了保证线程安全，通常需要使用 <code>synchronized</code> 关键字或 <code>volatile</code> 关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 关键字保证变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改共享变量</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Producer: Flag is set to true.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="comment">// 等待共享变量被修改</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer: Flag is now true.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释</p>
<ul>
<li><code>volatile</code> 关键字确保了 <code>flag</code> 变量在多个线程之间的可见性，即一个线程修改了 <code>flag</code> 的值，其他线程能立即看到。</li>
<li>生产者线程在睡眠 2 秒后将 <code>flag</code> 设置为 <code>true</code>，消费者线程在 <code>flag</code> 为 <code>false</code> 时一直等待，直到 <code>flag</code> 变为 <code>true</code> 才继续执行。</li>
</ul>
<p><strong><code>Object</code> 类中的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法可以用于线程间的协作</strong>。<code>wait()</code> 方法使当前线程进入等待状态，<code>notify()</code> 方法唤醒在此对象监视器上等待的单个线程，<code>notifyAll()</code> 方法唤醒在此对象监视器上等待的所有线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producer: Producing...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producer: Production finished. Notifying consumer.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumer: Waiting for production to finish.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 进入等待状态</span></span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumer: Production finished. Consuming...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ul>
<li><code>lock</code> 是一个用于同步的对象，生产者和消费者线程都需要获取该对象的锁才能执行相应的操作。</li>
<li>消费者线程调用 <code>lock.wait()</code> 方法进入等待状态，释放锁；生产者线程执行完生产任务后调用 <code>lock.notify()</code> 方法唤醒等待的消费者线程。</li>
</ul>
<p><strong><code>java.util.concurrent.locks</code> 包中的 <code>Lock</code> 和 <code>Condition</code> 接口提供了比 <code>synchronized</code> 更灵活的线程间通信方式。</strong><code>Condition</code> 接口的 <code>await()</code> 方法类似于 <code>wait()</code> 方法，<code>signal()</code> 方法类似于 <code>notify()</code> 方法，<code>signalAll()</code> 方法类似于 <code>notifyAll()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockConditionExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Producing...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Production finished. Notifying consumer.&quot;</span>);</span><br><span class="line">                <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Waiting for production to finish.&quot;</span>);</span><br><span class="line">                <span class="comment">// 进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Production finished. Consuming...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ul>
<li><code>ReentrantLock</code> 是 <code>Lock</code> 接口的一个实现类，<code>condition</code> 是通过 <code>lock.newCondition()</code> 方法创建的。</li>
<li>消费者线程调用 <code>condition.await()</code> 方法进入等待状态，生产者线程执行完生产任务后调用 <code>condition.signal()</code> 方法唤醒等待的消费者线程。</li>
</ul>
<p><strong><code>java.util.concurrent</code> 包中的 <code>BlockingQueue</code> 接口提供了线程安全的队列操作</strong>，当队列满时，插入元素的线程会被阻塞；当队列为空时，获取元素的线程会被阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Producing...&quot;</span>);</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Production finished.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Waiting for production to finish.&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Consumed item: &quot;</span> + item);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ul>
<li><code>LinkedBlockingQueue</code> 是 <code>BlockingQueue</code> 接口的一个实现类，容量为 1。</li>
<li>生产者线程调用 <code>queue.put(1)</code> 方法将元素插入队列，如果队列已满，线程会被阻塞；消费者线程调用 <code>queue.take()</code> 方法从队列中取出元素，如果队列为空，线程会被阻塞。</li>
</ul>
<h2 id="16-线程间通信方式有哪些？"><a href="#16-线程间通信方式有哪些？" class="headerlink" title="16.线程间通信方式有哪些？"></a>16.线程间通信方式有哪些？</h2><p><strong>Object 类的 wait()、notify() 和 notifyAll() 方法。</strong>这是 Java 中最基础的线程间通信方式，基于对象的监视器（锁）机制。</p>
<ul>
<li><code>wait()</code>：使当前线程进入等待状态，直到其他线程调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。</li>
<li><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。</li>
<li><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumerMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="comment">/* 条件不满足 */</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">producerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行相应操作</span></span><br><span class="line">        notify(); <span class="comment">// 或者 notifyAll()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、<strong><code>Lock</code> 和 <code>Condition</code> 接口。<code>Lock</code> 接口提供了比 <code>synchronized</code> 更灵活的锁机制，<code>Condition</code> 接口则配合 <code>Lock</code> 实现线程间的等待 / 通知机制。</strong></p>
<ul>
<li><code>await()</code>：使当前线程进入等待状态，直到被其他线程唤醒。</li>
<li><code>signal()</code>：唤醒一个等待在该 <code>Condition</code> 上的线程。</li>
<li><code>signalAll()</code>：唤醒所有等待在该 <code>Condition</code> 上的线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="comment">/* 条件不满足 */</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行相应操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行相应操作</span></span><br><span class="line">            condition.signal(); <span class="comment">// 或者 signalAll()</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、<code>volatile</code> 关键字。<code>volatile</code> <strong>关键字用于保证变量的可见性，即当一个变量被声明为 <code>volatile</code> 时，它会保证对该变量的写操作会立即刷新到主内存中，而读操作会从主内存中读取最新的值。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、<strong>CountDownLatch。<code>CountDownLatch</code> 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。</strong></p>
<ul>
<li><code>CountDownLatch(int count)</code>：构造函数，指定需要等待的线程数量。</li>
<li><code>countDown()</code>：减少计数器的值。</li>
<li><code>await()</code>：使当前线程等待，直到计数器的值为 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程任务完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、<strong>CyclicBarrier。<code>CyclicBarrier</code> 是一个同步辅助类，它允许一组线程相互等待，直到所有线程都到达某个公共屏障点。</strong></p>
<ul>
<li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>：构造函数，指定参与的线程数量和所有线程到达屏障点后要执行的操作。</li>
<li><code>await()</code>：使当前线程等待，直到所有线程都到达屏障点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(threadCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程都到达屏障点&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 到达屏障点&quot;</span>);</span><br><span class="line">                    barrier.await();</span><br><span class="line">                    <span class="comment">// 继续执行后续任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、<strong>Semaphore。<code>Semaphore</code> 是一个计数信号量，它可以控制同时访问特定资源的线程数量。</strong></p>
<ul>
<li><code>Semaphore(int permits)</code>：构造函数，指定信号量的初始许可数量。</li>
<li><code>acquire()</code>：获取一个许可，如果没有可用许可则阻塞。</li>
<li><code>release()</code>：释放一个许可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">permitCount</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(permitCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得许可&quot;</span>);</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放许可&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-如何停止一个线程？"><a href="#17-如何停止一个线程？" class="headerlink" title="17.如何停止一个线程？"></a>17.如何停止一个线程？</h2><p>在 Java 中，停止线程的正确方式是 <strong>通过协作式的逻辑控制线程终止</strong>，而非强制暴力终止（如已废弃的 <code>Thread.stop()</code>）。以下是实现安全停止线程的多种方法：</p>
<p><strong>第一种方式：通过共享标志位主动终止</strong>。<strong>定义一个 可见的 状态变量，由主线程控制其值，工作线程循环检测该变量以决定是否退出。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeStopWithFlag</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理任务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获中断异常后设置 running=false</span></span><br><span class="line">                running = <span class="literal">false</span>;</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread terminated safely.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止线程的方法（由外部调用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SafeStopWithFlag</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeStopWithFlag</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 某个时刻调用停止</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">task.stop();</span><br></pre></td></tr></table></figure>
<p><strong>第二种方式使用线程中断机制</strong>。通过 <code>Thread.interrupt()</code> 触发线程中断状态，结合中断检测逻辑实现安全停止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Working...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 当阻塞时被中断，抛出异常并清除中断状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted during sleep!&quot;</span>);</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread terminated by interrupt.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(new InterruptExample());</span><br><span class="line">thread.start();</span><br><span class="line">// 中断线程</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>interrupt()</code> <strong>不会立刻终止线程，只是设置中断标志位。</strong></li>
<li>线程需手动检查中断状态（<code>isInterrupted()</code>）或触发可中断操作（如<code>sleep()</code>，<code>wait()</code>，<code>join()</code>)响应中断。</li>
<li>阻塞操作中收到中断请求时，会抛出 <code>InterruptedException</code> 并清除中断状态。</li>
</ul>
<p><strong>第三种方式通过 <code>Future</code> 取消任务</strong>。使用线程池提交任务，并通过 <code>Future.cancel()</code> 停止线程，依赖中断机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCancelDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task running...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task interrupted.&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            future.cancel(<span class="literal">true</span>); <span class="comment">// true表示尝试中断任务线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四种方式**</strong>处理不可中断的阻塞操作。**某些 I/O 或同步操作（如 <code>Socket.accept()</code>、<code>Lock.lock()</code>）无法通过中断直接响应。此时需结合资源关闭操作。比如，关闭 Socket 释放阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketHandler</span><span class="params">(ServerSocket serverSocket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverSocket = serverSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// serverSocket.accept()阻塞时无法响应中断</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// 处理连接...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread stopped by interrupt.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊关闭方法（销毁资源）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket.close(); <span class="comment">// 关闭资源使accept()抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error closing socket: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：调用 <code>stop()</code> 方法关闭资源以解除阻塞。</p>
<p>线程停止的正确实践，如下表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>注意事项</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>循环检测标志位</strong></td>
<td>简单无阻塞的逻辑</td>
<td>确保标志位使用 <code>volatile</code> 或通过锁保证可见性</td>
</tr>
<tr>
<td><strong>中断机制</strong></td>
<td>可中断的阻塞操作</td>
<td>正确处理 <code>InterruptedException</code> 并恢复中断标志</td>
</tr>
<tr>
<td><strong>Future.cancel()</strong></td>
<td>线程池管理任务</td>
<td>需要线程池任务支持中断处理机制</td>
</tr>
<tr>
<td><strong>资源关闭</strong></td>
<td>不可中断的阻塞操作（如Sockets）</td>
<td>显式关闭资源触发异常，结合中断状态判断回滚</td>
</tr>
</tbody>
</table>
</div>
<p>避免使用以下已废弃方法：</p>
<ul>
<li><code>Thread.stop()</code>：暴力终止，可能导致状态不一致。</li>
<li><code>Thread.suspend()</code>/<code>resume()</code>：易导致死锁。</li>
</ul>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="1-juc包下你常用的类？"><a href="#1-juc包下你常用的类？" class="headerlink" title="1.juc包下你常用的类？"></a>1.juc包下你常用的类？</h2><p><strong>线程池相关：</strong></p>
<ul>
<li><code>ThreadPoolExecutor</code>：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求。</li>
<li><code>Executors</code>：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池，如<code>newFixedThreadPool</code>（创建固定线程数的线程池）、<code>newCachedThreadPool</code>（创建可缓存线程池）、<code>newSingleThreadExecutor</code>（创建单线程线程池）等，方便开发者快速创建线程池。</li>
</ul>
<p><strong>并发集合类：</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。它采用了<strong>分段锁</strong>等技术，允许多个线程同时访问不同的段，提高了并发性能，在高并发场景下比传统的<code>Hashtable</code>性能更好。</li>
<li><code>CopyOnWriteArrayList</code>：线程安全的列表，在对列表进行修改操作时，会<strong>创建一个新的底层数组，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行，从而实现了读写分离，提高了并发读的性能，适用于读多写少的场景。</strong></li>
</ul>
<p><strong>同步工具类：</strong></p>
<ul>
<li><code>CountDownLatch</code>：允许一个或多个线程等待其他一组线程完成操作后再继续执行。它通过一个计数器来实现，计数器初始化为线程的数量，每个线程完成任务后调用<code>countDown</code>方法将计数器减一，当计数器为零时，等待的线程可以继续执行。<strong>常用于多个线程完成各自任务后，再进行汇总或下一步操作的场景。</strong></li>
<li><code>CyclicBarrier</code>：让一组线程互相等待，直到所有线程都到达某个屏障点后，再一起继续执行。与<code>CountDownLatch</code>不同的是，<code>CyclicBarrier</code>可以重复使用，当所有线程都通过屏障后，计数器会重置，可以再次用于下一轮的等待。<strong>适用于多个线程需要协同工作，在某个阶段完成后再一起进入下一个阶段的场景。</strong></li>
<li><code>Semaphore</code>：信号量，<strong>用于控制同时访问某个资源的线程数量。</strong>它维护了一个许可计数器，线程在访问资源前需要获取许可，如果有可用许可，则获取成功并将许可计数器减一，否则线程需要等待，直到有其他线程释放许可。常用于控制对有限资源的访问，如数据库连接池、线程池中的线程数量等。</li>
</ul>
<p><strong>原子类：</strong></p>
<ul>
<li><code>AtomicInteger</code>：原子整数类，提供了<strong>对整数类型的原子操作</strong>，如自增、自减、比较并交换等。通过硬件级别的原子指令来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销，在多线程环境下对整数进行计数、状态标记等操作非常方便。</li>
<li><code>AtomicReference</code>：原子引用类，用于对对象引用进行原子操作。可以保证在多线程环境下，对对象的更新操作是原子性的，即要么全部成功，要么全部失败，不会出现数据不一致的情况。常用于实现无锁数据结构或需要对对象进行原子更新的场景。</li>
</ul>
<h2 id="2-怎么保证多线程安全？"><a href="#2-怎么保证多线程安全？" class="headerlink" title="2.怎么保证多线程安全？"></a>2.怎么保证多线程安全？</h2><ul>
<li><strong>synchronized关键字</strong>:可以使用<code>synchronized</code>关键字来同步代码块或方法，<strong>确保同一时刻只有一个线程可以访问这些代码</strong>。对象锁是通过<code>synchronized</code>关键字锁定对象的监视器（monitor）来实现的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anotherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>volatile关键字</strong>:<code>volatile</code>关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> sharedVariable;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Lock接口和ReentrantLock类</strong>:<code>java.util.concurrent.locks.Lock</code>接口提供了比<code>synchronized</code>更强大的锁定机制，<code>ReentrantLock</code>是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>原子类</strong>：Java并发库（<code>java.util.concurrent.atomic</code>）提供了原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter.incrementAndGet();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>线程局部变量</strong>:<code>ThreadLocal</code>类可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; threadLocalVar = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">threadLocalVar.set(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocalVar.get();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>并发集合</strong>:使用<code>java.util.concurrent</code>包中的线程安全集合，如<code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>等，这些集合内部已经实现了线程安全的逻辑。</li>
<li><strong>JUC工具类</strong>: 使用<code>java.util.concurrent</code>包中的一些工具类可以用于控制线程间的同步和协作。例如：<code>Semaphore</code>和<code>CyclicBarrier</code>等。</li>
</ul>
<h2 id="3-Java中有哪些常用的锁，在什么场景下使用？"><a href="#3-Java中有哪些常用的锁，在什么场景下使用？" class="headerlink" title="3.Java中有哪些常用的锁，在什么场景下使用？"></a>3.Java中有哪些常用的锁，在什么场景下使用？</h2><p>Java中的锁是用于管理多线程并发访问共享资源的关键机制。锁可以确保在任意给定时间内只有一个线程可以访问特定的资源，从而避免数据竞争和不一致性。Java提供了多种锁机制，可以分为以下几类：</p>
<ul>
<li><strong>内置锁（synchronized）</strong>：Java中的<code>synchronized</code>关键字是内置锁机制的基础，可以用于方法或代码块。<strong>当一个线程进入<code>synchronized</code>代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。</strong>如果其他线程尝试获取同一个对象的锁，它们将被<strong>阻塞</strong>，直到锁被释放。其中，syncronized加锁时<strong>有无锁、偏向锁、轻量级锁和重量级锁几个级别</strong>。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用<strong>偏向锁</strong>，以减少锁的开销。<strong>轻量级锁</strong>使用线程栈上的数据结构，避免了操作系统级别的锁。<strong>重量级锁则涉及操作系统级的互斥锁</strong>。</li>
<li><strong>ReentrantLock</strong>：<code>java.util.concurrent.locks.ReentrantLock</code>是一个显式的锁类，提供了比<code>synchronized</code>更高级的功能，如可<strong>中断的锁等待、定时锁等待、公平锁选项</strong>等。<code>ReentrantLock</code>使用<code>lock()</code>和<code>unlock()</code>方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。</li>
<li><strong>读写锁（ReadWriteLock）</strong>：<code>java.util.concurrent.locks.ReadWriteLock</code>接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。</li>
<li><strong>乐观锁和悲观锁</strong>：悲观锁（Pessimistic Locking）通常指<strong>在访问数据前就锁定资源</strong>，假设最坏的情况，即数据很可能被其他线程修改。<code>synchronized</code>和<code>ReentrantLock</code>都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，<strong>而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。比如CAS</strong></li>
<li><strong>自旋锁</strong>：自旋锁是一种锁机制，线程在等待锁时会<strong>持续循环检查锁是否可用，</strong>而不是放弃CPU并阻塞。通常可以使用CAS来实现。<strong>这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。</strong></li>
</ul>
<h2 id="4-怎么在实践中用锁的？"><a href="#4-怎么在实践中用锁的？" class="headerlink" title="4.怎么在实践中用锁的？"></a>4.怎么在实践中用锁的？</h2><p>Java提供了多种锁的实现，包括<code>synchronized</code>关键字、<code>java.util.concurrent.locks</code>包下的<code>Lock</code>接口及其具体实现如<code>ReentrantLock</code>、<code>ReadWriteLock</code>等。下面我们来看看这些锁的使用方式。</p>
<blockquote>
<ol>
<li><code>synchronized</code></li>
</ol>
</blockquote>
<p><code>synchronized</code>关键字可以用于方法或代码块，它是Java中最早的锁实现，使用起来非常简单。</p>
<p><strong>示例：synchronized方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例：synchronized代码块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>使用<code>Lock</code>接口</li>
</ol>
</blockquote>
<p><code>Lock</code>接口提供了比<code>synchronized</code>更灵活的锁操作，包括尝试锁、可中断锁、定时锁等。<code>ReentrantLock</code>是<code>Lock</code>接口的一个实现。</p>
<p><strong>示例：使用ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>使用<code>ReadWriteLock</code></li>
</ol>
</blockquote>
<p><code>ReadWriteLock</code>接口提供了一种读写锁的实现，允许多个读操作同时进行，但写操作是<strong>独占</strong>的。</p>
<p><strong>示例：使用ReadWriteLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(Object newData)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Java-并发工具你知道哪些？"><a href="#5-Java-并发工具你知道哪些？" class="headerlink" title="5.Java 并发工具你知道哪些？"></a>5.Java 并发工具你知道哪些？</h2><ul>
<li><strong>CountDownLatch</strong>：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。它使用一个计数器进行初始化，调用 <code>countDown()</code> 方法会使计数器减一，当计数器的值减为 0 时，等待的线程会被唤醒。可以把它想象成一个倒计时器，当倒计时结束（计数器为 0）时，等待的事件就会发生。示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberOfThreads</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(numberOfThreads);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动三个工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在工作&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟工作时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();  <span class="comment">// 完成工作，计数器减一</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成工作&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待工作线程完成&quot;</span>);</span><br><span class="line">        latch.await();  <span class="comment">// 主线程等待，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有工作线程已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CyclicBarrier</strong>：CyclicBarrier 允许一组线程互相等待，直到到达一个公共的屏障点。当所有线程都到达这个屏障点后，它们可以继续执行后续操作，并且这个屏障可以被重置循环使用。与 <code>CountDownLatch</code> 不同，<code>CyclicBarrier</code> 侧重于线程间的相互等待，而不是等待某些操作完成。示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberOfThreads</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(numberOfThreads, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程都到达了屏障，继续执行后续操作&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在运行&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟运行时间</span></span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经通过屏障&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Semaphore</strong>：Semaphore 是一个计数信号量，用于控制同时访问某个共享资源的线程数量。通过 <code>acquire()</code> 方法获取许可，使用 <code>release()</code> 方法释放许可。如果没有许可可用，线程将被阻塞，直到有许可被释放。可以用来限制对某些资源（如数据库连接池、文件操作等）的并发访问量。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);  <span class="comment">// 允许 2 个线程同时访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得了许可&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟资源使用</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放了许可&quot;</span>);</span><br><span class="line">                    semaphore.release();  <span class="comment">// 释放许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Future 和 Callable</strong>：Callable 是一个类似于 <code>Runnable</code> 的接口，但它可以返回结果，并且可以抛出异常。<strong>Future 用于表示一个异步计算的结果，可以通过它来获取 <code>Callable</code> 任务的执行结果或取消任务。代码如下：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行 Callable 任务&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 返回结果</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(callable);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 等待 Callable 任务完成并获取结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Callable 任务的结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ConcurrentHashMap</strong>：ConcurrentHashMap 是一个线程安全的哈希表，它允许多个线程同时进行读操作，在一定程度上支持并发的修改操作，避免了 <code>HashMap</code> 在多线程环境下需要使用 <code>synchronized</code> 或 <code>Collections.synchronizedMap()</code> 进行同步的性能问题。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发读操作</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发写操作</span></span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;key3&quot;</span>, k -&gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-CountDownLatch-是做什么的讲一讲？"><a href="#6-CountDownLatch-是做什么的讲一讲？" class="headerlink" title="6.CountDownLatch 是做什么的讲一讲？"></a>6.CountDownLatch 是做什么的讲一讲？</h2><p>CountDownLatch 是 Java 并发包（<code>java.util.concurrent</code>）中的一个同步工具类，<strong>用于让一个或多个线程等待其他线程完成操作后再继续执行</strong>。</p>
<p>其核心是通过一个计数器（Counter）实现线程间的协调，常用于多线程任务的分阶段控制或主线程等待多个子线程就绪的场景，核心原理：</p>
<ul>
<li><strong>初始化计数器</strong>：创建 <code>CountDownLatch</code> 时指定一个初始计数值（如 <code>N</code>）。</li>
<li><strong>等待线程阻塞</strong>：调用 <code>await()</code> 的线程会被阻塞，直到计数器变为 0。</li>
<li><strong>任务完成通知</strong>：其他线程完成任务后调用 <code>countDown()</code>，使计数器减 1。</li>
<li><strong>唤醒等待线程</strong>：当计数器减到 0 时，所有等待的线程会被唤醒。</li>
</ul>
<p>主线程等待所有子线程就绪后启动，代码例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程启动多个子线程执行任务，等待全部完成后统计结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThreadWaitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成，计数器-1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 主线程等待所有子线程完成任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-synchronized和reentrantlock及其应用场景？"><a href="#7-synchronized和reentrantlock及其应用场景？" class="headerlink" title="7.synchronized和reentrantlock及其应用场景？"></a>7.synchronized和reentrantlock及其应用场景？</h2><blockquote>
<p>synchronized 工作原理</p>
</blockquote>
<p>synchronized是Java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为<strong>监视器锁</strong>，</p>
<p>使用synchronized之后，会在<strong>编译之后在同步的代码块前后加上monitorenter和monitor exit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。</strong></p>
<p>还有有序性，，cup会对代码进行重排，导致输入和输出的顺序不一致，这个时候使用内存屏障来进制重排。</p>
<p>执行monitorenter指令时会尝试获取对象锁，<strong>如果对象没有被锁定或者已经获得了锁，锁的计数器+1</strong>。此时其他竞争锁的线程则会进入等待队列中。<strong>执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。</strong></p>
<p>synchronized是<strong>排它锁</strong>，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态，这种转换非常消耗性能。</p>
<p>从内存语义来说，加锁的过程会<strong>清除工作内存中的共享变量，再从主内存读取</strong>，而释放锁的过程则是将工作内存中的共享变量写回主内存。</p>
<p>实际上大部分时候我认为说到monitorenter就行了，但是为了更清楚的描述，还是再具体一点。</p>
<p>如果再深入到源码来说，synchronized实际上有两个队列waitSet和entryList。</p>
<p>wait池和锁池字</p>
<ol>
<li>当多个线程进入同步代码块时，首先进入entryList</li>
<li>有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1</li>
<li>如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁</li>
<li>如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null。或者是他进入waiting了然后进入waiting态，然后如果noticy的时候再进入entryList</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719918642412-181e3769-49d8-4c78-8f33-a866367a4693.png" alt="img"></li>
</ol>
<blockquote>
<p>reentrantlock工作原理</p>
</blockquote>
<p>ReentrantLock 的底层实现主要依赖于 AbstractQueuedSynchronizer<strong>（AQS）这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等。</strong></p>
<p>ReentrantLock 在 AQS 的基础上通过内部类 <strong>Sync</strong> 来实现具体的锁操作。<strong>不同的 Sync 子类实现了公平锁和非公平锁的不同逻辑：</strong></p>
<ul>
<li><strong>可中断性</strong>： ReentrantLock 实现了<strong>可中断性</strong>，这意味着线程在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，ReentrantLock 使用了与 <strong>LockSupport.park() 和 LockSupport.unpark() 相关的机制来实现可中断性。</strong></li>
<li><strong>设置超时时间</strong>： ReentrantLock <strong>支持在尝试获取锁时设置超时时间</strong>，即等待一定时间后如果还未获得锁，则放弃锁的获取。这是通过内部的 <strong>tryAcquireNanos 方法来实现的</strong>。</li>
<li><strong>公平锁和非公平锁</strong>： 在直接创建 ReentrantLock 对象时，<strong>默认情况下是非公平锁</strong>。公平锁是按照线程等待的顺序来获取锁，而非公平锁则允许多个线程在同一时刻竞争锁，不考虑它们申请锁的顺序。公平锁可以通过在创建 ReentrantLock 时传入 true 来设置，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>多个条件变量</strong>： ReentrantLock <strong>支持多个条件变量</strong>，每个条件变量可以与一个 ReentrantLock 关联。这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的 wait() 和 notify()。多个条件变量的实现依赖于 Condition 接口，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 使用下面方法进行等待和唤醒</span></span><br><span class="line">condition.await();</span><br><span class="line">condition.signal();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可重入性</strong>： ReentrantLock <strong>支持可重入性</strong>，<strong>即同一个线程可以多次获得同一把锁</strong>，而不会造成死锁。这是通过<strong>内部的 holdCount 计数来实现的</strong>。当一个线程多次获取锁时，holdCount 递增，释放锁时递减，只有当 holdCount 为零时，其他线程才有机会获取锁。</li>
</ul>
<blockquote>
<p>应用场景的区别</p>
</blockquote>
<p><strong>synchronized</strong>：</p>
<ul>
<li><strong>简单同步需求</strong>： 当你需要对<strong>代码块或方法进行简单的同步控制时</strong>，<code>synchronized</code>是一个很好的选择。它使用起来简单，不需要额外的资源管理，因为锁会在方法退出或代码块执行完毕后自动释放。</li>
<li><strong>代码块同步</strong>： 如果你想对特定代码段进行同步，而不是整个方法，可以使用<code>synchronized</code>代码块。这可以让你更精细地控制同步的范围，从而减少锁的持有时间，提高并发性能。</li>
<li><strong>内置锁的使用</strong>： <code>synchronized</code>关键字使用对象的内置锁（也称为监视器锁），这在需要使用对象作为锁对象的情况下很有用，尤其是在对象状态与锁保护的代码紧密相关时。</li>
</ul>
<p><strong>ReentrantLock：</strong></p>
<ul>
<li><strong>高级锁功能需求</strong>： <code>ReentrantLock</code>提供了<code>synchronized</code>所不具备的高级功能，如公平锁、响应中断、定时锁尝试、以及多个条件变量。当你需要这些功能时，<code>ReentrantLock</code>是更好的选择。</li>
<li><strong>性能优化</strong>： 在高度竞争的环境中，<code>ReentrantLock</code>可以提供比<code>synchronized</code>更好的性能，因为它提供了<strong>更细粒度的控制，如尝试锁定和定时锁定，可以减少线程阻塞的可能性</strong>。</li>
<li><strong>复杂同步结构</strong>： 当你需要更复杂的同步结构，如需要多个条件变量来协调线程之间的通信时，<code>ReentrantLock</code>及其配套的<code>Condition</code>对象可以提供更灵活的解决方案。</li>
</ul>
<p>综上，<code>synchronized</code>适用于简单同步需求和不需要额外锁功能的场景，而<code>ReentrantLock</code>适用于需要更高级锁功能、性能优化或复杂同步逻辑的情况。选择哪种同步机制取决于具体的应用需求和性能考虑。</p>
<h2 id="8-除了用synchronized，还有什么方法可以实现线程同步？"><a href="#8-除了用synchronized，还有什么方法可以实现线程同步？" class="headerlink" title="8.除了用synchronized，还有什么方法可以实现线程同步？"></a>8.除了用synchronized，还有什么方法可以实现线程同步？</h2><ul>
<li><strong>使用<code>ReentrantLock</code>类</strong>：<code>ReentrantLock</code>是一个可重入的互斥锁，相比<code>synchronized</code>提供了更灵活的锁定和解锁操作。它还支持公平锁和非公平锁，以及可以响应中断的锁获取操作。</li>
<li><strong>使用<code>volatile</code>关键字</strong>：虽然<code>volatile</code>不是一种锁机制，但它可以确保变量的可见性。当一个变量被声明为<code>volatile</code>后，线程将直接从主内存中读取该变量的值，这样就能保证线程间变量的可见性。但它不具备原子性。</li>
<li><strong>使用<code>Atomic</code>类</strong>：Java提供了一系列的原子类，例如<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等，用于实现对单个变量的原子操作，这些类在实现细节上利用了CAS（Compare-And-Swap）算法，可以用来实现无锁的线程安全。</li>
</ul>
<h2 id="9-synchronized锁静态方法和普通方法区别？"><a href="#9-synchronized锁静态方法和普通方法区别？" class="headerlink" title="9.synchronized锁静态方法和普通方法区别？"></a>9.synchronized锁静态方法和普通方法区别？</h2><p>锁的对象不同：</p>
<ul>
<li><strong>普通方法</strong>：锁的是<strong>当前对象实例</strong>（<code>this</code>）。同一对象实例的 <code>synchronized</code> 普通方法，同一时间只能被一个线程访问；不同对象实例间互不影响，可被不同线程同时访问各自的同步普通方法。</li>
<li><strong>静态方法</strong>：锁的是<strong>当前类的 <code>Class</code> 对象</strong>。由于类的 <code>Class</code> 对象全局唯一，无论多少个对象实例，该静态同步方法同一时间只能被一个线程访问。</li>
</ul>
<p>作用范围不同：</p>
<ul>
<li><strong>普通方法</strong>：仅对同一对象实例的同步方法调用互斥，不同对象实例的同步普通方法可并行执行。</li>
<li><strong>静态方法</strong>：对整个类的所有实例的该静态方法调用都互斥，一个线程进入静态同步方法，其他线程无法进入同一类任何实例的该方法。</li>
</ul>
<p>多实例场景影响不同：</p>
<ul>
<li><strong>普通方法</strong>：多线程访问不同对象实例的同步普通方法时，可同时执行。</li>
<li><strong>静态方法</strong>：不管有多少对象实例，同一时间仅一个线程能执行该静态同步方法。</li>
</ul>
<h2 id="10-synchronized和reentrantlock区别？"><a href="#10-synchronized和reentrantlock区别？" class="headerlink" title="10.synchronized和reentrantlock区别？"></a>10.synchronized和reentrantlock区别？</h2><p>synchronized 和 ReentrantLock 都是 Java 中提供的可重入锁：</p>
<ul>
<li><strong>用法不同</strong>：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。</li>
<li><strong>获取锁和释放锁方式不同</strong>：synchronized 会<strong>自动加锁和释放锁</strong>，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要<strong>手动加锁和释放锁</strong></li>
<li><strong>锁类型不同</strong>：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。</li>
<li><strong>响应中断不同</strong>：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。</li>
<li><strong>底层实现不同</strong>：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。</li>
</ul>
<h2 id="11-怎么理解可重入锁？"><a href="#11-怎么理解可重入锁？" class="headerlink" title="11.怎么理解可重入锁？"></a>11.怎么理解可重入锁？</h2><p>可重入锁是指同一个线程在获取了锁之后，<strong>可以再次重复获取该锁而不会造成死锁或其他问题</strong>。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。</p>
<p>ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。</p>
<ul>
<li>当一个线程第一次获取锁时，计数器会加1，表示该线程持有了锁。在此之后，如果同一个线程再次获取锁，计数器会再次加1。每次线程成功获取锁时，都会将计数器加1。</li>
<li>当线程释放锁时，计数器会相应地减1。<strong>只有当计数器减到0时，锁才会完全释放，其他线程才有机会获取锁。</strong></li>
</ul>
<p>这种计数器的设计使得同一个线程可以多次获取同一个锁，而不会造成死锁或其他问题。每次获取锁时，计数器加1；每次释放锁时，计数器减1。只有当计数器减到0时，锁才会完全释放。</p>
<p><strong>ReentrantLock通过这种计数器的方式，实现了可重入锁的机制。它允许同一个线程多次获取同一个锁，并且能够正确地处理锁的获取和释放，避免了死锁和其他并发问题。</strong></p>
<h2 id="12-synchronized-支持重入吗？如何实现的"><a href="#12-synchronized-支持重入吗？如何实现的" class="headerlink" title="12.synchronized 支持重入吗？如何实现的?"></a>12.synchronized 支持重入吗？如何实现的?</h2><p>synchronized是基于<strong>原子性的内部锁机制</strong>，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，<strong>也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</strong></p>
<p>synchronized底层是利用<strong>计算机系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态status。</strong></p>
<p>当一个线程请求方法时，会去检查锁状态。</p>
<ol>
<li>如果锁状态是0，代表该锁没有被占用，使用CAS操作获取锁，将线程ID替换成自己的线程ID。</li>
<li>如果锁状态不是0，代表有线程在访问该方法。此<strong>时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法；如果是非重入锁，就会进入阻塞队列等待。</strong></li>
</ol>
<p>在释放锁时，</p>
<ol>
<li>如果是可重入锁的，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。</li>
<li>如果非可重入锁的，线程退出方法，直接就会释放该锁。</li>
</ol>
<h2 id="13-syncronized锁升级的过程讲一下"><a href="#13-syncronized锁升级的过程讲一下" class="headerlink" title="13.syncronized锁升级的过程讲一下"></a>13.syncronized锁升级的过程讲一下</h2><p>在之前没有锁升级的时候的时候，都一样的锁，不足以应对不同时间的不同状态的并发操作</p>
<p>具体的锁升级的过程是：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</p>
<ul>
<li><strong>无锁</strong>：这是没有开启偏向锁的时候的状态，在JDK1.6之后偏向锁的默认开启的，但是有一个<strong>偏向延迟</strong>，需要在JVM启动之后的多少秒之后才能开启，这个可以通过JVM参数进行设置，同时是否开启偏向锁也可以通过JVM参数设置。</li>
<li><strong>偏向锁</strong>：这个是在偏向锁开启之后的锁的状态，如果还没有一个线程拿到这个锁的话，这个状态叫做匿名偏向，当一个线程拿到偏向锁的时候，<strong>下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID进行比较，如果线程ID相同则直接获取锁（相当于锁偏向于这个线程），不需要进行CAS操作和将线程挂起的操作。适用于一个锁的时候</strong></li>
<li><strong>轻量级锁</strong>：在这个状态下线程主要是通过<strong>CAS</strong>操作实现的。将<strong>对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，</strong>如果设置成功则获取锁。在线程出临界区的时候，也需要使用CAS，如果使用CAS替换成功则同步成功，如果失败表示有其他线程在获取锁，那么就需要在释放锁之后将被挂起的线程唤醒。 一般就是两个线程取竞争锁，他需要在这一 直自旋去等待，就是一直再循环执行，直到抢到锁为止，非常消耗cpu</li>
<li><strong>重量级锁</strong>：<strong>当有两个以上的线程获取锁的时候轻量级锁就会升级为重量级锁</strong>，因为CAS如果没有成功的话始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源。</li>
</ul>
<p>了解完 4 种锁状态之后，我们就可以整体的来看一下锁升级的过程了。 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="image.png"> 线程A进入 synchronized 开始抢锁，<strong>JVM 会判断当前是否是偏向锁的状态，如果是就会根据 Mark Word 中存储的线程 ID 来判断</strong>，当前线程A是否就是持有偏向锁的线程。如果是，则忽略 check，线程A直接执行临界区内的代码。</p>
<p>但如果 Mark Word 里的线程不是线程 A，就会通过<strong>自旋</strong>尝试获取锁，如果获取到了，就将 Mark Word 中的线程 ID 改为自己的;<strong>如果竞争失败，就会立马撤销偏向锁，膨胀为轻量级锁。</strong></p>
<p>后续的竞争线程都会通过自旋来尝试获取锁，如果自旋成功那么锁的状态仍然是轻量级锁。然而如果竞争失败，锁会膨胀为重量级锁，后续等待的竞争的线程都会被阻塞。</p>
<p><strong>线程阻塞与唤醒是操作系统层面的动作</strong>（涉及线程调度）；</p>
<p>需要进行：</p>
<ul>
<li>线程上下文切换（保存现场、恢复现场）；</li>
<li>线程状态变更（Runnable → Waiting / Blocked）；</li>
</ul>
<p>因为从用户态转到内核态是非常消耗性能的，所以只有重量级锁，很多线程去竞争的时候才会使用，一般的靠自旋解决就可以了</p>
<h2 id="14-JVM对Synchornized的优化？"><a href="#14-JVM对Synchornized的优化？" class="headerlink" title="14.JVM对Synchornized的优化？"></a>14.JVM对Synchornized的优化？</h2><p>synchronized 核心优化方案主要包含以下 4 个：</p>
<ul>
<li><strong>锁膨胀</strong>：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，<strong>大部分的场景都不需要用户态到内核态的转换了</strong>，这样就大幅的提升了 synchronized 的性能。</li>
<li><strong>锁消除</strong>：指的是在某些情况下，JVM 虚拟机如果<strong>检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉</strong>，从而到底提高程序性能的目的。</li>
<li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li>
<li><strong>自适应自旋锁</strong>：指通过自身循环，尝试获取锁的一种方式，优点在于它<strong>避免一些线程的挂起和恢复操作</strong>，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。</li>
</ul>
<h2 id="15-介绍一下AQS"><a href="#15-介绍一下AQS" class="headerlink" title="15.介绍一下AQS"></a>15.介绍一下AQS</h2><p>AQS全称为AbstractQueuedSynchronizer，是Java中的一个抽象类。 AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。</p>
<p>AQS核心思想是，<strong>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</strong>这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p>
<p>主要原理图如下： <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1721809581196-7c09ce04-1429-4810-ade4-bb3098a9303d.png" alt="image.png"></p>
<p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p>
<p>AQS广泛用于控制并发流程的类，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720958362111-45aa351b-c338-4eb8-8dad-da5e6f95a3c3.png" alt="img"></p>
<p>其中<code>Sync</code>是这些类中都有的内部类，其结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720958362187-35b5e5ef-04e0-44a6-b5f8-205f43df8847.png" alt="img"></p>
<p>可以看到：<code>Sync</code>是<code>AQS</code>的实现。 <code>AQS</code>主要完成的任务：</p>
<ul>
<li>同步状态（比如说计数器）的原子性管理；</li>
<li>线程的阻塞和解除阻塞；</li>
<li>队列的管理。</li>
</ul>
<blockquote>
<p>AQS原理</p>
</blockquote>
<p>AQS最核心的就是三大部分：</p>
<ul>
<li>状态：state；</li>
<li>控制线程抢锁和配合的FIFO队列（双向链表）；</li>
<li>期望协作工具类去实现的获取/释放等重要方法（重写）。</li>
</ul>
<p><strong>状态state</strong></p>
<ul>
<li>这里state的具体含义，会根据具体实现类的不同而不同：比如在Semapore里，他表示剩余许可证的数量；在CountDownLatch里，它表示还需要倒数的数量；在ReentrantLock中，state用来表示“锁”的占有情况，<strong>包括可重入计数，当state的值为0的时候，标识该Lock不被任何线程所占有。</strong></li>
<li><strong>state是volatile修饰的，并被并发修改</strong>，所以修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于unsafe类。</li>
</ul>
<p><strong>FIFO队列</strong></p>
<ul>
<li>这个队列用来存放“等待的线程，AQS就是“排队管理器”，<strong>当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。</strong></li>
<li>AQS会维护一个等待的线程队列，把线程都放到这个队列里，这个队列是双向链表形式。</li>
</ul>
<p><strong>实现获取/释放等方法</strong></p>
<ul>
<li>这里的获取和释放方法，是利用AQS的协作工具类里最重要的方法，是由协作类自己去实现的，并且含义各不相同；</li>
<li>获取方法：获取操作会以来state变量，经常会阻塞（比如获取不到锁的时候）。在Semaphore中，获取就是acquire方法，作用是获取一个许可证； 而在CountDownLatch里面，获取就是await方法，作用是等待，直到倒数结束；</li>
<li>释放方法：在Semaphore中，释放就是release方法，作用是释放一个许可证； 在CountDownLatch里面，获取就是countDown方法，作用是将倒数的数减一；</li>
<li><strong>需要每个实现类重写tryAcquire和tryRelease等方法。</strong></li>
</ul>
<h2 id="16-CAS-和-AQS-有什么关系？"><a href="#16-CAS-和-AQS-有什么关系？" class="headerlink" title="16.CAS 和 AQS 有什么关系？"></a>16.CAS 和 AQS 有什么关系？</h2><p>CAS 和 AQS 两者的区别：</p>
<ul>
<li>CAS 是一种<strong>乐观锁机制</strong>，它包含三个操作数：内存位置（V）、预期值（A）和新值（B）。CAS 操作的逻辑是，如果内存位置 V 的值等于预期值 A，则将其更新为新值 B，否则不做任何操作。整个过程是原子性的，通常由硬件指令支持，如在现代处理器上，<code>cmpxchg</code> 指令可以实现 CAS 操作。</li>
<li>AQS 是一个用于<strong>构建锁和同步器的框架</strong>，许多同步器如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都是基于 AQS 构建的。AQS 使用一个 <code>volatile</code> 的整数变量 <code>state</code> 来表示同步状态，通过内置的 <code>FIFO</code> 队列来管理等待线程。它提供了一些基本的操作，如 <code>acquire</code>（获取资源）和 <code>release</code>（释放资源），这些操作会修改 <code>state</code> 的值，并根据 <code>state</code> 的值来判断线程是否可以获取或释放资源。AQS 的 <code>acquire</code> 操作通常会先尝试获取资源，如果失败，线程将被添加到等待队列中，并阻塞等待。<code>release</code> 操作会释放资源，并唤醒等待队列中的线程。</li>
</ul>
<p>CAS 和 AQS 两者的联系：</p>
<ul>
<li><strong>CAS 为 AQS 提供原子操作支持</strong>：AQS 内部使用 CAS 操作来更新 <code>state</code> 变量，以实现线程安全的状态修改。在 <code>acquire</code> 操作中，当线程尝试获取资源时，会使用 CAS 操作尝试将 <code>state</code> 从一个值更新为另一个值，如果更新失败，说明资源已被占用，线程会进入等待队列。在 <code>release</code> 操作中，当线程释放资源时，也会使用 CAS 操作将 <code>state</code> 恢复到相应的值，以保证状态更新的原子性。</li>
</ul>
<h2 id="17-如何用-AQS-实现一个可重入的公平锁？"><a href="#17-如何用-AQS-实现一个可重入的公平锁？" class="headerlink" title="17.如何用 AQS 实现一个可重入的公平锁？"></a>17.如何用 AQS 实现一个可重入的公平锁？</h2><p>AQS 实现一个可重入的公平锁的详细步骤：</p>
<ol>
<li><strong>继承 AbstractQueuedSynchronizer</strong>：创建一个内部类继承自 <code>AbstractQueuedSynchronizer</code>，重写 <code>tryAcquire</code>、<code>tryRelease</code>、<code>isHeldExclusively</code> 等方法，这些方法将用于实现锁的获取、释放和判断锁是否被当前线程持有。</li>
<li><strong>实现可重入逻辑</strong>：在 <code>tryAcquire</code> 方法中，检查当前线程是否已经持有锁，如果是，则增加锁的持有次数（通过 <code>state</code> 变量）；如果不是，尝试使用 CAS操作来获取锁。</li>
<li><strong>实现公平性</strong>：在 <code>tryAcquire</code> 方法中，按照队列顺序来获取锁，即先检查等待队列中是否有线程在等待，如果有，当前线程必须进入队列等待，而不是直接竞争锁。</li>
<li><strong>创建锁的外部类</strong>：创建一个外部类，内部持有 <code>AbstractQueuedSynchronizer</code> 的子类对象，并提供 <code>lock</code> 和 <code>unlock</code> 方法，这些方法将调用 <code>AbstractQueuedSynchronizer</code> 子类中的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairReentrantLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断锁是否被当前线程持有</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 公平性检查：检查队列中是否有前驱节点，如果有，则当前线程不能获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 可重入逻辑：如果是当前线程持有锁，则增加持有次数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread()!= getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供一个条件变量，用于实现更复杂的同步需求，这里只是简单实现</span></span><br><span class="line">        ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前线程是否持有锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个条件变量，用于实现更复杂的同步需求，这里只是简单实现</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<p><strong>内部类 Sync</strong>：</p>
<ul>
<li><code>isHeldExclusively</code>：使用 <code>getExclusiveOwnerThread</code> 方法检查当前锁是否被当前线程持有。</li>
<li><code>tryAcquire</code>：<ul>
<li>首先获取当前锁的状态 <code>c</code>。</li>
<li>如果 <code>c</code> 为 0，表示锁未被持有，此时进行公平性检查，通过 <code>hasQueuedPredecessors</code> 检查是否有前驱节点在等待队列中。如果没有，使用 <code>compareAndSetState</code> 尝试将状态设置为 <code>acquires</code>（通常为 1），并设置当前线程为锁的持有线程。</li>
<li>如果 <code>c</code> 不为 0，说明锁已被持有，检查是否为当前线程持有。如果是，增加锁的持有次数（可重入），但要防止溢出。</li>
</ul>
</li>
<li><code>tryRelease</code>：<ul>
<li>先将状态减 <code>releases</code>（通常为 1）。</li>
<li>检查当前线程是否为锁的持有线程，如果不是，抛出异常。</li>
<li>如果状态减为 0，说明锁被完全释放，将持有线程设为 <code>null</code>。</li>
</ul>
</li>
<li><code>newCondition</code>：创建一个 <code>ConditionObject</code> 用于更复杂的同步操作，如等待 / 通知机制。</li>
</ul>
<p><strong>外部类 FairReentrantLock</strong>：</p>
<ul>
<li><code>lock</code> 方法：调用 <code>sync.acquire(1)</code> 尝试获取锁。</li>
<li><code>unlock</code> 方法：调用 <code>sync.release(1)</code> 释放锁。</li>
<li><code>isLocked</code> 方法：调用 <code>sync.isHeldExclusively</code> 判断锁是否被当前线程持有。</li>
<li><code>newCondition</code> 方法：调用 <code>sync.newCondition</code> 提供条件变量。</li>
</ul>
<h2 id="18-Threadlocal作用，原理，具体里面存的key-value是啥，会有什么问题，如何解决"><a href="#18-Threadlocal作用，原理，具体里面存的key-value是啥，会有什么问题，如何解决" class="headerlink" title="18.Threadlocal作用，原理，具体里面存的key value是啥，会有什么问题，如何解决?"></a>18.Threadlocal作用，原理，具体里面存的key value是啥，会有什么问题，如何解决?</h2><p><code>ThreadLocal</code>是Java中用于解决线程安全问题的一种机制，它允许创建线程局部变量，即每个线程都有自己独立的变量副本，从而避免了线程间的资源共享和同步问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png" alt="img"></p>
<p>从内存结构图，我们可以看到：</p>
<ul>
<li>Thread类中，有个ThreadLocal.ThreadLocalMap 的成员变量。</li>
<li>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key<strong>是</strong>ThreadLocal<strong>本身</strong>，value是ThreadLocal的泛型对象值。</li>
</ul>
<blockquote>
<p>ThreadLocal的作用</p>
</blockquote>
<ul>
<li><strong>线程隔离</strong>：<code>ThreadLocal</code>为每个线程提供了<strong>独立的变量副本，这意味着线程之间不会相互影响，可以安全地在多线程环境中使用这些变量而不必担心数据竞争或同步问题。</strong></li>
<li><strong>降低耦合度</strong>：在同一个线程内的多个函数或组件之间，使用<code>ThreadLocal</code>可以减少参数的传递，降低代码之间的耦合度，使代码更加清晰和模块化。</li>
<li><strong>性能优势</strong>：由于<code>ThreadLocal</code>避免了线程间的同步开销，所以在大量线程并发执行时，相比传统的锁机制，它可以提供更好的性能。</li>
</ul>
<blockquote>
<p>ThreadLocal的原理</p>
</blockquote>
<p><code>ThreadLocal</code>的实现依赖于<code>Thread</code>类中的一个<code>ThreadLocalMap</code>字段，这是一个存储<code>ThreadLocal</code>变量本身和对应值的映射。每个线程都有自己的<code>ThreadLocalMap</code>实例，用于存储该线程所持有的所有<code>ThreadLocal</code>变量的值。</p>
<p>当你创建一个<code>ThreadLocal</code>变量时，它实际上就是一个<code>ThreadLocal</code>对象的实例。每个<code>ThreadLocal</code>对象都可以存储任意类型的值，这个值对每个线程来说是独立的。</p>
<ul>
<li>当调用<code>ThreadLocal</code>的<code>get()</code>方法时，<code>ThreadLocal</code>会检查当前线程的<code>ThreadLocalMap</code>中是否有与之关联的值。</li>
<li>如果有，返回该值；</li>
<li>如果没有，会调用<code>initialValue()</code>方法（如果重写了的话）来初始化该值，然后将其放入<code>ThreadLocalMap</code>中并返回。</li>
<li>当调用<code>set()</code>方法时，<code>ThreadLocal</code>会将给定的值与当前线程关联起来，即在当前线程的<code>ThreadLocalMap</code>中存储一个键值对，键是<code>ThreadLocal</code>对象自身，值是传入的值。</li>
<li>当调用<code>remove()</code>方法时，会从当前线程的<code>ThreadLocalMap</code>中移除与该<code>ThreadLocal</code>对象关联的条目。</li>
</ul>
<blockquote>
<p>可能存在的问题</p>
</blockquote>
<p>当一个线程结束时，其<code>ThreadLocalMap</code>也会随之销毁，但是<code>ThreadLocal</code>对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。</p>
<p>因此，在使用<code>ThreadLocal</code>时需要注意，<strong>如果不显式调用<code>remove()</code>方法，或者线程结束时未正确清理<code>ThreadLocal</code>变量，可能会导致内存泄漏，因为<code>ThreadLocalMap</code>会持续持有<code>ThreadLocal</code>变量的引用，即使这些变量不再被其他地方引用。</strong></p>
<p>因此，实际应用中需要在使用完<code>ThreadLocal</code>变量后调用<code>remove()</code>方法释放资源。</p>
<h2 id="19-悲观锁和乐观锁的区别？"><a href="#19-悲观锁和乐观锁的区别？" class="headerlink" title="19.悲观锁和乐观锁的区别？"></a>19.悲观锁和乐观锁的区别？</h2><ul>
<li>乐观锁： 就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总 是会发生，<strong>因此它不需要持有锁</strong>，<strong>将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</strong></li>
<li>悲观锁： 还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总 是会发生，<strong>因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。</strong></li>
</ul>
<h2 id="20-Java中想实现一个乐观锁，都有哪些方式？"><a href="#20-Java中想实现一个乐观锁，都有哪些方式？" class="headerlink" title="20.Java中想实现一个乐观锁，都有哪些方式？"></a>20.Java中想实现一个乐观锁，都有哪些方式？</h2><ol>
<li><strong>CAS（Compare and Swap）操作：</strong> CAS 是乐观锁的基础。Java 提供了 java.util.concurrent.atomic 包，包含各种原子变量类（如 AtomicInteger、AtomicLong），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁。</li>
<li><strong>版本号控制</strong>：<strong>增加一个版本号字段记录数据更新时候的版本</strong>，每次更新时递增版本号。在更新数据时，同时比较版本号，若当前版本号和更新前获取的版本号一致，则更新成功，否则失败。</li>
<li><strong>时间戳</strong>：使用时间戳记录数据的更新时间，在更新数据时，在比较时间戳。如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败。</li>
</ol>
<h2 id="21-CAS-有什么缺点？"><a href="#21-CAS-有什么缺点？" class="headerlink" title="21.CAS 有什么缺点？"></a>21.CAS 有什么缺点？</h2><p>CAS的缺点主要有3点：</p>
<ul>
<li><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，<strong>当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A</strong>，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。Java中有<strong>AtomicStampedReference</strong>来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</li>
<li><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。</li>
</ul>
<h2 id="22-为什么不能所有的锁都用CAS？"><a href="#22-为什么不能所有的锁都用CAS？" class="headerlink" title="22.为什么不能所有的锁都用CAS？"></a>22.为什么不能所有的锁都用CAS？</h2><p>CAS操作是基于循环重试的机制，如果CAS操作一直未能成功，线程会一直自旋重试，占用CPU资源。在高并发情况下，大量线程自旋会导致CPU资源浪费。</p>
<h2 id="23-CAS-有什么问题，Java是怎么解决的？"><a href="#23-CAS-有什么问题，Java是怎么解决的？" class="headerlink" title="23.CAS 有什么问题，Java是怎么解决的？"></a>23.CAS 有什么问题，Java是怎么解决的？</h2><p>会有 ABA 的问题，变量值在操作过程中先被其他线程从 <strong>A</strong> 修改为 <strong>B</strong>，又被改回 <strong>A</strong>，CAS 无法感知中途变化，导致操作误判为“未变更”。比如：</p>
<ul>
<li>线程1读取变量为<code>A</code>，准备改为<code>C</code>。</li>
<li>此时线程2将变量<code>A</code>→<code>B</code>→<code>A</code>。</li>
<li>线程1的CAS执行时发现仍是<code>A</code>，但状态已丢失中间变化。</li>
</ul>
<p>Java 提供的工具类会在 CAS 操作中增加<strong>版本号（Stamp）或标记</strong>，每次修改都更新版本号，使得即使值相同也能识别变更历史。比如，可以用 AtomicStampedReference 来解决 ABA 问题，通过比对值<strong>和</strong>版本号识别ABA问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference&lt;Integer&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改值并更新版本号</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(<span class="number">100</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前提：当前值=100 且 版本号=0，才会更新为（200,1）</span></span><br></pre></td></tr></table></figure>
<h2 id="24-voliatle关键字有什么作用？"><a href="#24-voliatle关键字有什么作用？" class="headerlink" title="24.voliatle关键字有什么作用？"></a>24.voliatle关键字有什么作用？</h2><p>volatite作用有 2 个：</p>
<ul>
<li><strong>保证变量对所有线程的可见性</strong>。当一个变量被声明为volatile时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，从而确保了多线程环境下对该变量访问的可见性。这意味着一个线程修改了volatile变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。</li>
<li><strong>禁止指令重排序优化</strong>。volatile关键字在Java中主要通过内存屏障来禁止特定类型的指令重排序。<ul>
<li>1）<strong>写-写（Write-Write）屏障</strong>：在对volatile变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。</li>
<li>2）<strong>读-写（Read-Write）屏障</strong>：在对volatile变量执行读操作之后，会插入一个读屏障。它确保了对volatile变量的读操作之后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取到的数据是最新的。</li>
<li>3）<strong>写-读（Write-Read）屏障</strong>：这是最重要的一个屏障，它发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作（包括写操作）都不会被重排序到volatile读之后，同时也确保了volatile读操作之后的所有内存操作（包括读操作）都不会被重排序到volatile写之前。</li>
</ul>
</li>
</ul>
<h2 id="25-指令重排序的原理是什么？"><a href="#25-指令重排序的原理是什么？" class="headerlink" title="25.指令重排序的原理是什么？"></a>25.指令重排序的原理是什么？</h2><p>在执行程序时，为了提高性能，处理器和编译器常常会对指令进行重排序，但是重排序要满足下面 2 个条件才能进行：</p>
<ul>
<li><strong>在单线程环境下不能改变程序运行的结果</strong></li>
<li><strong>存在数据依赖关系的不允许重排序。</strong></li>
</ul>
<p>所以<strong>重排序不会对单线程有影响，只会破坏多线程的执行语义。</strong></p>
<p>我们看这个例子，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面，如果C排到A和B的前面，那么程序的结果将会被改变。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p>
<h2 id="26-volatile可以保证线程安全吗？"><a href="#26-volatile可以保证线程安全吗？" class="headerlink" title="26.volatile可以保证线程安全吗？"></a>26.volatile可以保证线程安全吗？</h2><p>volatile关键字可以保证可见性，<strong>但不能保证原子性</strong>，因此不能完全保证线程安全。volatile关键字用于修饰变量，当一个线程修改了volatile修饰的变量的值，其他线程能够立即看到最新的值，从而避免了线程之间的数据不一致。</p>
<p>但是，volatile并不能解决多线程并发下的复合操作问题，<strong>比如i++这种操作不是原子操作，如果多个线程同时对i进行自增操作，volatile不能保证线程安全。</strong>对于复合操作，需要使用synchronized关键字或者Lock来保证原子性和线程安全。</p>
<h2 id="27-volatile和sychronized比较？"><a href="#27-volatile和sychronized比较？" class="headerlink" title="27.volatile和sychronized比较？"></a>27.volatile和sychronized比较？</h2><p>Synchronized解决了多线程访问共享资源时可能出现的竞态条件和数据不一致的问题，保证了线程安全性。Volatile解决了变量在多线程环境下的可见性和有序性问题，确保了变量的修改对其他线程是可见的。</p>
<ul>
<li>Synchronized: Synchronized是一种排他性的同步机制，保证了多个线程访问共享资源时的互斥性，即<strong>同一时刻只允许一个线程访问共享资源</strong>。通过对代码块或方法添加Synchronized关键字来实现同步。</li>
<li>Volatile: Volatile是一种轻量级的同步机制，用来保证变量的可见性和禁止指令重排序。当一个变量被声明为Volatile时，线程在读取该变量时会直接从内存中读取，而不会使用缓存，同时对该变量的写操作会立即刷回主内存，而不是缓存在本地内存中。</li>
</ul>
<h2 id="28-什么是公平锁和非公平锁？"><a href="#28-什么是公平锁和非公平锁？" class="headerlink" title="28.什么是公平锁和非公平锁？"></a>28.什么是公平锁和非公平锁？</h2><ul>
<li><strong>公平锁：</strong> 指多个线程<strong>按照申请锁的顺序来获取锁</strong>，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点在于各个线程公平平等，每个线程等待一段时间后，都有执行的机会，而它的缺点就在于整体执行速度更慢，吞吐量更小。</li>
<li><strong>非公平锁：</strong> <strong>多个线程加锁时直接尝试获取锁，能抢到锁到直接占有锁</strong>，抢不到才会到等待队列的队尾等待。非公平锁的优势就在于整体执行速度更快，吞吐量更大，但同时也可能产生线程饥饿问题，也就是说如果一直有线程插队，那么在等待队列中的线程可能长时间得不到运行。</li>
</ul>
<h2 id="29-非公平锁吞吐量为什么比公平锁大？"><a href="#29-非公平锁吞吐量为什么比公平锁大？" class="headerlink" title="29.非公平锁吞吐量为什么比公平锁大？"></a>29.非公平锁吞吐量为什么比公平锁大？</h2><ul>
<li><strong>公平锁执行流程</strong>：获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，<strong>锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态</strong>，但线程<strong>每次休眠和恢复都需要从用户态转换成内核态</strong>，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。</li>
<li><strong>非公平锁执行流程</strong>：当线程获取锁时，<strong>会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。</strong>这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。</li>
</ul>
<p>看出公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：<strong>hasQueuedPredecessors() 为 false</strong>，这个方法就是判断在等待队列中是否已经有线程在排队了。</p>
<h2 id="30-什么情况会产生死锁问题？如何解决？"><a href="#30-什么情况会产生死锁问题？如何解决？" class="headerlink" title="30.什么情况会产生死锁问题？如何解决？"></a>30.什么情况会产生死锁问题？如何解决？</h2><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件：互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</li>
<li>持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</li>
<li>不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</li>
<li>环路等待条件：环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</li>
</ul>
<p>例如，线程 A 持有资源 R1 并试图获取资源 R2，而线程 B 持有资源 R2 并试图获取资源 R1，此时两个线程相互等待对方释放资源，从而导致死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread A acquired resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread A acquired resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread B acquired resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread B acquired resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p>
<p>那什么是资源有序分配法呢？线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1737006711792-cd31cdf7-f5e3-4091-8fb7-bde2d5f117bc.webp" alt="null"></p>
<h2 id="31-CAS的类型和使用"><a href="#31-CAS的类型和使用" class="headerlink" title="31.CAS的类型和使用"></a>31.CAS的类型和使用</h2><p><strong>比较并交换</strong>，是一种乐观锁技术，广泛应用于并发编程中，用来实现无锁（lock-free）算法。它不通过传统的互斥锁来保证线程安全，而是通过在操作共享数据前进行检查，并在数据未被其他线程修改的情况下才执行更新。</p>
<p>CAS被认为原子操作，分为三个</p>
<p><strong>内存位置（V）</strong>: 需要被更新的变量的内存地址。</p>
<p><strong>预期原值（A）</strong>: 线程希望该变量当前持有的值。</p>
<p><strong>新值（B）</strong>: 线程希望将变量更新成的值。</p>
<p>如果内存位置 V 的值与预期原值 A 相匹配，那么处理器就会自动地将该位置的值更新为新值 B。否则，不做任何操作。无论更新成功还是失败，都会返回内存位置 V 的最新值。</p>
<p>主要使用的是java.util.concurrent.atomic包下的原子类</p>
<p>AtomicInteger:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个共享的 AtomicInteger 计数器</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程同时调用 incrementAndGet()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    counter.incrementAndGet(); <span class="comment">// 内部使用 CAS 实现原子性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会不断尝试读取当前值，然后将<strong>当前值加 1 作为新值</strong>，再尝试用 CAS 更新。如果 CAS 失败（说明在它读取值之后，有其他线程修改了），它会重试，直到成功为止。</p>
<p>AtomicReference：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; INSTANCE = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋，直到成功</span></span><br><span class="line">            <span class="type">Singleton</span> <span class="variable">current</span> <span class="operator">=</span> INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试设置新实例</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Singleton</span>())) &#123;</span><br><span class="line">                <span class="keyword">return</span> INSTANCE.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原子地更新一个对象引用时，可以使用 <code>AtomicReference</code>。例如，实现一个线程安全的单例模式。</p>
<p>但是存在ABA问题，一个变量 V 初始值为 A。线程 T1 读取到 V 的值为 A。在 T1 执行 CAS 之前，另一个线程 T2 将 V 的值从 A 改为 B，然后又改回了 A。此时，T1 再次执行 CAS 操作，发现 V 的值仍然是 A，认为 V 没有被修改过，于是成功地将 V 更新为新值。然而，实际上 V 已经被其他线程修改过。</p>
<p>对于某些场景，ABA 问题可能导致逻辑上的错误。例如，在链表的头插法中，如果头节点经历了 A -&gt; B -&gt; A 的变化，CAS 可能会成功，但链表的结构可能已经被破坏。</p>
<p>我们可以引入时间戳和版本号或者是布尔标记来解决这个问题，比如AtomicStampedReference<code>和</code>AtomicMarkableReference</p>
<p><code>AtomicStampedReference</code>：引入了一个“版本戳”（stamp）或“时间戳”，每次修改变量时，不仅更新值，还更新版本戳。CAS 操作时，除了比较值，还会比较版本戳。</p>
<p><code>AtomicMarkableReference</code>：引入了一个布尔标记（mark），表示对象是否被逻辑删除过。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="1-多线程打印奇偶数，怎么控制打印的顺序"><a href="#1-多线程打印奇偶数，怎么控制打印的顺序" class="headerlink" title="1.多线程打印奇偶数，怎么控制打印的顺序"></a>1.多线程打印奇偶数，怎么控制打印的顺序</h2><p>可以利用wait()和notify()来控制线程的执行顺序。</p>
<p>以下是一个基于这种方法的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintOddEven</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">printOdd</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt;= MAX_COUNT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">printEven</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt;= MAX_COUNT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printOdd, <span class="string">&quot;OddThread&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printEven, <span class="string">&quot;EvenThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<strong>通过一个共享的锁对象lock来控制两个线程的交替执行</strong>。一个线程负责打印奇数，另一个线程负责打印偶数，<strong>通过wait()和notify()方法来在两个线程之间实现顺序控制。当当前应该打印奇数时，偶数线程会进入等待状态，反之亦然。</strong></p>
<h2 id="2-3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？"><a href="#2-3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？" class="headerlink" title="2.3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？"></a>2.3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？</h2><ul>
<li>创建 3 个并发执行的线程，在每个线程的任务结束时调用 <code>countDown</code> 方法将计数器减 1。</li>
<li>创建第 4 个线程，使用 <code>await</code> 方法等待计数器为 0，即等待其他 3 个线程完成任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CountDownLatch，初始计数为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动 3 个并发线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNumber</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threadNumber + <span class="string">&quot; is working.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟线程执行任务</span></span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threadNumber + <span class="string">&quot; has finished.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动第 4 个线程，等待其他 3 个线程完成</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Waiting for other threads to finish.&quot;</span>);</span><br><span class="line">                <span class="comment">// 等待计数器为 0</span></span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;All threads have finished, this thread starts to work.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码解释</strong>：</p>
<ul>
<li>首先，创建了一个 <code>CountDownLatch</code> 对象 <code>latch</code>，并将其初始计数设置为 3。</li>
<li>然后，使用 <code>for</code> 循环创建并启动 3 个线程。每个线程会执行一些工作（这里使用 <code>Thread.sleep</code> 模拟），在工作完成后，会调用 <code>latch.countDown()</code> 方法，将 <code>latch</code> 的计数减 1。</li>
<li>最后，创建第 4 个线程。这个线程在开始时调用 <code>latch.await()</code> 方法，它会阻塞，直到 <code>latch</code> 的计数为 0，即前面 3 个线程都调用了 <code>countDown()</code> 方法。一旦计数为 0，该线程将继续执行后续任务。</li>
</ul>
<h2 id="3-单例模型既然已经用了synchronized，为什么还要在加volatile？"><a href="#3-单例模型既然已经用了synchronized，为什么还要在加volatile？" class="headerlink" title="3.单例模型既然已经用了synchronized，为什么还要在加volatile？"></a>3.单例模型既然已经用了synchronized，为什么还要在加volatile？</h2><p>使用 <code>synchronized</code> 和 <code>volatile</code> 一起，可以创建一个既线程安全又能正确初始化的单例模式，避免了多线程环境下的各种潜在问题。这是一种比较完善的线程安全的单例模式实现方式，尤其适用于高并发环境。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>synchronized</code> 关键字的作用用于确保在多线程环境下，只有一个线程能够进入同步块（这里是 <code>synchronized (Singleton.class)</code>）。在创建单例对象时，<strong>通过 <code>synchronized</code> 保证了创建过程的线程安全性，避免多个线程同时创建多个单例对象。</strong></p>
<p><code>volatile</code> 确保了对象引用的可见性和创建过程的有序性，避免了由于指令重排序而导致的错误。</p>
<p><code>instance = new Singleton();</code> 这行代码并不是一个原子操作，它实际上可以分解为以下几个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>实例化对象。</li>
<li>将对象引用赋值给 <code>instance</code>。</li>
</ul>
<p><strong>由于 Java 内存模型允许编译器和处理器对指令进行重排序</strong>，在没有 <code>volatile</code> 的情况下，可能会出现重排序，例如先将对象引用赋值给 <code>instance</code>，但对象的实例化操作尚未完成。</p>
<p>这样，其他线程在检查 <code>instance == null</code> 时，会认为单例已经创建，从而得到一个未完全初始化的对象，导致错误。</p>
<p><code>volatile</code> 可以保证变量的可见性和禁止指令重排序。它确保对 <code>instance</code> 的修改对所有线程都是可见的，并且保证了上述三个步骤按顺序执行，避免了在单例创建过程中因指令重排序而导致的问题。</p>
<h2 id="4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？"><a href="#4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？" class="headerlink" title="4.假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？"></a>4.假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</h2><p>在没有任何同步机制的情况下，两个线程并发对同一个整型变量进行 50 次加 1 操作，<strong>最终结果可能是 100，也可能小于 100，最坏的结果是 50，</strong>也就是最终的结果可能是在 [50, 100] 。</p>
<p>小于 100 情况的分析，由于对整型变量的 <code>num++</code> 操作不是原子操作，它实际上包含了三个步骤：<strong>读取变量的值、将值加 1、将新值写回变量。</strong>在多线程环境下，可能会出现线程安全问题。例如，线程 1 和线程 2 同时读取了变量的当前值，然后各自将其加 1，<strong>最后都将相同的新值写回变量，这就导致了一次加 1 操作的丢失。</strong>这种情况会多次发生，最终结果就会小于 100。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式：通过 <code>synchronized</code> 关键字或 <code>ReentrantLock</code> 确保操作的互斥性，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/05/22/java-stack/juc2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/05/22/java-stack/juc2/')">JUC-线程池面试题hot</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/05/22/java-stack/juc2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JUC-线程池面试题hot&amp;url=https://blog.tokenlen.top/2025/05/22/java-stack/juc2/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=c7a8c787-9b70-567b-45ae-27be096b2bc6" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>技术栈<span class="categoryesPageCount">17</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">52</span></a><a class="post-meta__box__tags" href="/tags/juc/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>juc<span class="tagsPageCount">2</span></a><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">17</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712180.jpg?_r_=62f6a317-bd91-3170-d989-fbee8b722509" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/21/mysql/mysqlstack/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=00594d4b-64b2-2f13-607c-c135fb8d2c6d" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mysql进阶技术栈</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/23/javase/javase3/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=fc21cda4-9b16-8a3b-8e76-8c533e62bb97" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">javase面试题目hot2集合</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/06/21/javase/javaweb1/" title="javase面试题目hot2web开发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712175.jpg?_r_=2b27d2b3-ae76-1ef8-3a2b-3ce64efdc59d" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-21</div><div class="title">javase面试题目hot2web开发</div></div></a></div><div><a href="/2025/05/27/java-stack/javasample1/" title="JAVA设计模式面试题目hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712180.jpg?_r_=e79d2f84-77a5-b12b-a771-fd1bb213d31c" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-27</div><div class="title">JAVA设计模式面试题目hot</div></div></a></div><div><a href="/2025/05/25/java-stack/jvm2/" title="JVM-java虚拟机hot面试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837709.jpg?_r_=f5bda6f3-45c7-18b1-d9f4-996757111c79" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-25</div><div class="title">JVM-java虚拟机hot面试</div></div></a></div><div><a href="/2025/05/23/javase/javase3/" title="javase面试题目hot2集合"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=fc21cda4-9b16-8a3b-8e76-8c533e62bb97" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-23</div><div class="title">javase面试题目hot2集合</div></div></a></div><div><a href="/2025/05/19/javase/javase2/" title="javase面试题目hot1基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=658a8ea0-0858-340f-9fcf-aea7136ea757" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-19</div><div class="title">javase面试题目hot1基础</div></div></a></div><div><a href="/2025/05/09/java-stack/juc1/" title="JUC-线程池"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712181.jpg?_r_=3aeec275-b342-71e2-ec7c-095c00e05fb8" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-09</div><div class="title">JUC-线程池</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E8%BF%87%E6%B2%A1%E6%9C%89%EF%BC%9F-%E8%AF%B4%E8%AF%B4%E4%BB%96%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.线程池用过没有？ 说说他的核心参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.</span> <span class="toc-text">2.线程池的拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3.描述一下创建一个线程池，提交任务的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%8D%E5%BE%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">1.4.</span> <span class="toc-text">4.一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%A7%E8%A1%8C%E5%AE%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E9%9D%A2%E8%BF%98%E4%BC%9A%E6%9C%89%E5%87%A0%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">5.执行完第二个任务后，线程池里面还会有几个线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%90%97%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.有线程池参数设置的经验吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%BA0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7.核心线程数设置为0可不可以？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">8.线程池种类有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%80%E8%88%AC%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9.线程池一般是怎么用的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADshutdown-%EF%BC%8CshutdownNow-%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10.线程池中shutdown ()，shutdownNow()这两个方法有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%8F%90%E4%BA%A4%E7%BB%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%92%A4%E5%9B%9E%E5%90%97%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">11.提交给线程池中的任务可以被撤回吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Java-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">1.12.</span> <span class="toc-text">12.Java 中为什么要使用线程池？线程池如何处理异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-java%E9%87%8C%E9%9D%A2%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1.java里面的线程和操作系统的线程一样吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.使用多线程要注意哪些问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%E5%91%A2%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3.保证数据的一致性有哪些方案呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.4.</span> <span class="toc-text">4.线程的创建方式有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B-%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.怎么启动线程 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">2.6.</span> <span class="toc-text">6.如何停止一个线程的运行?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%B0%83%E7%94%A8-interrupt-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84"><span class="toc-number">2.7.</span> <span class="toc-text">7.调用 interrupt 是如何让线程抛出异常的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8.Java线程的状态有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-sleep-%E5%92%8C-wait%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9.sleep 和 wait的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-sleep%E4%BC%9A%E9%87%8A%E6%94%BEcpu%E5%90%97%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">10.sleep会释放cpu吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-blocked%E5%92%8Cwaiting%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text">11.blocked和waiting有啥区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-wait-%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D%E5%88%B0-running-%E7%8A%B6%E6%80%81"><span class="toc-number">2.12.</span> <span class="toc-text">12.wait 状态下的线程如何进行恢复到 running 状态?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-notify-%E5%92%8C-notifyAll-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.13.</span> <span class="toc-text">13.notify 和 notifyAll 的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-notify-%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.14.</span> <span class="toc-text">14.notify 选择哪个线程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">15.不同的线程之间如何通信？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">16.线程间通信方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">17.如何停止一个线程？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-juc%E5%8C%85%E4%B8%8B%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.juc包下你常用的类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.怎么保证多线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3.Java中有哪些常用的锁，在什么场景下使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%8E%E4%B9%88%E5%9C%A8%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%94%A8%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">4.怎么在实践中用锁的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">5.Java 并发工具你知道哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-CountDownLatch-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E8%AE%B2%E4%B8%80%E8%AE%B2%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">6.CountDownLatch 是做什么的讲一讲？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-synchronized%E5%92%8Creentrantlock%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">7.synchronized和reentrantlock及其应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%99%A4%E4%BA%86%E7%94%A8synchronized%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">8.除了用synchronized，还有什么方法可以实现线程同步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-synchronized%E9%94%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">9.synchronized锁静态方法和普通方法区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-synchronized%E5%92%8Creentrantlock%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">10.synchronized和reentrantlock区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">11.怎么理解可重入锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-synchronized-%E6%94%AF%E6%8C%81%E9%87%8D%E5%85%A5%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.12.</span> <span class="toc-text">12.synchronized 支持重入吗？如何实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-syncronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="toc-number">3.13.</span> <span class="toc-text">13.syncronized锁升级的过程讲一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-JVM%E5%AF%B9Synchornized%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">14.JVM对Synchornized的优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BAQS"><span class="toc-number">3.15.</span> <span class="toc-text">15.介绍一下AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-CAS-%E5%92%8C-AQS-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">3.16.</span> <span class="toc-text">16.CAS 和 AQS 有什么关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%A6%82%E4%BD%95%E7%94%A8-AQS-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">17.如何用 AQS 实现一个可重入的公平锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Threadlocal%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%85%B7%E4%BD%93%E9%87%8C%E9%9D%A2%E5%AD%98%E7%9A%84key-value%E6%98%AF%E5%95%A5%EF%BC%8C%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">3.18.</span> <span class="toc-text">18.Threadlocal作用，原理，具体里面存的key value是啥，会有什么问题，如何解决?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.19.</span> <span class="toc-text">19.悲观锁和乐观锁的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Java%E4%B8%AD%E6%83%B3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">20.Java中想实现一个乐观锁，都有哪些方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">3.21.</span> <span class="toc-text">21.CAS 有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%89%80%E6%9C%89%E7%9A%84%E9%94%81%E9%83%BD%E7%94%A8CAS%EF%BC%9F"><span class="toc-number">3.22.</span> <span class="toc-text">22.为什么不能所有的锁都用CAS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8CJava%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">3.23.</span> <span class="toc-text">23.CAS 有什么问题，Java是怎么解决的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-voliatle%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.24.</span> <span class="toc-text">24.voliatle关键字有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.25.</span> <span class="toc-text">25.指令重排序的原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-volatile%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">3.26.</span> <span class="toc-text">26.volatile可以保证线程安全吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-volatile%E5%92%8Csychronized%E6%AF%94%E8%BE%83%EF%BC%9F"><span class="toc-number">3.27.</span> <span class="toc-text">27.volatile和sychronized比较？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="toc-number">3.28.</span> <span class="toc-text">28.什么是公平锁和非公平锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E5%85%AC%E5%B9%B3%E9%94%81%E5%A4%A7%EF%BC%9F"><span class="toc-number">3.29.</span> <span class="toc-text">29.非公平锁吞吐量为什么比公平锁大？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">3.30.</span> <span class="toc-text">30.什么情况会产生死锁问题？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-CAS%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">3.31.</span> <span class="toc-text">31.CAS的类型和使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1.多线程打印奇偶数，怎么控制打印的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%EF%BC%8C1%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E8%BF%99%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%A8%E9%83%A8%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%9C%A8%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B%E6%97%A2%E7%84%B6%E5%B7%B2%E7%BB%8F%E7%94%A8%E4%BA%86synchronized%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%9C%A8%E5%8A%A0volatile%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3.单例模型既然已经用了synchronized，为什么还要在加volatile？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%81%87%E8%AE%BE%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%80%BC%E4%B8%BA%E9%9B%B6%EF%BC%8C%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8A%A0-50-%E6%AC%A1%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4.假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/06/leetcode/leetcodehot2/" title="Leetcode HOT面试题目2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712180.jpg?_r_=62f6a317-bd91-3170-d989-fbee8b722509" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode HOT面试题目2"/></a><div class="content"><a class="title" href="/2025/07/06/leetcode/leetcodehot2/" title="Leetcode HOT面试题目2">Leetcode HOT面试题目2</a><time datetime="2025-07-05T16:00:00.000Z" title="发表于 2025-07-06 00:00:00">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/06/new-stack/MQ2/" title="MQ面试场景题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712179.jpg?_r_=adb2204d-8826-c84f-f866-fe68ee2c374c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MQ面试场景题"/></a><div class="content"><a class="title" href="/2025/07/06/new-stack/MQ2/" title="MQ面试场景题">MQ面试场景题</a><time datetime="2025-07-05T16:00:00.000Z" title="发表于 2025-07-06 00:00:00">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/06/new-stack/es1/" title="Elasticsearch"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712179.jpg?_r_=f6dbd26d-6e93-db2b-423d-e2b729c3e688" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Elasticsearch"/></a><div class="content"><a class="title" href="/2025/07/06/new-stack/es1/" title="Elasticsearch">Elasticsearch</a><time datetime="2025-07-05T16:00:00.000Z" title="发表于 2025-07-06 00:00:00">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/workmenu/dianping1/" title="黑马点评项目逻辑功能分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=9af9b769-28a8-8a86-62fe-5b7bd2fac405" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="黑马点评项目逻辑功能分析"/></a><div class="content"><a class="title" href="/2025/07/01/workmenu/dianping1/" title="黑马点评项目逻辑功能分析">黑马点评项目逻辑功能分析</a><time datetime="2025-06-30T16:00:00.000Z" title="发表于 2025-07-01 00:00:00">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/workmenu/dianping2/" title="黑马点评项目知识分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712178.jpg?_r_=4fe195fd-e740-9618-5aa7-7a376f8c9bd9" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="黑马点评项目知识分析"/></a><div class="content"><a class="title" href="/2025/07/01/workmenu/dianping2/" title="黑马点评项目知识分析">黑马点评项目知识分析</a><time datetime="2025-06-30T16:00:00.000Z" title="发表于 2025-07-01 00:00:00">2025-07-01</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">147</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">25</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 0.88rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem;">CSRF<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 0.88rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 0.88rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>52</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>9</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>6</sup></a><a href="/tags/paper/" style="font-size: 0.88rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 0.88rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>3</sup></a><a href="/tags/rocketmq/" style="font-size: 0.88rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>2</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>13</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>19</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>17</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>