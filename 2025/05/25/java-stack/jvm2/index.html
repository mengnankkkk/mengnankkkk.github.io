<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JVM-java虚拟机hot面试 | mengnankkのblog</title><meta name="keywords" content="java,面试,jvm"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JVM-java虚拟机hot面试"><meta name="application-name" content="JVM-java虚拟机hot面试"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="JVM-java虚拟机hot面试"><meta property="og:url" content="https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="内存模型1.JVM的内存模型介绍一下根据 JDK 8 规范，JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。 JVM的内存结构主要分为以下几个部分：  程序计数器：可以看作是当前线程所执行的字节码的行"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722377.jpg?_r_=7cc40298-e708-fe8e-3db9-7130a1cbad28"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722377.jpg?_r_=7cc40298-e708-fe8e-3db9-7130a1cbad28"><meta name="description" content="内存模型1.JVM的内存模型介绍一下根据 JDK 8 规范，JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。 JVM的内存结构主要分为以下几个部分：  程序计数器：可以看作是当前线程所执行的字节码的行"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: 'JVM-java虚拟机hot面试',
  postAI: '',
  pageFillDescription: '内存模型, 1.JVM的内存模型介绍一下, 2.JVM内存模型里的堆和栈有什么区别？, 3.栈中存的到底是指针还是对象？, 4.堆分为哪几部分呢？, 5.如果有个大对象一般是在哪个区域？, 6.程序计数器的作用为什么是私有的？, 7.方法区中的方法的执行过程？, 8.HotSpot 为什么要分为新生代和老年代？, 9.方法区中还有哪些东西？, 10.String保存在哪里呢？, 11.String s = new String（abc）执行过程中分别对应哪些内存区域？, 引用, 1.为什么软引用可以防止内存溢出, 2.引用类型有哪些？有什么区别？, 3.弱引用了解吗?举例说明在哪里可以用?, 4.内存泄漏和内存溢出的理解？, 5.jvm 内存结构有哪几种内存溢出的情况？, 6.有具体的内存泄漏和内存溢出的例子么请举例及解决方案?, 类的加载, 1.创建对象的过程？, 2.对象的生命周期, 3.类加载器有哪些？, 3.双亲委派模型的作用, 4.讲一下类加载过程？, , 5.讲一下类的加载和双亲委派原则, 垃圾回收算法, 1.什么是Java里的垃圾回收？如何触发垃圾回收？, 2.判断垃圾的方法有哪些？, 3.垃圾回收算法是什么是为了解决了什么问题？, 4.垃圾回收算法有哪些？, 5.垃圾回收器有哪些？, 6.标记清除算法的缺点是什么？, 7.垃圾回收算法哪些阶段会stop the world?, 8.minorGC、majorGC、fullGC的区别什么场景触发full GC, 9.垃圾回收器 CMS 和 G1的区别？, 10.什么情况下使用CMS什么情况使用G1?, 11.G1回收器的特色是什么？, 12.GC只会对堆进行GC吗？内存模型的内存模型介绍一下根据规范运行时内存共分为虚拟机栈堆元空间程序计数器本地方法栈五个部分还有一部分内存叫直接内存属于操作系统的本地内存也是可以直接操作的的内存结构主要分为以下几个部分程序计数器可以看作是当前线程所执行的字节码的行号指示器用于存储当前线程正在执行的方法的指令地址相当于指针如果线程执行的是方法计数器值为是唯一一个在虚拟机规范中没有规定任何情况的区域生命周期与线程相同虚拟机栈每个线程都有自己独立的虚拟机栈生命周期与线程相同每个方法在执行时都会创建一个栈帧用于存储局部变量表操作数栈动态链接方法出口等信息可能会抛出和异常本地方法栈与虚拟机栈类似主要为虚拟机使用到的方法服务在虚拟机中和虚拟机栈合二为一本地方法执行时也会创建栈帧同样可能出现和两种错误堆是中最大的一块内存区域被所有线程共享在虚拟机启动时创建用于存放对象实例从内存回收角度堆被划分为新生代和老年代新生代又分为区和两个区和如果在堆中没有内存完成实例分配并且堆也无法扩展时会抛出异常方法区元空间在及以后的版本中方法区被元空间取代使用本地内存用于存储已被虚拟机加载的类信息常量静态变量等数据虽然方法区被描述为堆的逻辑部分但有非堆的别名方法区可以选择不实现垃圾收集内存不足时会抛出异常运行时常量池是方法区的一部分用于存放编译期生成的各种字面量和符号引用具有动态性运行时也可将新的常量放入池中当无法申请到足够内存时会抛出异常直接内存不属于运行时数据区的一部分通过类引入是一种堆外内存可以显著提高性能直接内存的使用受到本机总内存的限制若分配不当可能导致异常内存模型里的堆和栈有什么区别用途栈主要用于存储局部变量方法调用的参数方法返回地址以及一些临时数据每当一个方法被调用一个栈帧就会在栈中创建用于存储该方法的信息当方法执行完毕栈帧也会被移除堆用于存储对象的实例包括类的实例和数组当你使用关键字创建一个对象时对象的实例就会在堆上分配空间生命周期栈中的数据具有确定的生命周期当一个方法调用结束时其对应的栈帧就会被销毁栈中存储的局部变量也会随之消失堆中的对象生命周期不确定对象会在垃圾回收机制检测到对象不再被引用时才被回收存取速度栈的存取速度通常比堆快因为栈遵循先进后出的原则操作简单快速堆的存取速度相对较慢因为对象在堆上的分配和回收需要更多的时间而且垃圾回收机制的运行也会影响性能存储空间栈的空间相对较小且固定由操作系统管理当栈溢出时通常是因为递归过深或局部变量过大堆的空间较大动态扩展由管理堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象可见性栈中的数据对线程是私有的每个线程有自己的栈空间堆中的数据对线程是共享的所有线程都可以访问堆上的对象栈中存的到底是指针还是对象在内存模型中栈主要用于管理线程的局部变量和方法调用的上下文而堆则是用于存储所有类的实例和数组当我们在栈中讨论存储时实际上指的是存储基本类型的数据如等和对象的引用而不是对象本身这里的关键点是栈中存储的不是对象而是对象的引用也就是说当你在方法中声明一个对象比如这里的实际上是一个存储在栈上的引用指向堆中实际的对象实例这个引用是一个固定大小的数据例如在位系统上是字节它指向堆中分配给对象的内存区域堆分为哪几部分呢堆是虚拟机中内存管理的一个重要区域主要用于存放对象实例和数组随着的发展和不同垃圾收集器的实现堆的具体划分可能会有所不同但通常可以分为以下几个部分新生代新生代分为和在中大多数新创建的对象首先存放在这里区相对较小当区满时会触发一次新生代垃圾回收在中通常分为两个相等大小的区域称为和在每次后存活下来的对象会被移动到其中一个空间以继续它们的生命周期这两个区域轮流充当对象的中转站帮助区分短暂存活的对象和长期存活的对象老年代存放过一次或多次仍存活的对象会被移动到老年代老年代中的对象生命周期较长因此也称为涉及老年代的垃圾回收发生的频率相对较低但其执行时间通常比长老年代的空间通常比新生代大以存储更多的长期存活对象元空间从开始永久代被元空间取代用于存储类的元数据信息如类的结构信息如字段方法信息等元空间并不在堆中而是使用本地内存这解决了永久代容易出现的内存溢出问题大对象区在某些实现中如垃圾收集器为大对象分配了专门的区域称为大对象区或区域大对象是指需要大量连续内存空间的对象如大数组这类对象直接分配在老年代以避免因频繁的年轻代晋升而导致的内存碎片化问题如果有个大对象一般是在哪个区域大对象通常会直接分配到老年代新生代主要用于存放生命周期较短的对象并且其内存空间相对较小如果将大对象分配到新生代可能会很快导致新生代空间不足从而频繁触发而每次都需要进行对象的复制和移动操作这会带来一定的性能开销将大对象直接分配到老年代可以减少新生代的内存压力降低的频率大对象通常需要连续的内存空间如果在新生代中频繁分配和回收大对象容易产生内存碎片导致后续分配大对象时可能因为内存不连续而失败老年代的空间相对较大更适合存储大对象有助于减少内存碎片的产生程序计数器的作用为什么是私有的程序是支持多线程一起运行的多个线程一起运行的时候会有一个调动器组件给它们分配时间片比如说会给线程分给一个时间片它在时间片内如果它的代码没有执行完它就会把线程的状态执行一个暂存切换到线程去执行线程的代码等线程的代码执行到了一定程度线程的时间片用完了再切换回来再继续执行线程剩余部分的代码我们考虑一下如果在线程切换的过程中下一条指令执行到哪里了是不是还是会用到我们的程序计数器啊每个线程都有自己的程序计数器因为它们各自执行的代码的指令地址是不一样的呀所以每个线程都应该有自己的程序计数器方法区中的方法的执行过程当程序中通过对象或类直接调用某个方法时主要包括以下几个步骤解析方法调用会根据方法的符号引用找到实际的方法地址如果之前没有解析过的话栈帧创建在调用一个方法前会在当前线程的虚拟机栈中为该方法分配一个新的栈帧用于存储局部变量表操作数栈动态链接方法出口等信息执行方法执行方法内的字节码指令涉及的操作可能包括局部变量的读写操作数栈的操作跳转控制对象创建方法调用等返回处理方法执行完毕后可能会返回一个结果给调用者并清理当前栈帧恢复调用者的执行环境为什么要分为新生代和老年代将堆内存划分为新生代和老年代是为了利用对象生命周期的差异来优化垃圾回收性能大多数对象生命周期短适合在新生代中用高效的复制算法快速回收少量长寿命对象存放在老年代减少回收频率分代设计能有效缩短停顿时间提高吞吐量避免每次都扫描整个堆从而提升整体系统运行效率方法区中还有哪些东西它用于存储已被虚拟机加载的类型信息常量静态变量即时编译器编译后的代码缓存等类信息包括类的结构信息类的访问修饰符父类与接口等信息常量池存储类和接口中的常量包括字面值常量符号引用以及运行时常量池静态变量存储类的静态变量这些变量在类初始化的时候被赋值方法字节码存储类的方法字节码即编译后的代码符号引用存储类和方法的符号引用是一种直接引用不同于直接引用的引用类型运行时常量池存储着在类文件中的常量池数据在类加载后在方法区生成该运行时常量池常量池缓存用于提升类加载的效率将常用的常量缓存起来方便使用保存在哪里呢保存在字符串常量池中不同于其他对象它的值是不可变的且可以被多个引用共享执行过程中分别对应哪些内存区域首先我们看到这个代码中有一个关键字我们知道指令是创建一个类的实例对象并完成加载初始化的因此这个字符串对象是在运行期才能确定的创建的字符串对象是在堆内存上其次在的构造方法中传递了一个字符串由于这里的是被修饰的属性所以它是一个字符串常量在首次构建这个对象时拿字面量去字符串常量池试图获取其对应对象的引用于是在堆中创建了一个的对象并将其引用保存到字符串常量池中然后返回所以如果这个字符串常量不存在则创建两个对象分别是这个字符串常量以及这个实例对象如果这字符串常量存在则只会创建一个对象引用为什么软引用可以防止内存溢出减轻内存压力软引用对象在内存紧张时会被回收这意味着对于一些缓存型对象如图片缓存数据缓存使用软引用能让在不影响系统运行的前提下自动清理不重要的对象避免这些对象一直占用内存导致有利于缓存系统的实现比如在图片浏览器数据库连接池网页浏览器中常常需要缓存大量数据使用软引用作为缓存的基础可以确保缓存不会占用过多堆内存系统空闲时缓存仍可用一旦内存紧张缓存自动释放系统依旧安全运行相比强引用更灵活相比弱引用更安全引用类型回收时机是否适合做缓存对系统安全性的影响强引用永不回收除非没有引用会导致高风险弱引用时就回收不适合稳定但易失效软引用内存不足时回收非常适合安全可靠为什么弱引用虚引用用得少弱引用一旦触发不管内存够不够都会被回收太激进不适合缓存虚引用更偏底层用于监控对象被回收的时机不具备访问能力需要配合使用复杂度高引用类型有哪些有什么区别引用类型主要分为强软弱虚四种强引用指的就是代码中普遍存在的赋值方式比如这种强引用关联的对象永远不会被回收就是一个对象软引用可以用来描述指的是那些有用但是不是必须要的对象系统在发生内存溢出前会对这类引用的对象进行回收弱引用可以用来描述他的强度比软引用更低一点弱引用的对象下一次的时候一定会被回收而不管内存是否足够虚引用也被称作幻影引用是最弱的引用关系可以用来描述他必须和一起使用同样的当发生的时候虚引用也会被回收可以用虚引用来管理堆外内存弱引用了解吗举例说明在哪里可以用中的弱引用是一种引用类型它不会阻止一个对象被垃圾回收在中弱引用是通过类实现的弱引用的一个主要用途是创建非强制性的对象引用这些引用可以在内存压力大时被垃圾回收器清理从而避免内存泄露弱引用的使用场景缓存系统弱引用常用于实现缓存特别是当希望缓存项能够在内存压力下自动释放时如果缓存的大小不受控制可能会导致内存溢出使用弱引用来维护缓存可以让在需要更多内存时自动清理这些缓存对象对象池在对象池中弱引用可以用来管理那些暂时不使用的对象当对象不再被强引用时它们可以被垃圾回收释放内存避免内存泄露当一个对象不应该被长期引用时使用弱引用可以防止该对象被意外地保留从而避免潜在的内存泄露示例代码假设我们有一个缓存系统我们使用弱引用来维护缓存中的对象假设是一个占用大量内存的对象在这个例子中使用来存储实例当内存压力增大时垃圾回收器可以自由地回收这些对象而不会影响缓存的正常运行如果一个对象被垃圾回收下次尝试从缓存中获取时方法会返回这时我们可以重新创建对象并将其放入缓存中因此使用弱引用时要注意一旦对象被垃圾回收通过弱引用获取的对象可能会变为因此在使用前通常需要检查这一点特性软引用弱引用回收时机内存不足时才回收下一次就可能回收存活时间相对更长非常短随时可能被清除适合场景缓存保留尽可能多对象映射辅助引用监听器等安全性更高内存紧张时才回收更低不稳定随时可能为被使用的典型类底层内存泄漏和内存溢出的理解内存泄露内存泄漏是指程序在运行过程中不再使用的对象仍然被引用而无法被垃圾收集器回收从而导致可用内存逐渐减少虽然在中垃圾回收机制会自动回收不再使用的对象但如果有对象仍被不再使用的引用持有垃圾收集器无法回收这些内存最终可能导致程序的内存使用不断增加内存泄露常见原因静态集合使用静态数据结构如或存储对象且未清理事件监听未取消对事件源的监听导致对象持续被引用线程未停止的线程可能持有对象引用无法被回收内存溢出内存溢出是指虚拟机在申请内存时无法找到足够的内存最终引发这通常发生在堆内存不足以存放新创建的对象时内存溢出常见原因大量对象创建程序中不断创建大量对象超出堆的限制持久引用大型数据结构如缓存集合等长时间持有对象引用导致内存累积递归调用深度递归导致栈溢出内存泄漏是还没满内存溢出是已经满了内存结构有哪几种内存溢出的情况堆内存溢出当出现异常时就是堆内存溢出了原因是代码中可能存在大对象分配或者发生了内存泄露导致在多次之后还是无法找到一块足够大的内存容纳当前对象栈溢出如果我们写一段程序不断的进行递归调用而且没有退出条件就会导致不断地进行压栈类似这种情况实际会抛出当然如果试图去扩展栈空间的的时候失败则会抛出元空间溢出元空间的溢出系统会抛出出现这个异常的问题的原因是系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法导致元空间的内存占用很大直接内存内存溢出在使用中的的时候会用到很多像的框架中被封装为其他的方法出现该问题时会抛出异常除了程序计数器都会出现有具体的内存泄漏和内存溢出的例子么请举例及解决方案静态属性导致内存泄露会导致内存泄露的一种情况就是大量使用静态变量在中静态属性的生命周期通常伴随着应用整个生命周期除非符合垃圾回收的条件下面来看一个具体的会导致内存泄露的实例如果监控内存堆内存的变化会发现在打印和之间堆内存会有一个明显的增长趋势图但当执行完方法之后对堆内存并没有被垃圾回收器进行回收但针对上述程序如果将定义的变量前的关键字去掉再次执行程序会发现内存发生了具体的变化监控信息如下图对比两个图可以看出程序执行的前半部分内存使用情况都一样但当执行完方法之后后者不再有引用指向对应的数据垃圾回收器便进行了回收操作因此我们要十分留意的变量如果集合或大量的对象定义为的它们会停留在整个应用程序的生命周期当中而它们所占用的内存空间本可以用于其他地方那么如何优化呢第一进来减少静态变量第二如果使用单例尽量采用懒加载未关闭的资源无论什么时候当我们创建一个连接或打开一个流都会分配内存给这些资源比如数据库链接输入流和对象忘记关闭这些资源会阻塞内存从而导致无法进行清理特别是当程序发生异常时没有在中进行资源关闭的情况这些未正常关闭的连接如果不进行处理轻则影响程序性能重则导致异常发生如果进行处理呢第一始终记得在中进行资源的关闭第二关闭连接的自身代码不能发生异常第三以上版本可使用代码方式进行资源关闭中定义的对象必须实现接口也可以间接继承块执行完后会自动调用这些资源的方法使用提供了线程本地变量它可以保证访问到的变量属于当前线程每个线程都保存有一个变量副本每个线程的变量都不同相当于提供了一种线程隔离将变量与线程相绑定从而实现线程安全的特性的实现中每个维护一个映射表是实例本身是真正需要存储的使用的弱引用作为如果一个没有外部强引用来引用它那么系统时这个势必会被回收这样一来中就会出现为的就没有办法访问这些为的的如果当前线程迟迟不结束的话这些为的的就会一直存在一条强引用链永远无法回收造成内存泄漏如何解决此问题第一使用提供的方法可对当前线程中的值进行移除第二不要使用的方式清除它实际上并没有清除值而是查找与当前线程关联的并将键值对分别设置为当前线程和第三最好将视为需要在块中关闭的资源以确保即使在发生异常的情况下也始终关闭该资源类的加载创建对象的过程在中创建对象的过程包括以下几个步骤类加载检查虚拟机遇到一条指令时首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用并且检查这个符号引用代表的类是否已被加载过解析和初始化过如果没有那必须先执行相应的类加载过程分配内存在类加载检查通过后接下来虚拟机将为新生对象分配内存对象所需的内存大小在类加载完成后便可确定为对象分配空间的任务等同于把一块确定大小的内存从堆中划分出来初始化零值内存分配完成后虚拟机需要将分配到的内存空间都初始化为零值不包括对象头这一步操作保证了对象的实例字段在代码中可以不赋初始值就直接使用程序能访问到这些字段的数据类型所对应的零值进行必要设置比如对象头初始化零值完成之后虚拟机要对对象进行必要的设置例如这个对象是哪个类的实例如何才能找到类的元数据信息对象的哈希码对象的分代年龄等信息这些信息存放在对象头中另外根据虚拟机当前运行状态的不同如是否启用偏向锁等对象头会有不同的设置方式执行方法在上面工作都完成之后从虚拟机的视角来看一个新的对象已经产生了但从程序的视角来看对象创建才刚开始构造函数即文件中的方法还没有执行所有的字段都还为零对象需要的其他资源和状态信息还没有按照预定的意图构造好所以一般来说执行指令之后会接着执行方法把对象按照程序员的意愿进行初始化这样一个真正可用的对象才算完全被构造出来对象的生命周期对象的生命周期包括创建使用和销毁三个阶段创建对象通过关键字在堆内存中被实例化构造函数被调用对象的内存空间被分配使用对象被引用并执行相应的操作可以通过引用访问对象的属性和方法在程序运行过程中被不断使用销毁当对象不再被引用时通过垃圾回收机制自动回收对象所占用的内存空间垃圾回收器会在适当的时候检测并回收不再被引用的对象释放对象占用的内存空间完成对象的销毁过程类加载器有哪些启动类加载器这是最顶层的类加载器负责加载的核心库如位于中的类它是用编写的是的一部分启动类加载器无法被程序直接引用扩展类加载器它是语言实现的继承自类负责加载扩展目录或由系统变量指定的目录下的包和类库扩展类加载器由启动类加载器加载并且父加载器就是启动类加载器系统类加载器应用程序类加载器这也是语言实现的负责加载用户类路径上的指定类库是我们平时编写程序时默认使用的类加载器系统类加载器的父加载器是扩展类加载器它可以通过方法获取到自定义类加载器开发者可以根据需求定制类的加载方式比如从网络加载文件数据库甚至是加密的文件中加载类等自定义类加载器可以用来扩展应用程序的灵活性和安全性是动态性的一个重要体现这些类加载器之间的关系形成了双亲委派模型其核心思想是当一个类加载器收到类加载的请求时首先不会自己去尝试加载这个类而是把这个请求委派给父类加载器去完成每一层次的类加载器都是如此因此所有的加载请求最终都应该传送到顶层的启动类加载器中只有当父加载器反馈自己无法完成这个加载请求它的搜索范围中没有找到所需的类时子加载器才会尝试自己去加载双亲委派模型的作用保证类的唯一性通过委托机制确保了所有加载请求都会传递到启动类加载器避免了不同类加载器重复加载相同类的情况保证了核心类库的统一性也防止了用户自定义类覆盖核心类库的可能保证安全性由于核心库被启动类加载器加载而启动类加载器只加载信任的类路径中的类这样可以防止不可信的类假冒核心类增强了系统的安全性例如恶意代码无法自定义一个类并加载到中因为这个请求会被委托给启动类加载器而启动类加载器只会加载标准的库中的类支持隔离和层次划分双亲委派模型支持不同层次的类加载器服务于不同的类加载需求如应用程序类加载器加载用户代码扩展类加载器加载扩展框架启动类加载器加载核心库这种层次化的划分有助于实现沙箱安全机制保证了各个层级类加载器的职责清晰也便于维护和扩展简化了加载流程通过委派大部分类能够被正确的类加载器加载减少了每个加载器需要处理的类的数量简化了类的加载过程提高了加载效率讲一下类加载过程加载通过类的全限定名包名类名获取到该类的文件的二进制字节流将二进制字节流所代表的静态存储结构转化为方法区运行时的数据结构在内存中生成一个代表该类的对象作为方法区这个类的各种数据的访问入口连接验证准备解析个阶段统称为连接验证确保文件中的字节流包含的信息符合当前虚拟机的要求保证这个被加载的类的正确性不会危害到虚拟机的安全验证阶段大致会完成以下四个阶段的检验动作文件格式校验元数据验证字节码验证符号引用验证准备为类中的静态字段分配内存并设置默认的初始值比如类型初始值是被修饰的字段不会设置因为在编译的时候就分配了解析解析阶段是虚拟机将常量池的符号引用直接替换为直接引用的过程符号引用是以一组符号来描述所引用的目标符号可以是任何形式的字面量只要使用的时候可以无歧义地定位到目标即可直接引用可以是直接指向目标的指针相对偏移量或是一个能间接定位到目标的句柄直接引用是和虚拟机实现的内存布局相关的如果有了直接引用那引用的目标必定已经存在在内存中了初始化初始化是整个类加载过程的最后一个阶段初始化阶段简单来说就是执行类的构造器方法要注意的是这里的构造器方法并不是开发者写的而是编译器自动生成的使用使用类或者创建对象卸载如果有下面的情况类就会被卸载该类所有的实例都已经被回收也就是堆中不存在该类的任何实例加载该类的已经被回收类对应的对象没有任何地方被引用无法在任何地方通过反射访问该类的方法讲一下类的加载和双亲委派原则我们把的类加载过程分为三个主要步骤加载链接初始化首先是加载阶段它是将字节码数据从不同的数据源读取到中并映射为认可的数据结构对象这里的数据源可能是各种各样的形态如文件文件甚至是网络数据源等如果输入数据不是的结构则会抛出加载阶段是用户参与的阶段我们可以自定义类加载器去实现自己的类加载过程第二阶段是链接这是核心的步骤简单说是把原始的类定义信息平滑地转化入运行的过程中这里可进一步细分为三个步骤验证这是虚拟机安全的重要保障需要核验字节信息是符合虚拟机规范的否则就被认为是这样就防止了恶意信息或者不合规的信息危害的运行验证阶段有可能触发更多的加载准备创建类或接口中的静态变量并初始化静态变量的初始值但这里的初始化和下面的显式初始化阶段是有区别的侧重点在于分配所需要的内存空间不会去执行更进一步的指令解析在这一步会将常量池中的符号引用替换为直接引用最后是初始化阶段这一步真正去执行类初始化的代码逻辑包括静态字段赋值的动作以及执行类定义中的静态初始化块内的逻辑编译器在编译阶段就会把这部分逻辑整理好父类型的初始化逻辑优先于当前类型的逻辑再来谈谈双亲委派模型简单说就是当类加载器试图加载某个类型的时候除非父加载器找不到相应类型否则尽量将这个任务代理给当前加载器的父加载器去做使用委派模型的目的是避免重复加载类型垃圾回收算法什么是里的垃圾回收如何触发垃圾回收垃圾回收是自动管理内存的一种机制它负责自动释放不再被程序引用的对象所占用的内存这种机制减少了内存泄漏和内存管理错误的可能性垃圾回收可以通过多种方式触发具体如下内存不足时当检测到堆内存不足无法为新的对象分配内存时会自动触发垃圾回收手动请求虽然垃圾回收是自动的开发者可以通过调用或建议进行垃圾回收不过这只是一个建议并不能保证立即执行参数启动应用时可以通过参数来调整垃圾回收的行为比如最大堆大小初始堆大小等对象数量或内存使用达到阈值垃圾收集器内部实现了一些策略以监控对象的创建和内存使用达到某个阈值时触发垃圾回收判断垃圾的方法有哪些在中判断对象是否为垃圾即不再被使用可以被垃圾回收器回收主要依据两种主流的垃圾回收算法来实现引用计数法和可达性分析算法引用计数法原理为每个对象分配一个引用计数器每当有一个地方引用它时计数器加当引用失效时计数器减当计数器为时表示对象不再被任何变量引用可以被回收缺点不能解决循环引用的问题即两个对象相互引用但不再被其他任何对象引用这时引用计数器不会为导致对象无法被回收可达性分析算法虚拟机主要采用此算法来判断对象是否为垃圾原理从一组称为垃圾收集根的对象出发向下追溯它们引用的对象以及这些对象引用的其他对象以此类推如果一个对象到没有任何引用链相连即从到这个对象不可达那么这个对象就被认为是不可达的可以被回收对象包括虚拟机栈栈帧中的本地变量表中引用的对象方法区中类静态属性引用的对象本地方法栈中引用的对象活跃线程的引用等垃圾回收算法是什么是为了解决了什么问题有垃圾回收机制的原因是为了解决内存管理的问题在传统的编程语言中开发人员需要手动分配和释放内存这可能导致内存泄漏内存溢出等问题而作为一种高级语言旨在提供更简单更安全的编程环境因此引入了垃圾回收机制来自动管理内存垃圾回收机制的主要目标是自动检测和回收不再使用的对象从而释放它们所占用的内存空间这样可以避免内存泄漏一些对象被分配了内存却无法被释放导致内存资源的浪费同时垃圾回收机制还可以防止内存溢出即程序需要的内存超过了可用内存的情况通过垃圾回收机制可以在程序运行时自动识别和清理不再使用的对象使得开发人员无需手动管理内存这样可以提高开发效率减少错误并且使程序更加可靠和稳定垃圾回收算法有哪些标记清除算法标记清除算法分为标记和清除两个阶段首先通过可达性分析标记出所有需要回收的对象然后统一回收所有被标记的对象标记清除算法有两个缺陷一个是效率问题标记和清除的过程效率都不高另外一个就是清除结束后会造成大量的碎片空间有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次复制算法为了解决碎片空间的问题出现了复制算法复制算法的原理是将内存分成两块每次申请内存时都使用其中的一块当内存不够时将这一块内存中所有存活的复制到另一块上然后将然后再把已使用的内存整个清理掉复制算法解决了空间碎片的问题但是也带来了新的问题因为每次在申请内存时都只能使用一半的内存空间内存利用率严重不足标记整理算法复制算法在之后存活对象较少的情况下效率比较高但如果存活对象比较多时会执行较多的复制操作效率就会下降而老年代的对象在之后的存活率就比较高所以就有人提出了标记整理算法标记整理算法的标记过程与标记清除算法的标记过程一致但标记之后不会直接清理而是将所有存活对象都移动到内存的一端移动结束后直接清理掉剩余部分分代回收算法分代收集是将内存划分成了新生代和老年代分配的依据是对象的生存周期或者说经历过的次数对象创建时一般在新生代申请内存当经历一次之后如果对还存活那么对象的年龄当年龄超过一定值默认是可以通过参数来设定后如果对象还存活那么该对象会进入老年代比如新生代我们使用复制算法效率较高老年代使用标记整理算法更好垃圾回收器有哪些标记清除算法的缺点是什么主要缺点有两个一个是效率问题标记和清除过程的效率都不高另外一个是空间问题标记清除之后会产生大量不连续的内存碎片空间碎片太多可能会导致当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作垃圾回收算法哪些阶段会标记复制算法应用在新生代是默认的新生代垃圾回收器和垃圾回收器中标记复制算法可以分为三个阶段标记阶段即从集合开始标记活跃对象转移阶段即把活跃对象复制到新的内存地址上重定位阶段因为转移导致对象的地址发生了变化在重定位阶段所有指向对象旧地址的指针都要调整到对象新的地址上下面以为例通过中标记复制算法过程的和均采用该算法分析停顿耗时的主要瓶颈垃圾回收周期如下图所示的混合回收过程可以分为标记阶段清理阶段和复制阶段标记阶段停顿分析初始标记阶段初始标记阶段是指从出发标记全部直接子节点的过程该阶段是的由于数量不多通常该阶段耗时非常短并发标记阶段并发标记阶段是指从开始对堆中对象进行可达性分析找出存活对象该阶段是并发的即应用线程和线程可以同时活动并发标记耗时相对长很多但因为不是所以我们不太关心该阶段耗时的长短再标记阶段重新标记那些在并发标记阶段发生变化的对象该阶段是的清理阶段停顿分析清理阶段清点出有存活对象的分区和没有存活对象的分区该阶段不会清理垃圾对象也不会执行存活对象的复制该阶段是的复制阶段停顿分析复制算法中的转移阶段需要分配新内存和复制对象的成员变量转移阶段是的其中内存分配通常耗时非常短但对象成员变量的复制耗时有可能较长这是因为复制耗时与存活对象数量与对象复杂度成正比对象越复杂复制耗时越长四个过程中初始标记因为只标记耗时较短再标记因为对象数少耗时也较短清理阶段因为内存分区数量少耗时也较短转移阶段要处理所有存活的对象耗时会较长因此停顿时间的瓶颈主要是标记复制中的转移阶段的区别什么场景触发在中垃圾回收机制是自动管理内存的重要组成部分根据其作用范围和触发条件的不同可以将分为三种类型也称为有时也称为以及以下是这三种的区别和触发场景作用范围只针对年轻代进行回收包括区和两个区和触发条件当区空间不足时会触发一次将区和一个区中的存活对象移动到另一个区或老年代特点通常发生得非常频繁因为年轻代中对象的生命周期较短回收效率高暂停时间相对较短作用范围主要针对老年代进行回收但不一定只回收老年代触发条件当老年代空间不足时或者系统检测到年轻代对象晋升到老年代的速度过快可能会触发特点相比发生的频率较低但每次回收可能需要更长的时间因为老年代中的对象存活率较高作用范围对整个堆内存包括年轻代老年代以及永久代元空间进行回收触发条件直接调用或方法时虽然不能保证立即执行但会尝试执行新生代垃圾回收时如果存活的对象无法全部放入老年代或者老年代空间不足以容纳存活的对象则会触发对整个堆内存进行回收当永久代之前的版本或元空间及以后的版本空间不足时特点是最昂贵的操作因为它需要停止所有的工作线程遍历整个堆内存来查找和回收不再使用的对象因此应尽量减少的触发垃圾回收器和的区别区别一使用的范围不一样收集器是老年代的收集器可以配合新生代的和收集器一起使用收集器收集范围是老年代和新生代不需要结合其他收集器使用区别二的时间收集器以最小的停顿时间为目标的收集器目标是交互更多一点收集器可预测垃圾回收的停顿时间建立可预测的停顿时间模型目标是高吞吐量区别三垃圾碎片收集器是使用标记清除算法进行的垃圾回收容易产生内存碎片收集器使用的是标记整理算法进行了空间整合没有内存空间碎片局部上看是标记复制算法区别四垃圾回收的过程不一样注意这两个收集器第四阶段得不同区别五会产生浮动垃圾产生浮动垃圾过多时会退化为效率低因为在上图的第四阶段清除垃圾时是并发清除的这个时候垃圾回收线程和用户线程同时工作会产生浮动垃圾也就意味着垃圾回收器必须预留一部分内存空间用于存放浮动垃圾而没有浮动垃圾的筛选回收是多个垃圾回收线程并行的没有浮动垃圾的回收在执行并发清理步骤时用户线程也会同时产生一部分可回收对象但是这部分可回收对象只能在下次执行清理是才会被回收如果在清理过程中预留给用户线程的内存不足就会出现一旦出现此错误时便会切换到收集方式什么情况下使用什么情况使用适用场景低延迟需求适用于对停顿时间要求敏感的应用程序老生代收集主要针对老年代的垃圾回收碎片化管理容易出现内存碎片可能需要定期进行来压缩内存空间适用场景大堆内存适用于需要管理大内存堆的场景能够有效处理数以上的堆内存对内存碎片敏感通过紧凑整理来减少内存碎片降低了碎片化对性能的影响比较平衡的性能在提供较低停顿时间的同时也保持了相对较高的吞吐量回收器的特色是什么的特点最大的特点是引入分区的思路弱化了分代的概念合理利用垃圾收集各个周期的资源解决了其他收集器甚至的众多缺陷相比较的改进算法基于标记整理算法不会产生空间碎片在分配大对象时不会因无法得到连续的空间而提前触发一次停顿时间可控可以通过设置预期停顿时间来控制垃圾收集时间避免应用雪崩现象并行与并发能更充分的利用多核环境下的硬件优势来缩短的停顿时间只会对堆进行吗的垃圾回收器不仅仅会对堆进行垃圾回收它还会对方法区进行垃圾回收堆堆是用于存储对象实例的内存区域大部分的垃圾回收工作都发生在堆上因为大多数对象都会被分配在堆上而垃圾回收的重点通常也是回收堆中不再被引用的对象以释放内存空间方法区方法区是用于存储类信息常量静态变量等数据的区域虽然方法区中的垃圾回收与堆有所不同但是同样存在对不再需要的常量无用的类信息等进行清理的过程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-27 18:36:45',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 1.05rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 1.05rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/football/" style="font-size: 1.05rem;">football<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>41</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>8</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>6</sup></a><a href="/tags/paper/" style="font-size: 1.05rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 1.05rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>3</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>2</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>7</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>4</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>18</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 1.05rem;">毛选<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>11</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a><a class="article-meta__tags" href="/tags/jvm/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>jvm</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JVM-java虚拟机hot面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-24T16:00:00.000Z" title="发表于 2025-05-25 00:00:00">2025-05-25</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-27T10:36:45.261Z" title="更新于 2025-05-27 18:36:45">2025-05-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">13.4k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="JVM-java虚拟机hot面试"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722377.jpg?_r_=7cc40298-e708-fe8e-3db9-7130a1cbad28"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><a href="/tags/jvm/" tabindex="-1" itemprop="url">jvm</a><h1 id="CrawlerTitle" itemprop="name headline">JVM-java虚拟机hot面试</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-05-24T16:00:00.000Z" title="发表于 2025-05-25 00:00:00">2025-05-25</time><time itemprop="dateCreated datePublished" datetime="2025-05-27T10:36:45.261Z" title="更新于 2025-05-27 18:36:45">2025-05-27</time></header><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="1-JVM的内存模型介绍一下"><a href="#1-JVM的内存模型介绍一下" class="headerlink" title="1.JVM的内存模型介绍一下"></a>1.JVM的内存模型介绍一下</h2><p>根据 JDK 8 规范，JVM 运行时内存共分为<strong>虚拟机栈、堆、元空间、程序计数器、本地方法栈</strong>五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p>
<p>JVM的内存结构主要分为以下几个部分：</p>
<ul>
<li><strong>程序计数器</strong>：可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>，用于存储当前线程正在执行的 Java 方法的 JVM 指令地址。相当于指针，<strong>如果线程执行的是 Native 方法，计数器值为 null。</strong>是唯一一个在 Java 虚拟机规范中<strong>没有规定任何 OutOfMemoryError</strong> 情况的区域，生命周期与线程相同。</li>
<li><strong>Java 虚拟机栈</strong>：<strong>每个线程都有自己独立的 Java 虚拟机栈</strong>，生命周期与线程相同。每个<strong>方法在执行时都会创建一个栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。可能会抛出 <strong>StackOverflowError 和 OutOfMemoryError</strong> 异常。</li>
<li><strong>本地方法栈</strong>：与 Java 虚拟机栈类似，主<strong>要为虚拟机使用到的 Native 方法服务</strong>，在 <strong>HotSpot 虚拟机中和 Java 虚拟机栈合二为一</strong>。本地方法执行时也会创建栈帧，<strong>同样可能出现 StackOverflowError 和 OutOfMemoryError 两种错误。</strong></li>
<li><strong>Java 堆</strong>：是 <strong>JVM 中最大的一块内存区域，被所有线程共享</strong>，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区（From Survivor 和 To Survivor）。如果在堆中没有内存完成实例分配，<strong>并且堆也无法扩展时会抛出 OutOfMemoryError 异常。</strong></li>
<li><strong>方法区（元空间）</strong>：在 JDK 1.8 及以后的版本中，<strong>方法区被元空间取代，使用本地内存</strong>。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。虽然方法区被描述为堆的逻辑部分，但有 “非堆” 的别名。<strong>方法区可以选择不实现垃圾收集，内存不足时会抛出 OutOfMemoryError 异常。</strong></li>
<li><strong>运行时常量池</strong>：是方法区的一部分，<strong>用于存放编译期生成的各种字面量和符号引用</strong>，具有动态性，运行时也可将新的常量放入池中。当无法申请到足够内存时，会抛出 OutOfMemoryError 异常。</li>
<li><strong>直接内存</strong>：不属于 JVM 运行时数据区的一部分，<strong>通过 NIO 类引入，是一种堆外内存，可以显著提高 I/O 性能。</strong>直接内存的使用受到本机总内存的限制，若分配不当，可能导致 OutOfMemoryError 异常。</li>
</ul>
<h2 id="2-JVM内存模型里的堆和栈有什么区别？"><a href="#2-JVM内存模型里的堆和栈有什么区别？" class="headerlink" title="2.JVM内存模型里的堆和栈有什么区别？"></a>2.JVM内存模型里的堆和栈有什么区别？</h2><ul>
<li><strong>用途</strong>：<strong>栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。</strong>每当一个方法被调用，一个栈帧（stack frame）就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆用于存储对象的实例（包括类的实例和数组）。<strong>当你使用<code>new</code>关键字创建一个对象时，对象的实例就会在堆上分配空间。</strong></li>
<li><strong>生命周期</strong>：栈中的数据具有<strong>确定的生命周期</strong>，当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，<strong>对象会在垃圾回收机制（Garbage Collection, GC）检测到对象不再被引用时才被回收。</strong></li>
<li><strong>存取速度</strong>：<strong>栈的存取速度通常比堆快</strong>，因为栈遵循先进后出（LIFO, Last In First Out）的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。</li>
<li><strong>存储空间</strong>：<strong>栈的空间相对较小，且固定，由操作系统管理</strong>。当栈溢出时，通常是因为递归过深或局部变量过大。堆的空间较大，动态扩展，由JVM管理。<strong>堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。</strong></li>
<li><strong>可见性</strong>：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。</li>
</ul>
<h2 id="3-栈中存的到底是指针还是对象？"><a href="#3-栈中存的到底是指针还是对象？" class="headerlink" title="3.栈中存的到底是指针还是对象？"></a>3.栈中存的到底是指针还是对象？</h2><p>在JVM内存模型中，栈（Stack）主要用于<strong>管理线程的局部变量和方法调用的上下文</strong>，而堆（Heap）则是用于<strong>存储所有类的实例和数组。</strong></p>
<p>当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。</p>
<p>这里的关键点是，栈中存储的<strong>不是</strong>对象，而是<strong>对象的引用</strong>。也就是说，<strong>当你在方法中声明一个对象，比如<code>MyObject obj = new MyObject();</code>，这里的<code>obj</code>实际上是一个存储在栈上的引用</strong>，<strong>指向堆中实际的对象实例</strong>。这个引用是一个固定大小的数据（例如在64位系统上是8字节），它指向堆中分配给对象的内存区域。</p>
<h2 id="4-堆分为哪几部分呢？"><a href="#4-堆分为哪几部分呢？" class="headerlink" title="4.堆分为哪几部分呢？"></a>4.堆分为哪几部分呢？</h2><p>Java堆（Heap）是Java虚拟机（JVM）中内存管理的一个重要区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt=""></p>
<ul>
<li><strong>新生代（Young Generation）</strong>:新生代分为<strong>Eden Space和Survivor Space</strong>。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，<strong>称为S0（Survivor 0）和S1（Survivor 1）</strong>。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。<strong>这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</strong></li>
<li><strong>老年代（Old Generation/Tenured Generation）</strong>:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。<strong>老年代中的对象生命周期较长</strong>，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的<strong>空间通常比新生代大</strong>，以存储更多的长期存活对象。</li>
<li><strong>元空间（Metaspace）</strong>:从Java 8开始，永久代（Permanent Generation）被<strong>元空间</strong>取代，<strong>用于存储类的元数据信息，如类的结构信息（如字段、方法信息等）</strong>。元空间并不在Java堆中，而是使用<strong>本地内存</strong>，这解决了永久代容易出现的内存溢出问题。</li>
<li><strong>大对象区（Large Object Space / Humongous Objects）</strong>:在某些JVM实现中（如G1垃圾收集器），<strong>为大对象分配了专门的区域，称为大对象区或Humongous Objects区域</strong>。大对象是指<strong>需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。</strong></li>
</ul>
<h2 id="5-如果有个大对象一般是在哪个区域？"><a href="#5-如果有个大对象一般是在哪个区域？" class="headerlink" title="5.如果有个大对象一般是在哪个区域？"></a>5.如果有个大对象一般是在哪个区域？</h2><p><strong>大对象通常会直接分配到老年代。</strong></p>
<p>新生代主要用于<strong>存放生命周期较短的对象，并且其内存空间相对较小</strong>。如果将大对象分配到新生代，可能会很快导致新生代空间不足，从而频繁触发 Minor GC。而每次 Minor GC 都需要进行对象的复制和移动操作，这会带来一定的性能开销。将大对象直接分配到老年代，可以减少新生代的内存压力，降低 Minor GC 的频率。</p>
<p><strong>大对象通常需要连续的内存空间</strong>，如果在新生代中频繁分配和回收大对象，<strong>容易产生内存碎片，导致后续分配大对象时可能因为内存不连续而失败。</strong>老年代的空间相对较大，更适合存储大对象，有助于减少内存碎片的产生。</p>
<h2 id="6-程序计数器的作用，为什么是私有的？"><a href="#6-程序计数器的作用，为什么是私有的？" class="headerlink" title="6.程序计数器的作用，为什么是私有的？"></a>6.程序计数器的作用，为什么是私有的？</h2><p>Java程序是支持多线程一起运行的，多个线程一起运行的时候cpu会有一个调动器组件给它们分配时间片，比如说会给线程1分给一个时间片，它在时间片内如果它的代码没有执行完，<strong>它就会把线程1的状态执行一个暂存</strong>，切换到线程2去，执行线程2的代码，等线程2的代码执行到了一定程度，线程2的时间片用完了，再切换回来，再继续执行线程1剩余部分的代码。</p>
<p>我们考虑一下，<strong>如果在线程切换的过程中，下一条指令执行到哪里了，是不是还是会用到我们的程序计数器啊。每个线程都有自己的程序计数器，因为它们各自执行的代码的指令地址是不一样的呀，所以每个线程都应该有自己的程序计数器。</strong></p>
<h2 id="7-方法区中的方法的执行过程？"><a href="#7-方法区中的方法的执行过程？" class="headerlink" title="7.方法区中的方法的执行过程？"></a>7.方法区中的方法的执行过程？</h2><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p>
<ul>
<li><strong>解析方法调用</strong>：JVM会根据<strong>方法的符号引用找到实际的方法地址</strong>（如果之前没有解析过的话）。</li>
<li><strong>栈帧创建</strong>：在调用一个方法前，JVM会在当前线程的Java<strong>虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</strong></li>
<li><strong>执行方法</strong>：执行方法内的<strong>字节码指令</strong>，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。</li>
<li><strong>返回处理</strong>：方法执行完毕后，可<strong>能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。</strong></li>
</ul>
<h2 id="8-HotSpot-为什么要分为新生代和老年代？"><a href="#8-HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="8.HotSpot 为什么要分为新生代和老年代？"></a>8.HotSpot 为什么要分为新生代和老年代？</h2><p>HotSpot 将堆内存划分为新生代和老年代，是为了<strong>利用对象生命周期的差异来优化垃圾回收性能。</strong>大多数对象生命周期短，适合在新生代中用高效的<strong>复制算法</strong>快速回收；少量长寿命对象存放在老年代，<strong>减少回收频率。分代设计能有效缩短停顿时间、提高吞吐量，避免每次 GC 都扫描整个堆，从而提升整体系统运行效率。</strong></p>
<h2 id="9-方法区中还有哪些东西？"><a href="#9-方法区中还有哪些东西？" class="headerlink" title="9.方法区中还有哪些东西？"></a>9.方法区中还有哪些东西？</h2><p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<ul>
<li>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。</li>
<li>常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。</li>
<li>静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。</li>
<li>方法字节码：存储类的方法字节码，即编译后的代码。</li>
<li>符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。</li>
<li>运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。</li>
<li>常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。</li>
</ul>
<h2 id="10-String保存在哪里呢？"><a href="#10-String保存在哪里呢？" class="headerlink" title="10.String保存在哪里呢？"></a>10.String保存在哪里呢？</h2><p>String 保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享</p>
<h2 id="11-String-s-new-String（“abc”）执行过程中分别对应哪些内存区域？"><a href="#11-String-s-new-String（“abc”）执行过程中分别对应哪些内存区域？" class="headerlink" title="11.String s = new String（“abc”）执行过程中分别对应哪些内存区域？"></a>11.String s = new String（“abc”）执行过程中分别对应哪些内存区域？</h2><p>首先，我们看到这个代码中有一个new关键字，我们知道<strong>new</strong>指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在<strong>运行期</strong>才能确定的，创建的字符串对象是在<strong>堆内存上</strong>。</p>
<p>其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时，JVM拿字面量”abc”去<strong>字符串常量池</strong>试图获取其对应String对象的引用。<strong>于是在堆中创建了一个”abc”的String对象</strong>，并将其引用保存到字符串常量池中，然后返回；</p>
<p>所以，<strong>如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new String这个实例对象。如果abc这字符串常量存在，则只会创建一个对象</strong>。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="1-为什么软引用可以防止内存溢出"><a href="#1-为什么软引用可以防止内存溢出" class="headerlink" title="1.为什么软引用可以防止内存溢出"></a><strong>1.为什么软引用可以防止内存溢出</strong></h2><p>减轻内存压力：</p>
<p>软引用对象在内存紧张时会被 GC 回收，这意味着,对于一些<strong>缓存型对象</strong>（如图片缓存、数据缓存）：</p>
<ul>
<li>使用软引用能让 JVM 在不影响系统运行的前提下<strong>自动清理不重要的对象</strong>；</li>
<li>避免这些对象<strong>一直占用内存</strong>导致 OOM（OutOfMemoryError）。</li>
</ul>
<p>有利于缓存系统的实现：</p>
<p>比如在图片浏览器、数据库连接池、网页浏览器中，常常需要缓存大量数据；使用软引用作为缓存的基础可以确保：</p>
<ul>
<li>缓存不会<strong>占用过多堆内存</strong>；</li>
<li>系统空闲时缓存仍可用；</li>
<li>一旦内存紧张，<strong>缓存自动释放</strong>，系统依旧安全运行。</li>
</ul>
<p>相比强引用更灵活、相比弱引用更安全</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>引用类型</th>
<th>回收时机</th>
<th>是否适合做缓存</th>
<th>对系统安全性的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>永不回收（除非没有引用）</td>
<td>❌ 会导致 OOM</td>
<td>高风险</td>
</tr>
<tr>
<td>弱引用</td>
<td>GC 时就回收</td>
<td>⚠️ 不适合</td>
<td>稳定但易失效</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时回收</td>
<td>✅ 非常适合</td>
<td>✅ 安全可靠</td>
</tr>
</tbody>
</table>
</div>
<p>为什么弱引用/虚引用用得少？</p>
<p><strong>弱引用</strong>：一旦 GC 触发，不管内存够不够都会被回收，<strong>太激进，不适合缓存</strong>；</p>
<p><strong>虚引用</strong>：更偏底层，<strong>用于监控对象被回收的时机</strong>，不具备访问能力，<strong>需要配合 ReferenceQueue 使用</strong>，复杂度高。</p>
<h2 id="2-引用类型有哪些？有什么区别？"><a href="#2-引用类型有哪些？有什么区别？" class="headerlink" title="2.引用类型有哪些？有什么区别？"></a>2.引用类型有哪些？有什么区别？</h2><p>引用类型主要分为强软弱虚四种：</p>
<ul>
<li>强引用指的就是<strong>代码中普遍存在的赋值方式</strong>，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。就是一个对象</li>
<li>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。<strong>系统在发生内存溢出前会对这类引用的对象进行回收。</strong></li>
<li>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，<strong>弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。</strong></li>
<li>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，<strong>他必须和ReferenceQueue一起使用</strong>，同样的当发生GC的时候，虚引用也会被回收。<strong>可以用虚引用来管理堆外内存。</strong></li>
</ul>
<h2 id="3-弱引用了解吗-举例说明在哪里可以用"><a href="#3-弱引用了解吗-举例说明在哪里可以用" class="headerlink" title="3.弱引用了解吗?举例说明在哪里可以用?"></a>3.弱引用了解吗?举例说明在哪里可以用?</h2><p>Java中的弱引用是一种引用类型，它不会阻止一个对象被垃圾回收。</p>
<p>在Java中，弱引用是通过<code>Java.lang.ref.WeakReference</code>类实现的。弱引用的一个主要用途是创建非强制性的对象引用，<strong>这些引用可以在内存压力大时被垃圾回收器清理，从而避免内存泄露。</strong></p>
<p>弱引用的使用场景：</p>
<ul>
<li><strong>缓存系统</strong>：弱引用常用于<strong>实现缓存</strong>，特别是当希望缓存项能够在内存压力下自动释放时。如果缓存的大小不受控制，可能会导致内存溢出。使用弱引用来维护缓存，可以让JVM在需要更多内存时自动清理这些缓存对象。</li>
<li><strong>对象池</strong>：在对象池中，<strong>弱引用可以用来管理那些暂时不使用的对象。当对象不再被强引用时，它们可以被垃圾回收，释放内存。</strong></li>
<li><strong>避免内存泄露</strong>：当一个对象<strong>不应该被长期引用时</strong>，使用弱引用可以防止该对象被意外地保留，从而避免潜在的内存泄露。</li>
</ul>
<p>示例代码：</p>
<p>假设我们有一个缓存系统，我们使用弱引用来维护缓存中的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> Java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> Java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WeakReference&lt;MyHeavyObject&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyHeavyObject <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        WeakReference&lt;MyHeavyObject&gt; ref = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ref.get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MyHeavyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHeavyObject</span>();</span><br><span class="line">            cache.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj));</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设MyHeavyObject是一个占用大量内存的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHeavyObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] largeData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 10MB data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用<code>WeakReference</code>来存储<code>MyHeavyObject</code>实例，当内存压力增大时，垃圾回收器可以自由地回收这些对象，而不会影响缓存的正常运行。</p>
<p>如果一个对象被垃圾回收，下次尝试从缓存中获取时，<code>get()</code>方法会返回<code>null</code>，这时我们可以重新创建对象并将其放入缓存中。因此，使用弱引用时要注意，一旦对象被垃圾回收，通过弱引用获取的对象可能会变为<code>null</code>，因此在使用前通常需要检查这一点。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>软引用（SoftReference）</th>
<th>弱引用（WeakReference）</th>
</tr>
</thead>
<tbody>
<tr>
<td>回收时机</td>
<td>内存不足时才回收</td>
<td>下一次 GC 就可能回收</td>
</tr>
<tr>
<td>存活时间</td>
<td>相对更长</td>
<td>非常短，随时可能被清除</td>
</tr>
<tr>
<td>适合场景</td>
<td>缓存（保留尽可能多对象）</td>
<td>映射、辅助引用、监听器、ThreadLocal 等</td>
</tr>
<tr>
<td>安全性</td>
<td>更高（内存紧张时才回收）</td>
<td>更低（不稳定，随时可能为 null）</td>
</tr>
<tr>
<td>被使用的典型类</td>
<td><code>SoftReferenceCache</code></td>
<td><code>WeakHashMap</code>、<code>ThreadLocal</code> 底层</td>
</tr>
</tbody>
</table>
</div>
<h2 id="4-内存泄漏和内存溢出的理解？"><a href="#4-内存泄漏和内存溢出的理解？" class="headerlink" title="4.内存泄漏和内存溢出的理解？"></a>4.内存泄漏和内存溢出的理解？</h2><p><strong>内存泄露</strong>：内存泄漏是<strong>指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。</strong>虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。</p>
<p>内存泄露常见原因：</p>
<ul>
<li><strong>静态集合</strong>：使用静态数据结构（如<code>HashMap</code>或<code>ArrayList</code>）存储对象，且未清理。</li>
<li><strong>事件监听</strong>：未取消对事件源的监听，导致对象持续被引用。</li>
<li><strong>线程</strong>：未停止的线程可能持有对象引用，无法被回收。</li>
</ul>
<p>内存溢出：内存溢出是指<strong>Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发<code>OutOfMemoryError</code>。这通常发生在堆内存不足以存放新创建的对象时。</strong></p>
<p>内存溢出常见原因：</p>
<ul>
<li><strong>大量对象创建</strong>：程序中不断创建大量对象，超出JVM堆的限制。</li>
<li><strong>持久引用</strong>：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。</li>
<li><strong>递归调用</strong>：深度递归导致栈溢出。</li>
</ul>
<p>内存泄漏是还没满，内存溢出是已经满了</p>
<h2 id="5-jvm-内存结构有哪几种内存溢出的情况？"><a href="#5-jvm-内存结构有哪几种内存溢出的情况？" class="headerlink" title="5.jvm 内存结构有哪几种内存溢出的情况？"></a>5.jvm 内存结构有哪几种内存溢出的情况？</h2><ul>
<li><strong>堆内存溢出</strong>：当出现Java.lang.OutOfMemoryError:Java heap space异常时，就是堆内存溢出了。原因是代码中<strong>可能存在大对象分配，或者发生了内存泄露</strong>，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。</li>
<li><strong>栈溢出</strong>：如果我们<strong>写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</strong>类似这种情况，JVM 实际会抛出 StackOverFlowError；<strong>当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</strong></li>
<li><strong>元空间溢出</strong>：元空间的溢出，系统会抛出Java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是<strong>系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。</strong></li>
<li><strong>直接内存内存溢出</strong>：在使用<strong>ByteBuffer中的allocateDirect()的时候会用到</strong>，很多JavaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出Java.lang.OutOfMemoryError: Direct buffer memory异常。</li>
</ul>
<p>除了<strong>程序计数器</strong>都会出现OOM</p>
<h2 id="6-有具体的内存泄漏和内存溢出的例子么请举例及解决方案"><a href="#6-有具体的内存泄漏和内存溢出的例子么请举例及解决方案" class="headerlink" title="6.有具体的内存泄漏和内存溢出的例子么请举例及解决方案?"></a>6.有具体的内存泄漏和内存溢出的例子么请举例及解决方案?</h2><blockquote>
<p>1、静态属性导致内存泄露</p>
</blockquote>
<p>会导致内存泄露的一种情况就是<strong>大量使用static静态变量</strong>。在Java中，静态属性的生命周期通常伴随着应用整个生命周期（除非ClassLoader符合垃圾回收的条件）。下面来看一个具体的会导致内存泄露的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticTest</span>().populateList();</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果监控内存堆内存的变化，会发现在打印Point1和Point2之间，堆内存会有一个明显的增长趋势图。但当执行完populateList方法之后，对堆内存并没有被垃圾回收器进行回收。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240820112907539.png" alt="image-20240820112907539"></p>
<p>但针对上述程序，如果将定义list的变量前的static关键字去掉，再次执行程序，会发现内存发生了具体的变化。VisualVM监控信息如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240820112851893.png" alt="image-20240820112851893"></p>
<p>对比两个图可以看出，程序执行的前半部分内存使用情况都一样，但当执行完populateList方法之后，后者不再有引用指向对应的数据，垃圾回收器便进行了回收操作。因此，我们要十分留意static的变量，<strong>如果集合或大量的对象定义为static的，它们会停留在整个应用程序的生命周期当中。而它们所占用的内存空间，本可以用于其他地方。</strong></p>
<p>那么如何优化呢？<strong>第一，进来减少静态变量；第二，如果使用单例，尽量采用懒加载。</strong></p>
<blockquote>
<p>2、 未关闭的资源</p>
</blockquote>
<p>无论什么时候当我们创建一个连接或打开一个流，JVM都会分配内存给这些资源。比如，数据库链接、输入流和session对象。</p>
<p><strong>忘记关闭这些资源，会阻塞内存，从而导致GC无法进行清理。</strong>特别是当程序发生异常时，没有在finally中进行资源关闭的情况。这些未正常关闭的连接，如果不进行处理，轻则影响程序性能，重则导致OutOfMemoryError异常发生。</p>
<p>如果进行处理呢？<strong>第一，始终记得在finally中进行资源的关闭；第二，关闭连接的自身代码不能发生异常；第三，Java7以上版本可使用try-with-resources代码方式进行资源关闭。</strong></p>
<p>try-with-resources:</p>
<p><code>try()</code> 中定义的对象，必须实现 <code>AutoCloseable</code> 接口（<code>Closeable</code> 也可以，间接继承）；</p>
<p>try 块执行完后，Java 会自动调用这些资源的 <code>.close()</code> 方法；</p>
<blockquote>
<p>3、 使用ThreadLocal</p>
</blockquote>
<p>ThreadLocal提供了<strong>线程本地变量</strong>，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。<strong>ThreadLocal相当于提供了一种线程隔离</strong>，将变量与线程相绑定，从而实现线程安全的特性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240820112835783.png" alt="image-20240820112835783"></p>
<p>ThreadLocal的实现中，<strong>每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。</strong></p>
<p>ThreadLocalMap使用ThreadLocal的<strong>弱引用作为key</strong>，如果一个ThreadLocal<strong>没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</strong></p>
<p>如果当前线程迟迟不结束的话，<strong>这些key为null的Entry的value就会一直存在一条强引用链</strong>：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p>
<p>如何解决此问题？</p>
<ul>
<li>第一，<strong>使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除</strong>；</li>
<li>第二，不要使用ThreadLocal.set(null) 的方式清除value，它实际上并没有清除值，而是<strong>查找与当前线程关联的Map并将键值对分别设置为当前线程和null。</strong></li>
<li>第三，<strong>最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(System.nanoTime());</span><br><span class="line">    <span class="comment">//... further processing</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><h2 id="1-创建对象的过程？"><a href="#1-创建对象的过程？" class="headerlink" title="1.创建对象的过程？"></a>1.创建对象的过程？</h2><p>在Java中创建对象的过程包括以下几个步骤：</p>
<ol>
<li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</li>
<li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为<strong>新生对象分配内存</strong>。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</li>
<li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要<strong>将分配到的内存空间都初始化为零值</strong>（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所<strong>以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</strong></li>
</ol>
<h2 id="2-对象的生命周期"><a href="#2-对象的生命周期" class="headerlink" title="2.对象的生命周期"></a>2.对象的生命周期</h2><p>对象的生命周期包括创建、使用和销毁三个阶段：</p>
<ul>
<li>创建：对象通过<strong>关键字new在堆内存中被实例化</strong>，构造函数被调用，对象的内存空间被分配。</li>
<li>使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。</li>
<li>销毁：当对象不再被引用时，通过<strong>垃圾回收机制自动回收对象所占用的内存空间</strong>。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。</li>
</ul>
<h2 id="3-类加载器有哪些？"><a href="#3-类加载器有哪些？" class="headerlink" title="3.类加载器有哪些？"></a>3.类加载器有哪些？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png" alt=""></p>
<ul>
<li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这是<strong>最顶层的类加载器</strong>，负责加载Java的核心库（如位于jre/lib/rt.jar中的类），它是用C++编写的，是JVM的一部分。启动类加载器无法被Java程序直接引用。</li>
<li><strong>扩展类加载器（Extension Class Loader）</strong>：它是Java语言实现的，<strong>继承自ClassLoader类</strong>，负责加载Java扩展目录（jre/lib/ext或由系统变量Java.ext.dirs指定的目录）下的jar包和类库。<strong>扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。</strong></li>
<li><strong>系统类加载器（System Class Loader）/ 应用程序类加载器（Application Class Loader）</strong>：这也是Java语言实现的，<strong>负责加载用户类路径（ClassPath）上的指定类库</strong>，是我们平时编写Java程序时默认使用的类加载器。系统类加载器的父加载器是扩展类加载器。它可以通过ClassLoader.getSystemClassLoader()方法获取到。</li>
<li><strong>自定义类加载器（Custom Class Loader）</strong>：开发者可以根据需求定制类的加载方式，比如从网络加载class文件、数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是Java动态性的一个重要体现。</li>
</ul>
<p>这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，<strong>而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</strong></p>
<p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载</p>
<h2 id="3-双亲委派模型的作用"><a href="#3-双亲委派模型的作用" class="headerlink" title="3.双亲委派模型的作用"></a>3.双亲委派模型的作用</h2><ul>
<li><strong>保证类的唯一性</strong>：通过委托机制，<strong>确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况</strong>，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</li>
<li><strong>保证安全性</strong>：由于Java核心库被启动类加载器加载，而<strong>启动类加载器只加载信任的类路径中的类</strong>，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li>
<li><strong>支持隔离和层次划分</strong>：双亲委派模型<strong>支持不同层次的类加载器服务于不同的类加载需求</strong>，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li>
<li><strong>简化了加载流程</strong>：通过委派，<strong>大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。</strong></li>
</ul>
<h2 id="4-讲一下类加载过程？"><a href="#4-讲一下类加载过程？" class="headerlink" title="4.讲一下类加载过程？"></a>4.讲一下类加载过程？</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt=""></h3><ul>
<li><strong>加载</strong>：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，<strong>转化为方法区运行时的数据结构</strong>，在内存中生成一个代表该类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
<li><strong>连接</strong>：验证、准备、解析 3 个阶段统称为连接。<ul>
<li><strong>验证</strong>：<strong>确保class文件中的字节流包含的信息，符合当前虚拟机的要求</strong>，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证</li>
<li><strong>准备</strong>：为类中的<strong>静态字段分配内存，并设置默认的初始值</strong>，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</li>
<li><strong>解析</strong>：解析阶段是<strong>虚拟机将常量池的「符号引用」直接替换为「直接引用」的过程</strong>。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</li>
</ul>
</li>
<li><strong>初始化</strong>：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是<strong>执行类的构造器方法（()</strong> ），要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。</li>
<li><strong>使用</strong>：使用类或者创建对象</li>
<li><strong>卸载</strong>：如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 3. 类对应的Java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="5-讲一下类的加载和双亲委派原则"><a href="#5-讲一下类的加载和双亲委派原则" class="headerlink" title="5.讲一下类的加载和双亲委派原则"></a>5.讲一下类的加载和双亲委派原则</h2><p>我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化。</p>
<p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
<p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li>
<li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li>
<li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。</li>
</ul>
<p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
<p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="1-什么是Java里的垃圾回收？如何触发垃圾回收？"><a href="#1-什么是Java里的垃圾回收？如何触发垃圾回收？" class="headerlink" title="1.什么是Java里的垃圾回收？如何触发垃圾回收？"></a>1.什么是Java里的垃圾回收？如何触发垃圾回收？</h2><p>垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，它负责自动释放不再被程序引用的对象所占用的内存，这种机制减少了内存泄漏和内存管理错误的可能性。垃圾回收可以通过多种方式触发，具体如下：</p>
<ul>
<li><strong>内存不足时</strong>：当JVM检测到<strong>堆内存不足</strong>，无法为新的对象分配内存时，会自动触发垃圾回收。</li>
<li><strong>手动请求</strong>：虽然垃圾回收是自动的，<strong>开发者可以通过调用 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 建议 JVM 进行垃圾回收。</strong>不过这只是一个建议，并不能保证立即执行。</li>
<li><strong>JVM参数</strong>：启动 Java 应用时可以通过 <strong>JVM 参数来调整垃圾回收的行为</strong>，比如：<code>-Xmx</code>（最大堆大小）、<code>-Xms</code>（初始堆大小）等。</li>
<li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。</li>
</ul>
<h2 id="2-判断垃圾的方法有哪些？"><a href="#2-判断垃圾的方法有哪些？" class="headerlink" title="2.判断垃圾的方法有哪些？"></a>2.判断垃圾的方法有哪些？</h2><p>在Java中，判断对象是否为垃圾（即不再被使用，可以被垃圾回收器回收）主要依据两种主流的垃圾回收算法来实现：<strong>引用计数法和可达性分析算法</strong>。</p>
<blockquote>
<p>引用计数法（Reference Counting）</p>
</blockquote>
<ul>
<li><strong>原理</strong>：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。</li>
<li><strong>缺点</strong>：<strong>不能解决循环引用的问题</strong>，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。</li>
</ul>
<blockquote>
<p>可达性分析算法（Reachability Analysis）</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" alt="img"></p>
<p>Java虚拟机主要采用此算法来判断对象是否为垃圾。</p>
<ul>
<li><strong>原理</strong>：从一组称为<strong>GC Roots（垃圾收集根）的对象出发</strong>，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。<strong>如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。</strong>GC Roots对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等。</li>
</ul>
<h2 id="3-垃圾回收算法是什么，是为了解决了什么问题？"><a href="#3-垃圾回收算法是什么，是为了解决了什么问题？" class="headerlink" title="3.垃圾回收算法是什么，是为了解决了什么问题？"></a>3.垃圾回收算法是什么，是为了解决了什么问题？</h2><p>JVM有垃圾回收机制的原因是为了<strong>解决内存管理的问题</strong>。在传统的编程语言中，开发人员需要手动分配和释放内存，这可能导致<strong>内存泄漏、内存溢出</strong>等问题。而Java作为一种高级语言，旨在提供更简单、更安全的编程环境，因此引入了垃圾回收机制来自动管理内存。</p>
<p>垃圾回收机制的主要目标是<strong>自动检测和回收**</strong>不再使用的对象<strong>，从而释放它们所占用的内存空间。这样可以</strong>避免内存泄漏（一些对象被分配了内存却无法被释放，导致内存资源的浪费）。同时，垃圾回收机制还可以防止内存溢出（即程序需要的内存超过了可用内存的情况）。**</p>
<p>通过垃圾回收机制，JVM可以在程序运行时自动识别和清理不再使用的对象，使得开发人员无需手动管理内存。这样可以提高开发效率、减少错误，并且使程序更加可靠和稳定。</p>
<h2 id="4-垃圾回收算法有哪些？"><a href="#4-垃圾回收算法有哪些？" class="headerlink" title="4.垃圾回收算法有哪些？"></a>4.垃圾回收算法有哪些？</h2><ul>
<li><strong>标记-清除算法</strong>：标记-清除算法分为<strong>“标记”和“清除”</strong>两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，<strong>标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。</strong>有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</li>
<li><strong>复制算法</strong>：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。<strong>因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</strong></li>
<li><strong>标记-整理算法</strong>：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，<strong>但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</strong></li>
<li><strong>分代回收算法</strong>：分代收集是将内存划分成了<strong>新生代和老年代</strong>。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，<strong>一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</strong></li>
</ul>
<p>比如新生代我们使用复制算法效率较高，老年代使用标记-整理算法更好</p>
<h2 id="5-垃圾回收器有哪些？"><a href="#5-垃圾回收器有哪些？" class="headerlink" title="5.垃圾回收器有哪些？"></a>5.垃圾回收器有哪些？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png" alt=""></p>
<h2 id="6-标记清除算法的缺点是什么？"><a href="#6-标记清除算法的缺点是什么？" class="headerlink" title="6.标记清除算法的缺点是什么？"></a>6.标记清除算法的缺点是什么？</h2><p>主要缺点有两个：</p>
<ul>
<li>一个是效率问题，标记和清除过程的效率都不高；</li>
<li>另外一个是空间问题，标记清除之后会产生<strong>大量不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到<strong>足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong></li>
</ul>
<h2 id="7-垃圾回收算法哪些阶段会stop-the-world"><a href="#7-垃圾回收算法哪些阶段会stop-the-world" class="headerlink" title="7.垃圾回收算法哪些阶段会stop the world?"></a>7.垃圾回收算法哪些阶段会stop the world?</h2><p>标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：</p>
<ul>
<li><strong>标记阶段，即从GC Roots集合开始，标记活跃对象；</strong></li>
<li><strong>转移阶段，即把活跃对象复制到新的内存地址上；</strong></li>
<li><strong>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</strong></li>
</ul>
<p>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1718783586342-9da40db7-1dac-42ec-8148-81c10d8bfc04.png" alt="img"></p>
<p>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。</p>
<p><strong>标记阶段停顿分析</strong></p>
<ul>
<li>初始标记阶段：初始标记阶段是指从GC Roots出发标记<strong>全部直接子节点</strong>的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。</li>
<li>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。</li>
<li>再标记阶段：<strong>重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。</strong></li>
</ul>
<p><strong>清理阶段停顿分析</strong></p>
<ul>
<li><strong>清理阶段清点</strong>出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。</li>
</ul>
<p><strong>复制阶段停顿分析</strong></p>
<ul>
<li><strong>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，</strong>其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。</li>
</ul>
<p>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。</p>
<p>因此，G1停顿时间的瓶颈<strong>主要是标记-复制中的转移阶段STW。</strong></p>
<h2 id="8-minorGC、majorGC、fullGC的区别，什么场景触发full-GC"><a href="#8-minorGC、majorGC、fullGC的区别，什么场景触发full-GC" class="headerlink" title="8.minorGC、majorGC、fullGC的区别，什么场景触发full GC"></a>8.minorGC、majorGC、fullGC的区别，什么场景触发full GC</h2><p>在Java中，垃圾回收机制是自动管理内存的重要组成部分。根据其作用范围和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。以下是这三种GC的区别和触发场景：</p>
<blockquote>
<p>Minor GC (Young GC)</p>
</blockquote>
<ul>
<li><strong>作用范围</strong>：只针对<strong>年轻代</strong>进行回收，包括Eden区和两个Survivor区（S0和S1）。</li>
<li><strong>触发条件</strong>：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。</li>
<li><strong>特点</strong>：<strong>通常发生得非常频繁</strong>，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。</li>
</ul>
<blockquote>
<p>Major GC</p>
</blockquote>
<ul>
<li><strong>作用范围</strong>：主要<strong>针对老年代进行回收</strong>，但不一定只回收老年代。</li>
<li><strong>触发条件</strong>：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。</li>
<li><strong>特点</strong>：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。</li>
</ul>
<blockquote>
<p>Full GC</p>
</blockquote>
<ul>
<li><strong>作用范围</strong>：<strong>对整个堆内存（包括年轻代、老年代以及永久代/元空间）进行回收</strong>。</li>
<li><strong>触发条件</strong>：<ul>
<li>直接调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>方法时，虽然不能保证立即执行，但JVM会尝试执行Full GC。</li>
<li>Minor GC（新生代垃圾回收）时，如<strong>果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。</strong></li>
<li>当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时。</li>
</ul>
</li>
<li><strong>特点</strong>：Full GC是最昂贵的操作，因为它需要停止所有的工作线程（Stop The World），遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发。</li>
</ul>
<h2 id="9-垃圾回收器-CMS-和-G1的区别？"><a href="#9-垃圾回收器-CMS-和-G1的区别？" class="headerlink" title="9.垃圾回收器 CMS 和 G1的区别？"></a>9.垃圾回收器 CMS 和 G1的区别？</h2><p><strong>区别一：使用的范围不一样：</strong></p>
<ul>
<li>CMS收集器是<strong>老年代</strong>的收集器，可以<strong>配合新生代的Serial和ParNew收集器一起使用</strong></li>
<li>G1收集器收集范围是<strong>老年代和新生代</strong>。不需要结合其他收集器使用</li>
</ul>
<p><strong>区别二：STW的时间：</strong></p>
<ul>
<li>CMS收集器以<strong>最小的停顿时间</strong>为目标的收集器。目标是交互更多一点</li>
<li>G1收集器可预测<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=垃圾回收&amp;spm=1001.2101.3001.7020">垃圾回收 (opens new window)</a>的停顿时间（建立可预测的停顿时间模型），目标是高吞吐量</li>
</ul>
<p><strong>区别三： 垃圾碎片</strong></p>
<ul>
<li>CMS收集器是使用“标记-清除”<strong>算法进行的垃圾回收，容易产生内存碎片</strong></li>
<li>G1收集器使用的是“<strong>标记-整理</strong>”算法，进行了空间整合，没有内存空间碎片</li>
</ul>
<p>局部上看是标记-复制算法</p>
<p><strong>区别四： 垃圾回收的过程不一样</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1716015294690-efd71a12-f4b1-4356-9de2-5164393482a5.png" alt="img"></p>
<p>注意这两个收集器第四阶段得不同</p>
<p><strong>区别五: CMS会产生浮动垃圾</strong></p>
<ul>
<li>CMS产生浮动垃圾过多时<strong>会退化为serial old，效率低</strong>，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户线程同时工作会产生浮动垃圾，<strong>也就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾</strong></li>
<li>而G1没有浮动垃圾，<strong>G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收，</strong>在执行‘并发清理’步骤时，<strong>用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。</strong>如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,<strong>一旦出现此错误时便会切换到SerialOld收集方式。</strong></li>
</ul>
<h2 id="10-什么情况下使用CMS，什么情况使用G1"><a href="#10-什么情况下使用CMS，什么情况使用G1" class="headerlink" title="10.什么情况下使用CMS，什么情况使用G1?"></a>10.什么情况下使用CMS，什么情况使用G1?</h2><p>CMS适用场景：</p>
<ul>
<li><strong>低延迟需求</strong>：适用于对停顿时间要求敏感的应用程序。</li>
<li><strong>老生代收集</strong>：主要针对老年代的垃圾回收。</li>
<li><strong>碎片化管理</strong>：容易出现内存碎片，可能需要定期进行Full GC来压缩内存空间。</li>
</ul>
<p>G1适用场景：</p>
<ul>
<li><strong>大堆内存</strong>：适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。</li>
<li><strong>对内存碎片敏感</strong>：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。</li>
<li><strong>比较平衡的性能</strong>：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。</li>
</ul>
<h2 id="11-G1回收器的特色是什么？"><a href="#11-G1回收器的特色是什么？" class="headerlink" title="11.G1回收器的特色是什么？"></a>11.G1回收器的特色是什么？</h2><p><strong>G1 的特点：</strong></p>
<ul>
<li>G1最大的特点是<strong>引入分区的思路，弱化了分代的概念。</strong></li>
<li><strong>合理利用垃圾收集各个周期的资源</strong>，解决了其他收集器、甚至 CMS 的众多缺陷</li>
</ul>
<p><strong>G1 相比较 CMS 的改进：</strong></p>
<ul>
<li><strong>算法</strong>： G1 基于标记—整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。</li>
<li><strong>停顿时间可控</strong>： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。</li>
<li><strong>并行与并发</strong>：G1 能更充分的利用 <strong>CPU 多核环境下的硬件优势</strong>，来缩短 stop the world 的停顿时间。</li>
</ul>
<h2 id="12-GC只会对堆进行GC吗？"><a href="#12-GC只会对堆进行GC吗？" class="headerlink" title="12.GC只会对堆进行GC吗？"></a>12.GC只会对堆进行GC吗？</h2><p>JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。</p>
<ol>
<li><strong>堆（Heap）：</strong> 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，因为大多数对象都会被分配在堆上，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。</li>
<li><strong>方法区（Method Area）：</strong> 方法区是用于<strong>存储类信息、常量、静态变量</strong>等数据的区域。虽然方法区中的垃圾回收与堆有所不同，<strong>但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。</strong></li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/')">JVM-java虚拟机hot面试</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JVM-java虚拟机hot面试&amp;url=https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722377.jpg?_r_=7cc40298-e708-fe8e-3db9-7130a1cbad28" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>技术栈<span class="categoryesPageCount">12</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">41</span></a><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">11</span></a><a class="post-meta__box__tags" href="/tags/jvm/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>jvm<span class="tagsPageCount">2</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510550.jpg?_r_=e7eca60e-e37a-0b29-2ab7-1994322e8af6" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/25/java-stack/jvm1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=1c6cccc8-b45b-84ca-8f8b-eff3a960f4cb" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM-java虚拟机</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/27/workmenu/crmeb/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=8b14dccf-ff4b-0db4-7bfb-aca9c872b6c1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">crmeb商城分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/05/27/java-stack/javasample1/" title="JAVA设计面试题目hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712180.jpg?_r_=5134985d-b810-aba1-4e91-a59f85899fee" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-27</div><div class="title">JAVA设计面试题目hot</div></div></a></div><div><a href="/2025/05/25/java-stack/jvm1/" title="JVM-java虚拟机"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=1c6cccc8-b45b-84ca-8f8b-eff3a960f4cb" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-25</div><div class="title">JVM-java虚拟机</div></div></a></div><div><a href="/2025/05/22/java-stack/juc2/" title="JUC-线程池面试题hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510494.jpg?_r_=5bd4b823-b6e2-69dc-ec26-c80dc79a8de9" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-22</div><div class="title">JUC-线程池面试题hot</div></div></a></div><div><a href="/2025/05/05/java-stack/spring2/" title="Spring面试题hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510678.jpg?_r_=5e92a557-855a-0ccb-bde3-2a8e67a99315" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-05</div><div class="title">Spring面试题hot</div></div></a></div><div><a href="/2025/05/23/javase/javase3/" title="javase面试题目hot2集合"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg?_r_=6be734f6-aaeb-63b7-c7d0-44306f53f5e7" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-23</div><div class="title">javase面试题目hot2集合</div></div></a></div><div><a href="/2025/05/19/javase/javase2/" title="javase面试题目hot1基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=25ba0a99-fd04-d47d-7748-8ca299856644" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-19</div><div class="title">javase面试题目hot1基础</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.JVM的内存模型介绍一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E9%87%8C%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.JVM内存模型里的堆和栈有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%88%E4%B8%AD%E5%AD%98%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3.栈中存的到底是指针还是对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A0%86%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E5%91%A2%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4.堆分为哪几部分呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%AA%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%80%E8%88%AC%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5.如果有个大对象一般是在哪个区域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.程序计数器的作用，为什么是私有的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7.方法区中的方法的执行过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-HotSpot-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BA%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">8.HotSpot 为什么要分为新生代和老年代？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9.方法区中还有哪些东西？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-String%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10.String保存在哪里呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-String-s-new-String%EF%BC%88%E2%80%9Cabc%E2%80%9D%EF%BC%89%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">11.String s &#x3D; new String（“abc”）执行过程中分别对应哪些内存区域？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BD%AF%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.1.</span> <span class="toc-text">1.为什么软引用可以防止内存溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.引用类型有哪些？有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BC%B1%E5%BC%95%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%9C%A8%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3.弱引用了解吗?举例说明在哪里可以用?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4.内存泄漏和内存溢出的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-jvm-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.jvm 内存结构有哪几种内存溢出的情况？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9C%89%E5%85%B7%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E4%BE%8B%E5%AD%90%E4%B9%88%E8%AF%B7%E4%B8%BE%E4%BE%8B%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.6.</span> <span class="toc-text">6.有具体的内存泄漏和内存溢出的例子么请举例及解决方案?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.创建对象的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.对象的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3.类加载器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">3.双亲委派模型的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">4.讲一下类加载过程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.5.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8E%9F%E5%88%99"><span class="toc-number">3.6.</span> <span class="toc-text">5.讲一下类的加载和双亲委派原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJava%E9%87%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1.什么是Java里的垃圾回收？如何触发垃圾回收？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E5%9E%83%E5%9C%BE%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.判断垃圾的方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3.垃圾回收算法是什么，是为了解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4.垃圾回收算法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">5.垃圾回收器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">6.标记清除算法的缺点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%E4%BC%9Astop-the-world"><span class="toc-number">4.7.</span> <span class="toc-text">7.垃圾回收算法哪些阶段会stop the world?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-minorGC%E3%80%81majorGC%E3%80%81fullGC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E8%A7%A6%E5%8F%91full-GC"><span class="toc-number">4.8.</span> <span class="toc-text">8.minorGC、majorGC、fullGC的区别，什么场景触发full GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-CMS-%E5%92%8C-G1%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">9.垃圾回收器 CMS 和 G1的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8CMS%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8G1"><span class="toc-number">4.10.</span> <span class="toc-text">10.什么情况下使用CMS，什么情况使用G1?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%89%B9%E8%89%B2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">11.G1回收器的特色是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-GC%E5%8F%AA%E4%BC%9A%E5%AF%B9%E5%A0%86%E8%BF%9B%E8%A1%8CGC%E5%90%97%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">12.GC只会对堆进行GC吗？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/05/network/net4/" title="计算机网络面试题hot2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510550.jpg?_r_=e7eca60e-e37a-0b29-2ab7-1994322e8af6" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络面试题hot2"/></a><div class="content"><a class="title" href="/2025/06/05/network/net4/" title="计算机网络面试题hot2">计算机网络面试题hot2</a><time datetime="2025-06-04T16:00:00.000Z" title="发表于 2025-06-05 00:00:00">2025-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/31/new-stack/git/" title="Git"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=5f7e3e06-e9c2-fd3a-e5c6-ab7ba6f89c9a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git"/></a><div class="content"><a class="title" href="/2025/05/31/new-stack/git/" title="Git">Git</a><time datetime="2025-05-30T16:00:00.000Z" title="发表于 2025-05-31 00:00:00">2025-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/28/leetcode/leetocdehot1/" title="Leetcode HOT面试题目"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=1e6f007a-127d-172a-f968-c24fb7fcdf32" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode HOT面试题目"/></a><div class="content"><a class="title" href="/2025/05/28/leetcode/leetocdehot1/" title="Leetcode HOT面试题目">Leetcode HOT面试题目</a><time datetime="2025-05-27T16:00:00.000Z" title="发表于 2025-05-28 00:00:00">2025-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/27/java-stack/javasample1/" title="JAVA设计面试题目hot"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712180.jpg?_r_=5134985d-b810-aba1-4e91-a59f85899fee" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA设计面试题目hot"/></a><div class="content"><a class="title" href="/2025/05/27/java-stack/javasample1/" title="JAVA设计面试题目hot">JAVA设计面试题目hot</a><time datetime="2025-05-26T16:00:00.000Z" title="发表于 2025-05-27 00:00:00">2025-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/27/leetcode/leetcode4/" title="Leetcode动态规划"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837447.jpg?_r_=b8a6e082-9b27-9e96-b484-8d1324c6daf0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode动态规划"/></a><div class="content"><a class="title" href="/2025/05/27/leetcode/leetcode4/" title="Leetcode动态规划">Leetcode动态规划</a><time datetime="2025-05-26T16:00:00.000Z" title="发表于 2025-05-27 00:00:00">2025-05-27</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">126</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">18</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 0.88rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 0.88rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/football/" style="font-size: 0.88rem;">football<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>41</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>8</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>6</sup></a><a href="/tags/paper/" style="font-size: 0.88rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 0.88rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>3</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>2</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>7</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>4</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>18</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 0.88rem;">毛选<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>11</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>