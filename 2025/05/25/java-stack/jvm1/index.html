<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JVM-java虚拟机 | mengnankkのblog</title><meta name="keywords" content="java,jvm"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JVM-java虚拟机"><meta name="application-name" content="JVM-java虚拟机"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="JVM-java虚拟机"><meta property="og:url" content="https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="基本介绍 JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现··· JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=c7fb141a-72a5-5574-d622-d0dee0d44b7b"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=c7fb141a-72a5-5574-d622-d0dee0d44b7b"><meta name="description" content="基本介绍 JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现··· JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: 'JVM-java虚拟机',
  postAI: '',
  pageFillDescription: '基本介绍, 类加载器, 加载顺序, 双亲委派机制, 运行时数据区, 本地方法栈和程序计数器, 方法区, 虚拟机栈和虚拟机堆, 栈, 堆, 垃圾回收算法（GC）, 堆空间的基本结构, 新生代, 老年代, 空间分配担保, 对象死亡的判断方法, 引用计数器, 可达性分析, 使用终结器, 引用类型总结, 强引用, 软引用, 弱引用, 虚引用, 判断是不是该废弃, 垃圾回收算法, 标记清除算法, 复制算法, 标记整理算法, 分代收集算法, 垃圾收集器, Serial, ParNew, Parallerl Scavenge, Serial Old, Parallel Old, CMS, G1, ZGC, JVM 的常用参数基本介绍是的缩写它是一个虚构出来的计算机一种规范通过在实际的计算机上仿真模拟各类计算机功能实现其实就类似于一台小电脑运行在或者这些操作系统环境下即可它直接和操作系统进行交互与硬件不直接交互而操作系统可以帮我们完成和硬件进行交互的工作那我们的是不认识文本文件的所以它需要一个编译让其成为一个它会读二进制文件的如果想要执行这个文件我们需要将其装进一个类加载器中它就像一个搬运工一样会把所有的文件全部搬进里面来方法区是用于存放类似于元数据信息方面的数据的比如类信息常量静态变量编译后代码等类加载器将文件搬过来就是先丢到这一块上堆主要放了一些存储的数据比如对象实例数组等它和方法区都同属于线程共享区域也就是说它们都是线程不安全的栈这是我们的代码运行空间我们编写的每一个方法都会放到栈里面运行我们会听说过本地方法栈或者本地方法接口这两个名词不过我们基本不会涉及这两块的内容它俩底层是使用来进行工作的和没有太大的关系程序计数器主要就是完成一个加载工作类似于一个指针一样的指向下一行我们需要执行的代码和栈一样都是线程独享的就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题而的调优主要就是围绕堆栈两大块进行线程共享区就是线程不安全的区域执行过程编译好后得到后执行系统会启动一个进程从路径中找到一个名为的二进制文件将的类信息加载到运行时数据区的方法区内这个过程叫做类的加载找到的主程序入口执行方法这个中的第一条语句为就是让创建一个对象但是这个时候方法区中是没有类的信息的所以马上加载类把类的信息放到方法区中加载完类后在堆中为一个新的实例分配内存然后调用构造函数初始化实例这个实例持有指向方法区中的类的类型信息的引用执行时根据的引用找到对象然后根据对象持有的引用定位到方法区中类的类型信息的方法表获得的字节码地址执行只需要知道对象实例初始化时会去方法区中找类信息完成后再到栈那里去运行方法找方法就在方法表中找类加载器之前也提到了它是负责加载文件的它们在文件开头会有特定的文件标示将文件字节码内容加载到内存中并将这些内容转换成方法区中的运行时数据结构并且只负责文件的加载而是否能够运行则由来决定从类被加载到虚拟机内存中开始到释放内存总共有个步骤加载验证准备解析初始化使用卸载其中验证准备解析三个部分统称为连接将文件加载到内存将静态数据结构转化成方法区中运行时的数据结构在堆中生成一个代表这个类的对象作为数据访问的入口验证确保加载的类符合规范和安全保证被校验类的方法在运行时不会做出危害虚拟机的事件其实就是一个安全检查准备为变量在方法区中分配内存空间设置变量的初始值例如注意准备阶段只设置类中的静态变量方法区中不包括实例变量堆内存中实例变量是对象初始化时赋值的解析虚拟机将常量池内的符号引用替换为直接引用的过程符号引用比如我现在这就算符号引用直接引用就是指针或者对象地址注意引用对象一定是在内存进行初始化其实就是执行类构造器方法的的过程而且要保证执行前父类的方法执行完毕这个方法由编译器收集顺序执行所有类变量修饰的成员变量显式初始化和静态代码块中语句此时准备阶段时的那个由默认初始化的变成了显式初始化的由于执行顺序缘故初始化阶段类变量如果在静态代码块中又进行了更改会覆盖类变量的显式初始化最终值会为静态代码块中的赋值注意字节码文件中初始化方法有两种非静态资源初始化的和静态资源初始化的类构造器方法不同于类的构造器这些方法都是字节码文件中只能给识别的特殊方法将无用对象从内存中卸载加载顺序加载一个类的顺序也是有优先级的类加载器从最底层开始往上的顺序是这样的加载扩展的包指定的下面的包自定义的类加载器双亲委派机制当一个类收到了加载请求时它是不会先自己去尝试加载的而是委派给父类去完成比如我现在要一个这个是我们自定义的类如果我们要加载它就会先委派只有当父类加载器都反馈自己无法完成这个请求也就是父类加载器都没有找到加载所需的时子类加载器才会自行尝试加载这样做的好处是加载位于包中的类时不管是哪个加载器加载最终都会委托到进行加载这样保证了使用不同的类加载器得到的都是同一个结果其实这个也是一个隔离的作用避免了我们的代码影响了的代码比如我现在自己定义一个尝试运行当前类的函数的时候我们的代码肯定会报错这是因为在加载的时候其实是找到了中的然而发现这个里面并没有方法运行时数据区本地方法栈和程序计数器比如说我们现在点开类的源码会看到它的方法带有一个关键字修饰而且不存在方法体这种用修饰的方法就是本地方法这是使用来实现的然后一般这些方法都会放到一个叫做本地方法栈的区域程序计数器其实就是一个指针它指向了我们程序中下一句需要执行的指令它也是内存区域中唯一一个不会出现的区域而且占用内存空间小到基本可以忽略不计这个内存仅代表当前线程所执行的字节码的行号指示器字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令如果执行的是方法那这个指针就不工作了方法区方法区主要的作用是存放类的元数据信息常量和静态变量等当它存储的信息过大时会在无法满足内存分配时报错虚拟机栈和虚拟机堆一句话便是栈管运行堆管存储则虚拟机栈负责运行代码而虚拟机堆负责存储数据栈它是方法执行的内存模型里面会对局部变量动态链表方法出口栈的操作入栈和出栈进行存储且线程独享同时如果我们听到局部变量表那也是在说虚拟机栈如果线程请求的栈的深度大于虚拟机栈的最大深度就会报这种错误经常出现在递归中虚拟机也可以动态扩展但随着扩展会不断地申请内存当无法申请足够内存时就会报错对于栈来说不存在垃圾回收只要程序运行结束栈的空间自然就会释放了栈的生命周期和所处的线程是一致的这里补充一句种基本类型的变量对象的引用变量实例方法都是在栈里面分配内存我们经常说的栈帧数据说白了在中叫栈帧放到中其实就是方法它也是存放在栈中的栈中的数据都是以栈帧的格式存在它是一个关于方法和运行期数据的数据集比如我们执行一个方法就会对应产生一个栈帧然后会被压入栈中同理方法会有一个方法会有一个等到这个线程执行完毕后栈会先弹出后它是一个先进后出后进先出原则局部变量表用于存放方法参数和方法内部所定义的局部变量它的容量是以为最小单位一个可以存放位以内的数据类型虚拟机通过索引定位的方式使用局部变量表范围为局部变量表的的数量方法中的参数就会按一定顺序排列在这个局部变量表中至于怎么排的我们可以先不关心而为了节省栈帧空间这些是可以复用的当方法执行位置超过了某个变量那么这个变量的可以被其它变量复用当然如果需要复用那我们的垃圾回收自然就不会去动这些内存堆内存会划分为堆内存和非堆内存堆内存中也会划分为年轻代和老年代而非堆内存则为永久代年轻代又会分为和区也会分为和的区域是空的和的默认占比为当然这个东西其实也可以通过一个参数来根据生成对象的速率动态调整堆内存中存放的是对象垃圾收集就是收集这些对象然后交给算法进行回收非堆内存其实我们已经说过了就是方法区在中已经移除永久代替代品是一个元空间最大区别是是不存在于中的它使用的是本地内存并有两个参数初始化元空间大小控制发生限制元空间大小上限防止占用过多物理内存移除的原因可以大致了解一下融合和而做出的改变因为是没有永久代的不过这也间接性地解决了永久代的问题年轻代当我们一个对象后会先放到划分出来的一块作为存储空间的内存但是我们知道对堆内存是线程共享的所以有可能会出现两个对象共用一个内存的情况这里的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置而如果空间不足会再申请多块内存空间这个操作我们会称作有兴趣可以了解一下修正当区内存空间满了的时候就会触发区满不会触发那区的对象什么时候垃圾回收呢假设区现在是满的此时又触发了发现区依旧是满的存不下此时会将区与区的对象一起进行可达性分析找出活跃的对象将它复制到区并且将区域和区的对象给清空这样那些不可达的对象进行清除并且将区和区交换老年代老年代是存储长期存活的对象的占满时就会触发我们最常听说的期间会停止所有线程等待的完成所以对于响应要求高的应用应该尽量去减少发生从而避免响应超时的问题而且当老年区执行了之后仍然无法进行对象保存的操作就会产生这时候就是虚拟机中的堆内存不足原因可能会是堆内存设置的大小过小这个可以通过参数来调整也可能是代码中创建的对象大且多而且它们一直在被引用从而长时间垃圾收集无法收集它们回收图中程序计数器虚拟机栈本地方法栈个区域随着线程的生存而生存的内存分配和回收都是确定的随着线程的结束内存自然就被回收了因此不需要考虑垃圾回收的问题而堆和方法区则不一样各线程共享内存的分配和回收都是动态的因此垃圾收集器所关注的都是堆和方法这部分内存在进行回收前就要判断哪些对象还存活哪些已经死去下面介绍两个基础的计算方法引用计数器计算给对象添加一个引用计数器每次引用这个对象时计数器加一引用失效时减一计数器等于时就是不会再次使用的不过这个方法有一种情况就是出现对象的循环引用时没法回收可达性分析计算这是一种类似于二叉树的实现将一系列的作为起始的存活对象集从这个节点往下搜索搜索所走过的路径成为引用链把能被该集合引用到的对象加入到集合中搜索当一个对象到没有使用任何引用链时则说明该对象是不可用的主流的商用程序语言例如等都是靠这招去判定对象是否存活的终结器如果对象重写了方法垃圾回收器会在回收该对象之前调用方法对象可以在方法中进行一些清理操作然而终结器机制的使用不被推荐因为它的执行时间是不确定的可能会导致不可预测的性能问题这个类似于中的一个对象的方法只会被系统自动调用一次经过方法逃脱死亡的对象第二次不会再调用补充一句并不提倡在程序中调用来进行自救建议忘掉程序中该方法的存在因为它执行的时间不确定甚至是否被执行也不确定程序的不正常退出而且运行代价高昂无法保证各个对象的调用顺序甚至有不同线程中调用在中已经被标记为且也就是强软弱幻象引用的那一套中已经逐步替换掉它会比来的更加的轻量及可靠在语言汇总能作为的对象分为以下几种虚拟机栈栈帧中的本地方法表中引用的对象局部变量方法区中静态变量所引用的对象静态变量方法区中常量引用的对象本地方法栈即修饰的方法中引用的对象是虚拟机调用对应的函数的方式通过函数也可以创建新的对象且对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收已启动的且未终止的线程这种方法的优点是能够解决循环引用的问题可它的实现需要耗费大量资源和时间也需要它的分析过程引用关系不能发生变化所以需要停止所有进程判断一个对象的死亡至少需要两次标记如果对象进行可达性分析之后没发现与相连的引用链那它将会第一次标记并且进行一次筛选判断的条件是决定这个对象是否有必要执行方法如果对象有必要执行方法则被放入队列中对队列中的对象进行二次标记如果对象在方法中重新与引用链上的任何一个对象建立了关联那么二次标记时则会将它移出即将回收集合如果此时对象还没成功逃脱那么只能被回收了如果确定对象已经死亡我们又该如何回收这些垃圾呢垃圾回收算法堆空间的基本结构的自动内存管理主要是针对对象内存的回收和对象内存的分配同时自动内存管理最核心的功能是堆内存中对象的分配与回收堆是垃圾收集器管理的主要区域因此也被称作堆从垃圾回收的角度来说由于现在收集器基本都采用分代垃圾收集算法所以堆被划分为了几个不同的区域这样我们就可以根据各个区域的特点选择合适的垃圾收集算法在版本及版本之前堆内存被通常分为下面三部分新生代内存老生代永久代下图所示的区两个区和都属于新生代中间一层属于老年代最下面一层属于永久代之后改为元空间方法区新生代当区没有足够空间进行分配时虚拟机将发起一次期间虚拟机又发现无法存入空间所以只好通过分配担保机制把新生代的对象提前转移到老年代中去老年代上的空间足够存放所以不会出现执行后后面分配的对象如果能够存在区的话还是会在区分配内存老年代大对象就是需要大量连续内存空间的对象比如字符串数组大对象直接进入老年代的行为是由虚拟机动态决定的它与具体使用的垃圾回收器和相关参数有关大对象直接进入老年代是一种优化策略旨在避免将大对象放入新生代从而减少新生代的垃圾回收频率和成本垃圾回收器会根据参数设置的堆区域大小和参数设置的阈值来决定哪些对象会直接进入老年代垃圾回收器中默认情况下并没有一个固定的阈值是动态调整的来决定何时直接在老年代分配大对象而是由虚拟机根据当前的堆内存情况和历史数据动态决定既然虚拟机采用了分代收集的思想来管理内存那么内存回收时就必须能识别哪些对象应放在新生代哪些对象应放在老年代中为了做到这一点虚拟机给每个对象一个对象年龄计数器如果对象在出生并经过第一次后仍然能够存活并且能被容纳的话将被移动到空间或者中并将对象年龄设为区区后对象的初始年龄变为对象在中每熬过一次年龄就增加岁当它的年龄增加到一定程度默认为岁就会被晋升到老年代中对象晋升到老年代的年龄阈值可以通过参数来设置遍历所有对象时按照年龄从小到大对其所占用的大小进行累积当累积的某个年龄大小超过了区的时默认值是可以通过来设置取这个年龄和中更小的一个值作为新的晋升年龄阈值默认晋升年龄并不都是这个是要区分垃圾收集器的就是针对的实现它里面的其实准确分类只有两大种部分收集新生代收集只对新生代进行垃圾收集老年代收集只对老年代进行垃圾收集需要注意的是在有的语境中也用于指代整堆收集混合收集对整个新生代和部分老年代进行垃圾收集整堆收集收集整个堆和方法区空间分配担保空间分配担保是为了确保在之前老年代本身还有容纳新生代所有对象的剩余空间之前在发生之前虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间如果这个条件成立那这一次可以确保是安全的如果不成立则虚拟机会先查看参数的设置值是否允许担保失败如果允许那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小如果大于将尝试进行一次尽管这次是有风险的如果小于或者设置不允许冒险那这时就要改为进行一次之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行否则将进行对象死亡的判断方法引用计数器给对象中添加一个引用计数器每当有一个地方引用它计数器就加当引用失效计数器就减任何时候计数器为的对象就是不可能再被使用的这个方法实现简单效率高但是目前主流的虚拟机中并没有选择这个算法来管理内存其最主要的原因是它很难解决对象之间循环引用的问题例子如下面代码所示除了对象和相互引用着对方之外这两个对象之间再无任何引用但是他们因为互相引用对方导致它们的引用计数器都不为于是引用计数算法无法通知回收器回收他们可达性分析通过一系列的称为的对象作为起点从这些节点开始向下搜索节点所走过的路径称为引用链当一个对象到没有任何引用链相连的话则证明此对象是不可用的需要被回收哪些对象可以作为呢虚拟机栈栈帧中的局部变量表中引用的对象本地方法栈方法中引用的对象方法区中类静态属性引用的对象方法区中常量引用的对象所有被同步锁持有的对象引用的对象然后要进行两次标记之后才会真正给他回收了判断一个对象的死亡至少需要两次标记如果对象进行可达性分析之后没发现与相连的引用链那它将会第一次标记并且进行一次筛选判断的条件是决定这个对象是否有必要执行方法如果对象有必要执行方法则被放入队列中对队列中的对象进行二次标记如果对象在方法中重新与引用链上的任何一个对象建立了关联那么二次标记时则会将它移出即将回收集合如果此时对象还没成功逃脱那么只能被回收了使用终结器但是他嗯成为了语言的负担影响了语言的安全和的性能引用类型总结之前中引用的定义很传统如果类型的数据存储的数值代表的是另一块内存的起始地址就称这块内存代表一个引用以后对引用的概念进行了扩充将引用分为强引用软引用弱引用虚引用四种引用强度逐渐减弱强引用就是中普通的对象而软引用弱引用虚引用在中定义的类分别是强引用就是程序代码中普遍存在的引用赋值这是使用最普遍的引用其代码如下如果一个对象具有强引用那就类似于必不可少的生活用品垃圾回收器绝不会回收它当内存空间不足虚拟机宁愿抛出错误使程序异常终止也不会靠随意回收具有强引用的对象来解决内存不足问题软引用如果一个对象只具有软引用那就类似于可有可无的生活用品软引用代码如下软引用如果内存空间足够垃圾回收器就不会回收它如果内存空间不足了就会回收这些对象的内存只要垃圾回收器没有回收它该对象就可以被程序使用软引用可用来实现内存敏感的高速缓存软引用可以和一个引用队列联合使用如果软引用所引用的对象被垃圾回收虚拟机就会把这个软引用加入到与之关联的引用队列中弱引用如果一个对象只具有弱引用那就类似于可有可无的生活用品弱引用代码如下变成软引用可以被收集弱引用与软引用的区别在于只具有弱引用的对象拥有更短暂的生命周期在垃圾回收器线程扫描它所管辖的内存区域的过程中一旦发现了只具有弱引用的对象不管当前内存空间足够与否都会回收它的内存不过由于垃圾回收器是一个优先级很低的线程因此不一定会很快发现那些只具有弱引用的对象弱引用可以和一个引用队列联合使用如果弱引用所引用的对象被垃圾回收虚拟机就会把这个弱引用加入到与之关联的引用队列中虚引用虚引用顾名思义就是形同虚设与其他几种引用都不同虚引用并不会决定对象的生命周期如果一个对象仅持有虚引用那么它就和没有任何引用一样在任何时候都可能被垃圾回收虚引用代码如下创建虚引用要求必须与一个引用队列关联虚引用主要用来跟踪对象被垃圾回收的活动虚引用与软引用和弱引用的一个区别在于虚引用必须和引用队列联合使用当垃圾回收器准备回收一个对象时如果发现它还有虚引用就会在回收对象的内存之前把这个虚引用加入到与之关联的引用队列中程序可以通过判断引用队列中是否已经加入了虚引用来了解被引用的对象是否将要被垃圾回收程序如果发现某个虚引用已经被加入到引用队列那么就可以在所引用的对象的内存被回收之前采取必要的行动特别注意在程序设计中一般很少使用弱引用与虚引用使用软引用的情况较多这是因为软引用可以加速对垃圾内存的回收速度可以维护系统的运行安全防止内存溢出等问题的产生为什么软引用可以防止内存溢出减轻内存压力软引用对象在内存紧张时会被回收这意味着对于一些缓存型对象如图片缓存数据缓存使用软引用能让在不影响系统运行的前提下自动清理不重要的对象避免这些对象一直占用内存导致有利于缓存系统的实现比如在图片浏览器数据库连接池网页浏览器中常常需要缓存大量数据使用软引用作为缓存的基础可以确保缓存不会占用过多堆内存系统空闲时缓存仍可用一旦内存紧张缓存自动释放系统依旧安全运行相比强引用更灵活相比弱引用更安全引用类型回收时机是否适合做缓存对系统安全性的影响强引用永不回收除非没有引用会导致高风险弱引用时就回收不适合稳定但易失效软引用内存不足时回收非常适合安全可靠为什么弱引用虚引用用得少弱引用一旦触发不管内存够不够都会被回收太激进不适合缓存虚引用更偏底层用于监控对象被回收的时机不具备访问能力需要配合使用复杂度高判断是不是该废弃运行时常量池主要回收的是废弃的常量那么我们如何判断一个常量是废弃常量呢之前运行时常量池逻辑包含字符串常量池存放在方法区此时虚拟机对方法区的实现为永久代字符串常量池被从方法区拿到了堆中这里没有提到运行时常量池也就是说字符串常量池被单独拿到堆运行时常量池剩下的东西还在方法区也就是中的永久代移除了永久代用元空间取而代之这时候字符串常量池还在堆运行时常量池还在方法区只不过方法区的实现从永久代变成了元空间假如在字符串常量池中存在字符串如果当前没有任何对象引用该字符串常量的话就说明常量就是废弃常量如果这时发生内存回收的话而且有必要的话就会被系统清理出常量池了方法区主要回收的是无用的类那么如何判断一个类是无用的类的呢判定一个常量是否是废弃常量比较简单而要判定一个类是否是无用的类的条件则相对苛刻许多类需要同时满足下面个条件才能算是无用的类该类所有的实例都已经被回收也就是堆中不存在该类的任何实例加载该类的已经被回收该类对应的对象没有在任何地方被引用无法在任何地方通过反射访问该类的方法虚拟机可以对满足上述个条件的无用类进行回收这里说的仅仅是可以而并不是和对象一样不使用了就会必然被回收垃圾回收算法标记清除算法标记清除算法分为标记和清除阶段首先标记出所有不需要回收的对象在标记完成后统一回收掉所有没有被标记的对象它是最基础的收集算法后续的算法都是对其不足进行改进得到这种垃圾收集算法会带来两个明显的问题效率问题标记和清除两个过程效率都不高空间问题标记清除后会产生大量不连续的内存碎片如果按照前者的理解整个标记清除过程大致是这样的当一个对象被创建时给一个标记位假设为在标记阶段我们将所有可达对象或用户可以引用的对象的标记位设置为扫描阶段清除的就是标记位为的对象复制算法为了解决标记清除算法的效率和内存碎片问题复制收集算法出现了它可以将内存分为大小相同的两块每次使用其中的一块当这一块的内存使用完后就将还存活的对象复制到另一块去然后再把使用的空间一次清理掉这样就使每次的内存回收都是对内存区间的一半进行回收虽然改进了标记清除算法但依然存在下面这些问题可用内存变小可用内存缩小为原来的一半不适合老年代如果存活对象数量比较大复制性能会变得很差标记整理算法标记整理算法是根据老年代的特点提出的一种标记算法标记过程仍然与标记清除算法一样但后续步骤不是直接对可回收对象回收而是让所有存活的对象向一端移动然后直接清理掉端边界以外的内存由于多了整理这一步因此效率也不高适合老年代这种垃圾回收频率不是很高的场景分代收集算法当前虚拟机的垃圾收集都采用分代收集算法这种算法没有什么新的思想只是根据对象存活周期的不同将内存分为几块一般将堆分为新生代和老年代这样我们就可以根据各个年代的特点选择合适的垃圾收集算法比如在新生代中每次收集都会有大量对象死去所以可以选择复制算法只需要付出少量对象的复制成本就可以完成每次垃圾收集而老年代的对象存活几率是比较高的而且没有额外的空间对它进行分配担保所以我们必须选择标记清除或标记整理算法进行垃圾收集垃圾收集器如果说收集算法是内存回收的方法论那么垃圾收集器就是内存回收的具体实现虽然我们对各个收集器进行比较但并非要挑选出一个最好的收集器因为直到现在为止还没有最好的垃圾收集器出现更加没有万能的垃圾收集器我们能做的就是根据具体应用场景选择适合自己的垃圾收集器试想一下如果有一种四海之内任何场景下都适用的完美收集器存在那么我们的虚拟机就不会实现那么多不同的垃圾收集器了默认垃圾收集器使用命令查看新生代老年代串行收集器是最基本历史最悠久的垃圾收集器了大家看名字就知道这个收集器是一个单线程收集器了它的单线程的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程直到它收集结束新生代采用标记复制算法老年代采用标记整理算法虚拟机的设计者们当然知道带来的不良用户体验所以在后续的垃圾收集器设计中停顿时间在不断缩短仍然还有停顿寻找最优秀的垃圾收集器的过程仍然在继续但是收集器有没有优于其他垃圾收集器的地方呢当然有它简单而高效与其他收集器的单线程相比收集器由于没有线程交互的开销自然可以获得很高的单线程收集效率收集器对于运行在模式下的虚拟机来说是个不错的选择收集器其实就是收集器的多线程版本除了使用多线程进行垃圾收集外其余行为控制参数收集算法回收策略等等和收集器完全一样新生代采用标记复制算法老年代采用标记整理算法它是许多运行在模式下的虚拟机的首要选择除了收集器外只有它能与收集器真正意义上的并发收集器后面会介绍到配合工作并行和并发概念补充并行指多条垃圾收集线程并行工作但此时用户线程仍然处于等待状态并发指用户线程与垃圾收集线程同时执行但不一定是并行可能会交替执行用户程序在继续运行而垃圾收集器运行在另一个上收集器也是使用标记复制算法的多线程收集器它看上去几乎和都一样那么它有什么特别之处呢使用收集器老年代串行使用收集器老年代并行收集器关注点是吞吐量高效率的利用等垃圾收集器的关注点更多的是用户线程的停顿时间提高用户体验所谓吞吐量就是中用于运行用户代码的时间与总消耗时间的比值收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量如果对于收集器运作不太了解手工优化存在困难的时候使用收集器配合自适应调节策略把内存管理优化交给虚拟机去完成也是一个不错的选择新生代采用标记复制算法老年代采用标记整理算法这是默认收集器使用命令查看默认使用的是如果指定了参数则默认指定了可以使用来禁用该功能收集器的老年代版本它同样是一个单线程收集器它主要有两大用途一种用途是在以及以前的版本中与收集器搭配使用另一种用途是作为收集器的后备方案收集器的老年代版本使用多线程和标记整理算法在注重吞吐量以及资源的场合都可以优先考虑收集器和收集器收集器是一种以获取最短回收停顿时间为目标的收集器它非常符合在注重用户体验的应用上使用收集器是虚拟机第一款真正意义上的并发收集器它第一次实现了让垃圾收集线程与用户线程基本上同时工作从名字中的这两个词可以看出收集器是一种标记清除算法实现的它的运作过程相比于前面几种垃圾收集器来说更加复杂一些整个过程分为四个步骤初始标记短暂停顿标记直接与相连的对象根对象并发标记同时开启和用户线程用一个闭包结构去记录可达对象但在这个阶段结束这个闭包结构并不能保证包含当前所有的可达对象因为用户线程可能会不断的更新引用域所以线程无法保证可达性分析的实时性所以这个算法里会跟踪记录这些发生引用更新的地方重新标记重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录这个阶段的停顿时间一般会比初始标记阶段的时间稍长远远比并发标记阶段时间短并发清除开启用户线程同时线程开始对未标记的区域做清扫从它的名字就可以看出它是一款优秀的垃圾收集器主要优点并发收集低停顿但是它有下面三个明显的缺点对资源敏感无法处理浮动垃圾它使用的回收算法标记清除算法会导致收集结束时会有大量空间碎片产生垃圾回收器在中已经被标记为过时并在中被移除是一款面向服务器的垃圾收集器主要针对配备多颗处理器及大容量内存的机器以极高概率满足停顿时间要求的同时还具备高吞吐量性能特征被视为中虚拟机的一个重要进化特征它具备以下特点并行与并发能充分利用多核环境下的硬件优势使用多个或者核心来缩短停顿时间暂停其他的线程部分其他收集器原本需要停顿线程执行的动作收集器仍然可以通过并发的方式让程序继续执行分代收集虽然可以不需要其他收集器配合就能独立管理整个堆但是还是保留了分代的概念空间整合与的标记清除算法不同从整体来看是基于标记整理算法实现的收集器从局部上来看是基于标记复制算法实现的可预测的停顿这是相对于的另一个大优势降低停顿时间是和共同的关注点但除了追求低停顿外还能建立可预测的停顿时间模型能让使用者明确指定在一个长度为毫秒的时间片段内消耗在垃圾收集上的时间不得超过毫秒收集器的运作大致分为以下几个步骤初始标记短暂停顿标记从可直接引用的对象即标记所有直接可达的活跃对象并发标记与应用并发运行标记所有可达对象这一阶段可能持续较长时间取决于堆的大小和对象的数量最终标记短暂停顿处理并发标记阶段结束后残留的少量未处理的引用变更筛选回收根据标记结果选择回收价值高的区域复制存活对象到新区域回收旧区域内存这一阶段包含一个或多个停顿具体取决于回收的复杂度收集器在后台维护了一个优先列表每次根据允许的收集时间优先选择回收价值最大的这也就是它的名字的由来这种使用划分内存空间以及有优先级的区域回收方式保证了收集器在有限时间内可以尽可能高的收集效率把内存化整为零从开始垃圾收集器成为了默认的垃圾收集器与中的和类似也采用标记复制算法不过对该算法做了重大改进可以将暂停时间控制在几毫秒以内且暂停时间不受堆内存大小的影响出现的情况会更少但代价是牺牲了一些吞吐量最大支持的堆内存在中引入处于试验阶段经过多个版本的迭代不断的完善和修复问题在已经可以正式使用了不过默认的垃圾回收器依然是你可以通过下面的参数启用在中引入了分代暂停时间可以缩短到毫秒以内你可以通过下面的参数启用分代的常用参数参数名作用描述示例值说明初始堆内存大小最大堆内存大小新生代大小控制区前初始永久代大小方法区前最大永久代大小元空间初始大小元空间最大大小输出详细信息调试用使用串行垃圾收集器适合单核或小内存环境使用并行收集器吞吐量优先默认在使用收集器低延迟场景推荐在大内存服务端场景中使用与区大小比时导出内存快照用于定位内存泄漏指定文件路径设置每个线程的栈大小打印日志时附带时间戳调试用压缩对象指针节省位内存默认开启设置系统属性常用于配置示例',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-29 22:07:55',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 1.05rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/Cache/" style="font-size: 1.05rem;">Cache<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 1.05rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/Github/" style="font-size: 1.05rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>2</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/SpringAI/" style="font-size: 1.05rem;">SpringAI<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>57</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>10</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>7</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>4</sup></a><a href="/tags/rocketmq/" style="font-size: 1.05rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>3</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>24</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a><a class="article-meta__tags" href="/tags/jvm/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>jvm</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JVM-java虚拟机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-24T16:00:00.000Z" title="发表于 2025-05-25 00:00:00">2025-05-25</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-29T14:07:55.582Z" title="更新于 2025-05-29 22:07:55">2025-05-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">12.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="JVM-java虚拟机"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=c7fb141a-72a5-5574-d622-d0dee0d44b7b"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><a href="/tags/jvm/" tabindex="-1" itemprop="url">jvm</a><h1 id="CrawlerTitle" itemprop="name headline">JVM-java虚拟机</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-05-24T16:00:00.000Z" title="发表于 2025-05-25 00:00:00">2025-05-25</time><time itemprop="dateCreated datePublished" datetime="2025-05-29T14:07:55.582Z" title="更新于 2025-05-29 22:07:55">2025-05-29</time></header><h1>基本介绍</h1>
<p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p>
<p>JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。<strong>它直接和操作系统进行交互</strong>，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" alt=""></p>
<p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p>
<p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进 JVM 里面来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://static001.geekbang.org/infoq/2f/2f012fde94376f43a25dbe1dd07e0dd8.png" alt=""></p>
<p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p>
<p>类加载器将 .class 文件搬过来就是先丢到这一块上</p>
<p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p>
<p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p>
<p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系</p>
<p><strong>程序计数器</strong>主要就是完成一个<strong>加载工作</strong>，类似于一个指针一样的，指向<strong>下一行我们需要执行的代码。和栈一样</strong>，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://static001.geekbang.org/infoq/c6/c602f57ea9297f50bbc265f1821d6263.png" alt=""></p>
<p>而 JVM 的调优主要就是围绕堆，栈两大块进行</p>
<p>线程共享区就是线程不安全的区域</p>
<p>执行过程：</p>
<p>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</p>
<p>JVM 找到 App 的主程序入口，执行 main 方法</p>
<p>这个 main 中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</p>
<p>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</p>
<p>执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</p>
<p>执行 sayName()</p>
<p>只需要知道对象实例初始化时会去<strong>方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</strong></p>
<h1>类加载器</h1>
<p>之前也提到了它是<strong>负责加载.class 文件</strong>的，它们在文件开头会有特定的文件标示，**将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，**并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</p>
<p>从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p>
<ol>
<li>
<p>将 class 文件加载到内存</p>
</li>
<li>
<p>将静态数据结构转化成方法区中运行时的数据结构</p>
</li>
<li>
<p>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</p>
</li>
<li>
<p>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，<strong>其实就是一个安全检查</strong></p>
</li>
<li>
<p>准备：<strong>为 static 变量在方法区中分配内存空间，设置变量的初始值</strong>，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</p>
</li>
<li>
<p>解析：虚拟机将<strong>常量池内的符号引用替换为直接引用的过程</strong>（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，<strong>直接引用就是指针或者对象地址</strong>，注意引用对象一定是在内存进行）</p>
</li>
<li>
<p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由<strong>编译器收集</strong>，<strong>顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句</strong>。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，<strong>初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</strong></p>
<blockquote>
<p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p>
</blockquote>
</li>
</ol>
<p>8.GC 将无用对象从内存中卸载</p>
<h2 id="加载顺序">加载顺序</h2>
<p>加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<ol>
<li>BootStrap ClassLoader：rt.jar</li>
<li>Extension ClassLoader: 加载扩展的 jar 包</li>
<li>App ClassLoader：指定的 classpath 下面的 jar 包</li>
<li>Custom ClassLoader：自定义的类加载器</li>
</ol>
<h2 id="双亲委派机制">双亲委派机制</h2>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，<strong>而是委派给父类去完成</strong>，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，<strong>只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</strong></p>
<p>这样做的好处是，<strong>加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader</strong> 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p>
<p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 <code>java.lang.String</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">public class String &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p>
<hr>
<h1>运行时数据区</h1>
<h2 id="本地方法栈和程序计数器">本地方法栈和程序计数器</h2>
<p>比如说我们现在点开 Thread 类的源码，会看到它的 start0 方法带有一个 native 关键字修饰，而且不存在方法体，<strong>这种用 native 修饰的方法就是本地方法</strong>，这是使用 C 来实现的，<strong>然后一般这些方法都会放到一个叫做本地方法栈的区域。</strong></p>
<p>程序计数器其实就是<strong>一个指针</strong>，它指向了<strong>我们程序中下一句需要执行的指令</strong>，<strong>它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。<strong>这个内存仅代表</strong>当前线程所执行的字节码的行号指示器</strong>，字节码解析器通过<strong>改变这个计数器的值选取下一条需要执行的字节码指令。</strong></p>
<p>如果执行的是 native 方法，那这个指针就不工作了。</p>
<h2 id="方法区">方法区</h2>
<p>方法区主要的作用是<strong>存放类的元数据信息</strong>，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p>
<h2 id="虚拟机栈和虚拟机堆">虚拟机栈和虚拟机堆</h2>
<p>一句话便是：<strong>栈管运行，堆管存储</strong>。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p>
<h3 id="栈">栈</h3>
<p>它是 Java 方法执行的<strong>内存模型</strong>。里面会对**局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。**同时如果我们听到局部变量表，那也是在说虚拟机栈</p>
<p>如果线程请求的<strong>栈的深度大于虚拟机栈的最大深度</strong>，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p>
<p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p>
<p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p>
<p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，<strong>放到 Java 中其实就是方法</strong>，它也是存放在栈中的。</p>
<p>栈中的<strong>数据都是以栈帧</strong>的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。<strong>它是一个先进后出，后进先出原则。</strong></p>
<p>局部变量表用于存放<strong>方法参数和方法内部所定义的局部变量</strong>。它的容量是以 Slot 为最小单位，<strong>一个 slot 可以存放 32 位以内的数据类型</strong>。</p>
<p>虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，范围为 <code>[0,局部变量表的 slot 的数量]</code>。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，<strong>这些 slot 是可以复用的</strong>，**当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。**当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p>
<h3 id="堆">堆</h3>
<p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 <strong>-XX:+UsePSAdaptiveSurvivorSizePolicy</strong> 参数来根据生成对象的速率动态调整</p>
<p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。<strong>非堆内存其实我们已经说过了，就是方法区</strong>。在 1.8 中已经移除永久代，<strong>替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MetaspaceSize：初始化元空间大小，控制发生GC</span><br><span class="line">MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</span><br></pre></td></tr></table></figure>
<p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p>
<p><strong>年轻代：：：：</strong></p>
<p>当我们 new 一个对象后，会先放到 Eden 划分出来的**一块作为存储空间的内存，<strong>但是我们知道对堆内存是线程共享的，<strong>所以有可能会出现两个对象共用一个内存的情况</strong>。这里 JVM 的处理是</strong>为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB，**有兴趣可以了解一下</p>
<p>修正：当 Eden 区内存空间满了的时候，就会触发 <strong>Minor GC</strong>，Survivor0 区满不会触发 Minor GC 。</p>
<p><strong>那 Survivor0 区 的对象什么时候垃圾回收呢？</strong></p>
<p>假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，<strong>此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换</strong></p>
<p><strong>老年代</strong>：：：：：</p>
<p>老年代是<strong>存储长期存活的对象</strong>的，占满时就会触发我们最常听说的 <strong>Full GC</strong>，<strong>期间会停止所有线程等待 GC 的完成</strong>。所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p>
<p><strong>而且当老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 OOM</strong>，这时候就是<strong>虚拟机中的堆内存不足</strong>，原因可能会是堆内存设置的<strong>大小过小</strong>，这个可以通过参数-Xms、-Xmx 来调整。<strong>也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://static001.geekbang.org/infoq/39/398255141fde8ba208f6c99f4edaa9fe.png" alt=""></p>
<p><strong>回收：：：：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://static001.geekbang.org/infoq/1b/1ba7f3cff6e07c6e9c6765cc4ef74997.png" alt=""></p>
<p>图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而 Java 堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p>
<p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p>
<p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，<strong>计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</strong></p>
<p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的 <strong>GC ROOTS</strong> 作为起始的存活对象集，<strong>从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言</strong>，例如 Java，C#等都是靠这招去判定对象是否存活的。</p>
<p>3.<strong>终结器</strong>（Finalizer）：如果对象重写了<code>finalize()</code>方法，垃圾回收器会在回收该对象之前调用<code>finalize()</code>方法，对象可以在<code>finalize()</code>方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。这个类似于try-catch-finally中的finally</p>
<p>一个对象的 finalize()方法只会被<strong>系统自动调用一次</strong>，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。</p>
<p>补充一句：并不提倡在程序中调用 finalize()来进行自救。**建议忘掉 Java 程序中该方法的存在。**因为它执行的时间不确定，甚至是否被执行也不确定（Java 程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java9 中已经被标记为 <strong>deprecated</strong> ，且 <code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 <code>finalize</code> 来的更加的轻量及可靠。</p>
<hr>
<p>在 Java 语言汇总能作为 GC Roots 的对象分为以下几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地方法表）中引用的对象（<strong>局部变量</strong>）</li>
<li>方法区中静态变量所引用的对象（<strong>静态变量</strong>）</li>
<li>方法区中<strong>常量引用的对象</strong></li>
<li><strong>本地方法栈（即 native 修饰的方法）中 JNI 引用的对象</strong>（JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li>
<li>已启动的且未终止的 Java 线程</li>
</ol>
<p>这种方法的优点是能够<strong>解决循环引用的问题</strong>，可它的实现需要耗费大量资源和时间，也需要 GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p>
<p>判断一个对象的死亡至少需要两次标记</p>
<ol>
<li>如果<strong>对象进行可达性分析之后没发现与 GC Roots 相连的引用链</strong>，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。<strong>如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</strong></li>
<li>GC 对 F-Queue 队列中的对象进行二次标记。<strong>如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</strong></li>
</ol>
<p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p>
<hr>
<h1>垃圾回收算法（GC）</h1>
<h2 id="堆空间的基本结构">堆空间的基本结构</h2>
<p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>
<p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)</li>
</ol>
<p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。1.8之后改为元空间（方法区）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt=""></p>
<h3 id="新生代">新生代</h3>
<p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把<strong>新生代的对象提前转移到老年代中去</strong>，老年代上的空间足够存放 <code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存</p>
<h3 id="老年代">老年代</h3>
<p>大对象就是需要<strong>大量连续内存空间的对象</strong>（比如：字符串、数组）。</p>
<p>大对象直接进入老年代的行为是由<strong>虚拟机动态决定</strong>的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p>
<ul>
<li>G1 垃圾回收器会根据 <code>-XX:G1HeapRegionSize</code> 参数设置的堆区域大小和 <code>-XX:G1MixedGCLiveThresholdPercent</code> 参数设置的阈值，来决定哪些对象会直接进入老年代。</li>
<li>Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(<code>XX:ThresholdTolerance</code>是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。</li>
</ul>
<p>既然虚拟机采用了<strong>分代收集</strong>的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，<strong>虚拟机给每个对象一个对象年龄（Age）计数器。</strong></p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(<strong>Eden 区-&gt;Survivor 区后对象的初始年龄变为 1</strong>)。</p>
<p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 <strong>survivor 区的 50% 时</strong>（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，）取这个年龄和 MaxTenuringThreshold 中更小的一个值，<strong>作为新的晋升年龄阈值”。</strong></p>
<p><strong>默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对<strong>老年代进行垃圾收集</strong>。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h3 id="空间分配担保">空间分配担保</h3>
<p>空间分配担保是为了<strong>确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</strong></p>
<p>JDK 6 Update 24 之前，<strong>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，<strong>则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</strong></p>
<p>JDK 6 Update 24 之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>，就会进行 Minor GC，否则将进行 Full GC。</p>
<h2 id="对象死亡的判断方法">对象死亡的判断方法</h2>
<h3 id="引用计数器">引用计数器</h3>
<p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p>
<p>例子：</p>
<p>如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。<strong>但是他们因为互相引用对方，导致它们的引用计数器都不为 0</strong>，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<h3 id="可达性分析">可达性分析</h3>
<p>通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li>虚拟机<strong>栈(栈帧中的局部变量表)中引用的对象</strong></li>
<li><strong>本地方法栈(Native 方法)中引用的对象</strong></li>
<li>方法区中<strong>类静态属性</strong>引用的对象</li>
<li>方法区中<strong>常量</strong>引用的对象</li>
<li>所有<strong>被同步锁</strong>持有的对象</li>
<li>JNI（Java Native Interface）引用的对象</li>
</ul>
<p>然后要进行两次标记之后，才会真正给他回收了</p>
<p>判断一个对象的死亡至少需要两次标记</p>
<ol>
<li>如果<strong>对象进行可达性分析之后没发现与 GC Roots 相连的引用链</strong>，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。<strong>如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</strong></li>
<li>GC 对 F-Queue 队列中的对象进行二次标记。<strong>如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</strong></li>
</ol>
<h3 id="使用终结器">使用终结器</h3>
<p>但是他嗯，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。</p>
<h2 id="引用类型总结">引用类型总结</h2>
<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱），<strong>强引用就是 Java 中普通的对象</strong>，而软引用、弱引用、虚引用在 JDK 中定义的类分别是 <code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>。</p>
<h3 id="强引用">强引用</h3>
<p>就是程序代码中普遍存在的引用赋值，这是使用最普遍的引用，其代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 <strong>OutOfMemoryError</strong> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h3 id="软引用">软引用</h3>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。软引用代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>
<p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p>
<p><strong>软引用可以和一个引用队列</strong>（ReferenceQueue）联合使用，<strong>如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</strong></p>
<h3 id="弱引用">弱引用</h3>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line">str = <span class="literal">null</span>; <span class="comment">//str变成软引用，可以被收集</span></span><br></pre></td></tr></table></figure>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<strong>不过，由于垃圾回收器是</strong>一个优先级很低</strong>的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p><strong>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</strong></p>
<h3 id="虚引用">虚引用</h3>
<p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> **虚引用必须和引用队列（ReferenceQueue）联合使用。**当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，<strong>那么就可以在所引用的对象的内存被回收之前采取必要的行动。</strong></p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<p><strong>1.为什么软引用可以防止内存溢出</strong></p>
<p>减轻内存压力：</p>
<p>软引用对象在内存紧张时会被 GC 回收，这意味着,对于一些<strong>缓存型对象</strong>（如图片缓存、数据缓存）：</p>
<ul>
<li>使用软引用能让 JVM 在不影响系统运行的前提下<strong>自动清理不重要的对象</strong>；</li>
<li>避免这些对象<strong>一直占用内存</strong>导致 OOM（OutOfMemoryError）。</li>
</ul>
<p>有利于缓存系统的实现：</p>
<p>比如在图片浏览器、数据库连接池、网页浏览器中，常常需要缓存大量数据；使用软引用作为缓存的基础可以确保：</p>
<ul>
<li>缓存不会<strong>占用过多堆内存</strong>；</li>
<li>系统空闲时缓存仍可用；</li>
<li>一旦内存紧张，<strong>缓存自动释放</strong>，系统依旧安全运行。</li>
</ul>
<p>相比强引用更灵活、相比弱引用更安全</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>回收时机</th>
<th>是否适合做缓存</th>
<th>对系统安全性的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>永不回收（除非没有引用）</td>
<td>❌ 会导致 OOM</td>
<td>高风险</td>
</tr>
<tr>
<td>弱引用</td>
<td>GC 时就回收</td>
<td>⚠️ 不适合</td>
<td>稳定但易失效</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时回收</td>
<td>✅ 非常适合</td>
<td>✅ 安全可靠</td>
</tr>
</tbody>
</table>
<p>为什么弱引用/虚引用用得少？</p>
<p><strong>弱引用</strong>：一旦 GC 触发，不管内存够不够都会被回收，<strong>太激进，不适合缓存</strong>；</p>
<p><strong>虚引用</strong>：更偏底层，<strong>用于监控对象被回收的时机</strong>，不具备访问能力，<strong>需要配合 ReferenceQueue 使用</strong>，复杂度高。</p>
<h2 id="判断是不是该废弃">判断是不是该废弃</h2>
<p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>
<blockquote>
<ol>
<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
</blockquote>
<p>假如在字符串常量池中存在字符串 “abc”，<strong>如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量</strong>，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池了。</p>
<p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p>
<ul>
<li>该类所有的<strong>实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</strong></li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在<strong>任何地方被引用</strong>，<strong>无法在任何地方通过反射访问该类的方法。</strong></li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<h3 id="标记清除算法">标记清除算法</h3>
<p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：<strong>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</strong></p>
<p>它是最<strong>基础</strong>的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ol>
<p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p>
<ol>
<li>当一个对象被创建时，给一个标记位，假设为 0 (false)；</li>
<li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</li>
<li>扫描阶段清除的就是标记位为 0 (false)的对象。</li>
</ol>
<h3 id="复制算法">复制算法</h3>
<p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。**它可以将内存分为大小相同的两块，每次使用其中的一块。**当这一块的内存使用完后，**就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果<strong>存活对象数量比较大，复制性能会变得很差</strong>。</li>
</ul>
<h3 id="标记整理算法">标记整理算法</h3>
<p>标记-整理（Mark-and-Compact）算法是根据<strong>老年代</strong>的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<strong>而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</strong></p>
<p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-compact-garbage-collection-algorithm.png" alt=""></p>
<h3 id="分代收集算法">分代收集算法</h3>
<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在<strong>新生代</strong>中，每次收集都会有大量对象死去，<strong>所以可以选择“复制”算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，<strong>所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<h2 id="垃圾收集器">垃圾收集器</h2>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p>
<ul>
<li>JDK 8: <strong>Parallel Scavenge（新生代）+ Parallel Old（老年代）</strong></li>
<li>JDK 9 ~ JDK22: <strong>G1</strong></li>
</ul>
<h3 id="Serial">Serial</h3>
<p>Serial**（串行）收集器**是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，<strong>更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png" alt="Serial 收集器"></p>
<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。<strong>Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</strong></p>
<h3 id="ParNew">ParNew</h3>
<p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/parnew-garbage-collector.png" alt="ParNew 收集器 "></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，<strong>只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</strong></p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上</li>
</ul>
<h3 id="Parallerl-Scavenge">Parallerl Scavenge</h3>
<p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure>
<p>Parallel Scavenge 收集器关注点是<strong>吞吐量（高效率的利用 CPU）</strong>。CMS 等垃圾收集器的关注点更多的是<strong>用户线程的停顿时间</strong>（提高用户体验）。所谓吞吐量就是 <strong>CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值</strong>。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，<strong>使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</strong></p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png" alt=""></p>
<p><strong>这是 JDK1.8 默认收集器</strong></p>
<p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">262921408</span> -XX:MaxHeapSize=<span class="number">4206742528</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_211</span>-b12)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.211</span>-b12, mixed mode)</span></span><br></pre></td></tr></table></figure>
<p>JDK1.8 默认使用的是 <strong>Parallel Scavenge + Parallel Old</strong>，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p>
<h3 id="Serial-Old">Serial Old</h3>
<p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：<strong>一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png" alt="Serial 收集器"></p>
<h3 id="Parallel-Old">Parallel Old</h3>
<p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p>
<h3 id="CMS">CMS</h3>
<p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 短暂停顿，<strong>标记直接与 root 相连的对象（根对象）；</strong></li>
<li><strong>并发标记：</strong> <strong>同时开启 GC 和用户线程</strong>，用一个<strong>闭包结构</strong>去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。<strong>所以这个算法里会跟踪记录这些发生引用更新的地方。</strong></li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了**修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，**这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png" alt="CMS 收集器"></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<p><strong>CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。</strong></p>
<h3 id="G1">G1</h3>
<p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</strong></p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li><strong>并行与并发</strong>：<strong>G1 能充分利用 CPU、多核环境下的硬件优势</strong>，使用多个 CPU（CPU 或者 CPU 核心）来缩短 <strong>Stop-The-World 停顿时间</strong>(暂停其他的线程)。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，<strong>G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</strong></li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了<strong>分代</strong>的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</strong></li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，<strong>但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</strong>。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong>： 短暂停顿（Stop-The-World，STW），<strong>标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象</strong></li>
<li><strong>并发标记</strong>：<strong>与应用并发运行</strong>，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</li>
<li><strong>最终标记</strong>： 短暂停顿（STW），<strong>处理并发标记阶段结束后残留的少量未处理的引用变更。</strong></li>
<li><strong>筛选回收</strong>：根据标记结果，<strong>选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png" alt="G1 收集器"></p>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，<strong>保证了 G1 收集器在有限时间内可以尽可能高的收集效率</strong>（把内存化整为零）。</p>
<p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p>
<h3 id="ZGC">ZGC</h3>
<p>与 CMS 中的 ParNew 和 G1 类似，<strong>ZGC 也采用标记-复制算法</strong>，不过 ZGC 对该算法做了重大改进。</p>
<p><strong>ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。</strong></p>
<p>ZGC 在 Java11 中引入，处于试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java15 已经可以正式使用了。</p>
<p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启用 ZGC：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseZGC className</span><br></pre></td></tr></table></figure>
<p>在 Java21 中，<strong>引入了分代 ZGC，暂停时间可以缩短到 1 毫秒以内。</strong></p>
<p>你可以通过下面的参数启用分代 ZGC：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseZGC -XX:+ZGenerational className</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://static001.geekbang.org/infoq/9f/9ff72176ab0bf58bc43e142f69427379.png" alt=""></p>
<h1>JVM 的常用参数</h1>
<table>
<thead>
<tr>
<th>参数名</th>
<th>作用描述</th>
<th>示例值/说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Xms</code></td>
<td>初始堆内存大小</td>
<td><code>-Xms512m</code></td>
</tr>
<tr>
<td><code>-Xmx</code></td>
<td>最大堆内存大小</td>
<td><code>-Xmx1024m</code></td>
</tr>
<tr>
<td><code>-Xmn</code></td>
<td>新生代大小（控制 Eden + Survivor 区）</td>
<td><code>-Xmn256m</code></td>
</tr>
<tr>
<td><code>-XX:PermSize</code>（JDK 8 前）</td>
<td>初始永久代大小（方法区）</td>
<td><code>-XX:PermSize=128m</code></td>
</tr>
<tr>
<td><code>-XX:MaxPermSize</code>（JDK 8 前）</td>
<td>最大永久代大小</td>
<td><code>-XX:MaxPermSize=256m</code></td>
</tr>
<tr>
<td><code>-XX:MetaspaceSize</code>（JDK 8+）</td>
<td>元空间初始大小</td>
<td><code>-XX:MetaspaceSize=128m</code></td>
</tr>
<tr>
<td><code>-XX:MaxMetaspaceSize</code>（JDK 8+）</td>
<td>元空间最大大小</td>
<td><code>-XX:MaxMetaspaceSize=512m</code></td>
</tr>
<tr>
<td><code>-XX:+PrintGCDetails</code></td>
<td>输出 GC 详细信息</td>
<td>调试用</td>
</tr>
<tr>
<td><code>-XX:+UseSerialGC</code></td>
<td>使用串行垃圾收集器</td>
<td>适合单核或小内存环境</td>
</tr>
<tr>
<td><code>-XX:+UseParallelGC</code></td>
<td>使用并行收集器（吞吐量优先）</td>
<td>默认在 JDK 8</td>
</tr>
<tr>
<td><code>-XX:+UseG1GC</code></td>
<td>使用 G1 收集器（低延迟场景）</td>
<td>推荐在大内存、服务端场景中使用</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>Eden 与 Survivor 区大小比</td>
<td><code>-XX:SurvivorRatio=8</code></td>
</tr>
<tr>
<td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td>
<td>OOM 时导出内存快照</td>
<td>用于定位内存泄漏</td>
</tr>
<tr>
<td><code>-XX:HeapDumpPath</code></td>
<td>指定 heap dump 文件路径</td>
<td><code>-XX:HeapDumpPath=/tmp/dump.hprof</code></td>
</tr>
<tr>
<td><code>-Xss</code></td>
<td>设置每个线程的栈大小</td>
<td><code>-Xss256k</code></td>
</tr>
<tr>
<td><code>-XX:+PrintGCDateStamps</code></td>
<td>打印 GC 日志时附带时间戳</td>
<td>调试用</td>
</tr>
<tr>
<td><code>-XX:+UseCompressedOops</code></td>
<td>压缩对象指针（节省 64 位 JVM 内存）</td>
<td>默认开启</td>
</tr>
<tr>
<td><code>-Dkey=value</code></td>
<td>设置系统属性（常用于配置）</td>
<td>示例：<code>-Denv=prod</code></td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/')">JVM-java虚拟机</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JVM-java虚拟机&amp;url=https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=c7fb141a-72a5-5574-d622-d0dee0d44b7b" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>技术栈<span class="categoryesPageCount">23</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">57</span></a><a class="post-meta__box__tags" href="/tags/jvm/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>jvm<span class="tagsPageCount">2</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=4ef10f2e-41c4-8a83-25b9-23bbd54e0552" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/25/lastteam/networktest/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=c5034b3d-bd01-c456-cf7e-3d0f2d0e0e62" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络期末考试复习</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/25/java-stack/jvm2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=41e7d7e8-f339-5496-34ba-72657a4354b5" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM-java虚拟机hot面试</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/05/25/java-stack/jvm2/" title="JVM-java虚拟机hot面试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=41e7d7e8-f339-5496-34ba-72657a4354b5" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-25</div><div class="title">JVM-java虚拟机hot面试</div></div></a></div><div><a href="/2024/12/08/java-stack/bigdata/" title="大数据期末复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837447.jpg?_r_=0410ee86-8c98-f910-1359-94075b6f876b" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-12-08</div><div class="title">大数据期末复习</div></div></a></div><div><a href="/2025/05/27/java-stack/javasample1/" title="JAVA设计模式面试题目hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837602.jpg?_r_=c2ef60fa-c891-26be-9ad1-4dfe9d9aa62c" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-27</div><div class="title">JAVA设计模式面试题目hot</div></div></a></div><div><a href="/2025/05/09/java-stack/juc1/" title="JUC-线程池"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=2a63bbe9-4c3b-aa70-064a-c9e18beefe20" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-09</div><div class="title">JUC-线程池</div></div></a></div><div><a href="/2024/06/25/java-stack/spring%20boot/" title="Spring boot(1)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722380.jpg?_r_=ed181315-5ec4-c496-6feb-f6ab7f7e0869" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-25</div><div class="title">Spring boot(1)</div></div></a></div><div><a href="/2025/05/22/java-stack/juc2/" title="JUC-线程池面试题hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712181.jpg?_r_=23831538-4773-64d1-f0ed-95b492759205" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-22</div><div class="title">JUC-线程池面试题hot</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">加载顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">本地方法栈和程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">3.2.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86"><span class="toc-number">3.3.</span> <span class="toc-text">虚拟机栈和虚拟机堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.3.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">堆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">垃圾回收算法（GC）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">堆空间的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-number">4.1.1.</span> <span class="toc-text">新生代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">4.1.2.</span> <span class="toc-text">老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">4.1.3.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">对象死亡的判断方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">引用计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">可达性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E5%99%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">使用终结器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">引用类型总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E8%AF%A5%E5%BA%9F%E5%BC%83"><span class="toc-number">4.4.</span> <span class="toc-text">判断是不是该废弃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.3.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial"><span class="toc-number">4.6.1.</span> <span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew"><span class="toc-number">4.6.2.</span> <span class="toc-text">ParNew</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallerl-Scavenge"><span class="toc-number">4.6.3.</span> <span class="toc-text">Parallerl Scavenge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old"><span class="toc-number">4.6.4.</span> <span class="toc-text">Serial Old</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old"><span class="toc-number">4.6.5.</span> <span class="toc-text">Parallel Old</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS"><span class="toc-number">4.6.6.</span> <span class="toc-text">CMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1"><span class="toc-number">4.6.7.</span> <span class="toc-text">G1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZGC"><span class="toc-number">4.6.8.</span> <span class="toc-text">ZGC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">JVM 的常用参数</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/12/javase/javase4/" title="javase面试-深入源码"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=4ef10f2e-41c4-8a83-25b9-23bbd54e0552" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javase面试-深入源码"/></a><div class="content"><a class="title" href="/2025/08/12/javase/javase4/" title="javase面试-深入源码">javase面试-深入源码</a><time datetime="2025-08-11T16:00:00.000Z" title="发表于 2025-08-12 00:00:00">2025-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/10/workmenu/forum1/" title="微服务论坛设计方案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=c145f523-c70f-48c0-c2d0-6316b05340de" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务论坛设计方案"/></a><div class="content"><a class="title" href="/2025/08/10/workmenu/forum1/" title="微服务论坛设计方案">微服务论坛设计方案</a><time datetime="2025-08-09T16:00:00.000Z" title="发表于 2025-08-10 00:00:00">2025-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/10/workmenu/fourm2/" title="微服务论坛问题收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=99de7ccf-57bf-7694-9360-4a4c879df700" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务论坛问题收集"/></a><div class="content"><a class="title" href="/2025/08/10/workmenu/fourm2/" title="微服务论坛问题收集">微服务论坛问题收集</a><time datetime="2025-08-09T16:00:00.000Z" title="发表于 2025-08-10 00:00:00">2025-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/new-stack/springcloud1/" title="SpringCloud-组件介绍"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837602.jpg?_r_=de2a8de1-b8b7-4748-1b68-7ed9d20f8e8d" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud-组件介绍"/></a><div class="content"><a class="title" href="/2025/08/09/new-stack/springcloud1/" title="SpringCloud-组件介绍">SpringCloud-组件介绍</a><time datetime="2025-08-08T16:00:00.000Z" title="发表于 2025-08-09 00:00:00">2025-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/29/towork/woking3/" title="面试模拟-202508"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510550.jpg?_r_=b7f7d40d-4260-2ed2-d5d2-36ff18acc534" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试模拟-202508"/></a><div class="content"><a class="title" href="/2025/07/29/towork/woking3/" title="面试模拟-202508">面试模拟-202508</a><time datetime="2025-07-28T16:00:00.000Z" title="发表于 2025-07-29 00:00:00">2025-07-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">162</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">25</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 0.88rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/Cache/" style="font-size: 0.88rem;">Cache<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 0.88rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/Github/" style="font-size: 0.88rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>2</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/SpringAI/" style="font-size: 0.88rem;">SpringAI<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>57</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>10</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>7</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>4</sup></a><a href="/tags/rocketmq/" style="font-size: 0.88rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>3</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>24</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>