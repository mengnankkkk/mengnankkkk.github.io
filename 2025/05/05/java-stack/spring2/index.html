<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Spring面试题hot1 | mengnankkのblog</title><meta name="keywords" content="java,面试,spring"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Spring面试题hot1"><meta name="application-name" content="Spring面试题hot1"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="Spring面试题hot1"><meta property="og:url" content="https://blog.tokenlen.top/2025/05/05/java-stack/spring2/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="事务 1.spring 事务失效的场景有哪些？ spring事务的实现原理是基于AOP的动态代理和TransacationInterceptorh还有底层依赖 AOP：Spring 通过 ProxyFactoryBean 生成代理对象，默认对接口用 JDK 动态代理，对类用 CGLIB 代理；是采用"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=3d6fda97-304a-d3c6-a1c8-f2d58a0c71bd"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=3d6fda97-304a-d3c6-a1c8-f2d58a0c71bd"><meta name="description" content="事务 1.spring 事务失效的场景有哪些？ spring事务的实现原理是基于AOP的动态代理和TransacationInterceptorh还有底层依赖 AOP：Spring 通过 ProxyFactoryBean 生成代理对象，默认对接口用 JDK 动态代理，对类用 CGLIB 代理；是采用"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/05/05/java-stack/spring2/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: 'Spring面试题hot1',
  postAI: '',
  pageFillDescription: '事务, 1.spring 事务失效的场景有哪些？, 2.Spring的事务使用this调用是否生效？, 3.谈一下spring事务, spring, 1.说一下你对 Spring 的理解, 2.spring的核心思想说说你的理解？, 3.Spring IoC和AOP 介绍一下, 4.Spring的aop介绍一下, 5.IOC和AOP是通过什么机制来实现的?, 6.怎么理解SpringIoc？, 7.依赖倒置依赖注入控制反转分别是什么？, 8.依赖注入了解吗？怎么实现依赖注入的？, 9.如果让你设计一个SpringIoc你觉得会从哪些方面考虑这个设计？, 10.SpringAOP主要想解决什么问题, 11.SpringAOP的原理了解吗, 12.动态代理是什么？, 13.动态代理和静态代理的区别, 14.AOP实现有哪些注解？, 15.什么是反射？有哪些使用场景？, 16.spring是如何解决循环依赖的？, 17.spring三级缓存的数据结构是什么？, 18.spring框架中都用到了哪些设计模式, 19.spring 常用注解有什么？, 20.@componet和@bean, 21.讲一下 Spring 中用到的设计模式？, 22.springsecurity是什么, 23.spring 框架里的事务传播机制有哪些？比如 Propagation.REQUIRED 和 REQUIRES_NEW 的区别是啥呀？, 24.AOP 的实现原理, Bean, 1.Bean的生命周期说一下？, 2.Bean是否单例？, 3.Bean的单例和非单例生命周期是否一样, 4.Spring bean的作用域有哪些？, 5.Spring容器里存的是什么？, 6.在Spring中在bean加载/销毁前后如果想实现某些逻辑可以怎么做, 7.Bean注入和xml注入最终得到了相同的效果它们在底层是怎样做的, 8.Spring给我们提供了很多扩展点这些有了解吗？, 9.Spring 框架中Bean 的作用域有哪些？请分别说明它们的生命周期和应用场景, 10.BeanFactory 和 FactoryBean 的区别, MVC, 1.MVC分层介绍一下, 2.了解SpringMVC的处理流程吗？, 3.Handlermapping 和 handleradapter有了解吗？, Springboot, 1.为什么使用springboot, 2.SpringBoot比Spring好在哪里, 3.SpringBoot用到哪些设计模式？, 4.怎么理解SpringBoot中的约定大于配置, 5.SpringBoot的项目结构是怎么样的？, 6.SpringBoot自动装配原理是什么？, 7.说几个启动器（starter)？, 8.写过SpringBoot starter吗?, 9.SpringBoot里面有哪些重要的注解？还有一个配置相关的注解是哪个？, 10.springboot怎么开启事务？, 11.Springboot怎么做到导入就可以直接使用的？, 12.SpringBoot 过滤器和拦截器说一下？, 13.说说Spring Boot的启动流程。, 14.@Autowied和@Resource, Mybatis, 1.与传统的JDBC相比MyBatis的优点？, 2.MyBatis觉得在哪方面做的比较好？, 3.还记得JDBC连接数据库的步骤吗？, 4.如果项目中要用到原生的mybatis去查询该怎样写？, 5.Mybatis里的  和 $ 的区别？, 6.MybatisPlus和Mybatis的区别？, 7.MyBatis运用了哪些常见的设计模式？, 8.MyBatis 的两级缓存及其特点是什么？, 9.MyBatis Plus 的 Wrapper 和原生 XML 写 SQL 的区别？什么时候该用 Wrapper？, 10.分页查询的方式, 11.MyBatis Mapper 注册过程, 12.xml标签有啥事务事务失效的场景有哪些事务的实现原理是基于的动态代理和还有底层依赖通过生成代理对象默认对接口用动态代理对类用代理是采用继承目标类的方式去创建代理类非的方法不能能继承拦截器核心拦截器在方法调用前后开启提交回滚事务基于存储事务状态基于运行时异常来回滚的所以把运行时异常给或者返回没指定的异常底层依赖通过接口适配不同事务管理器如使用存储事务的状态如连接隔离级别通过存在线程本地变量保证线程安全所以基于这个情况事务失效的场景有吃掉运行时异常没抛出未配置回滚规则要配置指定类型调用非方法事务的传播属性设置为这种不支持事务的调用了不支持事务的数据库事务嵌套会挂起外部事务提前提交嵌套事务用会创建支持回滚子事务但数据库需支持外部事务外部异常不会影响提交的事务已提交属性详解传播行为如当前有事务则加入无则新建隔离级别如避免脏读事务超时时间如秒指定回滚的异常类型指定不回滚的异常类型的事务使用调用是否生效不能生效因为事务是通过代理对象来控制的只有通过代理对象的方法调用才会应用事务管理的相关规则当使用直接调用时是绕过了的代理机制因此不会应用事务设置谈一下事务提供了统一的事务管理抽象既支持编程式事务也支持声明式事务核心目的是控制数据的一致性与完整性多个数据库操作要么都成功要么都失败回滚放在类上表示该类的所有方法默认使用事务放在方法上表示该方法启用事务常用属性用来指明信息和事务的隔离级别和一样传播行为含义默认值当前存在事务就加入否则新建事务每次都新建事务挂起当前事务如果存在事务就嵌套执行一个子事务有事务就加入无事务就非事务执行始终非事务执行挂起现有事务非事务执行存在事务则抛异常必须在事务中运行否则抛异常支持编程式事务管理和声明式事务管理两种方式编程式事务管理使用声明式事务管理建立在之上的其本质是通过功能对方法前后进行拦截将事务处理的功能编织到拦截的方法中也就是在目标方法开始之前启动一个事务在执行完目标方法之后根据执行情况提交或者回滚事务声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码只需在配置文件中做相关的事务规则声明或通过注解的方式便可以将事务规则应用到业务逻辑中减少业务代码的污染唯一不足地方是最细粒度只能作用到方法级别无法做到像编程式事务那样可以作用到代码块级别说一下你对的理解框架核心特性包括容器通过控制反转实现了对象的创建和对象间的依赖关系管理开发者只需要定义好及其依赖关系容器负责创建和组装这些对象面向切面编程允许开发者定义横切关注点例如事务管理安全控制等独立于业务逻辑的代码通过可以将这些关注点模块化提高代码的可维护性和可重用性事务管理提供了一致的事务管理接口支持声明式和编程式事务开发者可以轻松地进行事务管理而无需关心具体的事务框架是一个基于构建的框架采用了模型视图控制器架构它支持灵活的到页面控制器的映射以及多种视图技术的核心思想说说你的理解核心思想解决的问题实现手段典型应用场景对象创建与依赖管理的高耦合容器管理生命周期动态替换数据库实现服务组装依赖关系的硬编码问题构造器注解注入注入数据源服务层依赖层横切逻辑分散在业务代码中动态代理与切面配置日志事务权限校验统一处理通过这三大核心思想实现了轻量级高内聚低耦合的企业级应用开发框架成为生态中不可或缺的基石和介绍一下即控制反转的意思它是一种创建和获取对象的技术思想依赖注入是实现这种技术的一种方式传统开发过程中我们需要通过关键字来创建对象使用思想开发方式的话我们不通过关键字创建对象而是通过容器来帮我们实例化对象通过的方式可以大大降低对象之间的耦合度是面向切面编程能够将那些与业务无关却为业务模块所共同调用的逻辑封装起来以减少系统的重复代码降低模块间的耦合度就是基于动态代理的如果要代理的对象实现了某个接口那么会使用去创建代理对象而对于没有实现接口的对象就无法使用去进行代理了这时候会使用生成一个被代理对象的子类来作为代理在框架中和结合使用可以更好地实现代码的模块化和分层管理例如通过容器管理对象的依赖关系然后通过将横切关注点统一切入到需要的业务逻辑中使用容器管理层和层的依赖关系然后通过在层实现事务管理日志记录等横切功能使得业务逻辑更加清晰和可维护的介绍一下是框架中的一个重要模块用于实现面向切面编程我们知道就是一门面向对象编程的语言在中最小的单元就是对象但是在中最小的单元是切面一个切面可以包含很多种类型和对象对它们进行模块化管理例如事务管理在面向切面编程的思想里面把功能分为两种核心业务登陆注册增删改查都叫核心业务周边功能日志事务管理这些次要的为周边业务在面向切面编程中核心业务功能和周边功能是分别独立进行开发两者不是耦合的然后把切面功能和核心业务功能编织在一起这就叫能够将那些与业务无关却为业务模块所共同调用的逻辑或责任例如事务处理日志管理权限控制等封装起来便于减少系统的重复代码降低模块间的耦合度并有利于未来的可拓展性和可维护性在中有以下几个概念切面只是一个概念没有具体的接口或类与之对应是和的一个统称连接点指程序执行过程中的一个点例如方法调用异常处理等在中仅支持方法级别的连接点通知即我们定义的一个切面中的横切逻辑有和三种类型在很多的实现框架中通常作为一个拦截器也可以包含许多个拦截器作为一条链路围绕着进行处理切点用于匹配连接点一个中包含哪些需要由进行筛选引介让一个切面可以声明被通知的对象实现任何他们没有真正实现的额外的接口例如可以让一个代理对象代理两个目标类织入在有了连接点切点通知以及切面如何将它们应用到程序中呢没错就是织入在切点的引导下将通知逻辑插入到目标方法上使得我们的通知逻辑在方法调用时得以执行代理指在实现框架中实现切面协议的对象在中有两种代理分别是动态代理和动态代理目标对象就是被代理的对象是基于动态代理和提升实现的两种代理方式都属于运行时的一个方式所以它没有编译时的一个处理那么因此是通过代码实现的和是通过什么机制来实现的实现机制反射容器利用的反射机制动态地加载类创建对象实例及调用对象方法反射允许在运行时检查类方法属性等信息从而实现灵活的对象实例化和管理依赖注入的核心概念是依赖注入即容器负责管理应用程序组件之间的依赖关系通过构造函数注入属性注入或方法注入将组件之间的依赖关系描述在配置文件中或使用注解设计模式工厂模式容器通常采用工厂模式来管理对象的创建和生命周期容器作为工厂负责实例化并管理它们的生命周期将的实例化过程交给容器来管理容器实现容器是实现的核心通常使用或来管理是容器的基本形式提供基本的功能是的扩展并提供更多企业级功能实现机制的实现依赖于动态代理技术动态代理是在运行时动态生成代理对象而不是在编译时它允许开发者在运行时指定要代理的接口和行为从而实现在不修改源码的情况下增强方法的功能支持两种动态代理基于的动态代理使用类和接口实现这种方式需要代理的类实现一个或多个接口基于的动态代理当被代理的类没有实现接口时会使用库生成一个被代理类的子类作为代理是一个第三方代码生成库通过继承方式实现代理怎么理解即控制反转是一种设计思想在传统的程序设计中我们直接在对象内部通过的方式来创建对象是程序主动创建依赖对象而在程序设计中是有专门的容器去控制对象所谓控制就是对象的创建初始化销毁创建对象原来是一个现在是由容器创建初始化对象原来是对象自己通过构造器或者方法给依赖的对象赋值现在是由容器自动注入销毁对象原来是直接给对象赋值或做一些销毁操作现在是容器管理生命周期负责销毁对象总结解决了繁琐的对象生命周期的操作解耦了我们的代码所谓反转其实是反转的控制权前面提到是由来控制对象的生命周期那么对象的控制就完全脱离了我们的控制控制权交给了这个反转是指我们由对象的控制者变成了的被动控制者依赖倒置依赖注入控制反转分别是什么控制反转控制指的是对程序执行流程的控制而反转指的是在没有使用框架之前程序员自己控制整个程序的执行在使用框架之后整个程序的执行流程通过框架来控制流程的控制权从程序员反转给了框架依赖注入依赖注入和控制反转恰恰相反它是一种具体的编码技巧我们不通过的方式在类内部创建依赖类的对象而是将依赖的类对象在外部创建好之后通过构造函数函数参数等方式传递或注入给类来使用依赖倒置这条原则跟控制反转有点类似主要用来指导框架层面的设计高层模块不依赖低层模块它们共同依赖同一个抽象抽象不要依赖具体实现细节具体实现细节依赖抽象依赖注入了解吗怎么实现依赖注入的在传统编程中当一个类需要使用另一个类的对象时通常会在该类内部通过关键字来创建依赖对象这使得类与类之间的耦合度较高而依赖注入则是将对象的创建和依赖关系的管理交给容器来完成类只需要声明自己所依赖的对象容器会在运行时将这些依赖对象注入到类中从而降低了类与类之间的耦合度提高了代码的可维护性和可测试性具体到中常见的依赖注入的实现方式比如构造器注入方法注入还有字段注入构造器注入通过构造函数传递依赖对象保证对象初始化时依赖已就绪构造器注入自动识别单构造器无需显式方法注入通过方法设置依赖灵活性高但依赖可能未完全初始化字段注入直接通过注解字段代码简洁但隐藏依赖关系不推荐生产代码如果让你设计一个你觉得会从哪些方面考虑这个设计的生命周期管理需要设计的创建初始化销毁等生命周期管理机制可以考虑使用工厂模式和单例模式来实现依赖注入需要实现依赖注入的功能包括属性注入构造函数注入方法注入等可以考虑使用反射机制和配置文件来实现的作用域需要支持多种作用域比如单例原型会话请求等可以考虑使用来存储不同作用域的实例功能的支持需要支持功能可以考虑使用动态代理机制和切面编程来实现异常处理需要考虑异常处理机制包括创建异常依赖注入异常等可以考虑使用机制来处理异常配置文件加载需要支持从不同的配置文件中加载的相关信息可以考虑使用注解或者配置类来实现主要想解决什么问题它的目的是对于面向对象思维的一种补充而不是像引入命令式函数式编程思维让他顺应另一种开发场景在我个人的理解下更像是一种对于不支持多继承的弥补除开对象的主要特征我更喜欢叫强共性被抽象为了一条继承链路对于一些弱共性可以统一对他们进行抽象和集中处理举一个简单的例子打印日志需要打印日志可能是许多对象的一个共性这在企业级开发中十分常见但是日志的打印并不反应这个对象的主要共性而日志的打印又是一个具体的内容它并不抽象所以它的工作也不可以用接口来完成而如果利用继承打印日志的工作又横跨继承树下面的多个同级子节点强行侵入到继承树内进行归纳会干扰这些强共性的区分这时候我们就需要了首先在一个切面里定义了一些增强其中包含具体实现的代码同时整理了切入点切入点的粒度是方法最后我们将这些织入到对象的方法上形成了最后执行方法时面对的完整方法的原理了解吗的实现依赖于动态代理技术动态代理是在运行时动态生成代理对象而不是在编译时它允许开发者在运行时指定要代理的接口和行为从而实现在不修改源码的情况下增强方法的功能支持两种动态代理基于的动态代理使用类和接口实现这种方式需要代理的类实现一个或多个接口基于的动态代理当被代理的类没有实现接口时会使用库生成一个被代理类的子类作为代理是一个第三方代码生成库通过继承方式实现代理动态代理是什么的动态代理是一种在运行时动态创建代理对象的机制主要用于在不修改原始类的情况下对方法调用进行拦截和增强动态代理主要分为两种类型基于接口的代理动态代理这种类型的代理要求目标对象必须实现至少一个接口动态代理会创建一个实现了相同接口的代理类然后在运行时动态生成该类的实例这种代理的实现核心是类和接口每一个动态代理类都必须实现接口并且每个代理类的实例都关联到一个当通过代理对象调用一个方法时这个方法的调用会被转发为由接口的方法来进行调用基于类的代理动态代理是一个强大的高性能的代码生成库它可以在运行时动态生成一个目标类的子类代理不需要目标类实现接口而是通过继承的方式创建代理类因此如果目标对象没有实现任何接口可以使用来创建动态代理动态代理和静态代理的区别代理是一种常用的设计模式目的是为其他对象提供一个代理以控制对某个对象的访问将两个类的关系解耦代理类和委托类都要实现相同的接口因为代理真正调用的是委托类的方法区别静态代理由程序员创建或者是由特定工具创建在代码编译时就确定了被代理的类是一个静态代理静态代理通常只代理一个类动态代理在代码运行期间运用反射机制动态创建生成动态代理代理的是一个接口下的多个实现类实现有哪些注解常用的注解包括用于定义切面标注在切面类上定义切点标注在方法上用于指定连接点在方法执行之前执行通知在方法执行之后执行通知在方法执行前后都执行通知在方法执行后返回结果后执行通知在方法抛出异常后执行通知通用的通知类型可以替代等什么是反射有哪些使用场景射机制是指程序在运行状态下对于任意一个类都能够获取这个类的所有属性和方法对于任意一个对象都能够调用它的任意属性和方法也就是说反射允许在运行时获取类的信息并动态操作对象即使在编译时不知道具体的类也能实现反射具有以下特性运行时类信息访问反射机制允许程序在运行时获取类的完整结构信息包括类名包名父类实现的接口构造函数方法和字段等动态对象创建可以使用反射动态地创建对象实例即使在编译时不知道具体的类名这是通过类的方法或对象的方法实现的动态方法调用可以在运行时动态地调用对象的方法包括私有方法这通过类的方法实现允许你传入对象实例和参数值来执行方法访问和修改字段值反射还允许程序在运行时访问和修改对象的字段值即使是私有的这是通过类的和方法完成的反射机制在框架中很多地方都用到了反射让我们来看看的和是如何使用反射技术的框架的依赖注入和控制反转使用反射来实现其核心特性依赖注入在中开发者可以通过配置文件或者基于注解的方式声明组件之间的依赖关系当应用程序启动时容器会扫描这些配置或注解然后利用反射来实例化即对象并根据配置自动装配它们的依赖例如当一个类需要依赖另一个类时开发者可以在类中使用注解而无需自己编写创建实例的代码容器会在运行时解析这个注解通过反射找到对应的类实例化它并将其注入到类中这样不仅降低了组件之间的耦合度也极大地增强了代码的可维护性和可测试性动态代理的实现在需要对现有类的方法调用进行拦截记录日志权限控制或是事务管理等场景中反射结合动态代理技术被广泛应用一个典型的例子是面向切面编程的实现允许开发者定义切面这些切面可以横切关注点如日志记录事务管理并将其插入到业务逻辑中而不需要修改业务逻辑代码例如为了给所有的服务层方法添加日志记录功能可以定义一个切面在这个切面中会使用动态代理或如果目标类没有实现接口来创建目标类的代理对象这个代理对象在调用任何方法前或后都会执行切面中定义的代码逻辑如记录日志而这一切都是在运行时通过反射来动态构建和执行的无需硬编码到每个方法调用中这两个例子展示了反射机制如何在实际工程中促进松耦合高内聚的设计以及如何提供动态灵活的编程能力特别是在框架层面和解决跨切面问题时是如何解决循环依赖的循环依赖指的是两个类中的属性相互依赖对方例如类中有属性类中有属性从而形成了一个依赖闭环如下图循环依赖问题在中主要有三种情况第一种通过构造方法进行依赖注入时产生的循环依赖问题第二种通过方法进行依赖注入且是在多例原型模式下产生的循环依赖问题第三种通过方法进行依赖注入且是在单例模式下产生的循环依赖问题只有第三种方式的循环依赖问题被解决了其他两种方式在遇到循环依赖问题时都会产生异常解决单例模式下的循环依赖问题的主要方式是通过三级缓存解决循环依赖三级缓存指的是在创建的过程中通过三级缓存来缓存正在创建的以及已经创建完成的实例具体步骤如下实例化在实例化时会先创建一个空的对象并将其放入一级缓存中属性赋值开始对进行属性赋值如果发现循环依赖会将当前对象提前暴露给后续需要依赖的通过提前暴露的方式解决循环依赖初始化完成属性赋值后将进行初始化并将其放入二级缓存中注入依赖继续对进行依赖注入如果发现循环依赖会从二级缓存中获取已经完成初始化的实例通过三级缓存的机制能够在处理循环依赖时确保及时暴露正在创建的对象并能够正确地注入已经初始化的实例从而解决循环依赖问题保证应用程序的正常运行三级缓存的数据结构是什么都是类型的缓存比如一级缓存这是一个类型的缓存存储的是已经完全初始化好的即完全准备好可以使用的实例键是的名称值是的实例这个缓存在类中的属性中二级缓存这同样是一个类型的缓存存储的是早期的引用即已经实例化但还未完全初始化的这些已经被实例化但是可能还没有进行属性注入等操作这个缓存在类中的属性中三级缓存这也是一个类型的缓存存储的是对象这些对象可以生成早期的引用当一个正在创建过程中如果它被其他依赖那么这个正在创建的就会通过这个来创建一个早期引用从而解决循环依赖的问题这个缓存在类中的属性中核心机制是提前暴露的早期引用允许在依赖注入阶段使用未完全初始化的仅支持单例作用域和字段注入的循环依赖构造函数注入和原型作用域无法自动解决优先选择使用注入或注解解决循环依赖最佳实践通过重构代码如提取公共使用事件机制从根本上消除循环依赖禁用循环依赖在明确不需要循环依赖时禁用的循环依赖支持以提高代码健壮性创建依赖注入发现依赖被提早暴露给从三级缓存创建放入二级缓存创建完成再回来注入框架中都用到了哪些设计模式工厂设计模式使用工厂模式通过创建对象代理设计模式功能的实现单例设计模式中的默认都是单例的模板方法模式中等以结尾的对数据库操作的类它们就使用到了模板模式包装器设计模式我们的项目需要连接多个数据库而且不同的客户在每次访问中根据需要会去访问不同的数据库这种模式让我们可以根据客户的需求能够动态切换不同的数据源观察者模式事件驱动模型就是观察者模式很经典的一个应用适配器模式的增强或通知使用到了适配器模式中也是用到了适配器模式适配常用注解有什么注解主要用于自动装配当容器中存在与要注入的属性类型匹配的时它会自动将注入到属性中就跟我们对象一样用法很简单如下示例代码在上面的示例代码中类中的属性被注解标记会自动将类型的注入到属性中这个注解用于标记一个类作为的当一个类被注解标记时会将其实例化为一个并将其添加到容器中在上面讲解的时候也看到了示例代码在上面的示例代码中类被注解标记会将其实例化为一个并将其添加到容器中注解用于标记一个类作为的配置类配置类可以包含注解的方法用于定义和配置作为全局配置示例代码注解用于标记一个方法作为的工厂方法当一个方法被注解标记时会将该方法的返回值作为一个并将其添加到容器中如果自定义配置经常用到这个注解这个注解用于标记一个类作为服务层的组件它是注解的特例用于标记服务层的一般标记在业务的实现类注解用于标记一个类作为数据访问层的组件它也是注解的特例用于标记数据访问层的这个注解很容易被忽略导致数据库无法访问在上面的示例代码中类被注解标记会将其实例化为一个并将其添加到容器中注解用于标记一个类作为控制层的组件它也是注解的特例用于标记控制层的这是结构的另一个部分加在控制层在上面的示例代码中类被注解标记会将其实例化为一个并将其添加到容器中和注解作用于类而注解作用于方法注解通过类路径扫描来自动侦测以及自动装配到容器中而注解通常是我们在标有该注解的方法中定义产生这个告诉了这是某个类的实例当我需要用它的时候创建这个实例注解比注解的自定义性更强当需要引用第三方库中的类装配到容器时只能通过来实现讲一下中用到的设计模式工厂设计模式用于管理对象包括创建初始化销毁等单例设计模式默认的作用域动态代理模式使用了动态代理模式观察者模式事件监听的作用适配器模式将不兼容的接口转换为客户端期望的接口如中适配不同的模板方法模式提供一些模板类如实现连接不同的数据库将具体实现步骤放到子类是什么是生态里的安全框架主要用于应用的权限管理和认证支持多种登录方式并集成防护机制保障企业级系统的安全性可防范等攻击我们可以调整里面可以放行的页面是什么比如登录页面注册页面等等还有一些前端页面通过来放行页面测试的时候可以关闭这个保护框架里的事务传播机制有哪些比如和的区别是啥呀默认如果当前有事务就加入这个事务如果没有就新建一个事务例子方法调方法有事务也用那共用一个事务要么都成功要么都回滚不管当前有没有事务都新建一个事务原来的事务会被挂起等新事务完成后再继续例子方法调方法有事务用那自己开一个新事务如果失败的事务可能不受影响看有没有捕获异常传播行为类型含义总结是否开启新事务当前无事务时行为适用场景简述默认行为有事务用当前无则新建否新建事务绝大多数业务场景默认选项始终新建事务挂起外部事务是新建事务独立操作如日志记录通知发送等嵌套事务外部事务失败可回滚内层依赖保存点否嵌套新建事务数据段落逻辑回滚不影响整体事务有事务则加入无事务则以非事务方式运行否非事务运行兼容性要求不高的查询操作不支持事务挂起外部事务否非事务运行读写分离不需要事务控制的场景必须运行在事务中没事务则抛异常否抛异常强依赖事务环境的组件方法必须在非事务环境中运行有事务则抛异常否正常运行断言无事务的调用场景如外部调用的实现原理概念适用场景作用点切面封装横切逻辑的类用注解标识切点定义横切逻辑作用的目标方法如通知横切逻辑的具体实现包括种类型连接点程序执行中的具体点如方法调用字段修改中主要指方法调用动态代理动态代理基于接口实现生成的代理对象适用于目标类有接口的情况代理基于子类继承生成目标类的子类代理对象适用于无接口的类需引入依赖默认策略有接口用代理无接口用代理可通过属性强制使用流程容器扫描到注解的切面类解析切点表达式和通知类型对目标类判断是否适用代理生成代理对象当调用代理对象的方法时实际执行的是通知逻辑目标方法的组合逻辑细节开启支持在配置类中添加注解或在中配置代理模式选择默认优先代理若需强制代理设置或循环依赖与若目标类被代理注入的是代理对象需注意方法调用不会触发因指向原始对象场景日志记录在方法执行前后记录入参结果避免业务代码污染事务管理本质是实现在方法调用时开启提交回滚事务权限校验在接口调用前校验用户权限拒绝非法请求性能监控统计方法执行耗时用于性能优化流程调用代理方法客户端调用代理对象的方法如匹配切点判断该方法是否匹配切面的切点表达式执行通知逻辑中先执行前置逻辑如日志记录开始调用触发目标方法执行执行后置逻辑如日志记录结束统计耗时返回结果通知逻辑执行完毕后将结果返回给客户端实例定义切面类定义切点匹配所有方法环绕通知实现耗时统计调用目标方法记录日志方法执行耗时的生命周期说一下启动查找并加载需要被管理的进行的实例化实例化后对将的引入和值注入到的属性中如果实现了接口的话将的传递给方法如果实现了接口的话将调用方法将容器实例传入如果实现了接口的话将调用的方法将所在应用上下文引用传入进来如果实现了接口就将调用他们的方法如果实现了接口将调用他们的方法类似的如果使用声明了初始化方法该方法也会被调用如果实现了接口就将调用他们的方法此时已经准备就绪可以被应用程序使用了他们将一直驻留在应用上下文中直到应用上下文被销毁如果实现了接口将调用它的接口方法同样如果使用了声明销毁方法该方法也会被调用创建初始化调用销毁的创建方式有四种构造器静态工厂实例工厂注入的方式在调用的时候因为作用域的不同不同的初始化和创建的时间也不相同在作用域为的时候是随着容器一起被创建好并且实例化的在作用域为的时候是随着它被调用的时候才创建和实例化完成然后程序就可以使用了当程序完成销毁的时候也被销毁是否单例中的默认都是单例的就是说每个的实例只会被创建一次并且会被存储在容器的缓存中以便在后续的请求中重复使用这种单例模式可以提高应用程序的性能和内存效率但是也支持将设置为多例模式即每次请求都会创建一个新的实例要将设置为多例模式可以在定义中通过设置属性为来实现需要注意的是虽然的默认行为是将设置为单例模式但在一些情况下使用多例模式是更为合适的例如在创建状态不可变的或有状态时此外需要注意的是如果单例是有状态的那么在使用时需要考虑线程安全性问题的单例和非单例生命周期是否一样不一样的的生命周期完全由容器控制只帮我们管理单例模式的完整生命周期对于的在创建好交给使用者之后则不会再管理后续的生命周期具体区别如下阶段单例非单例如创建时机容器启动时创建或首次请求时取决于配置每次请求时创建新实例初始化流程完整执行生命周期流程属性注入接口初始化方法等每次创建新实例时都会完整执行生命周期流程仅到初始化完成销毁时机容器关闭时销毁触发或容器不管理销毁需由调用者自行释放资源不跟踪实例内存占用单实例常驻内存高效但需注意线程安全每次请求生成新实例内存开销较大需手动管理资源释放适用场景无状态服务如层有状态对象如用户会话临时计算对象的作用域有哪些框架中的作用域定义了的生命周期和可见性不同的作用域影响着容器如何管理这些的实例包括它们如何被创建如何被销毁以及它们是否可以被多个用户共享支持几种不同的作用域以满足不同的应用场景需求以下是一些主要的作用域单例在整个应用程序中只存在一个实例默认作用域容器中只会创建一个实例并在容器的整个生命周期中共享该实例原型每次请求时都会创建一个新的实例次从容器中获取该时都会创建一个新实例适用于状态非常瞬时的请求每个请求都会创建一个新的实例仅在应用程序中有效每个请求都会创建一个新的实例适用于应用中需求局部性的会话范围内只会创建一个实例该实例在用户会话范围内共享仅在应用程序中有效适用于与用户会话相关的当前中只存在一个实例仅在应用程序中有效该实例在整个范围内共享适用于应用程序范围内共享的套接字在范围内只存在一个实例仅在支持的应用程序中有效该实例在会话范围内共享适用于会话范围内共享的自定义作用域允许开发者定义自定义的作用域通过实现接口来创建新的作用域在配置文件中可以通过标签的属性来指定的作用域例如在或基于的配置中可以通过注解来指定的作用域例如容器里存的是什么在容器中存储的主要是对象是框架中的基本组件用于表示应用程序中的各种对象当应用程序启动时容器会根据配置文件或注解的方式创建和管理这些对象容器会负责创建初始化注入依赖以及销毁对象在中在加载销毁前后如果想实现某些逻辑可以怎么做在框架中如果你希望在加载即实例化属性赋值初始化等过程完成后或销毁前后执行某些逻辑你可以使用的生命周期回调接口或注解这些接口和注解允许你定义在生命周期的关键点执行的代码使用和在配置中你可以通过和属性来指定初始化后和销毁前需要调用的方法然后在你的类中实现这些方法初始化逻辑销毁逻辑实现和接口你的类可以实现和接口并分别实现和方法初始化逻辑销毁逻辑使用和注解初始化逻辑销毁逻辑使用注解的和属性在基于的配置中你还可以在注解中指定和属性注入和注入最终得到了相同的效果它们在底层是怎样做的在框架中基于注解的注入如和基于的依赖注入虽然在配置方式上不同但在底层最终都通过容器的统一机制实现依赖注入它们的核心流程可以归纳为以下步骤阶段注解注入注入配置解析通过注解处理器扫描类路径解析等注解解析文件中的标签生成将注解信息转换为将配置转换为依赖注入由等后处理器处理在中直接记录属性或构造器参数由容器直接注入最终结果生成完整的实例完成依赖注入生成完整的实例完成依赖注入注入使用文件进行注入时在启动时会读取配置文件以下是其底层步骤定义解析容器通过类解析配置文件读取其中的标签以获取的定义信息注册定义解析后的信息被注册到如中包括的类作用域依赖关系初始化和销毁方法等实例化和依赖注入当应用程序请求某个时容器会根据已经注册的定义首先使用反射机制创建该的实例然后根据定义中的配置通过方法构造函数或方法注入所需的依赖注解注入使用注解进行注入时的处理过程如下类路径扫描当容器启动时它首先会进行类路径扫描查找带有特定注解如和的类注册定义找到的类会被注册到中容器将为其生成定义信息这通常通过类来实现依赖注入与注入类似在实例化时也会检查字段上是否有或注解如果有会根据注解的信息进行依赖注入尽管使用的方式不同但注入和注解注入在底层的实现机制是相似的主要体现在以下几个方面无论是还是注解最终都会生成对象并存储在同一个中后处理器提供了多个后处理器如用于处理注解如的依赖注入对于也有相应的后处理器来处理配置的依赖注入依赖查找在依赖注入时容器会通过中的方法来查找和注入依赖无论是通过还是注解都会调用类似的查找方法给我们提供了很多扩展点这些有了解吗框架提供了许多扩展点使得开发者可以根据需求定制和扩展的功能以下是一些常用的扩展点允许在容器实例化之前修改的定义常用于修改属性或改变的作用域可以在实例化配置以及初始化之后对其进行额外处理常用于代理修改属性等用于定义不同的属性源如文件数据库等以便在应用中使用和用于根据条件动态注册定义实现配置类的模块化中的用于拦截处理请求可以在请求处理前处理中和处理后执行特定逻辑中的用于全局处理控制器的异常数据绑定和数据校验的自动配置通过创建自定义的自动配置类可以实现对框架和第三方库的自动配置自定义注解创建自定义注解用于实现特定功能或约定如权限控制日志记录等框架中的作用域有哪些请分别说明它们的生命周期和应用场景大标准作用域全局唯一实例容器加载时创建适用于无状态服务每次获取新实例适用于有状态对象如层每次请求一个实例需环境适用于请求上下文数据每个用户会话一个实例需环境适用于会话级数据全局共享实例需环境生命周期实例化属性注入初始化完成使用销毁循环依赖单例注入三级缓存一级缓存存储完全初始化的单例二级缓存存储早期曝光的解决的循环依赖三级缓存存储的工厂用于生成代理对象解决代理的循环依赖和的区别是容器本身负责管理所有是你自己定义的用来创建其他对比点类型接口顶层容器接口自定义的工厂位置框架提供用户自定义实现作用提供获取的基础功能如用于控制某个复杂的创建逻辑返回对象返回注册的原始实例返回由方法创建的对象示例用途加载懒加载场景用到中用于创建接口代理典型实现类用户自定义如示例提供就是容器负责拿常用于早期的配置方式示例用户自定义返回一个自定义创建的对象实际注入的是返回的实例启动时会识别但注入时拿的是的返回值如果你想拿到本身可以用是的底层容器接口提供了的获取懒加载等功能是一个用于创建的工厂类由我们自定义创建逻辑它本身是一个但它返回的对象是产生的例如就是通过动态创建接口代理对象分层介绍一下全名是是模型视图控制器的缩写一种软件设计典范用一种业务逻辑数据界面显示分离的方法组织代码将业务逻辑聚集到一个部件里面在改进和个性化定制界面及用户交互的同时不需要重新编写业务逻辑视图为用户提供使用界面与用户直接进行交互模型代表一个存取数据的对象或简单对象它也可以带有逻辑主要用于承载数据并对用户提交请求进行计算的模块模型分为两类一类称为数据承载一类称为业务处理所谓数据承载是指实体类如类专门为用户承载业务数据的而业务处理则是指或对象专门用于处理用户提交请求的控制器用于将用户请求转发给相应的进行处理并根据的计算结果向用户提供相应响应它使视图与模型分离流程步骤用户通过页面向服务端提出请求可以是表单请求超链接请求请求等服务端控制器接收到请求后对请求进行解析找到相应的对用户请求进行处理处理将处理结果再交给控制器其实只是起到了承上启下的作用根据处理结果找到要作为向客户端发回的响应页面页面经渲染后发送给客户端了解的处理流程吗的工作流程如下用户发送请求至前端控制器收到请求调用处理器映射器处理器映射器根据请求找到具体的处理器生成处理器执行链包括处理器对象和处理器拦截器一并返回给根据处理器获取处理器适配器执行处理一系列的操作如参数封装数据格式转换数据验证等操作执行处理器也叫页面控制器执行完成返回将执行结果返回到将传给视图解析器解析后返回具体对进行渲染视图即将模型数据填充至视图中响应用户请求前端控制器返回执行链给前端控制器请求处理器适配器返回前端控制器给传输给视图解析器解析完返回给前端控制器渲染一下到域形成的执行流程如下用户点击某个请求路径发起一个请求该请求会被提交到前端控制器由请求一个或多个处理器映射器并返回一个执行链将执行链返回的信息发送给处理器适配器根据信息找到并执行相应的常称为执行完毕后会返回给一个对象的底层对象包括数据模型和视图信息接收到对象后将其返回给接收到对象后会请求视图解析器对视图进行解析根据信息匹配到相应的视图结果并返回给接收到具体的视图后进行视图渲染将中的模型数据填充到视图中的域生成最终的视图视图负责将结果显示到浏览器客户端和有了解吗作用负责将请求映射到处理器功能根据请求的请求参数等信息找到处理请求的类型提供了多种实现如等工作流程根据请求信息确定要请求的处理器可以根据请求参数等规则确定对应的处理器作用负责调用处理器来处理请求功能处理器可能有不同的接口类型接口接口等根据处理器的类型来选择合适的方法来调用处理器类型提供了多个实现用于适配不同类型的处理器工作流程根据处理器的接口类型选择相应的来调用处理器工作流程当客户端发送请求时根据请求信息找到对应的处理器根据处理器的类型选择合适的方法来调用处理器处理器执行相应的业务逻辑生成将处理器的执行结果包装成视图解析器根据找到对应的视图进行渲染将渲染后的视图返回给客户端和协同工作通过将请求映射到处理器并调用处理器来处理请求实现了请求处理的流程它们的灵活性使得在中可以支持多种处理器和处理方式提高了框架的扩展性和适应性为什么使用简化开发通过提供一系列的开箱即用的组件和自动配置简化了项目的配置和开发过程开发人员可以更专注于业务逻辑的实现而不需要花费过多时间在繁琐的配置上快速启动提供了快速的应用程序启动方式可通过内嵌的或等容器快速启动应用程序无需额外的部署步骤方便快捷自动化配置通过自动配置功能根据项目中的依赖关系和约定俗成的规则来配置应用程序减少了配置的复杂性使开发者更容易实现应用的最佳实践比好在哪里提供了自动化配置大大简化了项目的配置过程通过约定优于配置的原则很多常用的配置可以自动完成开发者可以专注于业务逻辑的实现提供了快速的项目启动器通过引入不同的可以快速集成常用的框架和库如数据库消息队列开发等极大地提高了开发效率默认集成了多种内嵌服务器如无需额外配置即可将应用打包成可执行的文件方便部署和运行用到哪些设计模式代理模式的通过动态代理实现方法级别的切面增强有静态和动态两种代理方式采用动态代理方式策略模式支持和两种动态代理实现方式通过策略接口和不同策略类运行时动态选择其创建一般通过工厂方法实现装饰器模式用解决缓存与数据库事务问题增加对事务的支持单例模式默认是单例模式通过单例注册表如实现简单工厂模式中的是简单工厂模式的体现通过工厂类方法获取实例工厂方法模式中的体现工厂方法模式为不同产品提供不同工厂观察者模式观察者模式包含事件监听者发送者通过定义事件监听器和发送者实现观察者注册在中消息发送由完成模板模式的创建过程涉及模板模式体现扩展性类似回调实现方式适配器模式中针对不同方式定义的利用适配器模式统一函数定义定义了统一接口及对应适配器类怎么理解中的约定大于配置约定大于配置是的核心设计理念它通过预设合理的默认行为和项目规范大幅减少开发者需要手动配置的步骤从而提升开发效率和项目标准化程度理解中的约定大于配置原则可以从以下几个方面来解释自动化配置提供了大量的自动化配置通过分析项目的依赖和环境自动配置应用程序的行为开发者无需显式地配置每个细节大部分常用的配置都已经预设好了例如引入后会自动配置内嵌和无需手动编写默认配置为诸多方面提供大量默认配置如连接数据库设置服务器处理日志等开发人员无需手动配置这些常见内容框架已做好决策例如默认的日志配置可让应用程序快速输出日志信息无需开发者额外繁琐配置日志级别输出格式与位置等约定的项目结构提倡特定项目结构通常主应用程序类含方法置于根包控制器类服务类数据访问类等分别放在相应子包如放控制器类放服务类等此约定使团队成员更易理解项目结构与组织新成员加入项目时能快速定位各功能代码位置提升协作效率的项目结构是怎么样的一个正常的企业项目里一种通用的项目结构和代码层级划分的指导意见按这阿里巴巴开发手册时本书上说的一般分为如下几层开放接口层可直接封装接口暴露成接口通过封装成接口网关控制层等终端显示层各个端的模板渲染并执行显示的层当前主要是渲染渲染渲染移动端展示等层主要是对访问控制进行转发各类基本参数校验或者不复用的业务简单处理等层相对具体的业务逻辑服务层层通用业务处理层它有如下特征对第三方平台封装的层预处理返回结果及转化异常信息适配上层接口对层通用能力的下沉如缓存方案中间件通用处理与层交互对多个的组合复用层数据访问层与底层等进行数据交互第三方服务包括其它部门服务接口基础平台其它公司的接口如淘宝开放平台支付宝付款服务高德地图服务等外部接口外部应用数据存储服务提供的接口多见于数据迁移场景中如果从一个用户访问一个网站的情况来看对应着上面的项目代码结构来分析可以贯穿整个代码分层对应代码目录的流转逻辑就是所以以后每当我们拿到一个新的项目到手时只要按照这个思路去看别人项目的代码应该基本都是能理得顺的自动装配原理是什么什么是自动装配的自动装配原理是基于的条件化配置和注解实现的这种机制允许开发者在项目中引入相关的依赖将根据这些依赖自动配置应用程序的上下文和功能定义了一套接口规范这套规范规定在启动时会扫描外部引用包中的文件将文件中配置的类型信息加载到容器此处涉及到类加载机制与的容器知识并执行类中定义的各种操作对于外部来说只需要按照定义的标准就能将自己的功能装置进通俗来讲自动装配就是通过注解或一些简单的配置就可以在的帮助下开启和配置各种功能比如数据库访问开发自动装配原理首先点进注解的内部接下来将逐个解释这些注解的作用该注解指定了这个注解可以用来标记在类上在这个特定的例子中这表示该注解用于标记配置类这个注解指定了注解的生命周期即在运行时保留这是因为在运行时扫描类路径上的注解来实现自动配置所以这里使用了保留策略该注解表示这个注解应该被包含在文档中它是用于生成文档的标记使开发者能够看到这个注解的相关信息这个注解指示一个被标注的类型是被继承的在这个例子中它表明这个注解可以被继承如果一个类继承了带有这个注解的类它也会继承这个注解这个注解表明这是一个配置类如果点进这个注解内部会发现与标准的没啥区别只是为了表明这是一个专门用于的配置这个注解是自动装配的核心它告诉启用自动配置机制根据项目的依赖和配置自动配置应用程序的上下文通过这个注解将尝试根据类路径上的依赖自动配置应用程序这个注解用于配置组件扫描的规则在这里它告诉在指定的包及其子包中查找组件这些组件包括被注解的类注解的类等其中的参数用于指定排除哪些组件这里使用了两个自定义的过滤器分别是和这个注解是实现自动装配的核心注解将项目中包下的所有组件注册到容器中例如标注了注解的类等是自动装配的核心接下来分析一下这个注解是中一个重要的类它实现了接口用于实现自动配置的选择和导入具体来说它通过分析项目的类路径和条件来决定应该导入哪些自动配置类代码太多选取部分主要功能的代码其他方法和属性获取所有符合条件的类的全限定类名例如的全限定类名这些类需要被加载到容器中扫描类路径上的文件获取所有实现了接口的自动配置类过滤掉不满足条件的自动配置类比如一些自动装配类排序自动配置类根据和注解指定的顺序将满足条件的自动配置类的类名数组返回这些类将被导入到应用程序上下文中其他方法获取自动配置类的候选列表从文件中读取通过类加载器加载所有候选类过滤出实现了接口的自动配置类对于版本还需要添加包中的自动配置类其他方法使用条件判断机制过滤掉不满足条件的自动配置类其他方法根据和注解指定的顺序对自动配置类进行排序其他方法梳理一下以下是的主要工作扫描类路径在应用程序启动时会扫描类路径上的文件这个文件中包含了各种配置和扩展的定义在这里它会查找所有实现了接口的类具体的实现为方法条件判断对于每一个发现的自动配置类会使用条件判断机制通常是通过注解来确定是否满足导入条件这些条件可以是配置属性类是否存在是否存在等等根据条件导入自动配置类满足条件的自动配置类将被导入到应用程序的上下文中这意味着它们会被实例化并应用于应用程序的配置自动配置通过触发利用扫描中的配置类配置类基于条件注解如类路径存在性缺失等选择性生效自动创建所需该机制通过条件判断和扩展实现零配置简化环境适配与组件装配过程说几个启动器这是最常用的起步依赖之一它包含了和嵌入式服务器用于快速构建应用程序提供了的基本配置帮助开发者快速实现应用的安全性包括认证和授权功能这个是由团队提供的用于简化在应用中集成的过程它自动配置了的相关组件包括等使得开发者能够快速地开始使用进行数据库操作或如果使用的是进行数据库操作那么应该使用这个包含了等实现以及数据库连接池等必要的库可以让你轻松地与数据库进行交互你需要在或中配置的连接信息如果倾向于直接使用而不通过那么可以使用它提供了基本的支持用于集成缓存和数据存储服务这个包含了与交互所需的客户端默认是客户端也可以配置为客户端以及的支持使得在应用中使用变得非常便捷同样地需要在配置文件中设置服务器的连接详情包含了单元测试和集成测试所需的库如等便于进行测试驱动开发写过吗步骤创建项目首先需要创建一个新的项目在中添加的和一些必要的依赖例如步骤添加自动配置在中添加自动配置的元数据例如然后创建类该类需要和注解用于启用你定义的配置属性类步骤创建配置属性类创建一个配置属性类使用注解来绑定配置文件中的属性步骤创建服务和控制器创建一个服务类和服务实现类以及一个控制器来展示你的的功能步骤发布将你的发布到仓库无论是私有的还是公共的如或步骤使用在你的主应用的中添加你的依赖然后在或中配置你的属性里面有哪些重要的注解还有一个配置相关的注解是哪个中一些常用的注解包括用于标注主应用程序类标识一个应用程序的入口点同时启用自动配置和组件扫描标识控制器类处理请求结合和返回风格的数据标识服务类通常用于标记业务逻辑层标识数据访问组件通常用于标记数据访问层通用的组件注解表示一个受管理的组件用于自动装配用于注入配置属性值用于映射请求路径到的处理方法简化的和请求另外一个与配置相关的重要注解是用于指定一个类为配置类其中定义的会被容器管理通常与配合使用用于声明一个实例由容器进行管理其中最重要得注解是他是用于标注主应用程序开启自动配置具体是内部的注解实现的自动配置在启动的时候开启自动配置主要是基于项目中引入的类和已定义的来实现的的关键功能是通过注解导入的来完成的配置类注解根据一些特定条件来控制的实例化的行为位置在的启动类上包扫描怎么开启事务在中开启事务非常简单只需在服务层的方法上添加注解即可例如假设我们有一个接口其中有一个保存用户的方法我们希望在这个方法中开启事务只需在该方法上添加注解如下所示这样当调用方法时就会自动为该方法开启一个事务如果方法执行成功事务会自动提交如果方法执行失败事务会自动回滚怎么做到导入就可以直接使用的这个主要依赖于自动配置起步依赖和条件注解等特性起步依赖起步依赖是一种特殊的或依赖它将项目所需的一系列依赖打包在一起例如这个起步依赖就包含了等构建应用所需的核心依赖开发者只需在项目中添加一个起步依赖或就会自动下载并管理与之关联的所有依赖避免了手动添加大量依赖的繁琐过程比如在中添加依赖自动配置的自动配置机制会根据类路径下的依赖和开发者的配置自动创建和配置应用所需的它通过注解启用该注解会触发去查找文件文件中定义了一系列自动配置类会根据当前项目的依赖情况选择合适的自动配置类进行加载例如如果项目中包含依赖会加载类该类会自动配置的相关组件如视图解析器等开发者可以通过自定义配置来覆盖自动配置的默认行为如果开发者在或中定义了特定的配置或者在代码中定义了同名的会优先使用开发者的配置条件注解条件注解用于控制的创建和加载只有在满足特定条件时才会创建相应的的自动配置类中广泛使用了条件注解如等比如表示只有当类路径中存在指定的类时才会创建该例如在类中可能会有如下代码配置相关的这段代码表示只有当类路径中存在和类时才会加载类中的配置过滤器和拦截器说一下在中过滤器和拦截器是用于处理请求和响应的两种不同机制特性过滤器拦截器规范框架规范框架作用范围全局所有请求静态资源层仅拦截管理的请求执行顺序在之前执行在之后方法前后执行依赖注入支持无法直接注入需间接获取支持自动注入触发时机在请求前响应后被调用分阶段触发适用场景全局请求处理编码日志安全业务逻辑相关的处理权限参数校验过滤器是规范中的一部分它可以对进入容器的请求和响应进行预处理和后处理过滤器通过实现接口并重写其中的和方法来完成相应的逻辑当请求进入容器时会按照配置的顺序依次经过各个过滤器然后再到达目标或控制器响应返回时也会按照相反的顺序再次经过这些过滤器拦截器是框架提供的一种机制它可以对控制器方法的执行进行拦截拦截器通过实现接口并重写其中的和方法来完成相应的逻辑当请求到达控制器时会先经过拦截器的方法如果该方法返回则继续执行后续的控制器方法和其他拦截器在控制器方法执行完成后会调用拦截器的方法最后在请求处理完成后会调用拦截器的方法过滤器和拦截器的区别如下所属规范过滤器是规范的一部分而拦截器是框架提供的机制执行顺序过滤器在请求进入容器后在到达目标或控制器之前执行拦截器在请求到达控制器之后在控制器方法执行前后执行使用范围过滤器可以对所有类型的请求进行过滤包括静态资源请求拦截器只能对控制器的请求进行拦截功能特性过滤器主要用于对请求和响应进行预处理和后处理如字符编码处理请求日志记录等拦截器可以更细粒度地控制控制器方法的执行如权限验证性能监控等说说的启动流程将日常企业应用研发中的各种常见都抽取出来做成一个个的启动器中整合了该场景下各种可能用到的依赖用户只需要在中引入依赖就能自动扫描到要加载的信息并启动相应的默认配置提供了大量的自动配置让用户摆脱了处理各种依赖和配置的困扰所有这些都遵循这约定俗成的默认配置并允许用户调整这些配置即遵循约定大于配置的原子和是提供的注解是提供的注解是只能按类型注入默认按名称注入也支持按类型注入按类型装配依赖对象默认情况下它要求依赖对象必须存在如果允许值可以设置它属性为如果我们想使用按名称装配可以结合注解一起使用与传统的相比的优点基于语句编程相当灵活不会对应用程序或者数据库的现有设计造成任何影响写在里解除与程序代码的耦合便于统一管理提供标签支持编写动态语句并可重用与相比减少了以上的代码量消除了大量冗余的代码不需要手动开关连接很好的与各种数据库兼容因为使用来连接数据库所以只要支持的数据库都支持能够与很好的集成开发效率高提供映射标签支持对象与数据库的字段关系映射提供对象关系映射标签支持对象关系组件维护觉得在哪方面做的比较好在灵活性动态支持结果集映射和与整合方面表现卓越尤其适合重视可控性的项目与代码解耦灵活可控允许开发者直接编写和优化相比全自动如让开发者明确知道每条的执行逻辑便于性能调优示例中定义动态的强大支持比如可以动态拼接通过等标签动态生成避免代码中繁琐的字符串拼接自动映射与自定义映射结合自动将查询结果字段名与对象属性名匹配如驼峰转换插件扩展机制可编写插件拦截执行过程实现分页性能监控改写等通用逻辑实现分页逻辑与生态无缝集成通过快速扫描接口结合事务管理配置简洁高效数据源和配置还记得连接数据库的步骤吗使用连接数据库的一般步骤如下加载数据库驱动程序在使用连接数据库之前需要加载相应的数据库驱动程序可以通过来加载数据库的驱动程序不同数据库的驱动类名会有所不同建立数据库连接使用类的方法来连接数据库其中是数据库的连接字符串包括数据库类型主机端口等是数据库用户名是密码创建对象通过对象的方法创建一个对象用于执行查询或更新操作执行查询或更新操作使用对象的方法来执行查询操作或者使用方法来执行或操作处理查询结果如果是查询操作通过对象来处理查询结果可以使用的方法遍历查询结果集然后通过方法获取各个字段的值关闭连接在完成数据库操作后需要逐级关闭数据库连接相关对象即先关闭再关闭最后关闭以下是一个简单的示例代码加载数据库驱动程序建立数据库连接创建对象执行查询处理查询结果处理每一行数据关闭资源请注意在实际应用中需要进行异常处理以确保资源的正确释放以及使用来简化代码和确保资源的及时关闭如果项目中要用到原生的去查询该怎样写步骤概述配置在项目中配置的数据源映射文件等创建实体类创建用于映射数据库表的实体类编写映射文件创建文件定义语句和映射关系编写接口创建接口定义数据库操作的方法编写具体的查询语句在接口中定义查询方法并在文件中编写对应的语句调用查询方法在服务层或控制层调用接口中的方法进行查询详细步骤配置在配置文件中配置数据源的文件位置等信息创建实体类创建与数据库表对应的实体类字段名和类型需与数据库表保持一致编写映射文件在目录下创建文件定义语句和映射关系编写接口创建接口定义查询方法编写具体的查询语句在文件中编写对应的语句调用查询方法在服务层或控制层中调用接口中的方法进行查询在层中调用通过以上步骤你可以利用原生的框架来进行数据库查询操作请确保配置正确语句准确并与数据库字段匹配以确保查询的准确性和高效性里的和的区别在处理时会创建预编译的语句将中的替换为号在执行时会为预编译中的占位符赋值调用的方法来赋值预编译的语句执行效率高并且可以防止注入提供更高的安全性适合传递参数值在处理时只是创建普通的语句然后在执行语句时将参数直接拼入到里不能防止注入因为参数直接拼接到语句中如果参数未经过验证过滤可能会导致安全问题和的区别是一个基于的增强工具库旨在简化开发并提高效率以下是和之间的一些主要区别操作通过继承接口提供了一系列内置的快捷方法使得操作更加简单无需编写重复的语句代码生成器提供了代码生成器功能可以根据数据库表结构自动生成实体类接口以及映射文件减少了手动编写的工作量通用方法封装封装了许多常用的方法如条件构造器排序分页查询等简化了开发过程提高了开发效率分页插件内置了分页插件支持各种数据库的分页查询开发者可以轻松实现分页功能而在传统的中需要开发者自己手动实现分页逻辑多租户支持提供了多租户的支持可以轻松实现多租户数据隔离的功能注解支持引入了更多的注解支持使得开发者可以通过注解来配置实体与数据库表之间的映射关系减少了配置文件的编写运用了哪些常见的设计模式建造者模式如等工厂模式如单例模式例如和代理模式实现的核心比如用的的动态代理还有包使用了或者达到延迟加载的效果组合模式例如和各个子类等模板方法模式例如和还有和所有的子类例如适配器模式例如的接口和它对等各种日志框架的适配实现装饰者模式例如包中的子包中等各个装饰者的实现迭代器模式例如迭代器模式的两级缓存及其特点是什么的两级缓存包括一级缓存和二级缓存一级缓存是级别的本地缓存默认开启仅在同一个会话中有效用于避免重复查询同一个查询在会话中只访问一次数据库但在执行更新操作或关闭会话后会失效且不能跨线程跨请求二级缓存是级别的全局缓存默认关闭需要在全局配置中开启并在对应的中使用标签声明它支持多个共享缓存通常用于读多写少的场景如商品信息字典数据等一级缓存生命周期短线程不安全适合单次请求优化二级缓存生命周期长线程安全适合全局数据共享但需注意缓存失效和一致性控制在一次生命周期内相同的查询语句参数会被缓存第二次执行时直接从缓存中取值不会发起数据库请求当前会话有效执行任何更新操作会清空缓存执行不同参数的时候也会失效二级缓存是级别共享缓存多个之间共享该的缓存数据启用条件在配置中启用全局缓存在对应文件中配置标签查询的实体类必须实现查询语句不能使用默认查询是更新是必须关闭后一级缓存的数据才会被写入二级缓存默认缓存实现是可自定义缓存策略如的和原生写的区别什么时候该用是提供的条件构造器用于构建的等子句简化代码书写用于普通查询使用表达式避免写字段名字符串用于更新条件构造方式是传统写的方式通过文件自定义语句更加灵活和强大支持复杂的多表连接子查询等对比项构造器原生语法风格代码风格链式调用语法放在中可读性简洁类型安全特别是接近原生清晰直观编写速度快速开发尤其适合单表编写略慢需额外维护文件灵活性支持简单查询单表分页排序支持复杂多表连接子查询聚合维护性逻辑分散在代码中不易集中查看逻辑集中在更适合团队协作维护运行效率两者本质上都由执行性能差异不大性能主要看写得是否合理调试与日志日志可查看也可通过日志查看使用的场景快速开发原型项目简单的单表查询分页筛选中构造简单业务逻辑需要链式调用构造条件代码更加优雅使用避免字段拼写错误风险推荐日常开发中能用就用提高开发效率使用写的场景涉及复杂多表关联聚合函数子查询动态查询语句过长不适合写在代码中项目追求清晰的逻辑分层可维护性性能调优场景需要手写精细团队需要审查推荐复杂业务线上稳定项目用更清晰更可控分页查询的方式分页指定主键过滤滚动查询分页查询支持页数跳转用户选定第几页就跳转到对应的页面返回记录总条数用户可以看到共几页一共多少条数据但是当出现深度分页时需要扫描大量数据才能找到指定页的数据造成慢查询分页查询必须指定排序方式如果没有指定排序方式使用分页很难保证数据不会出现重复指定主键过滤查询条件改进后查询条件改进后在原有的查询条件上指定了上一轮最小的在查询下一页时把上一页的最小传下去这样保证后续查到的列表都是小于从源头上增加了查询条件减少了的检索范围每次都只获取前二十条数据这种方式前提条件是排序方式可以指定主键每次查询都更新主键范围这样就能避免深度分页查询全部的数据滚动查询滚动分页查询则无需获取总页数无需查询总数减少了一次的查询只需要在每一次分页查询时每页数量即可例如每页条可以指定条如果真查出来条上游需要继续查否则上游无需再分页查询分页查询比较适用于检索条件复杂实时性要求比较低的查询场景例如端的各类复杂查询条件检索场景以及端用户关键词订单列表搜索等场景查询耗时基本在以上甚至以上值得一提的是需要数据异构到加载进索引也有左右延迟数据从产生到索引延迟比较高支持分页查询和类似同时也强烈建议使用分页查询时指定排序方式计算出记录起始下标起始记录下标从开始每页显示的记录数和类似也有深度分页的查询压力默认的最大查询深度阈值可以修改在低频的端查询场景可以根据需要适当调整阈值以上种分页查询方式没有最好需要针对不同的场景选择最合适的注册过程动态代理注册流程的理解使用将接口注册为代理对象启动时会把接口方法解析成存入中运行时由通过反射动态执行接口注册注册到创建代理类执行通过执行对应启动时扫描接口会注册或它们会扫描包下所有接口对每个接口注册一个到容器中每个接口注册成一个实现了的接口它不会直接注入自身而是调用返回接口的代理类创建代理类返回的是一个的动态代理对象底层通过实现所以你注入的实际是代理类代理对象调用方法时执行会查找中注册的调用或等执行语句和参数映射都来源于或注解注册的在构建过程中会加载映射文件或注解把每个里的语句解析为调用注册到全局配置里最终保存在的中标签有啥元素属性声明注释处理指令文档类型定义',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-21 22:28:29',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 1.05rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>2</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/Cache/" style="font-size: 1.05rem;">Cache<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 1.05rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/Github/" style="font-size: 1.05rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>2</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/SpringAI/" style="font-size: 1.05rem;">SpringAI<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>57</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>10</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>7</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>4</sup></a><a href="/tags/rocketmq/" style="font-size: 1.05rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>3</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>24</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a><a class="article-meta__tags" href="/tags/spring/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>spring</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Spring面试题hot1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-04T16:00:00.000Z" title="发表于 2025-05-05 00:00:00">2025-05-05</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-21T14:28:29.376Z" title="更新于 2025-07-21 22:28:29">2025-07-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">25.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="Spring面试题hot1"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=3d6fda97-304a-d3c6-a1c8-f2d58a0c71bd"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/05/05/java-stack/spring2/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">技术栈</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><a href="/tags/spring/" tabindex="-1" itemprop="url">spring</a><h1 id="CrawlerTitle" itemprop="name headline">Spring面试题hot1</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-05-04T16:00:00.000Z" title="发表于 2025-05-05 00:00:00">2025-05-05</time><time itemprop="dateCreated datePublished" datetime="2025-07-21T14:28:29.376Z" title="更新于 2025-07-21 22:28:29">2025-07-21</time></header><h1>事务</h1>
<h2 id="1-spring-事务失效的场景有哪些？">1.spring 事务失效的场景有哪些？</h2>
<p>spring事务的实现原理是基于AOP的动态代理和TransacationInterceptorh还有底层依赖</p>
<p>AOP：Spring 通过 ProxyFactoryBean 生成代理对象，默认对接口用 JDK 动态代理，对类用 CGLIB 代理；是采用cglib继承目标类的方式去创建代理类，非pulic的方法不能能继承。</p>
<p>拦截器：核心拦截器，在方法调用前后开启 / 提交 / 回滚事务，基于 ThreadLocal 存储事务状态；基于运行时异常来回滚的，所以把运行时异常给catch或者返回没指定的异常</p>
<p>底层依赖：通过 PlatformTransactionManager 接口适配不同事务管理器（如 JDBC、JPA）。</p>
<p>使用ThreadLocal存储事务的状态，（如连接、隔离级别）通过<code>TransactionSynchronizationManager</code>存在线程本地变量，保证线程安全。</p>
<p>所以基于这个情况,spring事务失效的场景有：</p>
<p>1.吃掉运行时异常没抛出：</p>
<p>2.未配置回滚规则，要配置rollbackFor=Exception.class指定类型</p>
<p>3.调用this</p>
<p>4.非public方法</p>
<p>5.事务的传播属性设置为never,not_support这种不支持事务的</p>
<p>6.调用了不支持事务的数据库</p>
<p>7.事务嵌套：</p>
<p><code>REQUIRES_NEW</code> 会挂起外部事务，<strong>提前提交</strong></p>
<p>嵌套事务用 <code>NESTED</code> 会创建 savepoint，支持回滚子事务（但数据库需支持）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部事务</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">    inner(); <span class="comment">// REQUIRES_NEW</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(); <span class="comment">// 外部异常不会影响 inner 提交的事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 已提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Transactional 属性详解:</p>
<ul>
<li><code>propagation</code>：传播行为（如 REQUIRED：当前有事务则加入，无则新建）；</li>
<li><code>isolation</code>：隔离级别（如 READ_COMMITTED 避免脏读）；</li>
<li><code>timeout</code>：事务超时时间（如<code>timeout=30</code>秒）；</li>
<li><code>rollbackFor/rollbackForClassName</code>：指定回滚的异常类型；</li>
<li><code>noRollbackFor/noRollbackForClassName</code>：指定不回滚的异常类型。</li>
</ul>
<h2 id="2-Spring的事务，使用this调用是否生效？">2.Spring的事务，使用this调用是否生效？</h2>
<p>不能生效。</p>
<p>因为Spring事务是通过代理对象来控制的，只有通过代理对象的方法调用才会应用事务管理的相关规则。当使用<code>this</code>直接调用时，是绕过了Spring的代理机制，因此不会应用事务设置。</p>
<h2 id="3-谈一下spring事务">3.谈一下spring事务</h2>
<p>Spring 提供了 <strong>统一的事务管理抽象</strong>，既支持编程式事务，也支持声明式事务（AOP）。核心目的是控制数据的一致性与完整性。</p>
<p>多个数据库操作要么都成功，要么都失败（回滚）</p>
<p><strong>@Transactional</strong></p>
<p>放在类上：表示该类的所有方法默认使用事务。</p>
<p>放在方法上：表示该方法启用事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">    propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">    isolation = Isolation.READ_COMMITTED,</span></span><br><span class="line"><span class="meta">    rollbackFor = Exception.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>常用属性，用来指明信息。</p>
<p>ACID和事务的隔离级别和mysql一样</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUIRED</td>
<td>默认值，<strong>当前存在事务就加入</strong>，否则新建事务</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>每次都新建事务，挂起当前事务</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果存在事务，就嵌套执行一个子事务（savepoint）</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>有事务就加入，无事务就非事务执行</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>始终非事务执行，挂起现有事务</td>
</tr>
<tr>
<td>NEVER</td>
<td>非事务执行，<strong>存在事务则抛异常</strong></td>
</tr>
<tr>
<td>MANDATORY</td>
<td>必须在事务中运行，否则抛异常</td>
</tr>
</tbody>
</table>
<p>spring支持编程式事务管理和声明式事务管理两种方式：  ①编程式事务管理使用TransactionTemplate。  ②声明式事务<strong>管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，<strong>将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后</strong>根据执行情况提交或者回滚事务。</strong>  声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h1>spring</h1>
<h2 id="1-说一下你对-Spring-的理解">1.说一下你对 Spring 的理解</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1712650311366-b499469c-5afd-4be9-bad3-d787de86bf98.png" alt=""></p>
<p>Spring框架核心特性包括：</p>
<ul>
<li><strong>IoC容器</strong>：Spring通过<strong>控制反转</strong>实现了<strong>对象的创建和对象间的依赖关系管理</strong>。开发者只需要定义好Bean及其依赖关系，Spring容器负责创建和组装这些对象。</li>
<li><strong>AOP</strong>：面向切面编程，允许开发者定义横切关注点，例如<strong>事务管理、安全控制</strong>等，独立于业务逻辑的代码。通过AOP，可以将这些关注点模块化，<strong>提高代码的可维护性和可重用性。</strong></li>
<li><strong>事务管理</strong>：Spring提供了一致的事务管理接口，<strong>支持声明式和编程式事务</strong>。开发者可以轻松地进行事务管理，而无需关心具体的事务API。</li>
<li><strong>MVC框架</strong>：Spring **MVC是一个基于Servlet API构建的Web框架，采用了模型-视图-控制器（MVC）架构。**它支持灵活的URL到页面控制器的映射，以及多种视图技术。</li>
</ul>
<h2 id="2-spring的核心思想说说你的理解？">2.spring的核心思想说说你的理解？</h2>
<table>
<thead>
<tr>
<th><strong>核心思想</strong></th>
<th><strong>解决的问题</strong></th>
<th><strong>实现手段</strong></th>
<th><strong>典型应用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IOC</strong></td>
<td>对象创建与依赖管理的高耦合</td>
<td>容器管理Bean生命周期</td>
<td>动态替换数据库实现、服务组装</td>
</tr>
<tr>
<td><strong>DI</strong></td>
<td>依赖关系的硬编码问题</td>
<td>Setter/构造器/注解注入</td>
<td>注入数据源、服务层依赖DAO层</td>
</tr>
<tr>
<td><strong>AOP</strong></td>
<td>横切逻辑分散在业务代码中</td>
<td>动态代理与切面配置</td>
<td>日志、事务、权限校验统一处理</td>
</tr>
</tbody>
</table>
<p>Spring通过这IOC、DI、AOP三大核心思想，实现了轻量级、高内聚低耦合的企业级应用开发框架，成为Java生态中不可或缺的基石。</p>
<h2 id="3-Spring-IoC和AOP-介绍一下">3.Spring IoC和AOP 介绍一下</h2>
<ul>
<li><strong>IoC</strong>：即控制反转的意思，它是一种<strong>创建和获取对象</strong>的技术思想，**依赖注入(DI)是实现这种技术的一种方式。**传统开发过程中，我们需要通过new关键字来创建对象。使用IoC思想开发方式的话，我们不通过new关键字创建对象，<strong>而是通过IoC容器来帮我们实例化对象。 通过IoC的方式，可以大大降低对象之间的耦合度。</strong></li>
<li><strong>AOP</strong>：是面向切面编程，能够将那些<strong>与业务无关，却为业务模块所共同调用的逻辑封装起来，以减少系统的重复代码，降低模块间的耦合度。<strong>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP <strong>会使用 JDK Proxy</strong>，去创建代理对象，而对于没有</strong>实现接口的对象</strong>，就无法使用 JDK Proxy 去进行代理了，<strong>这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理。</strong></li>
</ul>
<p>在 Spring 框架中，IOC 和 AOP 结合使用，可以更好地实现代码的模块化和分层管理。例如：</p>
<ul>
<li>通过 IOC 容器管理对象的依赖关系，然后通过 AOP 将横切关注点统一切入到需要的业务逻辑中。</li>
<li>使用 IOC 容器管理 Service 层和 DAO 层的依赖关系，然后通过 AOP 在 Service 层实现事务管理、日志记录等横切功能，使得业务逻辑更加清晰和可维护。</li>
</ul>
<h2 id="4-Spring的aop介绍一下">4.Spring的aop介绍一下</h2>
<p>Spring AOP是Spring框架中的一个重要模块，用于实现面向切面编程。</p>
<p>我们知道，Java 就是一门面向对象编程的语言，在 OOP 中最小的单元就是“Class 对象”，但是在 AOP 中最小的单元是“切面”。一个“切面”可以包含很多种类型和对象，对它们进行模块化管理，例如事务管理。</p>
<p>在面向切面编程的思想里面，把功能分为两种</p>
<ul>
<li><strong>核心业务</strong>：登陆、注册、增、删、改、查、都叫核心业务</li>
<li><strong>周边功能</strong>：日志、事务管理这些次要的为周边业务</li>
</ul>
<p>在面向切面编程中，核心业务功能和周边功能是分别独立进行开发，两者不是耦合的，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP。</p>
<p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p>在 AOP 中有以下几个概念：</p>
<ul>
<li><strong>AspectJ</strong>：切面，只是一个概念，没有具体的接口或类与之对应，是 Join point，Advice 和 Pointcut 的一个统称。</li>
<li><strong>Join point</strong>：连接点，指程序执行过程中的一个点，例如方法调用、异常处理等。在 Spring AOP 中，仅支持方法级别的连接点。</li>
<li><strong>Advice</strong>：通知，即我们定义的一个切面中的横切逻辑，有“around”，“before”和“after”三种类型。在很多的 AOP 实现框架中，Advice 通常作为一个拦截器，也可以包含许多个拦截器作为一条链路围绕着 Join point 进行处理。</li>
<li><strong>Pointcut</strong>：切点，用于匹配连接点，一个 AspectJ 中包含哪些 Join point 需要由 Pointcut 进行筛选。</li>
<li><strong>Introduction</strong>：引介，让一个切面可以声明被通知的对象实现任何他们没有真正实现的额外的接口。例如可以让一个代理对象代理两个目标类。</li>
<li><strong>Weaving</strong>：织入，在有了连接点、切点、通知以及切面，如何将它们应用到程序中呢？没错，就是织入，在切点的引导下，将通知逻辑插入到目标方法上，使得我们的通知逻辑在方法调用时得以执行。</li>
<li><strong>AOP proxy</strong>：AOP 代理，指在 AOP 实现框架中实现切面协议的对象。在 Spring AOP 中有两种代理，分别是 JDK 动态代理和 CGLIB 动态代理。</li>
<li><strong>Target object</strong>：目标对象，就是被代理的对象。</li>
</ul>
<p>Spring AOP 是基于 <strong>JDK 动态代理和 Cglib 提升</strong>实现的，两种代理方式都属于运行时的一个方式，所以它没有编译时的一个处理，那么因此 Spring 是通过 Java 代码实现的。</p>
<h2 id="5-IOC和AOP是通过什么机制来实现的">5.IOC和AOP是通过什么机制来实现的?</h2>
<blockquote>
<p>Spring IOC 实现机制</p>
</blockquote>
<ul>
<li><strong>反射</strong>：Spring IOC容器利用Java的反射机制动态地加载类、创建对象实例及调用对象方法，反射允许在运行时检查类、方法、属性等信息，从而实现灵活的对象实例化和管理。</li>
<li><strong>依赖注入</strong>：IOC的核心概念是<strong>依赖注入</strong>，即容器负责管理应用程序组件之间的依赖关系。Spring通过构造函数注入、属性注入或方法注入，将组件之间的依赖关系描述在配置文件中或使用注解。</li>
<li><strong>设计模式 - 工厂模式</strong>：Spring IOC容器通常采用**工厂模式来管理对象的创建和生命周期。**容器作为工厂负责实例化Bean并管理它们的生命周期，将Bean的实例化过程交给容器来管理。</li>
<li><strong>容器实现</strong>：Spring IOC容器是实现IOC的核心，通常使用BeanFactory或ApplicationContext来管理Bean。<strong>BeanFactory是IOC容器的基本形式，提供基本的IOC功能</strong>；ApplicationContext是BeanFactory的扩展，并提供更多企业级功能。</li>
</ul>
<blockquote>
<p>Spring AOP 实现机制</p>
</blockquote>
<p>Spring AOP的实现依赖于<strong>动态代理技术</strong>。动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。</p>
<p>Spring AOP支持两种动态代理：</p>
<ul>
<li><strong>基于JDK的动态代理</strong>：使用<strong>java.lang.reflect.Proxy</strong>类和<strong>java.lang.reflect.InvocationHandler</strong>接口实现。这种方式需要代理的类实现一个或多个接口。</li>
<li><strong>基于CGLIB的动态代理</strong>：当被代理的类没有实现接口时，Spring会<strong>使用CGLIB库</strong>生成一个被代理类的子类作为代理。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理。</li>
</ul>
<h2 id="6-怎么理解SpringIoc？">6.怎么理解SpringIoc？</h2>
<p><strong>IOC</strong>：Inversion Of Control，即控制反转，是一种设计思想。在传统的 Java SE 程序设计中，我们直接在对象内部通过 new 的方式来创建对象，是程序主动创建依赖对象；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1716790809843-e520e960-fb95-4511-aa30-73966361320a.webp" alt="img"></p>
<p>而在Spring程序设计中，IOC 是有专门的容器去控制对象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1716790809860-74256f8b-3a96-485c-8aa1-11fa5dfb7640.webp" alt="img"></p>
<p><strong>所谓控制</strong>就是对象的创建、初始化、销毁。</p>
<ul>
<li>创建对象：原来是 new 一个，现在是由 Spring 容器创建。</li>
<li>初始化对象：原来是对象自己通过构造器或者 setter 方法给依赖的对象赋值，现在是由 Spring 容器自动注入。</li>
<li>销毁对象：原来是直接给对象赋值 null 或做一些销毁操作，现在是 Spring 容器管理生命周期负责销毁对象。</li>
</ul>
<p>总结：IOC 解决了繁琐的对象生命周期的操作，解耦了我们的代码。<strong>所谓反转</strong>：其实是反转的控制权，前面提到是<strong>由 Spring 来控制对象的生命周期</strong>，那么对象的控制就完全脱离了我们的控制，控制权交给了 Spring 。这个反转是指：我们由对象的控制者变成了 IOC 的被动控制者。</p>
<h2 id="7-依赖倒置，依赖注入，控制反转分别是什么？">7.依赖倒置，依赖注入，控制反转分别是什么？</h2>
<ul>
<li>控制反转：“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</li>
<li>依赖注入：依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将<strong>依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</strong></li>
<li>依赖倒置：这条原则跟控制反转有点类似，主要用来指导框架层面的设计。<strong>高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</strong></li>
</ul>
<h2 id="8-依赖注入了解吗？怎么实现依赖注入的？">8.依赖注入了解吗？怎么实现依赖注入的？</h2>
<p>在传统编程中，当一个类需要使用另一个类的对象时，通常会在该类内部通过<code>new</code>关键字来创建依赖对象，这使得类与类之间的耦合度较高。</p>
<p>而依赖注入则是将<strong>对象的创建和依赖关系的管理交给 Spring 容器来完成</strong>，类只需要声明自己所依赖的对象，容器会在运行时将这些依赖对象注入到类中，从而降低了类与类之间的耦合度，提高了代码的可维护性和可测试性。</p>
<p>具体到Spring中，常见的依赖注入的实现方式，比如<strong>构造器注入、Setter方法注入，还有字段注入。</strong></p>
<ul>
<li>**构造器注入：**通过构造函数传递依赖对象，保证对象初始化时依赖已就绪。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器注入（Spring 4.3+ 自动识别单构造器，无需显式@Autowired）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>**Setter 方法注入：**通过 Setter 方法设置依赖，灵活性高，但依赖可能未完全初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentGateway gateway;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGateway</span><span class="params">(PaymentGateway gateway)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gateway = gateway;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>**字段注入：**直接通过 <code>@Autowired</code> 注解字段，代码简洁但隐藏依赖关系，不推荐生产代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-如果让你设计一个SpringIoc，你觉得会从哪些方面考虑这个设计？">9.如果让你设计一个SpringIoc，你觉得会从哪些方面考虑这个设计？</h2>
<ul>
<li>Bean的生命周期管理：需要<strong>设计Bean</strong>的创建、初始化、销毁等生命周期管理机制，可以考虑使用工厂模式和单例模式来实现。</li>
<li>依赖注入：需要实现依赖注入的功能，包括属性注入、构造函数注入、方法注入等，<strong>可以考虑使用反射机制和XML配置文件来实现。</strong></li>
<li>Bean的作用域：需要<strong>支持多种Bean作用域</strong>，比如单例、原型、会话、请求等，可以考虑使用Map来存储不同作用域的Bean实例。</li>
<li>AOP功能的支持：需要支持AOP功能，可以考虑使用<strong>动态代理机制和切面编程</strong>来实现。</li>
<li>异常处理：需要考虑异常处理机制，包括Bean创建异常、依赖注入异常等，可以考虑使用try-catch机制来处理异常。</li>
<li>配置文件加载：需要支持从不同的配置文件中加载Bean的相关信息，可以考虑使用XML、注解或者Java配置类来实现。</li>
</ul>
<h2 id="10-SpringAOP主要想解决什么问题">10.SpringAOP主要想解决什么问题</h2>
<p>它的目的是对于面向对象思维的一种补充，而不是像引入命令式、函数式编程思维让他顺应另一种开发场景。在我个人的理解下AOP更像是一种对于不支持多继承的弥补，除开对象的主要特征（我更喜欢叫“强共性”）被抽象为了一条继承链路，对于一些“弱共性”，AOP可以统一对他们进行抽象和集中处理。</p>
<p>举一个简单的例子，打印日志。需要打印日志可能是许多对象的一个<strong>共性</strong>，这在企业级开发中十分常见，但是日志的打印并不反应这个对象的主要共性。而日志的打印又是一个具体的内容，它并不抽象，所以它的工作也不可以用接口来完成。而如果利用继承，打印日志的工作又横跨继承树下面的多个同级子节点，强行侵入到继承树内进行归纳会干扰这些强共性的区分。</p>
<p>这时候，我们就需要AOP了。AOP首先在**一个Aspect（切面）里定义了一些Advice（增强），其中包含具体实现的代码，同时整理了切入点，切入点的粒度是方法。**最后，我们将这些Advice织入到对象的方法上，形成了最后执行方法时面对的完整方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1716791217083-132fe2ba-706a-4d8d-aef3-1617a2046585.png" alt="img"></p>
<h2 id="11-SpringAOP的原理了解吗">11.SpringAOP的原理了解吗</h2>
<p>Spring AOP的实现依赖于<strong>动态代理技术</strong>。动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。</p>
<p>Spring AOP支持两种动态代理：</p>
<ul>
<li><strong>基于JDK的动态代理</strong>：使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口实现。这种方式需要代理的类实现一个或多个接口。</li>
<li><strong>基于CGLIB的动态代理</strong>：当被代理的类没有实现接口时，Spring会使用CGLIB库生成一个被代理类的子类作为代理。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理。</li>
</ul>
<h2 id="12-动态代理是什么？">12.动态代理是什么？</h2>
<p>ava的动态代理是一种在运行时动态创建代理对象的机制，主要用于在不修改原始类的情况下对方法调用进行拦截和增强。</p>
<p>Java动态代理主要分为两种类型：</p>
<ul>
<li><strong>基于接口的代理</strong>（JDK动态代理）： 这种类型的代理要求目标对象必须实现至少一个接口。Java动态代理会创建一个实现了相同接口的代理类，然后在运行时动态生成该类的实例。这种代理的实现核心是<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。每一个**动态代理类都必须实现<code>InvocationHandler</code>接口，并且每个代理类的实例都关联到一个<code>handler</code>。**当通过代理对象调用一个方法时，这个方法的调用会被转发为由<code>InvocationHandler</code><strong>接口的<code>invoke()</code>方法来进行调用。</strong></li>
<li><strong>基于类的代理</strong>（CGLIB动态代理）： CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，它可以在运行时动态生成一个目标类的子类。CGLIB代理不需要目标类实现接口，而是通过继承的方式创建代理类。因此，如果目标对象没有实现任何接口，可以使用CGLIB来创建动态代理。</li>
</ul>
<h2 id="13-动态代理和静态代理的区别">13.动态代理和静态代理的区别</h2>
<p>代理是一种常用的设计模式，目的是：**为其他对象提供一个代理以控制对某个对象的访问，将两个类的关系解耦。**代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。</p>
<p>区别：</p>
<ul>
<li>静态代理：由程序员创建或者是由特定工具创建，在代码编译时就确定了被代理的类是一个静态代理。静态代理通常只代理一个类；</li>
<li>动态代理：在代码运行期间，运用<strong>反射机制</strong>动态创建生成。动态代理代理的是<strong>一个接口下的多个实现类。</strong></li>
</ul>
<h2 id="14-AOP实现有哪些注解？">14.AOP实现有哪些注解？</h2>
<p>常用的注解包括：</p>
<ul>
<li>@Aspect：用于定义切面，标注在切面类上。</li>
<li>@Pointcut：定义切点，标注在方法上，用于指定连接点。</li>
<li>@Before：在方法执行之前执行通知。</li>
<li>@After：在方法执行之后执行通知。</li>
<li>@Around：在方法执行前后都执行通知。</li>
<li>@AfterReturning：在方法执行后返回结果后执行通知。</li>
<li>@AfterThrowing：在方法抛出异常后执行通知。</li>
<li>@Advice：通用的通知类型，可以替代@Before、@After等。</li>
</ul>
<h2 id="15-什么是反射？有哪些使用场景？">15.什么是反射？有哪些使用场景？</h2>
<p>射机制是指程序在运行状态下，**对于任意一个类，都能够获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意属性和方法。**也就是说，Java 反射允许在运行时获取类的信息并动态操作对象，即使在编译时不知道具体的类也能实现。</p>
<p>反射具有以下特性：</p>
<ol>
<li><strong>运行时类信息访问</strong>：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</li>
<li><strong>动态对象创建</strong>：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。</li>
<li><strong>动态方法调用</strong>：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</li>
<li><strong>访问和修改字段值</strong>：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31-20240725232406027.png" alt="img"></p>
<p>Java反射机制在spring框架中，很多地方都用到了反射，让我们来看看Spring的IoC和AOP是如何使用反射技术的。</p>
<blockquote>
<p>1、Spring框架的依赖注入（DI）和控制反转（IoC）</p>
</blockquote>
<p>Spring <strong>使用反射来实现其核心特性</strong>：依赖注入。</p>
<p>在Spring中，开发者可以通过XML配置文件或者基于注解的方式声明组件之间的依赖关系。当应用程序启动时，Spring容器会扫描这些配置或注解，然后利用<strong>反射来实例化Bean</strong>（即Java对象），并根据配置自动装配它们的依赖。</p>
<p>例如**，当一个Service类需要依赖另一个DAO类时，开发者可以在Service类中使用@Autowired注解，而无需自己编写创建DAO实例的代码。**Spring容器会在运行时解析这个注解，**通过反射找到对应的DAO类，实例化它，并将其注入到Service类中。**这样不仅降低了组件之间的耦合度，也极大地增强了代码的可维护性和可测试性。</p>
<blockquote>
<p>2、动态代理的实现</p>
</blockquote>
<p>在需要对现有类的方法调用<strong>进行拦截、记录日志、权限控制或是事务管理</strong>等场景中，反射结合动态代理技术被广泛应用。</p>
<p>一个典型的例子是Spring AOP（面向切面编程）的实现。Spring AOP允许开发者定义切面（Aspect），这些切面可以横切关注点（如日志记录、事务管理），并将其插入到业务逻辑中，而不需要修改业务逻辑代码。</p>
<p>例如，为了给所有的服务层方法添加日志记录功能，可以定义一个切面，在这个切面中，<strong>Spring会使用JDK动态代理或CGLIB（如果目标类没有实现接口）来创建目标类的代理对象。<strong>这个代理对象在调用</strong>任何方法前或后</strong>，都会执行切面中定义的代码逻辑（如记录日志），而这一切都是在运行时通过反射来动态构建和执行的，无需硬编码到每个方法调用中。</p>
<p>这两个例子展示了反射机制如何在实际工程中促进<strong>松耦合、高内聚</strong>的设计，以及如何提供动态、灵活的编程能力，特别是在框架层面和解决跨切面问题时。</p>
<h2 id="16-spring是如何解决循环依赖的？">16.spring是如何解决循环依赖的？</h2>
<p>循环依赖指的是两个类中的属性相互依赖对方：例如 A 类中有 B 属性，B 类中有 A属性，从而形成了一个依赖闭环，如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720684589425-d06727ba-bf03-484a-b656-c225554b5b49.png" alt="img"></p>
<p>循环依赖问题在Spring中主要有三种情况：</p>
<ul>
<li>第一种：通过构造方法进行依赖注入时产生的循环依赖问题。</li>
<li>第二种：通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</li>
<li>第三种：<strong>通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</strong></li>
</ul>
<p>只有【第三种方式】的循环依赖问题被 Spring 解决了，其他两种方式在遇到循环依赖问题时，Spring都会产生异常。</p>
<p>Spring 解决单例模式下的setter循环依赖问题的主要方式是通过<strong>三级缓存</strong>解决循环依赖。三级缓存指的是 Spring 在创建 Bean 的过程中，通过三级缓存来缓存正在创建的 Bean，以及已经创建完成的 Bean 实例。具体步骤如下：</p>
<ul>
<li><strong>实例化 Bean</strong>：Spring 在实例化 Bean 时，<strong>会先创建一个空的 Bean 对象，并将其放入一级缓存中。</strong></li>
<li><strong>属性赋值</strong>：Spring 开始对 Bean 进行属性赋值，如果发现循环依赖，会将当前 Bean 对象提前暴露给后续需要依赖的 Bean（<strong>通过提前暴露的方式解决循环依赖</strong>）。</li>
<li><strong>初始化 Bean</strong>：完成属性赋值后，Spring 将 Bean 进行初始化，并将其放<strong>入二级缓存</strong>中。</li>
<li><strong>注入依赖</strong>：Spring 继续对 Bean 进行依赖注入，<strong>如果发现循环依赖，会从二级缓存中获取已经完成初始化的 Bean 实例。</strong></li>
</ul>
<p>通过三级缓存的机制，Spring 能够在处理循环依赖时，<strong>确保及时暴露正在创建的 Bean 对象，并能够正确地注入已经初始化的 Bean 实例，从而解决循环依赖问题，保证应用程序的正常运行。</strong></p>
<h2 id="17-spring三级缓存的数据结构是什么？">17.spring三级缓存的数据结构是什么？</h2>
<p>都是 Map类型的缓存，比如Map {k:name; v:bean}。</p>
<ol>
<li><strong>一级缓存（Singleton Objects）</strong>：这是一个<strong>Map类型</strong>的缓存，<strong>存储的是已经完全初始化好的bean，即完全准备好可以使用的bean实例</strong>。**键是bean的名称，值是bean的实例。**这个缓存在<code>DefaultSingletonBeanRegistry</code>类中的<code>singletonObjects</code>属性中。</li>
<li><strong>二级缓存（Early Singleton Objects）</strong>：这同样是一个Map类型的缓存，**存储的是早期的bean引用，即已经实例化但还未完全初始化的bean。**这些bean已经被实例化，**但是可能还没有进行属性注入等操作。**这个缓存在<code>DefaultSingletonBeanRegistry</code>类中的<code>earlySingletonObjects</code>属性中。</li>
<li><strong>三级缓存（Singleton Factories）</strong>：这也是一个Map类型的缓存，存储的是<strong>ObjectFactory对象</strong>，这些对象可以生成早期的bean引用。**当一个bean正在创建过程中，如果它被其他bean依赖，那么这个正在创建的bean就会通过这个ObjectFactory来创建一个早期引用，从而解决循环依赖的问题。**这个缓存在<code>DefaultSingletonBeanRegistry</code>类中的<code>singletonFactories</code>属性中。</li>
</ol>
<p>核心机制是提前暴露Bean的早期引用，允许在依赖注入阶段使用未完全初始化的Bean。</p>
<p>仅支持单例作用域和setter/字段注入的循环依赖，构造函数注入和原型作用域无法自动解决。</p>
<p><strong>优先选择</strong>：<strong>使用setter注入或@Lazy注解解决循环依赖。</strong></p>
<p><strong>最佳实践</strong>：通过重构代码（如提取公共Bean、使用事件机制）从根本上消除循环依赖。</p>
<p><strong>禁用循环依赖</strong>：在明确不需要循环依赖时，禁用Spring的循环依赖支持以提高代码健壮性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanA</span><span class="params">(<span class="meta">@Lazy</span> BeanB beanB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建 A -&gt; 依赖注入 B -&gt; 发现 B 依赖 A</span><br><span class="line">        ↓                    ↑</span><br><span class="line">     A 被提早暴露给 B（从三级缓存创建放入二级缓存）</span><br><span class="line">        ↓                    ↑</span><br><span class="line">    B 创建完成，再回来注入 A</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="18-spring框架中都用到了哪些设计模式">18.spring框架中都用到了哪些设计模式</h2>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 <strong>Bean 默认都是单例的</strong>。</li>
<li><strong>模板方法模式</strong> : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。<strong>这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</strong></li>
<li><strong>观察者模式:</strong> <strong>Spring 事件驱动模型</strong>就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li>
</ul>
<h2 id="19-spring-常用注解有什么？">19.spring <strong>常用注解有什么？</strong></h2>
<blockquote>
<p>@Autowired 注解</p>
</blockquote>
<p>@Autowired：主要用于<strong>自动装配bean</strong>。当Spring<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tke?from_column=20065&amp;from=20065">容器 (opens new window)</a>中存在与要注入的属性类型匹配的bean时，它会自动将bean注入到属性中。就跟我们new 对象一样。</p>
<p>用法很简单，如下示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，MyController类中的myService属性被@Autowired注解标记，Spring会自动将MyService类型的bean注入到myService属性中。</p>
<blockquote>
<p>@Component</p>
</blockquote>
<p>这个注解用于<strong>标记一个类作为Spring的bean</strong>。当一个类被@Component注解标记时，Spring会将其实例化为一个bean，并将其添加到Spring容器中。在上面讲解@Autowired的时候也看到了，示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，MyComponent类被@Component注解标记，Spring会将其实例化为一个bean，并将其添加到Spring容器中。</p>
<blockquote>
<p>@Configuration</p>
</blockquote>
<p>@Configuration，注解用于<strong>标记一个类作为Spring的配置类</strong>。配置类可以包含@Bean注解的方法，用于定义和配置bean，作为全局配置。示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Bean</p>
</blockquote>
<p>@Bean注解用于<strong>标记一个方法作为Spring的bean工厂方法</strong>。当一个方法被@Bean注解标记时，Spring会将该方法的返回值作为一个bean，并将其添加到Spring容器中，如果自定义配置，经常用到这个注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Service</p>
</blockquote>
<p>@Service，这个注解用于标记一个类作为服务层的组件。它是@Component注解的特例，用于标记服务层的bean，一般标记在业务service的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@Repository</p>
</blockquote>
<p>@Repository注解<strong>用于标记一个类作为数据访问层的组件</strong>。它也是@Component注解的特例，用于标记数据访问层的bean。这个注解很容易被忽略，导致数据库无法访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，MyRepository类被@Repository注解标记，Spring会将其实例化为一个bean，并将其添加到Spring容器中。</p>
<blockquote>
<p>@Controller</p>
</blockquote>
<p>@Controller注解用于标记一个类作为控制层的组件。它也是@Component注解的特例，用于标记控制层的bean。这是MVC结构的另一个部分，加在控制层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，MyController类被@Controller注解标记，Spring会将其实例化为一个bean，并将其添加到Spring容器中。</p>
<h2 id="20-componet和-bean">20.@componet和@bean</h2>
<p>（1）@Component 注解作用于类，而@Bean注解作用于方法。</p>
<p>（2）@Component注解<strong>通过类路径扫描来自动侦测以及</strong>自动装配到 Spring 容器中，而@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候创建这个bean实例。</p>
<p>（3）@Bean 注解比 @Component 注解的自定义性更强，当需要引用第三方库中的类装配到 Spring容器时，只能通过 @Bean来实现。</p>
<h2 id="21-讲一下-Spring-中用到的设计模式？">21.讲一下 Spring 中用到的设计模式？</h2>
<p>工厂设计模式：用于管理bean对象，包括创建、初始化、销毁等</p>
<p>单例设计模式：默认bean的作用域</p>
<p>动态代理模式：springAop使用了动态代理模式</p>
<p>观察者模式：事件监听的作用</p>
<p>适配器模式：将不兼容的接口转换为客户端期望的接口，如springmvc中handler adapter适配不同的handler 模板方法模式：spring提供一些模板类，如jdbctemplate实现连接不同的数据库，将具体实现步骤放到子类</p>
<h2 id="22-springsecurity是什么">22.springsecurity是什么</h2>
<p>springsecurity是Spring生态里的安全框架，主要用于<strong>web应用的权限管理和认证</strong>，支持多种登录方式并集成防护机制，保障企业级系统的安全性。可防范CSRF/XSS等攻击， 我们可以调整里面可以放行的页面是什么，比如登录页面注册页面等等，还有一些前端页面。通过.antMarch(“”)来放行页面，测试的时候可以关闭这个csrf保护</p>
<h2 id="23-spring-框架里的事务传播机制有哪些？比如-Propagation-REQUIRED-和-REQUIRES-NEW-的区别是啥呀？">23.spring 框架里的事务传播机制有哪些？比如 Propagation.REQUIRED 和 REQUIRES_NEW 的区别是啥呀？</h2>
<ul>
<li><strong><code>Propagation.REQUIRED</code>（默认）</strong>：<br>
如果当前有事务，就加入这个事务；如果没有，就新建一个事务。<br>
<strong>例子</strong>：A 方法调 B 方法，A 有事务，B 也用<code>REQUIRED</code>，那 AB 共用一个事务，要么都成功，要么都回滚。</li>
<li><strong><code>Propagation.REQUIRES_NEW</code></strong>：<br>
不管当前有没有事务，都新建一个事务。原来的事务会被挂起，等新事务完成后再继续。<br>
<strong>例子</strong>：A 方法调 B 方法，A 有事务，B 用<code>REQUIRES_NEW</code>，那 B 自己开一个新事务。如果 B 失败，A 的事务可能不受影响（看 A 有没有捕获异常）。</li>
</ul>
<table>
<thead>
<tr>
<th>传播行为类型</th>
<th>含义总结</th>
<th>是否开启新事务</th>
<th>当前无事务时行为</th>
<th>适用场景简述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>REQUIRED</strong></td>
<td>默认行为，有事务用当前，无则新建</td>
<td>否</td>
<td>新建事务</td>
<td>绝大多数业务场景，默认选项</td>
</tr>
<tr>
<td><strong>REQUIRES_NEW</strong></td>
<td>始终新建事务，挂起外部事务</td>
<td>是</td>
<td>新建事务</td>
<td>独立操作如日志记录、通知发送等</td>
</tr>
<tr>
<td><strong>NESTED</strong></td>
<td>嵌套事务，外部事务失败可回滚内层（依赖保存点）</td>
<td>否（嵌套）</td>
<td>新建事务</td>
<td>数据段落逻辑回滚，不影响整体事务</td>
</tr>
<tr>
<td><strong>SUPPORTS</strong></td>
<td>有事务则加入，无事务则以非事务方式运行</td>
<td>否</td>
<td>非事务运行</td>
<td>兼容性要求不高的查询操作</td>
</tr>
<tr>
<td><strong>NOT_SUPPORTED</strong></td>
<td>不支持事务，挂起外部事务</td>
<td>否</td>
<td>非事务运行</td>
<td>读写分离、不需要事务控制的场景</td>
</tr>
<tr>
<td><strong>MANDATORY</strong></td>
<td>必须运行在事务中，没事务则抛异常</td>
<td>否</td>
<td>抛异常</td>
<td>强依赖事务环境的组件方法</td>
</tr>
<tr>
<td><strong>NEVER</strong></td>
<td>必须在非事务环境中运行，有事务则抛异常</td>
<td>否</td>
<td>正常运行</td>
<td>断言无事务的调用场景（如外部调用）</td>
</tr>
</tbody>
</table>
<h2 id="24-AOP-的实现原理">24.AOP 的实现原理</h2>
<p>概念：适用场景</p>
<p>作用点：</p>
<ul>
<li><strong>切面（Aspect）</strong>：封装横切逻辑的类，用<code>@Aspect</code>注解标识；</li>
<li><strong>切点（Pointcut）</strong>：定义横切逻辑作用的目标方法（如<code>@Pointcut(&quot;execution(* com.service.*.*(..))&quot;)</code>）；</li>
<li><strong>通知（Advice）</strong>：横切逻辑的具体实现，包括 5 种类型</li>
<li><strong>连接点（Joinpoint）</strong>：程序执行中的具体点（如方法调用、字段修改），AOP 中主要指<strong>方法调用</strong></li>
</ul>
<p>动态代理：</p>
<ul>
<li><strong>JDK 动态代理</strong>：基于接口实现，生成<code>InvocationHandler</code>的代理对象，适用于目标类有接口的情况；</li>
<li><strong>CGLIB 代理</strong>：基于子类继承，生成目标类的子类代理对象，适用于无接口的类（需引入<code>cglib</code>依赖）；</li>
<li><strong>Spring 默认策略</strong>：有接口用 JDK 代理，无接口用 CGLIB 代理（可通过<code>proxy-target-class</code>属性强制使用 CGLIB）。</li>
<li>流程：</li>
<li>Spring 容器扫描到<code>@Aspect</code>注解的切面类，解析切点表达式和通知类型；</li>
<li>对目标类判断是否适用 JDK/CGLIB 代理，生成代理对象；</li>
<li>当调用代理对象的方法时，实际执行的是<strong>通知逻辑 + 目标方法</strong>的组合逻辑。</li>
</ul>
<p>细节：</p>
<ol>
<li>
<p><strong>开启 AOP 支持</strong>：在配置类中添加<code>@EnableAspectJAutoProxy</code>注解，或在 XML 中配置<code>&lt;aop:aspectj-autoproxy/&gt;</code>；</p>
</li>
<li>
<p>代理模式选择</p>
<p>：</p>
<ul>
<li>默认<code>proxyTargetClass=false</code>（优先 JDK 代理）；</li>
<li>若需强制 CGLIB 代理，设置<code>proxyTargetClass=true</code>或<code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>；</li>
</ul>
</li>
<li>
<p><strong>循环依赖与 AOP</strong>：若目标类被代理，注入的是代理对象，需注意<code>this.方法()</code>调用不会触发 AOP（因<code>this</code>指向原始对象）。</p>
</li>
</ol>
<p>场景：</p>
<ul>
<li>
<p><strong>日志记录</strong>：在方法执行前后记录入参 / 结果，避免业务代码污染；</p>
</li>
<li>
<p><strong>事务管理</strong>：<code>@Transactional</code>本质是 AOP 实现，在方法调用时开启 / 提交 / 回滚事务；</p>
</li>
<li>
<p><strong>权限校验</strong>：在接口调用前校验用户权限，拒绝非法请求；</p>
</li>
<li>
<p><strong>性能监控</strong>：统计方法执行耗时，用于性能优化。</p>
</li>
</ul>
<p>流程：</p>
<ol>
<li><strong>调用代理方法</strong>：客户端调用代理对象的方法（如<code>userService.save()</code>）；</li>
<li><strong>匹配切点</strong>：Spring 判断该方法是否匹配切面的切点表达式；</li>
<li>执行通知逻辑
<ul>
<li><code>@Around</code>中先执行前置逻辑（如日志记录开始）；</li>
<li>调用<code>proceed()</code>触发目标方法执行；</li>
<li>执行后置逻辑（如日志记录结束、统计耗时）；</li>
</ul>
</li>
<li><strong>返回结果</strong>：通知逻辑执行完毕后，将结果返回给客户端。</li>
</ol>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 定义切点（匹配所有Service方法）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.service..*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">servicePointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 环绕通知实现耗时统计</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法 &quot;</span> + methodName + <span class="string">&quot; 执行耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Bean</h1>
<h2 id="1-Bean的生命周期说一下？">1.Bean的生命周期说一下？</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719570477922-ad595a67-be98-4272-9e13-8ad73dd75c13.png" alt="img"></p>
<ol>
<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>
<li>Bean实例化后对<strong>将Bean的引入和值</strong>注入到Bean的属性中</li>
<li>如果Bean实现了<strong>BeanNameAware</strong>接口的话，Spring将Bean的Id传递给setBeanName()方法</li>
<li>如果Bean实现了<strong>BeanFactoryAware</strong>接口的话，S<strong>pring将调用setBeanFactory()方法，将BeanFactory容器实例传入</strong></li>
<li>如果Bean实现了ApplicationContextAware接口的话，<strong>Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来</strong>。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的<strong>postProcessBeforeInitialization()方法。</strong></li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的<strong>afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</strong></li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>
<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li>
</ol>
<p><strong>创建，初始化，调用，销毁</strong>； bean的创建方式有四种，<strong>构造器，静态工厂，实例工厂，setter注入</strong>的方式。 spring在调用bean的时候因为<strong>作用域</strong>的不同，不同的bean初始化和创建的时间也不相同。 在作用域为<strong>singleton的时候，bean是随着容器一起被创建好并且实例化的，</strong> 在作用域为pritotype的时候，<strong>bean是随着它被调用的时候才创建和实例化完成</strong>。 然后程序就可以使用bean了，当程序完成销毁的时候，bean也被销毁。</p>
<h2 id="2-Bean是否单例？">2.Bean是否单例？</h2>
<p>Spring 中的 Bean <strong>默认都是单例的</strong>。</p>
<p>就是说，<strong>每个Bean的实例只会被创建一次，并且会被存储在Spring容器的缓存中，以便在后续的请求中重复使用。这种单例模式可以提高应用程序的性能和内存效率。</strong></p>
<p>但是，Spring也支持将Bean设置为多例模式，即<strong>每次请求都会创建一个新的Bean实例。要将Bean设置为多例模式，可以在Bean定义中通过设置scope属性为&quot;prototype&quot;来实现。</strong></p>
<p>需要注意的是，虽然Spring的默认行为是将Bean设置为单例模式，但在一些情况下，使用多例模式是更为合适的，<strong>例如在创建状态不可变的Bean或有状态Bean时。此外，需要注意的是，如果Bean单例是有状态的，那么在使用时需要考虑线程安全性问题。</strong></p>
<h2 id="3-Bean的单例和非单例，生命周期是否一样">3.Bean的单例和非单例，生命周期是否一样</h2>
<p>不一样的，Spring Bean 的生命周期完全由 IoC 容器控制。Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 <code>prototype</code> 的 Bean，Spring 在创建好交给使用者之后，则不会再管理后续的生命周期。</p>
<p>具体区别如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>阶段</strong></th>
<th style="text-align:left"><strong>单例（Singleton）</strong></th>
<th style="text-align:left"><strong>非单例（如Prototype）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>创建时机</strong></td>
<td style="text-align:left">容器启动时创建（或首次请求时，取决于配置）。</td>
<td style="text-align:left">每次请求时创建新实例。</td>
</tr>
<tr>
<td style="text-align:left"><strong>初始化流程</strong></td>
<td style="text-align:left">完整执行生命周期流程（属性注入、Aware接口、初始化方法等）。</td>
<td style="text-align:left">每次创建新实例时都会完整执行生命周期流程（仅到初始化完成）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>销毁时机</strong></td>
<td style="text-align:left">容器关闭时销毁，触发<code>DisposableBean</code>或<code>destroy-method</code>。</td>
<td style="text-align:left"><strong>容器不管理销毁</strong>，需由调用者自行释放资源（Spring不跟踪实例）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>内存占用</strong></td>
<td style="text-align:left">单实例常驻内存，高效但需注意线程安全。</td>
<td style="text-align:left">每次请求生成新实例，内存开销较大，需手动管理资源释放。</td>
</tr>
<tr>
<td style="text-align:left"><strong>适用场景</strong></td>
<td style="text-align:left">无状态服务（如Service、DAO层）。</td>
<td style="text-align:left">有状态对象（如用户会话、临时计算对象）。</td>
</tr>
</tbody>
</table>
<h2 id="4-Spring-bean的作用域有哪些？">4.Spring bean的作用域有哪些？</h2>
<p>Spring框架中的Bean作用域（Scope）定义了Bean的生命周期和可见性。不同的作用域影响着Spring容器如何管理这些Bean的实例，包括它们如何被创建、如何被销毁以及它们是否可以被多个用户共享。</p>
<p>Spring支持几种不同的作用域，以满足不同的应用场景需求。以下是一些主要的Bean作用域：</p>
<ul>
<li><strong>Singleton（单例）</strong>：在整个应用程序中<strong>只存在一个 Bean 实例</strong>。默认作用域，Spring 容器中只会创建一个 Bean 实例，并在容器的整个生命周期中共享该实例。</li>
<li><strong>Prototype（原型）</strong>：<strong>每次请求时都会创建一个新的 Bean 实例。次从容器中获取该 Bean 时都会创建一个新实例，适用于状态非常瞬时的 Bean。</strong></li>
<li><strong>Request（请求）</strong>：**每个 HTTP 请求都会创建一个新的 Bean 实例。**仅在 Spring Web 应用程序中有效，每个 HTTP 请求都会创建一个新的 Bean 实例，适用于 Web 应用中需求局部性的 Bean。</li>
<li><strong>Session（会话）</strong>：<strong>Session 范围内只会创建一个 Bean 实例</strong>。该 Bean 实例在用户会话范围内共享，仅在 Spring Web 应用程序中有效，适用于与用户会话相关的 Bean。</li>
<li><strong>Application</strong>：**当前 ServletContext 中只存在一个 Bean 实例。**仅在 Spring Web 应用程序中有效，该 Bean 实例在整个 ServletContext 范围内共享，适用于应用程序范围内共享的 Bean。</li>
<li><strong>WebSocket（Web套接字）</strong>：**在 WebSocket 范围内只存在一个 Bean 实例。**仅在支持 WebSocket 的应用程序中有效，该 Bean 实例在 WebSocket 会话范围内共享，适用于 WebSocket 会话范围内共享的 Bean。</li>
<li><strong>Custom scopes（自定义作用域）</strong>：<strong>Spring 允许开发者定义自定义的作用域，通过实现 Scope 接口来创建新的 Bean 作用域。</strong></li>
</ul>
<p>在Spring配置文件中，可以通过标签的scope属性来指定Bean的作用域。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBeanClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Spring Boot或基于Java的配置中，可以通过@Scope注解来指定Bean的作用域。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> MyBeanClass <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBeanClass</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Spring容器里存的是什么？">5.Spring容器里存的是什么？</h2>
<p>在Spring容器中，存储的<strong>主要是Bean对象</strong>。</p>
<p>Bean是Spring框架中的基本组件，**用于表示应用程序中的各种对象。**当应用程序启动时，Spring容器会根据配置文件或注解的方式创建和管理这些Bean对象。Spring容器会负责创建、初始化、注入依赖以及销毁Bean对象。</p>
<h2 id="6-在Spring中，在bean加载-销毁前后，如果想实现某些逻辑，可以怎么做">6.在Spring中，在bean加载/销毁前后，如果想实现某些逻辑，可以怎么做</h2>
<p>在Spring框架中，如果你希望在<strong>Bean加载（即实例化、属性赋值、初始化等过程完成后）或销毁前后执行某些逻辑，<strong>你可以使用</strong>Spring的生命周期回调接口或注解</strong>。这些接口和注解允许你定义在Bean生命周期的关键点执行的代码。</p>
<blockquote>
<p>使用init-method和destroy-method</p>
</blockquote>
<p>在XML配置中，你可以通过<strong>init-method和destroy-method属性</strong>来指定Bean初始化后和销毁前需要调用的方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBeanClass&quot;</span>  </span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，在你的Bean类中实现这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanClass</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 初始化逻辑  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 销毁逻辑  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>实现InitializingBean和DisposableBean接口</strong></p>
</blockquote>
<p>你的Bean类可以实现org.springframework.beans.factory.InitializingBean和org.springframework.beans.factory.DisposableBean接口，并分别实现<strong>afterPropertiesSet和destroy</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanClass</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="comment">// 初始化逻辑  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="comment">// 销毁逻辑  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用@PostConstruct和@PreDestroy注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;  </span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanClass</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@PostConstruct</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 初始化逻辑  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@PreDestroy</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 销毁逻辑  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用@Bean注解的initMethod和destroyMethod属性</p>
</blockquote>
<p>在基于Java的配置中，<strong>你还可以在@Bean注解中指定initMethod和destroyMethod属性。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBeanClass <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBeanClass</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的">7.Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的</h2>
<p>在Spring框架中，<strong>基于注解的Bean注入（如<code>@Autowired</code>、<code>@Resource</code>）和基于XML的依赖注入</strong>虽然在配置方式上不同，<strong>但在底层最终都通过Spring容器的统一机制实现依赖注入</strong>。它们的核心流程可以归纳为以下步骤：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>阶段</strong></th>
<th style="text-align:left"><strong>注解注入</strong></th>
<th style="text-align:left"><strong>XML注入</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>配置解析</strong></td>
<td style="text-align:left">通过注解处理器扫描类路径，解析<code>@Component</code>、<code>@Autowired</code>等注解。</td>
<td style="text-align:left">解析XML文件中的<code>&lt;bean&gt;</code>、<code>&lt;property&gt;</code>、<code>&lt;constructor-arg&gt;</code>标签。</td>
</tr>
<tr>
<td style="text-align:left"><strong>生成BeanDefinition</strong></td>
<td style="text-align:left">将注解信息转换为<code>AnnotatedBeanDefinition</code>。</td>
<td style="text-align:left">将XML配置转换为<code>GenericBeanDefinition</code>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>依赖注入</strong></td>
<td style="text-align:left">由<code>AutowiredAnnotationBeanPostProcessor</code>等后处理器处理。</td>
<td style="text-align:left">在BeanDefinition中直接记录属性或构造器参数，由容器直接注入。</td>
</tr>
<tr>
<td style="text-align:left"><strong>最终结果</strong></td>
<td style="text-align:left">生成完整的Bean实例，完成依赖注入。</td>
<td style="text-align:left">生成完整的Bean实例，完成依赖注入。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>XML 注入</p>
</blockquote>
<p>使用 XML 文件进行 Bean 注入时，<strong>Spring 在启动时会读取 XML 配置文件，以下是其底层步骤：</strong></p>
<ul>
<li><strong>Bean 定义解析</strong>：Spring 容器通过 <code>XmlBeanDefinitionReader</code> 类解析 XML 配置文件，读取其中的 <code>&lt;bean&gt;</code> 标签以获取 Bean 的定义信息。</li>
<li><strong>注册 Bean 定义</strong>：解析后的 Bean 信息被注册到 <code>BeanDefinitionRegistry</code>（如 <code>DefaultListableBeanFactory</code>）中，包括 Bean 的类、作用域、依赖关系、初始化和销毁方法等。</li>
<li>实例化和依赖注入：当应用程序请求某个 Bean 时，Spring 容器会根据已经注册的 Bean 定义：
<ul>
<li>首先，<strong>使用反射机制创建该 Bean 的实例</strong>。</li>
<li>然后，根据 Bean 定义中的配置，通过 setter 方法、构造函数或方法注入所需的依赖 Bean。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注解注入</p>
</blockquote>
<p>使用注解进行 Bean 注入时，Spring 的处理过程如下：</p>
<ul>
<li><strong>类路径扫描</strong>：当 Spring 容器启动时，它首先会进行类路径扫描，<strong>查找带有特定注解</strong>（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 和 <code>@Controller</code>）的类。</li>
<li><strong>注册 Bean 定义</strong>：找到的类会被注册到 <code>BeanDefinitionRegistry</code> 中，Spring 容器将为其生成 Bean 定义信息。<strong>这通常通过 <code>AnnotatedBeanDefinitionReader</code> 类来实现。</strong></li>
<li><strong>依赖注入</strong>：与 XML 注入类似，Spring 在实例化 Bean 时，也会检查字段上是否有 <code>@Autowired</code>、<code>@Inject</code> 或 <code>@Resource</code> 注解。如果有，<strong>Spring 会根据注解的信息进行依赖注入。</strong></li>
</ul>
<p>尽管使用的方式不同，但 XML 注入和注解注入在底层的实现机制是相似的，主要体现在以下几个方面：</p>
<ol>
<li><strong>BeanDefinition</strong>：无论是 XML 还是注解，最终都会生成 <code>BeanDefinition</code> 对象，并存储在同一个 <code>BeanDefinitionRegistry</code> 中。</li>
<li>后处理器：
<ul>
<li>**Spring 提供了多个 Bean 后处理器（**如 <code>AutowiredAnnotationBeanPostProcessor</code>），用于处理注解（如 <code>@Autowired</code>）的依赖注入。</li>
<li>对于 XML，Spring 也有相应的后处理器来处理 XML 配置的依赖注入。</li>
</ul>
</li>
<li><strong>依赖查找</strong>：在依赖注入时，Spring 容器会通过 <code>ApplicationContext</code> 中的 BeanFactory 方法来查找和注入依赖，无论是通过 XML 还是注解，都会调用类似的查找方法。</li>
</ol>
<h2 id="8-Spring给我们提供了很多扩展点，这些有了解吗？">8.Spring给我们提供了很多扩展点，这些有了解吗？</h2>
<p>Spring框架提供了许多扩展点，使得开发者可以根据需求定制和扩展Spring的功能。以下是一些常用的扩展点：</p>
<ol>
<li>BeanFactoryPostProcessor：允许在Spring容器实例化bean之前修改bean的定义。常用于修改bean属性或改变bean的作用域。</li>
<li>BeanPostProcessor：可以在bean实例化、配置以及初始化之后对其进行额外处理。常用于代理bean、修改bean属性等。</li>
<li>PropertySource：用于定义不同的属性源，如文件、数据库等，以便在Spring应用中使用。</li>
<li>ImportSelector和ImportBeanDefinitionRegistrar：用于根据条件动态注册bean定义，实现配置类的模块化。</li>
<li>Spring MVC中的HandlerInterceptor：用于拦截处理请求，可以在请求处理前、处理中和处理后执行特定逻辑。</li>
<li>Spring MVC中的ControllerAdvice：用于全局处理控制器的异常、数据绑定和数据校验。</li>
<li>Spring Boot的自动配置：通过创建自定义的自动配置类，可以实现对框架和第三方库的自动配置。</li>
<li>自定义注解：创建自定义注解，用于实现特定功能或约定，如权限控制、日志记录等。</li>
</ol>
<h2 id="9-Spring-框架中，Bean-的作用域有哪些？请分别说明它们的生命周期和应用场景">9.Spring 框架中，Bean 的作用域有哪些？请分别说明它们的生命周期和应用场景</h2>
<p><strong>5 大标准作用域</strong>：</p>
<ul>
<li><strong>Singleton</strong>：全局唯一实例，Spring 容器加载时创建，适用于无状态服务；</li>
<li><strong>Prototype</strong>：每次获取新实例，适用于有状态对象（如 DAO 层）；</li>
<li><strong>Request</strong>：每次 HTTP 请求一个实例，需 Web 环境，适用于请求上下文数据；</li>
<li><strong>Session</strong>：每个用户会话一个实例，需 Web 环境，适用于会话级数据；</li>
<li><strong>Application</strong>：全局 ServletContext 共享实例，需 Web 环境。</li>
</ul>
<p>生命周期：实例化→属性注入→@PostConstruct→初始化完成→使用→@PreDestroy→销毁。</p>
<p>循环依赖：setter单例注入，三级缓存，</p>
<ul>
<li>一级缓存（singletonObjects）：存储完全初始化的单例 Bean；</li>
<li>二级缓存（earlySingletonObjects）：存储早期曝光的 Bean（解决 A→B→A 的循环依赖）；</li>
<li>三级缓存（singletonFactories）：存储 Bean 的工厂，用于生成代理对象（解决 A→B（代理）→A 的循环依赖）。</li>
</ul>
<h2 id="10-BeanFactory-和-FactoryBean-的区别">10.<code>BeanFactory</code> 和 <code>FactoryBean</code> 的区别</h2>
<p><code>BeanFactory</code> 是 Spring 容器本身，负责管理所有 Bean；<br>
<code>FactoryBean</code> 是你自己定义的 Bean，用来创建其他 Bean。</p>
<table>
<thead>
<tr>
<th>对比点</th>
<th><code>BeanFactory</code></th>
<th><code>FactoryBean</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>接口（Spring 顶层 IOC 容器）</td>
<td>接口（自定义 Bean 的工厂）</td>
</tr>
<tr>
<td>位置</td>
<td>Spring 框架提供</td>
<td>用户自定义实现</td>
</tr>
<tr>
<td>作用</td>
<td>提供获取 Bean 的基础功能，如 <code>getBean()</code></td>
<td>用于控制某个复杂 Bean 的创建逻辑</td>
</tr>
<tr>
<td>返回对象</td>
<td>返回注册的原始 Bean 实例</td>
<td>返回由 <code>getObject()</code> 方法创建的对象</td>
</tr>
<tr>
<td>示例用途</td>
<td>XML 加载、懒加载场景用到</td>
<td>MyBatis 中用于创建 Mapper 接口代理</td>
</tr>
<tr>
<td>典型实现类</td>
<td><code>DefaultListableBeanFactory</code></td>
<td>用户自定义，如 <code>MyCarFactoryBean</code></td>
</tr>
</tbody>
</table>
<p>1️⃣ <code>BeanFactory</code> 示例（Spring 提供）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory factory = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">UserService userService = factory.getBean(&quot;userService&quot;, UserService.class);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BeanFactory</code> 就是容器，负责“拿 Bean”。</li>
<li>常用于早期的 XML 配置方式。</li>
</ul>
<p><code>FactoryBean</code> 示例（用户自定义）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCarFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Car&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 返回一个自定义创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>, <span class="number">2025</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Car car; <span class="comment">// 实际注入的是 MyCarFactoryBean.getObject() 返回的 Car 实例</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Spring 启动时会识别 <code>MyCarFactoryBean</code>，但注入时拿的是 <code>getObject()</code> 的返回值；</li>
<li>如果你想拿到 <code>FactoryBean</code> 本身，可以用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CarFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> (CarFactoryBean) context.getBean(<span class="string">&quot;&amp;carFactoryBean&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>beanFactory</code> 是 Spring 的底层 IOC 容器接口，提供了 Bean 的获取、懒加载等功能。<br>
<code>FactoryBean</code> 是一个用于创建 Bean 的“工厂类”，由我们<strong>自定义创建逻辑</strong>，它本身是一个 Bean，但它返回的对象是 <code>getObject()</code> 产生的。<br>
例如：MyBatis 就是通过 FactoryBean 动态创建 Mapper 接口代理对象。</p>
<h1>MVC</h1>
<h2 id="1-MVC分层介绍一下">1.MVC分层介绍一下</h2>
<p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p>
<ul>
<li><strong>视图(view)： 为用户提供使用界面，与用户直接进行交互。</strong></li>
<li><strong>模型(model)： 代表一个存取数据的对象或 JAVA POJO（Plain Old Java Object，简单java对象）。它也可以带有逻辑，主要用于承载数据，并对用户提交请求进行计算的模块。模型分为两类，一类称为数据承载 Bean，一类称为业务处理Bean。所谓数据承载 Bean 是指实体类（如：User类），专门为用户承载业务数据的；而业务处理 Bean 则是指Service 或 Dao 对象， 专门用于处理用户提交请求的。</strong></li>
<li><strong>控制器(controller)： 用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。它使视图与模型分离。</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1713944902120-e35c2b4f-e290-4973-aa1a-3193af3bb371.png" alt="img"></p>
<p>流程步骤：</p>
<ol>
<li><strong>用户通过View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等；</strong></li>
<li><strong>服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的Model，对用户请求进行处理Model 处理；</strong></li>
<li><strong>将处理结果再交给 Controller（控制器其实只是起到了承上启下的作用）；</strong></li>
<li><strong>根据处理结果找到要作为向客户端发回的响应View 页面，页面经渲染后发送给客户端。</strong></li>
</ol>
<p>view-&gt;model-&gt;controller</p>
<h2 id="2-了解SpringMVC的处理流程吗？">2.了解SpringMVC的处理流程吗？</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1716791047520-ac0d9673-be0a-4005-8732-30bdedc8f1af.webp" alt="img"></p>
<p>Spring MVC的工作流程如下：</p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li>
<li>执行处理器Handler(Controller，也叫页面控制器)。</li>
<li>Handler执行完成返回ModelAndView</li>
<li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<p>请求-&gt;前端控制器-&gt;mapping-&gt;返回执行链给前端控制器-&gt;请求处理器适配器-&gt;controller-&gt;返回modelview-&gt;前端控制器给传输给视图解析器，解析完返回给前端控制器-&gt;渲染一下到request域-&gt;形成view</p>
<p>SpringMVC 的执行流程如下。</p>
<ol>
<li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li>
<li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。</li>
<li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li>
<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li>
<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li>
<li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li>
<li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li>
<li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li>
<li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li>
<li>视图负责将结果显示到浏览器（客户端）。</li>
</ol>
<h2 id="3-Handlermapping-和-handleradapter有了解吗？">3.Handlermapping 和 handleradapter有了解吗？</h2>
<p>HandlerMapping：</p>
<ul>
<li><strong>作用</strong>：HandlerMapping<strong>负责将请求映射到处理器</strong>（Controller）。</li>
<li><strong>功能</strong>：根据请求的URL、请求参数等信息，找到处理请求的 Controller。</li>
<li><strong>类型</strong>：Spring提供了多种HandlerMapping实现，如BeanNameUrlHandlerMapping、RequestMappingHandlerMapping等。</li>
<li><strong>工作流程</strong>：根据请求信息确定要请求的处理器(Controller)。HandlerMapping可以根据URL、请求参数等规则确定对应的处理器。</li>
</ul>
<p>HandlerAdapter：</p>
<ul>
<li><strong>作用</strong>：HandlerAdapter负责<strong>调用处理器(Controller)来处理请求</strong>。</li>
<li><strong>功能</strong>：处理器(Controller)可能有不同的接口类型（Controller接口、HttpRequestHandler接口等），HandlerAdapter根据处理器的类型来选择合适的方法来调用处理器。</li>
<li><strong>类型</strong>：Spring提供了多个HandlerAdapter实现，用于适配不同类型的处理器。</li>
<li><strong>工作流程</strong>：根据处理器的接口类型，选择相应的HandlerAdapter来调用处理器。</li>
</ul>
<p>工作流程：</p>
<ol>
<li>当客户端发送请求时，HandlerMapping根据请求信息找<strong>到对应的处理器</strong>(Controller)。</li>
<li>HandlerAdapter根据<strong>处理器的类型选择合适的方法来调用处理器。</strong></li>
<li>处理器执行相应的业务逻辑，生成ModelAndView。</li>
<li>HandlerAdapter将处理器的执行结果包装成ModelAndView。</li>
<li>视图解析器根据ModelAndView找到对应的视图进行渲染。</li>
<li>将渲染后的视图返回给客户端。</li>
</ol>
<p>HandlerMapping和HandlerAdapter协同工作，通过将请求映射到处理器，并调用处理器来处理请求，实现了请求处理的流程。它们的灵活性使得在Spring MVC中可以支持多种处理器和处理方式，提高了框架的扩展性和适应性。</p>
<h1>Springboot</h1>
<h2 id="1-为什么使用springboot">1.为什么使用springboot</h2>
<ul>
<li>简化开发：Spring Boot通过提供一系列的<strong>开箱即用的组件和自动配置</strong>，简化了项目的配置和开发过程，开发人员可以更专注于业务逻辑的实现，而不需要花费过多时间在繁琐的配置上。</li>
<li>快速启动：Spring Boot提供了快速的应用程序启动方式，<strong>可通过内嵌的Tomcat、Jetty或Undertow等容器快速启动应用程序</strong>，无需额外的部署步骤，方便快捷。</li>
<li>自动化配置：Spring Boot通过自动配置功能，根据<strong>项目中的依赖关系和约定俗成的规则来配置应用程序</strong>，减少了配置的复杂性，使开发者更容易实现应用的最佳实践。</li>
</ul>
<h2 id="2-SpringBoot比Spring好在哪里">2.SpringBoot比Spring好在哪里</h2>
<ul>
<li>Spring Boot 提供了自动化配置，大大简化了项目的配置过程。通过约定优于配置的原则，很多常用的配置可以自动完成，开发者可以专注于业务逻辑的实现。</li>
<li>Spring Boot 提供了快速的项目启动器，通过<strong>引入不同的 Starter，可以快速集成常用的框架和库（如数据库、消息队列、Web 开发等）</strong>，极大地提高了开发效率。</li>
<li>Spring Boot 默认集成了<strong>多种内嵌服务器（如Tomcat、Jetty、Undertow）</strong>，无需额外配置，即可将应用打包成可执行的 JAR 文件，方便部署和运行。</li>
</ul>
<h2 id="3-SpringBoot用到哪些设计模式？">3.SpringBoot用到哪些设计模式？</h2>
<ul>
<li><strong>代理模式</strong>：Spring 的 AOP 通过动态代理实现方法级别的切面增强，有静态和动态两种代理方式，采用动态代理方式。</li>
<li><strong>策略模式</strong>：Spring AOP 支持 JDK 和 Cglib 两种动态代理实现方式，通过策略接口和不同策略类，运行时动态选择，其创建一般通过工厂方法实现。</li>
<li><strong>装饰器模式</strong>：Spring 用 TransactionAwareCacheDecorator 解决缓存与数据库事务问题增加对事务的支持。</li>
<li><strong>单例模式</strong>：Spring Bean <strong>默认是单例模式</strong>，通过单例注册表（如 HashMap）实现。</li>
<li><strong>简单工厂模式</strong>：Spring 中的 BeanFactory 是简单工厂模式的体现，通过工厂类方法获取 Bean 实例。</li>
<li><strong>工厂方法模式</strong>：Spring中的 FactoryBean 体现工厂方法模式，为不同产品提供不同工厂。</li>
<li><strong>观察者模式</strong>：Spring 观察者模式包含 <strong>Event 事件、Listener 监听者、Publisher 发送者</strong>，通过定义事件、监听器和发送者实现，观察者注册在 <strong>ApplicationContext 中，消息发送由 ApplicationEventMulticaster 完成。</strong></li>
<li><strong>模板模式</strong>：Spring Bean 的创建过程涉及模板模式，体现扩展性，类似 Callback 回调实现方式。</li>
<li><strong>适配器模式</strong>：Spring MVC 中针对不同方式定义的 Controller，利用适配器模式统一函数定义，定义了统一接口 HandlerAdapter 及对应适配器类。</li>
</ul>
<h2 id="4-怎么理解SpringBoot中的约定大于配置">4.怎么理解SpringBoot中的约定大于配置</h2>
<p>约定大于配置是Spring Boot的核心设计理念，它通过<strong>预设合理的默认行为和项目规范</strong>，大幅减少开发者需要手动配置的步骤，从而提升开发效率和项目标准化程度。</p>
<p>理解 Spring Boot 中的“约定大于配置”原则，可以从以下几个方面来解释：</p>
<ul>
<li><strong>自动化配置</strong>：Spring Boot 提供了<strong>大量的自动化配置</strong>，通过分析项目的依赖和环境，自动配置应用程序的行为。开发者无需显式地配置每个细节，大部分常用的配置都已经预设好了。例如，引入<code>spring-boot-starter-web</code>后，Spring Boot会自动配置内嵌Tomcat和Spring MVC，无需手动编写XML。</li>
<li><strong>默认配置</strong>：Spring Boot 为诸多方面提供<strong>大量默认配置</strong>，如连接数据库、设置 Web 服务器、处理日志等。开发人员无需手动配置这些常见内容，框架已做好决策。例如，默认的日志配置可让应用程序快速输出日志信息，无需开发者额外繁琐配置日志级别、输出格式与位置等。</li>
<li><strong>约定的项目结构</strong>：Spring Boot 提倡<strong>特定项目结</strong>构，通常主应用程序类（含 main 方法）置于根包，控制器类、服务类、数据访问类等分别放在相应子包，如<code>com.example.demo.controller</code>放控制器类，<code>com.example.demo.service</code>放服务类等。此约定使团队成员更易理解项目结构与组织，新成员加入项目时能快速定位各功能代码位置，提升协作效率。</li>
</ul>
<h2 id="5-SpringBoot的项目结构是怎么样的？">5.SpringBoot的项目结构是怎么样的？</h2>
<p>一个正常的企业项目里一种通用的项目结构和代码层级划分的指导意见。按这《阿里巴巴Java开发手册》时本书上说的，一般分为如下几层：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1721712085278-f25ffdd1-26bc-4a7c-928a-42e48501b285.png" alt="img"></p>
<ul>
<li>开放接口层：可直接<strong>封装 Service 接口暴露成 RPC 接口</strong>；通过 Web 封装成 http 接口；网关控制层等。</li>
<li>终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li>
<li>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li>
<li>Service 层：相对具体的业务逻辑服务层。</li>
<li>Manager 层：通用业务处理层，它有如下特征：
<ul>
<li>1）对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。</li>
<li>2）对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</li>
<li>3）与 DAO 层交互，对多个 DAO 的组合复用。</li>
</ul>
</li>
<li>DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase、OceanBase 等进行数据交互。</li>
<li>第三方服务：包括其它部门 RPC 服务接口，基础平台，其它公司的 HTTP 接口，如淘宝开放平台、支付宝付款服务、高德地图服务等。</li>
<li>外部接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。</li>
</ul>
<p>如果从一个用户访问一个网站的情况来看，对应着上面的项目代码结构来分析，可以贯穿整个代码分层：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1721712159282-79195670-9acf-4bfb-93b1-47d089a4bc1c.png" alt="img"></p>
<p>对应代码目录的流转逻辑就是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1721712166152-4774fdac-cb1e-4fb1-929e-3ae130145aa8.png" alt="img"></p>
<p>所以，以后每当我们拿到一个新的项目到手时，只要按照这个思路去看别人项目的代码，应该基本都是能理得顺的</p>
<h2 id="6-SpringBoot自动装配原理是什么？">6.SpringBoot自动装配原理是什么？</h2>
<blockquote>
<p>什么是自动装配？</p>
</blockquote>
<p>SpringBoot 的自动装配原理是**基于Spring Framework的条件化配置和@EnableAutoConfiguration注解实现的。**这种机制允许开发者在项目中引入相关的依赖，SpringBoot 将根据这些依赖自动配置应用程序的上下文和功能。</p>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
<p>通俗来讲，<strong>自动装配就是通过注解或一些简单的配置就可以在SpringBoot的帮助下开启和配置各种功能，比如数据库访问、Web开发。</strong></p>
<blockquote>
<p>SpringBoot自动装配原理</p>
</blockquote>
<p>首先点进 <code>@SpringBootApplication</code> 注解的内部</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719493065090-4ce24f82-8f39-4aa6-b399-671e68e9c18f.png" alt="img"></p>
<p>接下来将逐个解释这些注解的作用：</p>
<ul>
<li><code>@Target(&#123;ElementType.TYPE&#125;)</code>: 该注解指定了这个注解可以用来标记在类上。在这个特定的例子中，这表示该注解用于标记配置类。</li>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 这个注解指定了注解的生命周期，即在运行时保留。这是因为 Spring Boot 在运行时扫描类路径上的注解来实现自动配置，所以这里使用了 RUNTIME 保留策略。</li>
<li><code>@Documented</code>: 该注解表示这个注解应该被包含在 Java 文档中。它是用于生成文档的标记，使开发者能够看到这个注解的相关信息。</li>
<li><code>@Inherited</code>: 这个注解指示一个被标注的类型是被继承的。在这个例子中，它表明这个注解可以被继承，如果一个类继承了带有这个注解的类，它也会继承这个注解。</li>
<li><code>@SpringBootConfiguration</code>: 这个注解表明这是一个 Spring Boot 配置类。如果点进这个注解内部会发现与标准的 @Configuration 没啥区别，只是为了表明这是一个专门用于 SpringBoot 的配置。</li>
<li><code>@EnableAutoConfiguration</code>: 这个注解是 Spring Boot 自动装配的核心。它告诉 Spring oot 启用自动配置机制，根据项目的依赖和配置自动配置应用程序的上下文。通过这个注解，SpringBoot 将尝试根据类路径上的依赖自动配置应用程序。</li>
<li><code>@ComponentScan</code>: 这个注解用于配置组件扫描的规则。在这里，它告诉 SpringBoot 在指定的包及其子包中查找组件，这些组件包括被注解的类、@Component 注解的类等。其中的 excludeFilters 参数用于指定排除哪些组件，这里使用了两个自定义的过滤器，分别是 TypeExcludeFilter 和 AutoConfigurationExcludeFilter。</li>
</ul>
<p><strong><code>@EnableAutoConfiguration</code> 这个注解是实现自动装配的核心注解</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719495511568-bc5f9e21-9e2c-4888-91a8-4048058ff408.png" alt="img"></p>
<ul>
<li>@AutoConfigurationPackage，将项目src中main包下的所有组件注册到容器中，例如标注了Component注解的类等</li>
<li>@Import({AutoConfigurationImportSelector.class})，<strong>是自动装配的核心，接下来分析一下这个注解</strong></li>
</ul>
<p>AutoConfigurationImportSelector 是 Spring Boot 中一个重要的类，它实现了 ImportSelector 接口，用于实现自动配置的选择和导入。具体来说，它通过分析项目的类路径和条件来决定应该导入哪些自动配置类。</p>
<p>代码太多，选取部分主要功能的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... （其他方法和属性）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有符合条件的类的全限定类名，例如RedisTemplate的全限定类名(org.springframework.data.redis.core.RedisTemplate;)，这些类需要被加载到 IoC 容器中。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		<span class="comment">// 扫描类路径上的 META-INF/spring.factories 文件，获取所有实现了 AutoConfiguration 接口的自动配置类</span></span><br><span class="line">		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 过滤掉不满足条件的自动配置类，比如一些自动装配类</span></span><br><span class="line">		configurations = filter(configurations, annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 排序自动配置类，根据 @AutoConfigureOrder 和 @AutoConfigureAfter/@AutoConfigureBefore 注解指定的顺序</span></span><br><span class="line">		sort(configurations, annotationMetadata, attributes);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将满足条件的自动配置类的类名数组返回，这些类将被导入到应用程序上下文中</span></span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... （其他方法）</span></span><br><span class="line">	<span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取自动配置类的候选列表，从 META-INF/spring.factories 文件中读取</span></span><br><span class="line">		<span class="comment">// 通过类加载器加载所有候选类</span></span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 过滤出实现了 AutoConfiguration 接口的自动配置类</span></span><br><span class="line">		configurations = configurations.stream()</span><br><span class="line">				.filter(<span class="built_in">this</span>::isEnabled)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对于 Spring Boot 1.x 版本，还需要添加 spring-boot-autoconfigure 包中的自动配置类</span></span><br><span class="line">		<span class="comment">// configurations.addAll(getAutoConfigEntry(getAutoConfigurationEntry(metadata)));</span></span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... （其他方法）</span></span><br><span class="line">	<span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">filter</span><span class="params">(List&lt;String&gt; configurations, AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">			AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">		<span class="comment">// 使用条件判断机制，过滤掉不满足条件的自动配置类</span></span><br><span class="line">		configurations = configurations.stream()</span><br><span class="line">				.filter(configuration -&gt; isConfigurationCandidate(configuration, metadata, attributes))</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... （其他方法）</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;String&gt; configurations, AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">			AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">		<span class="comment">// 根据 @AutoConfigureOrder 和 @AutoConfigureAfter/@AutoConfigureBefore 注解指定的顺序对自动配置类进行排序</span></span><br><span class="line">		configurations.sort((o1, o2) -&gt; &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> getAutoConfigurationOrder(o1, metadata, attributes);</span><br><span class="line">			<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> getAutoConfigurationOrder(o2, metadata, attributes);</span><br><span class="line">			<span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// ... （其他方法）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>梳理一下，以下是<code>AutoConfigurationImportSelector</code>的主要工作：</p>
<ul>
<li>扫描类路径: 在应用程序启动时，<code>AutoConfigurationImportSelector</code> 会扫描类路径上的 <code>META-INF/spring.factories</code> 文件，这个文件中包含了各种 Spring 配置和扩展的定义。在这里，它会查找所有实现了 <code>AutoConfiguration</code> 接口的类,具体的实现为<code>getCandidateConfigurations</code>方法。</li>
<li>条件判断: 对于每一个发现的自动配置类，<code>AutoConfigurationImportSelector</code> 会使用条件判断机制（通常是通过 <code>@ConditionalOnXxx</code>注解）来确定是否满足导入条件。这些条件可以是配置属性、类是否存在、Bean是否存在等等。</li>
<li>根据条件导入自动配置类: 满足条件的自动配置类将被导入到应用程序的上下文中。这意味着它们会被实例化并应用于应用程序的配置。</li>
</ul>
<p>SpringBoot自动配置通过@EnableAutoConfiguration触发，利用AutoConfigurationImportSelector**扫描META-INF/spring.factories中的配置类。**配置类基于@Conditional条件注解（如类路径存在性、Bean缺失等）选择性生效，<strong>自动创建所需Bean。该机制通过条件判断和SPI扩展实现零XML配置，简化环境适配与组件装配过程。</strong></p>
<h2 id="7-说几个启动器（starter-？">7.说几个启动器（starter)？</h2>
<ul>
<li><strong>spring-boot-starter-web</strong>：这是最常用的起步依赖之一，它包含了Spring MVC和Tomcat嵌入式服务器，用于快速构建Web应用程序。</li>
<li><strong>spring-boot-starter-security</strong>：提供了<strong>Spring Security</strong>的基本配置，帮助开发者快速实现应用的安全性，包括认证和授权功能。</li>
<li><strong>mybatis-spring-boot-starter</strong>：这个Starter是由MyBatis团队提供的，用于简化在Spring Boot应用中集成MyBatis的过程。它自动配置了MyBatis的相关组件，包括SqlSessionFactory、MapperScannerConfigurer等，使得开发者能够快速地开始使用MyBatis进行数据库操作。</li>
<li><strong>spring-boot-starter-data-jpa</strong> 或 <strong>spring-boot-starter-jdbc</strong>：如果使用的是Java Persistence API (JPA)进行数据库操作，那么应该使用spring-boot-starter-data-jpa。这个Starter包含了Hibernate等JPA实现以及数据库连接池等必要的库，可以让你轻松地与MySQL数据库进行交互。你需要在application.properties或application.yml中配置MySQL的连接信息。如果倾向于直接使用JDBC而不通过JPA，那么可以使用spring-boot-starter-jdbc，它提供了基本的JDBC支持。</li>
<li><strong>spring-boot-starter-data-redis</strong>：用于集成Redis缓存和数据存储服务。这个Starter包含了与Redis交互所需的客户端（默认是Jedis客户端，也可以配置为Lettuce客户端），以及Spring Data Redis的支持，使得在Spring Boot应用中使用Redis变得非常便捷。同样地，需要在配置文件中设置Redis服务器的连接详情。</li>
<li><strong>spring-boot-starter-test</strong>：包含了单元测试和集成测试所需的库，如JUnit, Spring Test, AssertJ等，便于进行测试驱动开发(TDD)。</li>
</ul>
<h2 id="8-写过SpringBoot-starter吗">8.写过SpringBoot starter吗?</h2>
<blockquote>
<p>步骤1: 创建Maven项目</p>
</blockquote>
<p>首先，需要创建一个新的Maven项目。在pom.xml中添加Spring Boot的starter parent和一些必要的依赖。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.7</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>步骤2: 添加自动配置</p>
</blockquote>
<p><strong>在src/main/resources/META-INF/spring.factories中添加自动配置的元数据</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration = com.example.starter.MyAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>然后，<strong>创建MyAutoConfiguration类，该类需要@Configuration和@EnableConfigurationProperties注解</strong>。@EnableConfigurationProperties用于启用你定义的配置属性类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>(properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>步骤3: 创建配置属性类</p>
</blockquote>
<p>创建一个配置属性类，使用@ConfigurationProperties注解来绑定配置文件中的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>步骤4: 创建服务和控制器</p>
</blockquote>
<p>创建一个服务类和服务实现类，以及一个控制器来展示你的starter的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyServiceImpl</span><span class="params">(MyProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyController</span><span class="params">(MyService myService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myService = myService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/name&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myService.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>步骤5: 发布Starter</p>
</blockquote>
<p>将你的starter发布到Maven仓库，无论是私有的还是公共的，如Nexus或Maven Central。</p>
<blockquote>
<p>步骤6: 使用Starter</p>
</blockquote>
<p>在你的主应用的pom.xml中添加你的starter依赖，<strong>然后在application.yml或application.properties中配置你的属性。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my:</span><br><span class="line">    name: Hello World</span><br></pre></td></tr></table></figure>
<h2 id="9-SpringBoot里面有哪些重要的注解？还有一个配置相关的注解是哪个？">9.SpringBoot里面有哪些重要的注解？还有一个配置相关的注解是哪个？</h2>
<p>Spring Boot 中一些常用的注解包括：</p>
<ul>
<li><strong>@SpringBootApplication</strong>：用于标注主应用程序类，标识一个Spring Boot应用程序的入口点，同时启用自动配置和组件扫描。</li>
<li><strong>@Controller</strong>：标识控制器类，处理HTTP请求。</li>
<li><strong>@RestController</strong>：结合@Controller和@ResponseBody，返回RESTful风格的数据。</li>
<li><strong>@Service</strong>：标识服务类，通常用于标记业务逻辑层。</li>
<li><strong>@Repository</strong>：标识数据访问组件，通常用于标记数据访问层。</li>
<li><strong>@Component</strong>：通用的Spring组件注解，表示一个受Spring管理的组件。</li>
<li><strong>@Autowired</strong>：用于自动装配Spring Bean。</li>
<li><strong>@Value</strong>：用于注入配置属性值。</li>
<li><strong>@RequestMapping</strong>：用于映射HTTP请求路径到Controller的处理方法。</li>
<li><strong>@GetMapping</strong>、@PostMapping、@PutMapping、@DeleteMapping：简化@RequestMapping的GET、POST、PUT和DELETE请求。</li>
</ul>
<p>另外，一个与配置相关的重要注解是：</p>
<ul>
<li><strong>@Configuration</strong>：用于指定一个类为配置类，其中定义的bean会被Spring容器管理。<strong>通常与@Bean配合使用，@Bean用于声明一个Bean实例，由Spring容器进行管理。</strong></li>
</ul>
<p>其中最重要得注解是**@SpringBootApplication**，他是用于标注主应用程序，开启自动配置，具体是内部的</p>
<p>@EnablAutoConfiguration注解实现的自动配置，在springboot启动的时候开启自动配置，主要是基于项目classpath中引入的类和已定义的bean来实现的。@Import:@EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。@Congiguration：配置类注解，根据一些特定条件来控制bean的实例化的行为。 @ComponentScan：位置在SpringBoot的启动类上，Spring包扫描。</p>
<h2 id="10-springboot怎么开启事务？">10.springboot怎么开启事务？</h2>
<p>在 Spring Boot 中开启事务非常简单，只需在服务层的方法上添加 <code>@Transactional</code> 注解即可。</p>
<p>例如，假设我们有一个 UserService 接口，其中有一个保存用户的方法 saveUser()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望在这个方法中开启事务，只需在该方法上添加 <code>@Transactional</code> 注解，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当调用 saveUser() 方法时，Spring 就会自动为该方法开启一个事务。<strong>如果方法执行成功，事务会自动提交；如果方法执行失败，事务会自动回滚。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="11-Springboot怎么做到导入就可以直接使用的？">11.Springboot怎么做到导入就可以直接使用的？</h2>
<p>这个主要依赖于自动配置、起步依赖和条件注解等特性。</p>
<blockquote>
<p>起步依赖</p>
</blockquote>
<p>起步依赖是一种特殊的 Maven 或 Gradle 依赖，它将<strong>项目所需的一系列依赖打包在一起。例如，<code>spring-boot-starter-web</code> 这个起步依赖就包含了 Spring Web MVC、Tomcat 等构建 Web 应用所需的核心依赖。</strong></p>
<p>开发者只需在项目中添加一个起步依赖，Maven 或 Gradle 就会自动下载并管理与之关联的所有依赖，避免了手动添加大量依赖的繁琐过程。</p>
<p>比如，在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-web</code> 依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动配置</p>
</blockquote>
<p>Spring Boot 的自动配置机制会根据类路径下的依赖和开发者的配置，自动创建和配置应用所需的 Bean。<strong>它通过 <code>@EnableAutoConfiguration</code> 注解启用</strong>，<strong>该注解会触发 Spring Boot 去查找 <code>META - INF/spring.factories</code> 文件。</strong></p>
<p><code>spring.factories</code> 文件中定义了一系列自动配置类，Spring Boot 会根据当前项目的依赖情况，选择合适的自动配置类进行加载。例如，如果项目中包含 <code>spring-boot-starter-web</code> 依赖，Spring Boot 会加载 <code>WebMvcAutoConfiguration</code> 类，该类会自动配置 Spring MVC 的相关组件，如 DispatcherServlet、视图解析器等。</p>
<p>开发者可以通过自定义配置来覆盖自动配置的默认行为。如果开发者在 <code>application.properties</code> 或 <code>application.yml</code> 中定义了特定的配置，或者在代码中定义了同名的 Bean，Spring Boot 会优先使用开发者的配置。</p>
<blockquote>
<p>条件注解</p>
</blockquote>
<p>条件注解用于控制 Bean 的创建和加载，只有在满足特定条件时，才会创建相应的 Bean。Spring Boot 的自动配置类中广泛使用了条件注解，<strong>如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等。</strong></p>
<p>比如，<code>@ConditionalOnClass</code> 表示只有当类路径中存在指定的类时，才会创建该 Bean。例如，在 <code>WebMvcAutoConfiguration</code> 类中，可能会有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 配置相关的 Bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码表示只有当类路径中存在 <code>Servlet</code>、<code>DispatcherServlet</code> 和 <code>WebMvcConfigurer</code> 类时，才会加载 <code>WebMvcAutoConfiguration</code> 类中的配置。</p>
<h2 id="12-SpringBoot-过滤器和拦截器说一下？">12.SpringBoot 过滤器和拦截器说一下？</h2>
<p>在 Spring Boot 中，过滤器（Filter）和拦截器（Interceptor）是用于处理请求和响应的两种不同机制。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>过滤器（Filter）</strong></th>
<th><strong>拦截器（Interceptor）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>规范/框架</strong></td>
<td>Servlet规范（<code>javax.servlet.Filter</code>）</td>
<td>Spring MVC框架（<code>org.springframework.web.servlet.HandlerInterceptor</code>）</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>全局（所有请求、静态资源）</td>
<td>Controller层（仅拦截Spring管理的请求）</td>
</tr>
<tr>
<td><strong>执行顺序</strong></td>
<td>在Servlet之前执行</td>
<td>在DispatcherServlet之后、Controller方法前后执行</td>
</tr>
<tr>
<td><strong>依赖注入支持</strong></td>
<td>无法直接注入Spring Bean（需间接获取）</td>
<td>支持自动注入Spring Bean</td>
</tr>
<tr>
<td><strong>触发时机</strong></td>
<td><code>doFilter()</code>在请求前/响应后被调用</td>
<td><code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>分阶段触发</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>全局请求处理（编码、日志、安全）</td>
<td>业务逻辑相关的处理（权限、参数校验）</td>
</tr>
</tbody>
</table>
<p>过滤器是 Java Servlet 规范中的一部分，**它可以对进入 Servlet 容器的请求和响应进行预处理和后处理。过滤器通过实现 <code>javax.servlet.Filter</code> 接口，并重写其中的 <code>init</code>、<code>doFilter</code> 和 <code>destroy</code> 方法来完成相应的逻辑。**当请求进入 Servlet 容器时，会按照配置的顺序依次经过各个过滤器，然后再到达目标 Servlet 或控制器；响应返回时，也会按照相反的顺序再次经过这些过滤器。</p>
<p>拦截器是 Spring 框架提供的一种机制，它可以对控制器方法的执行进行拦截。**拦截器通过实现 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口，并重写其中的 <code>preHandle</code>、<code>postHandle</code> 和 <code>afterCompletion</code> 方法来完成相应的逻辑。**当请求到达控制器时，会先经过拦截器的 <code>preHandle</code> 方法，如果该方法返回 <code>true</code>，则继续执行后续的控制器方法和其他拦截器；在控制器方法执行完成后，会调用拦截器的 <code>postHandle</code> 方法；最后，在请求处理完成后，会调用拦截器的 <code>afterCompletion</code> 方法。</p>
<p>过滤器和拦截器的区别如下：</p>
<ul>
<li><strong>所属规范</strong>：过滤器是 Java Servlet 规范的一部分，而拦截器是 Spring 框架提供的机制。</li>
<li><strong>执行顺序</strong>：过滤器在请求进入 Servlet 容器后，在到达目标 Servlet 或控制器之前执行；拦截器在请求到达控制器之后，在控制器方法执行前后执行。</li>
<li><strong>使用范围</strong>：过滤器可以对所有类型的请求进行过滤，包括静态资源请求；拦截器只能对 Spring MVC 控制器的请求进行拦截。</li>
<li><strong>功能特性</strong>：过滤器主要用于对请求和响应进行预处理和后处理，如字符编码处理、请求日志记录等；拦截器可以更细粒度地控制控制器方法的执行，如权限验证、性能监控等。</li>
</ul>
<h2 id="13-说说Spring-Boot的启动流程。">13.说说Spring Boot的启动流程。</h2>
<p>SpringBoot将日常企业应用研发中的各种常见都抽取出来，做成一个个的**starter（**启动器），starter中整合了该场景下各种可能用到的依赖，<strong>用户只需要在Maven中引入starter依赖，SpringBoot就能自动扫描到要加载的信息并启动相应的默认配置。<strong>starter提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰。所有这些starter都遵循这</strong>约定俗成的默认配置</strong>，并允许用户调整这些配置，即遵循“<strong>约定大于配置</strong>”的原子</p>
<h2 id="14-Autowied和-Resource">14.@Autowied和@Resource</h2>
<p>@Autowied是Spring提供的注解，@Resource是JDK提供的注解。@Autowied是<strong>只能按类型注入</strong>，@Resource<strong>默认按名称注入，也支持按类型注入</strong>。@Autowired按类型装配依赖对象,默认情况下它要求<strong>依赖对象必须存在,如果允许null值,可以设置它required属性为false,<strong>如果我们想使用按名称装配,可以结合</strong>@Qualifier</strong>注解一起使用</p>
<h1>Mybatis</h1>
<h2 id="1-与传统的JDBC相比，MyBatis的优点？">1.与传统的JDBC相比，MyBatis的优点？</h2>
<ul>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>
<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；</li>
<li>很好的与各种数据库兼容，因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持。</li>
<li>能够与 Spring 很好的集成，开发效率高</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。</li>
</ul>
<h2 id="2-MyBatis觉得在哪方面做的比较好？">2.MyBatis觉得在哪方面做的比较好？</h2>
<p>MyBatis 在 <strong>SQL 灵活性</strong>、<strong>动态 SQL 支持</strong>、<strong>结果集映射</strong>和<strong>与 Spring 整合</strong>方面表现卓越，尤其适合重视 SQL 可控性的项目。</p>
<ul>
<li>SQL 与代码解耦，灵活可控：<strong>MyBatis 允许开发者直接编写和优化 SQL</strong>，相比全自动 ORM（如 Hibernate），MyBatis 让开发者明确知道每条 SQL 的执行逻辑，便于性能调优。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 示例：XML 中定义 SQL --&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;findUserWithRole&quot;</span> resultMap=<span class="string">&quot;userRoleMap&quot;</span>&gt;</span><br><span class="line">    SELECT u.*, r.role_name </span><br><span class="line">    FROM user u </span><br><span class="line">    LEFT JOIN user_role ur ON u.id = ur.user_id</span><br><span class="line">    LEFT JOIN role r ON ur.role_id = r.id </span><br><span class="line">    WHERE u.id = #&#123;userId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态 SQL 的强大支持：比如可以动态拼接SQL，通过 <code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code>, <code>&lt;foreach&gt;</code> 等标签动态生成 SQL，避免 Java 代码中繁琐的字符串拼接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;searchUsers&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;name != null&quot;</span>&gt;AND name LIKE #&#123;name&#125;&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;status != null&quot;</span>&gt;<span class="type">AND</span> <span class="variable">status</span> <span class="operator">=</span> #&#123;status&#125;&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动映射与自定义映射结合：自动将查询结果字段名与对象属性名匹配（如驼峰转换）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;userRoleMap&quot;</span> type=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;user_id&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;user_name&quot;</span>/&gt;</span><br><span class="line">    &lt;collection property=<span class="string">&quot;roles&quot;</span> ofType=<span class="string">&quot;Role&quot;</span>&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;roleName&quot;</span> column=<span class="string">&quot;role_name&quot;</span>/&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>插件扩展机制：可编写<strong>插件拦截 SQL 执行过程，实现分页、性能监控、SQL 改写等通用逻辑。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">    @Signature(type=Executor.class, method=&quot;query&quot;, args=&#123;...&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaginationPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 实现分页逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与 Spring 生态无缝集成：通过 <code>@MapperScan</code> 快速扫描 Mapper 接口，结合 Spring 事务管理，配置简洁高效。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 数据源和 SqlSessionFactory 配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-还记得JDBC连接数据库的步骤吗？">3.还记得JDBC连接数据库的步骤吗？</h2>
<p>使用Java JDBC连接数据库的一般步骤如下：</p>
<ol>
<li><strong>加载数据库驱动程序</strong>：在使用JDBC连接数据库之前，需要加载相应的**数据库驱动程序。可以通过 Class.forName(“com.mysql.jdbc.Driver”) 来加载MySQL数据库的驱动程序。**不同数据库的驱动类名会有所不同。</li>
<li><strong>建立数据库连接</strong>：使用 DriverManager 类的 **getConnection(url, username, password) 方法来连接数据库，**其中url是数据库的连接字符串（包括数据库类型、主机、端口等）、username是数据库用户名，password是密码。</li>
<li><strong>创建 Statement 对象</strong>：通过 <strong>Connection 对象的 createStatement() 方法创建一个 Statement 对象，用于执行 SQL 查询或更新操作。</strong></li>
<li><strong>执行 SQL 查询或更新操作</strong>：使用 Statement 对象的 executeQuery(sql) 方法来执行 SELECT 查询操作，或者使用 executeUpdate(sql) 方法来执行 INSERT、UPDATE 或 DELETE 操作。</li>
<li><strong>处理查询结果</strong>：如果是 SELECT 查询操作，通过 ResultSet 对象来处理查询结果。可以使用 ResultSet 的 next() 方法遍历查询结果集，然后通过 getXXX() 方法获取各个字段的值。</li>
<li><strong>关闭连接</strong>：在完成数据库操作后，需要逐级关闭数据库连接相关对象，即先关闭 ResultSet，再关闭 Statement，最后关闭 Connection。</li>
</ol>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载数据库驱动程序</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 建立数据库连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 Statement 对象</span></span><br><span class="line">            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行 SQL 查询</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;SELECT * FROM mytable&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理查询结果</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">              <span class="comment">// 处理每一行数据</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            resultSet.close();</span><br><span class="line">            statement.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在实际应用中，需要进行异常处理以确保资源的正确释放，以及使用 try-with-resources 来简化代码和确保资源的及时关闭。</p>
<h2 id="4-如果项目中要用到原生的mybatis去查询，该怎样写？">4.如果项目中要用到原生的mybatis去查询，该怎样写？</h2>
<p>步骤概述：</p>
<ol>
<li><strong>配置MyBatis：</strong> 在项目中配置MyBatis的数据源、SQL映射文件等。</li>
<li><strong>创建实体类：</strong> 创建用于映射数据库表的实体类。</li>
<li><strong>编写SQL映射文件：</strong> 创建XML文件，定义SQL语句和映射关系。</li>
<li><strong>编写DAO接口：</strong> 创建DAO接口，定义数据库操作的方法。</li>
<li><strong>编写具体的SQL查询语句：</strong> 在DAO接口中定义查询方法，并在XML文件中编写对应的SQL语句。</li>
<li><strong>调用查询方法：</strong> 在服务层或控制层调用DAO接口中的方法进行查询。</li>
</ol>
<p>详细步骤：</p>
<ol>
<li><strong>配置MyBatis：</strong> 在配置文件中配置数据源、MyBatis的Mapper文件位置等信息。</li>
<li><strong>创建实体类：</strong> 创建与数据库表对应的实体类，字段名和类型需与数据库表保持一致。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>编写SQL映射文件：</strong> 在resources目录下创建XML文件，定义SQL语句和映射关系。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM users WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>编写DAO接口：</strong> 创建DAO接口，定义查询方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">selectUserById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>编写具体的SQL查询语句：</strong> 在XML文件中编写对应的SQL语句。</li>
<li><strong>调用查询方法：</strong> 在服务层或控制层中调用DAO接口中的方法进行查询。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Service层中调用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectUserById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>通过以上步骤，你可以利用原生的MyBatis框架来进行数据库查询操作。请确保配置正确、SQL语句准确并与数据库字段匹配，以确保查询的准确性和高效性。</p>
<h2 id="5-Mybatis里的-和-的区别？">5.Mybatis里的 # 和 $ 的区别？</h2>
<ul>
<li>Mybatis 在处理 #{} 时，会创建预编译的 SQL 语句，将 SQL 中的 #{} 替换为 ? 号，**在执行 SQL 时会为预编译 SQL 中的占位符（?）赋值，调用 PreparedStatement 的 set 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止SQL 注入，**提供更高的安全性，适合传递参数值。</li>
<li>Mybatis 在处理 ${} 时，只是创建普通的 SQL 语句，然后在执行 SQL 语句时 MyBatis 将参数直接拼入到 SQL 里，<strong>不能防止 SQL 注入，因为参数直接拼接到 SQL 语句中，如果参数未经过验证、过滤，可能会导致安全问题。</strong></li>
</ul>
<h2 id="6-MybatisPlus和Mybatis的区别？">6.MybatisPlus和Mybatis的区别？</h2>
<p>MybatisPlus是一个基于MyBatis的增强工具库，旨在简化开发并提高效率。以下是MybatisPlus和MyBatis之间的一些主要区别：</p>
<ul>
<li><strong>CRUD操作</strong>：MybatisPlus通过继承BaseMapper接口，提供了一系列内置的快捷方法，使得CRUD操作更加简单，无需编写重复的SQL语句。</li>
<li><strong>代码生成器</strong>：MybatisPlus提供了<strong>代码生成器功能</strong>，可以根据数据库表结构自动生成实体类、Mapper接口以及XML映射文件，减少了手动编写的工作量。</li>
<li><strong>通用方法封装</strong>：MybatisPlus封装了许多常用的方法，如条件构造器、排序、分页查询等，简化了开发过程，提高了开发效率。</li>
<li><strong>分页插件</strong>：MybatisPlus<strong>内置了分页插件</strong>，支持各种数据库的分页查询，开发者可以轻松实现分页功能，而在传统的MyBatis中，需要开发者自己手动实现分页逻辑。</li>
<li><strong>多租户支持</strong>：MybatisPlus提供了多租户的支持，可以轻松实现多租户数据隔离的功能。</li>
<li><strong>注解支持</strong>：MybatisPlus引入了更多的注解支持，使得开发者可以通过注解来配置实体与数据库表之间的映射关系，减少了XML配置文件的编写。</li>
</ul>
<h2 id="7-MyBatis运用了哪些常见的设计模式？">7.MyBatis运用了哪些常见的设计模式？</h2>
<ul>
<li>建造者模式（Builder），如：SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder等；</li>
<li>工厂模式，如：SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li>
<li>单例模式，例如ErrorContext和LogFactory；</li>
<li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li>
<li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li>
<li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li>
<li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li>
<li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li>
<li>迭代器模式，例如迭代器模式PropertyTokenizer；</li>
</ul>
<h2 id="8-MyBatis-的两级缓存及其特点是什么？">8.MyBatis 的两级缓存及其特点是什么？</h2>
<p>MyBatis 的两级缓存包括一级缓存和二级缓存。一级缓存是 <strong>SqlSession 级别的本地缓存</strong>，默认开启，仅在同一个会话中有效，用于避免重复查询，同一个查询在会话中只访问一次数据库；<strong>但在执行更新操作或关闭会话后会失效</strong>，且不能跨线程、跨请求。二级缓存是 <strong>Mapper 级别的全局缓存</strong>，默认关闭，需要在全局配置中开启并在对应的 Mapper 中使用 <code>&lt;cache /&gt;</code> 标签声明，它<strong>支持多个 SqlSession 共享缓存</strong>，通常用于<strong>读多写少</strong>的场景，如商品信息、字典数据等。一级缓存生命周期短、线程不安全，适合单次请求优化；<strong>二级缓存生命周期长、线程安全，适合全局数据共享</strong>，但需注意缓存失效和一致性控制。</p>
<p>sqlsession:</p>
<p>在一次 SqlSession 生命周期内，相同的查询语句（SQL + 参数）会被缓存，第二次执行时直接从缓存中取值，不会发起数据库请求。当前会话有效，执行 <code>insert/update/delete</code>：任何更新操作会清空缓存。执行<code>sqlSession.clearCache()</code>。不同参数的时候也会失效</p>
<p>mapper：</p>
<p>二级缓存是 <strong>Mapper 级别</strong>（namespace）共享缓存。</p>
<p>多个 SqlSession 之间共享该 Mapper 的缓存数据。</p>
<p>启用条件：</p>
<p>在 MyBatis 配置中启用全局缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>在对应 Mapper 文件中配置 <code>&lt;cache&gt;</code> 标签：</p>
<p>查询的 POJO 实体类必须实现 <code>Serializable</code>。</p>
<p>查询语句不能使用 <code>flushCache=&quot;true&quot;</code>（默认查询是 false，更新是 true）。</p>
<p>SqlSession 必须关闭后，一级缓存的数据才会被写入二级缓存。</p>
<p>默认缓存实现是 <code>PerpetualCache + LRU</code>。</p>
<p>可自定义缓存策略（如 EhCache、Redis）。</p>
<h2 id="9-MyBatis-Plus-的-Wrapper-和原生-XML-写-SQL-的区别？什么时候该用-Wrapper？"><strong>9.MyBatis Plus 的 Wrapper 和原生 XML 写 SQL 的区别？什么时候该用 Wrapper？</strong></h2>
<p>Wrapper 是 MyBatis Plus 提供的条件构造器，用于构建 SQL 的 WHERE、ORDER BY 等子句，简化代码书写。</p>
<p><code>QueryWrapper</code>：用于普通查询。</p>
<p><code>LambdaQueryWrapper</code>：使用 lambda 表达式避免写字段名字符串。</p>
<p><code>UpdateWrapper</code> / <code>LambdaUpdateWrapper</code>：用于更新条件构造。</p>
<p>XML 方式是传统 MyBatis 写 SQL 的方式，通过 Mapper.xml 文件自定义 SQL 语句，更加灵活和强大，支持复杂的多表连接、子查询等。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Wrapper（构造器）</th>
<th>XML 原生 SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>语法风格</td>
<td>Java 代码风格，链式调用</td>
<td>SQL 语法，放在 XML 中</td>
</tr>
<tr>
<td>可读性</td>
<td>简洁、类型安全（特别是 Lambda）</td>
<td>接近原生 SQL，清晰直观</td>
</tr>
<tr>
<td>编写速度</td>
<td>快速开发，尤其适合单表 CRUD</td>
<td>编写略慢，需额外维护 Mapper.xml 文件</td>
</tr>
<tr>
<td>SQL 灵活性</td>
<td>支持简单查询（单表、分页、排序）</td>
<td>支持复杂 SQL（多表连接、子查询、聚合）</td>
</tr>
<tr>
<td>维护性</td>
<td>逻辑分散在代码中，不易集中查看</td>
<td>逻辑集中在 XML，更适合团队协作维护</td>
</tr>
<tr>
<td>运行效率</td>
<td>两者本质上都由 MyBatis 执行，性能差异不大</td>
<td>性能主要看 SQL 写得是否合理</td>
</tr>
<tr>
<td>调试与日志</td>
<td>SQL 日志可查看</td>
<td>也可通过日志查看</td>
</tr>
</tbody>
</table>
<p>✅ 使用 Wrapper 的场景：</p>
<ul>
<li>快速开发、原型项目。</li>
<li>简单的单表查询、分页、筛选。</li>
<li>Controller/Service 中构造简单业务逻辑。</li>
<li>需要链式调用构造条件，代码更加优雅。</li>
<li>使用 Lambda 避免字段拼写错误风险。</li>
</ul>
<blockquote>
<p><strong>推荐：日常开发中能用 Wrapper 就用 Wrapper，提高开发效率。</strong></p>
</blockquote>
<hr>
<p>✅ 使用 XML 写 SQL 的场景：</p>
<ul>
<li>涉及复杂 SQL（多表关联、聚合函数、子查询、动态 SQL）。</li>
<li>查询语句过长、不适合写在 Java 代码中。</li>
<li>项目追求清晰的逻辑分层、SQL 可维护性。</li>
<li>性能调优场景，需要手写精细 SQL。</li>
<li>团队需要 DBA 审查 SQL。</li>
</ul>
<blockquote>
<p><strong>推荐：复杂业务、线上稳定项目，用 XML 更清晰、更可控。</strong></p>
</blockquote>
<h2 id="10-分页查询的方式">10.分页查询的方式</h2>
<p>1 Limit Offset分页</p>
<p>2 Limit 指定主键Id过滤</p>
<p>3 HasMore 滚动查询</p>
<p>4 ElasticSearch 分页查询</p>
<p><strong>Limit Offset：</strong></p>
<p>支持页数跳转。用户选定第几页，就跳转到对应的页面。</p>
<p>返回记录总条数。用户可以看到共几页，一共多少条数据。</p>
<p>但是<strong>当出现深度分页时，MySQL 需要扫描大量数据才能找到指定页的数据，造成慢查询</strong></p>
<p>分页查询必须指定排序方式。如果没有指定排序方式，使用分页很难保证数据不会出现重复。</p>
<p><strong>Limit 指定主键Id过滤</strong></p>
<p>select * from students where xxxx查询条件xxx order by id desc limit 1000,20;</p>
<p>改进后：select * from students where xxxx查询条件xxx AND id &lt;lastMinId order by id desc limit 20;</p>
<p>改进后在原有的查询条件上 指定了lastMinId，上一轮最小的Id。在查询下一页时，把上一页的最小id 传下去，这样保证后续查到的列表都是小于lastMinId。从源头上增加了查询条件，减少了mysql的检索范围，每次都只获取前二十条数据。</p>
<p>这种方式前提条件是排序方式可以指定主键Id，每次查询都更新主键id范围，这样就能避免深度分页，查询全部的数据。</p>
<p><strong>HasMore 滚动查询</strong></p>
<p>滚动分页查询则无需获取总页数，无需查询总数。减少了一次<code>select count(*)</code>的查询。</p>
<p>只需要在每一次分页查询时，每页数量+1 即可。例如每页10条，可以指定11条，如果真查出来11条，<code>hasMore=true</code>，上游需要继续查，否则<code>hasMore=false</code>，上游无需再分页查询。</p>
<p><strong>ElasticSearch 分页查询</strong></p>
<p>ES 比较适用于<strong>检索条件复杂、实时性要求比较低</strong>的查询场景。例如B端的各类复杂查询条件检索场景以及 C端用户关键词订单列表搜索等场景。查询耗时基本在100ms以上、甚至1s以上。</p>
<p>值得一提的是需要mysql数据异构到ES，ES加载进索引也有1s左右延迟，数据从产生到ES索引延迟比较高。</p>
<p>ElasticSearch 支持<strong>分页查询</strong>，和Mysql Limit offset 类似。同时也强烈建议，使用分页查询时，指定排序方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(index);</span><br><span class="line">  <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">  <span class="comment">//计算出记录起始下标</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> (pageNum - <span class="number">1</span>) * pageSize;</span><br><span class="line">  <span class="comment">// 起始记录下标，从0开始</span></span><br><span class="line">  sourceBuilder.from(from);</span><br><span class="line">  <span class="comment">//每页显示的记录数</span></span><br><span class="line">  sourceBuilder.size(pageSize);</span><br></pre></td></tr></table></figure>
<p>和mysql类似，ES也有深度分页的查询压力，默认的最大查询深度<code>max_result_window=1W</code>， 阈值可以修改。在低频的B端查询场景，可以根据需要适当调整阈值。</p>
<p>以上4种分页查询方式没有最好，需要针对不同的场景选择最合适的</p>
<h2 id="11-MyBatis-Mapper-注册过程">11.MyBatis Mapper 注册过程</h2>
<p>*动态代理、FactoryBean、Configuration 注册流程**的理解</p>
<p>MyBatis 使用 <code>MapperFactoryBean</code> 将<strong>接口注册为代理对象</strong>，启动时会把接口方法解析成 <code>MappedStatement</code> 存入 Configuration 中，运行时由 <code>MapperProxy</code> 通过反射动态执行 SQL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       XML or <span class="meta">@MapperScan</span></span><br><span class="line">              ↓</span><br><span class="line">  【Mapper接口注册】 → 注册到 Configuration.mapperRegistry</span><br><span class="line">              ↓</span><br><span class="line">  【创建代理类】 MapperProxyFactory → MapperProxy</span><br><span class="line">              ↓</span><br><span class="line">【执行 SQL】 通过 SqlSession 执行对应 MappedStatement</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.@MapperScan 启动时扫描 Mapper 接口</p>
<p><code>@MapperScan</code> 会注册 <code>MapperScannerConfigurer</code> 或 <code>MapperScannerRegistrar</code>；</p>
<p>它们会扫描包下所有接口，<strong>对每个接口注册一个 <code>MapperFactoryBean</code> 到 Spring 容器中</strong>。</p>
<p>2.<strong>每个 Mapper 接口注册成一个 MapperFactoryBean</strong></p>
<p><strong>MapperFactoryBean</strong> 实现了 Spring 的 <code>FactoryBean</code> 接口；</p>
<p>它不会直接注入自身，而是调用 <code>getObject()</code> 返回 Mapper 接口的代理类。</p>
<p>3.MapperProxyFactory 创建代理类</p>
<p>返回的是一个 <strong>MapperProxy 的动态代理对象</strong>，底层通过 <code>Proxy.newProxyInstance(...)</code> 实现；</p>
<p>所以你注入的 <code>UserMapper</code> 实际是 MapperProxy 代理类。</p>
<p>4.代理对象调用方法时执行 SQL</p>
<p><code>MapperMethod</code> 会查找 <code>Configuration</code> 中注册的 <code>MappedStatement</code>；</p>
<p>调用 <code>sqlSession.selectOne(...)</code> 或 <code>insert(...)</code> 等执行 SQL；</p>
<p>SQL 语句和参数映射都来源于 XML 或注解注册的 MappedStatement。</p>
<p>5.在 <code>SqlSessionFactoryBuilder.build()</code> 构建过程中，MyBatis 会：</p>
<ul>
<li>加载 XML 映射文件或注解 Mapper；</li>
<li>把每个 <code>&lt;mapper&gt;</code> 里的 SQL 语句解析为 <code>MappedStatement</code>；</li>
<li>调用 <code>Configuration.addMappedStatement()</code> 注册到全局配置里；</li>
<li>最终保存在 <code>configuration.getMappedStatements()</code> 的 Map 中。</li>
</ul>
<h2 id="12-xml标签有啥">12.xml标签有啥</h2>
<p>元素</p>
<p>属性</p>
<p>声明</p>
<p>注释</p>
<p>CDATA</p>
<p>处理指令</p>
<p>文档类型定义</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/05/05/java-stack/spring2/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/05/05/java-stack/spring2/')">Spring面试题hot1</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/05/05/java-stack/spring2/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Spring面试题hot1&amp;url=https://blog.tokenlen.top/2025/05/05/java-stack/spring2/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=3d6fda97-304a-d3c6-a1c8-f2d58a0c71bd" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>技术栈<span class="categoryesPageCount">23</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">57</span></a><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">24</span></a><a class="post-meta__box__tags" href="/tags/spring/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>spring<span class="tagsPageCount">3</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=4ef10f2e-41c4-8a83-25b9-23bbd54e0552" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/01/en/en9/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221838345.jpg?_r_=75d06b5f-4635-b41b-fd95-6b58e20765ea" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">English五月篇</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/05/java-stack/spring1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=59b1357e-7399-1370-3a45-ce1034e03148" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/07/19/java-stack/spring3/" title="Spring面试题hot2-源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=10230d47-7941-7fed-6aa3-e4d9743c6280" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-19</div><div class="title">Spring面试题hot2-源码分析</div></div></a></div><div><a href="/2025/05/27/java-stack/javasample1/" title="JAVA设计模式面试题目hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837602.jpg?_r_=c2ef60fa-c891-26be-9ad1-4dfe9d9aa62c" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-27</div><div class="title">JAVA设计模式面试题目hot</div></div></a></div><div><a href="/2025/05/25/java-stack/jvm2/" title="JVM-java虚拟机hot面试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=41e7d7e8-f339-5496-34ba-72657a4354b5" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-25</div><div class="title">JVM-java虚拟机hot面试</div></div></a></div><div><a href="/2025/05/22/java-stack/juc2/" title="JUC-线程池面试题hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712181.jpg?_r_=23831538-4773-64d1-f0ed-95b492759205" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-22</div><div class="title">JUC-线程池面试题hot</div></div></a></div><div><a href="/2025/05/05/java-stack/spring1/" title="Spring基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=59b1357e-7399-1370-3a45-ce1034e03148" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-05</div><div class="title">Spring基础</div></div></a></div><div><a href="/2025/05/19/javase/javase2/" title="javase面试-基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=27d9be06-fa07-7f5d-c14f-6c8a152f6c66" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-19</div><div class="title">javase面试-基础</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-spring-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.spring 事务失效的场景有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%8C%E4%BD%BF%E7%94%A8this%E8%B0%83%E7%94%A8%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.Spring的事务，使用this调用是否生效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%B0%88%E4%B8%80%E4%B8%8Bspring%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">3.谈一下spring事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9-Spring-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">1.说一下你对 Spring 的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-spring%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.spring的核心思想说说你的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Spring-IoC%E5%92%8CAOP-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3.Spring IoC和AOP 介绍一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Spring%E7%9A%84aop%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">4.Spring的aop介绍一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-IOC%E5%92%8CAOP%E6%98%AF%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.5.</span> <span class="toc-text">5.IOC和AOP是通过什么机制来实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3SpringIoc%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6.怎么理解SpringIoc？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%EF%BC%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">7.依赖倒置，依赖注入，控制反转分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8.依赖注入了解吗？怎么实现依赖注入的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AASpringIoc%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E4%BC%9A%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91%E8%BF%99%E4%B8%AA%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9.如果让你设计一个SpringIoc，你觉得会从哪些方面考虑这个设计？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-SpringAOP%E4%B8%BB%E8%A6%81%E6%83%B3%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.</span> <span class="toc-text">10.SpringAOP主要想解决什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-SpringAOP%E7%9A%84%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">2.11.</span> <span class="toc-text">11.SpringAOP的原理了解吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">12.动态代理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.13.</span> <span class="toc-text">13.动态代理和静态代理的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-AOP%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">14.AOP实现有哪些注解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">15.什么是反射？有哪些使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">16.spring是如何解决循环依赖的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">17.spring三级缓存的数据结构是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.18.</span> <span class="toc-text">18.spring框架中都用到了哪些设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-spring-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">19.spring 常用注解有什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-componet%E5%92%8C-bean"><span class="toc-number">2.20.</span> <span class="toc-text">20.@componet和@bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E8%AE%B2%E4%B8%80%E4%B8%8B-Spring-%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">21.讲一下 Spring 中用到的设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-springsecurity%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.22.</span> <span class="toc-text">22.springsecurity是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-spring-%E6%A1%86%E6%9E%B6%E9%87%8C%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%AF%94%E5%A6%82-Propagation-REQUIRED-%E5%92%8C-REQUIRES-NEW-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E5%95%A5%E5%91%80%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">23.spring 框架里的事务传播机制有哪些？比如 Propagation.REQUIRED 和 REQUIRES_NEW 的区别是啥呀？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-AOP-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.24.</span> <span class="toc-text">24.AOP 的实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.Bean的生命周期说一下？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Bean%E6%98%AF%E5%90%A6%E5%8D%95%E4%BE%8B%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.Bean是否单例？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Bean%E7%9A%84%E5%8D%95%E4%BE%8B%E5%92%8C%E9%9D%9E%E5%8D%95%E4%BE%8B%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%90%A6%E4%B8%80%E6%A0%B7"><span class="toc-number">3.3.</span> <span class="toc-text">3.Bean的单例和非单例，生命周期是否一样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Spring-bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">4.Spring bean的作用域有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Spring%E5%AE%B9%E5%99%A8%E9%87%8C%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">5.Spring容器里存的是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9C%A8Spring%E4%B8%AD%EF%BC%8C%E5%9C%A8bean%E5%8A%A0%E8%BD%BD-%E9%94%80%E6%AF%81%E5%89%8D%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%83%B3%E5%AE%9E%E7%8E%B0%E6%9F%90%E4%BA%9B%E9%80%BB%E8%BE%91%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">3.6.</span> <span class="toc-text">6.在Spring中，在bean加载&#x2F;销毁前后，如果想实现某些逻辑，可以怎么做</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Bean%E6%B3%A8%E5%85%A5%E5%92%8Cxml%E6%B3%A8%E5%85%A5%E6%9C%80%E7%BB%88%E5%BE%97%E5%88%B0%E4%BA%86%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%9C%A8%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E6%A0%B7%E5%81%9A%E7%9A%84"><span class="toc-number">3.7.</span> <span class="toc-text">7.Bean注入和xml注入最终得到了相同的效果，它们在底层是怎样做的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Spring%E7%BB%99%E6%88%91%E4%BB%AC%E6%8F%90%E4%BE%9B%E4%BA%86%E5%BE%88%E5%A4%9A%E6%89%A9%E5%B1%95%E7%82%B9%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">8.Spring给我们提供了很多扩展点，这些有了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%EF%BC%8CBean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%AF%B7%E5%88%86%E5%88%AB%E8%AF%B4%E6%98%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.9.</span> <span class="toc-text">9.Spring 框架中，Bean 的作用域有哪些？请分别说明它们的生命周期和应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-BeanFactory-%E5%92%8C-FactoryBean-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.10.</span> <span class="toc-text">10.BeanFactory 和 FactoryBean 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-MVC%E5%88%86%E5%B1%82%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1.MVC分层介绍一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%86%E8%A7%A3SpringMVC%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.了解SpringMVC的处理流程吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Handlermapping-%E5%92%8C-handleradapter%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3.Handlermapping 和 handleradapter有了解吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Springboot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8springboot"><span class="toc-number">5.1.</span> <span class="toc-text">1.为什么使用springboot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SpringBoot%E6%AF%94Spring%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">5.2.</span> <span class="toc-text">2.SpringBoot比Spring好在哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SpringBoot%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3.SpringBoot用到哪些设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3SpringBoot%E4%B8%AD%E7%9A%84%E7%BA%A6%E5%AE%9A%E5%A4%A7%E4%BA%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">5.4.</span> <span class="toc-text">4.怎么理解SpringBoot中的约定大于配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-SpringBoot%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5.SpringBoot的项目结构是怎么样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">6.SpringBoot自动装配原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%AF%B4%E5%87%A0%E4%B8%AA%E5%90%AF%E5%8A%A8%E5%99%A8%EF%BC%88starter-%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">7.说几个启动器（starter)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%86%99%E8%BF%87SpringBoot-starter%E5%90%97"><span class="toc-number">5.8.</span> <span class="toc-text">8.写过SpringBoot starter吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-SpringBoot%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%9F%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">9.SpringBoot里面有哪些重要的注解？还有一个配置相关的注解是哪个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-springboot%E6%80%8E%E4%B9%88%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">10.springboot怎么开启事务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Springboot%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E5%AF%BC%E5%85%A5%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">5.11.</span> <span class="toc-text">11.Springboot怎么做到导入就可以直接使用的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-SpringBoot-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-number">5.12.</span> <span class="toc-text">12.SpringBoot 过滤器和拦截器说一下？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E8%AF%B4%E8%AF%B4Spring-Boot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E3%80%82"><span class="toc-number">5.13.</span> <span class="toc-text">13.说说Spring Boot的启动流程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Autowied%E5%92%8C-Resource"><span class="toc-number">5.14.</span> <span class="toc-text">14.@Autowied和@Resource</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9A%84JDBC%E7%9B%B8%E6%AF%94%EF%BC%8CMyBatis%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1.与传统的JDBC相比，MyBatis的优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MyBatis%E8%A7%89%E5%BE%97%E5%9C%A8%E5%93%AA%E6%96%B9%E9%9D%A2%E5%81%9A%E7%9A%84%E6%AF%94%E8%BE%83%E5%A5%BD%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2.MyBatis觉得在哪方面做的比较好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%98%E8%AE%B0%E5%BE%97JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%90%97%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.还记得JDBC连接数据库的步骤吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%A6%81%E7%94%A8%E5%88%B0%E5%8E%9F%E7%94%9F%E7%9A%84mybatis%E5%8E%BB%E6%9F%A5%E8%AF%A2%EF%BC%8C%E8%AF%A5%E6%80%8E%E6%A0%B7%E5%86%99%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4.如果项目中要用到原生的mybatis去查询，该怎样写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Mybatis%E9%87%8C%E7%9A%84-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">5.Mybatis里的 # 和 $ 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-MybatisPlus%E5%92%8CMybatis%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">6.MybatisPlus和Mybatis的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-MyBatis%E8%BF%90%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">7.MyBatis运用了哪些常见的设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-MyBatis-%E7%9A%84%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">8.MyBatis 的两级缓存及其特点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-MyBatis-Plus-%E7%9A%84-Wrapper-%E5%92%8C%E5%8E%9F%E7%94%9F-XML-%E5%86%99-SQL-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8-Wrapper%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">9.MyBatis Plus 的 Wrapper 和原生 XML 写 SQL 的区别？什么时候该用 Wrapper？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.10.</span> <span class="toc-text">10.分页查询的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-MyBatis-Mapper-%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.11.</span> <span class="toc-text">11.MyBatis Mapper 注册过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-xml%E6%A0%87%E7%AD%BE%E6%9C%89%E5%95%A5"><span class="toc-number">6.12.</span> <span class="toc-text">12.xml标签有啥</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/12/javase/javase4/" title="javase面试-深入源码"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=4ef10f2e-41c4-8a83-25b9-23bbd54e0552" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javase面试-深入源码"/></a><div class="content"><a class="title" href="/2025/08/12/javase/javase4/" title="javase面试-深入源码">javase面试-深入源码</a><time datetime="2025-08-11T16:00:00.000Z" title="发表于 2025-08-12 00:00:00">2025-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/10/workmenu/forum1/" title="微服务论坛设计方案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=c145f523-c70f-48c0-c2d0-6316b05340de" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务论坛设计方案"/></a><div class="content"><a class="title" href="/2025/08/10/workmenu/forum1/" title="微服务论坛设计方案">微服务论坛设计方案</a><time datetime="2025-08-09T16:00:00.000Z" title="发表于 2025-08-10 00:00:00">2025-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/10/workmenu/fourm2/" title="微服务论坛问题收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837448.jpg?_r_=99de7ccf-57bf-7694-9360-4a4c879df700" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务论坛问题收集"/></a><div class="content"><a class="title" href="/2025/08/10/workmenu/fourm2/" title="微服务论坛问题收集">微服务论坛问题收集</a><time datetime="2025-08-09T16:00:00.000Z" title="发表于 2025-08-10 00:00:00">2025-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/09/new-stack/springcloud1/" title="SpringCloud-组件介绍"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837602.jpg?_r_=de2a8de1-b8b7-4748-1b68-7ed9d20f8e8d" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud-组件介绍"/></a><div class="content"><a class="title" href="/2025/08/09/new-stack/springcloud1/" title="SpringCloud-组件介绍">SpringCloud-组件介绍</a><time datetime="2025-08-08T16:00:00.000Z" title="发表于 2025-08-09 00:00:00">2025-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/29/towork/woking3/" title="面试模拟-202508"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510550.jpg?_r_=b7f7d40d-4260-2ed2-d5d2-36ff18acc534" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试模拟-202508"/></a><div class="content"><a class="title" href="/2025/07/29/towork/woking3/" title="面试模拟-202508">面试模拟-202508</a><time datetime="2025-07-28T16:00:00.000Z" title="发表于 2025-07-29 00:00:00">2025-07-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">162</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">25</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 0.88rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>2</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/Cache/" style="font-size: 0.88rem;">Cache<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 0.88rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/Github/" style="font-size: 0.88rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>2</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/SpringAI/" style="font-size: 0.88rem;">SpringAI<sup>2</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>57</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>10</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>7</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>4</sup></a><a href="/tags/rocketmq/" style="font-size: 0.88rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>3</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>24</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>