<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>面试面经优化回答 | mengnankkのblog</title><meta name="keywords" content="面试"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="面试面经优化回答"><meta name="application-name" content="面试面经优化回答"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="面试面经优化回答"><meta property="og:url" content="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="Spring框架1.SpringBoot的配置加载优先级首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：  先是命令行参数（--server.port&amp;#x3D;9000 或 java -jar app.jar --spring.config.location&amp;#x3D;...）  然后是我们的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510095.jpg?_r_=a3e34e80-83d8-f14a-7a77-4502d78a2aee"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510095.jpg?_r_=a3e34e80-83d8-f14a-7a77-4502d78a2aee"><meta name="description" content="Spring框架1.SpringBoot的配置加载优先级首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：  先是命令行参数（--server.port&amp;#x3D;9000 或 java -jar app.jar --spring.config.location&amp;#x3D;...）  然后是我们的"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: '面试面经优化回答',
  postAI: '',
  pageFillDescription: 'Spring框架, 1.SpringBoot的配置加载优先级, 2.Springboot是如何解决跨域问题的？, 3.Spring 解决循环依赖, JUC, 1.线程池常见的坑, 2.AQS的大局解析, 3.wait和sleep的区别, 4.异步编排, 5.synchronized 锁升级的细节追问, 6.ThreadLocal, 7.谈谈怎么理解线程安全的, 8.@ConditionalOnClass设计内涵, 9.ThreadLocal 在线程池中的失效问题, 10.如何保证三个线程有序执行任务, Mybatis, 1.UserMappe这个类为啥要是接口呢？, JVM, JavaSE, 1.流式输出和非流式输出, 2.HashMap remove 方法的实现细节, Mysql, 1.多表join的时候小表驱动大表, 2.一条 UPDATE 语句发过来从网络接收开始到最终落盘会经过哪些核心模块的处理, 3.为什么选择 WAL？它相比于直接写数据文件核心优势是什么？写日志和更新内存数据页的顺序是怎样的？, 4.当一个叶子节点分裂时具体逻辑是怎样的？如何处理并发问题？, Redis, 1.多级缓存数据一致性与失败回滚, 2.什么情况下就是两个线程会持有同一把锁, 3.如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断会发生什么？有什么容灾方案吗？, 4.你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。, 5.缓存三问题, 6.用户在10分钟之内连续输错三次密码就禁止其登录。如果使用 Redis你会选择哪种数据结构来实现, MQ, 1.消息队列（MQ）消息积压处理, 2.消费者组的对应, 设计模式, 1.当被问及如何在多个接口中统一管理以避免代码重复时, 2.策略方法怎么去解决具体调用哪一个策略, 异常解决, 1.就比如说你这个部署到线上了然后他抛了一个异常然后那你这个应该怎么排查呢框架的配置加载优先级首先我们先确定一下配置加载优先级是按照我以下的顺序由高到低的分别是先是命令行参数或然后是我们的系统的环境变量和系统属性比如设置端口为比如我们在这里设置的然后占位符用于生成随机数字符串可在配置中引用接着是外部配置文件包外部的包外部的包内部的包内部的接着是我们注解指定的配置最后是我们默认的配置然后在配置文件中的配置大于因为是按加载顺序来的后加载的把的值给覆盖了对于外部配置文件查找路径的优先级为当前目录下的目录当前目录实际应用基础配置放在环境特定配置使用如通过激活敏感信息放在环境变量或外部化配置文件避免入库临时调试测试使用命令行参数临时覆盖多环境冲突处理利用合并特性公共配置放在环境差异放在对应文件是如何解决跨域问题的基本都是基于跨域资源共享通过设置响应头如告诉浏览器允许访问对于复杂跨域请求非或自定义头浏览器会先发预检请求局部注解用标记单个接口秒开跨域权限适合快速测试简单高效优先级高于全局配置全局配置使用接口统一设定允许的域名请求方法头信息统一配置但是不适合动态的控制用手动处理跨域逻辑处理适合需要动态校验权限等特殊场景比如不同权限开放不同接口在过滤器中动态判断但是实现成本较高在微服务架构中也可以在网关层如统一处理跨域减少业务服务配置优先级解决循环依赖既然能解决循环依赖那为什么我们还经常听说构造器注入无法解决循环依赖三级缓存对构造器注入为什么无效您问到了循环依赖解决方案的一个核心前提三级缓存之所以能工作其根本在于它将的实例化和属性填充这两个阶段分离开来了第一步实例化首先通过无参构造函数创建了的一个空壳实例这个实例已经有了自己的内存地址第二步暴露早期引用紧接着立即将这个空壳实例的工厂放入三级缓存从而提前暴露了的引用第三步属性填充然后才开始尝试为注入属性此时发现需要就去创建当需要时可以从三级缓存中获取到的早期引用从而打破循环构造器注入的工作流程对于构造器注入的实例化和属性填充这两个阶段是合并在一起的是原子性的当尝试创建时它必须调用的构造函数而的构造函数需要一个的实例作为参数为了满足这个参数必须先去创建而当尝试创建时又发现的构造函数需要一个的实例作为参数此时的实例根本还没有被创建出来它还卡在等待的阶段内存中不存在任何的空壳实例三级缓存中自然也就不可能有任何关于的引用这就形成了一个无法解开的死结的创建依赖的创建的创建又依赖的创建因此会直接抛出线程池常见的坑线程池的参数配置核心线程的数量和最大线程的数量是业务场景来的密集型比如数据的计算业务就是的数量密集型根据业务压测的值来决定的最佳线程数线程等待时间线程时间线程时间数量比如我们服务器核数为核任务线程耗时线程等待等等耗时那么最佳线程数线程那我们最大线程数就是个共享线程池次要的逻辑拖垮主要的逻辑避免所有的业务都共享一个线程池防止一个次要的业务一直在执行业务占用线程池而主要的业务并没有足够的线程数来执行影响到了我们主要的服务这样做是不合理的我们应该要做线程池的隔离使用方法的时候使用带超时时间的因为他是阻塞的防止被其他抢占是中一个注解他不是线程池他其实是不会复用线程适合执行大量短时间的线程还是尽量自己定义一个异步的线程池然后使用来注册使用线程池的时候不使用参数来自定义命名这样导致后期不好排查问题和回溯问题使用提交任务不会把异常直接抛出来最好我们在之中进行进行捕获或者是在时捕获并记录异常线程池使用完之后记得关闭防止内存泄漏的问题最好线程池设计成单例的模式长期运行的全局线程池如管理的不需手动关闭临时线程池需在中调用线程池不要和事务一起使用使用的时候依赖于当前线程的线程上下文而线程池的线程和当前事务的线程不是一个线程事务的上下文不会传递导致线程池中的业务代码不在事务中执行事务就失效了我们可以将事务放在线程池之外进行这是最好的方法或者是使用支持事务上下文传递的机制如消息队列保证一致性我们要负责监控线程池状态比如当前活跃的线程池的数量队列的长度拒绝的次数要配置合理的拒绝策略比如一个需要快速获取结果的线程就需要胚子和这样的话谁提交谁执行回退给调用的线程的大局解析是里面的一个抽象同步框架核心的作用就是统一分装了线程的等待唤醒排队机制底层通过一个的变量的队列来实现线程安全的资源性抢夺表示资源的状态独占锁里面没人占就是已经上锁可重入锁里面数字代表可重入的次数线程要抢不到锁就会被挂到队列里面进行排队队列是双向链表实现的队列节点记录了等待状态信息等他只是一个框架真正的锁逻辑交给实现类自己决定和的区别和的主要区别在于所属类不同是类的方法是类的静态方法会释放对象锁而保持锁不释放必须在同步代码块中调用没有此限制需要或来唤醒而在超时或被中断时自动恢复使用场景上用于线程间的协作用于简单的延时操作方法使当前线程进入等待状态将其从运行状态转变为等待状态并将其加入到等待池中异步编排在我看来异步编排的核心思想是将多个独立的耗时的异步任务尤其是密集型任务组合编排起来让它们尽可能地并行执行最终汇总结果从而极大地缩短整体的响应时间这在微服务架构中尤其重要在现代开发中实现异步编排最核心的工具就是举一个我们项目中非常典型的例子获取商品详情页数据一个商品详情页通常需要展示多种信息而这些信息可能来自不同的微服务或数据库表任务调用商品服务获取商品基本信息任务调用用户服务获取当前用户的优惠券信息任务调用评论服务获取商品的热门评论任务调用推荐服务获取相关商品推荐如果采用传统的同步调用方式总耗时将是的累加但实际上这四个任务没有任何依赖关系完全可以并行执行通过异步编排理想情况下的总耗时将仅仅取决于耗时最长的那一个任务即性能会得到指数级的提升实现任务并行化为每一个独立的调用任务创建一个实例关键是使用方法并为其提供一个自定义的线程池这可以避免耗尽服务器如的业务线程池结果编排与组合当所有并行的任务都完成后我需要将它们的结果组合成一个最终的我会使用来等待所有任务完成最终结果处理在完成后通过或来执行最终的组装逻辑异常处理与超时控制在生产环境中还需要考虑健壮性我会使用来处理任何一个异步任务的失败返回一个默认值或降级数据同时使用为整个编排流程设置一个最大等待时间防止因为某个下游服务缓慢而导致整个请求长时间阻塞锁升级的细节追问线程是如何从偏向锁升级到轻量级锁的是如何判断偏向失效的偏向锁的核心思想是它偏向于第一个获取它的线程认为在接下来的执行中锁将一直被这个线程持有偏向状态当一个线程第一次获取锁时会通过操作尝试将锁对象头中的线程指向当前线程如果成功就获取了偏向锁升级触发点当另一个线程线程尝试获取这个已经被线程持有的偏向锁时升级过程就被触发了偏向锁的撤销首先线程的操作会失败会检查中记录的线程是否是线程会暂停线程在一个全局安全点然后检查线程是否还存活如果线程已经执行完毕那么锁对象恢复到无锁状态线程可以重新尝试获取如果线程仍然存活且还在同步块内说明发生了真正的竞争此时偏向锁就会被撤销锁对象头的会被修改清除偏向锁标志并升级为轻量级锁的状态同时线程的栈帧中会创建锁记录指向锁对象之后线程和线程都会在轻量级锁的状态下进行竞争通过自旋只不过目前在中被默认禁用并在被完全移除因为偏向锁的撤销消耗的性能是比较大的那轻量级锁又是如何升级到重量级锁的自旋失败后发生了什么轻量级锁的核心思想是它认为锁的竞争时间会非常短线程只需要稍等一下自旋就可以拿到锁从而避免了线程阻塞和唤醒带来的内核态切换开销轻量级锁的获取线程在自己的栈帧中创建锁记录然后通过操作尝试将锁对象的指向这个锁记录如果成功就获取了轻量级锁自旋等待如果失败说明锁已被其他线程持有当前线程并不会立即阻塞而是会进行自旋即执行一个空循环不断地重试操作升级触发点升级到重量级锁主要有两种情况自旋失败自旋的次数是有限的会动态调整比如次如果一个线程自旋了指定次数后仍然没有获取到锁就认为竞争已经非常激烈了不适合再空耗竞争者过多如果在自旋过程中又有第三个线程也来竞争这把锁那么也会立即触发升级锁膨胀一旦触发升级锁就会膨胀为重量级锁锁对象的会被修改指向一个重量级锁的监视器对象所有等待锁的线程包括正在自旋的线程和后来者都不再自旋而是会被阻塞并放入的等待队列中当持有锁的线程释放锁时会唤醒等待队列中的一个线程进行新一轮的锁竞争这个过程就涉及到了操作系统的互斥量和线程的上下文切换锁的升级是单向的只能从低级别到高级别不能降级在的实现中既然用弱引用会导致内存泄漏那为什么的设计者不把也设计成强引用呢或者为什么不把也设计成弱引用为什么不能是强引用假设是强引用那么对象会通过这个强引用着对象只要线程本身不消亡这个强引用链对象就一直存在这意味着即使我们在业务代码中已经不再使用某个对象了比如只要这个线程还在线程池中被复用这个对象本身就永远无法被回收这会导致对象本身的泄漏比现在的情况更糟糕为什么不能是弱引用的核心目的就是让我们存放一些与线程绑定的数据这些数据通常是我们业务逻辑中需要用到的对象比如用户信息对象数据库连接等如果我们把也设计成弱引用那么当一次发生时只要这个对象在其他地方没有被强引用它就可能被意外地回收掉这会导致我们调用时突然得到一个值这完全违背了的设计初衷会引发严重的业务逻辑错误我们存放进去的对象必须保证在之前是可靠存在的所以必须是强引用因此只能做出了个权衡使用弱引用是为了当对象本身在外部不再被使用时能够回收它从而让中的的变为为后续的清理提供了可能性使用强引用是为了保证我们存放的数据的生命周期是可控的不会被意外回收谈谈怎么理解线程安全的线程安全指的是当多个线程同时访问一个对象或方法时无论操作系统如何调度这些线程也无需调用方在代码中去做额外的同步处理都能保证程序的正确性不会出现数据损坏或不一致的情况线程不安全的问题通常会表现在三个方面原子性一个或多个操作作为一个不可分割的整体来进行要去这个操作序列必须由一个线程独占完整的去执行不能被其他线程所干扰调不可被中断可见性一个线程修改了一个共享变量的值这个修改的值能够被其他线程看到但是实际在的高速缓存下对指令做出的重排序操作导致共享变量的值对其他线程不是立即课件的缓存读的旧值有序性写的代码的顺序和实际代码的顺序不一致是由于编译器和处理器层面对指令重排优化导致的可能会导致可见性问题我们可以使用或者是直接加或者是直接加锁或者使用原子类的或者是线程安全的设计内涵面试官提出了一个非常精妙的问题这行代码能编译通过说明肯定存在于中那为什么还需要这个注解呢未能理解系列注解是为了解决通用模块在不同应用环境下的适配性问题而不是为了解决当前项目中的类是否存在的问题确实如果在我当前的项目中写这个条件判断看起来是多余的因为如果不存在我的项目根本无法编译通过这个注解的真正威力体现在开发通用的模块时想象一下我们正在开发一个这个希望能够同时支持阿里云短信和腾讯云短信我们的会提供两个自动配置类和负责创建阿里云短信服务的负责创建腾讯云短信服务的一个使用者应用项目在他的项目中引入了我们的他可能只想使用阿里云短信所以他只会在他的中添加阿里云的依赖而不会添加腾讯云的这时我们的如何智能地判断只加载阿里云的而不去加载腾讯云的呢如果去加载腾讯云的会因为缺少腾讯云的包而直接抛出导致应用启动失败我们就是使用在上我们会这样写当使用者的应用启动时会解析我们中的这两个自动配置类在解析时它会检查当前应用的中是否存在因为使用者添加了阿里云的依赖所以这个类存在条件满足这个配置类就会被加载阿里云的就会被创建在解析时它会检查中是否存在因为使用者没有添加腾讯云的依赖所以这个类不存在条件不满足这个配置类就会被优雅地跳过不会被加载从而避免了并不是为了判断我们自己项目里的类是否存在而是为了让我们开发的通用模块能够智能地感知和适配它所运行的应用环境根据应用环境中引入了哪些依赖来动态地决定哪些功能应该被激活这是实现约定大于配置和开箱即用的关键魔法之一在线程池中的失效问题之所以能够实现父子线程间的数据传递是因为在创建子线程时子线程的构造函数会检查父线程的这个如果它不为空子线程就会将父线程中的所有值拷贝一份到自己的中关键在于这个值的拷贝动作只发生在子线程被创建的那一瞬间在线程池的场景下工作线程通常在系统启动时就已经被预先创建好了并存放在池中当我们提交一个任务时线程池只是从池中取出一个已经存在的线程来执行我们的任务并没有这个动作为了解决这个问题阿里巴巴开源了一个非常强大的工具它专门用于解决在使用线程池等会池化线程的组件时实现父子线程任务提交者与任务执行者之间的上下文传递问题的优点在于它通过或手动包装的方式对线程池的等方法以及任务进行了装饰任务提交时当我们调用被装饰过的时会捕获当前线程父线程的值并将其打包进一个或对象中任务执行前当线程池中的某个工作线程开始执行这个被包装过的时在其方法的块开始处会将被打包的父线程值回放到当前工作线程的中任务执行后在块中会清理当前工作线程的将其恢复到执行任务之前的状态从而避免了数据串扰如何保证三个线程有序执行任务方案使用方案你需要自己管理锁状态变量循环防止伪唤醒保证锁释放代码量大且极易出错使用会唤醒所有等待的线程造成不必要的竞争而使用又存在风险如果错误地唤醒了不该被唤醒的线程比如唤醒了而不是信号就可能丢失导致程序死锁方案升级版提供了比更强大的功能对象则将机制从一个锁只有一个等待队列升级为一个锁可以有多个独立的等待队列我们可以为每个线程的等待室创建一个实现精准的点对点唤醒彻底避免了的信号丢失问题创建一个实例创建一个状态变量例如用于标识当前应该哪个线程执行为每个线程创建一个对象线程的逻辑获取锁在中执行块中执行任务更新状态精准唤醒线程线程和的逻辑与类似分别在自己的上并在执行完任务后更新并下一个线程的实现了有序执行通过实现了精准唤醒比更高效比更安全但还是比较复杂方案信号量接力信号量是控制同时访问特定资源的线程数量的工具我们可以创建两个初始许可为的信号量作为两个线程之间的接力棒创建两个信号量和线程的逻辑执行任务执行完毕后释放一个给的许可线程的逻辑首先尝试获取来自的许可如果许可未被释放将在此阻塞获取到许可后执行任务执行完毕后释放一个给的许可线程的逻辑首先尝试获取来自的许可获取到许可后执行任务代码清晰简单但需要创建个对象如果线程数量很多会增加一些对象管理的开销方案会创建一个单线程的线程池这个线程池的核心特性是它内部有一个无界的来存放任务并且永远只有一个工作线程来从队列中取出并执行任务这就天然地保证了所有提交给它的任务都会严格按照提交的顺序来串行执行创建一个单线程执行器定义三个任务或按顺序提交任务关闭线程池严格来说这是三个任务有序执行而不是三个不同的线程有序执行因为所有任务都是由同一个工作线程来执行的如果面试官的题目严格要求必须是三个不同的预先创建好的线程那么这个方案就不完全符合字面要求这个类为啥要是接口呢的之所以必须定义为接口其根本原因在于框架在底层使用了动态代理技术来为我们自动地生成这个接口的实现类只定义了接口并在文件中写了但我们从来没有手动编写过一个然而在层我们却可以直接注入一个的实例并调用它的方法启动时扫描当容器启动时的会扫描指定的包路径如找到所有被注解标记的接口或者所有继承了特定标记接口的接口注册定义对于找到的每一个接口比如并不会去创建一个真实的实现类而是在容器中注册一个特殊类型的定义创建代理对象当层需要注入时会向请求获取实例此时就会调用动态代理在内存中动态地生成一个接口的代理实现对象这个动态生成的代理对象它的内部有一个当我们调用代理对象的任何方法时比如这个调用都会被拦截的逻辑大致是它会获取到我们调用的方法名和参数它会将方法名与文件中配置的语句的进行映射和绑定它会从连接池获取一个数据库连接将参数设置到语句中然后通过执行这条最后它会将查询结果封装成我们方法签名中定义好的返回类型如对象并返回正是因为依赖于动态代理而动态代理技术本身就要求被代理的目标必须是一个接口它无法为一个具体的类或抽象类创建代理这就是为什么必须是接口的根本技术原因流式输出和非流式输出对比点流式输出非流式输出数据传输边生产边传输生成完后一次传输响应延迟首字节快用户能尽快看到结果必须等所有数据生成后才能看到内存占用占用更少内存分段处理可能占用大量内存一次性加载实现复杂度较高需要支持分段协议推送机制较低一次性返回应用场景视频流日志实时消费逐字打印小文件下载查询一次性返回结果非流式输出是等数据全部生成后一次性返回而流式输出则是边生成边返回能降低延迟和内存占用更适合大数据量和实时场景方法的实现细节首先方法会计算的值根据值定位到它在底层数组中的索引位置即如果该为空直接返回如果不为空则遍历该位置的链表或红黑树逐个节点使用值和方法进行比较直到找到要删除的目标节点如果遍历完没找到也返回如果当前是链表结构是头节点的话即让头节点的下一个节点成为新的头节点是中间节点或尾节点那么就跳过这个节点将自动回收这个不再被引用的节点红黑树的删除操作要复杂得多因为它必须在删除节点后通过一系列的旋转和重新着色操作来维持红黑树的条性质例如根是黑的不能有连续的红节点任何节点到其每个叶子节点的所有路径都包含相同数目的黑色节点等从而保证树的平衡性会调用内部的方法来执行这个复杂的过程在红黑树中删除了一个节点后还会检查该的节点数量如果数量减少到了一个阈值默认为为了节省内存和在节点数少时提升性能这棵红黑树会退化变回普通的链表结构删除成功后的会减方法会返回被删除节点的值多表的时候小表驱动大表在的中驱动表首先被扫描的表被驱动表对驱动表每一行根据条件去查找匹配行的表核心原则过滤后剩余行数少的表应该作为驱动表这样可以减少被驱动表的访问次数这就是小表执行过程扫描驱动表全表扫描或索引扫描对驱动表的每一行根据连接条件在被驱动表中查找通常用索引查找如果被驱动表使用二级索引且需要回表则访问主键索引小表驱动大表大表负责命中索引比如数据库会全表扫然后每拿到一行就去比较条件去表里面查表命中索引的查询实际上就是一个搜索树查询的时间复杂度近似然后加上一次回表可能就是所以总体的时间复杂度为如果是覆盖索引的话复杂度可降为所以我的们越小越好的本质就是查驱动表然后扫被驱动表当然是查的越少越好了一条语句发过来从网络接收开始到最终落盘会经过哪些核心模块的处理是一个分层的核心模块包括网络层层和存储引擎层如果以一条语句为例它的生命周期是这样的网络层首先客户端通过连接发送这条我的网络模块基于实现会接收这个请求并将其传递给层层解析与执行解析器层会解析这条字符串生成一个抽象语法树执行器然后执行器会解释这棵树对于这条语句它知道要去表中找到的行并更新列存储引擎层事务与数据处理这是最核心的部分事务管理器执行器会向事务管理器申请开启一个事务访问数据执行器请求存储引擎去获取的行存储引擎会先去内存缓冲池里查找如果数据页不在内存会通过模块从磁盘加载并发控制在读取和修改数据时为了保证隔离性这里会涉及到和锁管理器是一种当前读所以它会读取最新的已提交版本并在这行数据上加一个排他锁防止其他事务同时修改执行修改获取到锁之后执行器会在中修改对应的数据页但它不是直接覆盖旧数据而是会生成一个日志记录下修改前的样子用于回滚和支持记录日志在修改内存数据页之前必须先将这次操作的详细信息写入日志的内存缓冲区这是为了保证持久性提交事务当客户端发起时日志管理器会确保对应的日志被刷入磁盘只要日志落盘了即使此时宕机数据也能恢复所以我们就可以认为事务提交成功了数据落盘至于里的脏数据页则由一个后台线程根据一定的策略比如异步地刷回磁盘这个过程不影响事务的提交响应为什么选择它相比于直接写数据文件核心优势是什么写日志和更新内存数据页的顺序是怎样的选择的核心优势在于将随机转换为了顺序极大地提升了写入性能并保证了数据不丢失性能提升数据库的数据页在磁盘上是离散存储的修改它们需要大量的随机磁盘寻址非常慢而日志文件是追加写入的是顺序速度比随机快几个数量级通过事务提交时只需要保证日志落盘即可脏数据页可以异步批量地刷回磁盘大大降低了事务提交的延迟顺序保证这个顺序是绝对不能颠倒的必须是先写日志再更新内存页这就是预写日志这个名字的由来原因如果反过来先修改了内存中的数据页然后系统在写日志之前宕机了那么当系统重启时内存中的修改会全部丢失而日志里又没有记录这次操作这个更新就永远地丢失了这违反了事务的持久性而只要保证日志先写入即使系统在数据页刷盘前宕机重启后也可以通过扫描日志来恢复数据保证了数据的完整性当一个叶子节点分裂时具体逻辑是怎样的如何处理并发问题当向一个叶子节点插入数据发现它已经满了的时候会触发分裂操作逻辑如下创建新节点首先创建一个新的兄弟叶子节点找到分裂点计算出当前节点所有记录的中间位置移动数据将中间位置之后的所有记录移动到新的兄弟节点中更新父节点将原中间位置的键值提升到父节点中作为一个新的索引项这个索引项的指针会指向新创建的兄弟节点级联分裂如果插入这个新的索引项导致父节点也满了那么父节点会重复上述的分裂过程这个过程可能会一直级联到根节点最坏情况下会导致树的高度增加关于并发问题这是一个非常关键的点对树的这种结构性修改如分裂或合并必须是原子的否则可能导致树的结构被破坏当一个线程需要修改一个树节点时它会先获取这个节点的在分裂过程中它会同时持有父节点和要分裂的子节点的操作完成后再释放这种方式只锁定了必要的节点允许其他不相关的读写操作继续进行和区别保护对象锁是在事务层面用来保护逻辑数据比如表中的一行记录它的目的是保证事务的隔离性闩锁是在线程层面用来保护内存中的物理数据结构比如中的一个数据页树的一个节点或者一个共享的内存链表它的目的是保证多线程访问共享内存结构时的线程安全持有时间的持有时间很长可能会贯穿整个事务直到事务提交或回滚才释放的持有时间非常短通常只在一次原子操作的临界区内持有比如修改一个树节点操作一完成马上就释放死锁会涉及到死锁问题需要数据库有专门的死锁检测机制而通常通过规定获取顺序比如在树中总是从父节点到子节点获取来避免死锁所以一般认为是无死锁的简单来说是给数据库用户事务用的保证业务逻辑的正确性是给数据库内核开发者用的保证内核数据结构的正确性多级缓存数据一致性与失败回滚当被问及如何保证和本地缓存更新的原子性以及在更新失败时如何回滚你的回答提到了不甚准确的编程式事务并最终倾向于人工处理方案引入消息队列进行可靠的异步处理修改架构不再直接调用消费逻辑而是将解析后的事件作为消息发送到的一个中消费者逻辑消费者服务从拉取消息其处理逻辑是先失效缓存再发布一个广播消息如通过通知所有应用实例失效本地缓存失败处理只有当所有步骤成功后消费者才向发送如果处理过程中任何一步失败如连接超时消费者不发送会在超时后将该消息重新投递给其他消费者实现自动重试方案死信队列在的消费者逻辑中使用等框架对缓存失效操作进行封装配置重试策略例如重试次每次间隔采用指数退避如避免在故障期间频繁冲击下游服务配置一个当所有重试都失败后将这条失败的事件包含表名主键操作类型等信息发送到一个专门的死信队列或记录到数据库的失败任务表中部署一个独立的监控程序或定时任务消费中的消息并发送告警邮件短信钉钉如果重试逻辑设计不当可能会在短时间内放大故障死信队列需要有完善的监控否则会成为被遗忘的角落方案先更新缓存再更新数据库的策略写请求先更新或失效缓存然后更新数据库为了解决并发更新导致的不一致问题可以引入延时双删先删缓存更新数据库延迟一段时间如后再次删除缓存本地缓存仍然可以通过监听的失效事件或消息广播来同步失效非常不推荐延时双删的延迟时间很难确定无法保证一致性代码侵入性强业务逻辑与缓存逻辑耦合严重维护困难什么情况下就是两个线程会持有同一把锁两个不同的线程在同一时刻是不可能持有同一把锁的这是锁的互斥性基本原则所保证的如果出现了这种情况那一定是锁的实现出了严重的问题您这个问题可能是在考察一个非常重要的特性锁的可重入性可重入性指的是同一个线程可以多次成功获取同一把锁而不会自己把自己锁死在释放锁时也需要释放相应次数后锁才会被真正释放比如在一个复杂的业务方法中它获取了锁然后它又调用了另一个方法而方法也需要获取同一个锁如果没有可重入性那么在方法中当前线程会因为无法获取一个已经被自己持有的锁而陷入死锁实现巧妙地使用了的数据结构来实现当一个线程第一次获取锁时它会在中创建一个这个的是锁的名称例如这个结构内部会存储两个关键信息一个存储持有锁的线程标识例如另一个存储一个计数器表示该线程重入的次数初始值为当同一个线程再次尝试获取这把锁时会检查中存储的线程标识如果与当前线程标识匹配它就不会阻塞而是直接将计数器的值加表示又重入了一次当线程释放锁时它会去将计数器减只有当计数器的值减到时才会真正地从中删除这个即释放锁这样其他线程才有机会获取如果挂了怎么办或者到消费端的链路出现长时间中断会发生什么有什么容灾方案吗您提的这个问题非常关键它涉及到整个数据同步链路的高可用性自身的高可用首先自身是可以部署成高可用集群的通过进行集群管理和主备选举当主节点宕机时备用节点可以自动接管从而保证了数据订阅服务的连续性链路中断的影响如果到消费端的链路中断确实会导致缓存与数据库在中断期间的数据不一致窗口期变长新写入的数据无法触发缓存失效用户可能会在一段时间内读到旧的缓存数据我们的容灾与补偿策略监控与告警我们必须对的消费位点与主库的最新位点之间的延迟做严格的监控一旦延迟超过阈值比如分钟就立即触发高级别告警通知和开发团队介入设置合理的缓存即使同步链路中断我们缓存中的数据也不是永久有效的通过为所有缓存设置一个合理的兜底过期时间比如小时可以保证即使在最坏的情况下数据不一致的时间也不会无限延长这是一种自愈机制手动全量增量校准对于极端重要的数据我们会准备一个手动触发的数据校准脚本当链路长时间中断并恢复后可以运行这个脚本根据时间戳或版本号主动查询数据库强制刷新中的核心数据确保最终一致性你提到用的来广播失效本地缓存是即发即忘模式不保证消息必达如果某个应用实例因为网络抖动没收到失效消息怎么办您观察得非常仔细确实存在消息丢失的风险对于这个问题我们有分层级的解决方案接受短暂不一致对于大部分业务场景单台服务器上短暂的本地缓存不一致是可以接受的因为流量通常会通过负载均衡打到多台服务器上只有一小部分用户请求会命中这台机器的旧缓存且本身也有过期机制影响是可控的引入更可靠的消息总线如果业务对一致性要求极高我们会放弃轻量级的转而使用更可靠的消息中间件如的广播消费模式每个应用实例都作为一个消费者组内的广播消费者订阅失效通知的机制可以保证每个实例都可靠地收到失效消息版本号机制我们可以在缓存的对象中增加一个版本号或时间戳字段当应用从缓存中获取到数据后可以在某些关键操作前与数据库中的版本号进行一次快速比对如果发现缓存版本落后就主动失效本地缓存并重新加载这是一种主动校验的补偿机制缓存三问题布隆过滤器和缓存空值这两种方案在你的项目中你会如何选择它们各自有什么优缺点和需要注意的地方方案一缓存空值优点实现简单逻辑清晰开发和维护成本极低效果直接能拦截住对同一个不存在的的重复攻击缺点与注意事项消耗额外的缓存空间如果被恶意攻击攻击者不断变换不存在的来查询会导致中存储大量的空值造成内存浪费数据一致性问题如果这个之前不存在的数据后来又在数据库中被创建了例如一个新用户注册了缓存中的空值需要有一种机制被及时地更新或失效否则会导致用户刚注册完却查不到自己的信息适用于不存在的的集合相对固定或者重复查询率高的场景例如查询一个已经下架的商品方案二布隆过滤器优点空间效率极高它使用位图来存储数据占用的内存空间远小于缓存空值方案非常适合处理海量数据缺点与注意事项存在误判率布隆过滤器判断不存在是准确的但判断存在时有一定概率会把一个不存在的误判为存在这意味着它无法完全拦截所有穿透请求会有一小部分漏网之鱼打到数据库无法删除元素标准的布隆过滤器不支持删除操作如果数据需要频繁地增删就需要使用等变种实现更复杂初始化和重建成本需要在系统启动时将全量数据加载到布隆过滤器中这个过程可能比较耗时当数据发生变化时也需要有机制来同步更新过滤器适用场景适用于数据量巨大但数据相对稳定且对误判率有一定容忍度的场景例如防止恶意用户用随机生成的来攻击用户查询接口用户在分钟之内连续输错三次密码就禁止其登录如果使用你会选择哪种数据结构来实现方案使用的命令是原子性的可以保证在并发环境下计数的准确性命令可以为一个设置生存时间完美地契合了分钟之内这个时间窗口的需求定义为每个用户的登录失败计数定义一个清晰的例如登录失败逻辑当用户登录失败时执行以下操作对该用户的执行命令获取增长后的计数值判断是否是第一次失败如果等于说明这是分钟窗口内的第一次失败此时必须为这个设置过期时间秒分钟检查是否达到阈值判断是否大于等于如果是则触发锁定用户的逻辑例如在数据库中更新用户状态或在另一个中设置一个锁定标记登录成功逻辑当用户登录成功时应该立即删除这个计数以清除之前的失败记录问题存在一个微小的竞态条件在和两个命令之间如果服务器恰好宕机或重启可能会导致一个计数被创建但没有设置过期时间从而变成一个永久的计数器虽然概率极低但在高并发系统中仍需考虑解决方案可以使用脚本将和两个操作打包成一个原子操作或者使用一条命令完成方案灵活精确作为失败记录队列的是一个双向链表可以作为队列使用通过在队头插入元素修剪队列长度可以非常高效地维护一个固定大小的事件窗口定义登录失败逻辑获取当前时间戳秒或毫秒并将其作为元素到的头部检查当前失败次数获取的长度如果大于等于说明已经发生了至少次失败此时获取中第个元素即最早的那次失败记录索引为判断时间窗口计算当前时间与的时间差如果差值小于分钟则说明在分钟内发生了次失败触发锁定逻辑队列维护为了防止无限增长可以在每次后使用命令只保留最近的条记录同时为整个设置一个比分钟稍长的过期时间如分钟用于自动清理冷数据登录成功逻辑同方案一掉对应的实现了精确的时间窗口判断内存占用非常小因为每个用户的最多只存储个时间戳方案三功能强大实现滑动时间窗口的是一个有序集合每个成员都关联一个我们可以用来存储事件发生的时间戳利用按分数范围查询和删除的特性完美地实现滑动时间窗口定义登录失败逻辑获取当前时间戳为了防止成员重复可以给每个成员一个唯一的值例如将新的失败记录添加到中和都使用时间戳或是时间戳是唯一清理过期记录移除所有分钟之前的记录这是一个非常关键的步骤保证了窗口的滑动假设是毫秒统计窗口内次数获取当前中的成员数量检查阈值如果大于等于触发锁定逻辑登录成功逻辑同方案一掉对应的消息队列消息积压处理当被问及线上消息积压如何处理时你的第一反应是清空队列然后恢复这在线上环境中是绝对禁止的操作在引导下你提到了扩容消费者方案紧急扩容消费者并监控下游依赖监控分析在扩容前必须先快速查看消费者应用的内存情况以及其下游依赖如数据库外部的负载情况确认瓶颈在于消费者本身而不是下游水平扩容如果瓶颈在消费者立即增加消费者实例数量在等云原生环境中可以通过调整的数量快速实现注意数量确保消费者实例数不超过的数量因为多余的消费者将处于空闲状态方案消息转储与异步回补编写转储程序快速开发一个简单的程序它的唯一作用就是消费积压中的消息然后原封不动地存储到另一个临时或一个临时存储如文件数据库中启动转储启动该程序快速将积压消息搬空修复与回补在修复了原始消费者的或性能问题后再编写一个回补程序以一个受控的速率从临时或存储中读取消息重新发送回原始进行处理以空间换时间快速恢复线上新消息的处理能力为修复问题和处理积压数据赢得时间方案优化消费逻辑并临时提升处理能力代码审查快速排查消费逻辑寻找性能瓶颈常见的优化点包括将单条处理改为批量处理将同步调用外部改为异步并行调用优化查询减少不必要的数据库交互紧急上线快速修复并上线优化后的代码比如说你提到扩容消费者来解决积压假设现在是双十一零点流量洪峰导致了严重积压而下游的数据库集群负载也已经很高了此时你作为负责人应该如何决策直接扩容消费者吗面试官这是一个非常经典的雪崩前兆场景决策的核心是止损和降级而不是盲目地增加压力我的决策流程会是这样的立即止损保护核心系统绝对不能直接扩容消费者因为监控显示下游数据库已经高负载扩容消费者只会变成压垮数据库的最后一根稻草导致核心系统崩溃造成更大的故障立即对消费者进行限流甚至暂停我会立即调整消费者的消费速率甚至在极端情况下通过配置中心或运维指令暂停非核心业务的消费优先保住数据库的稳定业务降级保障核心链路我会立即与产品和业务方沟通启动业务降级预案例如关闭非核心功能暂时关闭实时用户积分更新推荐商品刷新等非核心功能的消费将资源和数据库资源全部让给核心交易链路如下单支付异步转同步对于某些可以接受延迟的业务可以暂时将消息积压在中等高峰期过后系统负载降低了再慢慢处理流量削峰与后续处理利用的积压能力此时本身就扮演了一个天然的流量削峰器的角色大量的请求被积压在队列中而不是直接冲击后端系统这正是我们使用的一个重要原因高峰后恢复等到流量洪峰过去数据库负载下降后我们再逐步分批地恢复被暂停的消费者并可以适当地增加消费者实例以一个受控的速率慢慢地将积压的消息消费完毕复盘与改进事后我们会进行深入复盘分析是数据库容量预估不足还是存在性能问题或者是消费者逻辑有待优化并根据分析结果进行数据库扩容优化或引入更精细化的流量控制策略为下一次大促做好准备我的核心决策原则是牺牲非核心业务的实时性来换取核心系统的稳定性和可用性消费者组的对应你刚刚说的就是一个消费者端然后去对应一个相当于一个然后为什么要一一对应呢核心原因保证分区内的消息顺序性一个在同一个消费者组内同一时间只能被一个消费理论依据只在单个内部保证消息的有序性也就是说生产者以的顺序发送到同一个的消息消费者也必须以的顺序来消费它们机制实现为了实现这个保证必须规定一个在任意时刻只能被一个消费者实例锁定并消费如果允许多个消费者同时消费同一个那么消息的消费顺序将无法得到保证因为无法协调哪个消费者先处理哪条消息这将彻底破坏的顺序性承诺实现高并发以为并行处理的最小单元理论依据虽然单个是顺序处理的但通过将一个划分为多个来实现整体的高并发机制实现整个的吞吐量等于所有吞吐量的总和我们可以通过增加的数量来水平扩展的处理能力消费者协同消费者组内的多个消费者实例会通过再均衡机制自动协调分配它们各自负责消费的例如一个有个的如果消费者组有个消费者理想情况下就是每个消费者负责一个此时并行度达到最大设计模式当被问及如何在多个接口中统一管理以避免代码重复时你的初步想法是提取一个公共方法面试官进一步引导你思考过滤器和拦截器方案使用的拦截器是提供的实现专门用于在方法执行前后进行预处理和后处理它与请求生命周期紧密耦合是处理用户认证日志记录上下文设置等横切关注点的标准方式创建一个类实现接口在方法中从请求如中获取解析出用户信息然后调用工具类的方法将用户信息存入在方法中无论方法执行成功还是失败都调用工具类的方法清理通常放在块中以确保执行创建一个配置类实现重写方法将你的拦截器注册到容器中并配置其拦截路径如方案使用的过滤器创建一个类实现接口在方法中在调用之前执行的操作使用结构在块中执行的操作确保无论后续处理是否异常都能清理资源使用和注解或通过将注册为与类似实现了解耦和统一管理由于作用范围更广可以拦截静态资源等非处理的请求方案使用自定义切面创建一个类并使用和注解定义一个切点例如用于匹配所有类中的方法创建一个环绕通知在通知方法的块中执行的操作然后调用执行目标方法在块中执行操作功能上与前两者类似但提供了最大的灵活性可以切入到层甚至任意的方法通知需要手动调用如果忘记调用目标方法将不会被执行策略方法怎么去解决具体调用哪一个策略为了避免在业务代码中使用大量的或来选择策略我们创建了一个策略工厂在项目启动时容器会扫描并加载所有的实现类我们创建一个类它在构造时注入一个会自动将所有策略实现类注入到这个中其中是的名称例如是实例我们约定优惠券类型例如与名称有映射关系工厂类提供一个方法当业务代码需要使用某个策略时它只需要传入优惠券类型字符串工厂就会从中返回对应的策略对象我们完全消除了业务代码中的判断当未来需要增加一种新的优惠券时我们只需要新增一个策略实现类而不需要修改任何现有的业务逻辑代码这完全符合开闭原则使得系统非常易于扩展和维护异常解决就比如说你这个部署到线上了然后他抛了一个异常然后那你这个应该怎么排查呢线上出现异常我会遵循一套从宏观到微观由表及里的排查标准作业程序来定位和解决问题第一步信息收集与初步判断确认影响范围首先快速判断这个异常的影响面有多大是影响了所有用户还是部分用户是核心功能还是边缘功能这决定了问题的紧急程度查看监控告警立即查看监控系统如的告警信息检查应用的关键指标如应用层面响应时间错误率是否突增层面使用率内存占用活动是否异常主机层面服务器的内存磁盘网络流量是否正常依赖服务数据库等中间件的健康状况如何这一步的目标是快速定位问题是出在应用本身还是外部依赖第二步日志分析与精准定位聚合日志平台检索登录或类似日志平台根据告警信息中的时间点错误信息关键字如进行检索利用进行链路追踪如果系统接入了分布式追踪系统如这是最强大的工具我会根据报错信息找到一个然后用这个查询完整的请求调用链这可以清晰地看到请求经过了哪些服务在哪一个环节耗时最长又是在哪个服务的具体代码行抛出了异常服务器手动排查作为补充如果日志平台不完善我会登录到具体的服务器上进行排查使用命令根据关键字快速过滤日志可以显示异常上下文的行帮助理解问题背景如果需要根据查我会用对于实时滚动的日志我会用来实时监控错误输出第三步根因分析与问题复现代码分析定位到具体的异常代码后分析代码逻辑判断是业务逻辑错误空指针并发问题还是资源未释放等环境复现如果可能尝试在测试环境或预发环境构造相同的参数和条件复现这个问题以便于调试和验证修复方案第四步问题解决与复盘紧急修复如果是严重立即进行修复并上线如果是资源问题进行扩容或配置调整复盘总结问题解决后必须进行复盘分析问题发生的根本原因是代码缺陷设计不合理还是容量预估不足并制定改进措施例如增加单元测试完善监控告警优化架构等防止同类问题再次发生',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-08-19 19:56:22',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 1.05rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 1.05rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 1.05rem;">FI<sup>1</sup></a><a href="/tags/Github/" style="font-size: 1.05rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/football/" style="font-size: 1.05rem;">football<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>57</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>10</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>17</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>7</sup></a><a href="/tags/paper/" style="font-size: 1.05rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 1.05rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>4</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>3</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 1.05rem;">毛选<sup>1</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>27</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url">面经</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">面试面经优化回答</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-19T11:56:22.262Z" title="更新于 2025-08-19 19:56:22">2025-08-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">16.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="面试面经优化回答"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510095.jpg?_r_=a3e34e80-83d8-f14a-7a77-4502d78a2aee"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url">面经</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">面试面经优化回答</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time><time itemprop="dateCreated datePublished" datetime="2025-08-19T11:56:22.262Z" title="更新于 2025-08-19 19:56:22">2025-08-19</time></header><h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="1-SpringBoot的配置加载优先级"><a href="#1-SpringBoot的配置加载优先级" class="headerlink" title="1.SpringBoot的配置加载优先级"></a>1.SpringBoot的配置加载优先级</h2><p>首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：</p>
<ol>
<li><p>先是<strong>命令行参数</strong>（<code>--server.port=9000</code> 或 <code>java -jar app.jar --spring.config.location=...</code>）</p>
</li>
<li><p>然后是我们的系统的环境变量和JVM系统属性，比如设置端口为8080，比如我们在这里设置API的KEY</p>
</li>
<li><p>然后<strong><code>RandomValuePropertySource</code></strong>（<code>random.*</code> 占位符，用于生成随机数/字符串，可在配置中引用）</p>
</li>
<li><p>接着是<strong>外部配置文件</strong>（properties / yml）</p>
<ul>
<li><p>JAR 包外部的 <code>./config/</code></p>
</li>
<li><p>JAR 包外部的 <code>./</code></p>
</li>
<li><p>JAR 包内部的 <code>classpath:/config/</code></p>
</li>
<li><p>JAR 包内部的 <code>classpath:/</code></p>
</li>
</ul>
</li>
<li><p>接着是我们@PropertySource注解指定的配置</p>
</li>
<li><p>最后是我们Springboot默认的配置</p>
</li>
</ol>
<p>然后在配置文件中，properties的配置大于yml，因为springboot是按加载顺序来的，后加载的properties把yml的值给覆盖了</p>
<p>对于外部配置文件，查找路径的优先级为：</p>
<ol>
<li><code>./config/</code>（当前目录下的config目录）</li>
<li><code>./</code>（当前目录）</li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ol>
<p>实际应用:</p>
<p><strong>基础配置</strong>：放在 <code>classpath:/application.yml</code></p>
<p><strong>环境特定配置</strong>：使用 <code>application-&#123;profile&#125;.yml</code>（如 <code>application-prod.yml</code>），通过 <code>--spring.profiles.active=prod</code> 激活</p>
<p><strong>敏感信息</strong>：放在环境变量或外部化配置文件（避免入库）</p>
<p><strong>临时调试/测试</strong>：使用命令行参数临时覆盖</p>
<p><strong>多环境冲突处理</strong>：利用 profile 合并特性，公共配置放在 <code>application.yml</code>，环境差异放在对应 profile 文件</p>
<h2 id="2-Springboot是如何解决跨域问题的？"><a href="#2-Springboot是如何解决跨域问题的？" class="headerlink" title="2.Springboot是如何解决跨域问题的？"></a>2.Springboot是如何解决跨域问题的？</h2><p>基本都是基于CORS（跨域资源共享）通过设置响应头（如 <code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>）告诉浏览器允许访问。</p>
<p>对于复杂跨域请求（非 GET/POST/HEAD 或自定义头），浏览器会先发 <strong>OPTIONS 预检请求</strong>。</p>
<ol>
<li>局部注解，用@CrossOrigin标记单个接口，秒开跨域权限，适合快速测试。简单高效，优先级高于全局配置</li>
<li>全局配置，使用WebMvcConfigurer接口，统一设定允许的域名，请求方法，头信息。统一配置，但是不适合动态的控制</li>
<li>用CorsFilter手动处理跨域逻辑处理，适合需要动态校验权限等特殊场景，比如不同权限开放不同接口，在过滤器中动态判断，但是实现成本较高</li>
<li>在微服务架构中，也可以在<strong>网关层</strong>（如 Spring Cloud Gateway、Nginx）统一处理跨域，减少业务服务配置。</li>
</ol>
<p>优先级：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin` &gt; `WebMvcConfigurer` &gt; `CorsFilter</span><br></pre></td></tr></table></figure>
<h2 id="3-Spring-解决循环依赖"><a href="#3-Spring-解决循环依赖" class="headerlink" title="3.Spring 解决循环依赖"></a>3.<strong>Spring 解决循环依赖</strong></h2><p><strong>既然Spring能解决循环依赖，那为什么我们还经常听说‘构造器注入无法解决循环依赖’？三级缓存对构造器注入为什么无效？</strong></p>
<p>您问到了Spring循环依赖解决方案的一个核心<strong>前提</strong>。三级缓存之所以能工作，其根本在于它将<strong>Bean的实例化（Instantiation）\</strong>和*<em>属性填充（Population）*<em>这两个阶段**分离开来</em></em>了。</p>
<ul>
<li><strong>第一步：实例化</strong>。Spring首先通过<strong>无参构造函数</strong>创建了Bean A的一个“空壳”实例。这个实例已经有了自己的内存地址。</li>
<li><strong>第二步：暴露早期引用</strong>。紧接着，Spring立即将这个“空壳”实例的工厂（ObjectFactory）放入三级缓存，从而<strong>提前暴露</strong>了A的引用。</li>
<li><p><strong>第三步：属性填充</strong>。然后Spring才开始尝试为A注入属性，此时发现需要B，就去创建B。当B需要A时，可以从三级缓存中获取到A的早期引用，从而打破循环。</p>
<p><strong>构造器注入的工作流程</strong>:</p>
</li>
<li><p>对于构造器注入，<strong>Bean的实例化和属性填充这两个阶段是合并在一起的，是原子性的</strong>。</p>
</li>
<li>当Spring尝试创建Bean A时，它必须调用A的构造函数。而A的构造函数需要一个Bean B的实例作为参数。</li>
<li>为了满足这个参数，Spring必须先去创建Bean B。</li>
<li>而当Spring尝试创建Bean B时，又发现B的构造函数需要一个Bean A的实例作为参数。</li>
<li>此时，<strong>Bean A的实例根本还没有被创建出来</strong>（它还卡在等待B的阶段），内存中不存在任何A的“空壳”实例，三级缓存中自然也就不可能有任何关于A的引用。</li>
<li>这就形成了一个无法解开的死结：A的创建依赖B的创建，B的创建又依赖A的创建。因此，Spring会直接抛出<code>BeanCurrentlyInCreationException</code>。</li>
</ul>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1-线程池常见的坑"><a href="#1-线程池常见的坑" class="headerlink" title="1.线程池常见的坑"></a>1.线程池常见的坑</h2><ol>
<li><p>线程池的参数配置：核心线程的数量，和最大线程的数量是业务场景来的，CPU密集型，比如数据的计算业务，就是CPU的数量+1。</p>
<p>IO密集型根据业务压测的值来决定的，最佳线程数=（（线程等待时间+线程CPU时间）/线程CPU时间）*CPU数量</p>
</li>
</ol>
<p>比如，我们服务器CPU核数为8核，任务线程CPU耗时20ms,线程等待等等耗时80ms，那么最佳线程数=（80+20）/20*8=40线程，那我们最大线程数就是80个</p>
<ol>
<li>共享线程池，次要的逻辑拖垮主要的逻辑。避免所有的业务都共享一个线程池，防止一个次要的业务一直在执行业务，占用线程池。而主要的业务并没有足够的线程数来执行，影响到了我们主要的服务。这样做是不合理的。我们应该要做线程池的隔离，使用Future.get方法的时候，使用带超时时间的，因为他是阻塞的，防止被其他抢占。</li>
<li>@Async是Spring中一个注解，他不是线程池，他其实是SimpleAsyncTaskExecutor，不会复用线程，适合执行大量短时间的线程。还是尽量自己定义一个异步的线程池，然后使用@EnableAsync来注册</li>
<li>使用线程池的时候，不使用threadfactory参数来自定义命名，这样导致后期不好排查问题和回溯问题</li>
<li>使用submit提交任务，不会把异常直接抛出来。最好我们在submit之中进行try-catch进行捕获，或者是在 <code>Future.get()</code> 时捕获并记录异常。</li>
<li>线程池使用完之后，记得关闭，防止内存泄漏的问题。最好线程池设计成单例的模式。长期运行的全局线程池（如 Spring 管理的）不需手动关闭，临时线程池需在 finally 中调用 <code>shutdown()</code>。</li>
<li><p>线程池不要和事务一起使用，使用@Transtation的时候，依赖于当前线程的线程上下文，而线程池的线程和当前事务的线程不是一个线程，事务的上下文不会传递，导致线程池中的业务代码不在事务中执行，事务就失效了。我们可以将事务放在线程池之外进行，这是最好的方法，或者是使用支持事务上下文传递的机制（如 <code>TransactionAwareDataSourceProxy</code>、消息队列保证一致性）</p>
</li>
<li><p>我们要负责监控线程池状态，比如当前活跃的线程池的数量，队列的长度，拒绝的次数</p>
</li>
<li>要配置合理的拒绝策略，比如一个需要快速获取结果的线程，就需要胚子和callerrunpolicy，这样的话，谁提交谁执行，回退给调用的线程。</li>
</ol>
<h2 id="2-AQS的大局解析"><a href="#2-AQS的大局解析" class="headerlink" title="2.AQS的大局解析"></a>2.AQS的大局解析</h2><p>AQS是JUC里面的一个抽象同步框架，核心的作用就是统一分装了线程的等待唤醒排队机制。</p>
<p>底层通过一个volatile的state变量+FIFO的队列来实现线程安全的资源性抢夺</p>
<p>state表示资源的状态，独占锁里面0没人占，1就是已经上锁。可重入锁里面数字代表可重入的次数</p>
<p>线程要抢不到锁，就会被挂到队列里面进行排队，队列是双向链表实现的CLH队列，节点记录了等待状态，信息等</p>
<p>他只是一个框架，真正的锁逻辑交给实现类自己决定</p>
<h2 id="3-wait和sleep的区别"><a href="#3-wait和sleep的区别" class="headerlink" title="3.wait和sleep的区别"></a>3.wait和sleep的区别</h2><p>wait()和sleep()的主要区别在于：1. 所属类不同，wait()是Object类的方法，sleep()是Thread类的静态方法；2. wait()会释放对象锁，而sleep()保持锁不释放；3. wait()必须在同步代码块中调用，sleep()没有此限制；4. wait()需要notify()或notifyAll()来唤醒，而sleep()在超时或被中断时自动恢复；5. 使用场景上，wait()用于线程间的协作，sleep()用于简单的延时操作。</p>
<p>wait()方法使当前线程进入等待状态，将其从运行状态转变为等待状态，并将其加入到等待池中。</p>
<h2 id="4-异步编排"><a href="#4-异步编排" class="headerlink" title="4.异步编排"></a>4.<strong>异步编排</strong></h2><p>在我看来，<strong>异步编排的核心思想是，将多个独立的、耗时的异步任务（尤其是I/O密集型任务）组合、编排起来，让它们尽可能地并行执行，最终汇总结果，从而极大地缩短整体的响应时间。</strong> 这在微服务架构中尤其重要。</p>
<p>在现代Java开发中，实现异步编排最核心的工具就是 <strong><code>CompletableFuture</code></strong></p>
<p>举一个我们项目中非常典型的例子：<strong>获取‘商品详情页’数据</strong>。一个商品详情页通常需要展示多种信息，而这些信息可能来自不同的微服务或数据库表：</p>
<ul>
<li><strong>任务A</strong>：调用商品服务，获取商品基本信息。</li>
<li><strong>任务B</strong>：调用用户服务，获取当前用户的优惠券信息。</li>
<li><strong>任务C</strong>：调用评论服务，获取商品的热门评论。</li>
<li><strong>任务D</strong>：调用推荐服务，获取相关商品推荐。</li>
</ul>
<p>如果采用传统的同步调用方式，总耗时将是 <code>A + B + C + D</code> 的累加。但实际上，这四个任务<strong>没有任何依赖关系，完全可以并行执行</strong>。通过异步编排，理想情况下的总耗时将仅仅取决于<strong>耗时最长的那一个任务</strong>，即 <code>Max(A, B, C, D)</code>，性能会得到指数级的提升。</p>
<p>实现：</p>
<ol>
<li><strong>任务并行化</strong>：为每一个独立的调用任务创建一个<code>CompletableFuture</code>实例。关键是使用<code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code>方法，并为其<strong>提供一个自定义的线程池</strong>。这可以避免耗尽Web服务器（如Tomcat）的业务线程池。</li>
<li><strong>结果编排与组合</strong>：当所有并行的任务都完成后，我需要将它们的结果组合成一个最终的<code>ProductDetailPageDTO</code>。我会使用<code>CompletableFuture.allOf()</code>来等待所有任务完成。</li>
<li><strong>最终结果处理</strong>：在<code>allOf()</code>完成后，通过<code>thenApply()</code>或<code>thenAccept()</code>来执行最终的组装逻辑。</li>
<li><strong>异常处理与超时控制</strong>：在生产环境中，还需要考虑健壮性。我会使用<code>exceptionally()</code>来处理任何一个异步任务的失败，返回一个默认值或降级数据。同时，使用<code>orTimeout()</code>为整个编排流程设置一个最大等待时间，防止因为某个下游服务缓慢而导致整个请求长时间阻塞。</li>
</ol>
<h2 id="5-synchronized-锁升级的“细节追问"><a href="#5-synchronized-锁升级的“细节追问" class="headerlink" title="5.synchronized 锁升级的“细节追问"></a>5.<strong><code>synchronized</code> 锁升级的“细节追问</strong></h2><p>1.<strong>线程是如何从‘偏向锁’升级到‘轻量级锁’的？JVM是如何判断‘偏向’失效的</strong></p>
<p>“偏向锁的核心思想是，它‘偏向’于第一个获取它的线程，认为在接下来的执行中，锁将一直被这个线程持有。</p>
<ol>
<li><strong>偏向状态</strong>：当一个线程第一次获取锁时，JVM会通过<strong>CAS操作</strong>，尝试将锁对象头（Mark Word）中的<strong>线程ID</strong>指向当前线程。如果成功，就获取了偏向锁。</li>
<li><strong>升级触发点</strong>：当<strong>另一个线程</strong>（线程B）尝试获取这个已经被线程A持有的偏向锁时，升级过程就被触发了。</li>
<li><strong>偏向锁的撤销</strong>：<ul>
<li>首先，线程B的CAS操作会失败。JVM会检查Mark Word中记录的线程ID是否是线程A。</li>
<li>JVM会暂停线程A（在一个<strong>全局安全点</strong>），然后检查线程A是否还存活。</li>
<li>如果线程A<strong>已经执行完毕</strong>，那么锁对象恢复到无锁状态，线程B可以重新尝试获取。</li>
<li>如果线程A<strong>仍然存活且还在同步块内</strong>，说明发生了真正的竞争。此时，偏向锁就会被<strong>撤销（Revoke）</strong>。锁对象头的Mark Word会被修改，清除偏向锁标志，并升级为<strong>轻量级锁</strong>的状态。同时，线程A的栈帧中会创建锁记录（Lock Record），指向锁对象。</li>
<li>之后，线程A和线程B都会在轻量级锁的状态下进行竞争（通过自旋）。</li>
</ul>
</li>
<li>只不过目前在<strong>JDK 15</strong> 中被 <strong>默认禁用</strong>，并在 <strong>JDK 18</strong> 被 <strong>完全移除</strong>。因为偏向锁的撤销消耗的性能是比较大的</li>
</ol>
<p>2.<strong>那轻量级锁又是如何升级到重量级锁的？‘自旋’失败后发生了什么？</strong></p>
<p>轻量级锁的核心思想是，它认为锁的竞争时间会非常短，线程只需要‘稍等一下’（自旋），就可以拿到锁，从而避免了线程阻塞和唤醒带来的内核态切换开销。</p>
<ol>
<li><strong>轻量级锁的获取</strong>：线程在自己的栈帧中创建锁记录（Lock Record），然后通过<strong>CAS操作</strong>尝试将锁对象的Mark Word指向这个锁记录。如果成功，就获取了轻量级锁。</li>
<li><strong>自旋等待</strong>：如果CAS失败，说明锁已被其他线程持有。当前线程并不会立即阻塞，而是会进行<strong>自旋</strong>，即执行一个空循环，不断地重试CAS操作。</li>
<li><strong>升级触发点</strong>：升级到重量级锁主要有两种情况：<ul>
<li><strong>自旋失败</strong>：自旋的次数是有限的（JVM会动态调整，比如10次）。如果一个线程自旋了指定次数后，仍然没有获取到锁，JVM就认为竞争已经非常激烈了，不适合再空耗CPU。</li>
<li><strong>竞争者过多</strong>：如果在自旋过程中，又有<strong>第三个线程</strong>也来竞争这把锁，那么也会立即触发升级。</li>
</ul>
</li>
<li><strong>锁膨胀（Inflation）</strong>：<ul>
<li>一旦触发升级，锁就会<strong>膨胀</strong>为重量级锁。</li>
<li>锁对象的Mark Word会被修改，指向一个重量级锁的监视器对象（Monitor）。</li>
<li>所有等待锁的线程（包括正在自旋的线程和后来者）都<strong>不再自旋</strong>，而是会被<strong>阻塞</strong>，并放入Monitor的等待队列中。</li>
<li>当持有锁的线程释放锁时，会唤醒等待队列中的一个线程，进行新一轮的锁竞争。这个过程就涉及到了操作系统的互斥量（Mutex）和线程的上下文切换。</li>
</ul>
</li>
</ol>
<p>锁的升级是<strong>单向的</strong>，只能从低级别到高级别，不能降级（在HotSpot JVM的实现中）。</p>
<h2 id="6-ThreadLocal"><a href="#6-ThreadLocal" class="headerlink" title="6.ThreadLocal"></a>6.ThreadLocal</h2><p><strong>既然<code>key</code>用弱引用会导致内存泄漏，那为什么<code>ThreadLocalMap</code>的设计者不把<code>key</code>也设计成强引用呢？或者，为什么不把<code>value</code>也设计成弱引用</strong></p>
<p> 1.<strong>为什么Key不能是强引用？</strong></p>
<ul>
<li>假设Key是强引用。那么<code>Thread</code>对象会通过<code>threadLocals</code>这个Map强引用着<code>ThreadLocal</code>对象（Key）。只要线程本身不消亡，这个强引用链（<code>Thread</code> -&gt; <code>ThreadLocalMap</code> -&gt; <code>Entry</code> -&gt; <code>ThreadLocal</code>对象）就一直存在。</li>
<li>这意味着，即使我们在业务代码中已经不再使用某个<code>ThreadLocal</code>对象了（比如，<code>myThreadLocal = null;</code>），只要这个线程还在线程池中被复用，这个<code>ThreadLocal</code>对象本身就<strong>永远无法被GC回收</strong>。这会导致<code>ThreadLocal</code>对象本身的泄漏，比现在的情况更糟糕。”</li>
</ul>
<p>2.<strong>为什么Value不能是弱引用？</strong></p>
<ul>
<li><code>ThreadLocal</code>的核心目的就是让我们存放一些与线程绑定的<strong>数据（Value）</strong>。这些数据通常是我们业务逻辑中需要用到的对象，比如用户信息对象、数据库连接等。</li>
<li>如果我们把Value也设计成弱引用，那么当一次GC发生时，<strong>只要这个Value对象在其他地方没有被强引用，它就可能被意外地回收掉</strong>。</li>
<li>这会导致我们调用<code>threadLocal.get()</code>时，突然得到一个<code>null</code>值，这完全违背了<code>ThreadLocal</code>的设计初衷，会引发严重的业务逻辑错误。我们存放进去的对象，必须保证在<code>remove()</code>之前是可靠存在的。所以，<strong>Value必须是强引用</strong>。”</li>
</ul>
<p>因此只能做出了个权衡：</p>
<ul>
<li><strong>Key使用弱引用</strong>：是为了当<code>ThreadLocal</code>对象本身在外部不再被使用时，GC能够回收它，从而让Map中的Entry的key变为<code>null</code>，为后续的清理（expungeStaleEntry）提供了可能性。</li>
<li><strong>Value使用强引用</strong>：是为了保证我们存放的数据的生命周期是可控的，不会被GC意外回收。</li>
</ul>
<h2 id="7-谈谈怎么理解线程安全的"><a href="#7-谈谈怎么理解线程安全的" class="headerlink" title="7.谈谈怎么理解线程安全的"></a>7.谈谈怎么理解线程安全的</h2><p><strong>线程安全</strong>指的是当多个线程同时访问一个对象或方法时，无论操作系统如何调度这些线程，也无需调用方在代码中去做额外的同步处理，都能保证程序的正确性，不会出现数据损坏或不一致的情况。</p>
<p>线程不安全的问题通常会表现在三个方面</p>
<ol>
<li>原子性：一个或多个操作作为一个不可分割的整体来进行，要去这个操作序列，必须由一个线程独占完整的去执行，不能被其他线程所干扰，调不可被中断。i++</li>
<li>可见性：一个线程修改了一个共享变量的值，这个修改的值能够被其他线程看到。但是实际在CPU的高速缓存下，对指令做出的重排序操作，导致共享变量的值，对其他线程不是立即课件的。缓存读的旧值</li>
<li>有序性：写的代码的顺序和实际代码的顺序不一致，是由于编译器和处理器层面对指令重排优化导致的，可能会导致可见性问题</li>
</ol>
<p>我们可以使用voliate或者是直接加synchronized，或者是直接加锁</p>
<p>或者使用原子类的CAS，或者是线程安全的ThreadLocal</p>
<h2 id="8-ConditionalOnClass设计内涵"><a href="#8-ConditionalOnClass设计内涵" class="headerlink" title="8.@ConditionalOnClass设计内涵"></a>8.<strong><code>@ConditionalOnClass</code></strong>设计内涵</h2><p>面试官提出了一个非常精妙的问题：“<code>@ConditionalOnClass(User.class)</code>这行代码能编译通过，说明<code>User.class</code>肯定存在于classpath中，那为什么还需要这个注解呢？</p>
<p>未能理解<code>@Conditional</code>系列注解是为了解决<strong>通用starter模块在不同应用环境下的适配性</strong>问题，而不是为了解决当前项目中的类是否存在的问题。</p>
<p>确实，如果在我当前的项目中写<code>@ConditionalOnClass(User.class)</code>，这个条件判断看起来是多余的。因为<code>User.class</code>如果不存在，我的项目根本无法编译通过。</p>
<p>这个注解的真正威力体现在<strong>开发通用的starter模块</strong>时。想象一下，我们正在开发一个<code>my-sms-spring-boot-starter</code>，这个starter希望能够同时支持<strong>阿里云短信</strong>和<strong>腾讯云短信</strong>。</p>
<ul>
<li>我们的starter会提供两个自动配置类：<code>AliyunSmsAutoConfiguration</code> 和 <code>TencentSmsAutoConfiguration</code>。</li>
<li><code>AliyunSmsAutoConfiguration</code>负责创建阿里云短信服务的Bean。</li>
<li><p><code>TencentSmsAutoConfiguration</code>负责创建腾讯云短信服务的Bean。</p>
</li>
<li><p>一个<strong>使用者（应用项目）\</strong>在他的项目中引入了我们的starter。他可能只想使用阿里云短信，所以他只会在他的<code>pom.xml</code>中添加*<em>阿里云的SDK依赖*</em>，而不会添加腾讯云的。</p>
</li>
<li>这时，我们的starter如何智能地判断只加载阿里云的Bean，而不去加载腾讯云的Bean呢？（如果去加载腾讯云的Bean，会因为缺少腾讯云SDK的jar包而直接抛出<code>ClassNotFoundException</code>，导致应用启动失败）</li>
<li>我们就是使用@ConditionalOnClass</li>
</ul>
<p>在<code>AliyunSmsAutoConfiguration</code>上，我们会这样写,@ConditionalOnClass(com.aliyun.sms.sdk.SmsClient.class) </p>
<ul>
<li>当使用者的应用启动时，Spring Boot会解析我们starter中的这两个自动配置类。</li>
<li>在解析<code>AliyunSmsAutoConfiguration</code>时，它会检查<strong>当前应用的classpath</strong>中是否存在<code>com.aliyun.sms.sdk.SmsClient.class</code>。因为使用者添加了阿里云的SDK依赖，所以这个类存在，条件满足，这个配置类就会被加载，阿里云的Bean就会被创建。</li>
<li>在解析<code>TencentSmsAutoConfiguration</code>时，它会检查classpath中是否存在<code>com.tencent.cloud.sms.sdk.SmsSender.class</code>。因为使用者<strong>没有</strong>添加腾讯云的SDK依赖，所以这个类不存在，条件不满足，<strong>这个配置类就会被优雅地跳过，不会被加载</strong>，从而避免了<code>ClassNotFoundException</code>。</li>
</ul>
<p><code>@ConditionalOnClass</code>并不是为了判断我们自己项目里的类是否存在，而是为了让我们开发的<strong>通用模块（starter）\</strong>能够*<em>智能地感知和适配它所运行的应用环境*</em>，根据应用环境中引入了哪些依赖，来动态地决定哪些功能应该被激活。这是Spring Boot实现‘约定大于配置’和‘开箱即用’的关键魔法之一</p>
<h2 id="9-ThreadLocal-在线程池中的失效问题"><a href="#9-ThreadLocal-在线程池中的失效问题" class="headerlink" title="9.ThreadLocal 在线程池中的失效问题"></a>9.<strong><code>ThreadLocal</code> 在线程池中的失效问题</strong></h2><ul>
<li><code>InheritableThreadLocal</code>之所以能够实现父子线程间的数据传递，是因为在<code>new Thread()</code>创建子线程时，子线程的构造函数会检查父线程的<code>inheritableThreadLocals</code>这个Map。如果它不为空，子线程就会将父线程Map中的所有值<strong>拷贝</strong>一份到自己的<code>inheritableThreadLocals</code>中。</li>
<li><strong>关键在于</strong>：这个值的拷贝动作，<strong>只发生在子线程被创建的那一瞬间</strong>。</li>
<li>在线程池的场景下，工作线程通常在系统启动时就已经被<strong>预先创建</strong>好了，并存放在池中。当我们提交一个任务时，线程池只是从池中<strong>取出一个已经存在的线程</strong>来执行我们的任务，并<strong>没有<code>new Thread()</code>这个动作</strong>。</li>
</ul>
<p>为了解决这个问题，阿里巴巴开源了一个非常强大的工具——<strong><code>TransmittableThreadLocal</code>（TTL）</strong>。它专门用于解决在使用线程池等会池化线程的组件时，实现父子线程、任务提交者与任务执行者之间的上下文传递问题。</p>
<p>TTL的优点在于它通过<strong>Java Agent</strong>或<strong>手动包装</strong>的方式，对线程池的<code>submit</code>/<code>execute</code>等方法以及<code>Runnable</code>/<code>Callable</code>任务进行了<strong>装饰（Decorate）</strong>。”</p>
<ol>
<li><strong>任务提交时（<code>submit</code>）</strong>：当我们调用被装饰过的<code>threadPool.submit(myRunnable)</code>时，TTL会<strong>捕获</strong>当前线程（父线程）的<code>ThreadLocal</code>值，并将其<strong>‘打包’</strong>进一个<code>TtlRunnable</code>或<code>TtlCallable</code>对象中。</li>
<li><strong>任务执行前（<code>run</code>）</strong>：当线程池中的某个工作线程开始执行这个被包装过的<code>TtlRunnable</code>时，在其<code>run</code>方法的<code>try</code>块开始处，TTL会将被‘打包’的父线程<code>ThreadLocal</code>值，<strong>‘回放’（replay）</strong>到当前工作线程的<code>ThreadLocal</code>中。</li>
<li><strong>任务执行后（<code>finally</code>）</strong>：在<code>finally</code>块中，TTL会<strong>清理</strong>当前工作线程的<code>ThreadLocal</code>，将其恢复到执行任务之前的状态，从而避免了数据串扰。</li>
</ol>
<h2 id="10-如何保证三个线程有序执行任务"><a href="#10-如何保证三个线程有序执行任务" class="headerlink" title="10.如何保证三个线程有序执行任务"></a>10.如何保证三个线程有序执行任务</h2><p>方案1：使用<strong><code>wait/notify</code> 方案</strong></p>
<p>你需要自己管理锁（<code>synchronized</code>）、状态变量（<code>volatile int state</code>）、<code>while</code>循环（防止伪唤醒）、<code>try-finally</code>（保证锁释放），代码量大且极易出错。</p>
<p>使用<code>notifyAll()</code>会唤醒所有等待的线程，造成不必要的CPU竞争。而使用<code>notify()</code>又存在风险：如果错误地唤醒了不该被唤醒的线程（比如T1唤醒了T3而不是T2），信号就可能丢失，导致程序死锁。</p>
<p>方案2：<strong>升级版 <code>wait/notify</code> - <code>ReentrantLock</code> + <code>Condition</code></strong></p>
<p><code>ReentrantLock</code>提供了比<code>synchronized</code>更强大的功能。<code>Condition</code>对象则将<code>wait/notify</code>机制从“一个锁只有一个等待队列”升级为“<strong>一个锁可以有多个独立的等待队列</strong>”，我们可以为每个线程的“等待室”创建一个<code>Condition</code>，实现精准的“点对点”唤醒，彻底避免了<code>notify()</code>的信号丢失问题。</p>
<ol>
<li>创建一个<code>ReentrantLock</code>实例。</li>
<li>创建一个<code>volatile</code>状态变量，例如<code>volatile int state = 1;</code>，用于标识当前应该哪个线程执行。</li>
<li>为<strong>每个线程</strong>创建一个<code>Condition</code>对象：<code>Condition c1 = lock.newCondition(); Condition c2 = lock.newCondition(); Condition c3 = lock.newCondition();</code></li>
<li>线程T1的逻辑：<ul>
<li>获取锁 <code>lock.lock()</code>。</li>
<li>在<code>try...finally</code>中执行，<code>finally</code>块中<code>lock.unlock()</code>。</li>
<li><code>while (state != 1)</code>，<code>c1.await()</code>。</li>
<li>执行任务1。</li>
<li>更新状态 <code>state = 2</code>。</li>
<li><strong>精准唤醒</strong>线程T2：<code>c2.signal()</code>。</li>
</ul>
</li>
<li><strong>线程T2和T3的逻辑</strong>与T1类似，分别在自己的<code>Condition</code>上<code>await</code>，并在执行完任务后，更新<code>state</code>并<code>signal</code>下一个线程的<code>Condition</code>。</li>
</ol>
<p>实现了有序执行，通过<code>signal()</code>实现了精准唤醒，比<code>notifyAll()</code>更高效，比<code>notify()</code>更安全。但还是比较复杂</p>
<p>方案3：<strong>信号量接力 - <code>Semaphore</code></strong></p>
<p><code>Semaphore</code>（信号量）是控制同时访问特定资源的线程数量的工具。我们可以创建两个初始许可为0的信号量，作为两个线程之间的“接力棒”。</p>
<ol>
<li>创建两个信号量：<code>Semaphore sem2 = new Semaphore(0);</code> 和 <code>Semaphore sem3 = new Semaphore(0);</code>。</li>
<li>线程T1的逻辑：<ul>
<li>执行任务1。</li>
<li>执行完毕后，释放一个“给T2的许可”：<code>sem2.release()</code>。</li>
</ul>
</li>
<li>线程T2的逻辑：<ul>
<li>首先尝试获取“来自T1的许可”，如果许可未被释放，T2将在此阻塞：<code>sem2.acquire()</code>。</li>
<li>获取到许可后，执行任务2。</li>
<li>执行完毕后，释放一个“给T3的许可”：<code>sem3.release()</code>。</li>
</ul>
</li>
<li>线程T3的逻辑：<ul>
<li>首先尝试获取“来自T2的许可”：<code>sem3.acquire()</code>。</li>
<li>获取到许可后，执行任务3。</li>
</ul>
</li>
</ol>
<p>代码清晰简单，但需要创建N-1个<code>Semaphore</code>对象，如果线程数量很多，会增加一些对象管理的开销。</p>
<p>方案4：<strong><code>SingleThreadExecutor</code></strong></p>
<p><code>Executors.newSingleThreadExecutor()</code>会创建一个<strong>单线程的线程池</strong>。这个线程池的核心特性是：它内部有一个<strong>无界的<code>LinkedBlockingQueue</code>\</strong>来存放任务，并且*<em>永远只有一个工作线程<strong>来从队列中取出并执行任务。这就天然地保证了所有提交给它的任务，都会</strong>严格按照提交的顺序（FIFO）来串行执行*</em>。</p>
<ol>
<li><p>创建一个单线程执行器：<code>ExecutorService executor = Executors.newSingleThreadExecutor();</code></p>
</li>
<li><p>定义三个任务（<code>Runnable</code>或<code>Callable</code>）：<code>task1</code>, <code>task2</code>, <code>task3</code>。</p>
</li>
<li><p>按顺序提交任务：java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭线程池：<code>executor.shutdown()</code>。</p>
</li>
</ol>
<ul>
<li><strong>严格来说，这是“三个任务有序执行”，而不是“三个不同的线程有序执行”</strong>。因为所有任务都是由<strong>同一个</strong>工作线程来执行的。如果面试官的题目严格要求必须是三个<strong>不同的、预先创建好</strong>的线程，那么这个方案就不完全符合字面要求。</li>
</ul>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-UserMappe这个类为啥要是接口呢？"><a href="#1-UserMappe这个类为啥要是接口呢？" class="headerlink" title="1.UserMappe这个类为啥要是接口呢？"></a>1.UserMappe这个类为啥要是接口呢？</h2><p>MyBatis的Mapper之所以必须定义为接口，其根本原因在于MyBatis框架在底层使用了<strong>JDK动态代理（JDK Dynamic Proxy）</strong>技术，来为我们自动地生成这个接口的实现类。</p>
<p>只定义了<code>UserMapper</code>接口，并在XML文件中写了SQL，但我们<strong>从来没有手动编写过一个<code>class UserMapperImpl implements UserMapper</code></strong>。然而，在Service层，我们却可以直接<code>@Autowired</code>注入一个<code>UserMapper</code>的实例并调用它的方法。</p>
<ol>
<li><strong>启动时扫描</strong>：当Spring容器启动时，MyBatis的<code>MapperScannerConfigurer</code>会扫描指定的包路径（如<code>com.example.mapper</code>），找到所有被<code>@Mapper</code>注解标记的接口，或者所有继承了特定标记接口的接口。</li>
<li><strong>注册Bean定义</strong>：对于找到的每一个Mapper接口（比如<code>UserMapper.class</code>），MyBatis并不会去创建一个真实的实现类，而是在Spring容器中注册一个特殊类型的Bean定义——<code>MapperFactoryBean</code>。</li>
<li><strong>创建代理对象</strong>：当Service层需要注入<code>UserMapper</code>时，Spring会向<code>MapperFactoryBean</code>请求获取Bean实例。此时，<code>MapperFactoryBean</code>就会调用JDK动态代理，<strong>在内存中动态地生成一个<code>UserMapper</code>接口的代理实现对象</strong>。</li>
</ol>
<ul>
<li><p>“这个动态生成的代理对象，它的内部有一个<code>InvocationHandler</code>。当我们调用代理对象的任何方法时（比如<code>userMapper.selectById(1)</code>），这个调用都会被<code>InvocationHandler</code>拦截。”</p>
</li>
<li><p>InvocationHandler的逻辑大致是：”</p>
<ol>
<li>它会获取到我们调用的<strong>方法名</strong>（<code>selectById</code>）和<strong>参数</strong>（<code>1</code>）。</li>
<li>它会将方法名与Mapper XML文件中配置的SQL语句的<code>id</code>进行<strong>映射和绑定</strong>。</li>
<li>它会从连接池获取一个数据库连接，将参数设置到SQL语句中，然后通过JDBC执行这条SQL。</li>
<li>最后，它会将查询结果封装成我们方法签名中定义好的返回类型（如<code>User</code>对象），并返回。</li>
</ol>
</li>
</ul>
<p>  正是因为MyBatis依赖于<strong>JDK动态代理</strong>，而JDK动态代理技术本身就<strong>要求被代理的目标必须是一个接口</strong>。它无法为一个具体的类或抽象类创建代理。这就是为什么Mapper必须是接口的根本技术原因。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="1-流式输出和非流式输出"><a href="#1-流式输出和非流式输出" class="headerlink" title="1.流式输出和非流式输出"></a>1.流式输出和非流式输出</h2><div class="table-container">
<table>
<thead>
<tr>
<th>对比点</th>
<th>流式输出</th>
<th>非流式输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据传输</strong></td>
<td>边生产边传输</td>
<td>生成完后一次传输</td>
</tr>
<tr>
<td><strong>响应延迟</strong></td>
<td>首字节快，用户能尽快看到结果</td>
<td>必须等所有数据生成后才能看到</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>占用更少内存（分段处理）</td>
<td>可能占用大量内存（一次性加载）</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>较高（需要支持分段协议/推送机制）</td>
<td>较低（一次性返回）</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>视频流、日志实时消费、AI Chat逐字打印</td>
<td>小文件下载、查询一次性返回结果</td>
</tr>
</tbody>
</table>
</div>
<p>非流式输出是等数据全部生成后一次性返回，而流式输出则是边生成边返回，能降低延迟和内存占用，更适合大数据量和实时场景。</p>
<h2 id="2-HashMap-remove-方法的实现细节"><a href="#2-HashMap-remove-方法的实现细节" class="headerlink" title="2.HashMap remove 方法的实现细节"></a>2.<strong>HashMap <code>remove</code> 方法的实现细节</strong></h2><ol>
<li>首先，<code>remove(key)</code>方法会计算<code>key</code>的<code>hash</code>值。</li>
<li>根据<code>hash</code>值定位到它在底层<code>table</code>数组中的索引位置（即bucket）。</li>
<li>如果该bucket为空，直接返回<code>null</code>。</li>
<li>如果bucket不为空，则遍历该位置的链表或红黑树，逐个节点使用<code>hash</code>值和<code>equals()</code>方法进行比较，直到找到要删除的目标节点。如果遍历完没找到，也返回<code>null</code>。</li>
</ol>
<p><strong>如果当前是链表结构</strong>,是头节点的话，即让头节点的下一个节点成为新的头节点。</p>
<p><strong><code>p</code>是中间节点或尾节点</strong>。那么就跳过这个节点，GC将自动回收这个不再被引用的节点</p>
<ul>
<li>红黑树的删除操作要复杂得多，因为它必须在删除节点后，通过一系列的<strong>旋转（Rotation）和重新着色（Recoloring）\</strong>操作，来*<em>维持红黑树的5条性质*</em>（例如，根是黑的、不能有连续的红节点、任何节点到其每个叶子节点的所有路径都包含相同数目的黑色节点等），从而保证树的平衡性。</li>
<li><code>HashMap</code>会调用内部的<code>removeTreeNode</code>方法来执行这个复杂的过程。</li>
<li>在红黑树中删除了一个节点后，<code>HashMap</code>还会检查该bucket的节点数量。如果数量减少到了一个<strong>阈值（UNTREEIFY_THRESHOLD，默认为6）</strong>，为了节省内存和在节点数少时提升性能，这棵红黑树会<strong>退化（untreeify）</strong>变回普通的链表结构。</li>
<li>删除成功后，<code>HashMap</code>的<code>size</code>会减1。</li>
<li>方法会返回被删除节点的<code>value</code>值。</li>
</ul>
<p>3.</p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="1-多表join的时候，小表驱动大表"><a href="#1-多表join的时候，小表驱动大表" class="headerlink" title="1.多表join的时候，小表驱动大表"></a>1.多表join的时候，小表驱动大表</h2><p>在Mysql的 Nested Loop Join 中</p>
<p><strong>驱动表（outer table）</strong>：首先被扫描的表。</p>
<p><strong>被驱动表（inner table）</strong>：对驱动表每一行，根据 Join 条件去查找匹配行的表。</p>
<p><strong>核心原则</strong>：过滤后剩余行数少的表，应该作为驱动表，这样可以减少被驱动表的访问次数。这就是小表</p>
<p>执行过程：</p>
<p>扫描驱动表（全表扫描或索引扫描）。</p>
<p>对驱动表的每一行，根据连接条件在被驱动表中查找（通常用索引 B+Tree 查找）。</p>
<p>如果被驱动表使用二级索引且需要回表，则访问主键索引。</p>
<p>小表驱动大表，大表负责命中索引。</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A straight_join B on A.a = B.a;</span><br></pre></td></tr></table></figure>
<p>数据库会全表扫A，然后每拿到一行就去比较条件 A.a=B.a，去B表里面查，B表命中索引的查询。实际上就是一个搜索树，查询的时间复杂度近似log2^B^，然后加上一次回表，可能就是2Log2 ^B^,所以总体的时间复杂度为A+2log2^B^*A，如果是覆盖索引的话，复杂度可降为 O(A + log₂(B) × A)</p>
<p>所以我的们A越小越好，join的本质就是查驱动表，然后扫被驱动表，当然是查的越少越好了</p>
<h2 id="2-一条-UPDATE-语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理"><a href="#2-一条-UPDATE-语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理" class="headerlink" title="2.一条 UPDATE 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理"></a>2.一条 <code>UPDATE</code> 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理</h2><p>Mysql是一个分层的，核心模块包括网络层、SQL层和存储引擎层。</p>
<p>如果以一条 <code>UPDATE t SET c = 2 WHERE id = 1;</code> 语句为例，它的生命周期是这样的：</p>
<p>网络层：</p>
<p>首先，客户端通过TCP连接发送这条SQL。我的网络模块基于Java NIO实现，会接收这个请求，并将其传递给SQL层。</p>
<p>SQL层 - 解析与执行：</p>
<ul>
<li><strong>SQL解析器</strong>：SQL层会解析这条字符串，生成一个抽象语法树（AST）。</li>
<li><strong>执行器</strong>：然后，执行器会解释这棵树。对于这条<code>UPDATE</code>语句，它知道要去表<code>t</code>中找到<code>id=1</code>的行，并更新<code>c</code>列。</li>
</ul>
<p>存储引擎层 - 事务与数据处理：这是最核心的部分。</p>
<ul>
<li><strong>事务管理器</strong>：执行器会向事务管理器申请开启一个事务。</li>
<li><strong>访问数据</strong>：执行器请求存储引擎去获取<code>id=1</code>的行。存储引擎会先去 <strong>Buffer Pool</strong>（内存缓冲池）里查找，如果数据页不在内存，会通过 <strong>IO模块</strong> 从磁盘加载。</li>
<li><strong>并发控制</strong>：在读取和修改数据时，为了保证隔离性，这里会涉及到 <strong>MVCC</strong> 和 <strong>锁管理器</strong>。<code>UPDATE</code> 是一种“当前读”，所以它会读取最新的已提交版本，并在这行数据上加一个 <strong>排他锁（X Lock）</strong>，防止其他事务同时修改。</li>
<li><strong>执行修改</strong>：获取到锁之后，执行器会在 Buffer Pool 中修改对应的数据页。但它不是直接覆盖旧数据，而是会生成一个 <strong>undo日志</strong>，记录下修改前的样子，用于回滚和支持MVCC。</li>
<li><strong>记录日志</strong>：在修改内存数据页之前，必须先将这次操作的详细信息写入 <strong>redo日志（WAL）</strong> 的内存缓冲区。这是为了保证持久性。</li>
<li><strong>提交事务</strong>：当客户端发起 <code>COMMIT</code> 时，<strong>日志管理器</strong> 会确保对应的 redo 日志被刷入磁盘。只要 redo 日志落盘了，即使此时宕机，数据也能恢复，所以我们就可以认为事务提交成功了。</li>
<li><strong>数据落盘</strong>：至于 Buffer Pool 里的脏数据页，则由一个后台线程根据一定的策略（比如LRU）异步地刷回磁盘，这个过程不影响事务的提交响应。</li>
</ul>
<h2 id="3-为什么选择-WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？"><a href="#3-为什么选择-WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？" class="headerlink" title="3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？"></a>3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？</h2><p>选择 WAL 的核心优势在于<strong>将随机IO转换为了顺序IO，极大地提升了写入性能并保证了数据不丢失</strong>。</p>
<ul>
<li><strong>性能提升</strong>：数据库的数据页在磁盘上是离散存储的，修改它们需要大量的随机磁盘寻址，非常慢。而日志文件是追加写入的，是顺序IO，速度比随机IO快几个数量级。通过 WAL，事务提交时只需要保证日志落盘即可，脏数据页可以异步、批量地刷回磁盘，大大降低了事务提交的延迟。</li>
<li>顺序保证：这个顺序是绝对不能颠倒的，必须是先写日志（Log），再更新内存页（Buffer Pool）。这就是“Write-Ahead Logging”（预写日志）这个名字的由来。<ul>
<li><strong>原因</strong>：如果反过来，先修改了内存中的数据页，然后系统在写日志之前宕机了。那么当系统重启时，内存中的修改会全部丢失，而日志里又没有记录这次操作，这个更新就永远地丢失了，这违反了事务的<strong>持久性（Durability）</strong>。而只要保证日志先写入，即使系统在数据页刷盘前宕机，重启后也可以通过扫描 redo 日志来恢复数据，保证了数据的完整性。”</li>
</ul>
</li>
</ul>
<h2 id="4-当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？"><a href="#4-当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？" class="headerlink" title="4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？"></a>4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？</h2><p>当向一个叶子节点插入数据，发现它已经满了的时候，会触发分裂操作，逻辑如下：</p>
<ol>
<li><strong>创建新节点</strong>：首先，创建一个新的兄弟叶子节点。</li>
<li><strong>找到分裂点</strong>：计算出当前节点所有记录的中间位置。</li>
<li><strong>移动数据</strong>：将中间位置之后的所有记录移动到新的兄弟节点中。</li>
<li><strong>更新父节点</strong>：将原中间位置的键值（Key）提升到父节点中，作为一个新的索引项。这个索引项的指针会指向新创建的兄弟节点。</li>
<li><strong>级联分裂</strong>：如果插入这个新的索引项导致父节点也满了，那么父节点会重复上述的分裂过程，这个过程可能会一直级联到根节点，最坏情况下会导致树的高度增加。</li>
</ol>
<p>关于并发问题，这是一个非常关键的点。对B+树的这种结构性修改（如分裂或合并）必须是原子的，否则可能导致树的结构被破坏。</p>
<ul>
<li>当一个线程需要修改一个B+树节点时，它会先获取这个节点的 Latch。在分裂过程中，它会同时持有父节点和要分裂的子节点的 Latch，操作完成后再释放。这种方式只锁定了必要的节点，允许其他不相关的读写操作继续进行。</li>
</ul>
<p>Lock 和 Latch 区别</p>
<ul>
<li><strong>保护对象</strong>：<strong>Lock（锁）</strong> 是在<strong>事务层面</strong>，用来保护<strong>逻辑数据</strong>，比如表中的一行记录。它的目的是保证事务的隔离性。<strong>Latch（闩锁）</strong> 是在<strong>线程层面</strong>，用来保护<strong>内存中的物理数据结构</strong>，比如 Buffer Pool 中的一个数据页、B+树的一个节点或者一个共享的内存链表。它的目的是保证多线程访问共享内存结构时的线程安全。</li>
<li><strong>持有时间</strong>：<strong>Lock</strong> 的持有时间很长，可能会贯穿整个事务，直到事务提交或回滚才释放。<strong>Latch</strong> 的持有时间非常短，通常只在一次原子操作的临界区内持有，比如修改一个 B+ 树节点，操作一完成马上就释放。</li>
<li><strong>死锁</strong>：<strong>Lock</strong> 会涉及到死锁问题，需要数据库有专门的死锁检测机制。而 <strong>Latch</strong> 通常通过规定获取顺序（比如在B+树中总是从父节点到子节点获取）来避免死锁，所以一般认为 Latch 是无死锁的。</li>
</ul>
<p>简单来说，Lock 是给数据库用户（事务）用的，保证业务逻辑的正确性；Latch 是给数据库内核开发者用的，保证内核数据结构的正确性。”</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-多级缓存数据一致性与失败回滚"><a href="#1-多级缓存数据一致性与失败回滚" class="headerlink" title="1.多级缓存数据一致性与失败回滚"></a>1.<strong>多级缓存数据一致性与失败回滚</strong></h2><p>当被问及如何保证Redis和本地缓存更新的原子性，以及在更新失败时如何回滚，你的回答提到了不甚准确的“编程式事务”，并最终倾向于人工处理。</p>
<p>方案1：<strong>引入消息队列（MQ）进行可靠的异步处理</strong></p>
<ol>
<li>修改架构：Canal不再直接调用消费逻辑，而是将解析后的binlog事件作为消息发送到MQ的一个Topic中。</li>
<li>消费者逻辑：消费者服务从MQ拉取消息。其处理逻辑是：先失效Redis缓存，再发布一个广播消息（如通过Redis Pub/Sub）通知所有应用实例失效本地Caffeine缓存。</li>
<li>失败处理：只有当所有步骤成功后，消费者才向MQ发送ACK。如果处理过程中任何一步失败（如Redis连接超时），消费者不发送ACK。MQ会在超时后将该消息重新投递给其他消费者，实现自动重试。</li>
</ol>
<p>方案2 死信队列</p>
<ol>
<li>在Canal的消费者逻辑中，使用<code>Spring Retry</code>等框架对缓存失效操作进行封装。</li>
<li>配置重试策略，例如重试3次，每次间隔采用指数退避（如1s, 2s, 4s），避免在故障期间频繁冲击下游服务。</li>
<li>配置一个<code>RecoveryCallback</code>。当所有重试都失败后，将这条失败的binlog事件（包含表名、主键、操作类型等信息）发送到一个专门的<strong>死信队列（Dead Letter Queue）</strong>或记录到数据库的失败任务表中。</li>
<li>部署一个独立的监控程序或定时任务，消费DLQ中的消息，并发送告警（邮件、短信、钉钉）。</li>
</ol>
<p>如果重试逻辑设计不当，可能会在短时间内放大故障。死信队列需要有完善的监控，否则会成为被遗忘的角落。</p>
<p>方案3 <strong>先更新缓存，再更新数据库”的策略</strong></p>
<ol>
<li>写请求：先更新（或失效）Redis缓存，然后更新数据库。</li>
<li>为了解决并发更新导致的不一致问题，可以引入“延时双删”：先删缓存 -&gt; 更新数据库 -&gt; 延迟一段时间（如500ms）后再次删除缓存。</li>
<li>本地Caffeine缓存仍然可以通过监听Redis的key失效事件（Keyspace Notifications）或消息广播来同步失效。</li>
</ol>
<p><strong>非常不推荐</strong>。延时双删的延迟时间很难确定，无法100%保证一致性。代码侵入性强，业务逻辑与缓存逻辑耦合严重，维护困难。</p>
<h2 id="2-什么情况下，就是两个线程会持有同一把锁"><a href="#2-什么情况下，就是两个线程会持有同一把锁" class="headerlink" title="2.什么情况下，就是两个线程会持有同一把锁"></a>2.什么情况下，就是两个线程会持有同一把锁</h2><p><strong>两个不同的线程在同一时刻是不可能持有同一把锁的</strong>，这是锁的<strong>互斥性</strong>基本原则所保证的。如果出现了这种情况，那一定是锁的实现出了严重的问题。</p>
<p>您这个问题可能是在考察一个非常重要的特性——<strong>锁的可重入性</strong>。可重入性指的是<strong>同一个线程</strong>可以多次成功获取同一把锁，而不会自己把自己锁死。在释放锁时，也需要释放相应次数后，锁才会被真正释放。”</p>
<p>比如：在一个复杂的业务方法A中，它获取了锁。然后它又调用了另一个方法B，而方法B也需要获取同一个锁。如果没有可重入性，那么在方法B中，当前线程会因为无法获取一个已经被自己持有的锁而陷入死锁。</p>
<p>实现：Redisson巧妙地使用了Redis的<strong>Hash数据结构</strong>来实现。</p>
<ul>
<li>当一个线程第一次获取锁时，它会在Redis中创建一个Hash。这个Hash的Key是锁的名称（例如<code>myLock</code>）。</li>
<li>这个Hash结构内部会存储两个关键信息：<ul>
<li>一个field存储<strong>持有锁的线程标识</strong>（例如，UUID + ThreadId）。</li>
<li>另一个field存储一个<strong>计数器</strong>，表示该线程重入的次数，初始值为1。</li>
</ul>
</li>
<li>当同一个线程<strong>再次</strong>尝试获取这把锁时，Redisson会检查Hash中存储的线程标识。如果与当前线程标识匹配，它就不会阻塞，而是直接将计数器的值加1，表示又重入了一次。</li>
<li>当线程<strong>释放锁</strong>时，它会去将计数器减1。只有当计数器的值减到0时，Redisson才会真正地从Redis中删除这个Hash（即释放锁），这样其他线程才有机会获取。</li>
</ul>
<h2 id="3-如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？"><a href="#3-如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？" class="headerlink" title="3.如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？"></a>3.<strong>如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？</strong></h2><p>您提的这个问题非常关键，它涉及到整个数据同步链路的<strong>高可用性</strong>。</p>
<ol>
<li><strong>Canal自身的高可用</strong>：首先，Canal自身是可以部署成<strong>高可用集群</strong>的。通过Zookeeper进行集群管理和主备选举，当主节点宕机时，备用节点可以自动接管，从而保证了数据订阅服务的连续性。</li>
<li><strong>链路中断的影响</strong>：如果Canal到消费端的链路中断，确实会导致缓存与数据库在中断期间的<strong>数据不一致窗口期变长</strong>。新写入的数据无法触发缓存失效，用户可能会在一段时间内读到旧的缓存数据。</li>
<li><strong>我们的容灾与补偿策略</strong>：<ul>
<li><strong>监控与告警</strong>：我们必须对Canal的消费位点（Position）与MySQL主库的最新binlog位点之间的<strong>延迟</strong>做严格的监控。一旦延迟超过阈值（比如1分钟），就立即触发高级别告警，通知SRE和开发团队介入。</li>
<li><strong>设置合理的缓存TTL</strong>：即使同步链路中断，我们缓存中的数据也不是永久有效的。通过为所有缓存设置一个合理的<strong>兜底过期时间（TTL）</strong>，比如1小时，可以保证即使在最坏的情况下，数据不一致的时间也不会无限延长。这是一种<strong>自愈机制</strong>。</li>
<li><strong>手动全量/增量校准</strong>：对于极端重要的数据，我们会准备一个<strong>手动触发的数据校准脚本</strong>。当链路长时间中断并恢复后，可以运行这个脚本，根据时间戳或版本号，主动查询数据库，强制刷新Redis中的核心数据，确保最终一致性。”</li>
</ul>
</li>
</ol>
<h2 id="4-你提到用Redis的Pub-Sub来广播失效Caffeine本地缓存。"><a href="#4-你提到用Redis的Pub-Sub来广播失效Caffeine本地缓存。" class="headerlink" title="4.你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。"></a>4.<strong>你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。</strong></h2><p><strong>Pub/Sub是‘fire-and-forget’（即发即忘）模式，不保证消息必达。如果某个应用实例因为网络抖动没收到失效消息，怎么办？</strong></p>
<p>您观察得非常仔细，Pub/Sub确实存在消息丢失的风险。对于这个问题，我们有分层级的解决方案</p>
<ol>
<li><strong>接受短暂不一致</strong>：对于大部分业务场景，单台服务器上短暂的本地缓存不一致是可以接受的。因为流量通常会通过负载均衡打到多台服务器上，只有一小部分用户请求会命中这台机器的旧缓存，且Caffeine本身也有过期机制，影响是可控的。</li>
<li><strong>引入更可靠的消息总线</strong>：如果业务对一致性要求极高，我们会放弃轻量级的Pub/Sub，转而使用<strong>更可靠的消息中间件（如RocketMQ）的广播消费模式</strong>。每个应用实例都作为一个消费者组内的广播消费者，订阅失效通知。MQ的ACK机制可以保证每个实例都可靠地收到失效消息。</li>
<li><strong>版本号机制</strong>：我们可以在缓存的对象中增加一个<strong>版本号或时间戳字段</strong>。当应用从缓存中获取到数据后，可以（在某些关键操作前）与数据库中的版本号进行一次快速比对。如果发现缓存版本落后，就主动失效本地缓存并重新加载。这是一种<strong>主动校验</strong>的补偿机制。”</li>
</ol>
<h2 id="5-缓存三问题"><a href="#5-缓存三问题" class="headerlink" title="5.缓存三问题"></a>5.缓存三问题</h2><p><strong>布隆过滤器和缓存空值，这两种方案在你的项目中，你会如何选择？它们各自有什么优缺点和需要注意的地方？</strong></p>
<p><strong>方案一：缓存空值（Cache Null Values）</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li><strong>实现简单</strong>：逻辑清晰，开发和维护成本极低。</li>
<li><strong>效果直接</strong>：能100%拦截住对同一个不存在的key的重复攻击。</li>
</ul>
</li>
<li><p>缺点与注意事项：</p>
<ul>
<li><strong>消耗额外的缓存空间</strong>：如果被恶意攻击，攻击者不断变换不存在的key来查询，会导致Redis中存储大量的空值key，造成内存浪费。</li>
<li><strong>数据一致性问题</strong>：如果这个之前不存在的数据，后来又在数据库中被创建了（例如，一个新用户注册了），缓存中的空值需要有一种机制被及时地更新或失效，否则会导致用户刚注册完却查不到自己的信息。</li>
</ul>
<p>适用于<strong>不存在的key的集合相对固定，或者重复查询率高</strong>的场景。例如，查询一个已经下架的商品</p>
</li>
</ul>
<p><strong>方案二：布隆过滤器（Bloom Filter）</strong></p>
<ul>
<li>优点：<ul>
<li><strong>空间效率极高</strong>：它使用位图（bitmap）来存储数据，占用的内存空间远小于缓存空值方案，非常适合处理海量数据。</li>
</ul>
</li>
<li>缺点与注意事项：<ul>
<li><strong>存在误判率（False Positive）</strong>：布隆过滤器判断“不存在”是100%准确的，但判断“存在”时，有一定概率会把一个不存在的key误判为存在。这意味着它无法完全拦截所有穿透请求，会有一小部分漏网之鱼打到数据库。</li>
<li><strong>无法删除元素</strong>：标准的布隆过滤器不支持删除操作。如果数据需要频繁地增删，就需要使用Counting Bloom Filter等变种，实现更复杂。</li>
<li><strong>初始化和重建成本</strong>：需要在系统启动时，将全量数据加载到布隆过滤器中，这个过程可能比较耗时。当数据发生变化时，也需要有机制来同步更新过滤器。</li>
</ul>
</li>
<li><strong>适用场景</strong>：适用于<strong>数据量巨大，但数据相对稳定，且对误判率有一定容忍度</strong>的场景。例如，防止恶意用户用随机生成的ID来攻击用户查询接口。</li>
</ul>
<h2 id="6-用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用-Redis，你会选择哪种数据结构来实现"><a href="#6-用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用-Redis，你会选择哪种数据结构来实现" class="headerlink" title="6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现"></a>6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现</h2><p>方案1：使用String</p>
<p>Redis的<code>INCR</code>命令是原子性的，可以保证在并发环境下计数的准确性。<code>EXPIRE</code>命令可以为一个key设置生存时间（TTL），完美地契合了“10分钟之内”这个时间窗口的需求。</p>
<ol>
<li><strong>定义Key</strong>：为每个用户的登录失败计数定义一个清晰的Key，例如：<code>login:fail:count:&#123;userId&#125;</code>。</li>
<li>登录失败逻辑：当用户登录失败时，执行以下操作：<ul>
<li>对该用户的Key执行<code>INCR</code>命令，获取增长后的计数值：<code>count = redis.incr(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>。</li>
<li><strong>判断是否是第一次失败</strong>：如果<code>count</code>等于1，说明这是10分钟窗口内的第一次失败。此时，必须为这个Key设置过期时间：<code>redis.expire(&quot;login:fail:count:&#123;userId&#125;&quot;, 600)</code> (600秒 = 10分钟)。</li>
<li><strong>检查是否达到阈值</strong>：判断<code>count</code>是否大于等于3。如果是，则触发锁定用户的逻辑（例如，在数据库中更新用户状态，或在另一个Redis Key中设置一个锁定标记）。</li>
</ul>
</li>
<li><strong>登录成功逻辑</strong>：当用户登录成功时，应该<strong>立即删除</strong>这个计数Key：<code>redis.del(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>，以清除之前的失败记录。</li>
</ol>
<p>问题：</p>
<ul>
<li>存在一个微小的<strong>竞态条件（Race Condition）</strong>：在<code>INCR</code>和<code>EXPIRE</code>两个命令之间，如果服务器恰好宕机或重启，可能会导致一个计数Key被创建但<strong>没有设置过期时间</strong>，从而变成一个永久的计数器。虽然概率极低，但在高并发系统中仍需考虑。</li>
<li><strong>解决方案</strong>：可以使用<strong>Lua脚本</strong>将<code>INCR</code>和<code>EXPIRE</code>两个操作打包成一个原子操作，或者使用一条Redis命令完成</li>
</ul>
<p>方案2：<strong>灵活精确 - List 作为失败记录队列</strong></p>
<p>Redis的<code>List</code>是一个双向链表，可以作为队列使用。通过<code>LPUSH</code>在队头插入元素，<code>LTRIM</code>修剪队列长度，可以非常高效地维护一个固定大小的事件窗口。</p>
<ol>
<li><strong>定义Key</strong>：<code>login:fail:log:&#123;userId&#125;</code>。</li>
<li>登录失败逻辑：<ul>
<li>获取当前时间戳（秒或毫秒），并将其作为元素<code>LPUSH</code>到List的头部：<code>redis.lpush(&quot;login:fail:log:&#123;userId&#125;&quot;, System.currentTimeMillis())</code>。</li>
<li><strong>检查当前失败次数</strong>：获取List的长度<code>llen</code>。</li>
<li>如果<code>llen</code>大于等于3，说明已经发生了至少3次失败。此时，获取List中<strong>第3个元素</strong>（即最早的那次失败记录，索引为2）：<code>third_attempt_time = redis.lindex(&quot;login:fail:log:&#123;userId&#125;&quot;, 2)</code>。</li>
<li><strong>判断时间窗口</strong>：计算当前时间与<code>third_attempt_time</code>的时间差。如果差值小于10分钟，则说明在10分钟内发生了3次失败，触发锁定逻辑。</li>
</ul>
</li>
<li><strong>队列维护</strong>：为了防止List无限增长，可以在每次<code>LPUSH</code>后，使用<code>LTRIM</code>命令只保留最近的3条记录：<code>redis.ltrim(&quot;login:fail:log:&#123;userId&#125;&quot;, 0, 2)</code>。同时，为整个Key设置一个比10分钟稍长的过期时间，如11分钟，用于自动清理冷数据。</li>
<li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li>
</ol>
<ul>
<li>实现了精确的时间窗口判断。</li>
<li>内存占用非常小，因为每个用户的Key最多只存储3个时间戳。</li>
</ul>
<p><strong>方案三：功能强大 - ZSET (Sorted Set) 实现滑动时间窗口</strong></p>
<p> Redis的<code>ZSET</code>是一个有序集合，每个成员都关联一个<code>score</code>。我们可以用<code>score</code>来存储事件发生的时间戳，利用<code>ZSET</code>按分数范围查询和删除的特性，完美地实现<strong>滑动时间窗口</strong>。</p>
<ol>
<li><strong>定义Key</strong>：<code>login:fail:zset:&#123;userId&#125;</code>。</li>
<li>登录失败逻辑：<ul>
<li>获取当前时间戳<code>now</code>。</li>
<li>为了防止成员重复，可以给每个成员一个唯一的值，例如<code>now + &quot;:&quot; + Math.random()</code>。</li>
<li>将新的失败记录添加到ZSET中，<code>score</code>和<code>member</code>都使用时间戳（或<code>score</code>是时间戳，<code>member</code>是唯一ID）：<code>redis.zadd(&quot;login:fail:zset:&#123;userId&#125;&quot;, now, now)</code>。</li>
<li><strong>清理过期记录</strong>：移除所有10分钟之前的记录，这是一个非常关键的步骤，保证了窗口的滑动：<code>redis.zremrangebyscore(&quot;login:fail:zset:&#123;userId&#125;&quot;, 0, now - 600000)</code> (假设<code>now</code>是毫秒)。</li>
<li><strong>统计窗口内次数</strong>：获取当前ZSET中的成员数量：<code>count = redis.zcard(&quot;login:fail:zset:&#123;userId&#125;&quot;)</code>。</li>
<li><strong>检查阈值</strong>：如果<code>count</code>大于等于3，触发锁定逻辑。</li>
</ul>
</li>
<li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li>
</ol>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="1-消息队列（MQ）消息积压处理"><a href="#1-消息队列（MQ）消息积压处理" class="headerlink" title="1.消息队列（MQ）消息积压处理"></a>1.<strong>消息队列（MQ）消息积压处理</strong></h2><p>当被问及线上Topic消息积压如何处理时，你的第一反应是“清空队列，然后恢复”，这在线上环境中是绝对禁止的操作。在引导下，你提到了扩容消费者。</p>
<p>方案1 <strong>紧急扩容消费者并监控下游依赖</strong></p>
<ol>
<li><strong>监控分析</strong>：在扩容前，必须先快速查看消费者应用的CPU、内存、GC情况，以及其下游依赖（如数据库、外部API）的负载情况。<strong>确认瓶颈在于消费者本身，而不是下游</strong>。</li>
<li><strong>水平扩容</strong>：如果瓶颈在消费者，立即增加消费者实例数量。在Kubernetes等云原生环境中，可以通过调整Deployment的replica数量快速实现。</li>
<li><strong>注意Partition数量</strong>：确保消费者实例数<strong>不超过</strong>Topic的Partition数量，因为多余的消费者将处于空闲状态。</li>
</ol>
<p>方案2 <strong>消息转储与异步回补</strong></p>
<ol>
<li><strong>编写转储程序</strong>：快速开发一个简单的程序，它的唯一作用就是消费积压Topic中的消息，然后原封不动地存储到另一个临时Topic或一个临时存储（如文件、数据库）中。</li>
<li><strong>启动转储</strong>：启动该程序，快速将积压消息“搬空”。</li>
<li><strong>修复与回补</strong>：在修复了原始消费者的Bug或性能问题后，再编写一个回补程序，以一个受控的速率，从临时Topic或存储中读取消息，重新发送回原始Topic进行处理。</li>
</ol>
<p>以空间换时间，快速恢复线上新消息的处理能力，为修复问题和处理积压数据赢得时间。</p>
<p>方案3 <strong>优化消费逻辑并临时提升处理能力</strong></p>
<ol>
<li>代码审查：快速排查消费逻辑，寻找性能瓶颈。常见的优化点包括：<ul>
<li>将单条处理改为<strong>批量处理</strong>。</li>
<li>将同步调用外部API改为<strong>异步并行</strong>调用。</li>
<li>优化SQL查询，减少不必要的数据库交互。</li>
</ul>
</li>
<li><strong>紧急上线</strong>：快速修复并上线优化后的代码。</li>
</ol>
<p>比如说：</p>
<p><strong>你提到扩容消费者来解决积压。假设现在是双十一零点，流量洪峰导致了严重积压，而下游的数据库集群负载也已经很高了。此时你作为负责人，应该如何决策？直接扩容消费者吗？</strong></p>
<p>面试官，这是一个非常经典的<strong>‘雪崩前兆’</strong>场景，决策的核心是<strong>‘止损和降级’</strong>，而不是盲目地增加压力。我的决策流程会是这样的</p>
<ol>
<li><strong>立即止损，保护核心系统</strong>，绝对不能直接扩容消费者！ 因为监控显示下游数据库已经高负载，扩容消费者只会变成压垮数据库的最后一根稻草，导致核心系统崩溃，造成更大的故障。 <em>立即对消费者进行限流甚至暂停<em>*。我会立即调整消费者的消费速率，甚至在极端情况下，通过配置中心或运维指令，</em></em>暂停非核心业务的消费，优先保住数据库的稳定。</li>
<li><strong>业务降级，保障核心链路</strong> <em> 我会立即与产品和业务方沟通，启动<strong>业务降级预案</strong>。例如： </em> <strong>关闭非核心功能</strong>：暂时关闭‘实时用户积分更新’、‘推荐商品刷新’等非核心功能的消费，将MQ资源和数据库资源全部让给<strong>核心交易链路</strong>（如下单、支付）。 <em> <em>*异步转同步</em></em>：对于某些可以接受延迟的业务，可以暂时将消息积-压在MQ中，等高峰期过后，系统负载降低了再慢慢处理。</li>
<li><strong>流量削峰与后续处理</strong> <em> <strong>利用MQ的积压能力</strong>：此时，MQ本身就扮演了一个<strong>天然的流量削峰器</strong>的角色。大量的请求被积压在队列中，而不是直接冲击后端系统，这正是我们使用MQ的一个重要原因。 </em> <strong>高峰后恢复</strong>：等到流量洪峰过去，数据库负载下降后，我们再<strong>逐步、分批地</strong>恢复被暂停的消费者，并可以适当地<strong>增加消费者实例</strong>，以一个受控的速率，慢慢地将积压的消息消费完毕。</li>
<li><strong>复盘与改进</strong> * 事后，我们会进行深入复盘。分析是数据库容量预估不足，还是SQL存在性能问题，或者是消费者逻辑有待优化。并根据分析结果，进行数据库扩容、SQL优化、或引入更精细化的流量控制策略，为下一次大促做好准备。</li>
</ol>
<p>我的核心决策原则是：<strong>牺牲非核心业务的实时性，来换取核心系统的稳定性和可用性。</strong></p>
<h2 id="2-消费者组的对应"><a href="#2-消费者组的对应" class="headerlink" title="2.消费者组的对应"></a>2.消费者组的对应</h2><p>你刚刚说的就是一个消费者端，然后去对应一个相当于一个partition，然后为什么要一一对应呢？</p>
<p><strong>核心原因：保证分区内的消息顺序性（Message Ordering Guarantee）</strong></p>
<p>‘一个Partition在同一个消费者组内，同一时间只能被一个Consumer消费</p>
<ul>
<li><strong>理论依据</strong>：Kafka只在<strong>单个Partition内部</strong>保证消息的有序性。也就是说，生产者以1, 2, 3的顺序发送到同一个Partition的消息，消费者也必须以1, 2, 3的顺序来消费它们。</li>
<li><strong>机制实现</strong>：为了实现这个保证，Kafka必须规定，一个Partition在任意时刻，只能被一个消费者实例“锁定”并消费。<strong>如果允许多个消费者同时消费同一个Partition，那么消息的消费顺序将无法得到保证</strong>，因为无法协调哪个消费者先处理哪条消息，这将彻底破坏Kafka的顺序性承诺。</li>
</ul>
<p><strong>实现高并发：以Partition为并行处理的最小单元</strong></p>
<ul>
<li><strong>理论依据</strong>：虽然单个Partition是顺序处理的，但Kafka通过<strong>将一个Topic划分为多个Partition</strong>来实F现整体的高并发。</li>
<li><strong>机制实现</strong>：整个Topic的吞吐量等于所有Partition吞吐量的总和。我们可以通过增加Partition的数量，来水平扩展Topic的处理能力。</li>
<li><strong>消费者协同</strong>：消费者组（Consumer Group）内的多个消费者实例会通过<strong>Rebalance（再均衡）\</strong>机制，自动协调分配它们各自负责消费的Partition。例如，一个有10个Partition的Topic，如果消费者组有10个消费者，理想情况下就是每个消费者负责一个Partition，此时*<em>并行度达到最大*</em>。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-当被问及如何在多个接口中统一管理以避免代码重复时"><a href="#1-当被问及如何在多个接口中统一管理以避免代码重复时" class="headerlink" title="1.当被问及如何在多个接口中统一管理以避免代码重复时"></a>1.当被问及如何在多个接口中统一管理以避免代码重复时</h2><p>你的初步想法是提取一个公共方法。面试官进一步引导你思考过滤器和拦截器。</p>
<p>方案1：<strong>使用Spring MVC的<code>HandlerInterceptor</code>（拦截器）</strong></p>
<p><code>HandlerInterceptor</code>是Spring MVC提供的AOP实现，专门用于在Controller方法执行前后进行预处理和后处理。它与请求生命周期紧密耦合，是处理用户认证、日志记录、上下文设置等横切关注点的标准方式。</p>
<ol>
<li>创建一个类实现<code>HandlerInterceptor</code>接口。</li>
<li>在<code>preHandle</code>方法中，从请求（如Header）中获取Token，解析出用户信息，然后调用工具类的<code>set()</code>方法将用户信息存入<code>ThreadLocal</code>。</li>
<li>在<code>afterCompletion</code>方法中，无论Controller方法执行成功还是失败，都调用工具类的<code>remove()</code>方法清理<code>ThreadLocal</code>，通常放在<code>finally</code>块中以确保执行。</li>
<li>创建一个配置类实现<code>WebMvcConfigurer</code>，重写<code>addInterceptors</code>方法，将你的拦截器注册到Spring容器中，并配置其拦截路径（如<code>/api/**</code>）。</li>
</ol>
<p>方案2：<strong>使用Servlet的<code>Filter</code>（过滤器）</strong></p>
<ol>
<li>创建一个类实现<code>javax.servlet.Filter</code>接口。</li>
<li>在<code>doFilter</code>方法中，在调用<code>chain.doFilter(request, response)</code>之前，执行<code>ThreadLocal</code>的<code>set()</code>操作。</li>
<li>使用<code>try...finally</code>结构，在<code>finally</code>块中执行<code>ThreadLocal</code>的<code>remove()</code>操作，确保无论后续处理是否异常，都能清理资源。</li>
<li>使用<code>@Component</code>和<code>@Order</code>注解（或通过<code>FilterRegistrationBean</code>）将Filter注册为Spring Bean。</li>
</ol>
<p>与<code>Interceptor</code>类似，实现了解耦和统一管理。由于作用范围更广，可以拦截静态资源等非Spring MVC处理的请求。</p>
<p>方案3：<strong>使用自定义AOP切面（<code>@Aspect</code>）</strong></p>
<ol>
<li>创建一个类，并使用<code>@Aspect</code>和<code>@Component</code>注解。</li>
<li>定义一个切点（Pointcut），例如<code>@Pointcut(&quot;within(@org.springframework.web.bind.annotation.RestController *)&quot;)</code>，用于匹配所有RestController类中的方法。</li>
<li>创建一个<code>@Around</code>环绕通知。在通知方法的<code>try</code>块中，执行<code>ThreadLocal</code>的<code>set()</code>操作，然后调用<code>proceedingJoinPoint.proceed()</code>执行目标方法。在<code>finally</code>块中，执行<code>remove()</code>操作。</li>
</ol>
<p>功能上与前两者类似，但提供了最大的灵活性，可以切入到Service层甚至任意Bean的方法。<code>@Around</code>通知需要手动调用<code>proceed()</code>，如果忘记调用，目标方法将不会被执行。</p>
<h2 id="2-策略方法怎么去解决具体调用哪一个策略"><a href="#2-策略方法怎么去解决具体调用哪一个策略" class="headerlink" title="2.策略方法怎么去解决具体调用哪一个策略"></a>2.策略方法怎么去解决具体调用哪一个策略</h2><ul>
<li>为了避免在业务代码中使用大量的<code>if-else</code>或<code>switch</code>来选择策略，我们创建了一个<strong>策略工厂（Strategy Factory）</strong>。</li>
</ul>
<ol>
<li>在项目启动时，Spring容器会扫描并加载所有<code>CouponStrategy</code>的实现类。</li>
<li>我们创建一个<code>CouponStrategyFactory</code>类，它在构造时注入一个<code>Map&lt;String, CouponStrategy&gt;</code>。Spring会自动将所有策略实现类注入到这个Map中，其中Key是Bean的名称（例如<code>&quot;fullDiscountStrategy&quot;</code>），Value是Bean实例。</li>
<li>我们约定优惠券类型（例如<code>&quot;FULL_DISCOUNT&quot;</code>, <code>&quot;PERCENTAGE_DISCOUNT&quot;</code>）与Bean名称有映射关系。</li>
<li>工厂类提供一个<code>getStrategy(String couponType)</code>方法。当业务代码需要使用某个策略时，它只需要传入优惠券类型字符串，工厂就会从Map中返回对应的策略对象。</li>
<li>我们完全消除了业务代码中的<code>if-else</code>判断。当未来需要增加一种新的优惠券时，我们只需要新增一个策略实现类，而不需要修改任何现有的业务逻辑代码，这完全符合<strong>开闭原则</strong>，使得系统非常易于扩展和维护。”</li>
</ol>
<h1 id="异常解决"><a href="#异常解决" class="headerlink" title="异常解决"></a>异常解决</h1><h2 id="1-就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢"><a href="#1-就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢" class="headerlink" title="1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢"></a>1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢</h2><p>线上出现异常，我会遵循一套<strong>从宏观到微观、由表及里</strong>的排查SOP（标准作业程序）来定位和解决问题。</p>
<p><strong>第一步：信息收集与初步判断</strong></p>
<ol>
<li><p><strong>确认影响范围</strong>：首先，快速判断这个异常的影响面有多大。是影响了所有用户，还是部分用户？是核心功能还是边缘功能？这决定了问题的紧急程度。</p>
</li>
<li><p>查看监控告警：立即查看监控系统（如Prometheus/Grafana, Zabbix）的告警信息。检查应用的</p>
<p>关键指标，如：</p>
<ul>
<li><strong>应用层面</strong>：QPS、响应时间（RT）、错误率（Error Rate）是否突增？</li>
<li><strong>JVM层面</strong>：CPU使用率、内存占用、GC活动是否异常？</li>
<li><strong>主机层面</strong>：服务器的CPU、内存、磁盘I/O、网络流量是否正常？</li>
<li><strong>依赖服务</strong>：数据库、Redis、MQ等中间件的健康状况如何？</li>
<li>这一步的目标是快速定位问题是出在<strong>应用本身</strong>，还是<strong>外部依赖</strong>。</li>
</ul>
</li>
</ol>
<p><strong>第二步：日志分析与精准定位</strong></p>
<ol>
<li><strong>聚合日志平台检索</strong>：登录ELK（Elasticsearch, Logstash, Kibana）或类似日志平台，根据告警信息中的时间点、错误信息关键字（如<code>RuntimeException</code>）进行检索。</li>
<li><strong>利用Trace ID进行链路追踪</strong>：如果系统接入了分布式追踪系统（如SkyWalking, Zipkin），这是最强大的工具。我会根据报错信息找到一个<strong>Trace ID</strong>，然后用这个ID查询完整的请求调用链。这可以清晰地看到请求经过了哪些服务，在哪一个环节耗时最长，又是在哪个服务的具体代码行抛出了异常。</li>
<li>Linux服务器手动排查（作为补充）：如果日志平台不完善，我会登录到具体的服务器上进行排查。<ul>
<li>使用<code>grep</code>命令根据关键字快速过滤日志：<code>grep -C 10 &#39;ExceptionNameToFind&#39; /path/to/app.log</code>。<code>-C 10</code>可以显示异常上下文的10行，帮助理解问题背景。</li>
<li>如果需要根据Trace ID查，我会用：<code>grep &#39;your-trace-id&#39; /path/to/app.log</code>。</li>
<li>对于实时滚动的日志，我会用<code>tail -f /path/to/app.log | grep &#39;ERROR&#39;</code>来实时监控错误输出。</li>
</ul>
</li>
</ol>
<p>第三步：<strong>根因分析与问题复现</strong></p>
<ol>
<li><strong>代码分析</strong>：定位到具体的异常代码后，分析代码逻辑，判断是业务逻辑错误、空指针、并发问题还是资源未释放等。</li>
<li><strong>环境复现</strong>：如果可能，尝试在测试环境或预发环境，构造相同的参数和条件，复现这个问题，以便于调试和验证修复方案。</li>
</ol>
<p>第四步：<strong>问题解决与复盘</strong></p>
<ol>
<li><strong>紧急修复</strong>：如果是严重Bug，立即进行Hotfix修复并上线。如果是资源问题，进行扩容或配置调整。</li>
<li><strong>复盘总结</strong>：问题解决后，必须进行复盘。分析问题发生的根本原因，是代码缺陷、设计不合理、还是容量预估不足？并制定改进措施，例如增加单元测试、完善监控告警、优化架构等，防止同类问题再次发生。</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/')">面试面经优化回答</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=面试面经优化回答&amp;url=https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510095.jpg?_r_=a3e34e80-83d8-f14a-7a77-4502d78a2aee" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E9%9D%A2%E7%BB%8F/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>面经<span class="categoryesPageCount">5</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">27</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=62fdf508-366c-3d5b-8ecb-c1fa3fd69c11" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837602.jpg?_r_=af1cd94c-ab2a-2bf2-3847-74517d9620fe" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">javase面试-深入源码</div></div></a></div><div class="next-post pull-right"><a href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=bb24e144-c84d-1554-84f2-39ee521b0d4e" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mysql底层分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/" title="JUC-源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=62fdf508-366c-3d5b-8ecb-c1fa3fd69c11" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-15</div><div class="title">JUC-源码分析</div></div></a></div><div><a href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/" title="Mysql底层分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=bb24e144-c84d-1554-84f2-39ee521b0d4e" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-15</div><div class="title">Mysql底层分析</div></div></a></div><div><a href="/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/" title="javase面试-深入源码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837602.jpg?_r_=af1cd94c-ab2a-2bf2-3847-74517d9620fe" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-12</div><div class="title">javase面试-深入源码</div></div></a></div><div><a href="/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/" title="面试面经-2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=16c252b8-d977-4d28-43c5-078963099ae5" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-29</div><div class="title">面试面经-2</div></div></a></div><div><a href="/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/" title="面试面经-1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=9aba7cca-e654-8080-5840-e5a08a39a5d0" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-25</div><div class="title">面试面经-1</div></div></a></div><div><a href="/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/" title="Spring面试题hot2-源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722382.jpg?_r_=0acda185-7932-fd6b-b51e-25feab652e03" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-19</div><div class="title">Spring面试题hot2-源码分析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">Spring框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.</span> <span class="toc-text">1.SpringBoot的配置加载优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Springboot%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.Springboot是如何解决跨域问题的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Spring-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.3.</span> <span class="toc-text">3.Spring 解决循环依赖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC"><span class="toc-number">2.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91"><span class="toc-number">2.1.</span> <span class="toc-text">1.线程池常见的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AQS%E7%9A%84%E5%A4%A7%E5%B1%80%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2.AQS的大局解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">3.wait和sleep的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92"><span class="toc-number">2.4.</span> <span class="toc-text">4.异步编排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E2%80%9C%E7%BB%86%E8%8A%82%E8%BF%BD%E9%97%AE"><span class="toc-number">2.5.</span> <span class="toc-text">5.synchronized 锁升级的“细节追问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-ThreadLocal"><span class="toc-number">2.6.</span> <span class="toc-text">6.ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%B0%88%E8%B0%88%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">2.7.</span> <span class="toc-text">7.谈谈怎么理解线程安全的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-ConditionalOnClass%E8%AE%BE%E8%AE%A1%E5%86%85%E6%B6%B5"><span class="toc-number">2.8.</span> <span class="toc-text">8.@ConditionalOnClass设计内涵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-ThreadLocal-%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.9.</span> <span class="toc-text">9.ThreadLocal 在线程池中的失效问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.10.</span> <span class="toc-text">10.如何保证三个线程有序执行任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mybatis"><span class="toc-number">3.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-UserMappe%E8%BF%99%E4%B8%AA%E7%B1%BB%E4%B8%BA%E5%95%A5%E8%A6%81%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%91%A2%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.UserMappe这个类为啥要是接口呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">4.</span> <span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaSE"><span class="toc-number">5.</span> <span class="toc-text">JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA%E5%92%8C%E9%9D%9E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="toc-number">5.1.</span> <span class="toc-text">1.流式输出和非流式输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HashMap-remove-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">5.2.</span> <span class="toc-text">2.HashMap remove 方法的实现细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">6.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E8%A1%A8join%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1.多表join的时候，小表驱动大表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%80%E6%9D%A1-UPDATE-%E8%AF%AD%E5%8F%A5%E5%8F%91%E8%BF%87%E6%9D%A5%EF%BC%8C%E4%BB%8E%E7%BD%91%E7%BB%9C%E6%8E%A5%E6%94%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%B0%E6%9C%80%E7%BB%88%E8%90%BD%E7%9B%98%EF%BC%8C%E4%BC%9A%E7%BB%8F%E8%BF%87%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">2.一条 UPDATE 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-WAL%EF%BC%9F%E5%AE%83%E7%9B%B8%E6%AF%94%E4%BA%8E%E7%9B%B4%E6%8E%A5%E5%86%99%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%86%99%E6%97%A5%E5%BF%97%E5%92%8C%E6%9B%B4%E6%96%B0%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BD%93%E4%B8%80%E4%B8%AA%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%88%86%E8%A3%82%E6%97%B6%EF%BC%8C%E5%85%B7%E4%BD%93%E9%80%BB%E8%BE%91%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">7.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%A4%B1%E8%B4%A5%E5%9B%9E%E6%BB%9A"><span class="toc-number">7.1.</span> <span class="toc-text">1.多级缓存数据一致性与失败回滚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%8C%81%E6%9C%89%E5%90%8C%E4%B8%80%E6%8A%8A%E9%94%81"><span class="toc-number">7.2.</span> <span class="toc-text">2.什么情况下，就是两个线程会持有同一把锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9CCanal%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%88%96%E8%80%85Canal%E5%88%B0%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E9%93%BE%E8%B7%AF%E5%87%BA%E7%8E%B0%E9%95%BF%E6%97%B6%E9%97%B4%E4%B8%AD%E6%96%AD%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%B9%E7%81%BE%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">3.如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%A0%E6%8F%90%E5%88%B0%E7%94%A8Redis%E7%9A%84Pub-Sub%E6%9D%A5%E5%B9%BF%E6%92%AD%E5%A4%B1%E6%95%88Caffeine%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E3%80%82"><span class="toc-number">7.4.</span> <span class="toc-text">4.你提到用Redis的Pub&#x2F;Sub来广播失效Caffeine本地缓存。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE%E9%A2%98"><span class="toc-number">7.5.</span> <span class="toc-text">5.缓存三问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%94%A8%E6%88%B7%E5%9C%A810%E5%88%86%E9%92%9F%E4%B9%8B%E5%86%85%E8%BF%9E%E7%BB%AD%E8%BE%93%E9%94%99%E4%B8%89%E6%AC%A1%E5%AF%86%E7%A0%81%EF%BC%8C%E5%B0%B1%E7%A6%81%E6%AD%A2%E5%85%B6%E7%99%BB%E5%BD%95%E2%80%9D%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8-Redis%EF%BC%8C%E4%BD%A0%E4%BC%9A%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.6.</span> <span class="toc-text">6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ"><span class="toc-number">8.</span> <span class="toc-text">MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E5%A4%84%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">1.消息队列（MQ）消息积压处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="toc-number">8.2.</span> <span class="toc-text">2.消费者组的对应</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BD%93%E8%A2%AB%E9%97%AE%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E4%BB%A5%E9%81%BF%E5%85%8D%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D%E6%97%B6"><span class="toc-number">9.1.</span> <span class="toc-text">1.当被问及如何在多个接口中统一管理以避免代码重复时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AD%96%E7%95%A5%E6%96%B9%E6%B3%95%E6%80%8E%E4%B9%88%E5%8E%BB%E8%A7%A3%E5%86%B3%E5%85%B7%E4%BD%93%E8%B0%83%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA%E7%AD%96%E7%95%A5"><span class="toc-number">9.2.</span> <span class="toc-text">2.策略方法怎么去解决具体调用哪一个策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3"><span class="toc-number">10.</span> <span class="toc-text">异常解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B0%B1%E6%AF%94%E5%A6%82%E8%AF%B4%E4%BD%A0%E8%BF%99%E4%B8%AA%E9%83%A8%E7%BD%B2%E5%88%B0%E7%BA%BF%E4%B8%8A%E4%BA%86%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%96%E6%8A%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%84%B6%E5%90%8E%E9%82%A3%E4%BD%A0%E8%BF%99%E4%B8%AA%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E5%91%A2"><span class="toc-number">10.1.</span> <span class="toc-text">1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/" title="JUC-源码分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=62fdf508-366c-3d5b-8ecb-c1fa3fd69c11" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC-源码分析"/></a><div class="content"><a class="title" href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/" title="JUC-源码分析">JUC-源码分析</a><time datetime="2025-08-14T16:00:00.000Z" title="发表于 2025-08-15 00:00:00">2025-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/" title="Mysql底层分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722379.jpg?_r_=bb24e144-c84d-1554-84f2-39ee521b0d4e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql底层分析"/></a><div class="content"><a class="title" href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/" title="Mysql底层分析">Mysql底层分析</a><time datetime="2025-08-14T16:00:00.000Z" title="发表于 2025-08-15 00:00:00">2025-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/" title="面试面经优化回答"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510095.jpg?_r_=a3e34e80-83d8-f14a-7a77-4502d78a2aee" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试面经优化回答"/></a><div class="content"><a class="title" href="/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/" title="面试面经优化回答">面试面经优化回答</a><time datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/" title="javase面试-深入源码"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837602.jpg?_r_=af1cd94c-ab2a-2bf2-3847-74517d9620fe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javase面试-深入源码"/></a><div class="content"><a class="title" href="/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/" title="javase面试-深入源码">javase面试-深入源码</a><time datetime="2025-08-11T16:00:00.000Z" title="发表于 2025-08-12 00:00:00">2025-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/" title="微服务论坛设计方案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722380.jpg?_r_=e33991d9-cb8a-61ad-aec1-65c854617651" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务论坛设计方案"/></a><div class="content"><a class="title" href="/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/" title="微服务论坛设计方案">微服务论坛设计方案</a><time datetime="2025-08-09T16:00:00.000Z" title="发表于 2025-08-10 00:00:00">2025-08-10</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">164</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">25</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 0.88rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 0.88rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 0.88rem;">FI<sup>1</sup></a><a href="/tags/Github/" style="font-size: 0.88rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/football/" style="font-size: 0.88rem;">football<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>57</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>10</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>17</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>7</sup></a><a href="/tags/paper/" style="font-size: 0.88rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 0.88rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>4</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>3</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 0.88rem;">毛选<sup>1</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>27</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>