<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>面试面经优化回答 | mengnankkのblog</title><meta name="keywords" content="面试"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="面试面经优化回答"><meta name="application-name" content="面试面经优化回答"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="面试面经优化回答"><meta property="og:url" content="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="Spring框架 1.SpringBoot的配置加载优先级 首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：   先是命令行参数（--server.port&amp;#x3D;9000 或 java -jar app.jar --spring.config.location&amp;#x3D;...）   然后"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=f367dec8-8911-a97c-1f8e-768aa23b2df8"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=f367dec8-8911-a97c-1f8e-768aa23b2df8"><meta name="description" content="Spring框架 1.SpringBoot的配置加载优先级 首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：   先是命令行参数（--server.port&amp;#x3D;9000 或 java -jar app.jar --spring.config.location&amp;#x3D;...）   然后"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: '面试面经优化回答',
  postAI: '',
  pageFillDescription: 'Spring框架, 1.SpringBoot的配置加载优先级, 2.Springboot是如何解决跨域问题的？, 3.Spring 解决循环依赖, 4.Bean的生命周期, 5.@Bean 和 @Component 的区别？, JUC, 1.线程池常见的坑, 2.AQS的大局解析, 3.wait和sleep的区别, 4.异步编排, 5.synchronized 锁升级的细节追问, 6.ThreadLocal, 7.谈谈怎么理解线程安全的, 8.**@ConditionalOnClass**设计内涵, 9.ThreadLocal 在线程池中的失效问题, 10.如何保证三个线程有序执行任务, 11.ReentrantLock 和 synchronized 在性能上到底差异在哪？, Mybatis, 1.UserMappe这个类为啥要是接口呢？, JVM, 1.那有哪些对象是可以直接在栈上分配呢？, 2.JMM和一个对象的生命周期, 3.GC, JavaSE, 1.流式输出和非流式输出, 2.HashMap remove 方法的实现细节, 3.说说 ArrayList、LinkedList、CopyOnWriteArrayList 这三者的适用场景与关键差异, 4.反射的原理ampamp应用, Mysql, 1.多表join的时候小表驱动大表, 2.一条 UPDATE 语句发过来从网络接收开始到最终落盘会经过哪些核心模块的处理, 3.为什么选择 WAL？它相比于直接写数据文件核心优势是什么？写日志和更新内存数据页的顺序是怎样的？, 4.当一个叶子节点分裂时具体逻辑是怎样的？如何处理并发问题？, 5.慢查询的的过程, 6.SQL, Redis, 1.多级缓存数据一致性与失败回滚, 2.什么情况下就是两个线程会持有同一把锁, 3.如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断会发生什么？有什么容灾方案吗？, 4.你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。, 5.缓存三问题, 6.用户在10分钟之内连续输错三次密码就禁止其登录。如果使用 Redis你会选择哪种数据结构来实现, 7.Redis持久化, 8.Redis底层数据结构, MQ, 1.消息队列（MQ）消息积压处理, 2.消费者组的对应, 3.消息不丢失ampamp消息幂等, 4.RocketMQ半事务消息, 分布式, 1.分布式事务设计, 设计模式, 1.当被问及如何在多个接口中统一管理以避免代码重复时, 2.策略方法怎么去解决具体调用哪一个策略, 3.100个有序文件如何拼接保证整体有序？, 4.设计一个高并发的系统, 5.模板方法的回答, 6.30分钟自动关闭, 7.如何设计全局统一异常处理, 网络编程, 计网, 1.对比一下 HTTP/1.0 HTTP/1.1 和 HTTP/2.0 这三个版本的主要区别。, 2.从用户在浏览器输入 URL 到页面渲染完成请按网络与系统角度分层讲解关键路径。, 3.在 TCP 三次握手过程中如果第三次握手的 ACK 报文丢失了会发生什么？, 异常解决, 1.就比如说你这个部署到线上了然后他抛了一个异常然后那你这个应该怎么排查呢, 2.考察线上问题排查, 3.线上问题卡顿, AI, 1.设计一个可扩展的架构并说明如何实现 1-2 秒 P95 的延迟指标。框架的配置加载优先级首先我们先确定一下配置加载优先级是按照我以下的顺序由高到低的分别是先是命令行参数或然后是我们的系统的环境变量和系统属性比如设置端口为比如我们在这里设置的然后占位符用于生成随机数字符串可在配置中引用接着是外部配置文件包外部的包外部的包内部的包内部的接着是我们注解指定的配置最后是我们默认的配置然后在配置文件中的配置大于因为是按加载顺序来的后加载的把的值给覆盖了对于外部配置文件查找路径的优先级为当前目录下的目录当前目录实际应用基础配置放在环境特定配置使用如通过激活敏感信息放在环境变量或外部化配置文件避免入库临时调试测试使用命令行参数临时覆盖多环境冲突处理利用合并特性公共配置放在环境差异放在对应文件是如何解决跨域问题的基本都是基于跨域资源共享通过设置响应头如告诉浏览器允许访问对于复杂跨域请求非或自定义头浏览器会先发预检请求局部注解用标记单个接口秒开跨域权限适合快速测试简单高效优先级高于全局配置全局配置使用接口统一设定允许的域名请求方法头信息统一配置但是不适合动态的控制用手动处理跨域逻辑处理适合需要动态校验权限等特殊场景比如不同权限开放不同接口在过滤器中动态判断但是实现成本较高在微服务架构中也可以在网关层如统一处理跨域减少业务服务配置优先级解决循环依赖既然能解决循环依赖那为什么我们还经常听说构造器注入无法解决循环依赖三级缓存对构造器注入为什么无效您问到了循环依赖解决方案的一个核心前提三级缓存之所以能工作其根本在于它将的实例化和属性填充这两个阶段分离开来了第一步实例化首先通过无参构造函数创建了的一个空壳实例这个实例已经有了自己的内存地址第二步暴露早期引用紧接着立即将这个空壳实例的工厂放入三级缓存从而提前暴露了的引用第三步属性填充然后才开始尝试为注入属性此时发现需要就去创建当需要时可以从三级缓存中获取到的早期引用从而打破循环构造器注入的工作流程对于构造器注入的实例化和属性填充这两个阶段是合并在一起的是原子性的当尝试创建时它必须调用的构造函数而的构造函数需要一个的实例作为参数为了满足这个参数必须先去创建而当尝试创建时又发现的构造函数需要一个的实例作为参数此时的实例根本还没有被创建出来它还卡在等待的阶段内存中不存在任何的空壳实例三级缓存中自然也就不可能有任何关于的引用这就形成了一个无法解开的死结的创建依赖的创建的创建又依赖的创建因此会直接抛出的生命周期依赖注入三级缓存流程实例化通过反射创建的实例填充属性注入的依赖初始化调用各种接口如调用的前置处理方法调用注解的方法或的方法调用自定义的调用的后置处理方法代理发生在这里使用处于可用状态销毁调用注解的方法或的方法调用自定义的和的区别面试官您好和都是向容器注册的方式但它们在使用场景和控制粒度上有本质区别注解目标不同是一个类级别的注解通过包扫描发现并自动注册为它还有三个衍生的注解用于更清晰地划分业务分层是一个方法级别的注解通常用在注解的配置类中这个方法需要返回一个对象会将这个返回的对象注册为使用场景不同用于我们自己编写的类希望自动管理它们时使用主要用于第三方库的组件因为我们无法修改第三方库的源码去添加注解所以通过方法可以显式地将其实例化并交给管理此外当一个的创建过程比较复杂需要一些前置逻辑判断时也适合用总结来说是让自动发现控制权在而是我们主动声明控制权在我们开发者手中更加灵活引出必须在被或注解的类中使用可以进一步说明的属性来体现你对底层代理的理解关于的属性这其实是深入理解容器核心原理的一个关键点它控制着是否要为我们的配置类创建一个代理从而影响之间的依赖注入行为我们可以分两种情况来看也就是为默认值和时的行为有何不同模式这是的默认行为在这种模式下在启动时会使用动态代理技术为我们的配置类比如创建一个代理子类并把这个代理子类放入容器中这个代理的核心作用是拦截所有对方法的调用当容器初始化时它会调用方法当代码执行到时因为是一个代理对象这个调用会被代理拦截代理会检查容器里是否已经存在一个名为的单例如果存在代理会直接返回容器中那个已经存在的实例如果不存在它才会执行真正的方法体创建一个新的实例将它注册到容器中然后再返回在模式下无论你在配置类内部调用方法多少次总能保证你拿到的是容器中那个唯一的正确的单例实例这保证了依赖关系的正确性我们称之为容器内的单例保证模式当我们将它设置为时情况就完全不同了不会为配置类创建代理容器中的就是一个普通的对象在这种模式下当初始化时调用方法当代码执行到时由于没有代理拦截这就变成了一次普通的方法调用它会直接执行创建一个全新的对象这意味着所依赖的那个实例和容器中独立注册的那个名为的实例是两个完全不同的对象这就破坏了的单例作用域当你的配置类中之间存在相互依赖关系时比如的创建依赖于调用方法你必须使用默认的来保证依赖注入的是容器中的单例当你的配置类中所有的方法都是独立的彼此之间没有任何调用关系在这种情况下设置为可以跳过代理的创建过程能够提升的启动性能减少内存占用事实上的很多自动配置类在可能的情况下都会选择使用模式来优化性能线程池常见的坑线程池的参数配置核心线程的数量和最大线程的数量是业务场景来的密集型比如数据的计算业务就是的数量密集型根据业务压测的值来决定的最佳线程数线程等待时间线程时间线程时间数量比如我们服务器核数为核任务线程耗时线程等待等等耗时那么最佳线程数线程那我们最大线程数就是个共享线程池次要的逻辑拖垮主要的逻辑避免所有的业务都共享一个线程池防止一个次要的业务一直在执行业务占用线程池而主要的业务并没有足够的线程数来执行影响到了我们主要的服务这样做是不合理的我们应该要做线程池的隔离使用方法的时候使用带超时时间的因为他是阻塞的防止被其他抢占是中一个注解他不是线程池他其实是不会复用线程适合执行大量短时间的线程还是尽量自己定义一个异步的线程池然后使用来注册使用线程池的时候不使用参数来自定义命名这样导致后期不好排查问题和回溯问题使用提交任务不会把异常直接抛出来最好我们在之中进行进行捕获或者是在时捕获并记录异常线程池使用完之后记得关闭防止内存泄漏的问题最好线程池设计成单例的模式长期运行的全局线程池如管理的不需手动关闭临时线程池需在中调用线程池不要和事务一起使用使用的时候依赖于当前线程的线程上下文而线程池的线程和当前事务的线程不是一个线程事务的上下文不会传递导致线程池中的业务代码不在事务中执行事务就失效了我们可以将事务放在线程池之外进行这是最好的方法或者是使用支持事务上下文传递的机制如消息队列保证一致性我们要负责监控线程池状态比如当前活跃的线程池的数量队列的长度拒绝的次数要配置合理的拒绝策略比如一个需要快速获取结果的线程就需要胚子和这样的话谁提交谁执行回退给调用的线程执行过程判断核心线程数是否已满当前运行的线程数是则直接创建一个新的核心线程来执行任务即使其他核心线程现在是空闲的否进入判断任务队列是否已满是否成功是任务入队成功等待空闲线程来处理否进入判断最大线程数是否已满当前运行的线程数是则创建一个新的非核心线程来执行任务否进入执行拒绝策略调用的大局解析是里面的一个抽象同步框架核心的作用就是统一分装了线程的等待唤醒排队机制底层通过一个的变量的队列来实现线程安全的资源性抢夺表示资源的状态独占锁里面没人占就是已经上锁可重入锁里面数字代表可重入的次数线程要抢不到锁就会被挂到队列里面进行排队队列是双向链表实现的队列节点记录了等待状态信息等他只是一个框架真正的锁逻辑交给实现类自己决定获取锁和解锁的过程获取锁尝试用修改从到如果成功则获取锁成功将锁持有者设为当前线程如果失败说明锁被占用则将当前线程包装成一个节点加入到队列的尾部加入队列后线程会自旋一小会儿再次尝试获取锁如果还是失败则调用挂起当前线程等待被唤醒释放锁修改的值比如减如果变为说明锁已完全释放则找到队列头节点的下一个节点调用唤醒它让它去竞争锁和的区别和的主要区别在于所属类不同是类的方法是类的静态方法会释放对象锁而保持锁不释放必须在同步代码块中调用没有此限制需要或来唤醒而在超时或被中断时自动恢复使用场景上用于线程间的协作用于简单的延时操作方法使当前线程进入等待状态将其从运行状态转变为等待状态并将其加入到等待池中异步编排在我看来异步编排的核心思想是将多个独立的耗时的异步任务尤其是密集型任务组合编排起来让它们尽可能地并行执行最终汇总结果从而极大地缩短整体的响应时间这在微服务架构中尤其重要在现代开发中实现异步编排最核心的工具就是举一个我们项目中非常典型的例子获取商品详情页数据一个商品详情页通常需要展示多种信息而这些信息可能来自不同的微服务或数据库表任务调用商品服务获取商品基本信息任务调用用户服务获取当前用户的优惠券信息任务调用评论服务获取商品的热门评论任务调用推荐服务获取相关商品推荐如果采用传统的同步调用方式总耗时将是的累加但实际上这四个任务没有任何依赖关系完全可以并行执行通过异步编排理想情况下的总耗时将仅仅取决于耗时最长的那一个任务即性能会得到指数级的提升实现任务并行化为每一个独立的调用任务创建一个实例关键是使用方法并为其提供一个自定义的线程池这可以避免耗尽服务器如的业务线程池结果编排与组合当所有并行的任务都完成后我需要将它们的结果组合成一个最终的我会使用来等待所有任务完成最终结果处理在完成后通过或来执行最终的组装逻辑异常处理与超时控制在生产环境中还需要考虑健壮性我会使用来处理任何一个异步任务的失败返回一个默认值或降级数据同时使用为整个编排流程设置一个最大等待时间防止因为某个下游服务缓慢而导致整个请求长时间阻塞锁升级的细节追问线程是如何从偏向锁升级到轻量级锁的是如何判断偏向失效的偏向锁的核心思想是它偏向于第一个获取它的线程认为在接下来的执行中锁将一直被这个线程持有偏向状态当一个线程第一次获取锁时会通过操作尝试将锁对象头中的线程指向当前线程如果成功就获取了偏向锁升级触发点当另一个线程线程尝试获取这个已经被线程持有的偏向锁时升级过程就被触发了偏向锁的撤销首先线程的操作会失败会检查中记录的线程是否是线程会暂停线程在一个全局安全点然后检查线程是否还存活如果线程已经执行完毕那么锁对象恢复到无锁状态线程可以重新尝试获取如果线程仍然存活且还在同步块内说明发生了真正的竞争此时偏向锁就会被撤销锁对象头的会被修改清除偏向锁标志并升级为轻量级锁的状态同时线程的栈帧中会创建锁记录指向锁对象之后线程和线程都会在轻量级锁的状态下进行竞争通过自旋只不过目前在中被默认禁用并在被完全移除因为偏向锁的撤销消耗的性能是比较大的那轻量级锁又是如何升级到重量级锁的自旋失败后发生了什么轻量级锁的核心思想是它认为锁的竞争时间会非常短线程只需要稍等一下自旋就可以拿到锁从而避免了线程阻塞和唤醒带来的内核态切换开销轻量级锁的获取线程在自己的栈帧中创建锁记录然后通过操作尝试将锁对象的指向这个锁记录如果成功就获取了轻量级锁自旋等待如果失败说明锁已被其他线程持有当前线程并不会立即阻塞而是会进行自旋即执行一个空循环不断地重试操作升级触发点升级到重量级锁主要有两种情况自旋失败自旋的次数是有限的会动态调整比如次如果一个线程自旋了指定次数后仍然没有获取到锁就认为竞争已经非常激烈了不适合再空耗竞争者过多如果在自旋过程中又有第三个线程也来竞争这把锁那么也会立即触发升级锁膨胀一旦触发升级锁就会膨胀为重量级锁锁对象的会被修改指向一个重量级锁的监视器对象所有等待锁的线程包括正在自旋的线程和后来者都不再自旋而是会被阻塞并放入的等待队列中当持有锁的线程释放锁时会唤醒等待队列中的一个线程进行新一轮的锁竞争这个过程就涉及到了操作系统的互斥量和线程的上下文切换锁的升级是单向的只能从低级别到高级别不能降级在的实现中既然用弱引用会导致内存泄漏那为什么的设计者不把也设计成强引用呢或者为什么不把也设计成弱引用为什么不能是强引用假设是强引用那么对象会通过这个强引用着对象只要线程本身不消亡这个强引用链对象就一直存在这意味着即使我们在业务代码中已经不再使用某个对象了比如只要这个线程还在线程池中被复用这个对象本身就永远无法被回收这会导致对象本身的泄漏比现在的情况更糟糕为什么不能是弱引用的核心目的就是让我们存放一些与线程绑定的数据这些数据通常是我们业务逻辑中需要用到的对象比如用户信息对象数据库连接等如果我们把也设计成弱引用那么当一次发生时只要这个对象在其他地方没有被强引用它就可能被意外地回收掉这会导致我们调用时突然得到一个值这完全违背了的设计初衷会引发严重的业务逻辑错误我们存放进去的对象必须保证在之前是可靠存在的所以必须是强引用因此只能做出了个权衡使用弱引用是为了当对象本身在外部不再被使用时能够回收它从而让中的的变为为后续的清理提供了可能性使用强引用是为了保证我们存放的数据的生命周期是可控的不会被意外回收谈谈怎么理解线程安全的线程安全指的是当多个线程同时访问一个对象或方法时无论操作系统如何调度这些线程也无需调用方在代码中去做额外的同步处理都能保证程序的正确性不会出现数据损坏或不一致的情况线程不安全的问题通常会表现在三个方面原子性一个或多个操作作为一个不可分割的整体来进行要去这个操作序列必须由一个线程独占完整的去执行不能被其他线程所干扰调不可被中断可见性一个线程修改了一个共享变量的值这个修改的值能够被其他线程看到但是实际在的高速缓存下对指令做出的重排序操作导致共享变量的值对其他线程不是立即课件的缓存读的旧值有序性写的代码的顺序和实际代码的顺序不一致是由于编译器和处理器层面对指令重排优化导致的可能会导致可见性问题我们可以使用或者是直接加或者是直接加锁或者使用原子类的或者是线程安全的设计内涵面试官提出了一个非常精妙的问题这行代码能编译通过说明肯定存在于中那为什么还需要这个注解呢未能理解系列注解是为了解决通用模块在不同应用环境下的适配性问题而不是为了解决当前项目中的类是否存在的问题确实如果在我当前的项目中写这个条件判断看起来是多余的因为如果不存在我的项目根本无法编译通过这个注解的真正威力体现在开发通用的模块时想象一下我们正在开发一个这个希望能够同时支持阿里云短信和腾讯云短信我们的会提供两个自动配置类和负责创建阿里云短信服务的负责创建腾讯云短信服务的一个使用者应用项目在他的项目中引入了我们的他可能只想使用阿里云短信所以他只会在他的中添加阿里云的依赖而不会添加腾讯云的这时我们的如何智能地判断只加载阿里云的而不去加载腾讯云的呢如果去加载腾讯云的会因为缺少腾讯云的包而直接抛出导致应用启动失败我们就是使用在上我们会这样写当使用者的应用启动时会解析我们中的这两个自动配置类在解析时它会检查当前应用的中是否存在因为使用者添加了阿里云的依赖所以这个类存在条件满足这个配置类就会被加载阿里云的就会被创建在解析时它会检查中是否存在因为使用者没有添加腾讯云的依赖所以这个类不存在条件不满足这个配置类就会被优雅地跳过不会被加载从而避免了并不是为了判断我们自己项目里的类是否存在而是为了让我们开发的通用模块能够智能地感知和适配它所运行的应用环境根据应用环境中引入了哪些依赖来动态地决定哪些功能应该被激活这是实现约定大于配置和开箱即用的关键魔法之一在线程池中的失效问题之所以能够实现父子线程间的数据传递是因为在创建子线程时子线程的构造函数会检查父线程的这个如果它不为空子线程就会将父线程中的所有值拷贝一份到自己的中关键在于这个值的拷贝动作只发生在子线程被创建的那一瞬间在线程池的场景下工作线程通常在系统启动时就已经被预先创建好了并存放在池中当我们提交一个任务时线程池只是从池中取出一个已经存在的线程来执行我们的任务并没有这个动作为了解决这个问题阿里巴巴开源了一个非常强大的工具它专门用于解决在使用线程池等会池化线程的组件时实现父子线程任务提交者与任务执行者之间的上下文传递问题的优点在于它通过或手动包装的方式对线程池的等方法以及任务进行了装饰任务提交时当我们调用被装饰过的时会捕获当前线程父线程的值并将其打包进一个或对象中任务执行前当线程池中的某个工作线程开始执行这个被包装过的时在其方法的块开始处会将被打包的父线程值回放到当前工作线程的中任务执行后在块中会清理当前工作线程的将其恢复到执行任务之前的状态从而避免了数据串扰如何保证三个线程有序执行任务方案使用方案你需要自己管理锁状态变量循环防止伪唤醒保证锁释放代码量大且极易出错使用会唤醒所有等待的线程造成不必要的竞争而使用又存在风险如果错误地唤醒了不该被唤醒的线程比如唤醒了而不是信号就可能丢失导致程序死锁方案升级版提供了比更强大的功能对象则将机制从一个锁只有一个等待队列升级为一个锁可以有多个独立的等待队列我们可以为每个线程的等待室创建一个实现精准的点对点唤醒彻底避免了的信号丢失问题创建一个实例创建一个状态变量例如用于标识当前应该哪个线程执行为每个线程创建一个对象线程的逻辑获取锁在中执行块中执行任务更新状态精准唤醒线程线程和的逻辑与类似分别在自己的上并在执行完任务后更新并下一个线程的实现了有序执行通过实现了精准唤醒比更高效比更安全但还是比较复杂方案信号量接力信号量是控制同时访问特定资源的线程数量的工具我们可以创建两个初始许可为的信号量作为两个线程之间的接力棒创建两个信号量和线程的逻辑执行任务执行完毕后释放一个给的许可线程的逻辑首先尝试获取来自的许可如果许可未被释放将在此阻塞获取到许可后执行任务执行完毕后释放一个给的许可线程的逻辑首先尝试获取来自的许可获取到许可后执行任务代码清晰简单但需要创建个对象如果线程数量很多会增加一些对象管理的开销方案会创建一个单线程的线程池这个线程池的核心特性是它内部有一个无界的来存放任务并且永远只有一个工作线程来从队列中取出并执行任务这就天然地保证了所有提交给它的任务都会严格按照提交的顺序来串行执行创建一个单线程执行器定义三个任务或按顺序提交任务关闭线程池严格来说这是三个任务有序执行而不是三个不同的线程有序执行因为所有任务都是由同一个工作线程来执行的如果面试官的题目严格要求必须是三个不同的预先创建好的线程那么这个方案就不完全符合字面要求和在性能上到底差异在哪实现它是的关键字由层面直接实现其核心依赖于操作系统底层的互斥量开销获取和释放需要进行用户态到内核态的切换这是一个非常昂贵的操作涉及到线程上下文的切换和调度会消耗大量的时间实现它是一个类位于包下其核心是基于框架实现的开销在底层利用了这一原子指令和关键字在无竞争或低竞争的情况下可以通过操作直接在用户态完成锁的获取完全避免了内核态的切换因此性能极高性能一定优于这个说法在之前是成立的但在之后对进行了翻天覆地的优化引入了锁升级机制使其性能在很多场景下已经不输甚至优于偏向锁在只有一个线程访问同步块的场景下几乎没有同步开销性能极高轻量级锁当出现少量线程交替竞争时会使用自旋的方式尝试获取锁自旋也是在用户态完成的避免了线程阻塞和内核态切换性能同样很高重量级锁只有当竞争非常激烈自旋多次仍无法获取锁时才会升级为重量级锁退化到依赖操作系统的只不过有更多的功能可中断等待允许线程在等待锁的过程中响应中断可超时等待可以避免死等多条件变量一个可以创建多个对象实现更精细的线程通信这个类为啥要是接口呢的之所以必须定义为接口其根本原因在于框架在底层使用了动态代理技术来为我们自动地生成这个接口的实现类只定义了接口并在文件中写了但我们从来没有手动编写过一个然而在层我们却可以直接注入一个的实例并调用它的方法启动时扫描当容器启动时的会扫描指定的包路径如找到所有被注解标记的接口或者所有继承了特定标记接口的接口注册定义对于找到的每一个接口比如并不会去创建一个真实的实现类而是在容器中注册一个特殊类型的定义创建代理对象当层需要注入时会向请求获取实例此时就会调用动态代理在内存中动态地生成一个接口的代理实现对象这个动态生成的代理对象它的内部有一个当我们调用代理对象的任何方法时比如这个调用都会被拦截的逻辑大致是它会获取到我们调用的方法名和参数它会将方法名与文件中配置的语句的进行映射和绑定它会从连接池获取一个数据库连接将参数设置到语句中然后通过执行这条最后它会将查询结果封装成我们方法签名中定义好的返回类型如对象并返回正是因为依赖于动态代理而动态代理技术本身就要求被代理的目标必须是一个接口它无法为一个具体的类或抽象类创建代理这就是为什么必须是接口的根本技术原因那有哪些对象是可以直接在栈上分配呢在中并不是特定类型的对象能够直接在栈上分配而是取决于该对象的作用域通过一种叫做逃逸分析的技术来判断一个对象是否可以安全地在栈上分配如果一个对象的引用没有逃逸出它被创建的方法之外那么它就可能被优化为在栈上分配这样做的好处是当方法执行结束时栈帧被弹出对象的内存会立即被回收无需等待垃圾回收从而提高性能逃逸分析是即时编译器的一项优化技术默认在现代中是开启的只有那些生命周期完全局限于单个方法调用内体积较小且线程安全的对象才最有可能被优化到栈上进行分配未逃逸的定义仅在方法内部使用对象的引用完全封装在方法体内没有被方法返回未赋值给外部变量没有将该对象的引用赋值给任何类变量字段或实例变量未传递给可能逃逸的方法没有将该对象的引用作为参数传递给其他方法或者传递给了但能确定其他方法也不会让它逃逸逃逸的例子比如对象作为方法的返回值他就是逃离了这个方法的作用域对象引用赋值给实例变量也是逃离这个方法的作用域和一个对象的生命周期划分线程共享方法区堆线程私有程序计数器虚拟机栈本地方法栈生命周期创建类加载检查堆内存分配指针碰撞空闲列表初始化零值设置对象头执行方法进行使用回收可达性分析垃圾回收算法分代回收优化手段逃逸分析栈上分配线程本地分配缓冲等优化手段逃逸分析栈上分配和是为了自动化地提升对象分配效率降低压力而设计的一套协同工作的优化组合拳逃逸分析是决策入口它决定了一个不逃逸的对象是否有资格享受栈上分配这一特权从而完全避免对于必须在堆上分配的逃逸对象则为它们提供了线程私有的通道避免了并发分配时的锁竞争当我们在代码中写下时这个对象在中并不是无脑地直接被分配到堆上它会经历一个由即时编译器主导的充满优化的审批流程逃逸分析逃逸分析是一种编译期优化技术它不是直接的优化手段而是一种分析手段编译器会分析一个对象的动态作用域判断这个对象是否有可能逃逸出它的创建方法或当前线程如果逃逸分析的结果是这个对象完全不逃逸那么就会启用一个颠覆性的优化栈上分配是指将那些不逃逸的小对象直接在当前线程的虚拟机栈上进行分配而不是在堆上如果逃逸分析的结果是这个对象逃逸了必须在堆上分配那么并不会立刻去抢占全局的堆内存而是会尝试一个更高效的策略线程本地分配缓冲是为了提升对象在堆上分配的效率而设计的一种机制会在堆的新生代区为每个线程预先分配一小块私有的内存区域这个区域就叫避免并发冲突堆是所有线程共享的如果没有那么每次一个对象多个线程都需要去竞争同一块区的内存这个过程需要加锁比如来保证分配的原子性在高并发下会成为性能瓶颈当一个线程需要分配一个新对象时它会首先尝试在自己的中进行分配因为是线程私有的所以在这个区域内分配对象完全不需要加锁速度极快这是一个简单的指针碰撞操作只有当的空间用完了或者要分配的对象太大放不下时线程才会去申请一个新的或者在全局的区此时需要加锁进行分配然后在堆中是如何分配的呢内存分配方式主要有两种指针碰撞和空闲列表如果堆内存是规整的就用指针碰撞简单高效如果是不规整的比如使用收集器后就用空闲列表并发处理在多线程并发创建对象时如何保证堆上分配的线程安全除了你提到的每个线程预先在区申请一小块私有区域另一种方式是对整个堆的分配动作进行加锁是为了避免频繁的加锁是一种更高效的优化除了这些内还有一个优化的策略就是堆外内存它是一种手动管理的内存区域不属于的管理范畴通过的方法分配的内存这块内存并不在堆上而是直接向操作系统申请的本地内存特性堆内存堆外内存管理者自动管理开发者手动管理机制分配速度快慢系统调用访问速度快极快与交互时影响受影响可能不受影响大小限制受参数限制受物理内存限制我们可以使用他来完成零拷贝的操作当进行网络或文件操作时如果数据在堆内存中需要先从堆内存拷贝到内核缓冲区再由操作系统发送出去如果数据直接在堆外内存中可以直接将这块内存的地址交给操作系统省去了从用户态到内核态的这次数据拷贝实现了零拷贝极大地提升了性能使用等高性能网络消息框架大量使用堆外内存作为网络通信的缓冲区需要缓存大量数据且不希望对造成巨大压力的场景例如本地缓存框架但是容易出现内存泄漏和排查困难的问题如何定位和分析内存问题的通过监控工具如或者日志通过堆内存再用等工具分析是优化了数据结构减少内存占用还是调整了参数比如回收每个对象从诞生之初就在它的对象头里为它设置了一个年龄计数器占个这个年龄是对象晋升老年代的主要依据绝大多数新创建的对象首先会被分配在新生代的区此时它们的年龄为当区满了之后会触发第一次会扫描区将所有存活的对象复制到新生代的区中的一个我们称之为区在这个复制的过程中这些幸存对象的年龄会加区中所有未被复制的被判定为垃圾的对象都会被一次性清空新生代有两个区我们通常称之为和在任何时刻总有一个是空的另一个是有数据的当下一次发生时会同时扫描区和区即上次存放幸存对象的那个区所有存活的对象都会被再次复制到那个空的区同样在复制过程中这些对象的年龄会再次加清空区和区然后和的角色互换为下一次做准备这个过程会一直重复对象就在和之间来回倒腾每经历一次只要它还活着年龄就会加当一个对象在区中不断地倒腾其年龄达到一个设定的阈值时在下一次中它将不再被复制到另一个区而是被直接晋升到老年代这个年龄阈值可以通过参数来设置默认是因为对象头中的年龄计数器只有个最大能表示的数字就是二进制一个新生代的晋升流程年龄为的时候进入老年代除了年龄达到阈值还有一种情况会触发晋升如果在区中相同年龄的所有对象大小的总和大于空间的一半那么年龄大于或等于该年龄的对象就可以直接进入老年代无需等到这个规则是为了防止区被过度填充如果大量同龄的对象在某次后集中幸存可能会导致区空间不足进而触发更复杂的分配担保机制动态年龄判断可以在这种情况发生前提前将一些年长的对象送到老年代为更年轻的对象腾出空间大对象直接晋升这个对象的大小超过了由参数设定的阈值那么这个大对象将不会被分配在新生代的区而是会被直接分配到老年代在执行之前会检查老年代的连续可用空间是否大于新生代所有对象的总大小或者大于历次晋升到老年代的对象的平均大小如果是那么这次是安全的如果否会进行一次来清理老年代以腾出更多空间如果在过程中区确实无法容纳所有存活对象那么多余的对象就会通过这个分配担保机制被直接移入老年代对象死亡的三个方法引用计数器可达性分析方法可达性分析需要两次标记第一次看是不是没用跟引用链相连第二次看队列中的是不是还没有相连选择标记清除的核心原因是它是一个并发收集器在垃圾收集的大部分阶段用户线程和线程是可以同时运行的而标记整理算法需要移动对象这个过程非常复杂很难与用户线程并发执行所以只能选择实现相对简单的标记清除这也正是产生内存碎片的根本原因的核心优势恰恰在于它的并发标记和并发清除阶段是可以和用户线程一起运行的从而大大缩短了时间的主要发生在初始标记和重新标记这两个非常短暂的阶段你应该强调的总时长很短但不可预测而的虽然也是分阶段的但其总时长可以在一个目标范围内被预测和控制流式输出和非流式输出对比点流式输出非流式输出数据传输边生产边传输生成完后一次传输响应延迟首字节快用户能尽快看到结果必须等所有数据生成后才能看到内存占用占用更少内存分段处理可能占用大量内存一次性加载实现复杂度较高需要支持分段协议推送机制较低一次性返回应用场景视频流日志实时消费逐字打印小文件下载查询一次性返回结果非流式输出是等数据全部生成后一次性返回而流式输出则是边生成边返回能降低延迟和内存占用更适合大数据量和实时场景方法的实现细节首先方法会计算的值根据值定位到它在底层数组中的索引位置即如果该为空直接返回如果不为空则遍历该位置的链表或红黑树逐个节点使用值和方法进行比较直到找到要删除的目标节点如果遍历完没找到也返回如果当前是链表结构是头节点的话即让头节点的下一个节点成为新的头节点是中间节点或尾节点那么就跳过这个节点将自动回收这个不再被引用的节点红黑树的删除操作要复杂得多因为它必须在删除节点后通过一系列的旋转和重新着色操作来维持红黑树的条性质例如根是黑的不能有连续的红节点任何节点到其每个叶子节点的所有路径都包含相同数目的黑色节点等从而保证树的平衡性会调用内部的方法来执行这个复杂的过程在红黑树中删除了一个节点后还会检查该的节点数量如果数量减少到了一个阈值默认为为了节省内存和在节点数少时提升性能这棵红黑树会退化变回普通的链表结构删除成功后的会减方法会返回被删除节点的值说说这三者的适用场景与关键差异底层结构基于动态数组实现内存是连续的它实现了标记接口关键差异读性能支持高效的随机访问操作的时间复杂度是写性能尾部添加均摊复杂度是但在中间插入或删除元素需要移动后续所有元素时间复杂度是开销很大迭代一致性它的迭代器是快速失败的如果在迭代过程中集合结构被其他线程修改会立刻抛出底层结构基于双向链表实现关键差异读性能不支持高效的随机访问访问一个元素需要从头或尾遍历时间复杂度是写性能在头部或尾部进行增删操作时间复杂度是效率极高但在中间位置操作需要先遍历定位所以复杂度也是迭代一致性和一样是快速失败的底层结构同样基于数组关键差异并发安全它是线程安全的核心思想是写时复制读性能读操作完全不加锁直接访问底层数组性能和相当非常高效写性能写操作增删改开销巨大它需要先加锁然后完整地拷贝一份新数组在新数组上修改最后再将引用指向新数组迭代一致性它的迭代器是快照模式迭代器创建时会引用当时的底层数组快照后续的修改对该迭代器不可见不会抛出异常保证了迭代的绝对安全但牺牲了数据的实时性反射的原理应用反射机制允许程序在运行时动态地获取任意一个类的信息如属性方法构造器并进行操作它的优点是极大地增加了程序的灵活性是很多框架如的实现基石在动态代理中反射主要用在最关键的一步创建代理对象实例整个流程是我们调用方法来创建代理对象在这个方法内部它会在运行时动态地创建一个新的代理类文件然后它会使用反射通过获取到这个新代理类的构造器最后再通过反射调用传入我们自己实现的来实例化这个代理对象比如代理模式的实现就是在对象进行初始化的时候在的后置处理的时候将原先的换成我们代理的所以反射是用在了获取代理类的构造器并创建其实例这最核心的一步多表的时候小表驱动大表在的中驱动表首先被扫描的表被驱动表对驱动表每一行根据条件去查找匹配行的表核心原则过滤后剩余行数少的表应该作为驱动表这样可以减少被驱动表的访问次数这就是小表执行过程扫描驱动表全表扫描或索引扫描对驱动表的每一行根据连接条件在被驱动表中查找通常用索引查找如果被驱动表使用二级索引且需要回表则访问主键索引小表驱动大表大表负责命中索引比如数据库会全表扫然后每拿到一行就去比较条件去表里面查表命中索引的查询实际上就是一个搜索树查询的时间复杂度近似然后加上一次回表可能就是所以总体的时间复杂度为如果是覆盖索引的话复杂度可降为所以我的们越小越好的本质就是查驱动表然后扫被驱动表当然是查的越少越好了一条语句发过来从网络接收开始到最终落盘会经过哪些核心模块的处理是一个分层的核心模块包括网络层层和存储引擎层如果以一条语句为例它的生命周期是这样的网络层首先客户端通过连接发送这条我的网络模块基于实现会接收这个请求并将其传递给层层解析与执行解析器层会解析这条字符串生成一个抽象语法树执行器然后执行器会解释这棵树对于这条语句它知道要去表中找到的行并更新列存储引擎层事务与数据处理这是最核心的部分事务管理器执行器会向事务管理器申请开启一个事务访问数据执行器请求存储引擎去获取的行存储引擎会先去内存缓冲池里查找如果数据页不在内存会通过模块从磁盘加载并发控制在读取和修改数据时为了保证隔离性这里会涉及到和锁管理器是一种当前读所以它会读取最新的已提交版本并在这行数据上加一个排他锁防止其他事务同时修改执行修改获取到锁之后执行器会在中修改对应的数据页但它不是直接覆盖旧数据而是会生成一个日志记录下修改前的样子用于回滚和支持记录日志在修改内存数据页之前必须先将这次操作的详细信息写入日志的内存缓冲区这是为了保证持久性提交事务当客户端发起时日志管理器会确保对应的日志被刷入磁盘只要日志落盘了即使此时宕机数据也能恢复所以我们就可以认为事务提交成功了数据落盘至于里的脏数据页则由一个后台线程根据一定的策略比如异步地刷回磁盘这个过程不影响事务的提交响应为什么选择它相比于直接写数据文件核心优势是什么写日志和更新内存数据页的顺序是怎样的选择的核心优势在于将随机转换为了顺序极大地提升了写入性能并保证了数据不丢失性能提升数据库的数据页在磁盘上是离散存储的修改它们需要大量的随机磁盘寻址非常慢而日志文件是追加写入的是顺序速度比随机快几个数量级通过事务提交时只需要保证日志落盘即可脏数据页可以异步批量地刷回磁盘大大降低了事务提交的延迟顺序保证这个顺序是绝对不能颠倒的必须是先写日志再更新内存页这就是预写日志这个名字的由来原因如果反过来先修改了内存中的数据页然后系统在写日志之前宕机了那么当系统重启时内存中的修改会全部丢失而日志里又没有记录这次操作这个更新就永远地丢失了这违反了事务的持久性而只要保证日志先写入即使系统在数据页刷盘前宕机重启后也可以通过扫描日志来恢复数据保证了数据的完整性当一个叶子节点分裂时具体逻辑是怎样的如何处理并发问题当向一个叶子节点插入数据发现它已经满了的时候会触发分裂操作逻辑如下叶子节点分裂找到中间位置的将节点平分成两个将这个中间连同指向新节点的指针一起上提到父节点中内部节点分裂如果因为子节点的上提导致父节点也满了那么父节点内部节点也需要分裂找到中间位置的将该单独上提到它的父节点中而该左右两侧的和指针则分别构成两个新的内部节点这个过程可能会一直递归到根节点根节点分裂如果根节点也需要分裂那么分裂后会产生一个新的根节点此时树的高度加一关于并发问题这是一个非常关键的点对树的这种结构性修改如分裂或合并必须是原子的否则可能导致树的结构被破坏当一个线程需要修改一个树节点时它会先获取这个节点的在分裂过程中它会同时持有父节点和要分裂的子节点的操作完成后再释放这种方式只锁定了必要的节点允许其他不相关的读写操作继续进行和区别保护对象锁是在事务层面用来保护逻辑数据比如表中的一行记录它的目的是保证事务的隔离性闩锁是在线程层面用来保护内存中的物理数据结构比如中的一个数据页树的一个节点或者一个共享的内存链表它的目的是保证多线程访问共享内存结构时的线程安全持有时间的持有时间很长可能会贯穿整个事务直到事务提交或回滚才释放的持有时间非常短通常只在一次原子操作的临界区内持有比如修改一个树节点操作一完成马上就释放死锁会涉及到死锁问题需要数据库有专门的死锁检测机制而通常通过规定获取顺序比如在树中总是从父节点到子节点获取来避免死锁所以一般认为是无死锁的简单来说是给数据库用户事务用的保证业务逻辑的正确性是给数据库内核开发者用的保证内核数据结构的正确性为什么选择树在上看关键在于高扇出数据库的数据是存储在磁盘上的操作非常昂贵我们需要一种矮胖的数据结构而不是瘦高的平衡二叉树为什么不行因为它是二叉的每个节点最多两个子节点一棵存储百万数据的树深度会非常高约导致需要进行很多次磁盘才能找到数据树为什么行树的非叶子节点只存储索引而不存储数据这意味着在同样大小的磁盘页比如中树的非叶子节点可以存放成百上千个索引指针这就是高扇出因此一棵三到四层的树就能存储上千万甚至上亿的数据查询时只需要次磁盘树相比树的劣势树的非叶子节点也存数据导致其扇出没有树那么高树的高度会相对更高次数更多哈希表的另一个致命缺点除了哈希冲突哈希索引不支持范围查询而数据库中这样的范围查询非常普遍这是树的叶子节点通过双向链表连接起来所能高效支持的慢查询的的过程第一步开启慢查询日志在中配置和让数据库自动记录超过阈值的慢第二步分析慢查询日志使用等工具对日志文件进行分析找出出现频率最高查询时间最长的第三步使用分析执行计划针对找到的慢使用查看其执行计划重点关注是否为全表扫描是否用上了索引是否出现了等关键字段通过在字段上增加联合索引并利用索引覆盖我们将这条的查询时间从秒优化到了毫秒接口的响应时间也从秒降低到了毫秒查询前使用使用函数不考虑并列给出连续排名考虑并列但会跳过排名比如两个第二名下一个就是第四名考虑并列且不跳过排名在取的场景下或通常是更合适的选择联合索引怎么走怎么走只会使用到联合索引的部分而和部分将无法有效地利用索引来缩小查询范围优化器首先会使用索引来处理这个条件它会在索引树上进行范围扫描找到所有满足大于给定值的索引记录这部分是高效的这是最关键的一点当索引遇到了一个范围查询如那么这个范围查询列也就是右边的所有索引列也就是和都会失效无法再用于进一步的索引查找为什么会失效联合索引的排序是严格按照的顺序来的它首先按排序在值相同的情况下再按排序以此类推当你执行时你筛选出的是一个值的范围在这个范围里的值是无序的或者说只是在每个单独的值内部有序但整体是无序的因此数据库无法利用索引去快速定位满足的记录只能一条一条地去过滤多级缓存数据一致性与失败回滚当被问及如何保证和本地缓存更新的原子性以及在更新失败时如何回滚你的回答提到了不甚准确的编程式事务并最终倾向于人工处理方案引入消息队列进行可靠的异步处理修改架构不再直接调用消费逻辑而是将解析后的事件作为消息发送到的一个中消费者逻辑消费者服务从拉取消息其处理逻辑是先失效缓存再发布一个广播消息如通过通知所有应用实例失效本地缓存失败处理只有当所有步骤成功后消费者才向发送如果处理过程中任何一步失败如连接超时消费者不发送会在超时后将该消息重新投递给其他消费者实现自动重试方案死信队列在的消费者逻辑中使用等框架对缓存失效操作进行封装配置重试策略例如重试次每次间隔采用指数退避如避免在故障期间频繁冲击下游服务配置一个当所有重试都失败后将这条失败的事件包含表名主键操作类型等信息发送到一个专门的死信队列或记录到数据库的失败任务表中部署一个独立的监控程序或定时任务消费中的消息并发送告警邮件短信钉钉如果重试逻辑设计不当可能会在短时间内放大故障死信队列需要有完善的监控否则会成为被遗忘的角落方案先更新缓存再更新数据库的策略写请求先更新或失效缓存然后更新数据库为了解决并发更新导致的不一致问题可以引入延时双删先删缓存更新数据库延迟一段时间如后再次删除缓存本地缓存仍然可以通过监听的失效事件或消息广播来同步失效非常不推荐延时双删的延迟时间很难确定无法保证一致性代码侵入性强业务逻辑与缓存逻辑耦合严重维护困难什么情况下就是两个线程会持有同一把锁两个不同的线程在同一时刻是不可能持有同一把锁的这是锁的互斥性基本原则所保证的如果出现了这种情况那一定是锁的实现出了严重的问题您这个问题可能是在考察一个非常重要的特性锁的可重入性可重入性指的是同一个线程可以多次成功获取同一把锁而不会自己把自己锁死在释放锁时也需要释放相应次数后锁才会被真正释放比如在一个复杂的业务方法中它获取了锁然后它又调用了另一个方法而方法也需要获取同一个锁如果没有可重入性那么在方法中当前线程会因为无法获取一个已经被自己持有的锁而陷入死锁实现巧妙地使用了的数据结构来实现当一个线程第一次获取锁时它会在中创建一个这个的是锁的名称例如这个结构内部会存储两个关键信息一个存储持有锁的线程标识例如另一个存储一个计数器表示该线程重入的次数初始值为当同一个线程再次尝试获取这把锁时会检查中存储的线程标识如果与当前线程标识匹配它就不会阻塞而是直接将计数器的值加表示又重入了一次当线程释放锁时它会去将计数器减只有当计数器的值减到时才会真正地从中删除这个即释放锁这样其他线程才有机会获取如果挂了怎么办或者到消费端的链路出现长时间中断会发生什么有什么容灾方案吗您提的这个问题非常关键它涉及到整个数据同步链路的高可用性自身的高可用首先自身是可以部署成高可用集群的通过进行集群管理和主备选举当主节点宕机时备用节点可以自动接管从而保证了数据订阅服务的连续性链路中断的影响如果到消费端的链路中断确实会导致缓存与数据库在中断期间的数据不一致窗口期变长新写入的数据无法触发缓存失效用户可能会在一段时间内读到旧的缓存数据我们的容灾与补偿策略监控与告警我们必须对的消费位点与主库的最新位点之间的延迟做严格的监控一旦延迟超过阈值比如分钟就立即触发高级别告警通知和开发团队介入设置合理的缓存即使同步链路中断我们缓存中的数据也不是永久有效的通过为所有缓存设置一个合理的兜底过期时间比如小时可以保证即使在最坏的情况下数据不一致的时间也不会无限延长这是一种自愈机制手动全量增量校准对于极端重要的数据我们会准备一个手动触发的数据校准脚本当链路长时间中断并恢复后可以运行这个脚本根据时间戳或版本号主动查询数据库强制刷新中的核心数据确保最终一致性你提到用的来广播失效本地缓存是即发即忘模式不保证消息必达如果某个应用实例因为网络抖动没收到失效消息怎么办您观察得非常仔细确实存在消息丢失的风险对于这个问题我们有分层级的解决方案接受短暂不一致对于大部分业务场景单台服务器上短暂的本地缓存不一致是可以接受的因为流量通常会通过负载均衡打到多台服务器上只有一小部分用户请求会命中这台机器的旧缓存且本身也有过期机制影响是可控的引入更可靠的消息总线如果业务对一致性要求极高我们会放弃轻量级的转而使用更可靠的消息中间件如的广播消费模式每个应用实例都作为一个消费者组内的广播消费者订阅失效通知的机制可以保证每个实例都可靠地收到失效消息版本号机制我们可以在缓存的对象中增加一个版本号或时间戳字段当应用从缓存中获取到数据后可以在某些关键操作前与数据库中的版本号进行一次快速比对如果发现缓存版本落后就主动失效本地缓存并重新加载这是一种主动校验的补偿机制缓存三问题布隆过滤器和缓存空值这两种方案在你的项目中你会如何选择它们各自有什么优缺点和需要注意的地方方案一缓存空值优点实现简单逻辑清晰开发和维护成本极低效果直接能拦截住对同一个不存在的的重复攻击缺点与注意事项消耗额外的缓存空间如果被恶意攻击攻击者不断变换不存在的来查询会导致中存储大量的空值造成内存浪费数据一致性问题如果这个之前不存在的数据后来又在数据库中被创建了例如一个新用户注册了缓存中的空值需要有一种机制被及时地更新或失效否则会导致用户刚注册完却查不到自己的信息适用于不存在的的集合相对固定或者重复查询率高的场景例如查询一个已经下架的商品方案二布隆过滤器优点空间效率极高它使用位图来存储数据占用的内存空间远小于缓存空值方案非常适合处理海量数据缺点与注意事项存在误判率布隆过滤器判断不存在是准确的但判断存在时有一定概率会把一个不存在的误判为存在这意味着它无法完全拦截所有穿透请求会有一小部分漏网之鱼打到数据库无法删除元素标准的布隆过滤器不支持删除操作如果数据需要频繁地增删就需要使用等变种实现更复杂初始化和重建成本需要在系统启动时将全量数据加载到布隆过滤器中这个过程可能比较耗时当数据发生变化时也需要有机制来同步更新过滤器适用场景适用于数据量巨大但数据相对稳定且对误判率有一定容忍度的场景例如防止恶意用户用随机生成的来攻击用户查询接口用户在分钟之内连续输错三次密码就禁止其登录如果使用你会选择哪种数据结构来实现方案使用的命令是原子性的可以保证在并发环境下计数的准确性命令可以为一个设置生存时间完美地契合了分钟之内这个时间窗口的需求定义为每个用户的登录失败计数定义一个清晰的例如登录失败逻辑当用户登录失败时执行以下操作对该用户的执行命令获取增长后的计数值判断是否是第一次失败如果等于说明这是分钟窗口内的第一次失败此时必须为这个设置过期时间秒分钟检查是否达到阈值判断是否大于等于如果是则触发锁定用户的逻辑例如在数据库中更新用户状态或在另一个中设置一个锁定标记登录成功逻辑当用户登录成功时应该立即删除这个计数以清除之前的失败记录问题存在一个微小的竞态条件在和两个命令之间如果服务器恰好宕机或重启可能会导致一个计数被创建但没有设置过期时间从而变成一个永久的计数器虽然概率极低但在高并发系统中仍需考虑解决方案可以使用脚本将和两个操作打包成一个原子操作或者使用一条命令完成方案灵活精确作为失败记录队列的是一个双向链表可以作为队列使用通过在队头插入元素修剪队列长度可以非常高效地维护一个固定大小的事件窗口定义登录失败逻辑获取当前时间戳秒或毫秒并将其作为元素到的头部检查当前失败次数获取的长度如果大于等于说明已经发生了至少次失败此时获取中第个元素即最早的那次失败记录索引为判断时间窗口计算当前时间与的时间差如果差值小于分钟则说明在分钟内发生了次失败触发锁定逻辑队列维护为了防止无限增长可以在每次后使用命令只保留最近的条记录同时为整个设置一个比分钟稍长的过期时间如分钟用于自动清理冷数据登录成功逻辑同方案一掉对应的实现了精确的时间窗口判断内存占用非常小因为每个用户的最多只存储个时间戳方案三功能强大实现滑动时间窗口的是一个有序集合每个成员都关联一个我们可以用来存储事件发生的时间戳利用按分数范围查询和删除的特性完美地实现滑动时间窗口定义登录失败逻辑获取当前时间戳为了防止成员重复可以给每个成员一个唯一的值例如将新的失败记录添加到中和都使用时间戳或是时间戳是唯一清理过期记录移除所有分钟之前的记录这是一个非常关键的步骤保证了窗口的滑动假设是毫秒统计窗口内次数获取当前中的成员数量检查阈值如果大于等于触发锁定逻辑登录成功逻辑同方案一掉对应的持久化是快照模式是指令日志模式并理解了它们都是为了解决宕机后的数据恢复问题你提到了文件小恢复快但可能丢失数据文件大恢复慢但数据更完整这是一个非常关键的知识点当和文件同时存在时会优先选择文件来恢复数据为什么因为文件通常记录的数据比文件更完整更新的默认策略是每秒写一次盘而默认是几分钟甚至更久才生成一次快照为了尽可能少地丢失数据的设计者选择了优先使用数据更全的重写你提到了文件会很大这是一个很重要的缺点但你没有提到解决这个问题的关键机制重写会在后台定期地对文件进行重写将多条冗余的命令比如对一个多次合并成一条最终的命令从而大大压缩文件的大小这个机制是能够被长期使用的重要保障的触发方式是一段时间触发一次可以更具体地说明其触发方式主要有命令同步阻塞式保存会阻塞主线程生产环境禁用命令异步非阻塞式保存会一个子进程来执行快照这是我们手动执行或配置自动执行的主要方式配置文件自动触发比如秒内有次写入秒内有次写入等模式这个概念是对的它叫混合持久化但它的工作方式可以描述得更清晰当触发重写时不再简单地写入指令而是将重写那一刻的内存数据以的格式写入到新的文件的开头然后再将重写期间产生的增量命令以格式追加到文件末尾这样做的好处是重启恢复时可以先像一样快速加载内存快照然后再重放增量命令兼顾了的恢复速度和的数据完整性底层数据结构它不是一个真正的列表而是一块连续的内存区域这块内存中将多个数据项紧凑地排列在一起从而极大地节省内存每个包含三个部分前一个节点的长度当前节点内容的编码方式和长度实际内容极致的内存效率由于是连续内存没有指针开销内存利用率极高但是有连锁更新的问题由于每个节点都记录了前一个节点的长度当我们在一个的中间插入或删除了一个元素如果这个元素的大小发生了变化比如从一个小整数变成一个长字符串就可能导致其后所有节点的字段都需要被级联修改与类似也是一块连续的内存区域用于紧凑地存储数据项的每个不再记录前一个节点的长度取而代之的是它记录了当前节点的总长度字段中包含了长度信息当需要从后向前遍历时它会先读取当前节点的前一个节点的尾部那里记录了那个节点的总长度然后再跳到那个节点的起始位置依然是连续内存内存利用率很高但解决了连锁更新的问题成为小数据量和的底层实现有序集合需要一种既能高效查找又能高效增删的数据结构平衡树如红黑树实现复杂而是一种概率性的实现相对简单且性能媲美平衡树的数据结构从最高层的链表开始向右查找直到找到一个大于等于目标值的节点的前驱然后从这个前驱节点下降一层继续向右查找重复此过程直到到达最底层的链表最终找到目标元素底层是链表可以方便地进行范围遍历增删改查效率都是消息队列消息积压处理当被问及线上消息积压如何处理时你的第一反应是清空队列然后恢复这在线上环境中是绝对禁止的操作在引导下你提到了扩容消费者方案紧急扩容消费者并监控下游依赖监控分析在扩容前必须先快速查看消费者应用的内存情况以及其下游依赖如数据库外部的负载情况确认瓶颈在于消费者本身而不是下游水平扩容如果瓶颈在消费者立即增加消费者实例数量在等云原生环境中可以通过调整的数量快速实现注意数量确保消费者实例数不超过的数量因为多余的消费者将处于空闲状态方案消息转储与异步回补编写转储程序快速开发一个简单的程序它的唯一作用就是消费积压中的消息然后原封不动地存储到另一个临时或一个临时存储如文件数据库中启动转储启动该程序快速将积压消息搬空修复与回补在修复了原始消费者的或性能问题后再编写一个回补程序以一个受控的速率从临时或存储中读取消息重新发送回原始进行处理以空间换时间快速恢复线上新消息的处理能力为修复问题和处理积压数据赢得时间方案优化消费逻辑并临时提升处理能力代码审查快速排查消费逻辑寻找性能瓶颈常见的优化点包括将单条处理改为批量处理将同步调用外部改为异步并行调用优化查询减少不必要的数据库交互紧急上线快速修复并上线优化后的代码比如说你提到扩容消费者来解决积压假设现在是双十一零点流量洪峰导致了严重积压而下游的数据库集群负载也已经很高了此时你作为负责人应该如何决策直接扩容消费者吗面试官这是一个非常经典的雪崩前兆场景决策的核心是止损和降级而不是盲目地增加压力我的决策流程会是这样的立即止损保护核心系统绝对不能直接扩容消费者因为监控显示下游数据库已经高负载扩容消费者只会变成压垮数据库的最后一根稻草导致核心系统崩溃造成更大的故障立即对消费者进行限流甚至暂停我会立即调整消费者的消费速率甚至在极端情况下通过配置中心或运维指令暂停非核心业务的消费优先保住数据库的稳定业务降级保障核心链路我会立即与产品和业务方沟通启动业务降级预案例如关闭非核心功能暂时关闭实时用户积分更新推荐商品刷新等非核心功能的消费将资源和数据库资源全部让给核心交易链路如下单支付异步转同步对于某些可以接受延迟的业务可以暂时将消息积压在中等高峰期过后系统负载降低了再慢慢处理流量削峰与后续处理利用的积压能力此时本身就扮演了一个天然的流量削峰器的角色大量的请求被积压在队列中而不是直接冲击后端系统这正是我们使用的一个重要原因高峰后恢复等到流量洪峰过去数据库负载下降后我们再逐步分批地恢复被暂停的消费者并可以适当地增加消费者实例以一个受控的速率慢慢地将积压的消息消费完毕复盘与改进事后我们会进行深入复盘分析是数据库容量预估不足还是存在性能问题或者是消费者逻辑有待优化并根据分析结果进行数据库扩容优化或引入更精细化的流量控制策略为下一次大促做好准备我的核心决策原则是牺牲非核心业务的实时性来换取核心系统的稳定性和可用性消费者组的对应你刚刚说的就是一个消费者端然后去对应一个相当于一个然后为什么要一一对应呢核心原因保证分区内的消息顺序性一个在同一个消费者组内同一时间只能被一个消费理论依据只在单个内部保证消息的有序性也就是说生产者以的顺序发送到同一个的消息消费者也必须以的顺序来消费它们机制实现为了实现这个保证必须规定一个在任意时刻只能被一个消费者实例锁定并消费如果允许多个消费者同时消费同一个那么消息的消费顺序将无法得到保证因为无法协调哪个消费者先处理哪条消息这将彻底破坏的顺序性承诺实现高并发以为并行处理的最小单元理论依据虽然单个是顺序处理的但通过将一个划分为多个来实现整体的高并发机制实现整个的吞吐量等于所有吞吐量的总和我们可以通过增加的数量来水平扩展的处理能力消费者协同消费者组内的多个消费者实例会通过再均衡机制自动协调分配它们各自负责消费的例如一个有个的如果消费者组有个消费者理想情况下就是每个消费者负责一个此时并行度达到最大消息不丢失消息幂等不丢失生产者端如何确保消息成功发出并被接收同步发送有限次重试我们会采用同步发送的方式这意味着生产者线程在发送一条消息后会阻塞等待直到收到返回的成功确认如果等待超时或收到错误响应就证明发送失败一旦发送失败我们会配置一个有限次的重试机制例如重试次每次间隔秒通过这种确认重试的闭环可以极大地提高消息发送到的成功率的同步发送方法本身就是阻塞等待确认的对于可靠性要求极高的场景我们还会配合端的同步刷盘策略确保消息在持久化到磁盘后才返回对于需要本地事务与消息发送保持原子性的场景例如下单成功后发送扣减库存消息我们会使用独有的事务消息它通过两阶段提交发送消息执行本地事务提交回滚消息的机制从根本上保证了本地操作成功消息就一定能成功发送端如何确保持久化防止自身宕机导致消息丢失持久化刷盘多副本冗余同步刷盘这是最可靠的方式接收到消息后必须将其写入磁盘文件才向生产者返回即使进程或服务器瞬间宕机消息也不会丢失异步刷盘将消息写入操作系统的后就立即返回由操作系统异步地将数据刷到磁盘性能最高但如果服务器在刷盘前掉电中的数据会丢失我们会为每个或配置多个副本通常是个分布在不同的物理机架上消息会同时写入主副本和备用副本当主副本宕机时系统可以从备用副本中选举出新的主副本继续提供服务保证了数据的高可用和冗余也支持的多副本架构以及基于协议的模式都能实现类似的高可用保障消费者端如何确保消息被消费者成功处理手动确认提交消费位点消费者从拉取一批消息先执行我们自己的业务逻辑例如更新数据库调用外部等当且仅当业务逻辑全部成功执行完毕后我们才向发送或者提交这批消息的这样如果消费者在处理业务的途中宕机由于没有提交它重启后会从上一次已提交的处重新拉取消息保证了宕机期间正在处理的消息不会丢失在中消费者的监听器会返回一个消费状态我们只有在业务处理成功后才返回才会认为消息消费成功并更新如果返回或抛出异常消息会在稍后被重试幂等对于同一个业务操作无论执行多少次其产生的结果和影响都和执行一次是相同的我们的实现方案是基于唯一状态判断为消息赋予全局唯一我们要求生产者在发送每一条具有业务含义的消息时都在消息体或中附带一个全局唯一的业务例如支付成功的消息就用支付流水号创建订单的消息就用订单号消费者端实现幂等判断消费者在处理消息时不会立即执行业务逻辑而是会先根据这个唯一去查询一个持久化的存储如或数据库来判断这个操作是否已经被执行过方案一数据库唯一索引对于插入操作我们可以直接利用数据库的唯一键约束例如在处理用户注册消息时将用户名或手机号作为唯一索引如果消息重复尝试插入时会直接触发我们捕获这个异常就知道是重复操作直接消息即可方案二对于一些通用的操作我们可以利用的命令将消息的唯一作为尝试写入如果写入成功返回说明是第一次处理就执行业务逻辑并在成功后保留这个可以设置一个过期时间如果写入失败返回说明这个已经被处理过直接跳过并方案三状态机与版本号对于更新操作我们可以在业务表中引入状态字段或版本号例如处理订单状态流转的消息消费者会先查询订单的当前状态只有当订单状态符合前置条件时例如只有待支付状态的订单才能被更新为已支付才执行更新如果状态不匹配说明已经被其他操作处理过直接忽略半事务消息第一阶段发送半消息生产者订单服务先发送一条半消息到这条消息对消费者是不可见的执行本地事务生产者发送半消息成功后立即开始执行自己的本地事务比如创建订单并写入数据库第二阶段提交回滚如果本地事务执行成功生产者就向发送一个命令收到后才将这条半消息对消费者可见如果本地事务执行失败生产者就向发送一个命令就会删除这条半消息回查机制如果生产者在执行完本地事务后宕机没能发送会定期地回调生产者的一个回查接口询问我这里有一条半消息你对应的本地事务到底成功了没有生产者根据本地事务的状态告诉应该还是分布式分布式事务设计本地消息表事务消息本地消息表这是一种实现最终一致性的常用方案核心思想是将业务操作和发送消息这两个步骤放在同一个本地事务里来保证原子性事务发起方在执行核心业务逻辑时例如创建订单会在同一个数据库事务中向一张本地的消息表插入一条消息记录这条记录的状态初始为待发送事务提交当本地事务成功提交后订单数据和待发送的消息记录会同时落库消息投递我会用一个独立的可靠的后台任务比如使用定时任务调度框架如去轮询这张消息表把所有待发送状态的消息发送到消息队列中状态确认消息成功投递到后后台任务会更新消息表中的记录状态为已发送或直接删除如果投递失败它会进行重试事务消费方下游服务消费中的消息并执行相应的业务逻辑为了防止重复消费消费方必须保证接口的幂等性消息的发送不是实时的存在一定的延迟需要额外维护一个后台任务事务消息第一阶段生产者先向发送一条半消息或预备消息这条消息对消费者是不可见的第二阶段执行本地事务发送半消息成功后生产者开始执行本地的数据库事务第三阶段如果本地事务成功生产者会向发送一个指令收到后会将之前的半消息标记为可投递消费者此时才能消费到如果本地事务失败生产者会发送一个指令会删除这条半消息超时回调检查如果生产者在执行完本地事务后宕机没有发送或指令会在超时后主动回调生产者应用提供的一个接口来查询该事务的最终状态并根据查询结果来决定是还是需要消息中间件本身支持事务消息这个特性阶段这是准备阶段对各个服务的资源进行检查和预留比如库存服务阶段就是冻结指定数量的库存而不是直接扣减阶段如果所有服务的阶段都成功协调器就会调用所有服务的方法执行真正的业务逻辑比如库存服务阶段就是将之前冻结的库存进行扣减阶段如果任何一个服务的阶段失败协调器会调用所有已经执行过成功的服务的方法释放预留的资源比如库存服务阶段就是解冻之前冻结的库存优点性能较高因为它不像那样在整个事务过程中都持有锁能够实现数据的强一致性缺点对业务代码的侵入性非常强开发成本高每个业务操作都需要实现三个接口并且要保证它们的幂等性是一种长事务解决方案核心思想是将一个大的分布式事务拆分成一系列的本地事务由事务协调器来协调如果某个步骤失败则会调用前面已执行步骤的补偿操作一个由一系列子事务组成每个子事务都有一个对应的补偿事务执行顺序是如果其中任意一个失败则会按逆序执行补偿事务优点适用于长流程业务复杂的场景一阶段提交没有锁系统吞吐量高缺点不保证事务的隔离性因为在补偿发生前其他事务可能已经看到了等操作产生的不一致的中间状态设计模式当被问及如何在多个接口中统一管理以避免代码重复时你的初步想法是提取一个公共方法面试官进一步引导你思考过滤器和拦截器方案使用的拦截器是提供的实现专门用于在方法执行前后进行预处理和后处理它与请求生命周期紧密耦合是处理用户认证日志记录上下文设置等横切关注点的标准方式创建一个类实现接口在方法中从请求如中获取解析出用户信息然后调用工具类的方法将用户信息存入在方法中无论方法执行成功还是失败都调用工具类的方法清理通常放在块中以确保执行创建一个配置类实现重写方法将你的拦截器注册到容器中并配置其拦截路径如方案使用的过滤器创建一个类实现接口在方法中在调用之前执行的操作使用结构在块中执行的操作确保无论后续处理是否异常都能清理资源使用和注解或通过将注册为与类似实现了解耦和统一管理由于作用范围更广可以拦截静态资源等非处理的请求方案使用自定义切面创建一个类并使用和注解定义一个切点例如用于匹配所有类中的方法创建一个环绕通知在通知方法的块中执行的操作然后调用执行目标方法在块中执行操作功能上与前两者类似但提供了最大的灵活性可以切入到层甚至任意的方法通知需要手动调用如果忘记调用目标方法将不会被执行策略方法怎么去解决具体调用哪一个策略为了避免在业务代码中使用大量的或来选择策略我们创建了一个策略工厂在项目启动时容器会扫描并加载所有的实现类我们创建一个类它在构造时注入一个会自动将所有策略实现类注入到这个中其中是的名称例如是实例我们约定优惠券类型例如与名称有映射关系工厂类提供一个方法当业务代码需要使用某个策略时它只需要传入优惠券类型字符串工厂就会从中返回对应的策略对象我们完全消除了业务代码中的判断当未来需要增加一种新的优惠券时我们只需要新增一个策略实现类而不需要修改任何现有的业务逻辑代码这完全符合开闭原则使得系统非常易于扩展和维护个有序文件如何拼接保证整体有序我们有个已经内部有序的数据源文件需要将它们合并成一个单一的全局有序的输出这正是归并排序中归并这一步的经典应用由于文件可能很大无法一次性全部读入内存所以这是一个外部排序问题我们可以使用最小堆来解决创建一个大小为的最小堆为个文件每个文件都打开一个文件读取流从每个文件中读取第一个数字并将这个数字连同它所属的文件源信息例如文件索引一起封装成一个对象如放入最小堆中此时堆中有个元素循环执行以下操作直到堆为空取出最小元素从最小堆的堆顶取出一个这个的就是当前全局最小的数字写入输出文件将这个写入到最终的输出文件中补充新元素根据取出的中的我们知道这个数字来自哪个文件我们立即从那个文件中读取下一个数字处理文件结束如果那个文件已经读完则什么也不做如果还能读到新数字就将这个新数字和它的再次封装成一个新的插入到最小堆中当最小堆为空时意味着所有文件都已被读取完毕输出文件也就包含了所有数字并且是全局有序的这个问题本质上是一个典型的多路归并排序问题特别是在处理无法完全加载到内存的大文件时属于外部排序的范畴设计一个高并发的系统面试官您好设计一个高并发秒杀系统核心挑战在于如何在瞬时巨大流量下保证库存扣减的绝对正确性和系统的整体高可用我的设计方案将围绕层层过滤异步处理最终一致的核心思想展开严格遵循题目要求的几个方面进行阐述整体架构首先我会将整个秒杀流程进行动静分离和垂直分层构建一个清晰的数据流前端层商品详情页静态化通过分发降低服务器压力秒杀按钮在倒计时结束前置灰并通过定时器从服务端获取最新时间防止客户端时间不准导致提前请求接入层网关负责反向代理初步限流过滤恶意请求秒杀服务独立部署这是核心业务逻辑所在与普通商品服务物理隔离避免秒杀流量冲垮主站数据处理流用户请求首先到达网管通过限流后请求进入秒杀服务秒杀服务在中完成资格校验和库存预扣减预扣减成功后立即向用户返回排队中或抢购成功的提示并将订单信息异步发送到订单服务作为消费者从拉取消息进行数据库层面的订单创建和库存真实扣减后续的支付履约流程由订单服务驱动数据模型在中会有一个秒杀库存表秒杀活动索引商品索引乐观锁版本号换成设计存储秒杀活动的总库存数量用于快速判断库存是否售罄一个售罄标记一旦库存为设置此标记后续请求可以直接在接入层拦截无需再访问存储已成功抢购的用于防止用户重复下单数据一致性在秒杀场景下我们采用缓存预扣减数据库异步更新的策略追求的是最终一致性库存预热秒杀活动开始前通过定时任务将中的库存数量加载到的中缓存预扣减用户的抢购请求直接在中通过原子操作进行库存扣减异步更新数据库扣减成功后将订单信息发送到订单服务消费消息后再对中的进行操作数据不一致的风险与兜底风险如果消息丢失或订单服务消费失败会导致库存减少而库存未变兜底我们会有一个定时对账任务定期如每分钟比对中的已售数量和中的已创建订单数量如果不一致则进行修复或告警限流和短融限流是保护系统的第一道防线必须在多层级部署前端层限流通过控制用户在点击秒杀按钮后按钮会置灰一段时间防止用户疯狂点击造成不必要的请求网关层限流基于漏桶算法对用户的或进行请求速率限制例如限制单个用户每秒只能请求次限制单个的最大连接数防止恶意攻击业务服务层限流使用或对秒杀接口本身进行限制这个值应该根据压测结果设定略高于系统的最大处理能力作为最后的保险丝熔断同样使用我们会对秒杀服务依赖的下游服务如订单服务用户服务的调用进行熔断配置策略当在指定时间窗口内对订单服务的调用错误率或平均响应时间超过阈值时熔断器会打开在接下来的一个时间窗口内所有对订单服务的调用都会被直接拒绝并快速失败返回系统繁忙避免因下游故障导致的秒杀服务线程池耗尽和雪崩热点和超卖的数据处理这是秒杀系统的核心我采用了原子操作分布式锁数据库乐观锁的三重保障来彻底杜绝超卖热点数据处理库存预热已在一致性策略中提及将的热点库存数据提前加载到中所有读写操作都在完成避免直接冲击数据库防超卖机制核心流程第一重防护原子操作在用户请求到达时首先检查中的售罄标记如果存在直接返回已售罄然后使用进行库存预扣减这是一个原子操作天然地避免了多线程下的并发问题如果后的返回值小于说明库存已不足我们将库存加回去并返回已售罄第二重防护分布式锁可选用于更复杂逻辑如果扣减库存的逻辑不仅仅是还包含了用户资格校验如检查是否重复购买那么校验扣减这两个操作就不是原子的此时我们会使用分布式锁脚本将检查用户是否在集合中和库存这两个逻辑封装在一个脚本中然后在获取到分布式锁后原子化地执行这个脚本第三重防护最终兜底数据库乐观锁订单服务在消费消息准备真实扣减库存时会使用乐观锁语句为如果这条执行后返回的影响行数为说明在并发情况下库存已被其他事务修改变为或不匹配此时我们会认为这是一个无效的订单进行记录并丢弃不会创建订单这确保了数据库层面的最终正确性异步队列补偿处理异步队列的作用流量削峰秒杀的瞬时流量是巨大的但后端数据库的处理能力是有限的像一个蓄水池将瞬时的写请求缓冲起来让下游的订单服务可以按照自己的节奏平稳地进行消费保护了数据库业务解耦秒杀服务只负责最核心的库存预扣减成功后即可返回创建订单发送通知等非核心耗时的操作被解耦到下游服务大大降低了秒杀接口的响应时间补偿机制消息可靠性我们会使用的事务消息或生产者发送确认重试机制确保库存预扣减成功的消息一定能被发送到消费失败处理如果订单服务消费消息失败例如数据库暂时不可用我们会让消息进入重试队列死信队列如果经过多次重试后仍然失败消息会被投递到死信队列我们会有一个专门的后台任务或告警系统来监控死信队列一旦有消息进入就立即通知开发人员进行人工介入和补偿压测工具使用或等分布式压测工具压测目标模拟秒杀开始瞬间在极短时间内如秒内发起远超系统处理能力的并发请求例如模拟万用户同时抢购件商品监控指标业务指标下单成功率最终创建的订单数是否与库存数严格相等验证正确性性能指标系统的接口的平均响应时间和分位线资源指标压测过程中密切监控所有组件秒杀服务数据库的内存网络磁盘等资源使用率瓶颈定位通过观察各个环节的监控指标找出最先达到瓶颈的组件然后针对性地进行优化例如升级集群优化增加秒杀服务实例等再进行下一轮压测如此循环直到系统达到预期的性能目标模板方法的回答模板方法模式定义了一个操作中的算法骨架而将一些可变的步骤延迟到子类中去实现在一个抽象的父类中会有一个的模板方法它定义了整个流程的执行顺序这个模板方法会调用一系列的抽象方法由子类实现和具体方法父类实现优点是复用了算法的公共部分并将变化的部分进行隔离比如中的方法就是一个模板方法它定义了批量添加的流程而具体的则由子类或去实现分钟自动关闭下单时用户下单成功后除了创建订单我们还会向发送一条延时等级为分钟的延时消息消息内容包含订单号消费者我们有一个专门的消费者来消费这些延时消息分钟后会将这条消息投递给消费者处理逻辑消费者收到消息后会根据订单号去查询数据库中该订单的支付状态如果订单状态仍是未支付则执行关单操作如果订单状态已经是已支付则直接忽略这条消息如何设计全局统一异常处理全局统一异常处理是项目中用于解耦业务代码和异常处理逻辑并向前端提供统一响应格式的重要机制它的实现主要依赖两个核心注解我会创建一个类并使用这个注解它是一个组合注解相当于表示这个类是一个全局的切面用于增强所有被注解的控制器并会将方法的返回值序列化为在这个类里面我会定义多个方法每个方法使用注解并指定它能处理的异常类型例如一个方法处理自定义的业务异常如一个方法处理参数校验异常如一个兜底的方法处理所有其他未被捕获的异常如在这些方法内部我会构建一个统一的响应对象例如包含状态码错误信息等然后通过包装后返回这样做的好处是业务代码中只需要专注于业务逻辑当发生错误时直接即可异常的捕获和格式化响应都由这个全局处理器统一完成代码非常清晰和易于维护网络编程如何封装是对原生的一个高度封装和增强的框架它解决了原生在使用上非常复杂功能有限且容易出错的痛点封装与事件循环原生需要我们手动编写一个死循环不断地调用然后遍历再根据的类型等进行判断代码繁琐且容易出错将其封装成了每个内部都包含一个和一个线程这个线程会自动地高效地执行事件轮询和分发我们开发者完全不需要关心底层的操作封装与原生的使用起来非常反直觉需要我们手动很容易出错提供了自己的它通过读写指针分离的设计彻底告别了操作使用起来非常方便它还提供了零拷贝池化和堆外内存等高级功能性能远超原生的接口也比原生的更统一更易用封装责任链与业务逻辑解耦原生的所有处理逻辑都混杂在一起引入了和的设计这是一个经典的责任链模式我们可以将网络处理逻辑如解码编码业务处理拆分成一个个独立的然后像搭积木一样将它们组织在中这使得代码结构清晰高度解耦易于扩展和复用多模型的线程模型正是经典多模型的实现通常是主从模式主通常只配置一个线程它的唯一职责就是监听服务端的连接请求事件当接收到一个新的客户端连接后主会将这个新建立的注册到从上然后继续回去监听新的连接它不处理任何读写从通常配置多个线程数量一般是核心数的倍或倍它的职责是处理所有已连接的读写事件一个的整个生命周期内的所有操作都会被绑定在同一个从线程上执行这避免了多线程并发处理同一个连接时需要加锁的问题计网对比一下和这三个版本的主要区别请从连接管理性能优化头部处理等角度展开并说明每一个版本的演进分别解决了上一代的什么核心痛点长链接是相对于最核心的改进之一默认是短连接每个请求响应对都需要一次连接而默认开启了长链接允许在一个连接上发送多个请求极大地减少了连接建立和关闭的开销还引入了管道机制允许客户端在收到上一个响应之前就发送下一个请求但这只是部分解决了队头阻塞问题因为服务端的响应仍然必须按顺序返回多路复用这是最核心的优势它允许在一个连接上同时并行地收发多个请求和响应并且不按顺序这彻底解决了的队头阻塞问题头部压缩使用算法来压缩请求和响应的头部对于多个请求很多头部字段是重复的可以极大地减少这部分的数据传输量服务器推送服务器可以主动地将客户端未来可能会用到的资源如文件提前推送到客户端缓存中减少了请求的往返时间二进制分帧这是的革命性变化和都是基于文本的协议而将所有传输的信息分割为更小的消息和帧并对它们采用二进制格式的编码这解决了时代基于文本的协议解析效率低的问题解决了什么连接无法复用的问题通过什么解决默认开启长链接解决了什么队头阻塞和头部冗余的问题通过什么解决二进制分帧多路复用头部压缩从用户在浏览器输入到页面渲染完成请按网络与系统角度分层讲解关键路径我将其分为请求准备阶段网络通信阶段和浏览器渲染阶段当我在栏输入地址的话首先要知道这个域名对应的地址是啥请求准备浏览器首先会解析判断协议域名端口默认为等信息接着它会查询自己的浏览器缓存看之前是否已经解析过这个域名并且缓存还未过期如果命中就直接使用缓存的地址跳过后续的查询如果浏览器缓存未命中操作系统会启动一个查询流程这是一个从近到远层层递归的查询过程核心目标是将域名转换为地址先是操作系统文件然后是本地服务器再是根域名服务器顶级域名服务器权威域名服务器依次类推拿到地址后会将其缓存起来并返回给操作系统操作系统再返回给浏览器至此解析完成网络通信这个过程涉及到和三个核心协议三次握手第一次握手客户端随机选择一个初始序列号将报文段的标志位置为然后发送给服务器此时客户端进入状态第二次握手服务器收到包后必须确认客户端的它将报文段的和标志位都置为确认号设为同时自己也选择一个初始序列号然后发送给客户端此时服务器进入状态第三次握手客户端收到服务器的包后检查确认号是否正确如果正确它会将标志位置为确认号设为然后发送给服务器这个包可以携带数据发送后客户端和服务器都进入状态连接建立成功四次挥手客户端发送支持的版本加密套件列表以及一个随机数服务器选择一个加密套件返回自己的数字证书以及一个随机数客户端验证与密钥交换客户端验证服务器证书的有效性验证通过后生成一个预主密钥用服务器证书中的公钥加密后发送给服务器服务器解密与会话密钥生成服务器用自己的私钥解密得到至此客户端和服务器双方都拥有了和它们使用相同的算法各自独立地生成一个对称的会话密钥双方互发消息用生成的会话密钥加密验证握手过程是否成功握手结束后后续所有的数据都将使用这个对称的会话密钥进行加密传输请求和相应发送请求浏览器构建一个请求报文包含请求行请求头等和请求体请求通常为空然后通过建立好的通道发送给服务器请求到达服务器后可能会先经过负载均衡器如它会将请求转发到后端的某一台应用服务器应用服务器如接收到请求后容器会解析报文将其封装成对象业务代码如的被调用它可能会查询缓存数据库执行业务逻辑最终生成数据服务器将数据渲染进模板构建一个响应报文包含状态行响应头等和响应体内容接收响应浏览器接收到服务器的响应报文浏览器渲染浏览器自上而下解析文档生成树在解析过程中如果遇到标签引用的文件会异步下载并解析生成树如果遇到标签会阻塞的解析立即下载并执行代码除非标签有或属性构建渲染树将树和树结合起来生成渲染树渲染树只包含需要被显示的节点及其样式信息例如的节点就不会在渲染树中布局浏览器根据渲染树计算出每个节点在屏幕上的精确位置和大小绘制浏览器调用根据布局信息将每个节点绘制成屏幕上的实际像素合成对于复杂的页面如使用了或浏览器会将页面分层独立绘制最后再合成到一起以提升性能所有资源加载完成或者是空闲超时了之后就会开始断开请求的四次挥手第一次挥手主动关闭方如客户端发送一个报文表示自己的数据已发送完毕进入状态第二次挥手被动关闭方服务器收到后回复一个报文此时连接处于半关闭状态服务器仍然可以向客户端发送数据第三次挥手服务器也准备好关闭连接时发送一个报文给客户端进入状态第四次挥手客户端收到服务器的后回复一个报文发送后客户端进入状态服务器收到这个后立即关闭连接状态可靠地终止连接这是最主要的原因四次挥手中的最后一个报文是由主动关闭方客户端发出的这个报文有可能会在网络中丢失如果丢失被动关闭方服务器就收不到确认它会超时重传它的报文如果此时客户端已经彻底关闭连接它将无法响应这个重传的导致服务器永远无法正常关闭而处于状态的客户端仍然能接收到这个重传的并重新发送一次从而确保服务器能够正常关闭防止已失效的报文段被新连接误接收考虑一个场景一个连接由源源端口目的目的端口这个四元组唯一标识关闭后马上又用完全相同的四元组建立了一个新的连接此时网络中可能还存在上一个旧连接中延迟到达的报文段如果没有状态这些迷路的旧报文段就可能会被这个新连接误认为是合法数据并接收造成数据错乱为什么等待时间是是指一个报文段在网络中可能存活的最长时间任何报文在超过后都会被网络丢弃的时间足以保证在一个连接的一去一回两个方向上所有的报文段都能在网络中自然消失当状态结束后可以保证网络中不再有任何与旧连接相关的幽灵报文段此时再建立新的连接就是完全安全的在三次握手过程中如果第三次握手的报文丢失了会发生什么三次握手分别是服务端状态当服务端发送完之后它会进入状态并启动一个定时器等待客户端的第三次客户端状态当客户端发送完第三次之后它单方面认为连接已经建立状态会变为因为是服务端在状态下等待第三次超时了当定时器超时后服务端会重新发送包给客户端重传的次数由系统参数如控制在状态下连接并未完全建立对于服务端应用层来说它通过拿到的连接还处于一个半连接队列中应用层是无法使用这个连接的所以服务端应用层无感知因为客户端在发送完第三次后其内核协议栈就认为连接已建立状态所以对于客户端应用层来说系统调用会立即返回成功此时客户端应用层会认为连接已经建立成功并开始发送数据处理客户端应用层发送的数据会和因为第三次丢失而重传的在网络中交汇当客户端收到服务端重传的后它的内核会意识到自己之前发送的可能丢失了于是会再次发送一个给服务端当服务端收到了这个新的后无论是客户端重发的还是伴随着数据包一起过来的服务端状态才会变为连接才真正建立之前客户端发送的数据才会被服务端应用层接收状态机转变异常解决就比如说你这个部署到线上了然后他抛了一个异常然后那你这个应该怎么排查呢线上出现异常我会遵循一套从宏观到微观由表及里的排查标准作业程序来定位和解决问题第一步信息收集与初步判断确认影响范围首先快速判断这个异常的影响面有多大是影响了所有用户还是部分用户是核心功能还是边缘功能这决定了问题的紧急程度查看监控告警立即查看监控系统如的告警信息检查应用的关键指标如应用层面响应时间错误率是否突增层面使用率内存占用活动是否异常主机层面服务器的内存磁盘网络流量是否正常依赖服务数据库等中间件的健康状况如何这一步的目标是快速定位问题是出在应用本身还是外部依赖第二步日志分析与精准定位聚合日志平台检索登录或类似日志平台根据告警信息中的时间点错误信息关键字如进行检索利用进行链路追踪如果系统接入了分布式追踪系统如这是最强大的工具我会根据报错信息找到一个然后用这个查询完整的请求调用链这可以清晰地看到请求经过了哪些服务在哪一个环节耗时最长又是在哪个服务的具体代码行抛出了异常服务器手动排查作为补充如果日志平台不完善我会登录到具体的服务器上进行排查使用命令根据关键字快速过滤日志可以显示异常上下文的行帮助理解问题背景如果需要根据查我会用对于实时滚动的日志我会用来实时监控错误输出第三步根因分析与问题复现代码分析定位到具体的异常代码后分析代码逻辑判断是业务逻辑错误空指针并发问题还是资源未释放等环境复现如果可能尝试在测试环境或预发环境构造相同的参数和条件复现这个问题以便于调试和验证修复方案第四步问题解决与复盘紧急修复如果是严重立即进行修复并上线如果是资源问题进行扩容或配置调整复盘总结问题解决后必须进行复盘分析问题发生的根本原因是代码缺陷设计不合理还是容量预估不足并制定改进措施例如增加单元测试完善监控告警优化架构等防止同类问题再次发生考察线上问题排查第一步紧急止血恢复服务优先第二步定位根因第三步复盘总结避免再犯看监控定范围看应用自身监控接口的响应时间次数时间线程数线程池监控队列长度活跃线程数首先确认是自身应用的问题还是外部问题看主机监控使用率内存占用网络磁盘确认是不是机器资源被打满了分析线程找瓶颈使用命令线程堆栈分析是否有大量线程处于状态锁竞争状态等待外部资源如调用数据库连接这是定位问题的最核心手段查判影响使用查看情况确认是否发生了频繁的导致从而影响接口响应查依赖判外部检查所有下游服务调用的响应时间是不是某个下游服务变慢拖垮了你检查数据库和缓存的慢查询日志和响应时间是不是因为慢或大导致的阻塞看网络做补充如果以上都正常再考虑网络问题比如丢包重传等恢复手段重启大法最简单粗暴但有效服务降级通过配置中心暂时关闭一些非核心功能服务限流立即调低接口的阈值避免被流量打垮扩容如果是资源不足立即进行水平扩容线上问题卡顿提出了一个自顶向下的排查思路先通过监控工具宝塔看服务器资源内存定位到具体程序再通过程序的日志日志定位到具体组件和代码异常命令行工具如的提及对于一个硬核的技术面试面试官更希望听到你如何使用这些底层工具进行排查此外排查的维度不够全面没有考虑到网络问题数据库慢查询下游服务拖累等常见原因设计一个可扩展的架构并说明如何实现秒的延迟指标召回重排向量库更新上下文窗口管理长对话状态持久化以及延迟预算分配几个维度的核心流程文档切分向量化入库用户问题向量化相似度检索结果送入生成答案是为了解决没有记忆和无法利用私有知识的问题召回你只提到了向量相似度检索但一个生产级的系统召回层通常是混合检索比如向量检索关键词检索如以应对不同类型的问题重排你提到了重排模型但没有说明它的作用模型如通常是一个轻量级的交叉编码器模型它会对召回的比如个文档进行更精细化的相关性打分再选出最终的比如送给能显著提升最终答案的质量向量库更新这是一个工程难题你完全没有提及如何处理知识的增量更新修改和删除是定期全量重建索引还是采用支持实时更新的向量数据库时间分配用户问题预处理向量化向量检索重排生成这是大头网络开销等然后你需要思考如何优化每个环节比如模型和模型需要选择轻量级高性能的版本向量检索需要对索引进行优化如索引的参数调优需要采用流式输出让用户能更快地看到第一个',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-05 21:56:44',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 1.05rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 1.05rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 1.05rem;">FI<sup>1</sup></a><a href="/tags/Github/" style="font-size: 1.05rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/dubbo/" style="font-size: 1.05rem;">dubbo<sup>1</sup></a><a href="/tags/football/" style="font-size: 1.05rem;">football<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>59</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>2</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>17</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>7</sup></a><a href="/tags/paper/" style="font-size: 1.05rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 1.05rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>4</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>4</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 1.05rem;">毛选<sup>1</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>29</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url">面经</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">面试面经优化回答</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-09-05T13:56:44.065Z" title="更新于 2025-09-05 21:56:44">2025-09-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">35.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="面试面经优化回答"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=f367dec8-8911-a97c-1f8e-768aa23b2df8"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url">面经</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">面试面经优化回答</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-08-13T16:00:00.000Z" title="发表于 2025-08-14 00:00:00">2025-08-14</time><time itemprop="dateCreated datePublished" datetime="2025-09-05T13:56:44.065Z" title="更新于 2025-09-05 21:56:44">2025-09-05</time></header><h1>Spring框架</h1>
<h2 id="1-SpringBoot的配置加载优先级">1.SpringBoot的配置加载优先级</h2>
<p>首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：</p>
<ol>
<li>
<p>先是<strong>命令行参数</strong>（<code>--server.port=9000</code> 或 <code>java -jar app.jar --spring.config.location=...</code>）</p>
</li>
<li>
<p>然后是我们的系统的环境变量和JVM系统属性，比如设置端口为8080，比如我们在这里设置API的KEY</p>
</li>
<li>
<p>然后**<code>RandomValuePropertySource</code>**（<code>random.*</code> 占位符，用于生成随机数/字符串，可在配置中引用）</p>
</li>
<li>
<p>接着是<strong>外部配置文件</strong>（properties / yml）</p>
<ul>
<li>
<p>JAR 包外部的 <code>./config/</code></p>
</li>
<li>
<p>JAR 包外部的 <code>./</code></p>
</li>
<li>
<p>JAR 包内部的 <code>classpath:/config/</code></p>
</li>
<li>
<p>JAR 包内部的 <code>classpath:/</code></p>
</li>
</ul>
</li>
<li>
<p>接着是我们@PropertySource注解指定的配置</p>
</li>
<li>
<p>最后是我们Springboot默认的配置</p>
</li>
</ol>
<p>然后在配置文件中，properties的配置大于yml，因为springboot是按加载顺序来的，后加载的properties把yml的值给覆盖了</p>
<p>对于外部配置文件，查找路径的优先级为：</p>
<ol>
<li><code>./config/</code>（当前目录下的config目录）</li>
<li><code>./</code>（当前目录）</li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ol>
<p>实际应用:</p>
<p><strong>基础配置</strong>：放在 <code>classpath:/application.yml</code></p>
<p><strong>环境特定配置</strong>：使用 <code>application-&#123;profile&#125;.yml</code>（如 <code>application-prod.yml</code>），通过 <code>--spring.profiles.active=prod</code> 激活</p>
<p><strong>敏感信息</strong>：放在环境变量或外部化配置文件（避免入库）</p>
<p><strong>临时调试/测试</strong>：使用命令行参数临时覆盖</p>
<p><strong>多环境冲突处理</strong>：利用 profile 合并特性，公共配置放在 <code>application.yml</code>，环境差异放在对应 profile 文件</p>
<h2 id="2-Springboot是如何解决跨域问题的？">2.Springboot是如何解决跨域问题的？</h2>
<p>基本都是基于CORS（跨域资源共享）通过设置响应头（如 <code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>）告诉浏览器允许访问。</p>
<p>对于复杂跨域请求（非 GET/POST/HEAD 或自定义头），浏览器会先发 <strong>OPTIONS 预检请求</strong>。</p>
<ol>
<li>局部注解，用@CrossOrigin标记单个接口，秒开跨域权限，适合快速测试。简单高效，优先级高于全局配置</li>
<li>全局配置，使用WebMvcConfigurer接口，统一设定允许的域名，请求方法，头信息。统一配置，但是不适合动态的控制</li>
<li>用CorsFilter手动处理跨域逻辑处理，适合需要动态校验权限等特殊场景，比如不同权限开放不同接口，在过滤器中动态判断，但是实现成本较高</li>
<li>在微服务架构中，也可以在<strong>网关层</strong>（如 Spring Cloud Gateway、Nginx）统一处理跨域，减少业务服务配置。</li>
</ol>
<p>优先级：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin` &gt; `WebMvcConfigurer` &gt; `CorsFilter</span><br></pre></td></tr></table></figure>
<h2 id="3-Spring-解决循环依赖">3.<strong>Spring 解决循环依赖</strong></h2>
<p><strong>既然Spring能解决循环依赖，那为什么我们还经常听说‘构造器注入无法解决循环依赖’？三级缓存对构造器注入为什么无效？</strong></p>
<p>您问到了Spring循环依赖解决方案的一个核心<strong>前提</strong>。三级缓存之所以能工作，其根本在于它将<strong>Bean的实例化（Instantiation）**和**属性填充（Population）**这两个阶段**分离开来</strong>了。</p>
<ul>
<li><strong>第一步：实例化</strong>。Spring首先通过<strong>无参构造函数</strong>创建了Bean A的一个“空壳”实例。这个实例已经有了自己的内存地址。</li>
<li><strong>第二步：暴露早期引用</strong>。紧接着，Spring立即将这个“空壳”实例的工厂（ObjectFactory）放入三级缓存，从而<strong>提前暴露</strong>了A的引用。</li>
<li><strong>第三步：属性填充</strong>。然后Spring才开始尝试为A注入属性，此时发现需要B，就去创建B。当B需要A时，可以从三级缓存中获取到A的早期引用，从而打破循环。</li>
</ul>
<p><strong>构造器注入的工作流程</strong>:</p>
<ul>
<li>对于构造器注入，<strong>Bean的实例化和属性填充这两个阶段是合并在一起的，是原子性的</strong>。</li>
<li>当Spring尝试创建Bean A时，它必须调用A的构造函数。而A的构造函数需要一个Bean B的实例作为参数。</li>
<li>为了满足这个参数，Spring必须先去创建Bean B。</li>
<li>而当Spring尝试创建Bean B时，又发现B的构造函数需要一个Bean A的实例作为参数。</li>
<li>此时，<strong>Bean A的实例根本还没有被创建出来</strong>（它还卡在等待B的阶段），内存中不存在任何A的“空壳”实例，三级缓存中自然也就不可能有任何关于A的引用。</li>
<li>这就形成了一个无法解开的死结：A的创建依赖B的创建，B的创建又依赖A的创建。因此，Spring会直接抛出<code>BeanCurrentlyInCreationException</code>。</li>
</ul>
<h2 id="4-Bean的生命周期">4.Bean的生命周期</h2>
<p>依赖注入，三级缓存</p>
<p>流程：</p>
<ul>
<li><strong>实例化 (Instantiation):</strong> Spring 通过反射创建 Bean 的实例。</li>
<li><strong>填充属性 (Populate Properties):</strong> Spring 注入 Bean 的依赖（DI）。</li>
<li>初始化 (Initialization):
<ul>
<li>调用各种 Aware 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>）。</li>
<li>调用 <strong><code>BeanPostProcessor</code> 的前置处理</strong>方法 (<code>postProcessBeforeInitialization</code>)。</li>
<li>调用 <code>@PostConstruct</code> 注解的方法或 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法。</li>
<li>调用自定义的 <code>init-method</code>。</li>
<li>调用 <strong><code>BeanPostProcessor</code> 的后置处理</strong>方法 (<code>postProcessAfterInitialization</code>)。<strong>&lt;- AOP 代理发生在这里</strong></li>
</ul>
</li>
<li><strong>使用 (In Use):</strong> Bean 处于可用状态。</li>
<li>销毁 (Destruction):
<ul>
<li>调用 <code>@PreDestroy</code> 注解的方法或 <code>DisposableBean</code> 的 <code>destroy</code> 方法。</li>
<li>调用自定义的 <code>destroy-method</code>。</li>
</ul>
</li>
</ul>
<h2 id="5-Bean-和-Component-的区别？">5.<code>@Bean</code> 和 <code>@Component</code> 的区别？</h2>
<p>面试官您好，<code>@Component</code> 和 <code>@Bean</code> 都是向Spring IoC容器注册Bean的方式，但它们在使用场景和控制粒度上有本质区别：</p>
<ol>
<li>
<p>注解目标不同:</p>
<ul>
<li><code>@Component</code> 是一个<strong>类级别</strong>的注解，Spring通过包扫描发现并自动注册为Bean。它还有三个衍生的注解 <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>，用于更清晰地划分业务分层。</li>
<li><code>@Bean</code> 是一个<strong>方法级别</strong>的注解，通常用在 <code>@Configuration</code> 注解的配置类中。这个方法需要返回一个对象，Spring会将这个返回的对象注册为Bean。</li>
</ul>
</li>
<li>
<p>使用场景不同:</p>
<ul>
<li><code>@Component</code> 用于<strong>我们自己编写的类</strong>，希望Spring自动管理它们时使用。</li>
<li><code>@Bean</code> 主要用于<strong>第三方库的组件</strong>。因为我们无法修改第三方库的源码去添加<code>@Component</code>注解，所以通过<code>@Bean</code>方法可以显式地将其实例化并交给Spring管理。此外，当一个Bean的创建过程比较复杂，需要一些前置逻辑判断时，也适合用<code>@Bean</code>。</li>
</ul>
<p><strong>总结来说</strong>，<code>@Component</code> 是让Spring<strong>自动发现</strong>，控制权在Spring；而<code>@Bean</code> 是我们<strong>主动声明</strong>，控制权在我们开发者手中，更加灵活。</p>
</li>
</ol>
<p><strong>引出 <code>@Configuration</code></strong>: <code>@Bean</code> 必须在被 <code>@Configuration</code> 或 <code>@Component</code> 注解的类中使用。可以进一步说明 <code>@Configuration</code> 的 <code>proxyBeanMethods</code> 属性，来体现你对Spring底层代理的理解。</p>
<p>关于<code>@Configuration</code>的<code>proxyBeanMethods</code>属性，这其实是深入理解Spring IoC容器核心原理的一个关键点。它控制着Spring是否要为我们的配置类创建一个CGLIB代理，从而影响Bean之间的依赖注入行为</p>
<p>我们可以分两种情况来看，也就是<code>proxyBeanMethods</code>为<code>true</code>（默认值）和<code>false</code>时，Spring的行为有何不同。</p>
<p><strong><code>proxyBeanMethods = true</code> (Full模式)</strong></p>
<p>这是<code>@Configuration</code>的默认行为。在这种模式下，Spring在启动时会使用CGLIB动态代理技术，为我们的配置类（比如<code>AppConfig</code>）创建一个代理子类，并把这个代理子类放入IoC容器中。<strong>这个代理的核心作用是拦截所有对<code>@Bean</code>方法的调用</strong>。</p>
<p>当Spring容器初始化<code>beanA</code>时，它会调用<code>beanA()</code>方法。当代码执行到<code>beanB()</code>时，<strong>因为<code>AppConfig</code>是一个代理对象，这个调用会被代理拦截</strong>。代理会检查容器里是否已经存在一个名为<code>beanB</code>的单例Bean。</p>
<ul>
<li><strong>如果存在</strong>，代理会直接返回容器中那个已经存在的<code>beanB</code>实例。</li>
<li><strong>如果不存在</strong>，它才会执行真正的<code>beanB()</code>方法体，创建一个新的<code>BeanB</code>实例，将它注册到容器中，然后再返回。</li>
</ul>
<p>在Full模式下，无论你在配置类内部调用<code>@Bean</code>方法多少次，Spring总能保证你拿到的是容器中那个唯一的、正确的单例Bean实例。这保证了Bean依赖关系的正确性，<strong>我们称之为‘容器内的单例保证’</strong>。</p>
<p><strong><code>proxyBeanMethods = false</code> (Lite模式)</strong></p>
<p>当我们将它设置为<code>false</code>时，情况就完全不同了。Spring<strong>不会为配置类创建CGLIB代理</strong>，容器中的<code>AppConfig</code>就是一个普通的Java对象。</p>
<p>在这种模式下，当Spring初始化<code>beanA</code>时，调用<code>beanA()</code>方法。当代码执行到<code>beanB()</code>时，由于没有代理拦截，<strong>这就变成了一次普通的Java方法调用</strong>。它会直接执行<code>new BeanB()</code>，创建一个全新的<code>BeanB</code>对象。”</p>
<p>这意味着，<code>beanA</code>所依赖的那个<code>BeanB</code>实例，和Spring容器中独立注册的那个名为<code>beanB</code>的Bean实例，<strong>是两个完全不同的对象</strong>！这就破坏了Bean的单例作用域。</p>
<ul>
<li>当你的配置类中，<strong>Bean之间存在相互依赖关系时</strong>，比如<code>beanA</code>的创建依赖于调用<code>beanB()</code>方法。你必须使用默认的<code>true</code>来保证依赖注入的是容器中的单例Bean。</li>
<li>当你的配置类中，所有的<code>@Bean</code>方法都是独立的，<strong>彼此之间没有任何调用关系</strong>。在这种情况下，设置为<code>false</code>可以跳过CGLIB代理的创建过程，<strong>能够提升Spring的启动性能，减少内存占用</strong>。事实上，Spring Boot的很多自动配置类（Auto-Configuration）在可能的情况下都会选择使用Lite模式来优化性能。</li>
</ul>
<h1>JUC</h1>
<h2 id="1-线程池常见的坑">1.线程池常见的坑</h2>
<ol>
<li>
<p>线程池的参数配置：核心线程的数量，和最大线程的数量是业务场景来的，CPU密集型，比如数据的计算业务，就是CPU的数量+1。</p>
<p>IO密集型根据业务压测的值来决定的，最佳线程数=（（线程等待时间+线程CPU时间）/线程CPU时间）*CPU数量</p>
</li>
</ol>
<p>比如，我们服务器CPU核数为8核，任务线程CPU耗时20ms,线程等待等等耗时80ms，那么最佳线程数=（80+20）/20*8=40线程，那我们最大线程数就是80个</p>
<ol start="2">
<li>共享线程池，次要的逻辑拖垮主要的逻辑。避免所有的业务都共享一个线程池，防止一个次要的业务一直在执行业务，占用线程池。而主要的业务并没有足够的线程数来执行，影响到了我们主要的服务。这样做是不合理的。我们应该要做线程池的隔离，使用Future.get方法的时候，使用带超时时间的，因为他是阻塞的，防止被其他抢占。</li>
<li>@Async是Spring中一个注解，他不是线程池，他其实是SimpleAsyncTaskExecutor，不会复用线程，适合执行大量短时间的线程。还是尽量自己定义一个异步的线程池，然后使用@EnableAsync来注册</li>
<li>使用线程池的时候，不使用threadfactory参数来自定义命名，这样导致后期不好排查问题和回溯问题</li>
<li>使用submit提交任务，不会把异常直接抛出来。最好我们在submit之中进行try-catch进行捕获，或者是在 <code>Future.get()</code> 时捕获并记录异常。</li>
<li>线程池使用完之后，记得关闭，防止内存泄漏的问题。最好线程池设计成单例的模式。长期运行的全局线程池（如 Spring 管理的）不需手动关闭，临时线程池需在 finally 中调用 <code>shutdown()</code>。</li>
<li>线程池不要和事务一起使用，使用@Transtation的时候，依赖于当前线程的线程上下文，而线程池的线程和当前事务的线程不是一个线程，事务的上下文不会传递，导致线程池中的业务代码不在事务中执行，事务就失效了。我们可以将事务放在线程池之外进行，这是最好的方法，或者是使用支持事务上下文传递的机制（如 <code>TransactionAwareDataSourceProxy</code>、消息队列保证一致性）</li>
<li>我们要负责监控线程池状态，比如当前活跃的线程池的数量，队列的长度，拒绝的次数</li>
<li>要配置合理的拒绝策略，比如一个需要快速获取结果的线程，就需要胚子和callerrunpolicy，这样的话，谁提交谁执行，回退给调用的线程。</li>
<li>执行过程：</li>
</ol>
<ul>
<li>Step 1: 判断核心线程数是否已满？
<ul>
<li>当前运行的线程数 &lt; <code>corePoolSize</code>？</li>
<li><strong>是：</strong> 则<strong>直接创建一个新的核心线程</strong>来执行任务，即使其他核心线程现在是空闲的。</li>
<li><strong>否：</strong> 进入 Step 2。</li>
</ul>
</li>
<li>Step 2: 判断任务队列是否已满？
<ul>
<li><code>workQueue.offer(task)</code> 是否成功？</li>
<li><strong>是：</strong> 任务入队成功，等待空闲线程来处理。</li>
<li><strong>否：</strong> 进入 Step 3。</li>
</ul>
</li>
<li>Step 3: 判断最大线程数是否已满？
<ul>
<li>当前运行的线程数 &lt; <code>maximumPoolSize</code>？</li>
<li><strong>是：</strong> 则<strong>创建一个新的非核心线程</strong>来执行任务。</li>
<li><strong>否：</strong> 进入 Step 4。</li>
</ul>
</li>
<li>Step 4: 执行拒绝策略。
<ul>
<li>调用 <code>rejectedExecutionHandler.rejectedExecution(task, this)</code>。</li>
</ul>
</li>
</ul>
<h2 id="2-AQS的大局解析">2.AQS的大局解析</h2>
<p>AQS是JUC里面的一个抽象同步框架，核心的作用就是统一分装了线程的等待唤醒排队机制。</p>
<p>底层通过一个volatile的state变量+FIFO的队列来实现线程安全的资源性抢夺</p>
<p>state表示资源的状态，独占锁里面0没人占，1就是已经上锁。可重入锁里面数字代表可重入的次数</p>
<p>线程要抢不到锁，就会被挂到队列里面进行排队，队列是双向链表实现的CLH队列，节点记录了等待状态，信息等</p>
<p>他只是一个框架，真正的锁逻辑交给实现类自己决定</p>
<p>AQS获取锁和解锁的过程：</p>
<ul>
<li>获取锁 (acquire)：
<ol>
<li>尝试用 <strong>CAS</strong> 修改 <code>state</code> 从 0 到 1。</li>
<li>如果成功，则获取锁成功，将锁持有者设为当前线程。</li>
<li>如果失败，说明锁被占用。则将当前线程包装成一个 Node 节点，<strong>加入到 CLH 队列的尾部</strong>。</li>
<li>加入队列后，线程会<strong>自旋</strong>一小会儿，再次尝试获取锁。如果还是失败，则调用 <code>LockSupport.park()</code> <strong>挂起</strong>当前线程，等待被唤醒。</li>
</ol>
</li>
<li>释放锁 (release)：
<ol>
<li>修改 <code>state</code> 的值（比如减1）。</li>
<li>如果 <code>state</code> 变为 0，说明锁已完全释放。</li>
<li>则找到 CLH 队列头节点的<strong>下一个节点</strong>，调用 <code>LockSupport.unpark()</code> <strong>唤醒</strong>它，让它去竞争锁。</li>
</ol>
</li>
</ul>
<h2 id="3-wait和sleep的区别">3.wait和sleep的区别</h2>
<p>wait()和sleep()的主要区别在于：1. 所属类不同，wait()是Object类的方法，sleep()是Thread类的静态方法；2. wait()会释放对象锁，而sleep()保持锁不释放；3. wait()必须在同步代码块中调用，sleep()没有此限制；4. wait()需要notify()或notifyAll()来唤醒，而sleep()在超时或被中断时自动恢复；5. 使用场景上，wait()用于线程间的协作，sleep()用于简单的延时操作。</p>
<p>wait()方法使当前线程进入等待状态，将其从运行状态转变为等待状态，并将其加入到等待池中。</p>
<h2 id="4-异步编排">4.<strong>异步编排</strong></h2>
<p>在我看来，<strong>异步编排的核心思想是，将多个独立的、耗时的异步任务（尤其是I/O密集型任务）组合、编排起来，让它们尽可能地并行执行，最终汇总结果，从而极大地缩短整体的响应时间。</strong> 这在微服务架构中尤其重要。</p>
<p>在现代Java开发中，实现异步编排最核心的工具就是 <strong><code>CompletableFuture</code></strong></p>
<p>举一个我们项目中非常典型的例子：<strong>获取‘商品详情页’数据</strong>。一个商品详情页通常需要展示多种信息，而这些信息可能来自不同的微服务或数据库表：</p>
<ul>
<li><strong>任务A</strong>：调用商品服务，获取商品基本信息。</li>
<li><strong>任务B</strong>：调用用户服务，获取当前用户的优惠券信息。</li>
<li><strong>任务C</strong>：调用评论服务，获取商品的热门评论。</li>
<li><strong>任务D</strong>：调用推荐服务，获取相关商品推荐。</li>
</ul>
<p>如果采用传统的同步调用方式，总耗时将是 <code>A + B + C + D</code> 的累加。但实际上，这四个任务<strong>没有任何依赖关系，完全可以并行执行</strong>。通过异步编排，理想情况下的总耗时将仅仅取决于<strong>耗时最长的那一个任务</strong>，即 <code>Max(A, B, C, D)</code>，性能会得到指数级的提升。</p>
<p>实现：</p>
<ol>
<li><strong>任务并行化</strong>：为每一个独立的调用任务创建一个<code>CompletableFuture</code>实例。关键是使用<code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code>方法，并为其<strong>提供一个自定义的线程池</strong>。这可以避免耗尽Web服务器（如Tomcat）的业务线程池。</li>
<li><strong>结果编排与组合</strong>：当所有并行的任务都完成后，我需要将它们的结果组合成一个最终的<code>ProductDetailPageDTO</code>。我会使用<code>CompletableFuture.allOf()</code>来等待所有任务完成。</li>
<li><strong>最终结果处理</strong>：在<code>allOf()</code>完成后，通过<code>thenApply()</code>或<code>thenAccept()</code>来执行最终的组装逻辑。</li>
<li><strong>异常处理与超时控制</strong>：在生产环境中，还需要考虑健壮性。我会使用<code>exceptionally()</code>来处理任何一个异步任务的失败，返回一个默认值或降级数据。同时，使用<code>orTimeout()</code>为整个编排流程设置一个最大等待时间，防止因为某个下游服务缓慢而导致整个请求长时间阻塞。</li>
</ol>
<h2 id="5-synchronized-锁升级的“细节追问">5.<strong><code>synchronized</code> 锁升级的“细节追问</strong></h2>
<p>1.<strong>线程是如何从‘偏向锁’升级到‘轻量级锁’的？JVM是如何判断‘偏向’失效的</strong></p>
<p>“偏向锁的核心思想是，它‘偏向’于第一个获取它的线程，认为在接下来的执行中，锁将一直被这个线程持有。</p>
<ol>
<li><strong>偏向状态</strong>：当一个线程第一次获取锁时，JVM会通过<strong>CAS操作</strong>，尝试将锁对象头（Mark Word）中的<strong>线程ID</strong>指向当前线程。如果成功，就获取了偏向锁。</li>
<li><strong>升级触发点</strong>：当<strong>另一个线程</strong>（线程B）尝试获取这个已经被线程A持有的偏向锁时，升级过程就被触发了。</li>
<li><strong>偏向锁的撤销</strong>：
<ul>
<li>首先，线程B的CAS操作会失败。JVM会检查Mark Word中记录的线程ID是否是线程A。</li>
<li>JVM会暂停线程A（在一个<strong>全局安全点</strong>），然后检查线程A是否还存活。</li>
<li>如果线程A<strong>已经执行完毕</strong>，那么锁对象恢复到无锁状态，线程B可以重新尝试获取。</li>
<li>如果线程A<strong>仍然存活且还在同步块内</strong>，说明发生了真正的竞争。此时，偏向锁就会被<strong>撤销（Revoke）</strong>。锁对象头的Mark Word会被修改，清除偏向锁标志，并升级为<strong>轻量级锁</strong>的状态。同时，线程A的栈帧中会创建锁记录（Lock Record），指向锁对象。</li>
<li>之后，线程A和线程B都会在轻量级锁的状态下进行竞争（通过自旋）。</li>
</ul>
</li>
<li>只不过目前在<strong>JDK 15</strong> 中被 <strong>默认禁用</strong>，并在 <strong>JDK 18</strong> 被 <strong>完全移除</strong>。因为偏向锁的撤销消耗的性能是比较大的</li>
</ol>
<p>2.<strong>那轻量级锁又是如何升级到重量级锁的？‘自旋’失败后发生了什么？</strong></p>
<p>轻量级锁的核心思想是，它认为锁的竞争时间会非常短，线程只需要‘稍等一下’（自旋），就可以拿到锁，从而避免了线程阻塞和唤醒带来的内核态切换开销。</p>
<ol>
<li><strong>轻量级锁的获取</strong>：线程在自己的栈帧中创建锁记录（Lock Record），然后通过<strong>CAS操作</strong>尝试将锁对象的Mark Word指向这个锁记录。如果成功，就获取了轻量级锁。</li>
<li><strong>自旋等待</strong>：如果CAS失败，说明锁已被其他线程持有。当前线程并不会立即阻塞，而是会进行<strong>自旋</strong>，即执行一个空循环，不断地重试CAS操作。</li>
<li><strong>升级触发点</strong>：升级到重量级锁主要有两种情况：
<ul>
<li><strong>自旋失败</strong>：自旋的次数是有限的（JVM会动态调整，比如10次）。如果一个线程自旋了指定次数后，仍然没有获取到锁，JVM就认为竞争已经非常激烈了，不适合再空耗CPU。</li>
<li><strong>竞争者过多</strong>：如果在自旋过程中，又有<strong>第三个线程</strong>也来竞争这把锁，那么也会立即触发升级。</li>
</ul>
</li>
<li><strong>锁膨胀（Inflation）</strong>：
<ul>
<li>一旦触发升级，锁就会<strong>膨胀</strong>为重量级锁。</li>
<li>锁对象的Mark Word会被修改，指向一个重量级锁的监视器对象（Monitor）。</li>
<li>所有等待锁的线程（包括正在自旋的线程和后来者）都<strong>不再自旋</strong>，而是会被<strong>阻塞</strong>，并放入Monitor的等待队列中。</li>
<li>当持有锁的线程释放锁时，会唤醒等待队列中的一个线程，进行新一轮的锁竞争。这个过程就涉及到了操作系统的互斥量（Mutex）和线程的上下文切换。</li>
</ul>
</li>
</ol>
<p>锁的升级是<strong>单向的</strong>，只能从低级别到高级别，不能降级（在HotSpot JVM的实现中）。</p>
<h2 id="6-ThreadLocal">6.ThreadLocal</h2>
<p><strong>既然<code>key</code>用弱引用会导致内存泄漏，那为什么<code>ThreadLocalMap</code>的设计者不把<code>key</code>也设计成强引用呢？或者，为什么不把<code>value</code>也设计成弱引用</strong></p>
<p>1.<strong>为什么Key不能是强引用？</strong></p>
<ul>
<li>假设Key是强引用。那么<code>Thread</code>对象会通过<code>threadLocals</code>这个Map强引用着<code>ThreadLocal</code>对象（Key）。只要线程本身不消亡，这个强引用链（<code>Thread</code> -&gt; <code>ThreadLocalMap</code> -&gt; <code>Entry</code> -&gt; <code>ThreadLocal</code>对象）就一直存在。</li>
<li>这意味着，即使我们在业务代码中已经不再使用某个<code>ThreadLocal</code>对象了（比如，<code>myThreadLocal = null;</code>），只要这个线程还在线程池中被复用，这个<code>ThreadLocal</code>对象本身就<strong>永远无法被GC回收</strong>。这会导致<code>ThreadLocal</code>对象本身的泄漏，比现在的情况更糟糕。”</li>
</ul>
<p>2.<strong>为什么Value不能是弱引用？</strong></p>
<ul>
<li><code>ThreadLocal</code>的核心目的就是让我们存放一些与线程绑定的<strong>数据（Value）</strong>。这些数据通常是我们业务逻辑中需要用到的对象，比如用户信息对象、数据库连接等。</li>
<li>如果我们把Value也设计成弱引用，那么当一次GC发生时，<strong>只要这个Value对象在其他地方没有被强引用，它就可能被意外地回收掉</strong>。</li>
<li>这会导致我们调用<code>threadLocal.get()</code>时，突然得到一个<code>null</code>值，这完全违背了<code>ThreadLocal</code>的设计初衷，会引发严重的业务逻辑错误。我们存放进去的对象，必须保证在<code>remove()</code>之前是可靠存在的。所以，<strong>Value必须是强引用</strong>。”</li>
</ul>
<p>因此只能做出了个权衡：</p>
<ul>
<li><strong>Key使用弱引用</strong>：是为了当<code>ThreadLocal</code>对象本身在外部不再被使用时，GC能够回收它，从而让Map中的Entry的key变为<code>null</code>，为后续的清理（expungeStaleEntry）提供了可能性。</li>
<li><strong>Value使用强引用</strong>：是为了保证我们存放的数据的生命周期是可控的，不会被GC意外回收。</li>
</ul>
<h2 id="7-谈谈怎么理解线程安全的">7.谈谈怎么理解线程安全的</h2>
<p><strong>线程安全</strong>指的是当多个线程同时访问一个对象或方法时，无论操作系统如何调度这些线程，也无需调用方在代码中去做额外的同步处理，都能保证程序的正确性，不会出现数据损坏或不一致的情况。</p>
<p>线程不安全的问题通常会表现在三个方面</p>
<ol>
<li>原子性：一个或多个操作作为一个不可分割的整体来进行，要去这个操作序列，必须由一个线程独占完整的去执行，不能被其他线程所干扰，调不可被中断。i++</li>
<li>可见性：一个线程修改了一个共享变量的值，这个修改的值能够被其他线程看到。但是实际在CPU的高速缓存下，对指令做出的重排序操作，导致共享变量的值，对其他线程不是立即课件的。缓存读的旧值</li>
<li>有序性：写的代码的顺序和实际代码的顺序不一致，是由于编译器和处理器层面对指令重排优化导致的，可能会导致可见性问题</li>
</ol>
<p>我们可以使用voliate或者是直接加synchronized，或者是直接加锁</p>
<p>或者使用原子类的CAS，或者是线程安全的ThreadLocal</p>
<h2 id="8-ConditionalOnClass-设计内涵">8.**<code>@ConditionalOnClass</code>**设计内涵</h2>
<p>面试官提出了一个非常精妙的问题：“<code>@ConditionalOnClass(User.class)</code>这行代码能编译通过，说明<code>User.class</code>肯定存在于classpath中，那为什么还需要这个注解呢？</p>
<p>未能理解<code>@Conditional</code>系列注解是为了解决<strong>通用starter模块在不同应用环境下的适配性</strong>问题，而不是为了解决当前项目中的类是否存在的问题。</p>
<p>确实，如果在我当前的项目中写<code>@ConditionalOnClass(User.class)</code>，这个条件判断看起来是多余的。因为<code>User.class</code>如果不存在，我的项目根本无法编译通过。</p>
<p>这个注解的真正威力体现在<strong>开发通用的starter模块</strong>时。想象一下，我们正在开发一个<code>my-sms-spring-boot-starter</code>，这个starter希望能够同时支持<strong>阿里云短信</strong>和<strong>腾讯云短信</strong>。</p>
<ul>
<li>
<p>我们的starter会提供两个自动配置类：<code>AliyunSmsAutoConfiguration</code> 和 <code>TencentSmsAutoConfiguration</code>。</p>
</li>
<li>
<p><code>AliyunSmsAutoConfiguration</code>负责创建阿里云短信服务的Bean。</p>
</li>
<li>
<p><code>TencentSmsAutoConfiguration</code>负责创建腾讯云短信服务的Bean。</p>
</li>
<li>
<p>一个**使用者（应用项目）*<em>在他的项目中引入了我们的starter。他可能只想使用阿里云短信，所以他只会在他的<code>pom.xml</code>中添加*<em>阿里云的SDK依赖</em></em>，而不会添加腾讯云的。</p>
</li>
<li>
<p>这时，我们的starter如何智能地判断只加载阿里云的Bean，而不去加载腾讯云的Bean呢？（如果去加载腾讯云的Bean，会因为缺少腾讯云SDK的jar包而直接抛出<code>ClassNotFoundException</code>，导致应用启动失败）</p>
</li>
<li>
<p>我们就是使用@ConditionalOnClass</p>
</li>
</ul>
<p>在<code>AliyunSmsAutoConfiguration</code>上，我们会这样写,@ConditionalOnClass(com.aliyun.sms.sdk.SmsClient.class)</p>
<ul>
<li>当使用者的应用启动时，Spring Boot会解析我们starter中的这两个自动配置类。</li>
<li>在解析<code>AliyunSmsAutoConfiguration</code>时，它会检查<strong>当前应用的classpath</strong>中是否存在<code>com.aliyun.sms.sdk.SmsClient.class</code>。因为使用者添加了阿里云的SDK依赖，所以这个类存在，条件满足，这个配置类就会被加载，阿里云的Bean就会被创建。</li>
<li>在解析<code>TencentSmsAutoConfiguration</code>时，它会检查classpath中是否存在<code>com.tencent.cloud.sms.sdk.SmsSender.class</code>。因为使用者<strong>没有</strong>添加腾讯云的SDK依赖，所以这个类不存在，条件不满足，<strong>这个配置类就会被优雅地跳过，不会被加载</strong>，从而避免了<code>ClassNotFoundException</code>。</li>
</ul>
<p><code>@ConditionalOnClass</code>并不是为了判断我们自己项目里的类是否存在，而是为了让我们开发的**通用模块（starter）*<em>能够*<em>智能地感知和适配它所运行的应用环境</em></em>，根据应用环境中引入了哪些依赖，来动态地决定哪些功能应该被激活。这是Spring Boot实现‘约定大于配置’和‘开箱即用’的关键魔法之一</p>
<h2 id="9-ThreadLocal-在线程池中的失效问题">9.<strong><code>ThreadLocal</code> 在线程池中的失效问题</strong></h2>
<ul>
<li><code>InheritableThreadLocal</code>之所以能够实现父子线程间的数据传递，是因为在<code>new Thread()</code>创建子线程时，子线程的构造函数会检查父线程的<code>inheritableThreadLocals</code>这个Map。如果它不为空，子线程就会将父线程Map中的所有值<strong>拷贝</strong>一份到自己的<code>inheritableThreadLocals</code>中。</li>
<li><strong>关键在于</strong>：这个值的拷贝动作，<strong>只发生在子线程被创建的那一瞬间</strong>。</li>
<li>在线程池的场景下，工作线程通常在系统启动时就已经被<strong>预先创建</strong>好了，并存放在池中。当我们提交一个任务时，线程池只是从池中<strong>取出一个已经存在的线程</strong>来执行我们的任务，并<strong>没有<code>new Thread()</code>这个动作</strong>。</li>
</ul>
<p>为了解决这个问题，阿里巴巴开源了一个非常强大的工具——<strong><code>TransmittableThreadLocal</code>（TTL）</strong>。它专门用于解决在使用线程池等会池化线程的组件时，实现父子线程、任务提交者与任务执行者之间的上下文传递问题。</p>
<p>TTL的优点在于它通过<strong>Java Agent</strong>或<strong>手动包装</strong>的方式，对线程池的<code>submit</code>/<code>execute</code>等方法以及<code>Runnable</code>/<code>Callable</code>任务进行了<strong>装饰（Decorate）</strong>。”</p>
<ol>
<li><strong>任务提交时（<code>submit</code>）</strong>：当我们调用被装饰过的<code>threadPool.submit(myRunnable)</code>时，TTL会<strong>捕获</strong>当前线程（父线程）的<code>ThreadLocal</code>值，并将其**‘打包’**进一个<code>TtlRunnable</code>或<code>TtlCallable</code>对象中。</li>
<li><strong>任务执行前（<code>run</code>）</strong>：当线程池中的某个工作线程开始执行这个被包装过的<code>TtlRunnable</code>时，在其<code>run</code>方法的<code>try</code>块开始处，TTL会将被‘打包’的父线程<code>ThreadLocal</code>值，**‘回放’（replay）**到当前工作线程的<code>ThreadLocal</code>中。</li>
<li><strong>任务执行后（<code>finally</code>）</strong>：在<code>finally</code>块中，TTL会<strong>清理</strong>当前工作线程的<code>ThreadLocal</code>，将其恢复到执行任务之前的状态，从而避免了数据串扰。</li>
</ol>
<h2 id="10-如何保证三个线程有序执行任务">10.如何保证三个线程有序执行任务</h2>
<p>方案1：使用**<code>wait/notify</code> 方案**</p>
<p>你需要自己管理锁（<code>synchronized</code>）、状态变量（<code>volatile int state</code>）、<code>while</code>循环（防止伪唤醒）、<code>try-finally</code>（保证锁释放），代码量大且极易出错。</p>
<p>使用<code>notifyAll()</code>会唤醒所有等待的线程，造成不必要的CPU竞争。而使用<code>notify()</code>又存在风险：如果错误地唤醒了不该被唤醒的线程（比如T1唤醒了T3而不是T2），信号就可能丢失，导致程序死锁。</p>
<p>方案2：<strong>升级版 <code>wait/notify</code> - <code>ReentrantLock</code> + <code>Condition</code></strong></p>
<p><code>ReentrantLock</code>提供了比<code>synchronized</code>更强大的功能。<code>Condition</code>对象则将<code>wait/notify</code>机制从“一个锁只有一个等待队列”升级为“<strong>一个锁可以有多个独立的等待队列</strong>”，我们可以为每个线程的“等待室”创建一个<code>Condition</code>，实现精准的“点对点”唤醒，彻底避免了<code>notify()</code>的信号丢失问题。</p>
<ol>
<li>创建一个<code>ReentrantLock</code>实例。</li>
<li>创建一个<code>volatile</code>状态变量，例如<code>volatile int state = 1;</code>，用于标识当前应该哪个线程执行。</li>
<li>为<strong>每个线程</strong>创建一个<code>Condition</code>对象：<code>Condition c1 = lock.newCondition(); Condition c2 = lock.newCondition(); Condition c3 = lock.newCondition();</code></li>
<li>线程T1的逻辑：
<ul>
<li>获取锁 <code>lock.lock()</code>。</li>
<li>在<code>try...finally</code>中执行，<code>finally</code>块中<code>lock.unlock()</code>。</li>
<li><code>while (state != 1)</code>，<code>c1.await()</code>。</li>
<li>执行任务1。</li>
<li>更新状态 <code>state = 2</code>。</li>
<li><strong>精准唤醒</strong>线程T2：<code>c2.signal()</code>。</li>
</ul>
</li>
<li><strong>线程T2和T3的逻辑</strong>与T1类似，分别在自己的<code>Condition</code>上<code>await</code>，并在执行完任务后，更新<code>state</code>并<code>signal</code>下一个线程的<code>Condition</code>。</li>
</ol>
<p>实现了有序执行，通过<code>signal()</code>实现了精准唤醒，比<code>notifyAll()</code>更高效，比<code>notify()</code>更安全。但还是比较复杂</p>
<p>方案3：<strong>信号量接力 - <code>Semaphore</code></strong></p>
<p><code>Semaphore</code>（信号量）是控制同时访问特定资源的线程数量的工具。我们可以创建两个初始许可为0的信号量，作为两个线程之间的“接力棒”。</p>
<ol>
<li>创建两个信号量：<code>Semaphore sem2 = new Semaphore(0);</code> 和 <code>Semaphore sem3 = new Semaphore(0);</code>。</li>
<li>线程T1的逻辑：
<ul>
<li>执行任务1。</li>
<li>执行完毕后，释放一个“给T2的许可”：<code>sem2.release()</code>。</li>
</ul>
</li>
<li>线程T2的逻辑：
<ul>
<li>首先尝试获取“来自T1的许可”，如果许可未被释放，T2将在此阻塞：<code>sem2.acquire()</code>。</li>
<li>获取到许可后，执行任务2。</li>
<li>执行完毕后，释放一个“给T3的许可”：<code>sem3.release()</code>。</li>
</ul>
</li>
<li>线程T3的逻辑：
<ul>
<li>首先尝试获取“来自T2的许可”：<code>sem3.acquire()</code>。</li>
<li>获取到许可后，执行任务3。</li>
</ul>
</li>
</ol>
<p>代码清晰简单，但需要创建N-1个<code>Semaphore</code>对象，如果线程数量很多，会增加一些对象管理的开销。</p>
<p>方案4：<strong><code>SingleThreadExecutor</code></strong></p>
<p><code>Executors.newSingleThreadExecutor()</code>会创建一个<strong>单线程的线程池</strong>。这个线程池的核心特性是：它内部有一个<strong>无界的<code>LinkedBlockingQueue</code>**来存放任务，并且**永远只有一个工作线程</strong>来从队列中取出并执行任务。这就天然地保证了所有提交给它的任务，都会<strong>严格按照提交的顺序（FIFO）来串行执行</strong>。</p>
<ol>
<li>
<p>创建一个单线程执行器：<code>ExecutorService executor = Executors.newSingleThreadExecutor();</code></p>
</li>
<li>
<p>定义三个任务（<code>Runnable</code>或<code>Callable</code>）：<code>task1</code>, <code>task2</code>, <code>task3</code>。</p>
</li>
<li>
<p>按顺序提交任务：java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>关闭线程池：<code>executor.shutdown()</code>。</p>
</li>
</ol>
<ul>
<li><strong>严格来说，这是“三个任务有序执行”，而不是“三个不同的线程有序执行”</strong>。因为所有任务都是由<strong>同一个</strong>工作线程来执行的。如果面试官的题目严格要求必须是三个<strong>不同的、预先创建好</strong>的线程，那么这个方案就不完全符合字面要求。</li>
</ul>
<h2 id="11-ReentrantLock-和-synchronized-在性能上到底差异在哪？">11.<strong><code>ReentrantLock</code> 和 <code>synchronized</code> 在性能上到底差异在哪？</strong></h2>
<ul>
<li>
<p><code>synchronized</code>：</p>
<ul>
<li><strong>实现</strong>：它是Java的<strong>关键字</strong>，由JVM层面直接实现。其核心依赖于操作系统底层的**<code>Mutex Lock</code>（互斥量）**。</li>
<li><strong>开销</strong>：获取和释放<code>Mutex Lock</code>需要进行<strong>用户态到内核态的切换</strong>，这是一个非常昂贵的操作，涉及到线程上下文的切换和调度，会消耗大量的CPU时间。</li>
</ul>
</li>
<li>
<p><strong><code>ReentrantLock</code></strong>：</p>
<ul>
<li><strong>实现</strong>：它是一个<strong>Java类</strong>，位于<code>java.util.concurrent.locks</code>包下。其核心是基于**AQS（AbstractQueuedSynchronizer）**框架实现的。</li>
<li><strong>开销</strong>：AQS在底层利用了<strong>CAS（Compare-And-Swap）*<em>这一CPU原子指令和*</em><code>volatile</code>**关键字。在**无竞争或低竞争</strong>的情况下，<code>ReentrantLock</code>可以通过CAS操作直接在用户态完成锁的获取，<strong>完全避免了内核态的切换</strong>，因此性能极高。</li>
</ul>
</li>
</ul>
<p><code>ReentrantLock</code>性能一定优于<code>synchronized</code>”这个说法，在JDK 1.6之前是成立的。但在1.6之后，JVM对<code>synchronized</code>进行了翻天覆地的优化，引入了**锁升级（Lock Escalation）**机制，使其性能在很多场景下已经不输甚至优于<code>ReentrantLock</code>。</p>
<ul>
<li><strong>偏向锁</strong>：在只有一个线程访问同步块的场景下，<code>synchronized</code>几乎没有同步开销，性能极高。</li>
<li><strong>轻量级锁</strong>：当出现少量线程交替竞争时，<code>synchronized</code>会使用**自旋（Spinning）**的方式尝试获取锁。自旋也是在用户态完成的，避免了线程阻塞和内核态切换，性能同样很高。</li>
<li><strong>重量级锁</strong>：只有当竞争非常激烈，自旋多次仍无法获取锁时，<code>synchronized</code>才会升级为重量级锁，退化到依赖操作系统的<code>Mutex Lock</code>。</li>
</ul>
<p>只不过ReetrantLock有更多的功能，</p>
<ul>
<li><strong>可中断等待</strong>：<code>lockInterruptibly()</code>允许线程在等待锁的过程中响应中断。</li>
<li><strong>可超时等待</strong>：<code>tryLock(long timeout, TimeUnit unit)</code>可以避免死等。</li>
<li><strong>多条件变量</strong>：一个<code>ReentrantLock</code>可以创建多个<code>Condition</code>对象，实现更精细的线程通信。</li>
</ul>
<h1>Mybatis</h1>
<h2 id="1-UserMappe这个类为啥要是接口呢？">1.UserMappe这个类为啥要是接口呢？</h2>
<p>MyBatis的Mapper之所以必须定义为接口，其根本原因在于MyBatis框架在底层使用了**JDK动态代理（JDK Dynamic Proxy）**技术，来为我们自动地生成这个接口的实现类。</p>
<p>只定义了<code>UserMapper</code>接口，并在XML文件中写了SQL，但我们<strong>从来没有手动编写过一个<code>class UserMapperImpl implements UserMapper</code></strong>。然而，在Service层，我们却可以直接<code>@Autowired</code>注入一个<code>UserMapper</code>的实例并调用它的方法。</p>
<ol>
<li><strong>启动时扫描</strong>：当Spring容器启动时，MyBatis的<code>MapperScannerConfigurer</code>会扫描指定的包路径（如<code>com.example.mapper</code>），找到所有被<code>@Mapper</code>注解标记的接口，或者所有继承了特定标记接口的接口。</li>
<li><strong>注册Bean定义</strong>：对于找到的每一个Mapper接口（比如<code>UserMapper.class</code>），MyBatis并不会去创建一个真实的实现类，而是在Spring容器中注册一个特殊类型的Bean定义——<code>MapperFactoryBean</code>。</li>
<li><strong>创建代理对象</strong>：当Service层需要注入<code>UserMapper</code>时，Spring会向<code>MapperFactoryBean</code>请求获取Bean实例。此时，<code>MapperFactoryBean</code>就会调用JDK动态代理，<strong>在内存中动态地生成一个<code>UserMapper</code>接口的代理实现对象</strong>。</li>
</ol>
<ul>
<li>
<p>“这个动态生成的代理对象，它的内部有一个<code>InvocationHandler</code>。当我们调用代理对象的任何方法时（比如<code>userMapper.selectById(1)</code>），这个调用都会被<code>InvocationHandler</code>拦截。”</p>
</li>
<li>
<p>InvocationHandler的逻辑大致是：”</p>
<ol>
<li>它会获取到我们调用的<strong>方法名</strong>（<code>selectById</code>）和<strong>参数</strong>（<code>1</code>）。</li>
<li>它会将方法名与Mapper XML文件中配置的SQL语句的<code>id</code>进行<strong>映射和绑定</strong>。</li>
<li>它会从连接池获取一个数据库连接，将参数设置到SQL语句中，然后通过JDBC执行这条SQL。</li>
<li>最后，它会将查询结果封装成我们方法签名中定义好的返回类型（如<code>User</code>对象），并返回。</li>
</ol>
<p>正是因为MyBatis依赖于<strong>JDK动态代理</strong>，而JDK动态代理技术本身就<strong>要求被代理的目标必须是一个接口</strong>。它无法为一个具体的类或抽象类创建代理。这就是为什么Mapper必须是接口的根本技术原因。</p>
</li>
</ul>
<h1>JVM</h1>
<h2 id="1-那有哪些对象是可以直接在栈上分配呢？">1.那有哪些对象是可以直接在栈上分配呢？</h2>
<p>在Java中，并不是特定<strong>类型</strong>的对象能够直接在栈上分配，而是取决于该对象的<strong>作用域</strong>。JVM通过一种叫做**“逃逸分析”（Escape Analysis）**的技术来判断一个对象是否可以安全地在栈上分配。</p>
<p>如果一个对象的引用没有“逃逸”出它被创建的方法之外，那么它就可能被优化为在栈上分配。这样做的好处是，当方法执行结束时，栈帧被弹出，对象的内存会立即被回收，无需等待垃圾回收（GC），从而提高性能。</p>
<ul>
<li><strong>逃逸分析是JIT（即时编译器）的一项优化技术，默认在现代JVM中是开启的。<strong>只有那些</strong>生命周期完全局限于单个方法调用</strong>内、<strong>体积较小</strong>且<strong>线程安全</strong>的对象，才最有可能被优化到栈上进行分配。</li>
</ul>
<p>未逃逸的定义：</p>
<ol>
<li><strong>仅在方法内部使用</strong>：对象的引用完全封装在方法体内，没有被方法返回。</li>
<li><strong>未赋值给外部变量</strong>：没有将该对象的引用赋值给任何类变量（<code>static</code>字段）或实例变量。</li>
<li><strong>未传递给可能逃逸的方法</strong>：没有将该对象的引用作为参数传递给其他方法，或者传递给了但能确定其他方法也不会让它“逃逸”。</li>
</ol>
<p>逃逸的例子：</p>
<p>比如对象作为方法的返回值，他就是逃离了这个方法的作用域</p>
<p>对象引用赋值给实例变量，也是逃离这个方法的作用域</p>
<h2 id="2-JMM和一个对象的生命周期">2.JMM和一个对象的生命周期</h2>
<p>JMM划分：</p>
<p>​	线程共享：方法区 堆</p>
<p>​	线程私有：程序计数器，虚拟机栈，本地方法栈</p>
<p>生命周期：</p>
<p>​	创建： 类加载检查 -&gt; 堆内存分配（指针碰撞/空闲列表）-&gt; 初始化零值 -&gt; 设置对象头 -&gt; 执行 <code>init</code> 方法。</p>
<p>​	进行使用</p>
<p>​	回收：可达性分析 -&gt; 垃圾回收算法 -&gt; 分代回收(Minor GC, Full GC)</p>
<p>优化手段:</p>
<p>逃逸分析、栈上分配、TLAB（线程本地分配缓冲）等优化手段</p>
<p>逃逸分析、栈上分配和TLAB是JVM为了<strong>自动化地提升对象分配效率、降低GC压力</strong>而设计的一套<strong>协同工作的优化组合拳</strong></p>
<p>逃逸分析是决策入口，它决定了一个不逃逸的对象是否有资格享受<strong>栈上分配</strong>这一‘特权’，从而完全避免GC。对于必须在堆上分配的逃逸对象，<strong>TLAB</strong>则为它们提供了线程私有的‘VIP通道’，避免了并发分配时的锁竞争。</p>
<ol>
<li>当我们在代码中写下 <code>new User()</code> 时，这个<code>User</code>对象在JVM中并不是“无脑地”直接被分配到堆上。它会经历一个由JVM JIT（即时编译器）主导的、充满优化的“审批流程”</li>
<li><strong>逃逸分析</strong>：逃逸分析是一种<strong>编译期优化技术</strong>，它不是直接的优化手段，而是一种<strong>分析手段</strong>。JIT编译器会分析一个<strong>对象的动态作用域</strong>，判断这个对象是否有可能“逃逸”出它的创建方法或当前线程。</li>
<li>如果逃逸分析的结果是：<strong>“这个对象完全不逃逸！”</strong>，那么JVM就会启用一个颠覆性的优化。<strong>栈上分配</strong>是指将那些<strong>不逃逸的小对象</strong>，直接在**当前线程的虚拟机栈（Stack）<strong>上进行分配，而不是在</strong>堆（Heap）**上。</li>
<li>如果逃逸分析的结果是：<strong>“这个对象逃逸了，必须在堆上分配”</strong>，那么JVM并不会立刻去抢占全局的堆内存，而是会尝试一个更高效的策略。</li>
<li><strong>TLAB（线程本地分配缓冲）**是JVM为了**提升对象在堆上分配的效率</strong>而设计的一种机制。JVM会在堆的<strong>新生代（Eden区）**为**每个线程</strong>预先分配一小块<strong>私有的内存区域</strong>，这个区域就叫TLAB。<strong>避免并发冲突</strong>：堆是所有线程共享的。如果没有TLAB，那么每次<code>new</code>一个对象，多个线程都需要去<strong>竞争同一块Eden区的内存</strong>。这个过程需要<strong>加锁</strong>（比如CAS）来保证分配的原子性，在高并发下会成为性能瓶颈。</li>
<li>当一个线程需要分配一个新对象时，它会<strong>首先尝试在自己的TLAB中进行分配</strong>。</li>
<li>因为TLAB是线程私有的，所以在这个区域内分配对象<strong>完全不需要加锁</strong>，速度极快，这是一个简单的**指针碰撞（Bump the Pointer）**操作。</li>
<li>只有当<strong>TLAB的空间用完了</strong>，或者要分配的<strong>对象太大TLAB放不下</strong>时，线程才会去申请一个新的TLAB，或者在全局的Eden区（此时需要加锁）进行分配。</li>
<li>然后在堆中是如何分配的呢？</li>
</ol>
<p>内存分配方式：**主要有两种——**指针碰撞（Bump the Pointer）**和**空闲列表（Free List）。如果堆内存是规整的，就用指针碰撞（简单高效）；如果是不规整的（比如使用 CMS 收集器后），就用空闲列表。</p>
<p>并发处理：在多线程并发创建对象时，如何保证堆上分配的线程安全？除了你提到的 <strong>TLAB</strong>（每个线程预先在 Eden 区申请一小块私有区域），另一种方式是对<strong>整个堆的分配动作进行 CAS 加锁</strong>。TLAB 是为了避免频繁的 CAS 加锁，是一种更高效的优化。</p>
<p>除了这些JMM内还有一个优化的策略就是堆外内存，它是一种<strong>手动管理</strong>的内存区域，不属于JVM GC的管理范畴。</p>
<p>通过NIO的<code>ByteBuffer.allocateDirect()</code>方法分配的内存。这块内存并不在Java堆上，而是直接向操作系统申请的本地内存。</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">堆内存 (Heap)</th>
<th style="text-align:left">堆外内存 (Off-Heap)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>管理者</strong></td>
<td style="text-align:left">JVM (GC自动管理)</td>
<td style="text-align:left">开发者 (手动管理) / <code>Cleaner</code>机制</td>
</tr>
<tr>
<td style="text-align:left"><strong>分配速度</strong></td>
<td style="text-align:left">快 (TLAB)</td>
<td style="text-align:left">慢 (系统调用)</td>
</tr>
<tr>
<td style="text-align:left"><strong>访问速度</strong></td>
<td style="text-align:left">快</td>
<td style="text-align:left">极快 (与I/O交互时)</td>
</tr>
<tr>
<td style="text-align:left"><strong>GC影响</strong></td>
<td style="text-align:left">受GC影响，可能STW</td>
<td style="text-align:left"><strong>不受GC影响</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>大小限制</strong></td>
<td style="text-align:left">受<code>-Xmx</code>参数限制</td>
<td style="text-align:left">受物理内存限制</td>
</tr>
</tbody>
</table>
<p>我们可以使用他来完成零拷贝的操作</p>
<ul>
<li>当进行网络或文件I/O操作时，如果数据在堆内存中，需要先从<strong>堆内存拷贝到内核缓冲区</strong>，再由操作系统发送出去。</li>
<li>如果数据直接在堆外内存中，JVM可以直接将这块内存的地址交给操作系统，省去了从用户态到内核态的这次数据拷贝，实现了**“零拷贝”**，极大地提升了I/O性能。</li>
</ul>
<p>使用：</p>
<ul>
<li><strong>Netty</strong>、<strong>RocketMQ</strong>等高性能网络/消息框架，大量使用堆外内存作为网络通信的缓冲区。</li>
<li>需要缓存大量数据，且不希望对GC造成巨大压力的场景（例如，本地缓存框架）。</li>
<li>但是,容易出现内存泄漏和排查困难的问题</li>
</ul>
<p><strong>如何定位和分析</strong>内存问题的?</p>
<p>通过监控工具如 Arthas, VisualVM, 或者日志,通过 <code>jmap</code> dump 堆内存，再用 MAT 等工具分析,是优化了数据结构减少内存占用，还是调整了 JVM 参数，比如 <code>-Xmx</code>, <code>-Xms</code></p>
<p>回收：</p>
<p>每个对象从诞生之初，JVM就在它的**对象头（Object Header）**里，为它设置了一个‘年龄计数器’（Age），占4个bit。这个‘年龄’是对象晋升老年代的主要依据</p>
<ul>
<li>绝大多数新创建的对象，首先会被分配在新生代的<strong>Eden区</strong>。此时，它们的<strong>年龄为0</strong>。</li>
<li>当Eden区满了之后，会触发第一次<strong>Minor GC</strong>。</li>
<li>GC会扫描Eden区，将所有<strong>存活的对象</strong>复制到新生代的<strong>Survivor区中的一个（我们称之为To-Survivor区）</strong>。</li>
<li>在这个复制的过程中，这些幸存对象的<strong>年龄会加1</strong>。</li>
<li>Eden区中所有未被复制的（被判定为垃圾的）对象，都会被一次性清空。</li>
<li>新生代有两个Survivor区，我们通常称之为<code>S0</code>和<code>S1</code>。在任何时刻，总有一个是空的（To-Survivor），另一个是有数据的（From-Survivor）。</li>
<li>当<strong>下一次Minor GC</strong>发生时，GC会同时扫描<strong>Eden区</strong>和<strong>From-Survivor区</strong>（即上次存放幸存对象的那个区）。</li>
<li>所有存活的对象，都会被<strong>再次复制</strong>到那个空的<strong>To-Survivor区</strong>。</li>
<li>同样，在复制过程中，这些对象的<strong>年龄会再次加1</strong>。</li>
<li>清空Eden区和From-Survivor区。然后，<code>S0</code>和<code>S1</code>的角色互换，为下一次GC做准备。</li>
<li>这个过程会一直重复。对象就在<code>S0</code>和<code>S1</code>之间来回“倒腾”，每经历一次Minor GC，只要它还活着，年龄就会加1。</li>
<li>当一个对象在Survivor区中不断地“倒腾”，其年龄<strong>达到一个设定的阈值</strong>时，在下一次Minor GC中，它将不再被复制到另一个Survivor区，而是被<strong>直接晋升（Promote）到老年代</strong>。</li>
<li>这个年龄阈值可以通过JVM参数<code>-XX:MaxTenuringThreshold</code>来设置。默认是15，因为对象头中的年龄计数器只有4个bit，最大能表示的数字就是15（二进制<code>1111</code>）。</li>
</ul>
<p>一个新生代的晋升流程Eden -&gt; S0 -&gt; S1 -&gt; … -&gt; Old，年龄为15的时候进入老年代</p>
<p>除了年龄达到阈值，还有一种情况会触发晋升：如果在 Survivor 区中，<strong>相同年龄的所有对象大小的总和，大于 Survivor 空间的一半</strong>，那么<strong>年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无需等到 <code>MaxTenuringThreshold</code>。这个规则是为了<strong>防止Survivor区被过度填充</strong>。如果大量同龄的对象在某次GC后集中幸存，可能会导致Survivor区空间不足，进而触发更复杂的分配担保机制。动态年龄判断可以在这种情况发生前，提前将一些“年长”的对象送到老年代，为更“年轻”的对象腾出空间。</p>
<p>大对象直接晋升，这个对象的大小超过了由<code>-XX:PretenureSizeThreshold</code>参数设定的阈值，那么这个大对象将<strong>不会</strong>被分配在新生代的Eden区，而是会被<strong>直接分配到老年代</strong>。</p>
<p>在执行Minor GC之前，JVM会检查<strong>老年代的连续可用空间</strong>是否<strong>大于新生代所有对象的总大小</strong>（或者大于历次晋升到老年代的对象的平均大小）。</p>
<ul>
<li>如果<strong>是</strong>，那么这次Minor GC是安全的。如果<strong>否</strong>，JVM会进行一次<strong>Full GC</strong>来清理老年代，以腾出更多空间。</li>
<li>如果在Minor GC过程中，Survivor区确实无法容纳所有存活对象，那么多余的对象就会通过这个<strong>分配担保机制，被直接移入老年代</strong>。</li>
</ul>
<h2 id="3-GC">3.GC</h2>
<p>对象死亡的三个方法，引用计数器，可达性分析，finalize方法，可达性分析需要两次标记，第一次看是不是没用跟引用链相连，第二次看队列中的是不是还没有相连</p>
<p>CMS 选择标记-清除的核心原因是，它是一个**并发（Concurrent）**收集器，在垃圾收集的大部分阶段，<strong>用户线程（Mutator）和 GC 线程是可以同时运行的</strong>。而标记-整理算法需要移动对象，这个过程非常复杂，很难与用户线程并发执行，所以 CMS 只能选择实现相对简单的标记-清除。这也正是 CMS 产生内存碎片的根本原因。</p>
<p>CMS 的核心优势恰恰在于它的<strong>并发标记（Concurrent Mark）**和**并发清除（Concurrent Sweep）*<em>阶段，是*<em>可以和用户线程一起运行的</em></em>，从而大大缩短了 STW 时间。CMS 的 STW 主要发生在</strong>初始标记（Initial Mark）**和**重新标记（Remark）*<em>这两个非常短暂的阶段。你应该强调 CMS 的 STW **总时长很短**，但*<em>不可预测</em></em>；</p>
<p>而 G1 的 STW 虽然也是分阶段的，但其<strong>总时长可以在一个目标范围内被预测和控制</strong>。</p>
<h1>JavaSE</h1>
<h2 id="1-流式输出和非流式输出">1.流式输出和非流式输出</h2>
<table>
<thead>
<tr>
<th>对比点</th>
<th>流式输出</th>
<th>非流式输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据传输</strong></td>
<td>边生产边传输</td>
<td>生成完后一次传输</td>
</tr>
<tr>
<td><strong>响应延迟</strong></td>
<td>首字节快，用户能尽快看到结果</td>
<td>必须等所有数据生成后才能看到</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>占用更少内存（分段处理）</td>
<td>可能占用大量内存（一次性加载）</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>较高（需要支持分段协议/推送机制）</td>
<td>较低（一次性返回）</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>视频流、日志实时消费、AI Chat逐字打印</td>
<td>小文件下载、查询一次性返回结果</td>
</tr>
</tbody>
</table>
<p>非流式输出是等数据全部生成后一次性返回，而流式输出则是边生成边返回，能降低延迟和内存占用，更适合大数据量和实时场景。</p>
<h2 id="2-HashMap-remove-方法的实现细节">2.<strong>HashMap <code>remove</code> 方法的实现细节</strong></h2>
<ol>
<li>首先，<code>remove(key)</code>方法会计算<code>key</code>的<code>hash</code>值。</li>
<li>根据<code>hash</code>值定位到它在底层<code>table</code>数组中的索引位置（即bucket）。</li>
<li>如果该bucket为空，直接返回<code>null</code>。</li>
<li>如果bucket不为空，则遍历该位置的链表或红黑树，逐个节点使用<code>hash</code>值和<code>equals()</code>方法进行比较，直到找到要删除的目标节点。如果遍历完没找到，也返回<code>null</code>。</li>
</ol>
<p><strong>如果当前是链表结构</strong>,是头节点的话，即让头节点的下一个节点成为新的头节点。</p>
<p><strong><code>p</code>是中间节点或尾节点</strong>。那么就跳过这个节点，GC将自动回收这个不再被引用的节点</p>
<ul>
<li>红黑树的删除操作要复杂得多，因为它必须在删除节点后，通过一系列的**旋转（Rotation）和重新着色（Recoloring）*<em>操作，来*<em>维持红黑树的5条性质</em></em>（例如，根是黑的、不能有连续的红节点、任何节点到其每个叶子节点的所有路径都包含相同数目的黑色节点等），从而保证树的平衡性。</li>
<li><code>HashMap</code>会调用内部的<code>removeTreeNode</code>方法来执行这个复杂的过程。</li>
<li>在红黑树中删除了一个节点后，<code>HashMap</code>还会检查该bucket的节点数量。如果数量减少到了一个<strong>阈值（UNTREEIFY_THRESHOLD，默认为6）</strong>，为了节省内存和在节点数少时提升性能，这棵红黑树会**退化（untreeify）**变回普通的链表结构。</li>
<li>删除成功后，<code>HashMap</code>的<code>size</code>会减1。</li>
<li>方法会返回被删除节点的<code>value</code>值。</li>
</ul>
<h2 id="3-说说-ArrayList、LinkedList、CopyOnWriteArrayList-这三者的适用场景与关键差异">3.说说 <strong>ArrayList、LinkedList、CopyOnWriteArrayList</strong> 这三者的适用场景与关键差异</h2>
<p><strong>1. ArrayList:</strong></p>
<ul>
<li><strong>底层结构:</strong> 基于<strong>动态数组</strong>实现，内存是连续的。它实现了 <code>RandomAccess</code> 标记接口。</li>
<li>关键差异:
<ul>
<li><strong>读性能:</strong> 支持高效的随机访问，<code>get(index)</code> 操作的时间复杂度是 O(1)。</li>
<li><strong>写性能:</strong> 尾部添加（<code>add(e)</code>）均摊复杂度是 O(1)，但<strong>在中间插入或删除元素，需要移动后续所有元素，时间复杂度是 O(n)</strong>，开销很大。</li>
</ul>
</li>
<li><strong>迭代一致性:</strong> 它的迭代器是**快速失败（Fail-fast）**的。如果在迭代过程中，集合结构被其他线程修改，会立刻抛出 <code>ConcurrentModificationException</code>。</li>
</ul>
<p><strong>2. LinkedList:</strong></p>
<ul>
<li><strong>底层结构:</strong> 基于<strong>双向链表</strong>实现。</li>
<li>关键差异:
<ul>
<li><strong>读性能:</strong> 不支持高效的随机访问，访问一个元素需要从头或尾遍历，时间复杂度是 O(n)。</li>
<li><strong>写性能:</strong> <strong>在头部或尾部进行增删操作，时间复杂度是 O(1)</strong>，效率极高。但在中间位置操作，需要先遍历定位，所以复杂度也是 O(n)。</li>
</ul>
</li>
<li><strong>迭代一致性:</strong> 和 ArrayList 一样，是**快速失败（Fail-fast）**的。</li>
</ul>
<p><strong>3. CopyOnWriteArrayList (COWArrayList):</strong></p>
<ul>
<li><strong>底层结构:</strong> 同样基于<strong>数组</strong>。</li>
<li>关键差异:
<ul>
<li><strong>并发安全:</strong> 它是<strong>线程安全</strong>的，核心思想是“<strong>写时复制</strong>”。</li>
<li><strong>读性能:</strong> 读操作<strong>完全不加锁</strong>，直接访问底层数组，性能和 ArrayList 相当，非常高效。</li>
<li><strong>写性能:</strong> 写操作（增删改）<strong>开销巨大</strong>。它需要先加锁，然后<strong>完整地拷贝一份新数组</strong>，在新数组上修改，最后再将引用指向新数组。</li>
</ul>
</li>
<li><strong>迭代一致性:</strong> 它的迭代器是**快照（Snapshot）**模式。迭代器创建时会引用当时的底层数组快照，后续的修改对该迭代器不可见，<strong>不会抛出异常</strong>，保证了迭代的绝对安全，但牺牲了数据的实时性。</li>
</ul>
<h2 id="4-反射的原理-应用">4.反射的原理&amp;&amp;应用</h2>
<p>反射机制允许程序在<strong>运行时</strong>动态地获取任意一个类的信息（如属性、方法、构造器）并进行操作。它的优点是极大地增加了程序的灵活性，是很多框架（如 Spring IoC）的实现基石。</p>
<p>在 <strong>JDK 动态代理</strong>中，反射主要用在最关键的一步——<strong>创建代理对象实例</strong>。</p>
<p>整个流程是：我们调用 <code>Proxy.newProxyInstance()</code> 方法来创建代理对象。在这个方法内部，它会：</p>
<ol>
<li>在运行时动态地创建一个新的代理类（<code>.class</code> 文件）。</li>
<li>然后，它会使用<strong>反射</strong>，通过 <code>proxyClass.getConstructor(InvocationHandler.class)</code> 获取到这个新代理类的构造器。</li>
<li>最后，再通过<strong>反射</strong>调用 <code>constructor.newInstance(invocationHandler)</code>，传入我们自己实现的 <code>InvocationHandler</code>，来<strong>实例化</strong>这个代理对象。</li>
<li>比如代理模式的实现就是在对象进行初始化的时候，在bootpostproffer的后置处理的时候，将原先的bean换成我们代理的bean</li>
</ol>
<p>所以，反射是用在了<strong>获取代理类的构造器并创建其实例</strong>这最核心的一步。</p>
<h1>Mysql</h1>
<h2 id="1-多表join的时候，小表驱动大表">1.多表join的时候，小表驱动大表</h2>
<p>在Mysql的 Nested Loop Join 中</p>
<p><strong>驱动表（outer table）</strong>：首先被扫描的表。</p>
<p><strong>被驱动表（inner table）</strong>：对驱动表每一行，根据 Join 条件去查找匹配行的表。</p>
<p><strong>核心原则</strong>：过滤后剩余行数少的表，应该作为驱动表，这样可以减少被驱动表的访问次数。这就是小表</p>
<p>执行过程：</p>
<p>扫描驱动表（全表扫描或索引扫描）。</p>
<p>对驱动表的每一行，根据连接条件在被驱动表中查找（通常用索引 B+Tree 查找）。</p>
<p>如果被驱动表使用二级索引且需要回表，则访问主键索引。</p>
<p>小表驱动大表，大表负责命中索引。</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A straight_join B on A.a = B.a;</span><br></pre></td></tr></table></figure>
<p>数据库会全表扫A，然后每拿到一行就去比较条件 A.a=B.a，去B表里面查，B表命中索引的查询。实际上就是一个搜索树，查询的时间复杂度近似log2^B^，然后加上一次回表，可能就是2Log2 ^B^,所以总体的时间复杂度为A+2log2^B^*A，如果是覆盖索引的话，复杂度可降为 O(A + log₂(B) × A)</p>
<p>所以我的们A越小越好，join的本质就是查驱动表，然后扫被驱动表，当然是查的越少越好了</p>
<h2 id="2-一条-UPDATE-语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理">2.一条 <code>UPDATE</code> 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理</h2>
<p>Mysql是一个分层的，核心模块包括网络层、SQL层和存储引擎层。</p>
<p>如果以一条 <code>UPDATE t SET c = 2 WHERE id = 1;</code> 语句为例，它的生命周期是这样的：</p>
<p>网络层：</p>
<p>首先，客户端通过TCP连接发送这条SQL。我的网络模块基于Java NIO实现，会接收这个请求，并将其传递给SQL层。</p>
<p>SQL层 - 解析与执行：</p>
<ul>
<li><strong>SQL解析器</strong>：SQL层会解析这条字符串，生成一个抽象语法树（AST）。</li>
<li><strong>执行器</strong>：然后，执行器会解释这棵树。对于这条<code>UPDATE</code>语句，它知道要去表<code>t</code>中找到<code>id=1</code>的行，并更新<code>c</code>列。</li>
</ul>
<p>存储引擎层 - 事务与数据处理：这是最核心的部分。</p>
<ul>
<li><strong>事务管理器</strong>：执行器会向事务管理器申请开启一个事务。</li>
<li><strong>访问数据</strong>：执行器请求存储引擎去获取<code>id=1</code>的行。存储引擎会先去 <strong>Buffer Pool</strong>（内存缓冲池）里查找，如果数据页不在内存，会通过 <strong>IO模块</strong> 从磁盘加载。</li>
<li><strong>并发控制</strong>：在读取和修改数据时，为了保证隔离性，这里会涉及到 <strong>MVCC</strong> 和 <strong>锁管理器</strong>。<code>UPDATE</code> 是一种“当前读”，所以它会读取最新的已提交版本，并在这行数据上加一个 <strong>排他锁（X Lock）</strong>，防止其他事务同时修改。</li>
<li><strong>执行修改</strong>：获取到锁之后，执行器会在 Buffer Pool 中修改对应的数据页。但它不是直接覆盖旧数据，而是会生成一个 <strong>undo日志</strong>，记录下修改前的样子，用于回滚和支持MVCC。</li>
<li><strong>记录日志</strong>：在修改内存数据页之前，必须先将这次操作的详细信息写入 <strong>redo日志（WAL）</strong> 的内存缓冲区。这是为了保证持久性。</li>
<li><strong>提交事务</strong>：当客户端发起 <code>COMMIT</code> 时，<strong>日志管理器</strong> 会确保对应的 redo 日志被刷入磁盘。只要 redo 日志落盘了，即使此时宕机，数据也能恢复，所以我们就可以认为事务提交成功了。</li>
<li><strong>数据落盘</strong>：至于 Buffer Pool 里的脏数据页，则由一个后台线程根据一定的策略（比如LRU）异步地刷回磁盘，这个过程不影响事务的提交响应。</li>
</ul>
<h2 id="3-为什么选择-WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？">3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？</h2>
<p>选择 WAL 的核心优势在于<strong>将随机IO转换为了顺序IO，极大地提升了写入性能并保证了数据不丢失</strong>。</p>
<ul>
<li><strong>性能提升</strong>：数据库的数据页在磁盘上是离散存储的，修改它们需要大量的随机磁盘寻址，非常慢。而日志文件是追加写入的，是顺序IO，速度比随机IO快几个数量级。通过 WAL，事务提交时只需要保证日志落盘即可，脏数据页可以异步、批量地刷回磁盘，大大降低了事务提交的延迟。</li>
<li>顺序保证：这个顺序是绝对不能颠倒的，必须是先写日志（Log），再更新内存页（Buffer Pool）。这就是“Write-Ahead Logging”（预写日志）这个名字的由来。
<ul>
<li><strong>原因</strong>：如果反过来，先修改了内存中的数据页，然后系统在写日志之前宕机了。那么当系统重启时，内存中的修改会全部丢失，而日志里又没有记录这次操作，这个更新就永远地丢失了，这违反了事务的<strong>持久性（Durability）</strong>。而只要保证日志先写入，即使系统在数据页刷盘前宕机，重启后也可以通过扫描 redo 日志来恢复数据，保证了数据的完整性。”</li>
</ul>
</li>
</ul>
<h2 id="4-当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？">4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？</h2>
<p>当向一个叶子节点插入数据，发现它已经满了的时候，会触发分裂操作，逻辑如下：</p>
<ol>
<li><strong>叶子节点分裂：</strong> 找到中间位置的 key，将节点平分成两个。将这个中间 key <strong>连同指向新节点的指针</strong>一起“上提”到父节点中。</li>
<li><strong>内部节点分裂：</strong> 如果因为子节点的“上提”导致父节点也满了，那么父节点（内部节点）也需要分裂。找到中间位置的 key，将该 key <strong>单独</strong>“上提”到它的父节点中，而该 key 左右两侧的 key 和指针则分别构成两个新的内部节点。这个过程可能会一直递归到根节点。</li>
<li><strong>根节点分裂：</strong> 如果根节点也需要分裂，那么分裂后会产生一个新的根节点，此时 B+ 树的<strong>高度加一</strong>。</li>
</ol>
<p>关于并发问题，这是一个非常关键的点。对B+树的这种结构性修改（如分裂或合并）必须是原子的，否则可能导致树的结构被破坏。</p>
<ul>
<li>当一个线程需要修改一个B+树节点时，它会先获取这个节点的 Latch。在分裂过程中，它会同时持有父节点和要分裂的子节点的 Latch，操作完成后再释放。这种方式只锁定了必要的节点，允许其他不相关的读写操作继续进行。</li>
</ul>
<p>Lock 和 Latch 区别</p>
<ul>
<li><strong>保护对象</strong>：<strong>Lock（锁）</strong> 是在<strong>事务层面</strong>，用来保护<strong>逻辑数据</strong>，比如表中的一行记录。它的目的是保证事务的隔离性。<strong>Latch（闩锁）</strong> 是在<strong>线程层面</strong>，用来保护<strong>内存中的物理数据结构</strong>，比如 Buffer Pool 中的一个数据页、B+树的一个节点或者一个共享的内存链表。它的目的是保证多线程访问共享内存结构时的线程安全。</li>
<li><strong>持有时间</strong>：<strong>Lock</strong> 的持有时间很长，可能会贯穿整个事务，直到事务提交或回滚才释放。<strong>Latch</strong> 的持有时间非常短，通常只在一次原子操作的临界区内持有，比如修改一个 B+ 树节点，操作一完成马上就释放。</li>
<li><strong>死锁</strong>：<strong>Lock</strong> 会涉及到死锁问题，需要数据库有专门的死锁检测机制。而 <strong>Latch</strong> 通常通过规定获取顺序（比如在B+树中总是从父节点到子节点获取）来避免死锁，所以一般认为 Latch 是无死锁的。</li>
</ul>
<p>简单来说，Lock 是给数据库用户（事务）用的，保证业务逻辑的正确性；Latch 是给数据库内核开发者用的，保证内核数据结构的正确性。”</p>
<p>为什么选择B+树？在IO上看</p>
<ol>
<li>
<ul>
<li><strong>关键在于“高扇出” (High Fan-out)：</strong> 数据库的数据是存储在磁盘上的，I/O 操作非常昂贵。我们需要一种“矮胖”的数据结构，而不是“瘦高”的。</li>
<li><strong>平衡二叉树为什么不行？</strong> 因为它是二叉的，每个节点最多两个子节点。一棵存储百万数据的 AVL 树，深度会非常高（约 log₂(n)），导致需要进行很多次磁盘 I/O 才能找到数据。</li>
<li><strong>B+ 树为什么行？</strong> B+ 树的<strong>非叶子节点只存储索引（key）而不存储数据（data）</strong>。这意味着在同样大小的磁盘页（比如 16KB）中，B+ 树的非叶子节点可以存放<strong>成百上千个索引指针</strong>，这就是“高扇出”。因此，一棵三到四层的 B+ 树就能存储上千万甚至上亿的数据，查询时只需要 3-4 次磁盘 I/O。</li>
<li><strong>B 树相比 B+ 树的劣势：</strong> B 树的非叶子节点也存数据，导致其“扇出”没有 B+ 树那么高，树的高度会相对更高，I/O 次数更多。</li>
</ul>
</li>
<li><strong>哈希表的另一个致命缺点：</strong> 除了哈希冲突，哈希索引<strong>不支持范围查询</strong>。而数据库中 <code>WHERE age &gt; 20</code> 这样的范围查询非常普遍，这是 B+ 树的叶子节点通过双向链表连接起来所能高效支持的。</li>
</ol>
<h2 id="5-慢查询的的过程">5.慢查询的的过程</h2>
<ul>
<li><strong>第一步：开启慢查询日志。</strong> 在 MySQL 中配置 <code>slow_query_log</code> 和 <code>long_query_time</code>，让数据库自动记录超过阈值的慢 SQL。</li>
<li><strong>第二步：分析慢查询日志。</strong> 使用 <code>mysqldumpslow</code> 等工具，对日志文件进行分析，找出出现频率最高、查询时间最长的 SQL。</li>
<li><strong>第三步：使用 <code>EXPLAIN</code> 分析执行计划。</strong> 针对找到的慢 SQL，使用 <code>EXPLAIN</code> 查看其执行计划，重点关注 <code>type</code>（是否为 <code>ALL</code> 全表扫描）、<code>key</code>（是否用上了索引）、<code>Extra</code>（是否出现了 <code>Using filesort</code>, <code>Using temporary</code>）等关键字段。</li>
</ul>
<p>通过在 xxx 字段上增加联合索引，并利用索引覆盖，我们将这条 SQL 的查询时间从 2 秒优化到了 50 毫秒，接口的 P99 响应时间也从 2.2 秒降低到了 200 毫秒。</p>
<h2 id="6-SQL">6.SQL</h2>
<p>1.查询前xxx</p>
<ul>
<li>使用limit</li>
<li>使用rank函数，<code>ROW_NUMBER()</code>: 不考虑并列，给出连续排名 (1, 2, 3, 4)。<code>RANK()</code>: 考虑并列，但会跳过排名。比如两个第二名，下一个就是第四名 (1, 2, 2, 4)。<code>DENSE_RANK()</code>: 考虑并列，且不跳过排名 (1, 2, 2, 3)。 在“取 Top N”的场景下，<code>RANK()</code> 或 <code>DENSE_RANK()</code> 通常是更合适的选择。</li>
</ul>
<p>2.联合索引怎么走？</p>
<p>A，B，C，where a &gt; ? and b = ? c != ?，怎么走</p>
<p><strong>只会使用到联合索引的 <code>A</code> 部分</strong>，而 <code>B</code> 和 <code>C</code> 部分将无法有效地利用索引来缩小查询范围。</p>
<p>优化器首先会使用索引来处理 <code>a &gt; ?</code> 这个条件。它会在 <code>(A, B, C)</code> 索引树上进行 <strong>范围扫描 (range scan)</strong>，找到所有满足 <code>a</code> 大于给定值的索引记录。这部分是高效的。</p>
<p>这是最关键的一点。当索引遇到了一个<strong>范围查询</strong>（如 <code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>），那么这个范围查询列（也就是 <code>A</code>）<strong>右边</strong>的所有索引列（也就是 <code>B</code> 和 <code>C</code>）都会<strong>失效</strong>，无法再用于进一步的索引查找。</p>
<ul>
<li><strong>为什么会失效？</strong> 联合索引的排序是严格按照 <code>A</code>, <code>B</code>, <code>C</code> 的顺序来的。它首先按 <code>A</code> 排序，在 <code>A</code> 值相同的情况下，再按 <code>B</code> 排序，以此类推。当你执行 <code>a &gt; ?</code> 时，你筛选出的是一个 <code>A</code> 值的范围。在这个范围里，<code>B</code> 的值是无序的（或者说，只是在每个单独的 <code>A</code> 值内部有序，但整体是无序的）。因此，数据库无法利用索引去快速定位满足 <code>b = ?</code> 的记录，只能一条一条地去过滤。</li>
</ul>
<h1>Redis</h1>
<h2 id="1-多级缓存数据一致性与失败回滚">1.<strong>多级缓存数据一致性与失败回滚</strong></h2>
<p>当被问及如何保证Redis和本地缓存更新的原子性，以及在更新失败时如何回滚，你的回答提到了不甚准确的“编程式事务”，并最终倾向于人工处理。</p>
<p>方案1：<strong>引入消息队列（MQ）进行可靠的异步处理</strong></p>
<ol>
<li>修改架构：Canal不再直接调用消费逻辑，而是将解析后的binlog事件作为消息发送到MQ的一个Topic中。</li>
<li>消费者逻辑：消费者服务从MQ拉取消息。其处理逻辑是：先失效Redis缓存，再发布一个广播消息（如通过Redis Pub/Sub）通知所有应用实例失效本地Caffeine缓存。</li>
<li>失败处理：只有当所有步骤成功后，消费者才向MQ发送ACK。如果处理过程中任何一步失败（如Redis连接超时），消费者不发送ACK。MQ会在超时后将该消息重新投递给其他消费者，实现自动重试。</li>
</ol>
<p>方案2 死信队列</p>
<ol>
<li>在Canal的消费者逻辑中，使用<code>Spring Retry</code>等框架对缓存失效操作进行封装。</li>
<li>配置重试策略，例如重试3次，每次间隔采用指数退避（如1s, 2s, 4s），避免在故障期间频繁冲击下游服务。</li>
<li>配置一个<code>RecoveryCallback</code>。当所有重试都失败后，将这条失败的binlog事件（包含表名、主键、操作类型等信息）发送到一个专门的**死信队列（Dead Letter Queue）**或记录到数据库的失败任务表中。</li>
<li>部署一个独立的监控程序或定时任务，消费DLQ中的消息，并发送告警（邮件、短信、钉钉）。</li>
</ol>
<p>如果重试逻辑设计不当，可能会在短时间内放大故障。死信队列需要有完善的监控，否则会成为被遗忘的角落。</p>
<p>方案3 <strong>先更新缓存，再更新数据库”的策略</strong></p>
<ol>
<li>写请求：先更新（或失效）Redis缓存，然后更新数据库。</li>
<li>为了解决并发更新导致的不一致问题，可以引入“延时双删”：先删缓存 -&gt; 更新数据库 -&gt; 延迟一段时间（如500ms）后再次删除缓存。</li>
<li>本地Caffeine缓存仍然可以通过监听Redis的key失效事件（Keyspace Notifications）或消息广播来同步失效。</li>
</ol>
<p><strong>非常不推荐</strong>。延时双删的延迟时间很难确定，无法100%保证一致性。代码侵入性强，业务逻辑与缓存逻辑耦合严重，维护困难。</p>
<h2 id="2-什么情况下，就是两个线程会持有同一把锁">2.什么情况下，就是两个线程会持有同一把锁</h2>
<p><strong>两个不同的线程在同一时刻是不可能持有同一把锁的</strong>，这是锁的<strong>互斥性</strong>基本原则所保证的。如果出现了这种情况，那一定是锁的实现出了严重的问题。</p>
<p>您这个问题可能是在考察一个非常重要的特性——<strong>锁的可重入性</strong>。可重入性指的是<strong>同一个线程</strong>可以多次成功获取同一把锁，而不会自己把自己锁死。在释放锁时，也需要释放相应次数后，锁才会被真正释放。”</p>
<p>比如：在一个复杂的业务方法A中，它获取了锁。然后它又调用了另一个方法B，而方法B也需要获取同一个锁。如果没有可重入性，那么在方法B中，当前线程会因为无法获取一个已经被自己持有的锁而陷入死锁。</p>
<p>实现：Redisson巧妙地使用了Redis的<strong>Hash数据结构</strong>来实现。</p>
<ul>
<li>当一个线程第一次获取锁时，它会在Redis中创建一个Hash。这个Hash的Key是锁的名称（例如<code>myLock</code>）。</li>
<li>这个Hash结构内部会存储两个关键信息：
<ul>
<li>一个field存储<strong>持有锁的线程标识</strong>（例如，UUID + ThreadId）。</li>
<li>另一个field存储一个<strong>计数器</strong>，表示该线程重入的次数，初始值为1。</li>
</ul>
</li>
<li>当同一个线程<strong>再次</strong>尝试获取这把锁时，Redisson会检查Hash中存储的线程标识。如果与当前线程标识匹配，它就不会阻塞，而是直接将计数器的值加1，表示又重入了一次。</li>
<li>当线程<strong>释放锁</strong>时，它会去将计数器减1。只有当计数器的值减到0时，Redisson才会真正地从Redis中删除这个Hash（即释放锁），这样其他线程才有机会获取。</li>
</ul>
<h2 id="3-如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？">3.<strong>如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？</strong></h2>
<p>您提的这个问题非常关键，它涉及到整个数据同步链路的<strong>高可用性</strong>。</p>
<ol>
<li><strong>Canal自身的高可用</strong>：首先，Canal自身是可以部署成<strong>高可用集群</strong>的。通过Zookeeper进行集群管理和主备选举，当主节点宕机时，备用节点可以自动接管，从而保证了数据订阅服务的连续性。</li>
<li><strong>链路中断的影响</strong>：如果Canal到消费端的链路中断，确实会导致缓存与数据库在中断期间的<strong>数据不一致窗口期变长</strong>。新写入的数据无法触发缓存失效，用户可能会在一段时间内读到旧的缓存数据。</li>
<li><strong>我们的容灾与补偿策略</strong>：
<ul>
<li><strong>监控与告警</strong>：我们必须对Canal的消费位点（Position）与MySQL主库的最新binlog位点之间的<strong>延迟</strong>做严格的监控。一旦延迟超过阈值（比如1分钟），就立即触发高级别告警，通知SRE和开发团队介入。</li>
<li><strong>设置合理的缓存TTL</strong>：即使同步链路中断，我们缓存中的数据也不是永久有效的。通过为所有缓存设置一个合理的<strong>兜底过期时间（TTL）</strong>，比如1小时，可以保证即使在最坏的情况下，数据不一致的时间也不会无限延长。这是一种<strong>自愈机制</strong>。</li>
<li><strong>手动全量/增量校准</strong>：对于极端重要的数据，我们会准备一个<strong>手动触发的数据校准脚本</strong>。当链路长时间中断并恢复后，可以运行这个脚本，根据时间戳或版本号，主动查询数据库，强制刷新Redis中的核心数据，确保最终一致性。”</li>
</ul>
</li>
</ol>
<h2 id="4-你提到用Redis的Pub-Sub来广播失效Caffeine本地缓存。">4.<strong>你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。</strong></h2>
<p><strong>Pub/Sub是‘fire-and-forget’（即发即忘）模式，不保证消息必达。如果某个应用实例因为网络抖动没收到失效消息，怎么办？</strong></p>
<p>您观察得非常仔细，Pub/Sub确实存在消息丢失的风险。对于这个问题，我们有分层级的解决方案</p>
<ol>
<li><strong>接受短暂不一致</strong>：对于大部分业务场景，单台服务器上短暂的本地缓存不一致是可以接受的。因为流量通常会通过负载均衡打到多台服务器上，只有一小部分用户请求会命中这台机器的旧缓存，且Caffeine本身也有过期机制，影响是可控的。</li>
<li><strong>引入更可靠的消息总线</strong>：如果业务对一致性要求极高，我们会放弃轻量级的Pub/Sub，转而使用<strong>更可靠的消息中间件（如RocketMQ）的广播消费模式</strong>。每个应用实例都作为一个消费者组内的广播消费者，订阅失效通知。MQ的ACK机制可以保证每个实例都可靠地收到失效消息。</li>
<li><strong>版本号机制</strong>：我们可以在缓存的对象中增加一个<strong>版本号或时间戳字段</strong>。当应用从缓存中获取到数据后，可以（在某些关键操作前）与数据库中的版本号进行一次快速比对。如果发现缓存版本落后，就主动失效本地缓存并重新加载。这是一种<strong>主动校验</strong>的补偿机制。”</li>
</ol>
<h2 id="5-缓存三问题">5.缓存三问题</h2>
<p><strong>布隆过滤器和缓存空值，这两种方案在你的项目中，你会如何选择？它们各自有什么优缺点和需要注意的地方？</strong></p>
<p><strong>方案一：缓存空值（Cache Null Values）</strong></p>
<ul>
<li>
<p>优点：</p>
<ul>
<li><strong>实现简单</strong>：逻辑清晰，开发和维护成本极低。</li>
<li><strong>效果直接</strong>：能100%拦截住对同一个不存在的key的重复攻击。</li>
</ul>
</li>
<li>
<p>缺点与注意事项：</p>
<ul>
<li><strong>消耗额外的缓存空间</strong>：如果被恶意攻击，攻击者不断变换不存在的key来查询，会导致Redis中存储大量的空值key，造成内存浪费。</li>
<li><strong>数据一致性问题</strong>：如果这个之前不存在的数据，后来又在数据库中被创建了（例如，一个新用户注册了），缓存中的空值需要有一种机制被及时地更新或失效，否则会导致用户刚注册完却查不到自己的信息。</li>
</ul>
<p>适用于<strong>不存在的key的集合相对固定，或者重复查询率高</strong>的场景。例如，查询一个已经下架的商品</p>
</li>
</ul>
<p><strong>方案二：布隆过滤器（Bloom Filter）</strong></p>
<ul>
<li>优点：
<ul>
<li><strong>空间效率极高</strong>：它使用位图（bitmap）来存储数据，占用的内存空间远小于缓存空值方案，非常适合处理海量数据。</li>
</ul>
</li>
<li>缺点与注意事项：
<ul>
<li><strong>存在误判率（False Positive）</strong>：布隆过滤器判断“不存在”是100%准确的，但判断“存在”时，有一定概率会把一个不存在的key误判为存在。这意味着它无法完全拦截所有穿透请求，会有一小部分漏网之鱼打到数据库。</li>
<li><strong>无法删除元素</strong>：标准的布隆过滤器不支持删除操作。如果数据需要频繁地增删，就需要使用Counting Bloom Filter等变种，实现更复杂。</li>
<li><strong>初始化和重建成本</strong>：需要在系统启动时，将全量数据加载到布隆过滤器中，这个过程可能比较耗时。当数据发生变化时，也需要有机制来同步更新过滤器。</li>
</ul>
</li>
<li><strong>适用场景</strong>：适用于<strong>数据量巨大，但数据相对稳定，且对误判率有一定容忍度</strong>的场景。例如，防止恶意用户用随机生成的ID来攻击用户查询接口。</li>
</ul>
<h2 id="6-用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用-Redis，你会选择哪种数据结构来实现">6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现</h2>
<p>方案1：使用String</p>
<p>Redis的<code>INCR</code>命令是原子性的，可以保证在并发环境下计数的准确性。<code>EXPIRE</code>命令可以为一个key设置生存时间（TTL），完美地契合了“10分钟之内”这个时间窗口的需求。</p>
<ol>
<li><strong>定义Key</strong>：为每个用户的登录失败计数定义一个清晰的Key，例如：<code>login:fail:count:&#123;userId&#125;</code>。</li>
<li>登录失败逻辑：当用户登录失败时，执行以下操作：
<ul>
<li>对该用户的Key执行<code>INCR</code>命令，获取增长后的计数值：<code>count = redis.incr(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>。</li>
<li><strong>判断是否是第一次失败</strong>：如果<code>count</code>等于1，说明这是10分钟窗口内的第一次失败。此时，必须为这个Key设置过期时间：<code>redis.expire(&quot;login:fail:count:&#123;userId&#125;&quot;, 600)</code> (600秒 = 10分钟)。</li>
<li><strong>检查是否达到阈值</strong>：判断<code>count</code>是否大于等于3。如果是，则触发锁定用户的逻辑（例如，在数据库中更新用户状态，或在另一个Redis Key中设置一个锁定标记）。</li>
</ul>
</li>
<li><strong>登录成功逻辑</strong>：当用户登录成功时，应该<strong>立即删除</strong>这个计数Key：<code>redis.del(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>，以清除之前的失败记录。</li>
</ol>
<p>问题：</p>
<ul>
<li>存在一个微小的<strong>竞态条件（Race Condition）</strong>：在<code>INCR</code>和<code>EXPIRE</code>两个命令之间，如果服务器恰好宕机或重启，可能会导致一个计数Key被创建但<strong>没有设置过期时间</strong>，从而变成一个永久的计数器。虽然概率极低，但在高并发系统中仍需考虑。</li>
<li><strong>解决方案</strong>：可以使用<strong>Lua脚本</strong>将<code>INCR</code>和<code>EXPIRE</code>两个操作打包成一个原子操作，或者使用一条Redis命令完成</li>
</ul>
<p>方案2：<strong>灵活精确 - List 作为失败记录队列</strong></p>
<p>Redis的<code>List</code>是一个双向链表，可以作为队列使用。通过<code>LPUSH</code>在队头插入元素，<code>LTRIM</code>修剪队列长度，可以非常高效地维护一个固定大小的事件窗口。</p>
<ol>
<li><strong>定义Key</strong>：<code>login:fail:log:&#123;userId&#125;</code>。</li>
<li>登录失败逻辑：
<ul>
<li>获取当前时间戳（秒或毫秒），并将其作为元素<code>LPUSH</code>到List的头部：<code>redis.lpush(&quot;login:fail:log:&#123;userId&#125;&quot;, System.currentTimeMillis())</code>。</li>
<li><strong>检查当前失败次数</strong>：获取List的长度<code>llen</code>。</li>
<li>如果<code>llen</code>大于等于3，说明已经发生了至少3次失败。此时，获取List中<strong>第3个元素</strong>（即最早的那次失败记录，索引为2）：<code>third_attempt_time = redis.lindex(&quot;login:fail:log:&#123;userId&#125;&quot;, 2)</code>。</li>
<li><strong>判断时间窗口</strong>：计算当前时间与<code>third_attempt_time</code>的时间差。如果差值小于10分钟，则说明在10分钟内发生了3次失败，触发锁定逻辑。</li>
</ul>
</li>
<li><strong>队列维护</strong>：为了防止List无限增长，可以在每次<code>LPUSH</code>后，使用<code>LTRIM</code>命令只保留最近的3条记录：<code>redis.ltrim(&quot;login:fail:log:&#123;userId&#125;&quot;, 0, 2)</code>。同时，为整个Key设置一个比10分钟稍长的过期时间，如11分钟，用于自动清理冷数据。</li>
<li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li>
</ol>
<ul>
<li>实现了精确的时间窗口判断。</li>
<li>内存占用非常小，因为每个用户的Key最多只存储3个时间戳。</li>
</ul>
<p><strong>方案三：功能强大 - ZSET (Sorted Set) 实现滑动时间窗口</strong></p>
<p>Redis的<code>ZSET</code>是一个有序集合，每个成员都关联一个<code>score</code>。我们可以用<code>score</code>来存储事件发生的时间戳，利用<code>ZSET</code>按分数范围查询和删除的特性，完美地实现<strong>滑动时间窗口</strong>。</p>
<ol>
<li><strong>定义Key</strong>：<code>login:fail:zset:&#123;userId&#125;</code>。</li>
<li>登录失败逻辑：
<ul>
<li>获取当前时间戳<code>now</code>。</li>
<li>为了防止成员重复，可以给每个成员一个唯一的值，例如<code>now + &quot;:&quot; + Math.random()</code>。</li>
<li>将新的失败记录添加到ZSET中，<code>score</code>和<code>member</code>都使用时间戳（或<code>score</code>是时间戳，<code>member</code>是唯一ID）：<code>redis.zadd(&quot;login:fail:zset:&#123;userId&#125;&quot;, now, now)</code>。</li>
<li><strong>清理过期记录</strong>：移除所有10分钟之前的记录，这是一个非常关键的步骤，保证了窗口的滑动：<code>redis.zremrangebyscore(&quot;login:fail:zset:&#123;userId&#125;&quot;, 0, now - 600000)</code> (假设<code>now</code>是毫秒)。</li>
<li><strong>统计窗口内次数</strong>：获取当前ZSET中的成员数量：<code>count = redis.zcard(&quot;login:fail:zset:&#123;userId&#125;&quot;)</code>。</li>
<li><strong>检查阈值</strong>：如果<code>count</code>大于等于3，触发锁定逻辑。</li>
</ul>
</li>
<li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li>
</ol>
<h2 id="7-Redis持久化">7.Redis持久化</h2>
<p>RDB 是“快照”模式，AOF 是“指令日志”模式，并理解了它们都是为了解决 Redis 宕机后的数据恢复问题。</p>
<p>你提到了 RDB 文件小、恢复快，但可能丢失数据；AOF 文件大、恢复慢，但数据更完整。</p>
<p>这是一个非常关键的知识点。当 RDB 和 AOF 文件<strong>同时存在</strong>时，Redis <strong>会优先选择 AOF 文件</strong>来恢复数据。</p>
<ul>
<li><strong>为什么？</strong> 因为 AOF 文件通常记录的数据比 RDB 文件<strong>更完整、更新</strong>。AOF 的默认策略是每秒写一次盘，而 RDB 默认是几分钟甚至更久才生成一次快照。为了尽可能少地丢失数据，Redis 的设计者选择了优先使用数据更全的 AOF。</li>
</ul>
<p><strong>AOF 重写（AOF Rewrite）：</strong> 你提到了 AOF 文件会很大，这是一个很重要的缺点。但你没有提到解决这个问题的关键机制——<strong>AOF 重写</strong>。Redis 会在后台定期地对 AOF 文件进行重写，将多条冗余的命令（比如对一个 key 多次 <code>set</code>）合并成一条最终的命令，从而大大压缩 AOF 文件的大小。这个机制是 AOF 能够被长期使用的重要保障。</p>
<p>RDB 的触发方式： RDB 是“一段时间触发一次”，可以更具体地说明其触发方式，主要有：</p>
<ul>
<li><strong><code>save</code> 命令：</strong> 同步阻塞式保存，会阻塞主线程，生产环境禁用。</li>
<li><strong><code>bgsave</code> 命令：</strong> 异步非阻塞式保存，Redis 会 <code>fork</code> 一个子进程来执行快照，这是我们手动执行或配置自动执行的主要方式。</li>
<li><strong>配置文件自动触发：</strong> 比如 <code>save 900 1</code> (900秒内有1次写入)、<code>save 300 10</code> (300秒内有10次写入)等。</li>
</ul>
<p>“RDB-AOF 模式”，这个概念是对的，它叫<strong>混合持久化 (Mixed Persistence)</strong>。但它的工作方式可以描述得更清晰：当触发 AOF 重写时，Redis 不再简单地写入指令，而是将<strong>重写那一刻的内存数据，以 RDB 的格式写入到新的 AOF 文件的开头</strong>，然后再将重写期间产生的增量命令，以 AOF 格式追加到文件末尾。这样做的好处是，重启恢复时，可以先像 RDB 一样快速加载内存快照，然后再重放增量命令，<strong>兼顾了 RDB 的恢复速度和 AOF 的数据完整性</strong>。</p>
<h2 id="8-Redis底层数据结构">8.Redis底层数据结构</h2>
<p>ziplist:</p>
<p>它不是一个真正的列表，而是一块<strong>连续的内存区域</strong>。这块内存中，将多个数据项（entry）紧凑地排列在一起，从而极大地节省内存。每个entry包含三个部分：<code>previous_entry_length</code>（前一个节点的长度）、<code>encoding</code>（当前节点内容的编码方式和长度）、<code>content</code>（实际内容）。</p>
<ul>
<li><strong>极致的内存效率</strong>：由于是连续内存，没有指针开销，内存利用率极高。</li>
<li>但是有连锁更新的问题，由于每个节点都记录了<strong>前一个节点</strong>的长度，当我们在一个<code>ziplist</code>的<strong>中间</strong>插入或删除了一个元素，如果这个元素的<strong>大小发生了变化</strong>（比如从一个小整数变成一个长字符串），就可能导致<strong>其后所有节点</strong>的<code>previous_entry_length</code>字段都需要被级联修改。</li>
</ul>
<p>listpack：</p>
<p>与<code>ziplist</code>类似，也是一块<strong>连续的内存区域</strong>，用于紧凑地存储数据项。<code>listpack</code>的每个entry<strong>不再记录前一个节点的长度</strong>。取而代之的是，它记录了<strong>当前节点的总长度</strong>（<code>encoding</code>字段中包含了长度信息）。当需要从后向前遍历时，它会先读取当前节点的<strong>前一个节点</strong>的<strong>尾部</strong>，那里记录了那个节点的总长度，然后再跳到那个节点的起始位置。</p>
<p>依然是连续内存，内存利用率很高，但解决了连锁更新的问题。成为小数据量<code>Hash</code>和<code>Zset</code>的底层实现。</p>
<p>skiplist:</p>
<p><code>Zset</code>（有序集合）需要一种既能高效查找又能高效增删的数据结构。平衡树（如红黑树）实现复杂，而<code>skiplist</code>是一种概率性的、实现相对简单且性能媲美平衡树的数据结构。</p>
<p>从最高层的链表开始，向右查找，直到找到一个大于等于目标值的节点的前驱。然后从这个前驱节点<strong>下降一层</strong>，继续向右查找。重复此过程，直到到达最底层的链表，最终找到目标元素。</p>
<p>底层是链表，可以方便地进行范围遍历。增删改查效率都是O(log N)。</p>
<h1>MQ</h1>
<h2 id="1-消息队列（MQ）消息积压处理">1.<strong>消息队列（MQ）消息积压处理</strong></h2>
<p>当被问及线上Topic消息积压如何处理时，你的第一反应是“清空队列，然后恢复”，这在线上环境中是绝对禁止的操作。在引导下，你提到了扩容消费者。</p>
<p>方案1 <strong>紧急扩容消费者并监控下游依赖</strong></p>
<ol>
<li><strong>监控分析</strong>：在扩容前，必须先快速查看消费者应用的CPU、内存、GC情况，以及其下游依赖（如数据库、外部API）的负载情况。<strong>确认瓶颈在于消费者本身，而不是下游</strong>。</li>
<li><strong>水平扩容</strong>：如果瓶颈在消费者，立即增加消费者实例数量。在Kubernetes等云原生环境中，可以通过调整Deployment的replica数量快速实现。</li>
<li><strong>注意Partition数量</strong>：确保消费者实例数<strong>不超过</strong>Topic的Partition数量，因为多余的消费者将处于空闲状态。</li>
</ol>
<p>方案2 <strong>消息转储与异步回补</strong></p>
<ol>
<li><strong>编写转储程序</strong>：快速开发一个简单的程序，它的唯一作用就是消费积压Topic中的消息，然后原封不动地存储到另一个临时Topic或一个临时存储（如文件、数据库）中。</li>
<li><strong>启动转储</strong>：启动该程序，快速将积压消息“搬空”。</li>
<li><strong>修复与回补</strong>：在修复了原始消费者的Bug或性能问题后，再编写一个回补程序，以一个受控的速率，从临时Topic或存储中读取消息，重新发送回原始Topic进行处理。</li>
</ol>
<p>以空间换时间，快速恢复线上新消息的处理能力，为修复问题和处理积压数据赢得时间。</p>
<p>方案3 <strong>优化消费逻辑并临时提升处理能力</strong></p>
<ol>
<li>代码审查：快速排查消费逻辑，寻找性能瓶颈。常见的优化点包括：
<ul>
<li>将单条处理改为<strong>批量处理</strong>。</li>
<li>将同步调用外部API改为<strong>异步并行</strong>调用。</li>
<li>优化SQL查询，减少不必要的数据库交互。</li>
</ul>
</li>
<li><strong>紧急上线</strong>：快速修复并上线优化后的代码。</li>
</ol>
<p>比如说：</p>
<p><strong>你提到扩容消费者来解决积压。假设现在是双十一零点，流量洪峰导致了严重积压，而下游的数据库集群负载也已经很高了。此时你作为负责人，应该如何决策？直接扩容消费者吗？</strong></p>
<p>面试官，这是一个非常经典的**‘雪崩前兆’<strong>场景，决策的核心是</strong>‘止损和降级’**，而不是盲目地增加压力。我的决策流程会是这样的</p>
<ol>
<li><strong>立即止损，保护核心系统</strong>，绝对不能直接扩容消费者！ 因为监控显示下游数据库已经高负载，扩容消费者只会变成压垮数据库的最后一根稻草，导致核心系统崩溃，造成更大的故障。 <em>立即对消费者进行限流甚至暂停</em>*。我会立即调整消费者的消费速率，甚至在极端情况下，通过配置中心或运维指令，**暂停非核心业务的消费，优先保住数据库的稳定。</li>
<li><strong>业务降级，保障核心链路</strong> * 我会立即与产品和业务方沟通，启动<strong>业务降级预案</strong>。例如： * <strong>关闭非核心功能</strong>：暂时关闭‘实时用户积分更新’、‘推荐商品刷新’等非核心功能的消费，将MQ资源和数据库资源全部让给<strong>核心交易链路</strong>（如下单、支付）。 * <strong>异步转同步</strong>：对于某些可以接受延迟的业务，可以暂时将消息积-压在MQ中，等高峰期过后，系统负载降低了再慢慢处理。</li>
<li><strong>流量削峰与后续处理</strong> * <strong>利用MQ的积压能力</strong>：此时，MQ本身就扮演了一个<strong>天然的流量削峰器</strong>的角色。大量的请求被积压在队列中，而不是直接冲击后端系统，这正是我们使用MQ的一个重要原因。 * <strong>高峰后恢复</strong>：等到流量洪峰过去，数据库负载下降后，我们再<strong>逐步、分批地</strong>恢复被暂停的消费者，并可以适当地<strong>增加消费者实例</strong>，以一个受控的速率，慢慢地将积压的消息消费完毕。</li>
<li><strong>复盘与改进</strong> * 事后，我们会进行深入复盘。分析是数据库容量预估不足，还是SQL存在性能问题，或者是消费者逻辑有待优化。并根据分析结果，进行数据库扩容、SQL优化、或引入更精细化的流量控制策略，为下一次大促做好准备。</li>
</ol>
<p>我的核心决策原则是：<strong>牺牲非核心业务的实时性，来换取核心系统的稳定性和可用性。</strong></p>
<h2 id="2-消费者组的对应">2.消费者组的对应</h2>
<p>你刚刚说的就是一个消费者端，然后去对应一个相当于一个partition，然后为什么要一一对应呢？</p>
<p><strong>核心原因：保证分区内的消息顺序性（Message Ordering Guarantee）</strong></p>
<p>‘一个Partition在同一个消费者组内，同一时间只能被一个Consumer消费</p>
<ul>
<li><strong>理论依据</strong>：Kafka只在<strong>单个Partition内部</strong>保证消息的有序性。也就是说，生产者以1, 2, 3的顺序发送到同一个Partition的消息，消费者也必须以1, 2, 3的顺序来消费它们。</li>
<li><strong>机制实现</strong>：为了实现这个保证，Kafka必须规定，一个Partition在任意时刻，只能被一个消费者实例“锁定”并消费。<strong>如果允许多个消费者同时消费同一个Partition，那么消息的消费顺序将无法得到保证</strong>，因为无法协调哪个消费者先处理哪条消息，这将彻底破坏Kafka的顺序性承诺。</li>
</ul>
<p><strong>实现高并发：以Partition为并行处理的最小单元</strong></p>
<ul>
<li><strong>理论依据</strong>：虽然单个Partition是顺序处理的，但Kafka通过<strong>将一个Topic划分为多个Partition</strong>来实F现整体的高并发。</li>
<li><strong>机制实现</strong>：整个Topic的吞吐量等于所有Partition吞吐量的总和。我们可以通过增加Partition的数量，来水平扩展Topic的处理能力。</li>
<li><strong>消费者协同</strong>：消费者组（Consumer Group）内的多个消费者实例会通过**Rebalance（再均衡）*<em>机制，自动协调分配它们各自负责消费的Partition。例如，一个有10个Partition的Topic，如果消费者组有10个消费者，理想情况下就是每个消费者负责一个Partition，此时*<em>并行度达到最大</em></em>。</li>
</ul>
<h2 id="3-消息不丢失-消息幂等">3.消息不丢失&amp;&amp;消息幂等</h2>
<p>不丢失：</p>
<p><strong>生产者端  -&gt; Broker：如何确保消息成功发出并被Broker接收？</strong></p>
<p><strong>同步发送 + 有限次重试</strong></p>
<ul>
<li>我们会采用**同步发送（Sync Send）**的方式。这意味着，生产者线程在发送一条消息后，会阻塞等待，直到收到Broker返回的成功确认（ACK）。如果等待超时或收到错误响应，就证明发送失败</li>
<li>一旦发送失败，我们会配置一个<strong>有限次的重试机制</strong>（例如，重试3次，每次间隔1秒）。通过这种‘<strong>确认+重试</strong>’的闭环，可以极大地提高消息发送到Broker的成功率。</li>
<li>RocketMQ的同步发送<code>send()</code>方法本身就是阻塞等待Broker确认的。对于可靠性要求极高的场景，我们还会配合Broker端的<strong>同步刷盘</strong>策略，确保消息在持久化到磁盘后才返回ACK。</li>
<li>对于需要<strong>本地事务与消息发送保持原子性</strong>的场景（例如，下单成功后发送扣减库存消息），我们会使用RocketMQ独有的<strong>事务消息</strong>。它通过两阶段提交（发送Half消息 -&gt; 执行本地事务 -&gt; 提交/回滚Half消息）的机制，从根本上保证了本地操作成功，消息就一定能成功发送。</li>
</ul>
<p>Broker端<strong>如何确保持久化，防止自身宕机导致消息丢失？</strong></p>
<p><strong>持久化刷盘 + 多副本冗余</strong></p>
<ul>
<li><strong>同步刷盘（Sync Flush）</strong>：这是最可靠的方式。Broker接收到消息后，必须将其写入磁盘文件，才向生产者返回ACK。即使Broker进程或服务器瞬间宕机，消息也不会丢失。</li>
<li><strong>异步刷盘（Async Flush）</strong>：Broker将消息写入操作系统的Page Cache后，就立即返回ACK，由操作系统异步地将数据刷到磁盘。性能最高，但如果服务器在刷盘前掉电，Page Cache中的数据会丢失。</li>
<li>我们会为每个Topic或Partition配置<strong>多个副本（通常是3个）</strong>，分布在不同的物理机架上。消息会同时写入主副本（Leader）和备用副本（Follower）。当主副本宕机时，系统可以从备用副本中选举出新的主副本，继续提供服务，保证了数据的高可用和冗余。</li>
<li>RocketMQ也支持Master-Slave的多副本架构，以及基于Raft协议的Dledger模式，都能实现类似的高可用保障。</li>
</ul>
<p><strong>Broker -&gt; 消费者端 (Consumer)：如何确保消息被消费者成功处理？</strong></p>
<p><strong>手动确认（ACK）/提交消费位点（Offset）</strong></p>
<ol>
<li>消费者从Broker拉取一批消息。</li>
<li><strong>先执行我们自己的业务逻辑</strong>（例如，更新数据库、调用外部API等）。</li>
<li><strong>当且仅当业务逻辑全部成功执行完毕后</strong>，我们才向Broker发送ACK，或者提交这批消息的Offset。</li>
</ol>
<p>这样，如果消费者在处理业务的途中宕机，由于没有提交Offset，它重启后会从上一次已提交的Offset处重新拉取消息，保证了宕机期间正在处理的消息不会丢失。</p>
<p>在RocketMQ中，消费者的监听器<code>MessageListener</code>会返回一个消费状态。我们只有在业务处理成功后，才返回<code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code>，RocketMQ才会认为消息消费成功并更新Offset。如果返回<code>RECONSUME_LATER</code>或抛出异常，消息会在稍后被重试。</p>
<p>幂等：</p>
<p><strong>对于同一个业务操作，无论执行多少次，其产生的结果和影响都和执行一次是相同的</strong>。我们的实现方案是基于唯一ID + 状态判断</p>
<ol>
<li><strong>为消息赋予全局唯一ID</strong>： * “我们要求生产者在发送每一条具有业务含义的消息时，都在消息体或Header中附带一个<strong>全局唯一的业务ID</strong>。例如，支付成功的消息，就用‘支付流水号’；创建订单的消息，就用‘订单号’。”</li>
<li><strong>消费者端实现幂等判断</strong>： * “消费者在处理消息时，不会立即执行业务逻辑，而是会先根据这个<strong>唯一ID</strong>，去查询一个<strong>持久化的存储</strong>（如Redis或数据库），来判断这个操作是否已经被执行过。</li>
<li><strong>方案一：数据库唯一索引</strong>：对于插入操作，我们可以直接利用数据库的**唯一键（Unique Key）**约束。例如，在处理‘用户注册’消息时，将用户名或手机号作为唯一索引。如果消息重复，尝试插入时会直接触发<code>DuplicateKeyException</code>，我们捕获这个异常就知道是重复操作，直接ACK消息即可。</li>
<li>方案二：Redis <code>SETNX</code>**：对于一些通用的操作，我们可以利用Redis的<code>SETNX</code>命令。将消息的唯一ID作为Key，尝试写入Redis。如果写入成功（返回1），说明是第一次处理，就执行业务逻辑，并在成功后保留这个Key（可以设置一个过期时间）。如果写入失败（返回0），说明这个ID已经被处理过，直接跳过并ACK。</li>
<li>方案三：状态机与版本号：对于更新操作，我们可以在业务表中引入状态字段<strong>或</strong>版本号。例如，处理订单状态流转的消息。消费者会先查询订单的当前状态，只有当订单状态符合前置条件时（例如，只有‘待支付’状态的订单才能被更新为‘已支付’），才执行更新。如果状态不匹配，说明已经被其他操作处理过，直接忽略。</li>
</ol>
<h2 id="4-RocketMQ半事务消息">4.RocketMQ半事务消息</h2>
<ul>
<li>
<p><strong>第一阶段 (发送半消息):</strong> <strong>生产者（订单服务）**先发送一条**半消息（Half Message）**到 Broker。这条消息对消费者是**不可见</strong>的。</p>
</li>
<li>
<p><strong>执行本地事务：</strong> 生产者发送半消息成功后，<strong>立即开始执行自己的本地事务</strong>（比如创建订单并写入数据库）。</p>
</li>
<li>
<p>第二阶段 (提交/回滚):</p>
<ul>
<li>如果本地事务<strong>执行成功</strong>，生产者就向 Broker 发送一个 <strong>Commit</strong> 命令，Broker 收到后，才将这条半消息<strong>对消费者可见</strong>。</li>
<li>如果本地事务<strong>执行失败</strong>，生产者就向 Broker 发送一个 <strong>Rollback</strong> 命令，Broker 就会<strong>删除</strong>这条半消息。</li>
</ul>
</li>
<li>
<p><strong>回查机制：</strong> 如果生产者在执行完本地事务后宕机，没能发送 Commit/Rollback，Broker 会<strong>定期地回调</strong>生产者的一个<strong>回查接口</strong>，询问：“我这里有一条半消息，你对应的本地事务到底成功了没有？” 生产者根据本地事务的状态，告诉 Broker 应该 Commit 还是 Rollback。</p>
</li>
</ul>
<h1>分布式</h1>
<h2 id="1-分布式事务设计">1.分布式事务设计</h2>
<p><strong>TCC、Saga、本地消息表、事务消息</strong></p>
<p><strong>本地消息表</strong></p>
<p>这是一种实现“最终一致性”的常用方案，核心思想是将业务操作和发送消息这两个步骤，放在同一个本地事务里来保证原子性。</p>
<ol>
<li><strong>事务发起方</strong>：在执行核心业务逻辑时（例如：创建订单），会在同一个数据库事务中，向一张本地的“消息表”插入一条消息记录，这条记录的状态初始为“待发送”。</li>
<li><strong>事务提交</strong>：当本地事务成功提交后，订单数据和“待发送”的消息记录会同时落库。</li>
<li><strong>消息投递</strong>：我会用一个独立的、可靠的后台任务（比如使用定时任务调度框架如XXL-Job）去轮询这张消息表，把所有“待发送”状态的消息发送到消息队列（MQ）中。</li>
<li><strong>状态确认</strong>：消息成功投递到MQ后，后台任务会更新消息表中的记录状态为“已发送”或直接删除。如果投递失败，它会进行重试。</li>
<li><strong>事务消费方</strong>：下游服务消费MQ中的消息，并执行相应的业务逻辑。为了防止重复消费，消费方必须保证接口的幂等性。</li>
</ol>
<p>消息的发送不是实时的，存在一定的延迟。需要额外维护一个后台任务。</p>
<p>事务消息</p>
<ol>
<li><strong>第一阶段 (Prepare Message)</strong>：生产者先向MQ Server发送一条“半消息”或“预备消息”。这条消息对消费者是不可见的。</li>
<li><strong>第二阶段 (执行本地事务)</strong>：发送“半消息”成功后，生产者开始执行本地的数据库事务。</li>
<li>第三阶段 (Commit/Rollback)：
<ul>
<li>如果本地事务<strong>成功</strong>，生产者会向MQ Server发送一个<code>Commit</code>指令，MQ Server收到后会将之前的“半消息”标记为可投递，消费者此时才能消费到。</li>
<li>如果本地事务<strong>失败</strong>，生产者会发送一个<code>Rollback</code>指令，MQ Server会删除这条“半消息”。</li>
</ul>
</li>
<li><strong>超时回调检查</strong>：如果生产者在执行完本地事务后宕机，没有发送<code>Commit</code>或<code>Rollback</code>指令，MQ Server会在超时后，主动回调生产者应用提供的一个接口，来查询该事务的最终状态，并根据查询结果来决定是<code>Commit</code>还是<code>Rollback</code>。</li>
</ol>
<p>需要消息中间件本身支持事务消息这个特性</p>
<p>TCC (Try-Confirm-Cancel)</p>
<ol>
<li><strong>Try阶段</strong>：这是准备阶段。对各个服务的资源进行检查和预留。比如，库存服务<code>Try</code>阶段就是冻结指定数量的库存，而不是直接扣减。</li>
<li><strong>Confirm阶段</strong>：如果所有服务的<code>Try</code>阶段都成功，协调器就会调用所有服务的<code>Confirm</code>方法，执行真正的业务逻辑。比如，库存服务<code>Confirm</code>阶段就是将之前冻结的库存进行扣减。</li>
<li><strong>Cancel阶段</strong>：如果任何一个服务的<code>Try</code>阶段失败，协调器会调用所有已经执行过<code>Try</code>成功的服务的<code>Cancel</code>方法，释放预留的资源。比如，库存服务<code>Cancel</code>阶段就是解冻之前冻结的库存。</li>
</ol>
<ul>
<li><strong>优点</strong>：性能较高，因为它不像2PC那样在整个事务过程中都持有锁。能够实现数据的强一致性。</li>
<li><strong>缺点</strong>：对业务代码的侵入性非常强，开发成本高，每个业务操作都需要实现<code>Try-Confirm-Cancel</code>三个接口，并且要保证它们的幂等性。</li>
</ul>
<p>Saga</p>
<p>Saga是一种长事务解决方案，核心思想是将一个大的分布式事务拆分成一系列的本地事务，由Saga事务协调器来协调。如果某个步骤失败，则会调用前面已执行步骤的补偿操作。</p>
<ul>
<li>
<p>一个Saga由一系列子事务 <code>T1, T2, ..., Tn</code> 组成。</p>
</li>
<li>
<p>每个子事务 <code>Ti</code> 都有一个对应的补偿事务 <code>Ci</code>。</p>
</li>
<li>
<p>执行顺序是 <code>T1, T2, ..., Tn</code>。如果其中任意一个 <code>Ti</code> 失败，则会按逆序执行补偿事务 <code>C(i-1), ..., C2, C1</code>。</p>
</li>
<li>
<p><strong>优点</strong>：适用于长流程、业务复杂的场景，一阶段提交，没有锁，系统吞吐量高。</p>
</li>
<li>
<p><strong>缺点</strong>：不保证事务的隔离性，因为在补偿发生前，其他事务可能已经看到了<code>T1</code>,<code>T2</code>等操作产生的不一致的中间状态。</p>
</li>
</ul>
<h1>设计模式</h1>
<h2 id="1-当被问及如何在多个接口中统一管理以避免代码重复时">1.当被问及如何在多个接口中统一管理以避免代码重复时</h2>
<p>你的初步想法是提取一个公共方法。面试官进一步引导你思考过滤器和拦截器。</p>
<p>方案1：<strong>使用Spring MVC的<code>HandlerInterceptor</code>（拦截器）</strong></p>
<p><code>HandlerInterceptor</code>是Spring MVC提供的AOP实现，专门用于在Controller方法执行前后进行预处理和后处理。它与请求生命周期紧密耦合，是处理用户认证、日志记录、上下文设置等横切关注点的标准方式。</p>
<ol>
<li>创建一个类实现<code>HandlerInterceptor</code>接口。</li>
<li>在<code>preHandle</code>方法中，从请求（如Header）中获取Token，解析出用户信息，然后调用工具类的<code>set()</code>方法将用户信息存入<code>ThreadLocal</code>。</li>
<li>在<code>afterCompletion</code>方法中，无论Controller方法执行成功还是失败，都调用工具类的<code>remove()</code>方法清理<code>ThreadLocal</code>，通常放在<code>finally</code>块中以确保执行。</li>
<li>创建一个配置类实现<code>WebMvcConfigurer</code>，重写<code>addInterceptors</code>方法，将你的拦截器注册到Spring容器中，并配置其拦截路径（如<code>/api/**</code>）。</li>
</ol>
<p>方案2：<strong>使用Servlet的<code>Filter</code>（过滤器）</strong></p>
<ol>
<li>创建一个类实现<code>javax.servlet.Filter</code>接口。</li>
<li>在<code>doFilter</code>方法中，在调用<code>chain.doFilter(request, response)</code>之前，执行<code>ThreadLocal</code>的<code>set()</code>操作。</li>
<li>使用<code>try...finally</code>结构，在<code>finally</code>块中执行<code>ThreadLocal</code>的<code>remove()</code>操作，确保无论后续处理是否异常，都能清理资源。</li>
<li>使用<code>@Component</code>和<code>@Order</code>注解（或通过<code>FilterRegistrationBean</code>）将Filter注册为Spring Bean。</li>
</ol>
<p>与<code>Interceptor</code>类似，实现了解耦和统一管理。由于作用范围更广，可以拦截静态资源等非Spring MVC处理的请求。</p>
<p>方案3：<strong>使用自定义AOP切面（<code>@Aspect</code>）</strong></p>
<ol>
<li>创建一个类，并使用<code>@Aspect</code>和<code>@Component</code>注解。</li>
<li>定义一个切点（Pointcut），例如<code>@Pointcut(&quot;within(@org.springframework.web.bind.annotation.RestController *)&quot;)</code>，用于匹配所有RestController类中的方法。</li>
<li>创建一个<code>@Around</code>环绕通知。在通知方法的<code>try</code>块中，执行<code>ThreadLocal</code>的<code>set()</code>操作，然后调用<code>proceedingJoinPoint.proceed()</code>执行目标方法。在<code>finally</code>块中，执行<code>remove()</code>操作。</li>
</ol>
<p>功能上与前两者类似，但提供了最大的灵活性，可以切入到Service层甚至任意Bean的方法。<code>@Around</code>通知需要手动调用<code>proceed()</code>，如果忘记调用，目标方法将不会被执行。</p>
<h2 id="2-策略方法怎么去解决具体调用哪一个策略">2.策略方法怎么去解决具体调用哪一个策略</h2>
<ul>
<li>为了避免在业务代码中使用大量的<code>if-else</code>或<code>switch</code>来选择策略，我们创建了一个<strong>策略工厂（Strategy Factory）</strong>。</li>
</ul>
<ol>
<li>在项目启动时，Spring容器会扫描并加载所有<code>CouponStrategy</code>的实现类。</li>
<li>我们创建一个<code>CouponStrategyFactory</code>类，它在构造时注入一个<code>Map&lt;String, CouponStrategy&gt;</code>。Spring会自动将所有策略实现类注入到这个Map中，其中Key是Bean的名称（例如<code>&quot;fullDiscountStrategy&quot;</code>），Value是Bean实例。</li>
<li>我们约定优惠券类型（例如<code>&quot;FULL_DISCOUNT&quot;</code>, <code>&quot;PERCENTAGE_DISCOUNT&quot;</code>）与Bean名称有映射关系。</li>
<li>工厂类提供一个<code>getStrategy(String couponType)</code>方法。当业务代码需要使用某个策略时，它只需要传入优惠券类型字符串，工厂就会从Map中返回对应的策略对象。</li>
<li>我们完全消除了业务代码中的<code>if-else</code>判断。当未来需要增加一种新的优惠券时，我们只需要新增一个策略实现类，而不需要修改任何现有的业务逻辑代码，这完全符合<strong>开闭原则</strong>，使得系</li>
<li>统非常易于扩展和维护。”</li>
</ol>
<h2 id="3-100个有序文件，如何拼接保证整体有序？">3.<strong>100个有序文件，如何拼接保证整体有序？</strong></h2>
<p>我们有100个已经内部有序的数据源（文件），需要将它们合并成一个单一的、全局有序的输出。这正是<strong>归并排序</strong>中“归并（Merge）”这一步的经典应用。由于文件可能很大，无法一次性全部读入内存，所以这是一个<strong>外部排序</strong>问题。</p>
<p>我们可以使用最小堆来解决</p>
<ul>
<li>创建一个大小为100的<strong>最小堆</strong>。</li>
<li>为100个文件，每个文件都打开一个文件读取流（Reader）。</li>
<li>从<strong>每个文件</strong>中读取<strong>第一个数字</strong>，并将这个数字连同它<strong>所属的文件源信息</strong>（例如，文件索引）一起，封装成一个对象（如<code>Node(value, fileIndex)</code>），放入最小堆中。此时，堆中有100个元素。</li>
<li><strong>循环执行</strong>以下操作，直到堆为空： a. <strong>取出最小元素</strong>：从最小堆的堆顶取出一个<code>Node</code>。这个<code>Node</code>的<code>value</code>就是<strong>当前全局最小的数字</strong>。 b. <strong>写入输出文件</strong>：将这个<code>value</code>写入到最终的输出文件中。 c. <strong>补充新元素</strong>：根据取出的<code>Node</code>中的<code>fileIndex</code>，我们知道这个数字来自哪个文件。我们立即从那个文件中<strong>读取下一个数字</strong>。 d. <strong>处理文件结束</strong>：如果那个文件已经读完，则什么也不做。如果还能读到新数字，就将这个新数字和它的<code>fileIndex</code>再次封装成一个新的<code>Node</code>，<strong>插入到最小堆中</strong>。</li>
<li>当最小堆为空时，意味着所有文件都已被读取完毕，输出文件也就包含了所有数字，并且是全局有序的。</li>
</ul>
<p>这个问题本质上是一个典型的<strong>多路归并排序</strong>问题，特别是在处理无法完全加载到内存的大文件时，属于<strong>外部排序</strong>的范畴</p>
<h2 id="4-设计一个高并发的系统">4.设计一个高并发的系统</h2>
<p>面试官您好，设计一个高并发秒杀系统，核心挑战在于如何在瞬时巨大流量下，保证<strong>库存扣减的绝对正确性</strong>和<strong>系统的整体高可用</strong>。我的设计方案将围绕**“层层过滤、异步处理、最终一致”**的核心思想展开，严格遵循题目要求的几个方面进行阐述。</p>
<p>整体架构：</p>
<p>首先我会将整个秒杀流程进行<strong>动静分离</strong>和<strong>垂直分层</strong>，构建一个清晰的数据流。</p>
<ul>
<li><strong>前端层</strong>：商品详情页静态化，通过CDN分发，降低服务器压力。秒杀按钮在倒计时结束前置灰，并通过定时器从服务端获取最新时间，防止客户端时间不准导致提前请求。</li>
<li>接入层：
<ul>
<li><strong>Nginx/网关</strong>：负责反向代理、初步限流、过滤恶意请求。</li>
<li><strong>秒杀服务（独立部署）</strong>：这是核心业务逻辑所在，与普通商品服务物理隔离，避免秒杀流量冲垮主站。</li>
</ul>
</li>
<li>数据处理流：
<ol>
<li>用户请求首先到达Nginx/网管。</li>
<li>通过限流后，请求进入秒杀服务。</li>
<li>秒杀服务在Redis中完成<strong>资格校验</strong>和<strong>库存预扣减</strong>。</li>
<li>预扣减成功后，立即向用户返回“排队中”或“抢购成功”的提示，并将订单信息<strong>异步发送到RocketMQ</strong>。</li>
<li><strong>订单服务</strong>作为消费者，从MQ拉取消息，进行数据库层面的<strong>订单创建</strong>和<strong>库存真实扣减</strong>。</li>
<li>后续的支付、履约流程由订单服务驱动。</li>
</ol>
</li>
</ul>
<p>数据模型：</p>
<p>在Mysql中会有一个<code>promo_stock</code> (秒杀库存表)，<code>promo_id</code> (秒杀活动ID, 索引)，<code>item_id</code> (商品ID, 索引)，<code>version</code> (int, <strong>乐观锁版本号</strong>)</p>
<p>Redis换成设计：</p>
<ul>
<li>
<p><code>promo:stock:&#123;promo_id&#125;</code> (String): 存储秒杀活动的<strong>总库存数量</strong>。用于快速判断库存是否售罄。</p>
</li>
<li>
<p><code>promo:soldout:&#123;promo_id&#125;</code> (String/Bitmap): 一个<strong>售罄标记</strong>。一旦库存为0，设置此标记，后续请求可以直接在接入层拦截，无需再访问Redis。</p>
</li>
<li>
<p><code>promo:user:history:&#123;promo_id&#125;</code> (Set/HyperLogLog): 存储已成功抢购的<code>userId</code>，用于<strong>防止用户重复下单</strong>。</p>
</li>
</ul>
<p>数据一致性：</p>
<p>在秒杀场景下，我们采用‘<strong>缓存预扣减，数据库异步更新</strong>’的策略，追求的是<strong>最终一致性</strong></p>
<ol>
<li><strong>库存预热</strong>：秒杀活动开始前，通过定时任务将MySQL中的库存数量加载到Redis的<code>promo:stock:&#123;promo_id&#125;</code>中。</li>
<li><strong>缓存预扣减</strong>：用户的抢购请求直接在Redis中通过<code>DECR</code>原子操作进行库存扣减。</li>
<li><strong>异步更新数据库</strong>：Redis扣减成功后，将订单信息发送到MQ。订单服务消费消息后，再对MySQL中的<code>stock_count</code>进行<code>UPDATE ... SET stock_count = stock_count - 1</code>操作。</li>
<li>数据不一致的风险与兜底：
<ul>
<li><strong>风险</strong>：如果消息丢失或订单服务消费失败，会导致Redis库存减少，而MySQL库存未变。</li>
<li><strong>兜底</strong>：我们会有一个<strong>定时对账任务</strong>，定期（如每5分钟）比对Redis中的已售数量和MySQL中的已创建订单数量，如果不一致，则进行修复或告警。</li>
</ul>
</li>
</ol>
<p>限流和短融：</p>
<p>限流是保护系统的第一道防线，必须在<strong>多层级</strong>部署</p>
<ol>
<li><strong>前端层限流</strong>：通过JS控制，用户在点击秒杀按钮后，按钮会置灰一段时间，防止用户疯狂点击，造成不必要的请求。</li>
<li>Nginx/网关层限流：
<ul>
<li><strong><code>limit_req_zone</code></strong>：基于漏桶算法，对用户的IP或UID进行<strong>请求速率限制</strong>，例如，限制单个用户每秒只能请求1次。</li>
<li><strong><code>limit_conn_zone</code></strong>：限制单个IP的最大连接数，防止恶意攻击。</li>
</ul>
</li>
<li>业务服务层限流：
<ul>
<li>使用<strong>Sentinel</strong>或<strong>Guava RateLimiter</strong>，对秒杀接口本身进行<strong>QPS限制</strong>。这个值应该根据压测结果设定，略高于系统的最大处理能力，作为最后的保险丝。</li>
</ul>
</li>
<li>熔断：
<ul>
<li>同样使用<strong>Sentinel</strong>，我们会对秒杀服务依赖的下游服务（如订单服务、用户服务）的调用进行熔断配置。</li>
<li><strong>策略</strong>：当在指定时间窗口内，对订单服务的调用<strong>错误率</strong>或<strong>平均响应时间</strong>超过阈值时，熔断器会打开。在接下来的一个时间窗口内，所有对订单服务的调用都会被<strong>直接拒绝</strong>，并快速失败（返回“系统繁忙”），避免因下游故障导致的秒杀服务线程池耗尽和雪崩。</li>
</ul>
</li>
</ol>
<p>热点和超卖的数据处理：</p>
<p>这是秒杀系统的核心，我采用了**‘Redis原子操作 + 分布式锁 + 数据库乐观锁’**的三重保障来彻底杜绝超卖。</p>
<ol>
<li>热点数据处理：
<ul>
<li><strong>库存预热</strong>：已在一致性策略中提及，将MySQL的热点库存数据提前加载到Redis中，所有读写操作都在Redis完成，避免直接冲击数据库。</li>
</ul>
</li>
<li>防超卖机制（核心流程）：
<ul>
<li>第一重防护：Redis原子操作：
<ul>
<li>在用户请求到达时，首先检查Redis中的售罄标记<code>promo:soldout:&#123;promo_id&#125;</code>。如果存在，直接返回“已售罄”。</li>
<li>然后，使用<code>DECR promo:stock:&#123;promo_id&#125;</code>进行库存预扣减。这是一个<strong>原子操作</strong>，天然地避免了多线程下的并发问题。如果<code>DECR</code>后的返回值小于0，说明库存已不足，我们将库存<code>INCR</code>加回去，并返回“已售罄”。</li>
</ul>
</li>
<li>第二重防护：分布式锁（可选，用于更复杂逻辑）：
<ul>
<li>如果扣减库存的逻辑不仅仅是<code>DECR</code>，还包含了<strong>用户资格校验</strong>（如检查是否重复购买），那么“校验+扣减”这两个操作就不是原子的。</li>
<li>此时，我们会使用<strong>Redisson分布式锁 + Lua脚本</strong>。将“检查用户是否在<code>promo:user:history</code>集合中”和“<code>DECR</code>库存”这两个逻辑封装在一个<strong>Lua脚本</strong>中，然后在获取到分布式锁后，原子化地执行这个脚本。</li>
</ul>
</li>
<li>第三重防护（最终兜底）：数据库乐观锁：
<ul>
<li>订单服务在消费MQ消息，准备真实扣减MySQL库存时，会使用乐观锁。</li>
<li>SQL语句为：<code>UPDATE promo_stock SET stock_count = stock_count - 1, version = version + 1 WHERE promo_id = ? AND stock_count &gt; 0 AND version = ?</code>。</li>
<li>如果这条SQL执行后返回的影响行数为0，说明在并发情况下，库存已被其他事务修改（<code>stock_count</code>变为0或<code>version</code>不匹配）。此时，我们会认为这是一个<strong>无效的订单</strong>，进行记录并丢弃，<strong>不会创建订单</strong>。这确保了数据库层面的最终正确性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>异步队列+补偿处理：</p>
<ol>
<li>异步队列（RocketMQ）的作用：
<ul>
<li><strong>流量削峰</strong>：秒杀的瞬时流量是巨大的，但后端数据库的处理能力是有限的。MQ像一个蓄水池，将瞬时的写请求缓冲起来，让下游的订单服务可以按照自己的节奏平稳地进行消费，保护了数据库。</li>
<li><strong>业务解耦</strong>：秒杀服务只负责最核心的库存预扣减，成功后即可返回。创建订单、发送通知等非核心、耗时的操作被解耦到下游服务，大大降低了秒杀接口的响应时间。</li>
</ul>
</li>
<li>补偿机制：
<ul>
<li><strong>消息可靠性</strong>：我们会使用RocketMQ的<strong>事务消息</strong>或<strong>生产者发送确认+重试</strong>机制，确保库存预扣减成功的消息一定能被发送到MQ。</li>
<li><strong>消费失败处理</strong>：如果订单服务消费消息失败（例如，数据库暂时不可用），我们会让消息进入<strong>重试队列</strong>。</li>
<li><strong>死信队列（DLQ）</strong>：如果经过多次重试后仍然失败，消息会被投递到<strong>死信队列</strong>。我们会有一个专门的<strong>后台任务</strong>或<strong>告警系统</strong>来监控死信队列，一旦有消息进入，就立即通知开发人员进行<strong>人工介入和补偿</strong>。</li>
</ul>
</li>
</ol>
<p>压测：</p>
<ol>
<li><strong>工具</strong>：使用<strong>JMeter</strong>或<strong>nGrinder</strong>等分布式压测工具。</li>
<li><strong>压测目标</strong>：模拟秒杀开始瞬间，在极短时间内（如1秒内）发起远超系统处理能力的并发请求（例如，模拟10万用户同时抢购1000件商品）。</li>
<li>监控指标：
<ul>
<li><strong>业务指标</strong>：下单成功率、最终创建的订单数是否与库存数严格相等（<strong>验证正确性</strong>）。</li>
<li><strong>性能指标</strong>：系统的<strong>QPS/TPS</strong>、接口的<strong>平均响应时间</strong>和<strong>99%分位线</strong>。</li>
<li><strong>资源指标</strong>：压测过程中，密切监控所有组件（Nginx, Redis, 秒杀服务, 数据库）的CPU、内存、网络、磁盘I/O等资源使用率。</li>
</ul>
</li>
<li><strong>瓶颈定位</strong>：通过观察各个环节的监控指标，找出最先达到瓶颈的组件，然后针对性地进行优化（例如，升级Redis集群、优化SQL、增加秒杀服务实例等），再进行下一轮压测，如此循环，直到系统达到预期的性能目标。</li>
</ol>
<h2 id="5-模板方法的回答">5.模板方法的回答</h2>
<p>模板方法模式定义了一个操作中的<strong>算法骨架</strong>，而将一些可变的步骤延迟到子类中去实现。</p>
<p>在一个抽象的父类中，会有一个 <code>final</code> 的模板方法，它定义了整个流程的执行顺序。这个模板方法会调用一系列的抽象方法（由子类实现）和具体方法（父类实现）。</p>
<p><strong>优点是复用了算法的公共部分，并将变化的部分进行隔离</strong>。比如，<code>AbstractList</code> 中的 <code>addAll</code> 方法就是一个模板方法，它定义了批量添加的流程，而具体的 <code>add(index, element)</code> 则由子类 <code>ArrayList</code> 或 <code>LinkedList</code> 去实现。</p>
<h2 id="6-30分钟自动关闭">6.30分钟自动关闭</h2>
<ol>
<li><strong>下单时：</strong> 用户下单成功后，除了创建订单，我们还会向 RocketMQ 发送一条<strong>延时等级为 30 分钟</strong>的延时消息，消息内容包含订单号。</li>
<li><strong>消费者：</strong> 我们有一个专门的消费者来消费这些延时消息。</li>
<li><strong>30分钟后：</strong> Broker 会将这条消息投递给消费者。</li>
<li>处理逻辑：消费者收到消息后，会根据订单号去查询数据库中该订单的支付状态。
<ul>
<li>如果订单状态<strong>仍是“未支付”</strong>，则执行<strong>关单操作</strong>。</li>
<li>如果订单状态<strong>已经是“已支付”</strong>，则<strong>直接忽略</strong>这条消息。</li>
</ul>
</li>
</ol>
<h2 id="7-如何设计全局统一异常处理">7.如何设计全局统一异常处理</h2>
<p>全局统一异常处理是Spring Boot项目中用于解耦业务代码和异常处理逻辑、并向前端提供统一响应格式的重要机制。它的实现主要依赖两个核心注解：</p>
<ol>
<li>
<p><strong><code>@RestControllerAdvice</code></strong>: 我会创建一个类，并使用这个注解。它是一个组合注解，相当于<code>@ControllerAdvice</code> + <code>@ResponseBody</code>，表示这个类是一个全局的AOP切面，用于增强所有被<code>@RestController</code>注解的控制器，并会将方法的返回值序列化为JSON。</p>
</li>
<li>
<p><code>@ExceptionHandler</code>: 在这个类里面，我会定义多个方法，每个方法使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler</span><br></pre></td></tr></table></figure>
<p>注解并指定它能处理的异常类型。例如：</p>
<ul>
<li>一个方法处理自定义的业务异常，如<code>@ExceptionHandler(BusinessException.class)</code>。</li>
<li>一个方法处理参数校验异常，如<code>@ExceptionHandler(MethodArgumentNotValidException.class)</code>。</li>
<li>一个兜底的方法处理所有其他未被捕获的异常，如<code>@ExceptionHandler(Exception.class)</code>。</li>
</ul>
</li>
</ol>
<p>在这些方法内部，我会构建一个统一的响应对象（例如<code>ApiResult</code>），包含状态码、错误信息等，然后通过<code>ResponseEntity</code>包装后返回。这样做的好处是，业务代码中只需要专注于业务逻辑，当发生错误时直接<code>throw new BusinessException(...)</code>即可，异常的捕获和格式化响应都由这个全局处理器统一完成，代码非常清晰和易于维护。</p>
<h1>网络编程</h1>
<p>1.<strong>Netty 如何封装 NIO</strong></p>
<p>Netty 是对Java原生NIO的一个<strong>高度封装和增强</strong>的框架，它解决了原生NIO在使用上非常复杂、功能有限、且容易出错的痛点。</p>
<ul>
<li>封装Selector与事件循环：
<ul>
<li>原生NIO需要我们手动编写一个死循环，不断地调用<code>selector.select()</code>，然后遍历<code>selectedKeys</code>，再根据<code>key</code>的类型（<code>OP_ACCEPT</code>, <code>OP_READ</code>等）进行<code>if-else</code>判断，代码繁琐且容易出错。</li>
<li><strong>Netty</strong>将其封装成了**<code>EventLoop</code>**。每个<code>EventLoop</code>内部都包含一个<code>Selector</code>和一个线程。这个<code>EventLoop</code>线程会自动地、高效地执行事件轮询和分发，我们开发者完全不需要关心底层的<code>Selector</code>操作。</li>
</ul>
</li>
<li>封装Channel与Buffer：
<ul>
<li>原生NIO的<code>Buffer</code>使用起来非常反直觉，需要我们手动<code>flip()</code>、<code>clear()</code>、<code>rewind()</code>，很容易出错。</li>
<li><strong>Netty</strong>提供了自己的<code>ByteBuf</code>，它通过<strong>读写指针分离</strong>的设计，彻底告别了<code>flip()</code>操作，使用起来非常方便。它还提供了<strong>零拷贝（Zero-Copy）</strong>、<strong>池化（Pooling）**和**堆外内存</strong>等高级功能，性能远超原生<code>Buffer</code>。</li>
<li>Netty的<code>Channel</code>接口也比原生的更统一、更易用。</li>
</ul>
</li>
<li>封装责任链与业务逻辑解耦：
<ul>
<li>原生NIO的所有I/O处理逻辑都混杂在一起。</li>
<li><strong>Netty</strong>引入了**<code>ChannelPipeline</code><strong>和</strong><code>ChannelHandler</code><strong>的设计，这是一个经典的</strong>责任链模式**。我们可以将网络处理逻辑（如解码、编码、业务处理）拆分成一个个独立的<code>Handler</code>，然后像“搭积木”一样将它们组织在<code>Pipeline</code>中。这使得代码结构清晰、高度解耦、易于扩展和复用。</li>
</ul>
</li>
</ul>
<p>多<strong>Reactor 模型</strong></p>
<p>Netty的线程模型正是经典<strong>多Reactor模型</strong>的实现，通常是<strong>主从Reactor模式（Master-Slave Reactor</strong></p>
<ul>
<li>主Reactor（Boss Group）：
<ul>
<li>通常只配置<strong>一个线程</strong>（<code>EventLoop</code>）。</li>
<li>它的<strong>唯一职责</strong>就是监听服务端的<strong>连接请求（<code>OP_ACCEPT</code>事件）</strong>。</li>
<li>当接收到一个新的客户端连接后，主Reactor会<strong>将这个新建立的<code>SocketChannel</code>注册到从Reactor</strong>上，然后继续回去监听新的连接。它<strong>不处理任何I/O读写</strong>。</li>
</ul>
</li>
<li>从Reactor（Worker Group）：
<ul>
<li>通常配置<strong>多个线程</strong>（<code>EventLoop</code>），数量一般是CPU核心数的1倍或2倍。</li>
<li>它的职责是处理所有<strong>已连接<code>Channel</code>的I/O读写事件（<code>OP_READ</code>, <code>OP_WRITE</code>）</strong>。</li>
<li>一个<code>Channel</code>的整个生命周期内的所有I/O操作，都会被绑定在<strong>同一个</strong>从Reactor线程上执行，这避免了多线程并发处理同一个连接时需要加锁的问题。</li>
</ul>
</li>
</ul>
<h1>计网</h1>
<h2 id="1-对比一下-HTTP-1-0-HTTP-1-1-和-HTTP-2-0-这三个版本的主要区别。">1.对比一下 <strong>HTTP/1.0, HTTP/1.1, 和 HTTP/2.0</strong> 这三个版本的主要区别。</h2>
<p>请从<strong>连接管理、性能优化、头部处理</strong>等角度展开，并说明每一个版本的演进分别解决了上一代的什么核心痛点？</p>
<p>1.0-&gt;1.1</p>
<ul>
<li><strong>长链接 (Keep-Alive):</strong> 是 <strong>HTTP/1.1</strong> 相对于 HTTP/1.0 最核心的改进之一。HTTP/1.0 默认是短连接，每个请求/响应对都需要一次 TCP 连接。而 HTTP/1.1 默认开启了长链接，允许在一个 TCP 连接上发送多个 HTTP 请求，<strong>极大地减少了 TCP 连接建立和关闭的开销</strong>。</li>
<li>HTTP/1.1 还引入了<strong>管道机制 (Pipelining)</strong>，允许客户端在收到上一个响应之前就发送下一个请求。但这只是部分解决了队头阻塞（Head-of-Line Blocking）问题，因为服务端的响应仍然必须按顺序返回。</li>
</ul>
<p>2.0</p>
<ul>
<li>
<p><strong>多路复用 (Multiplexing):</strong> 这是 HTTP/2.0 <strong>最核心</strong>的优势。它允许在一个 TCP 连接上，<strong>同时、并行地</strong>收发多个请求和响应，并且不按顺序。这彻底解决了 HTTP/1.1 的队头阻塞问题。</p>
</li>
<li>
<p><strong>头部压缩 (Header Compression):</strong> HTTP/2.0 使用 HPACK 算法来压缩请求和响应的头部。对于多个请求，很多头部字段是重复的，HPACK 可以极大地减少这部分的数据传输量。</p>
</li>
<li>
<p><strong>服务器推送 (Server Push):</strong> 服务器可以主动地将客户端未来可能会用到的资源（如 CSS, JS 文件）提前推送到客户端缓存中，减少了请求的 RTT（往返时间）。</p>
</li>
<li>
<p><strong>二进制分帧 (Binary Framing):</strong> 这是 <strong>HTTP/2.0</strong> 的革命性变化。HTTP/1.0 和 1.1 都是基于文本的协议，而 HTTP/2.0 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。这解决了 1.x 时代基于文本的协议解析效率低的问题。</p>
</li>
<li>
<p><strong>HTTP/1.0 -&gt; HTTP/1.1:</strong> 解决了什么？<strong>连接无法复用的问题</strong>。通过什么解决？<strong>默认开启长链接 (Keep-Alive)</strong>。</p>
</li>
<li>
<p><strong>HTTP/1.1 -&gt; HTTP/2.0:</strong> 解决了什么？<strong>队头阻塞和头部冗余的问题</strong>。通过什么解决？<strong>二进制分帧、多路复用、头部压缩</strong>。</p>
</li>
</ul>
<h2 id="2-从用户在浏览器输入-URL-到页面渲染完成，请按网络与系统角度分层讲解关键路径。">2.从用户在浏览器输入 URL 到页面渲染完成，请按<strong>网络与系统角度</strong>分层讲解关键路径。</h2>
<p>我将其分为<strong>请求准备阶段</strong>、<strong>网络通信阶段</strong>、和<strong>浏览器渲染阶段</strong></p>
<p>当我在URL栏输入地址的话，首先要知道这个域名对应的IP地址是啥</p>
<p>请求准备：</p>
<ol>
<li>浏览器首先会解析URL，判断协议（HTTPS）、<a target="_blank" rel="noopener" href="http://xn--www-q33er8o.google.com">域名www.google.com</a>）、端口（默认为443）等信息。接着，它会查询自己的<strong>浏览器缓存</strong>，看之前是否已经解析过这个域名并且缓存还未过期。如果命中，就直接使用缓存的IP地址，跳过后续的DNS查询。</li>
<li>如果浏览器缓存未命中，操作系统会启动一个DNS查询流程，这是一个从近到远、层层递归的查询过程，核心目标是将域名转换为IP地址。先是操作系统&amp;host文件，然后是本地DNS服务器，再是根域名服务器，顶级域名服务器，权威域名服务器。依次类推</li>
<li>LDNS拿到IP地址后，会将其缓存起来，并返回给操作系统，操作系统再返回给浏览器。至此，DNS解析完成。</li>
</ol>
<p>网络通信：</p>
<p>这个过程涉及到TCP、TLS和HTTP三个核心协议</p>
<p>TCP三次握手</p>
<ol>
<li><strong>第一次握手 (SYN)</strong>：客户端随机选择一个初始序列号<code>client_isn</code>，将TCP报文段的<code>SYN</code>标志位置为1，然后发送给服务器。此时客户端进入<code>SYN_SENT</code>状态。</li>
<li><strong>第二次握手 (SYN+ACK)</strong>：服务器收到SYN包后，必须确认客户端的<code>SYN</code>。它将报文段的<code>SYN</code>和<code>ACK</code>标志位都置为1，确认号<code>ack</code>设为<code>client_isn + 1</code>，同时自己也选择一个初始序列号<code>server_isn</code>，然后发送给客户端。此时服务器进入<code>SYN_RCVD</code>状态。</li>
<li><strong>第三次握手 (ACK)</strong>：客户端收到服务器的SYN+ACK包后，检查确认号是否正确。如果正确，它会将<code>ACK</code>标志位置为1，确认号<code>ack</code>设为<code>server_isn + 1</code>，然后发送给服务器。这个ACK包可以携带数据。发送后，客户端和服务器都进入<code>ESTABLISHED</code>状态，连接建立成功。</li>
</ol>
<p>TLS四次挥手：</p>
<ol>
<li><strong>Client Hello</strong>：客户端发送支持的TLS版本、加密套件列表、以及一个随机数<code>client_random</code>。</li>
<li><strong>Server Hello &amp; Certificate</strong>：服务器选择一个加密套件，返回自己的数字证书、以及一个随机数<code>server_random</code>。</li>
<li><strong>客户端验证与密钥交换</strong>：客户端验证服务器证书的有效性。验证通过后，生成一个预主密钥<code>pre-master secret</code>，用服务器证书中的公钥加密后发送给服务器。</li>
<li><strong>服务器解密与会话密钥生成</strong>：服务器用自己的私钥解密，得到<code>pre-master secret</code>。至此，<strong>客户端和服务器双方都拥有了<code>client_random</code>、<code>server_random</code>和<code>pre-master secret</code></strong>，它们使用相同的算法，各自独立地生成一个<strong>对称的会话密钥</strong>。</li>
<li><strong>Finished</strong>：双方互发<code>Finished</code>消息，用生成的会话密钥加密，验证握手过程是否成功。握手结束后，后续所有的HTTP数据都将使用这个对称的会话密钥进行加密传输。</li>
</ol>
<p>Http请求和相应：</p>
<ol>
<li><strong>发送HTTP请求</strong>：浏览器构建一个HTTP请求报文，包含请求行（<code>GET / HTTP/1.1</code>）、请求头（<code>Host</code>, <code>User-Agent</code>, <code>Cookie</code>等）和请求体（GET请求通常为空），然后通过建立好的TCP/TLS通道发送给服务器。</li>
<li>请求到达服务器后，可能会先经过<strong>负载均衡器（如Nginx/SLB）</strong>，它会将请求转发到后端的某一台应用服务器。</li>
<li>应用服务器（如Tomcat）接收到请求后，Web容器会解析HTTP报文，将其封装成<code>HttpServletRequest</code>对象。</li>
<li>业务代码（如Spring MVC的Controller）被调用，它可能会查询<strong>缓存（Redis）</strong>、<strong>数据库（MySQL）</strong>，执行业务逻辑，最终生成数据。</li>
<li>服务器将数据渲染进HTML模板，构建一个HTTP响应报文，包含状态行（<code>HTTP/1.1 200 OK</code>）、响应头（<code>Content-Type</code>, <code>Set-Cookie</code>等）和响应体（HTML内容）。</li>
<li><strong>接收HTTP响应</strong>：浏览器接收到服务器的响应报文。</li>
</ol>
<p>浏览器渲染：</p>
<ul>
<li>浏览器自上而下解析HTML文档，生成<strong>DOM树（Document Object Model）</strong>。</li>
<li>在解析过程中，如果遇到<code>&lt;link&gt;</code>标签引用的CSS文件，会异步下载并解析，生成<strong>CSSOM树（CSS Object Model）</strong>。</li>
<li>如果遇到<code>&lt;script&gt;</code>标签，会阻塞DOM的解析，立即下载并执行JavaScript代码（除非<code>script</code>标签有<code>async</code>或<code>defer</code>属性）。</li>
<li><strong>构建渲染树（Render Tree）</strong>：将DOM树和CSSOM树结合起来，生成渲染树。渲染树只包含需要被显示的节点及其样式信息（例如，<code>display:none</code>的节点就不会在渲染树中）。</li>
<li><strong>布局（Layout/Reflow）</strong>：浏览器根据渲染树，计算出每个节点在屏幕上的精确位置和大小。</li>
<li><strong>绘制（Paint/Rasterizing）</strong>：浏览器调用GPU，根据布局信息，将每个节点绘制成屏幕上的实际像素。</li>
<li><strong>合成（Composite）</strong>：对于复杂的页面（如使用了<code>transform</code>或<code>opacity</code>），浏览器会将页面分层，独立绘制，最后再合成到一起，以提升性能。</li>
</ul>
<p>所有资源加载完成，或者是空闲超时了之后，就会开始断开请求TCP的四次挥手</p>
<ul>
<li><strong>第一次挥手 (FIN)</strong>：主动关闭方（如客户端）发送一个<code>FIN</code>报文，表示自己的数据已发送完毕。进入<code>FIN_WAIT_1</code>状态。</li>
<li><strong>第二次挥手 (ACK)</strong>：被动关闭方（服务器）收到<code>FIN</code>后，回复一个<code>ACK</code>报文。此时，连接处于<strong>半关闭</strong>状态，服务器仍然可以向客户端发送数据。</li>
<li><strong>第三次挥手 (FIN)</strong>：服务器也准备好关闭连接时，发送一个<code>FIN</code>报文给客户端。进入<code>LAST_ACK</code>状态。</li>
<li><strong>第四次挥手 (ACK)</strong>：客户端收到服务器的<code>FIN</code>后，回复一个<code>ACK</code>报文。发送后，客户端进入**<code>TIME_WAIT</code>**状态。服务器收到这个ACK后，立即关闭连接。</li>
</ul>
<p><code>TIME_WAIT</code>状态？</p>
<ol>
<li><strong>可靠地终止TCP连接</strong>：这是最主要的原因。四次挥手中的<strong>最后一个ACK报文是由主动关闭方（客户端）发出的</strong>。这个ACK报文有可能会在网络中丢失。如果丢失，被动关闭方（服务器）就收不到确认，它会<strong>超时重传它的FIN报文</strong>。如果此时客户端已经彻底关闭连接，它将无法响应这个重传的FIN，导致服务器永远无法正常关闭。而处于<code>TIME_WAIT</code>状态的客户端，仍然能接收到这个重传的FIN，并<strong>重新发送一次ACK</strong>，从而确保服务器能够正常关闭。</li>
<li><strong>防止已失效的报文段被新连接误接收</strong>：考虑一个场景：一个TCP连接（由<code>源IP:源端口, 目的IP:目的端口</code>这个四元组唯一标识）关闭后，马上又用<strong>完全相同的四元组</strong>建立了一个新的连接。此时，网络中可能还存在上一个旧连接中延迟到达的报文段。如果没有<code>TIME_WAIT</code>状态，这些“迷路”的旧报文段就可能会被这个新连接误认为是合法数据并接收，造成数据错乱。</li>
</ol>
<p><strong>为什么等待时间是 <code>2MSL</code>？</strong></p>
<ul>
<li>**MSL（Maximum Segment Lifetime）*<em>是指一个TCP报文段在网络中可能存活的*<em>最长时间</em></em>。任何报文在超过MSL后，都会被网络丢弃。</li>
</ul>
<p><strong><code>2MSL</code>的时间足以保证在一个连接的一去一回两个方向上，所有的报文段都能在网络中自然消失</strong>。当<code>TIME_WAIT</code>状态结束后，可以保证网络中不再有任何与旧连接相关的“幽灵”报文段，此时再建立新的连接就是完全安全的。</p>
<h2 id="3-在-TCP-三次握手过程中，如果第三次握手的-ACK-报文丢失了，会发生什么？">3.在 TCP 三次握手过程中，如果<strong>第三次握手的 ACK 报文丢失</strong>了，会发生什么？</h2>
<p>三次握手分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYN` -&gt; `SYN+ACK` -&gt; `ACK</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>服务端状态：</strong> 当服务端发送完 <code>SYN+ACK</code> 之后，它会进入 <strong><code>SYN_RCVD</code></strong> 状态，并<strong>启动一个定时器</strong>，等待客户端的第三次 <code>ACK</code>。</li>
<li><strong>客户端状态：</strong> 当客户端发送完第三次 <code>ACK</code> 之后，它<strong>单方面认为连接已经建立</strong>，状态会变为 <strong><code>ESTABLISHED</code></strong>。</li>
</ul>
<p>因为是<strong>服务端</strong>在 <code>SYN_RCVD</code> 状态下等待第三次 <code>ACK</code> 超时了。当定时器超时后，服务端会<strong>重新发送 <code>SYN+ACK</code> 包</strong>给客户端。重传的次数由系统参数（如 <code>net.ipv4.tcp_synack_retries</code>）控制。</p>
<p>在 <code>SYN_RCVD</code> 状态下，连接并未完全建立。对于服务端应用层来说，它通过 <code>accept()</code> 拿到的连接还处于一个“半连接队列”中，<strong>应用层是无法使用这个连接的</strong>，所以服务端应用层<strong>无感知</strong>。</p>
<p>因为客户端在发送完第三次 <code>ACK</code> 后，其内核协议栈就认为连接已建立（<code>ESTABLISHED</code> 状态），所以对于客户端应用层来说，<code>connect()</code> 系统调用<strong>会立即返回成功</strong>。此时，客户端应用层<strong>会认为连接已经建立成功，并开始发送数据</strong>。</p>
<p>处理：</p>
<ul>
<li>客户端应用层发送的数据，会和因为第三次 ACK 丢失而重传的 <code>SYN+ACK</code> 在网络中交汇。</li>
<li>当客户端收到服务端重传的 <code>SYN+ACK</code> 后，它的内核会意识到自己之前发送的 <code>ACK</code> 可能丢失了，于是会<strong>再次发送一个 <code>ACK</code></strong> 给服务端。</li>
<li>当服务端收到了这个新的 <code>ACK</code> 后（无论是客户端重发的，还是伴随着数据包一起过来的），服务端状态才会变为 <code>ESTABLISHED</code>，连接才真正建立，之前客户端发送的数据才会被服务端应用层接收。</li>
</ul>
<p>TCP状态机转变：CLOSED<code>-&gt;</code>SYN_SENT<code>-&gt;</code>SYN_RCVD<code>-&gt;</code>ESTABLISHE</p>
<h1>异常解决</h1>
<h2 id="1-就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢">1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢</h2>
<p>线上出现异常，我会遵循一套<strong>从宏观到微观、由表及里</strong>的排查SOP（标准作业程序）来定位和解决问题。</p>
<p><strong>第一步：信息收集与初步判断</strong></p>
<ol>
<li>
<p><strong>确认影响范围</strong>：首先，快速判断这个异常的影响面有多大。是影响了所有用户，还是部分用户？是核心功能还是边缘功能？这决定了问题的紧急程度。</p>
</li>
<li>
<p>查看监控告警：立即查看监控系统（如Prometheus/Grafana, Zabbix）的告警信息。检查应用的</p>
<p>关键指标，如：</p>
<ul>
<li><strong>应用层面</strong>：QPS、响应时间（RT）、错误率（Error Rate）是否突增？</li>
<li><strong>JVM层面</strong>：CPU使用率、内存占用、GC活动是否异常？</li>
<li><strong>主机层面</strong>：服务器的CPU、内存、磁盘I/O、网络流量是否正常？</li>
<li><strong>依赖服务</strong>：数据库、Redis、MQ等中间件的健康状况如何？</li>
<li>这一步的目标是快速定位问题是出在<strong>应用本身</strong>，还是<strong>外部依赖</strong>。</li>
</ul>
</li>
</ol>
<p><strong>第二步：日志分析与精准定位</strong></p>
<ol>
<li><strong>聚合日志平台检索</strong>：登录ELK（Elasticsearch, Logstash, Kibana）或类似日志平台，根据告警信息中的时间点、错误信息关键字（如<code>RuntimeException</code>）进行检索。</li>
<li><strong>利用Trace ID进行链路追踪</strong>：如果系统接入了分布式追踪系统（如SkyWalking, Zipkin），这是最强大的工具。我会根据报错信息找到一个<strong>Trace ID</strong>，然后用这个ID查询完整的请求调用链。这可以清晰地看到请求经过了哪些服务，在哪一个环节耗时最长，又是在哪个服务的具体代码行抛出了异常。</li>
<li>Linux服务器手动排查（作为补充）：如果日志平台不完善，我会登录到具体的服务器上进行排查。
<ul>
<li>使用<code>grep</code>命令根据关键字快速过滤日志：<code>grep -C 10 'ExceptionNameToFind' /path/to/app.log</code>。<code>-C 10</code>可以显示异常上下文的10行，帮助理解问题背景。</li>
<li>如果需要根据Trace ID查，我会用：<code>grep 'your-trace-id' /path/to/app.log</code>。</li>
<li>对于实时滚动的日志，我会用<code>tail -f /path/to/app.log | grep 'ERROR'</code>来实时监控错误输出。</li>
</ul>
</li>
</ol>
<p>第三步：<strong>根因分析与问题复现</strong></p>
<ol>
<li><strong>代码分析</strong>：定位到具体的异常代码后，分析代码逻辑，判断是业务逻辑错误、空指针、并发问题还是资源未释放等。</li>
<li><strong>环境复现</strong>：如果可能，尝试在测试环境或预发环境，构造相同的参数和条件，复现这个问题，以便于调试和验证修复方案。</li>
</ol>
<p>第四步：<strong>问题解决与复盘</strong></p>
<ol>
<li><strong>紧急修复</strong>：如果是严重Bug，立即进行Hotfix修复并上线。如果是资源问题，进行扩容或配置调整。</li>
<li><strong>复盘总结</strong>：问题解决后，必须进行复盘。分析问题发生的根本原因，是代码缺陷、设计不合理、还是容量预估不足？并制定改进措施，例如增加单元测试、完善监控告警、优化架构等，防止同类问题再次发生。</li>
</ol>
<h2 id="2-考察线上问题排查">2.考察线上问题排查</h2>
<ul>
<li>
<p><strong>第一步：紧急止血（恢复服务优先）。</strong></p>
</li>
<li>
<p><strong>第二步：定位根因（Root Cause）。</strong></p>
</li>
<li>
<p><strong>第三步：复盘总结（避免再犯）。</strong></p>
</li>
<li>
<p>\1. 看监控，定范围：</p>
<ul>
<li><strong>看应用自身监控：</strong> 接口的 QPS、P99 响应时间、JVM（GC次数/时间、线程数）、线程池监控（队列长度、活跃线程数）。首先确认是自身应用的问题还是外部问题。</li>
<li><strong>看主机监控：</strong> CPU 使用率、内存占用、网络 I/O、磁盘 I/O。确认是不是机器资源被打满了。</li>
</ul>
</li>
<li>
<p>\2. 分析线程，找瓶颈：</p>
<ul>
<li>使用 <code>jstack</code> 命令 dump 线程堆栈。分析是否有大量线程处于 <code>BLOCKED</code> 状态（锁竞争）、<code>WAITING</code> 状态（等待外部资源，如 HTTP 调用、数据库连接）。这是定位问题的<strong>最核心手段</strong>。</li>
</ul>
</li>
<li>
<p>\3. 查GC，判影响：</p>
<ul>
<li>使用 <code>jstat -gcutil</code> 查看 GC 情况。确认是否发生了频繁的 Full GC，导致 STW（Stop-The-World），从而影响接口响应。</li>
</ul>
</li>
<li>
<p>\4. 查依赖，判外部：</p>
<ul>
<li>检查所有**下游服务（RPC 调用）**的响应时间。是不是某个下游服务变慢，拖垮了你。</li>
<li>检查**数据库和缓存（Redis）**的慢查询日志和响应时间。是不是因为慢 SQL 或 Redis 大 Key 导致的阻塞。</li>
</ul>
</li>
<li>
<p>\5. 看网络，做补充：</p>
<ul>
<li>如果以上都正常，再考虑网络问题，比如丢包、重传等。</li>
</ul>
</li>
</ul>
<p>恢复手段：</p>
<ul>
<li><strong>重启大法：</strong> 最简单粗暴但有效。</li>
<li><strong>服务降级：</strong> 通过配置中心，暂时关闭一些非核心功能。</li>
<li><strong>服务限流：</strong> 立即调低接口的 QPS 阈值，避免被流量打垮。</li>
<li><strong>扩容：</strong> 如果是资源不足，立即进行水平扩容。</li>
</ul>
<h2 id="3-线上问题卡顿">3.线上问题卡顿</h2>
<p>提出了一个“自顶向下”的排查思路：先通过监控工具（宝塔）看服务器资源（CPU、内存），定位到具体程序，再通过程序的日志（Docker日志）定位到具体组件和代码异常。</p>
<p>Linux 命令行工具（如 <code>top</code>, <code>jstack</code>, <code>jmap</code>）的提及。对于一个硬核的技术面试，面试官更希望听到你如何使用这些底层工具进行排查。此外，排查的维度不够全面，没有考虑到<strong>网络问题、数据库慢查询、下游服务拖累</strong>等常见原因。</p>
<h2 id="AI">AI</h2>
<h2 id="1-设计一个可扩展的架构，并说明如何实现-1-2-秒-P95-的延迟指标。">1.设计一个可扩展的架构，并说明如何实现 <strong>1-2 秒 P95 的延迟指标</strong>。</h2>
<p><strong>召回、重排、向量库更新、上下文窗口管理、长对话状态持久化</strong>，以及<strong>延迟预算分配</strong>几个维度，</p>
<p>RAG 的核心流程：文档切分 -&gt; 向量化入库 -&gt; 用户问题向量化 -&gt; Top K 相似度检索 -&gt; 结果送入 LLM 生成答案。RAG 是为了解决 LLM 没有“记忆”和无法利用私有知识的问题。</p>
<ul>
<li><strong>召回（Recall）：</strong> 你只提到了向量相似度检索。但一个生产级的 RAG 系统，召回层通常是<strong>混合检索</strong>，比如 <strong>向量检索 + 关键词检索（如 BM25）</strong>，以应对不同类型的问题。</li>
<li><strong>重排（Rerank）：</strong> 你提到了重排模型，但没有说明它的作用。Rerank 模型（如 Cohere Rerank）通常是一个轻量级的交叉编码器模型，它会对召回的 Top N（比如 N=50）个文档，进行更精细化的相关性打分，再选出最终的 Top K（比如 K=5）送给 LLM，能<strong>显著提升最终答案的质量</strong>。</li>
<li><strong>向量库更新：</strong> 这是一个工程难题，你完全没有提及。如何处理知识的<strong>增量更新、修改和删除</strong>？是定期全量重建索引，还是采用支持实时更新的向量数据库？</li>
</ul>
<p>时间分配：</p>
<ul>
<li>用户问题预处理：50ms</li>
<li>向量化（Embedding）: 100ms</li>
<li>向量检索（Recall）: 150ms</li>
<li>重排（Rerank）: 200ms</li>
<li>LLM 生成（Generation）: 1000ms (这是大头)</li>
<li>网络开销等：500ms 然后你需要思考如何优化每个环节。比如，Embedding 模型和 Rerank 模型需要<strong>选择轻量级、高性能</strong>的版本；向量检索需要对索引进行<strong>优化</strong>（如 HNSW 索引的参数调优）；LLM 需要采用<strong>流式输出（Streaming）</strong>，让用户能更快地看到第一个 Token。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/')">面试面经优化回答</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=面试面经优化回答&amp;url=https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=f367dec8-8911-a97c-1f8e-768aa23b2df8" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E9%9D%A2%E7%BB%8F/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>面经<span class="categoryesPageCount">7</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">29</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722380.jpg?_r_=3d0d7da1-0d0f-9929-e0f4-32a2544db196" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=67fcca6b-98b8-35b7-ba2b-7d538d139dab" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">javase面试-深入源码</div></div></a></div><div class="next-post pull-right"><a href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510678.jpg?_r_=34afaba5-4e93-4113-3140-269fbfcea8c6" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mysql底层分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/09/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cap1/" title="分布式架构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510550.jpg?_r_=a87ced7d-96a4-553c-c746-8264ead292fb" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-09-09</div><div class="title">分布式架构</div></div></a></div><div><a href="/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/" title="面试面经-大厂收集"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=2ad77465-82ed-4b20-6588-21aa1964365d" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-27</div><div class="title">面试面经-大厂收集</div></div></a></div><div><a href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/" title="JUC-源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=66d0fa46-4d20-cb05-42f5-30f00f595b38" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-15</div><div class="title">JUC-源码分析</div></div></a></div><div><a href="/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/" title="Mysql底层分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510678.jpg?_r_=34afaba5-4e93-4113-3140-269fbfcea8c6" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-15</div><div class="title">Mysql底层分析</div></div></a></div><div><a href="/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/" title="javase面试-深入源码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=67fcca6b-98b8-35b7-ba2b-7d538d139dab" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-12</div><div class="title">javase面试-深入源码</div></div></a></div><div><a href="/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/" title="面试面经-2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=e0fc83dc-0f12-c498-e3ea-571c992ef413" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-29</div><div class="title">面试面经-2</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Spring框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.</span> <span class="toc-text">1.SpringBoot的配置加载优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Springboot%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.Springboot是如何解决跨域问题的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Spring-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.3.</span> <span class="toc-text">3.Spring 解决循环依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4.Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Bean-%E5%92%8C-Component-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5.@Bean 和 @Component 的区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91"><span class="toc-number">2.1.</span> <span class="toc-text">1.线程池常见的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AQS%E7%9A%84%E5%A4%A7%E5%B1%80%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2.AQS的大局解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">3.wait和sleep的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92"><span class="toc-number">2.4.</span> <span class="toc-text">4.异步编排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E2%80%9C%E7%BB%86%E8%8A%82%E8%BF%BD%E9%97%AE"><span class="toc-number">2.5.</span> <span class="toc-text">5.synchronized 锁升级的“细节追问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-ThreadLocal"><span class="toc-number">2.6.</span> <span class="toc-text">6.ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%B0%88%E8%B0%88%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">2.7.</span> <span class="toc-text">7.谈谈怎么理解线程安全的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-ConditionalOnClass-%E8%AE%BE%E8%AE%A1%E5%86%85%E6%B6%B5"><span class="toc-number">2.8.</span> <span class="toc-text">8.**@ConditionalOnClass**设计内涵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-ThreadLocal-%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.9.</span> <span class="toc-text">9.ThreadLocal 在线程池中的失效问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.10.</span> <span class="toc-text">10.如何保证三个线程有序执行任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-ReentrantLock-%E5%92%8C-synchronized-%E5%9C%A8%E6%80%A7%E8%83%BD%E4%B8%8A%E5%88%B0%E5%BA%95%E5%B7%AE%E5%BC%82%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">11.ReentrantLock 和 synchronized 在性能上到底差异在哪？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-UserMappe%E8%BF%99%E4%B8%AA%E7%B1%BB%E4%B8%BA%E5%95%A5%E8%A6%81%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%91%A2%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.UserMappe这个类为啥要是接口呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%82%A3%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%91%A2%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1.那有哪些对象是可以直接在栈上分配呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JMM%E5%92%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.JMM和一个对象的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-GC"><span class="toc-number">4.3.</span> <span class="toc-text">3.GC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA%E5%92%8C%E9%9D%9E%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="toc-number">5.1.</span> <span class="toc-text">1.流式输出和非流式输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HashMap-remove-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">5.2.</span> <span class="toc-text">2.HashMap remove 方法的实现细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%B4%E8%AF%B4-ArrayList%E3%80%81LinkedList%E3%80%81CopyOnWriteArrayList-%E8%BF%99%E4%B8%89%E8%80%85%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82"><span class="toc-number">5.3.</span> <span class="toc-text">3.说说 ArrayList、LinkedList、CopyOnWriteArrayList 这三者的适用场景与关键差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">4.反射的原理&amp;&amp;应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E8%A1%A8join%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1.多表join的时候，小表驱动大表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%80%E6%9D%A1-UPDATE-%E8%AF%AD%E5%8F%A5%E5%8F%91%E8%BF%87%E6%9D%A5%EF%BC%8C%E4%BB%8E%E7%BD%91%E7%BB%9C%E6%8E%A5%E6%94%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%B0%E6%9C%80%E7%BB%88%E8%90%BD%E7%9B%98%EF%BC%8C%E4%BC%9A%E7%BB%8F%E8%BF%87%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">2.一条 UPDATE 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-WAL%EF%BC%9F%E5%AE%83%E7%9B%B8%E6%AF%94%E4%BA%8E%E7%9B%B4%E6%8E%A5%E5%86%99%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%86%99%E6%97%A5%E5%BF%97%E5%92%8C%E6%9B%B4%E6%96%B0%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BD%93%E4%B8%80%E4%B8%AA%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%88%86%E8%A3%82%E6%97%B6%EF%BC%8C%E5%85%B7%E4%BD%93%E9%80%BB%E8%BE%91%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.5.</span> <span class="toc-text">5.慢查询的的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-SQL"><span class="toc-number">6.6.</span> <span class="toc-text">6.SQL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%A4%B1%E8%B4%A5%E5%9B%9E%E6%BB%9A"><span class="toc-number">7.1.</span> <span class="toc-text">1.多级缓存数据一致性与失败回滚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%8C%81%E6%9C%89%E5%90%8C%E4%B8%80%E6%8A%8A%E9%94%81"><span class="toc-number">7.2.</span> <span class="toc-text">2.什么情况下，就是两个线程会持有同一把锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9CCanal%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%88%96%E8%80%85Canal%E5%88%B0%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E9%93%BE%E8%B7%AF%E5%87%BA%E7%8E%B0%E9%95%BF%E6%97%B6%E9%97%B4%E4%B8%AD%E6%96%AD%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%AE%B9%E7%81%BE%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">3.如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%A0%E6%8F%90%E5%88%B0%E7%94%A8Redis%E7%9A%84Pub-Sub%E6%9D%A5%E5%B9%BF%E6%92%AD%E5%A4%B1%E6%95%88Caffeine%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E3%80%82"><span class="toc-number">7.4.</span> <span class="toc-text">4.你提到用Redis的Pub&#x2F;Sub来广播失效Caffeine本地缓存。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%E4%B8%89%E9%97%AE%E9%A2%98"><span class="toc-number">7.5.</span> <span class="toc-text">5.缓存三问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%94%A8%E6%88%B7%E5%9C%A810%E5%88%86%E9%92%9F%E4%B9%8B%E5%86%85%E8%BF%9E%E7%BB%AD%E8%BE%93%E9%94%99%E4%B8%89%E6%AC%A1%E5%AF%86%E7%A0%81%EF%BC%8C%E5%B0%B1%E7%A6%81%E6%AD%A2%E5%85%B6%E7%99%BB%E5%BD%95%E2%80%9D%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8-Redis%EF%BC%8C%E4%BD%A0%E4%BC%9A%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.6.</span> <span class="toc-text">6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.7.</span> <span class="toc-text">7.Redis持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.8.</span> <span class="toc-text">8.Redis底层数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E5%A4%84%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">1.消息队列（MQ）消息积压处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="toc-number">8.2.</span> <span class="toc-text">2.消费者组的对应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1-%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89"><span class="toc-number">8.3.</span> <span class="toc-text">3.消息不丢失&amp;&amp;消息幂等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-RocketMQ%E5%8D%8A%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">8.4.</span> <span class="toc-text">4.RocketMQ半事务消息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.1.</span> <span class="toc-text">1.分布式事务设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BD%93%E8%A2%AB%E9%97%AE%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E4%BB%A5%E9%81%BF%E5%85%8D%E4%BB%A3%E7%A0%81%E9%87%8D%E5%A4%8D%E6%97%B6"><span class="toc-number">10.1.</span> <span class="toc-text">1.当被问及如何在多个接口中统一管理以避免代码重复时</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AD%96%E7%95%A5%E6%96%B9%E6%B3%95%E6%80%8E%E4%B9%88%E5%8E%BB%E8%A7%A3%E5%86%B3%E5%85%B7%E4%BD%93%E8%B0%83%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA%E7%AD%96%E7%95%A5"><span class="toc-number">10.2.</span> <span class="toc-text">2.策略方法怎么去解决具体调用哪一个策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-100%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8B%BC%E6%8E%A5%E4%BF%9D%E8%AF%81%E6%95%B4%E4%BD%93%E6%9C%89%E5%BA%8F%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">3.100个有序文件，如何拼接保证整体有序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.4.</span> <span class="toc-text">4.设计一个高并发的系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E5%9B%9E%E7%AD%94"><span class="toc-number">10.5.</span> <span class="toc-text">5.模板方法的回答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-30%E5%88%86%E9%92%9F%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD"><span class="toc-number">10.6.</span> <span class="toc-text">6.30分钟自动关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%85%A8%E5%B1%80%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">10.7.</span> <span class="toc-text">7.如何设计全局统一异常处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%B9%E6%AF%94%E4%B8%80%E4%B8%8B-HTTP-1-0-HTTP-1-1-%E5%92%8C-HTTP-2-0-%E8%BF%99%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">12.1.</span> <span class="toc-text">1.对比一下 HTTP&#x2F;1.0, HTTP&#x2F;1.1, 和 HTTP&#x2F;2.0 这三个版本的主要区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%8E%E7%94%A8%E6%88%B7%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%EF%BC%8C%E8%AF%B7%E6%8C%89%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%A7%92%E5%BA%A6%E5%88%86%E5%B1%82%E8%AE%B2%E8%A7%A3%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E3%80%82"><span class="toc-number">12.2.</span> <span class="toc-text">2.从用户在浏览器输入 URL 到页面渲染完成，请按网络与系统角度分层讲解关键路径。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9C%A8-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84-ACK-%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%E4%BA%86%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">3.在 TCP 三次握手过程中，如果第三次握手的 ACK 报文丢失了，会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">异常解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B0%B1%E6%AF%94%E5%A6%82%E8%AF%B4%E4%BD%A0%E8%BF%99%E4%B8%AA%E9%83%A8%E7%BD%B2%E5%88%B0%E7%BA%BF%E4%B8%8A%E4%BA%86%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%96%E6%8A%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%EF%BC%8C%E7%84%B6%E5%90%8E%E9%82%A3%E4%BD%A0%E8%BF%99%E4%B8%AA%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E5%91%A2"><span class="toc-number">13.1.</span> <span class="toc-text">1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%80%83%E5%AF%9F%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">13.2.</span> <span class="toc-text">2.考察线上问题排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%8D%A1%E9%A1%BF"><span class="toc-number">13.3.</span> <span class="toc-text">3.线上问题卡顿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AI"><span class="toc-number">13.4.</span> <span class="toc-text">AI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-1-2-%E7%A7%92-P95-%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%8C%87%E6%A0%87%E3%80%82"><span class="toc-number">13.5.</span> <span class="toc-text">1.设计一个可扩展的架构，并说明如何实现 1-2 秒 P95 的延迟指标。</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/dubbo-alay/" title="Dubbo源码分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722380.jpg?_r_=3d0d7da1-0d0f-9929-e0f4-32a2544db196" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dubbo源码分析"/></a><div class="content"><a class="title" href="/2025/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/dubbo-alay/" title="Dubbo源码分析">Dubbo源码分析</a><time datetime="2025-09-09T16:00:00.000Z" title="发表于 2025-09-10 00:00:00">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cap1/" title="分布式架构"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202408081510550.jpg?_r_=a87ced7d-96a4-553c-c746-8264ead292fb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式架构"/></a><div class="content"><a class="title" href="/2025/09/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cap1/" title="分布式架构">分布式架构</a><time datetime="2025-09-08T16:00:00.000Z" title="发表于 2025-09-09 00:00:00">2025-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/08/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/spring-alay/" title="Spring源码分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712180.jpg?_r_=d185821d-2335-6691-b391-905a9bde5c14" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring源码分析"/></a><div class="content"><a class="title" href="/2025/09/08/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/spring-alay/" title="Spring源码分析">Spring源码分析</a><time datetime="2025-09-07T16:00:00.000Z" title="发表于 2025-09-08 00:00:00">2025-09-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/" title="面试面经-大厂收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722381.jpg?_r_=2ad77465-82ed-4b20-6588-21aa1964365d" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试面经-大厂收集"/></a><div class="content"><a class="title" href="/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/" title="面试面经-大厂收集">面试面经-大厂收集</a><time datetime="2025-08-26T16:00:00.000Z" title="发表于 2025-08-27 00:00:00">2025-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/" title="压测实际经验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=4c85ed1b-992f-b1d0-a6cc-c5f97e58c47e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="压测实际经验"/></a><div class="content"><a class="title" href="/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/" title="压测实际经验">压测实际经验</a><time datetime="2025-08-20T16:00:00.000Z" title="发表于 2025-08-21 00:00:00">2025-08-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">169</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">25</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BUG/" style="font-size: 0.88rem;">BUG<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 0.88rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem;">CSRF<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 0.88rem;">FI<sup>1</sup></a><a href="/tags/Github/" style="font-size: 0.88rem;">Github<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/dubbo/" style="font-size: 0.88rem;">dubbo<sup>1</sup></a><a href="/tags/football/" style="font-size: 0.88rem;">football<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>59</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>2</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>17</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>7</sup></a><a href="/tags/paper/" style="font-size: 0.88rem;">paper<sup>1</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 0.88rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>4</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>4</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>14</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>20</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%AF%9B%E9%80%89/" style="font-size: 0.88rem;">毛选<sup>1</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>29</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>