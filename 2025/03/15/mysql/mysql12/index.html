<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Mysql面试题目 | mengnankkのblog</title><meta name="keywords" content="面试,mysql"><meta name="author" content="mengnankkzhou"><meta name="copyright" content="mengnankkzhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#18171d"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Mysql面试题目"><meta name="application-name" content="Mysql面试题目"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#18171d"><meta property="og:type" content="article"><meta property="og:title" content="Mysql面试题目"><meta property="og:url" content="https://blog.tokenlen.top/2025/03/15/mysql/mysql12/index.html"><meta property="og:site_name" content="mengnankkのblog"><meta property="og:description" content="原理概念1.什么是mysqlMySQL 是一个开源的关系型数据库，现在隶属于 Oracle 公司。是我们国内使用频率最高的一种数据库，我在本地安装的是最新的 8.3 版本。 怎么删除建立一张表？ 使用DROP TABLE 来删除表 CREATE TABLE来创建表 创建表的时候可以使用PRIMARY"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=b0078bfc-8718-be24-66f8-bd95f158e9ac"><meta property="article:author" content="mengnankkzhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=b0078bfc-8718-be24-66f8-bd95f158e9ac"><meta name="description" content="原理概念1.什么是mysqlMySQL 是一个开源的关系型数据库，现在隶属于 Oracle 公司。是我们国内使用频率最高的一种数据库，我在本地安装的是最新的 8.3 版本。 怎么删除建立一张表？ 使用DROP TABLE 来删除表 CREATE TABLE来创建表 创建表的时候可以使用PRIMARY"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blog.tokenlen.top/2025/03/15/mysql/mysql12/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走啊，那种事情不要啊","backTitle":"♪(^∇^*)欢迎回家！！！！"},
  LA51: undefined,
  greetingBox: {"enable":"ture","default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.tokenlen.top/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"\tbd9428de12b54b96b2f1b4e69aeee81f","mailMd5":"F37442226DA71492"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: mengnankkzhou","link":"链接: ","source":"来源: mengnankkのblog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'mengnankkのblog',
  title: 'Mysql面试题目',
  postAI: '',
  pageFillDescription: '原理概念, 1.什么是mysql, 2.表的连接, 3.数据库的三大范式, 4.NOSQL和SQL的区别？, 5.说一下外键约束, sql语句, 1.MySQL如何避免重复插入数据？, 2.int(1) int(10) 在mysql有什么不同？, 3.Text数据类型可以无限大吗？, 4.varchar和char的区别, 5.blob和text有什么区别, 6.DATETIME和TIMESTAMP有什么区别, 7.in和exists的区别, 10.dropdeleteturncate的区别, 11.UNION和UNION ALL的区别, 12.count(*)count(1)count(列)这三种有什么区别, 13.mysql中的一些基本函数你知道哪些？, 14.sql语句的执行顺序, 15.UPDATE 语句的原理amp过程, 数据库存储, 1.记录货币, 2.如何存储emoji, 3.IP地址如何在数据库里存储？, 4.数据管理里数据文件大体分成哪几种数据文件？, sql优化, 1.慢sql问题怎么排查和解决, 2.有sql索引优化的经验吗？, 存储引擎, 1.你了解mysql的哪些存储引擎请详细的讲讲？, 2.执行一条SQL请求的过程是什么？, 3.MySQL为什么InnoDB是默认引擎？, 4.说一下mysql的innodb与MyISAM的区别？, 索引, 1.索引是什么？有什么好处？, 2.讲讲索引的分类是什么？, 3.MySQL聚簇索引和非聚簇索引的区别是什么？, 4.如果聚簇索引的数据更新它的存储要不要变化？, 5.MySQL主键是聚簇索引吗？, 6.什么字段适合当做主键？, 7.性别字段能加索引么？为啥？, 8.表中十个字段你主键用自增ID还是UUID为什么？, 9.什么自增ID更快一些UUID不快吗它在B+树里面存储是有序的吗?, 10.Mysql中的索引是怎么实现的 ？, B+树, 11.查询数据时到了B+树的叶子节点之后的查找数据是如何做？, 12.B+树的特性是什么？, 13.说说B+树和B树的区别, 14.B+树的好处是什么？, 15.B+树的叶子节点链表是单向还是双向？, 16.MySQL为什么用B+树结构？和其他结构比的优点？, 17.为什么 MysSQL 不用 跳表？, 联合索引, 1.联合索引的实现原理？, 2.创建联合索引时需要注意什么？, 3.联合索引ABC现在有个执行语句是A = XXX and C lt XXX索引怎么走, 4.联合索引(abc) 查询条件 where b gt xxx and a = x 会生效吗, 5.联合索引 (a bc)where条件是 a=2 and c = 1能用到联合索引吗？, 6.索引失效有哪些？, 7.什么情况下会回表查询, 索引原则, 1.什么是覆盖索引？, 2.如果一个列即使单列索引又是联合索引单独查它的话先走哪个？, 3.索引已经建好了那我再插入一条数据索引会有哪些变化？, 4.索引字段是不是建的越多越好？, 5.索引的优缺点？, 6.怎么决定建立哪些索引?, 7.索引优化详细讲讲, 8.了解过前缀索引吗？, 9.索引覆盖是什么, 10.索引跳跃式什么？, 11.mysql索引的类型聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？, 事务, 1.事务的特性是什么？如何实现的？, 2.mysql可能出现什么和并发相关问题？, 3.哪些场景不适合脏读举个例子？, 4.mysql的是怎么解决并发问题的？, 5.事务的隔离级别有哪些？, 6.可重复读隔离级别下A事务提交的数据在B事务能看见吗？, 7.Mysql 设置了可重读隔离级后怎么保证不发生幻读？, 8.举个例子说可重复读下的幻读问题, 9.串行化隔离级别是通过什么实现的？, 10.一条update是不是原子性的？为什么？, 11.滥用事务或者一个事务里有特别多sql的弊端？, 12.事务的两阶段提交, 锁, 1.讲一下mysql里有哪些锁？, 2.数据库的表锁和行锁有什么作用？, 3.MySQL两个线程的update语句同时处理一条数据会不会有阻塞？, 4.两条update语句处理一张表的不同的主键范围的记录一个15会不会遇到阻塞？底层是为什么的？, 5.如果2个范围不是主键或索引？还会阻塞吗？, 6.索引和锁的联系, 7.如何避免 MDL 死锁或阻塞？, 8.范围索引会造成的问题, 9.两段锁协议, 10.mysql中的死锁和死锁的解决办法检测机制, MVCC, 1.介绍MVCC实现原理, 2.MVCC的具体实现, 日志, 1.日志文件是分成了哪几种？, 2.讲一下binlog, 3.UndoLog日志的作用是什么？, 4.有了undolog为啥还需要redolog呢？, 5.redo log怎么保证持久性的？, 6.能不能只用binlog不用relo log？, 7.binlog 两阶段提交过程是怎么样的？, 8.update语句的具体执行过程是怎样的？, 9.MySQL是如何保障数据不丢失的？, 10.RedoLog是在内存里吗？, 11.为什么要写RedoLog而不是直接写到B+树里面？, 12.mysql 两次写（double write buffer）了解吗？, sql调优, 1.mysql的explain有什么作用？, 2.给你张表发现查询速度很慢你有那些解决方案, 3.如果Explain用到的索引不正确的话有什么办法干预吗？原理概念什么是是一个开源的关系型数据库现在隶属于公司是我们国内使用频率最高的一种数据库我在本地安装的是最新的版本怎么删除建立一张表使用来删除表来创建表创建表的时候可以使用来创建主键写一个升序降序的语句排序的第一依据是降序第二一依据是升序出现性能差的原因是什么可能是查询的时候使用了全表扫描也可能是查询语句过于复杂也有可能是单表数据量过大我们可以添加索引来解决大部分问题对于一些热点数据可以使用缓存表的连接内连接返回两个表中有匹配关系的行找出两张表的交集连接条件外连接不仅返回两个表中匹配的行还返回没有匹配的行用来填充想当与找并集右表没匹配的填充左表没匹配的填充交叉连接返回两张表的笛卡尔积也就是将左表的每一行与右表的每一行进行组合返回的行数是两张表行数的乘积一般用于生成排列组合或固定模板数据全外连接保留左右两表所有行能匹配的就匹配不能匹配的用补足最多为左表行数右表行数需要使用来实现因为不直接支持示例数据库的三大范式第一范式确保表的每一列都是不可分割的基本数据单元比如说用户地址应该拆分成省市区详细地址等个字段第二范式要求表中的每一列都和主键直接相关比如在订单表中商品名称单位商品价格等字段应该拆分到商品表中在的基础上非码属性必须完全依赖于候选码在基础上消除非主属性对主码的部分函数依赖第二范式需要确保数据库表中的每一列都和主键相关而不能只与主键的某一部分相关主要针对联合主键而言第三范式非主键列应该只依赖于主键列比如说在设计订单信息表的时候可以把客户名称所属公司联系方式等信息拆分到客户信息表中然后在订单信息表中用客户编号进行关联在基础上任何非主属性不依赖于其它非主属性在基础上消除传递依赖第三范式需要确保数据表中的每一列数据都和主键直接相关而不能间接相关建表的原则考虑表是否符合数据库的三大范式确保字段不可再分消除非主键依赖确保字段仅依赖于主键等然后在选择字段类型时应该尽量选择合适的数据类型在字符集上尽量选择这样不仅可以支持中文和英文还可以支持表情符号等当数据量较大时比如上千万行数据需要考虑分表比如订单表可以采用水平分表的方式来分散单表存储压力说白了就是必须是原子性的必须跟主键相关必须跟主键直接相关就是订单只放订单客户在客户表里面和的区别数据库指关系型数据库主要代表开源开源关系型数据库存储结构化数据这些数据逻辑上以行列二维表的形式存在每一列代表数据的一种属性每一行代表一个数据实体是一个实体类的映射一个实体类就相当于一个行他的属性就是列指非关系型数据库主要代表数据库逻辑上提供了不同于二维表的存储方式存储方式可以是文档哈希表或者其他方式选择考虑以下因素关系型数据库支持即原子性一致性隔离性和持续性相对而言采用更宽松的模型即基本可用软状态和最终一致性从实用的角度出发我们需要考虑对于面对的应用场景是否是必须的比如银行应用就必须保证否则一笔钱可能被使用两次又比如社交软件不必保证因为一条状态的更新对于所有用户读取先后时间有数秒不同并不影响使用对于需要保证的应用我们可以优先考虑反之则可以优先考虑扩展性对比数据之间无关系这样就非常容易扩展也无形之间在架构的层面上带来了可扩展的能力比如自带主从复制模式哨兵模式切片集群模式相反关系型数据库的数据之间存在关联性水平扩展较难需要解决跨服务器分布式事务等问题说一下外键约束外键约束的作用是维护表与表之间的关系确保数据的完整性和一致性让我们举一个简单的例子假设你有两个表一个是学生表另一个是课程表这两个表之间有一个关系即一个学生可以选修多门课程而一门课程也可以被多个学生选修在这种情况下我们可以在学生表中定义一个指向课程表的外键如下所示这里表中的字段是一个外键它指向表中的字段这个外键约束确保了每个学生所选的课程在表中都存在从而维护了数据的完整性和一致性如果没有定义外键约束那么就有可能出现学生选了不存在的课程或者删除了一个课程而忘记从学生表中删除选修该课程的学生的情况这会破坏数据的完整性和一致性因此使用外键约束可以帮助我们避免这些问题语句如何避免重复插入数据方式一使用约束在表的相关列上添加约束确保每个值在该列中唯一例如如果尝试插入重复的会返回错误方式二使用这种语句允许在插入记录时处理重复键的情况如果插入的记录与现有记录冲突可以选择更新现有记录方式三使用该语句会在插入记录时忽略那些因重复键而导致的插入错误例如如果已经存在这条插入语句将被忽略而不会返回错误选择哪种方法取决于具体的需求如果需要保证全局唯一性使用约束是最佳做法如果需要插入和更新结合可以使用对于快速忽略重复插入是合适的选择在有什么不同和的区别主要在于显示宽度而不是存储范围或数据类型本身的大小以下是核心区别的总结本质是显示宽度不改变存储方式的存储固定为字节所有无论写成还是占用的存储空间均为字节括号内的数值如或是显示宽度用于在特定场景下控制数值的展示格式唯一作用场景补零显示当字段设置时数字显示时会用前导零填充至指定宽度比如字段类型为实际存入显示为实际存入显示仍为宽度超限时不截断创建一个包含和字段的表并设置属性插入数据查询数据字段由于设置为其显示宽度为插入数据时会显示为字段设置为显示宽度为插入数据时会在前面填充零显示为数据类型可以无限大吗种类型的最大长度如下和的区别是可变长度的字符类型原则上最多可以容纳个字符但考虑字符集以及需要到个字节来表示字符串长度所以实际上最大可以设置到如果字符集是字符集字符集每个字符占用个字节那么最多可以存储个字符同时占用的存储空间最多为个字节不考虑额外的长度记录开销如果字符集是字符集它的每个字符可能占用到个字节对于的字段它最多可以存储个字符但占用的字节数会根据字符的不同而变化中空格也要占一个字节是固定长度的字符类型当定义一个字段时不管实际存储的字符长度是多少都只会占用个字符的空间如果插入的数据小于个字符剩余的部分会用空格填充分配多少就是多少和有什么区别用于存储二进制数据如图片音频等等但是实际应用中我们会把这些文件存储到或者文件服务器上数据库存储文件的用于存储文本数据如文章评论等和有什么区别直接存储日期和时间的完整值与时区无关存储的是时间戳以来的秒数受时区影响的默认值为占用个字节的默认值为当前时间占个字节实际开发中更常用因为可以自动更新和的区别使用时会首先执行子查询然后将子查询的结果集用于外部查询的条件这意味着子查询的结果集需要全部加载到内存中会对外部查询的每一行执行一次子查询如果子查询返回任何行则条件为真关注的是子查询是否返回行而不是返回的具体值的临时表可能成为性能瓶颈可以利用关联索引适用于子查询结果集较小的情况如果子查询返回大量数据的性能可能会下降因为它需要将整个结果集加载到内存适用于子查询结果集可能很大的情况由于只需要判断子查询是否返回行而不需要加载整个结果集因此在某些情况下性能更好特别是当子查询可以使用索引时值陷如果子查询的结果集中包含值可能会导致意外的结果例如如果返回则永远不会为真除非本身也为对值的处理更加直接只是检查子查询是否返回行不关心行的具体值因此不受值的影响性能差异在很多情况下的性能优于特别是当子查询的表很大时这是因为一旦找到匹配项就会立即停止查询而可能会扫描整个子查询结果集使用场景如果子查询结果集较小且不频繁变动可能更直观易懂而当子查询涉及外部查询的每一行判断并且子查询的效率较高时更为合适值处理能够正确处理子查询中包含值的情况而不受子查询结果中值的影响因为它关注的是行的存在性而不是具体值的区别都表示删除但是三者有一些差别区别类型属于属于属于回滚可回滚不可回滚不可回滚删除内容表结构还在删除表的全部或者一部分数据行表结构还在删除表中的所有数据从数据库中删除表所有数据行索引和权限也会被删除删除速度删除速度慢需要逐行删除删除速度快删除速度最快因此在不再需要一张表的时候用在想删除部分数据行时候用在保留表而删除所有数据的时候用和的区别如果使用会在表链接后筛选掉重复的记录行如果使用不会合并重复的记录行从效率上说要比快很多如果合并没有刻意要删除重复行那么就使用列这三种有什么区别统计总行数包括会读取表中的所有行但不访问具体字段的数据只是计数在大多数数据库如中数据库优化器会对其进行优化性能非常好比较推荐统计总行数本质类似数据库会把作为一个常量值对所有行都有效与区别理论上相同因为永远不为相当于每行都有值实际执行时性能几乎一致有些数据库会将其优化为有些人误以为比快这在现代数据库中已经不成立列统计指定列中非的行数关键区别会忽略该列为的记录需要访问该列的值性能可能稍低可用于判断某一字段是否完整填充或做数据质量检查中的一些基本函数你知道哪些一字符串函数连接多个字符串返回一个合并后的字符串返回字符串的长度字符数从指定位置开始截取指定长度的子字符串将字符串中的某部分替换为另一个字符串二数值函数返回数字的绝对值返回指定数字的指定幂次方三日期和时间函数返回当前日期和时间返回当前日期四聚合函数计算指定列中的非值的个数计算指定列的总和计算指定列的平均值返回指定列的最大值返回指定列的最小值语句的执行顺序首先确定查询数据来源的表包括进行表的连接操作在这个阶段会根据子句和子句生成一个虚拟表针对子句中的条件进行筛选满足条件的行会进入下一步根据类型如将条件过滤后的结果与主表或连接表进行组合生成一个新的虚拟表对上一步生成的虚拟表进行行级别的过滤所有不满足条件的行都会被排除将满足条件的行按照子句中指定的列进行分组对聚合后的结果进行组级别的过滤只有满足条件的组才会被保留根据列表中指定的列表达式或聚合函数从过滤后的组中选择数据如果子句中包含关键字则会在此步骤移除重复的行对语句返回的结果集进行排序或最后根据或中为子句限制返回的行数或指定从哪一行开始返回语句的原理过程核心目标是在确保数据完整性和一致性的前提下修改数据库中的现有记录事务层面每次操作通常都在一个事务中执行即使你没有显式地使用或数据库系统也会隐式地为每个语句创建一个事务在修改数据之前数据库会将修改前的数据和修改后的数据写入这个日志主要用于崩溃恢复确保即使系统发生故障也能够通过重放日志来恢复数据到一致状态同时为了支持事务回滚数据库还会记录记录了数据修改前的状态如果事务需要回滚数据库就可以利用将数据恢复到更新之前的状态锁层面为了保证数据在并发更新时的正确性数据库会使用锁定机制行级锁语句通常会尽可能地使用行级锁这意味着只有被更新的行才会被锁定从而最大限度地提高并发性其他事务仍然可以访问或修改表中未被锁定的行锁的持有时间锁的粒度取决于数据库系统和具体的配置锁会在事务提交或回滚时被释放死锁如果多个事务互相等待对方释放锁就可能发生死锁数据库系统通常有死锁检测和解决机制例如通过回滚其中一个事务来打破死锁数据页层面读取数据页数据库首先会从磁盘读取包含待更新数据的页到内存缓冲池在内存中修改在内存中数据库会对数据页中的相关记录进行修改脏页被修改过的内存中的数据页被称为脏页刷盘脏页不会立即写回磁盘而是由后台进程如线程在适当的时候异步地写入磁盘这样做可以减少磁盘提高性能事务日志的写入通常比数据页的写入更快且更频繁因为日志是顺序写入的而数据页的写入是随机的先写入再进行异步刷盘这就是索引层面如果操作修改了包含索引的列那么相关的索引也需要同步更新索引对于索引更新操作可能导致索引树的结构调整例如节点分裂或合并以保持索引的平衡和查询效率比如新建节点的时候会把当前节点一分为二后面的作为新节点新节点连接旧节点的兄弟节点旧节点连接新节点的兄弟节点层面当发生时通常不是直接修改现有行而是创建该行的一个新版本并标记旧版本为已删除或不可见这样正在读取旧版本的事务就不会受到影响执行过程解析数据库接收到语句后首先对其进行词法分析语法分析生成一个抽象语法树检查语句中的表名列名是否存在数据类型是否匹配以及用户是否有足够的权限执行更新操作查询优化器会根据统计信息和各种优化算法生成一个或多个执行计划对于语句优化器会确定最有效的方式来定位需要更新的行这可能涉及到选择合适的索引事务开始和锁定如果当前没有活跃的事务数据库会为这条语句隐式地开始一个新事务为了保证数据在更新过程中的一致性和隔离性数据库会获取必要的锁通常是针对被更新的行获取行级排他锁这意味着其他事务在当前事务提交或回滚前无法修改这些被锁定的行数据读取和修改读取数据页数据库将包含待更新数据行的磁盘数据页读取到内存的缓冲池中在修改数据之前数据库会将这些行修改前的原始数据即旧版本写入到撤销日志中主要用于事务回滚如果语句失败或被回滚数据库可以利用将数据恢复到原始状态在缓冲池中数据库对数据行进行实际的修改这包括更新列的值如果涉及到变长字段可能还需要调整记录的物理大小被修改过的内存数据页被称为脏页写入在内存中的数据被修改后数据库会将此次修改操作的详细信息新版本数据以及修改操作本身写入到重做日志中是保证持久性的关键它记录了对数据库所做的所有修改即使数据库崩溃也可以通过重放来恢复数据的写入通常遵循预写日志原则即在数据页写入磁盘之前必须先将对应的记录写入磁盘这保证了即使系统崩溃内存中的脏页没有来得及刷回磁盘也能通过恢复数据索引更新如果语句修改了包含索引的列数据库还需要更新这些相关的索引事务提交和锁的释放当语句成功执行并且其所在的事务被提交时事务日志会确保已经刷写到磁盘一旦事务提交所有由该事务持有的锁都会被释放使得其他等待的事务可以继续执行内存中的脏页会由后台线程异步地刷写到磁盘通常不需要等待事务提交后立即刷盘以提高性能事务回滚如果在过程中发生错误或者事务被显式回滚数据库会利用之前记录的将所有已经进行的修改操作撤销使数据回到事务开始之前的状态数据库存储记录货币货币在数据库中常用和类型表示这两种类型被实现为同样的类型他们被用于保存与货币有关的数据代表将被用于存储值的总的小数位数而代表将被用于存储小数点后的位数存储在列中的值的范围是从到不使用或者的原因因为和是以二进制存储的所以有一定的误差会出现大问题的如何存储字符集仅支持最多个字节的字符但是表情是个字节的字符所以在中存储表情时需要使用字符集地址如何在数据库里存储地址是一个位的二进制数通常以点分十进制表示法呈现例如字符串类型的存储方式直接将地址作为字符串存储在数据库中比如可以用来存储创建一个表使用类型存储地址插入数据优点直观易懂方便直接进行数据的插入查询和显示不需要进行额外的转换操作缺点占用存储空间较大字符串比较操作的性能相对较低不利于进行范围查询整数类型的存储方式将地址转换为位无符号整数进行存储常用的数据类型有创建一个表使用类型存储地址插入数据需要先将地址转换为整数查询时将整数转换回地址优点占用存储空间小整数比较操作的性能较高便于进行范围查询缺点需要进行额外的转换操作不够直观增加了开发的复杂度数据管理里数据文件大体分成哪几种数据文件我们每创建一个数据库都会在目录里面创建一个以为名的目录然后保存表结构和表数据的文件都会存放在这个目录里比如我这里有一个名为的该里有一张名为数据库表然后我们进入目录看看里面有什么文件可以看到共有三个文件这三个文件分别代表着用来存储当前数据库的默认字符集和字符校验规则的表结构会保存在这个文件在中建立一张表都会生成一个文件该文件是用来保存每个表的元数据信息的主要包含表结构定义的表数据会保存在这个文件表数据既可以存在共享表空间文件文件名里也可以存放在独占表空间文件文件名表名字这个行为是由参数控制的若设置了参数为则会将存储的数据索引等信息单独存储在一个独占表空间从版本开始它的默认值就是了因此从这个版本之后中每一张表的数据都存放在一个独立的文件优化慢问题怎么排查和解决分析查询语句使用命令分析执行计划找出慢查询的原因比如是否使用了全表扫描是否存在索引未被利用的情况等并根据相应情况对索引进行适当修改创建或优化索引根据查询条件创建合适的索引特别是经常用于子句的字段排序的字段连表查询的字典的字段并且如果查询中经常涉及多个字段考虑创建联合索引使用联合索引要符合最左匹配原则不然会索引失效避免索引失效比如不要用左模糊匹配函数计算表达式计算等等查询优化避免使用只查询真正需要的列使用覆盖索引即索引包含所有查询的字段联表查询最好要以小表驱动大表并且被驱动表的字段要有索引当然最好通过冗余字段的设计避免联表查询分页优化针对深分页的查询优化可以把查询转换成某个位置的查询该方案适用于主键自增的表读写分离搭建主从架构利用数据库的读写分离服务器在写数据的时候访问主数据库主数据库通过主从复制将数据更新同步到从数据库这样当服务器读数据的时候就可以通过从数据库获得数据这一方案使得在大量读操作的应用可以轻松地读取数据而主数据库也只会承受少量的写入操作还可以实现数据热备份可谓是一举两得优化数据库表如果单表的数据超过了千万级别考虑是否需要将大表拆分为小表减轻单个表的查询压力也可以将字段多的表分解成多个表有些字段使用频率高有些低数据量大时会由于使用频率低的存在而变慢可以考虑分开使用缓存技术引入缓存层如存储热点数据和频繁查询的结果但是要考虑缓存一致性的问题对于读请求会选择旁路缓存策略对于写请求会选择先更新再删除缓存的策略有索引优化的经验吗常见优化索引的方法前缀索引优化使用前缀索引是为了减小索引字段大小可以增加一个索引页中存储的索引值有效提高索引的查询速度在一些大字符串的字段作为索引时使用前缀索引可以帮助我们减小索引项的大小覆盖索引优化覆盖索引是指中的所有字段在索引的叶子节点上都能找得到的那些索引从二级索引中查询得到记录而不需要通过聚簇索引查询获得可以避免回表的操作主键索引最好是自增的如果我们使用自增主键那么每次插入的新数据就会按顺序添加到当前索引节点的位置不需要移动已有的数据当页面写满就会自动开辟一个新页面因为每次插入一条新记录都是追加操作不需要重新移动数据因此这种插入数据的方法效率非常高如果我们使用非自增主键由于每次插入主键的索引值都是随机的因此每次插入新的数据时就可能会插入到现有数据页中间的某个位置这将不得不移动其它数据来满足新数据的插入甚至需要从一个页面复制数据到另外一个页面我们通常将这种情况称为页分裂页分裂还有可能会造成大量的内存碎片导致索引结构不紧凑从而影响查询效率防止索引失效当我们使用左或者左右模糊匹配的时候也就是或者这两种方式都会造成索引失效当我们在查询条件中对索引列做了计算函数类型转换操作这些情况下都会造成索引失效联合索引要能正确使用需要遵循最左匹配原则也就是按照最左优先的方式进行索引的匹配否则就会导致索引失效在子句中如果在前的条件列是索引列而在后的条件列不是索引列那么索引会失效存储引擎你了解的哪些存储引擎请详细的讲讲是的默认存储引擎具有事务支持行级锁外键约束等特性它适用于高并发的读写操作支持较好的数据完整性和并发控制是的另一种常见的存储引擎具有较低的存储空间和内存消耗适用于大量读操作的场景然而不支持事务行级锁和外键约束因此在并发写入和数据完整性方面有一定的限制引擎将数据存储在内存中适用于对性能要求较高的读操作但是在服务器重启或崩溃时数据会丢失它不支持事务行级锁和外键约束执行一条请求的过程是什么先来一个上帝视角图下面就是执行一条查询语句的流程也从图中可以看到内部架构里的各个功能模块连接器建立连接管理连接校验用户身份查询缓存查询语句如果命中查询缓存则直接返回否则继续往下执行已删除该模块解析通过解析器对查询语句进行词法分析语法分析然后构建语法树方便后续模块读取表名字段语句类型执行执行共有三个阶段预处理阶段检查表或字段是否存在将中的符号扩展为表上的所有列优化阶段基于查询成本的考虑选择查询成本最小的执行计划比如索引执行阶段根据执行计划执行查询语句从存储引擎读取记录返回给客户端为什么是默认引擎引擎在事务支持并发性能崩溃恢复等方面具有优势因此被选择为默认的存储引擎事务支持引擎提供了对事务的支持可以进行原子性一致性隔离性持久性属性的操作存储引擎是不支持事务的并发性能引擎采用了行级锁定的机制可以提供更好的并发性能存储引擎只支持表锁锁的粒度比较大崩溃恢复引引擎通过日志实现了崩溃恢复可以在数据库发生异常情况如断电时通过日志文件进行恢复保证数据的持久性和一致性是不支持崩溃恢复的说一下的与的区别事务支持事务不支持事务这是将默认存储引擎从变成的重要原因之一索引结构是聚簇索引是非聚簇索引聚簇索引的文件存放在主键索引的叶子节点上因此必须要有主键通过主键索引效率很高但是辅助索引需要两次查询先查询到主键然后再通过主键查询到数据因此主键不应该过大因为主键太大其他索引也都会很大而是非聚簇索引数据文件是分离的索引保存的是数据文件的指针主键索引和辅助索引是独立的锁粒度最小的锁粒度是行锁最小的锁粒度是表锁一个更新语句会锁住整张表导致其他查询和更新都会被阻塞因此并发访问受限的效率不保存表的具体行数执行时需要全表扫描而用一个变量保存了整个表的行数执行上述语句时只需要读出该变量即可速度很快索引索引是什么有什么好处索引类似于书籍的目录可以减少扫描的数据量提高查询效率如果查询的时候没有用到索引就会全表扫描这时候查询的时间复杂度是如果用到了索引那么查询的时候可以基于二分查找算法通过索引快速定位到目标数据索引的数据结构一般是树其搜索复杂度为其中表示节点允许的最大子节点个数为个讲讲索引的分类是什么可以按照四个角度来分类索引按数据结构分类索引索引索引按物理存储分类聚簇索引主键索引二级索引辅助索引按字段特性分类主键索引唯一索引普通索引前缀索引按字段个数分类单列索引联合索引接下来按照这些角度来说说各类索引的特点按数据结构分类从数据结构的角度来看常见索引有索引索引索引每一种存储引擎支持的索引类型不一定相同我在表中总结了常见的存储引擎和分别支持的索引类型是在之后成为默认的存储引擎索引类型也是存储引擎采用最多的索引类型在创建表时存储引擎会根据不同的场景选择不同的列作为索引如果有主键默认会使用主键作为聚簇索引的索引键如果没有主键就选择第一个不包含值的唯一列作为聚簇索引的索引键在上面两个都没有的情况下将自动生成一个隐式自增列作为聚簇索引的索引键其它索引都属于辅助索引也被称为二级索引或非聚簇索引创建的主键索引和二级索引默认使用的是索引按物理存储分类从物理存储的角度来看索引分为聚簇索引主键索引二级索引辅助索引这两个区别在前面也提到了主键索引的的叶子节点存放的是实际数据所有完整的用户记录都存放在主键索引的的叶子节点里二级索引的的叶子节点存放的是主键值而不是实际数据所以在查询时使用了二级索引如果查询的数据能在二级索引里查询的到那么就不需要回表这个过程就是覆盖索引如果查询的数据不在二级索引里就会先检索二级索引找到对应的叶子节点获取到主键值后然后再检索主键索引就能查询到数据了这个过程就是回表按字段特性分类从字段特性的角度来看索引分为主键索引唯一索引普通索引前缀索引主键索引主键索引就是建立在主键字段上的索引通常在创建表的时候一起创建一张表最多只有一个主键索引索引列的值不允许有空值在创建表时创建主键索引的方式如下唯一索引唯一索引建立在字段上的索引一张表可以有多个唯一索引索引列的值必须唯一但是允许有空值在创建表时创建唯一索引的方式如下建表后如果要创建唯一索引可以使用这面这条命令普通索引普通索引就是建立在普通字段上的索引既不要求字段为主键也不要求字段为在创建表时创建普通索引的方式如下建表后如果要创建普通索引可以使用这面这条命令前缀索引前缀索引是指对字符类型字段的前几个字符建立的索引而不是在整个字段上建立的索引前缀索引可以建立在字段类型为的列上使用前缀索引的目的是为了减少索引占用的存储空间提升查询效率在创建表时创建前缀索引的方式如下建表后如果要创建前缀索引可以使用这面这条命令按字段个数分类从字段个数的角度来看索引分为单列索引联合索引复合索引建立在单列上的索引称为单列索引比如主键索引建立在多列上的索引称为联合索引通过将多个字段组合成一个索引该索引就被称为联合索引比如将商品表中的和字段组合成联合索引创建联合索引的方式如下联合索引的示意图如下图中叶子节点之间我画了单向链表但是实际上是双向链表原图我找不到了修改不了偷个懒我不重画了大家脑补成双向链表就行可以看到联合索引的非叶子节点用两个字段的值作为的值当在联合索引查询数据时先按字段比较在相同的情况下再按字段比较也就是说联合索引查询的是先按进行排序然后再相同的情况再按字段排序因此使用联合索引时存在最左匹配原则也就是按照最左优先的方式进行索引的匹配在使用联合索引进行查询的时候如果不遵循最左匹配原则联合索引会失效这样就无法利用到索引快速查询的特性了比如如果创建了一个联合索引如果查询条件是以下这几种就可以匹配上联合索引需要注意的是因为有查询优化器所以字段在子句的顺序并不重要但是如果查询条件是以下这几种因为不符合最左匹配原则所以就无法匹配上联合索引联合索引就会失效上面这些查询条件之所以会失效是因为联合索引是先按排序在相同的情况再按排序在相同的情况再按排序所以和是全局无序局部相对有序的这样在没有遵循最左匹配原则的情况下是无法利用到索引的联合索引有一些特殊情况并不是查询过程使用了联合索引查询就代表联合索引中的所有字段都用到了联合索引进行索引查询也就是可能存在部分字段用到联合索引的部分字段没有用到联合索引的的情况这种特殊情况就发生在范围查询联合索引的最左匹配原则会一直向右匹配直到遇到范围查询就会停止匹配也就是范围查询的字段可以用到联合索引但是在范围查询字段的后面的字段无法用到联合索引聚簇索引和非聚簇索引的区别是什么数据存储在聚簇索引中数据行按照索引键值的顺序存储也就是说索引的叶子节点包含了实际的数据行这意味着索引结构本身就是数据的物理存储结构非聚簇索引的叶子节点不包含完整的数据行而是包含指向数据行的指针或主键值数据行本身存储在聚簇索引中索引与数据关系由于数据与索引紧密相连当通过聚簇索引查找数据时可以直接从索引中获得数据行而不需要额外的步骤去查找数据所在的位置当通过非聚簇索引查找数据时首先在非聚簇索引中找到对应的主键值然后通过这个主键值回溯到聚簇索引中查找实际的数据行这个过程称为回表唯一性聚簇索引通常是基于主键构建的因此每个表只能有一个聚簇索引因为数据只能有一种物理排序方式一个表可以有多个非聚簇索引因为它们不直接影响数据的物理存储位置效率对于范围查询和排序查询聚簇索引通常更有效率因为它避免了额外的寻址开销非聚簇索引在使用覆盖索引进行查询时效率更高因为它不需要读取完整的数据行但是需要进行回表的操作使用非聚簇索引效率比较低因为需要进行额外的回表操作如果聚簇索引的数据更新它的存储要不要变化如果更新的数据是非索引数据也就是普通的用户记录那么存储结构是不会发生变化如果更新的数据是索引数据那么存储结构是有变化的因为要维护树的有序性主键是聚簇索引吗在的存储引擎中主键确实是以聚簇索引的形式存储的将数据存储在树的结构中其中主键索引的树就是所谓的聚簇索引这意味着表中的数据行在物理上是按照主键的顺序排列的聚簇索引的叶节点包含了实际的数据行在创建聚簇索引时会根据不同的场景选择不同的列作为索引如果有主键默认会使用主键作为聚簇索引的索引键如果没有主键就选择第一个不包含值的唯一列作为聚簇索引的索引键在上面两个都没有的情况下将自动生成一个隐式自增列作为聚簇索引的索引键一张表只能有一个聚簇索引那为了实现非主键字段的快速搜索就引出了二级索引非聚簇索引辅助索引它也是利用了树的数据结构但是二级索引的叶子节点存放的是主键值不是实际数据什么字段适合当做主键字段具有唯一性且不能为空的特性字段最好的是有递增的趋势的如果字段的值是随机无序的可能会引发页分裂的问题造型性能影响不建议用业务数据作为主键比如会员卡号订单号学生号之类的因为我们无法预测未来会不会因为业务需要而出现业务字段重复或者重用的情况通常情况下会用自增字段来做主键对于单机系统来说是没问题的但是如果有多台服务器各自都可以录入数据那就不一定适用了因为如果每台机器各自产生的数据需要合并就可能会出现主键重复的问题这时候就需要考虑分布式的方案了性别字段能加索引么为啥不建议针对性别字段加索引实际上与索引创建规则之一区分度有关性别字段假设有数据男女区别度几乎等于区分度的计算方式实际上对于性别字段不适合创建索引是因为操作还得进行次回表操作根据主键从聚簇索引中找到其他字段这一部分开销从上面的测试来说还是比较大的所以从性能角度来看不建议性别字段加索引加上索引并不是索引失效而是回表操作使得变慢的既然走索引的查询的成本比全表扫描高优化器就会选择全表扫描的方向进行查询这时候建立的性别字段索引就没有启到加快查询的作用反而还因为创建了索引占用了空间表中十个字段你主键用自增还是为什么用的是自增因为相对顺序的自增来说是毫无规律可言的新行的值不一定要比之前的主键的值要大所以无法做到总是把新行插入到索引的最后而是需要为新行寻找新的合适的位置从而来分配新的空间这个过程需要做很多额外的操作数据的毫无顺序会导致数据分布散乱将会导致以下的问题写入的目标页很可能已经刷新到磁盘上并且从缓存上移除或者还没有被加载到缓存中在插入之前不得不先找到并从磁盘读取目标页到内存中这将导致大量的随机因为写入是乱序的不得不频繁的做页分裂操作以便为新的行分配空间页分裂导致移动大量的数据影响性能由于频繁的页分裂页会变得稀疏并被不规则的填充最终会导致数据会有碎片结论使用应该尽可能的按主键的自增顺序插入并且尽可能使用单调的增加的聚簇键的值来插入新行什么自增更快一些不快吗它在树里面存储是有序的吗自增的主键的值是顺序的所以把每一条记录都存储在一条记录的后面所以自增更快的原因下一条记录就会写入新的页中一旦数据按照这种顺序的方式加载主键页就会近乎于顺序的记录填满提升了页面的最大填充率不会有页的浪费新插入的行一定会在原有的最大数据行下一行定位和寻址很快不会为计算新行的位置而做出额外的消耗减少了页分裂和碎片的产生但是不是递增的中索引的数据结构是这种数据结构的特点是索引树上的节点的数据是有序的而如果使用作为主键那么每次插入数据时因为无法保证每次产生的有序所以就会出现新的需要插入到索引树的中间去这样可能会频繁地导致页分裂使性能下降而且太占用内存每个由个字符组成在字符串进行比较时需要从前往后比较字符串越长性能越差另外字符串越长占用的内存越大由于页的大小是固定的这样一个页上能存放的关键字数量就会越少这样最终就会导致索引树的高度越大在索引搜索的时候发生的磁盘次数越多性能越差中的索引是怎么实现的引擎是用了树作为了索引的数据结构是一种多叉树叶子节点才存放数据非叶子节点只存放索引而且每个节点里的数据是按主键顺序存放的每一层父节点的索引值都会出现在下层子节点的索引值中因此在叶子节点中包括了所有的索引值信息并且每一个叶子节点都有两个指针分别指向下一个叶子节点和上一个叶子节点形成一个双向链表主键索引的如图所示比如我们执行了下面这条查询语句这条语句使用了主键索引查询号为的商品查询过程是这样的会自顶向下逐层进行查找将与根节点的索引数据比较在和之间所以根据的搜索逻辑找到第二层的索引数据在第二层的索引数据中进行查找因为在和之间所以找到第三层的索引数据在叶子节点的索引数据中进行查找然后我们找到了索引值为的行数据数据库的索引和数据都是存储在硬盘的我们可以把读取一个节点当作一次磁盘操作那么上面的整个查询过程一共经历了个节点也就是进行了次操作存储千万级的数据只需要层高度就可以满足这意味着从千万级的表查询目标数据最多需要次磁盘所以相比于树和二叉树来说最大的优势在于查询效率很高因为即使在数据量很大的情况查询一个数据的磁盘依然维持在次树查询数据时到了树的叶子节点之后的查找数据是如何做数据页中的记录按照主键顺序组成单向链表单向链表的特点就是插入删除非常方便但是检索效率不高最差的情况下需要遍历链表上的所有节点才能完成检索因此数据页中有一个页目录起到记录的索引作用就像我们书那样针对书中内容的每个章节设立了一个目录想看某个章节的时候可以查看目录快速找到对应的章节的页数而数据页中的页目录就是为了能快速找到记录那是如何给记录创建页目录的呢页目录与记录的关系如下图页目录创建的过程如下将所有的记录划分成几个组这些记录包括最小记录和最大记录但不包括标记为已删除的记录每个记录组的最后一条记录就是组内最大的那条记录并且最后一条记录的头信息中会存储该组一共有多少条记录作为字段上图中粉红色字段页目录用来存储每组最后一条记录的地址偏移量这些地址偏移量会按照先后顺序存储起来每组的地址偏移量也被称之为槽每个槽相当于指针指向了不同组的最后一个记录从图可以看到页目录就是由多个槽组成的槽相当于分组记录的索引然后因为记录是按照主键值从小到大排序的所以我们通过槽查找记录时可以使用二分法快速定位要查询的记录在哪个槽哪个记录分组定位到槽后再遍历槽内的所有记录找到对应的记录无需从最小记录开始遍历整个页中的记录链表以上面那张图举个例子个槽的编号分别为我想查找主键为的用户记录先二分得出槽中间位是号槽里最大的记录为因为所以需要从号槽后继续搜索记录再使用二分搜索出号和槽的中间位是号槽里最大的记录为因为所以主键为的记录在号槽里再从号槽指向的主键值为记录开始向下搜索次定位到主键为的记录取出该条记录的信息即为我们想要查找的内容树的特性是什么所有叶子节点都在同一层这是树的一个重要特性确保了所有数据项的检索都具有相同的延迟提高了搜索效率每个叶子节点都包含指向相邻叶子节点的指针形成一个链表由于叶子节点之间的链接树非常适合进行范围查询和排序扫描可以沿着叶子节点的链表顺序访问数据而无需进行多次随机访问非叶子节点存储键值非叶子节点仅存储键值和指向子节点的指针不包含数据记录这些键值用于指导搜索路径帮助快速定位到正确的叶子节点并且由于非叶子节点只存放键值当数据量比较大时相对于树树的层高更少查找效率也就更高叶子节点存储数据记录与树不同树的叶子节点存储实际的数据记录或指向数据记录的指针这意味着每次搜索都会到达叶子节点才能找到所需数据自平衡树在插入删除和更新操作后会自动重新平衡确保树的高度保持相对稳定从而保持良好的搜索性能每个节点最多可以有个子节点最少可以有个子节点除了根节点这里的是树的阶数说说树和树的区别在树中数据都存储在叶子节点上而非叶子节点只存储索引信息而树的非叶子节点既存储索引信息也存储部分数据树的叶子节点使用链表相连便于范围查询和顺序访问树的叶子节点没有链表连接树的查找性能更稳定每次查找都需要查找到叶子节点而树的查找可能会在非叶子节点找到数据性能相对不稳定树的好处是什么树和都是通过多叉树的方式会将树的高度变矮所以这两个数据结构非常适合检索存于磁盘中的数据但是默认的存储引擎采用的是作为索引的数据结构原因有树的非叶子节点不存放实际的记录数据仅存放索引因此数据量相同的情况下相比存储即存索引又存记录的树树的非叶子节点可以存放更多的索引因此树可以比树更矮胖查询底层节点的磁盘次数会更少树有大量的冗余节点所有非叶子节点都是冗余索引这些冗余索引让树在插入删除的效率都更高比如删除根节点的时候不会像树那样会发生复杂的树的变化树叶子节点之间用链表连接了起来有利于范围查询而树要实现范围查询因此只能通过树的遍历来完成范围查询这会涉及多个节点的磁盘操作范围查询效率不如树树的叶子节点链表是单向还是双向双向的为了实现倒序遍历或者排序使用的树有一些特别的点比如树的叶子节点之间是用双向链表进行连接这样的好处是既能向右遍历也能向左遍历树点节点内容是数据页数据页里存放了用户的记录以及各种信息每个数据页默认大小是根据索引类型不同分为聚集和二级索引他们区别在于聚集索引的叶子节点存放的是实际数据所有完整的用户记录都存放在聚集索引的叶子节点而二级索引的叶子节点存放的是主键值而不是实际数据因为表的数据都是存放在聚集索引的叶子节点里所以存储引擎一定会为表创建一个聚集索引且由于数据在物理上只会保存一份所以聚簇索引只能有一个而二级索引可以创建多个为什么用树结构和其他结构比的优点只在叶子节点存储数据而树的非叶子节点也要存储数据所以的单个节点的数据量更小在相同的磁盘次数下就能查询更多的节点另外叶子节点采用的是双链表连接适合中常见的基于范围的顺序查找而树无法做到这一点二叉树对于有个叶子节点的其搜索复杂度为其中表示节点允许的最大子节点个数为个在实际的应用当中值是大于的这样就保证了即使数据达到千万级别时的高度依然维持在层左右也就是说一次数据查询操作只需要做次的磁盘操作就能查询到目标数据而二叉树的每个父节点的儿子节点个数只能是个意味着其搜索复杂度为这已经比高出不少因此二叉树检索到目标数据所经历的磁盘次数要更多在做等值查询的时候效率贼快搜索复杂度为但是表不适合做范围查询它更适合做等值的查询这也是索引要比表索引有着更广泛的适用场景的原因为什么不用跳表树的高度在层时存储的数据可能已达千万级别但对于跳表而言同样去维护千万的数据量那么所造成的跳表层数过高而导致的磁盘次数增多也就是使用树在存储同样的数据下磁盘次数更少联合索引联合索引的实现原理将将多个字段组合成一个索引该索引就被称为联合索引比如将商品表中的和字段组合成联合索引创建联合索引的方式如下联合索引的示意图如下可以看到联合索引的非叶子节点用两个字段的值作为的值当在联合索引查询数据时先按字段比较在相同的情况下再按字段比较也就是说联合索引查询的是先按进行排序然后再相同的情况再按字段排序因此使用联合索引时存在最左匹配原则也就是按照最左优先的方式进行索引的匹配在使用联合索引进行查询的时候如果不遵循最左匹配原则联合索引会失效这样就无法利用到索引快速查询的特性了比如如果创建了一个联合索引如果查询条件是以下这几种就可以匹配上联合索引需要注意的是因为有查询优化器所以字段在子句的顺序并不重要但是如果查询条件是以下这几种因为不符合最左匹配原则所以就无法匹配上联合索引联合索引就会失效上面这些查询条件之所以会失效是因为联合索引是先按排序在相同的情况再按排序在相同的情况再按排序所以和是全局无序局部相对有序的这样在没有遵循最左匹配原则的情况下是无法利用到索引的我这里举联合索引的例子该联合索引的如下可以看到是全局有序的而是全局是无序的因此直接执行这种查询条件没有办法利用联合索引的利用索引的前提是索引里的是有序的只有在相同的情况才才是有序的比如等于的时候的值为这时就是有序的这个有序状态是局部的因此执行是和字段能用到联合索引的也就是联合索引生效了创建联合索引时需要注意什么建立联合索引时的字段顺序对索引效率也有很大影响越靠前的字段被用于索引过滤的概率越高实际开发工作中建立联合索引时要把区分度大的字段排在前面这样区分度大的字段越有可能被更多的使用到区分度就是某个字段不同值的个数除以表的总行数计算公式如下比如性别的区分度就很小不适合建立索引或不适合排在联合索引列的靠前的位置而这类字段就比较适合做索引或排在联合索引列的靠前的位置因为如果索引的区分度很小假设字段的值分布均匀那么无论搜索哪个值都可能得到一半的数据在这些情况下还不如不要索引因为还有一个查询优化器查询优化器发现某个值出现在表的数据行中的百分比惯用的百分比界线是很高的时候它一般会忽略索引进行全表扫描联合索引现在有个执行语句是索引怎么走根据最左匹配原则可以走联合索引不会走联合索引但是可以走索引下推联合索引查询条件会生效吗索引会生效和字段都能利用联合索引符合联合索引最左匹配原则联合索引条件是能用到联合索引吗会用到联合索引但是只有才能走索引无法走索引因为不符合最左匹配原则虽然无法走索引但是字段在版本之后会有索引下推的优化能减少回表查询的次数索引失效有哪些种会发生索引失效的情况当我们使用左或者左右模糊匹配的时候也就是或者这两种方式都会造成索引失效当我们在查询条件中对索引列使用函数就会导致索引失效当我们在查询条件中对索引列进行表达式计算也是无法走索引的在遇到字符串和数字比较的时候会自动把字符串转为数字然后再进行比较如果字符串是索引列而条件语句中的输入参数是数字的话那么索引列会发生隐式类型转换由于隐式类型转换是通过函数实现的等同于对索引列使用了函数所以就会导致索引失效联合索引要能正确使用需要遵循最左匹配原则也就是按照最左优先的方式进行索引的匹配否则就会导致索引失效在子句中如果在前的条件列是索引列而在后的条件列不是索引列那么索引会失效什么情况下会回表查询从物理存储的角度来看索引分为聚簇索引主键索引二级索引辅助索引它们的主要区别如下主键索引的的叶子节点存放的是实际数据所有完整的用户记录都存放在主键索引的的叶子节点里二级索引的的叶子节点存放的是主键值而不是实际数据所以在查询时使用了二级索引如果查询的数据能在二级索引里查询的到那么就不需要回表这个过程就是覆盖索引如果查询的数据不在二级索引里就会先检索二级索引找到对应的叶子节点获取到主键值后然后再检索主键索引就能查询到数据了这个过程就是回表索引原则什么是覆盖索引覆盖索引是指一个索引包含了查询所需的所有列因此不需要访问表中的数据行就能完成查询换句话说查询所需的所有数据都能从索引中直接获取而不需要进行回表查询覆盖索引能够显著提高查询性能因为减少了访问数据页的次数从而减少了操作假设有一张表表结构如下如果我们有以下查询在这种情况下是一个覆盖索引因为它包含了查询所需的所有列和查询可以完全在索引层完成而不需要访问表中的数据行如果一个列即使单列索引又是联合索引单独查它的话先走哪个优化器会分析每个索引的查询成本然后选择成本最低的方案来执行如果单列索引是联合索引是那么针对下面这个查询优化器会选择联合索引因为查询成本更低查询也不需要回表直接索引覆盖了索引已经建好了那我再插入一条数据索引会有哪些变化插入新数据可能导致树结构的调整和索引信息的更新以保持树的平衡性和正确性这些变化通常由数据库系统自动处理确保数据的一致性和索引的有效性如果插入的数据导致叶子节点已满可能会触发叶子节点的分裂操作以保持树的平衡性索引字段是不是建的越多越好不是建的的越多会占用越多的空间而且在写入频繁的场景下对于树的维护所付出的性能消耗也会越大索引的优缺点索引最大的好处是提高查询速度但是索引也是有缺点的比如需要占用物理空间数量越大占用空间越大创建索引和维护索引要耗费时间这种时间随着数据量的增加而增大会降低表的增删改的效率因为每次增删改索引树为了维护索引有序性都需要进行动态维护所以索引不是万能钥匙它也是根据场景来使用的怎么决定建立哪些索引什么时候适用索引字段有唯一性限制的比如商品编码经常用于查询条件的字段这样能够提高整个表的查询速度如果查询条件不是一个字段可以建立联合索引经常用于和的字段这样在查询的时候就不需要再去做一次排序了因为我们都已经知道了建立索引之后在中的记录都是排序好的什么时候不需要创建索引条件里用不到的字段索引的价值是快速定位如果起不到定位的字段通常是不需要创建索引的因为索引是会占用物理空间的字段中存在大量重复数据不需要创建索引比如性别字段只有男女如果数据库表中男女的记录分布均匀那么无论搜索哪个值都可能得到一半的数据在这些情况下还不如不要索引因为还有一个查询优化器查询优化器发现某个值出现在表的数据行中的百分比很高的时候它一般会忽略索引进行全表扫描表数据太少的时候不需要创建索引经常更新的字段不用创建索引比如不要对电商项目的用户余额建立索引因为索引字段频繁修改索引优化详细讲讲常见优化索引的方法前缀索引优化使用前缀索引是为了减小索引字段大小可以增加一个索引页中存储的索引值有效提高索引的查询速度在一些大字符串的字段作为索引时使用前缀索引可以帮助我们减小索引项的大小覆盖索引优化覆盖索引是指中的所有字段在索引的叶子节点上都能找得到的那些索引从二级索引中查询得到记录而不需要通过聚簇索引查询获得可以避免回表的操作主键索引最好是自增的如果我们使用自增主键那么每次插入的新数据就会按顺序添加到当前索引节点的位置不需要移动已有的数据当页面写满就会自动开辟一个新页面因为每次插入一条新记录都是追加操作不需要重新移动数据因此这种插入数据的方法效率非常高如果我们使用非自增主键由于每次插入主键的索引值都是随机的因此每次插入新的数据时就可能会插入到现有数据页中间的某个位置这将不得不移动其它数据来满足新数据的插入甚至需要从一个页面复制数据到另外一个页面我们通常将这种情况称为页分裂页分裂还有可能会造成大量的内存碎片导致索引结构不紧凑从而影响查询效率防止索引失效当我们使用左或者左右模糊匹配的时候也就是或者这两种方式都会造成索引失效当我们在查询条件中对索引列做了计算函数类型转换操作这些情况下都会造成索引失效联合索引要能正确使用需要遵循最左匹配原则也就是按照最左优先的方式进行索引的匹配否则就会导致索引失效在子句中如果在前的条件列是索引列而在后的条件列不是索引列那么索引会失效了解过前缀索引吗使用前缀索引是为了减小索引字段大小可以增加一个索引页中存储的索引值有效提高索引的查询速度在一些大字符串的字段作为索引时使用前缀索引可以帮助我们减小索引项的大小索引覆盖是什么查询所需要的所有字段都能从索引中直接获取无需回表访问原始数据行查询的字段都包含在某个联合索引中查询条件中的字段顺序满足最左前缀原则查询语句中的字段都在索引中出现的字段条件字段不能使用因为可能包含未在索引中的字段使用索引跳跃式什么索引跳跃指的是查询未命中联合索引前缀中的某一列时跳过该列条件退化为对索引的部分范围扫描导致扫描数据量增大效率变差假设有如下联合索引复制编辑联合索引遵循最左前缀匹配原则即查询中必须先用到再用到才能用到如果跳过中间某一列后面的列索引就失效假设查询这时问题就来了是第一列能命中索引被跳过直接使用了是索引中的一列但由于被跳过不生效实际执行效果会使用的范围扫描对满足的所有记录还要回表检查是否成立的索引效果完全丧失造成了索引跳跃其本质是违反了最左前缀原则在这类场景中字段的索引无法生效性能下降避免索引跳跃不要跳过联合索引中间的字段联合索引中间字段若没在中使用后面的字段无法生效调整索引字段顺序把常用的查询条件字段放在索引前缀中考虑建多个单列索引或覆盖多个查询场景的联合索引索引的类型聚集索引和非聚集索引是什么非聚集索引一定回表查询吗索引下推是什么从开始引入的优化技术用于提升通过索引查询的效率它通过将部分条件下推到存储引擎层避免回表提高性能先用索引筛选出更符合条件的记录再决定是否回表取数据存储引擎读取索引记录先在索引字段中判断条件是否成立满足条件才回表取整行数据优点减少不必要的回表次数提升性能条件查询条件中涉及了联合索引的多个字段被下推的字段在索引中存在条件中使用的字段顺序与索引字段顺序不冲突仅支持引擎说明使用了索引下推事务事务的特性是什么如何实现的原子性一个事务中的所有操作要么全部完成要么全部不完成不会结束在中间某个环节而且事务在执行过程中发生错误会被回滚到事务开始前的状态就像这个事务从来没有执行过一样就好比买一件商品购买成功时则给商家付了钱商品到手购买失败时则商品在商家手中消费者的钱也没花出去一致性是指事务操作前和操作后数据满足完整性约束数据库保持一致性状态比如用户和用户在银行分别有元和元总共元用户给用户转账元分为两个步骤从的账户扣除元和对的账户增加元一致性就是要求上述步骤操作后最后的结果是用户还有元用户有元总共元而不会出现用户扣除了元但用户未增加的情况该情况用户和均为元总共元隔离性数据库允许多个并发事务同时对其数据进行读写和修改的能力隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致因为多个事务同时使用相同的数据时不会相互干扰每个事务都有一个完整的数据空间对其他并发事务是隔离的也就是说消费者购买商品这个事务是不影响其他消费者购买的持久性事务处理结束后对数据的修改就是永久的即便系统故障也不会丢失引擎通过什么技术来保证事务的这四个特性的呢持久性是通过重做日志来保证的原子性是通过回滚日志来保证的隔离性是通过多版本并发控制或锁机制来保证的一致性则是通过持久性原子性隔离性来保证可能出现什么和并发相关问题服务端是允许多个客户端连接的这意味着会出现同时处理多个事务的情况那么在同时处理多个事务的时候就可能出现脏读不可重复读幻读的问题接下来通过举例子给大家说明这些问题是如何发生的脏读如果一个事务读到了另一个未提交事务修改过的数据就意味着发生了脏读现象举个栗子假设有和这两个事务同时在处理事务先开始从数据库中读取小林的余额数据然后再执行更新操作如果此时事务还没有提交事务而此时正好事务也从数据库中读取小林的余额数据那么事务读取到的余额数据是刚才事务更新后的数据即使没有提交事务因为事务是还没提交事务的也就是它随时可能发生回滚操作如果在上面这种情况事务发生了回滚那么事务刚才得到的数据就是过期的数据这种现象就被称为脏读不可重复读在一个事务内多次读取同一个数据如果出现前后两次读到的数据不一样的情况就意味着发生了不可重复读现象举个栗子假设有和这两个事务同时在处理事务先开始从数据库中读取小林的余额数据然后继续执行代码逻辑处理在这过程中如果事务更新了这条数据并提交了事务那么当事务再次读取该数据时就会发现前后两次读到的数据是不一致的这种现象就被称为不可重复读幻读在一个事务内多次查询某个符合查询条件的记录数量如果出现前后两次查询到的记录数量不一样的情况就意味着发生了幻读现象举个栗子假设有和这两个事务同时在处理事务先开始从数据库查询账户余额大于万的记录发现共有条然后事务也按相同的搜索条件也是查询出了条记录接下来事务插入了一条余额超过万的账号并提交了事务此时数据库超过万余额的账号个数就变为然后事务再次查询账户余额大于万的记录此时查询到的记录数量有条发现和前一次读到的记录数量不一样了就感觉发生了幻觉一样这种现象就被称为幻读哪些场景不适合脏读举个例子脏读是指一个事务在读取到另一个事务未提交的数据时发生脏读可能会导致不一致的数据被读取并可能引起问题以下是一些不适合脏读的场景银行系统在银行系统中如果一个账户的余额正在被调整但尚未提交另一个事务读取了这个临时的余额可能会导致客户看到不正确的余额库存管理系统在一个库存管理系统中如果一个商品的数量正在被更新但尚未提交另一个事务读取了这个临时的数量可能会导致库存管理错误在线订单系统在一个在线订单系统中如果一个订单正在被修改但尚未提交另一个事务读取了这个临时的订单状态可能导致订单状态显示错误客户收到不准确的信息在以上这些场景中脏读可能导致严重的问题因此应该避免发生脏读保证数据的一致性和准确性的是怎么解决并发问题的锁机制提供了多种锁机制来保证数据的一致性包括行级锁表级锁页级锁等通过锁机制可以在读写操作时对数据进行加锁确保同时只有一个操作能够访问或修改数据事务隔离级别提供了多种事务隔离级别包括读未提交读已提交可重复读和串行化通过设置合适的事务隔离级别可以在多个事务并发执行时控制事务之间的隔离程度以避免数据不一致的问题多版本并发控制使用来管理并发访问它通过在数据库中保存不同版本的数据来实现不同事务之间的隔离在读取数据时会根据事务的隔离级别来选择合适的数据版本从而保证数据的一致性事务的隔离级别有哪些读未提交指一个事务还没提交时它做的变更就能被其他事务看到读提交指一个事务提交之后它做的变更才能被其他事务看到可重复读指一个事务执行过程中看到的数据一直跟这个事务启动时看到的数据是一致的引擎的默认隔离级别串行化会对记录加上读写锁在多个事务对这条记录进行读写操作时如果发生了读写冲突的时候后访问的事务必须等前一个事务执行完成才能继续执行按隔离水平高低排序如下针对不同的隔离级别并发事务时可能发生的现象也会不同也就是说在读未提交隔离级别下可能发生脏读不可重复读和幻读现象在读提交隔离级别下可能发生不可重复读和幻读现象但是不可能发生脏读现象在可重复读隔离级别下可能发生幻读现象但是不可能脏读和不可重复读现象在串行化隔离级别下脏读不可重复读和幻读现象都不可能会发生接下来举个具体的例子来说明这四种隔离级别有一张账户余额表里面有一条账户余额为万的记录然后有两个并发的事务事务只负责查询余额事务则会将我的余额改成万下面是按照时间顺序执行两个事务的行为在不同隔离级别下事务执行过程中查询到的余额可能会不同在读未提交隔离级别下事务修改余额后虽然没有提交事务但是此时的余额已经可以被事务看见了于是事务中余额查询的值是万余额自然也是万了在读提交隔离级别下事务修改余额后因为没有提交事务所以事务中余额的值还是万等事务提交完后最新的余额数据才能被事务看见因此额都是万在可重复读隔离级别下事务只能看见启动事务时的数据所以余额余额的值都是万当事务提交事务后就能看见最新的余额数据了所以余额的值是万在串行化隔离级别下事务在执行将余额万修改为万时由于此前事务执行了读操作这样就发生了读写冲突于是就会被锁住直到事务提交后事务才可以继续执行所以从的角度看余额的值是万余额的值是万这四种隔离级别具体是如何实现的呢对于读未提交隔离级别的事务来说因为可以读到未提交事务修改的数据所以直接读取最新的数据就好了对于串行化隔离级别的事务来说通过加读写锁的方式来避免并行访问对于读提交和可重复读隔离级别的事务来说它们是通过来实现的它们的区别在于创建的时机不同读提交隔离级别是在每个语句执行前都会重新生成一个而可重复读隔离级别是启动事务时生成一个然后整个事务期间都在用这个可重复读隔离级别下事务提交的数据在事务能看见吗不能可重复读隔离级是由多版本并发控制实现的实现的方式是开始事务后执行语句后在执行第一个查询语句后会创建一个后续的查询语句利用这个通过这个就可以在版本链找到事务开始时的数据所以事务过程中每次查询的数据都是一样的即使中途有其他事务插入了新纪录是查询不出来这条数据的设置了可重读隔离级后怎么保证不发生幻读尽量在开启事务之后马上执行这类锁定读的语句因为它会对记录加从而避免其他事务插入一条新记录就避免了幻读的问题举个例子说可重复读下的幻读问题可重复读隔离级别下虽然很大程度上避免了幻读但是还是没有能完全解决幻读我举例一个可重复读隔离级别发生幻读现象的场景以这张表作为例子事务执行查询的记录此时表中是没有该记录的所以查询不出来事务然后事务插入一条的记录并且提交了事务事务小美此时事务更新这条记录对没错事务看不到这条记录但是他去更新了这条记录这场景确实很违和然后再次查询的记录事务就能看到事务插入的纪录了幻读就是发生在这种违和的场景事务小林小林整个发生幻读的时序图如下在可重复读隔离级别下事务第一次执行普通的语句时生成了一个之后事务向表中新插入了一条的记录并提交接着事务对这条记录进行了更新操作在这个时刻这条新记录的隐藏列的值就变成了事务的事务之后事务再使用普通语句去查询这条记录时就可以看到这条记录了于是就发生了幻读因为这种特殊现象的存在所以我们认为中的并不能完全避免幻读现象串行化隔离级别是通过什么实现的是通过行级锁来实现的序列化隔离级别下普通的查询是会对记录加型的锁其他事务就没没办法对这些已经加锁的记录进行增删改操作了从而避免了脏读不可重复读和幻读现象一条是不是原子性的为什么是原子性主要通过锁日志保证原子性的执行的时候会加行级别锁保证了一个事务更新一条记录的时候不会被其他事务干扰事务执行过程中会生成如果事务执行失败就可以通过日志进行回滚滥用事务或者一个事务里有特别多的弊端事务的资源在事务提交之后才会释放的比如存储资源锁如果一个事务特别多那么会带来这些问题如果一个事务特别多锁定的数据太多容易造成大量的死锁和锁超时回滚记录会占用大量存储空间事务回滚时间长在中实际上每条记录在更新的时候都会同时记录一条回滚操作记录上的最新值通过回滚操作都可以得到前一个状态的值越多所需要保存的回滚数据就越多执行时间长容易造成主从延迟主库上必须等事务执行完成才会写入再传给备库所以如果一个主库上的语句执行分钟那这个事务很可能就会导致从库延迟分钟事务的两阶段提交写入的状态并刷盘引擎将事务修改的数据写入内存然后生成一条标记为状态调用将刷入磁盘保证崩溃后能恢复层将整个事务的逻辑操作记录为一条将持久化刷盘确保落地层写成功后通知将之前状态的更新为状态这一步是关键确认步骤表示事务已完全提交如果先写再写崩溃了但有记录主从同步出错如果只写不写主库恢复没问题但从库根本不会同步这条事务数据不一致所以必须保证与一致性落盘正是为了解决这一问题锁讲一下里有哪些锁在里根据加锁的范围可以分为全局锁表级锁和行锁三类全局锁通过语句会将整个数据库就处于只读状态了这时其他线程执行以下操作增删改或者表结构修改都会阻塞全局锁主要应用于做全库逻辑备份这样在备份数据库期间不会因为数据或表结构的更新而出现备份文件的数据与预期的不一样表级锁里面表级别的锁有这几种表锁通过语句可以对表加表锁表锁除了会限制别的线程的读写外也会限制本线程接下来的读写操作元数据锁当我们对数据库表进行操作时会自动给这个表加上对一张表进行操作时加的是读锁对一张表做结构变更操作的时候加的是写锁是为了保证当用户对表执行操作时防止其他线程对这个表结构做了变更意向锁当执行插入更新删除操作需要先对表加上意向独占锁然后对该记录加独占锁意向锁的目的是为了快速判断表里是否有记录被加锁行级锁引擎是支持行级锁的而引擎并不支持行级锁记录锁锁住的是一条记录而且记录锁是有锁和锁之分的满足读写互斥写写互斥间隙锁只存在于可重复读隔离级别目的是为了解决可重复读隔离级别下幻读的现象称为临键锁是的组合锁定一个范围并且锁定记录本身数据库的表锁和行锁有什么作用表锁的作用整体控制表锁可以用来控制整个表的并发访问当一个事务获取了表锁时其他事务无法对该表进行任何读写操作从而确保数据的完整性和一致性粒度大表锁的粒度比较大在锁定表的情况下可能会影响到整个表的其他操作可能会引起锁竞争和性能问题适用于大批量操作表锁适合于需要大批量操作表中数据的场景例如表的重建大量数据的加载等行锁的作用细粒度控制行锁可以精确控制对表中某行数据的访问使得其他事务可以同时访问表中的其他行数据在并发量大的系统中能够提高并发性能减少锁冲突行锁不会像表锁那样造成整个表的锁冲突减少了锁竞争的可能性提高了并发访问的效率适用于频繁单行操作行锁适合于需要频繁对表中单独行进行操作的场景例如订单系统中的订单修改删除等操作两个线程的语句同时处理一条数据会不会有阻塞如果是两个事务同时更新了比如那么是会阻塞的因为存储引擎实现了行级锁当事务对这行记录进行更新时会对主键为的记录加类型的记录锁这样第二事务对进行更新时发现已经有记录锁了就会陷入阻塞状态两条语句处理一张表的不同的主键范围的记录一个会不会遇到阻塞底层是为什么的不会因为锁住的范围不一样不会形成冲突第一条的话锁住的范围是第二条的话锁住的范围是这里用的是间隙锁锁的范围不一样如果个范围不是主键或索引还会阻塞吗如果个范围查询的字段不是索引的话那就代表没有用到索引这时候触发了全表扫描全部索引都会加行级锁这时候第二条执行的时候就会阻塞了因为如果没有用到索引在扫描过程中会对索引加锁所以全表扫描的场景下所有记录都会被加锁也就是这条语句产生了个记录锁和个间隙锁相当于锁住了全表索引和锁的联系的行级锁依赖索引加锁只有通过索引才能真正实现行级锁否则会升级为表锁的行级锁是通过索引来定位数据行并加锁的底层并不直接锁行而是锁树索引上的记录所以必须使用索引列来过滤数据才能锁中具体的行如果你不用索引定位记录会扫描整张表此时加锁范围会扩大可能会变成表锁或者加锁更多记录大大降低并发能力按照索引的分类开始主键索引聚簇索引的数据存储就是按照主键索引组织的所有主键更新时默认使用的是聚簇索引加主键索引上的记录锁唯一索引唯一索引也是可定位唯一记录的因此使用它加锁也是记录锁不会锁多余的数据普通索引非唯一非唯一索引加锁时还会回表从辅助索引查到主键后再访问聚簇索引这个过程可能会涉及对辅助索引加锁因为是查询入口对主键记录加锁因为实际行数据在主键索引上注意非唯一索引可能导致锁的扩大没有索引无法使用索引定位就必须全表扫描从而加锁过程中会对所有记录逐个加锁甚至退化为表锁这就是锁失效问题即便是主键这种范围查询也会触发间隙锁行锁锁定多个记录区间所以范围查询更容易引起锁冲突或幻读这是使用间隙锁防止幻读的手段对高并发系统慎用范围查询必要时用隔离级别避免间隙锁子句一定要走索引否则行锁会变成表锁严重影响性能设计表时考虑在经常更新查询的字段上加索引如何避免死锁或阻塞做法说明尽快提交事务不要让事务长时间挂起使用小事务减少长事务持有的风险表结构变更前踢人使用找出持有锁的线程操作选择低峰期尽量避免业务高峰期执行从起可用避免被阻塞你可以通过如下查看是否存在锁阻塞查出阻塞来源范围索引会造成的问题问题说明间隙锁的策略会锁住满足范围条件的记录及其之间的间隙防止幻读锁范围不明确导致并发能力下降锁粒度大容易阻塞其他事务影响覆盖索引使用索引失效范围查询容易导致无法使用覆盖索引或索引下推不能用索引的后续列索引中范围条件后面的列不会被用于索引即索引失效的分界点查询计划不稳定范围值的不同可能导致执行计划不一致甚至变慢间隙锁假设表中已有使用记录锁间隙锁锁定的范围是之间的所有值的间隙即使不存在也会被锁住防止别的事务插入这个范围内的值避免幻读并发下降发生阻塞事务事务两个事务都用了范围查询锁定的范围存在重叠就会发生阻塞甚至死锁范围查询导致索引失效无法使用复合索引后面的列以下查询中范围条件在前后面的字段索引无法使用遇到范围查询就不再使用索引后面的列做过滤优化范围查询的执行计划可能不稳定你可能在小表数据量时表现很好但随着数据增长的优化器可能改变执行计划比如从索引扫描变为全表扫描或选择了不合适的索引这会导致执行效率波动问题应对策略间隙锁影响使用更精确的等值查询必要时开启隔离级别不使用并发低下避免大范围更新更新分批提交合理控制事务粒度索引失效避免在复合索引前面使用范围条件或考虑索引调整执行计划不稳定使用或分析调整查询两段锁协议是数据库并发控制中保证事务隔离性特别是串行化的关键协议常用于实现事务的封锁调度两段锁协议要求一个事务中加锁和解锁必须严格分为两个阶段加锁阶段只允许加锁不允许解锁解锁阶段只允许解锁不允许再加锁阶段说明加锁阶段事务可以随意对数据项加锁共享锁排它锁但一旦开始释放锁就不能再加新锁了解锁阶段从第一个锁释放开始事务只能解锁不能再加锁保证事务的调度是可串行化的即并发执行效果等价于串行执行是实现事务隔离性的重要基础分类类型描述特点基本两段锁协议满足加锁解锁阶段划分只保证可串行性不一定防死锁严格两段锁协议所有锁直到事务提交或回滚时才释放默认采用防止脏读保证恢复安全强两段锁协议所有锁直到事务结束才统一释放读写锁都这样更严格安全性更高中的死锁和死锁的解决办法检测机制死锁定义两个或多个事务因争夺锁资源而形成互相等待的局面永远无法释放除非外部干预事务先锁定资源再等待资源事务先锁定资源再等待资源互相等待导致死锁场景描述不同事务更新相同的几行但顺序不同最典型事务未提交而持有锁太久导致其他事务阻塞大事务中穿插小事务小事务一直等待大事务一直不释放行锁升级为表锁或间隙锁干扰特别是的间隙锁和检测机制的引擎具备死锁自动检测机制遇到死锁时自动选择回滚其中一个事务通常选择代价最小影响最小的事务返回错误信息最近一次死锁的事务编号死锁涉及的语句被回滚的事务避免死锁尽量保证一致的访问顺序多个事务访问相同的表或记录时应按照相同顺序加锁尽量减少锁定范围避免一次锁定过多数据使用合理的索引避免全表扫描缩短事务执行时间不在事务中执行耗时操作如请求文件操作等事务越短锁持有时间越短冲突越少使用更高粒度的锁慎重行锁表锁如果确实冲突频繁可考虑调整为表锁或使用乐观锁开启合理的事务隔离级别如不需要强一致性可考虑而非减少间隙锁产生的可能性处理策略业务端重试机制执行业务逻辑最后一次抛出重试手动加锁顺序分解事务拆成多个子事务控制加锁顺序避免交叉或者是我们设置事务的最大等待时间超过这个时间直接回滚或者是把造成死锁的进程直接掉介绍实现原理允许多个事务同时读取同一行数据而不会彼此阻塞每个事务看到的数据版本是该事务开始时的数据版本这意味着如果其他事务在此期间修改了数据正在运行的事务仍然看到的是它开始时的数据状态从而实现了非阻塞读操作对于读提交和可重复读隔离级别的事务来说它们是通过来实现的它们的区别在于创建的时机不同大家可以把理解成一个数据快照就像相机拍照那样定格某一时刻的风景读提交隔离级别是在每个语句执行前都会重新生成一个可重复读隔离级别是执行第一条时生成一个然后整个事务期间都在用这个有四个重要的字段指的是在创建时当前数据库中活跃事务的事务列表注意是一个列表活跃事务指的就是启动了但还没提交的事务指的是在创建时当前数据库中活跃事务中事务最小的事务也就是的最小值这个并不是的最大值而是创建时当前数据库中应该给下一个事务的值也就是全局事务中最大的事务值指的是创建该的事务的事务对于使用存储引擎的数据库表它的聚簇索引记录中都包含下面两个隐藏列当一个事务对某条聚簇索引记录进行改动时就会把该事务的事务记录在隐藏列里每次对某条聚簇索引记录进行改动时都会把旧版本的记录写入到日志中然后这个隐藏列是个指针指向每一个旧版本记录于是就可以通过它找到修改前的记录在创建后我们可以将记录中的划分这三种情况一个事务去访问记录的时候除了自己的更新记录总是可见之外还有这几种情况如果记录的值小于中的值表示这个版本的记录是在创建前已经提交的事务生成的所以该版本的记录对当前事务可见如果记录的值大于等于中的值表示这个版本的记录是在创建后才启动的事务生成的所以该版本的记录对当前事务不可见如果记录的值在的和之间需要判断是否在列表中如果记录的在列表中表示生成该版本记录的活跃事务依然活跃着还没提交事务所以该版本的记录对当前事务不可见如果记录的不在列表中表示生成该版本记录的活跃事务已经被提交所以该版本的记录对当前事务可见这种通过版本链来控制并发事务访问同一个记录时的行为就叫多版本并发控制的具体实现一基本原理多版本数据每条记录并不只有当前值还保留了若干历史版本版本链通过日志串联原子性也是通过这个的来实现回滚快照读当前读快照读不加锁读取某个时刻的事务一致性视图当前读加锁读如或直接读取最新版本读视图事务启动时构造一个活跃事务列表快照每次快照读遇到版本时判断该版本的创建删除事务是否在视图中决定可见性二中的实现细节隐藏列每行记录额外维护两个隐藏列创建该版本的事务和指向上一个版本的日志日志存储历史版本修改操作先写日志再写日志和数据页日志负责回滚和给其他事务做时提供旧版本插入修改删除的版本链新版本的当前事务先把老版本写到日志创建新版本并链入相当于创建一个删除标记版本可见性判断对比版本的与事务的中的最小最大事务列表决定该版本是否对当前快照可见三事务隔离级别与隔离级别幻读并发写锁优点注意点会出现脏读无并发最高脏读不可重复读幻读都可能不会脏读无脏读消除不可重复读幻读默认不会幻读无快照读间隙锁阻止幻读无幻读可重复读注意单纯快照读不锁行范围写锁防幻读读写都加锁最严格并发最差四常见面试题及回答要点什么是为什么要用答为每个事务提供一个数据快照避免读写冲突提高并发性能中如何实现答基于日志存储历史版本通过隐藏列记录事务和回滚链指针快照读构造判断版本可见性当前读直接加行锁快照读和当前读有什么区别答快照读使用默认不加锁当前读会加行锁读取最新版本为什么能防止幻读答结合快照读范围写时锁定间隙共同防幻读日志何时会被清理答当所有活跃事务的都不需要该版本时后台的线程会清除长事务对有什么影响答会延迟日志的清理导致文件增长甚至使查询回滚链过长影响性能五示例演示假设初始表快照读示例事务读取事务事务仍读取快照中的当前读示例事务加锁读事务阻塞直到提交幻读防护示例表中记录事务锁定间隙防止被插入事务阻塞直到提交日志日志文件是分成了哪几种重做日志是存储引擎层生成的日志实现了事务中的持久性主要用于掉电等故障恢复事务提交的时候重做回滚日志是存储引擎层生成的日志实现了事务中的原子性主要用于事务回滚和事务未提交回滚二进制日志是层生成的日志主要用于数据备份和主从复制中继日志用于主从复制场景下通过线程拷贝的后本地生成的日志慢查询日志用于记录执行时间过长的需要设置阈值后手动开启讲一下在完成一条更新操作后层还会生成一条等之后事务提交的时候会将该事物执行过程中产生的所有统一写入文件是的层实现的日志所有存储引擎都可以使用是追加写写满一个文件就创建一个新的文件继续写不会覆盖以前的日志保存的是全量的日志用于备份恢复主从复制文件是记录了所有数据库表结构变更和表数据修改的日志不会记录查询类的操作比如和操作有种格式类型分别是默认格式区别如下每一条修改数据的都会被记录到中相当于记录了逻辑操作所以针对这种格式可以称为逻辑日志主从复制中端再根据语句重现但有动态函数的问题比如你用了或者这些函数你在主库上执行的结果并不是你在从库执行的结果这种随时在变的函数会导致复制的数据不一致记录行数据最终被修改成什么样了这种格式的日志就不能称为逻辑日志了不会出现下动态函数的问题但的缺点是每行数据的变化结果都会被记录比如执行批量语句更新多少行数据就会产生多少条记录使文件过大而在格式下只会记录一个语句而已包含了和模式它会根据不同的情况自动使用模式和模式日志的作用是什么是一种用于撤销回退的日志它保证了事务的特性中的原子性在事务没提交之前会先记录更新前的数据到日志文件里面当事务回滚时可以利用来进行回滚如下图每当引擎对一条记录进行操作修改删除新增时要把回滚时需要的信息都记录到里比如在插入一条记录时要把这条记录的主键值记下来这样之后回滚时只需要把这个主键值对应的记录删掉就好了在删除一条记录时要把这条记录中的内容都记下来这样之后回滚时再把由这些内容组成的记录插入到表中就好了在更新一条记录时要把被更新的列的旧值记下来这样之后回滚时再把这些列更新为旧值就好了在发生回滚时就读取里的数据然后做原先相反操作比如当一条记录时中会把记录中的内容都记下来然后执行回滚操作的时候就读取里的数据然后进行操作有了为啥还需要呢是提高了读写效率没错但是问题来了是基于内存的而内存总是不可靠万一断电重启还没来得及落盘的脏页数据就会丢失为了防止断电导致数据丢失的问题当有一条记录需要更新的时候引擎就会先更新内存同时标记为脏页然后将本次对这个页的修改以的形式记录下来这个时候更新就算完成了后续引擎会在适当的时候由后台线程将缓存在的脏页刷新到磁盘里这就是技术技术指的是的写操作并不是立刻写到磁盘上而是先写日志然后在合适的时间再写到磁盘上过程如下图是物理日志记录了某个数据页做了什么修改比如对表空间中的数据页偏移量的地方做了更新每当执行一个事务就会产生这样的一条或者多条物理日志在事务提交时只要先将持久化到磁盘即可可以不需要等到将缓存在里的脏页数据持久化到磁盘当系统崩溃时虽然脏页数据没有持久化但是已经持久化接着重启后可以根据的内容将所有数据恢复到最新的状态和这两种日志是属于存储引擎的日志它们的区别在于记录了此次事务完成后的数据状态记录的是更新之后的值记录了此次事务开始前的数据状态记录的是更新之前的值事务提交之前发生了崩溃重启后会通过回滚事务事务提交之后发生了崩溃重启后会通过恢复事务如下图所以有了再通过技术就可以保证即使数据库发生异常重启之前已提交的记录都不会丢失这个能力称为崩溃恢复可以看出来保证了事务四大特性中的持久性写入的方式使用了追加操作所以磁盘操作是顺序写而写入数据需要先找到写入位置然后才写到磁盘所以磁盘操作是随机写磁盘的顺序写比随机写高效的多因此写入磁盘的开销更小针对顺序写为什么比随机写更快这个问题可以比喻为你有一个本子按照顺序一页一页写肯定比写一个字都要找到对应页写快得多可以说这是技术的另外一个优点的写操作从磁盘的随机写变成了顺序写提升语句的执行性能这是因为的写操作并不是立刻更新到磁盘上而是先记录在日志上然后在合适的时间再更新到磁盘上至此针对为什么需要这个问题我们有两个答案实现事务的持久性让有的能力能够保证在任何时间段突然崩溃重启后之前已提交的记录都不会丢失将写操作从随机写变成了顺序写提升写入磁盘的性能怎么保证持久性的是中用于保证持久性的重要机制之一它通过以下方式来保证持久性在事务提交之前将事务所做的修改操作记录到中然后再将数据写入磁盘这样即使在数据写入磁盘之前发生了宕机系统可以通过中的记录来恢复数据保证了事务的持久性的顺序写入采用追加写入的方式将日志记录追加到文件末尾而不是随机写入这样可以减少磁盘的随机操作提高写入性能机制会定期将内存中的数据刷新到磁盘同时将最新的记录到磁盘中这个可以确保中的操作是按顺序执行的在恢复数据时系统会根据来确定从哪个位置开始应用能不能只用不用不行是层的日志没办法记录哪些脏页还没有刷盘是存储引擎层的日志可以记录哪些脏页还没有刷盘这样崩溃恢复的时候就能恢复那些还没有被刷盘的脏页数据两阶段提交过程是怎么样的事务提交后和都要持久化到磁盘但是这两个是独立的逻辑可能出现半成功的状态这样就造成两份日志之间的逻辑不一致在的存储引擎中开启的情况下会同时维护日志与的为了保证这两个日志的一致性使用了内部事务是的也有外部事务跟本文不太相关我就不介绍了内部事务由作为协调者存储引擎是参与者当客户端执行语句或者在自动提交的情况下内部开启一个事务分两阶段来完成事务的提交如下图从图中可看出事务的提交过程有两个阶段就是将的写入拆成了两个步骤和中间再穿插写入具体如下阶段将内部事务的写入到同时将对应的事务状态设置为然后将持久化到磁盘的作用阶段把写入到然后将持久化到磁盘的作用接着调用引擎的提交事务接口将状态设置为此时该状态并不需要持久化到磁盘只需要到文件系统的中就够了因为只要写磁盘成功就算的状态还是也没有关系一样会被认为事务已经执行成功我们来看看在两阶段提交的不同时刻异常重启会出现什么现象下图中有时刻和时刻都有可能发生崩溃不管是时刻已经写入磁盘还没写入磁盘还是时刻和都已经写入磁盘还没写入标识崩溃此时的都处于状态在重启后会按顺序扫描文件碰到处于状态的就拿着中的去查看是否存在此如果中没有当前内部事务的说明完成刷盘但是还没有刷盘则回滚事务对应时刻崩溃恢复的情况如果中有当前内部事务的说明和都已经完成了刷盘则提交事务对应时刻崩溃恢复的情况可以看到对于处于阶段的即可以提交事务也可以回滚事务这取决于是否能在中查找到与相同的如果有就提交事务如果没有就回滚事务这样就可以保证和这两份日志的一致性了所以说两阶段提交是以写成功为事务提交成功的标识因为写成功了就意味着能在中查找到与相同的语句的具体执行过程是怎样的具体更新一条记录的流程如下执行器负责具体执行会调用存储引擎的接口通过主键索引树搜索获取这一行记录如果这一行所在的数据页本来就在中就直接返回给执行器更新如果记录不在将数据页从磁盘读入到返回记录给执行器执行器得到聚簇索引记录后会看一下更新前的记录和更新后的记录是否一样如果一样的话就不进行后续更新流程如果不一样的话就把更新前的记录和更新后的记录都当作参数传给层让真正的执行更新记录的操作开启事务层更新记录前首先要记录相应的因为这是更新操作需要把被更新的列的旧值记下来也就是要生成一条会写入中的页面不过在内存修改该页面后需要记录对应的层开始更新记录会先更新内存同时标记为脏页然后将记录写到里面这个时候更新就算完成了为了减少磁盘不会立即将脏页写入磁盘后续由后台线程选择一个合适的时机将脏页写入到磁盘这就是技术的写操作并不是立刻写到磁盘上而是先写日志然后在合适的时间再将修改的行数据写到磁盘上至此一条记录更新完了在一条更新语句执行完成后然后开始记录该语句对应的此时记录的会被保存到并没有刷新到硬盘上的文件在事务提交时才会统一将该事务运行过程中的所有刷新到硬盘事务提交为了方便说明这里不说组提交的过程只说两阶段提交阶段将对应的事务状态设置为然后将刷新到硬盘阶段将刷新到磁盘接着调用引擎的提交事务接口将状态设置为将事务设置为状态后刷入到磁盘文件至此一条更新语句执行完成是如何保障数据不丢失的主要是通过来实现事务持久性的事务执行过程会把对存储引擎中数据页修改操作记录到里事务提交的时候就直接把刷入磁盘即使脏页中途没有刷盘成功宕机了也能通过重放恢复到之前事务修改数据页后的状态从而保障了数据不丢失是在内存里吗事务执行过程中生成的会在中也就是在内存中等事务提交的时候会把写入磁盘为什么要写而不是直接写到树里面因为写入磁盘是顺序写而树里数据页写入磁盘是随机写顺序写的性能会比随机写好这样可以提升事务提交的效率最重要的是具备故障恢复的能力记录的是物理级别的修改包括页的修改如插入更新删除操作在磁盘上的物理位置和修改内容例如当执行一个更新操作时会记录修改的数据页的地址和更新后的数据而不是语句本身在数据页实际更新之前先将修改操作写入当数据库重启时会进行恢复操作首先根据检查哪些事务已经提交但数据页尚未完全写入磁盘然后使用中的记录对这些事务进行重做操作将未完成的数据页修改完成确保事务的修改生效两次写了解吗我们常见的服务器一般都是操作系统文件系统页的大小默认是而的页大小默认是程序是跑在操作系统上的需要跟操作系统交互所以中一页数据刷到磁盘要写个文件系统里的页需要注意的是这个操作并非原子操作比如我操作系统写到第二个页的时候机器断电了这时候就会出现问题了造成页数据损坏并且这种页数据损坏靠日志是无法修复的的出现就是为了解决上面的这种情况虽然名字带了但实际上是内存磁盘的结构作用是在把页写到数据文件之前先把它们写到一个叫双写缓冲区的共享表空间内在写完成后才会把页写到数据文件的适当的位置如果在写页的过程中发生意外崩溃在稍后的恢复过程中在中找到完好的副本用于恢复所以本质上是一个最近写回的页面的备份拷贝如上图所示当有页数据要刷盘时页数据先通过函数拷贝至内存中的大小为约中分为两个区域每次写入一个区域最多的数据的内存里的数据页会刷到的磁盘上写两次到到共享表空间中连续存储顺序写性能很高每次写写入完成后再将脏页刷到数据磁盘存储文件上随机写当出现异常崩溃时有如下几种情况发生情况一步骤前宕机刷盘未开始数据在后期可以恢复情况二步骤后步骤前宕机因为是在内存中宕机清空内存和情况一样情况三步骤后步骤前宕机因为的磁盘有完整的数据可以修复损坏的页数据由此我们可以得出结论是针对实际的数据页的原子性保证就是避免异常崩溃时写的那几个不会出错要么都写了要么什么都没有做为什么无法代替的设计之初是账本的作用是一种操作日志用于异常崩溃恢复使用是引擎特有的日志本质上是物理日志记录的是在某个数据页上做了什么修改但如果数据页本身已经发生了损坏来恢复已经损坏的数据块是无效的数据块的本身已经损坏再次重做依然是一个坏块所以此时需要一个数据块的副本来还原该损坏的数据块再利用重做日志进行其他数据块的重做操作这就是的原因作用调优的有什么作用是查看的执行计划主要用来分析语句的执行过程比如有没有走索引有没有外部排序有没有索引覆盖等等如下图就是一个没有使用索引并且是一个全表扫描的查询语句对于执行计划参数有字段表示可能用到的索引字段表示实际用的索引如果这一项为说明没有使用索引表示索引的长度表示扫描的数据行数表示数据扫描类型我们需要重点看这个字段就是描述了找到所需数据时使用的扫描方式是什么常见扫描类型的执行效率从低到高的顺序为全表扫描在这些情况里是最坏的情况因为采用了全表扫描的方式全索引扫描和差不多只不过对索引表进行全扫描这样做的好处是不再需要对数据进行排序但是开销依然很大所以要尽量避免全表扫描和全索引扫描索引范围扫描表示采用了索引范围扫描一般在子句中使用等关键词只检索给定范围的行属于范围查找从这一级别开始索引的作用会越来越明显因此我们需要尽量让查询可以使用到这一级别及以上的访问方式非唯一索引扫描类型表示采用了非唯一索引或者是唯一索引的非唯一性前缀返回数据返回可能是多条因为虽然使用了索引但该索引列的值并不唯一有重复这样即使使用索引快速查找到了第一条数据仍然不能停止要进行目标值附近的小范围扫描但它的好处是它并不需要扫全表因为索引是有序的即便有重复值也是在一个非常小的范围内扫描唯一索引扫描类型是使用主键或唯一索引时产生的访问方式通常使用在多表联查中比如对两张表进行联查关联条件是两张表的相等且是唯一索引那么使用进行执行计划查看的时候就会显示结果只有一条的主键或唯一索引扫描类型表示使用了主键或者唯一索引与常量值进行比较比如需要说明的是类型和都使用了主键或唯一索引不过这两个类型有所区别是与常量进行比较查询效率会更快而通常用于多表联查中显示的结果这里说几个重要的参考指标当查询语句中包含操作而且无法利用索引完成排序操作的时候这时不得不选择相应的排序算法进行甚至可能会通过文件排序效率是很低的所以要避免这种问题的出现使了用临时表保存中间结果在对查询结果排序时使用临时表常见于排序和分组查询效率低要避免这种问题的出现所需数据只需在索引即可全部获得不须要再到表中取数据也就是使用了覆盖索引避免了回表操作效率不错给你张表发现查询速度很慢你有那些解决方案分析查询语句使用命令分析执行计划找出慢查询的原因比如是否使用了全表扫描是否存在索引未被利用的情况等并根据相应情况对索引进行适当修改创建或优化索引根据查询条件创建合适的索引特别是经常用于子句的字段排序的字段连表查询的字典的字段并且如果查询中经常涉及多个字段考虑创建联合索引使用联合索引要符合最左匹配原则不然会索引失效避免索引失效比如不要用左模糊匹配函数计算表达式计算等等查询优化避免使用只查询真正需要的列使用覆盖索引即索引包含所有查询的字段联表查询最好要以小表驱动大表并且被驱动表的字段要有索引当然最好通过冗余字段的设计避免联表查询分页优化针对深分页的查询优化可以把查询转换成某个位置的查询该方案适用于主键自增的表优化数据库表如果单表的数据超过了千万级别考虑是否需要将大表拆分为小表减轻单个表的查询压力也可以将字段多的表分解成多个表有些字段使用频率高有些低数据量大时会由于使用频率低的存在而变慢可以考虑分开使用缓存技术引入缓存层如存储热点数据和频繁查询的结果但是要考虑缓存一致性的问题对于读请求会选择旁路缓存策略对于写请求会选择先更新再删除缓存的策略如果用到的索引不正确的话有什么办法干预吗可以使用强制走索引比如输出',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-28 19:43:05',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/rss2.xml" title="mengnankkのblog" type="application/rss+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">mengnankkのblog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imgbed.mengnankk.asia/202407021650088.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imgbed.mengnankk.asia/202407021650088.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 1.05rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 1.05rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 1.05rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/Cache/" style="font-size: 1.05rem;">Cache<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 1.05rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 1.05rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 1.05rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>52</sup></a><a href="/tags/juc/" style="font-size: 1.05rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 1.05rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>9</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 1.05rem;">net<sup>6</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 1.05rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 1.05rem;">redis<sup>3</sup></a><a href="/tags/rocketmq/" style="font-size: 1.05rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 1.05rem;">spring<sup>2</sup></a><a href="/tags/spring-boot/" style="font-size: 1.05rem;">spring boot<sup>13</sup></a><a href="/tags/sql/" style="font-size: 1.05rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 1.05rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>19</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>18</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">17</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/sql/" itemprop="url">sql</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a><a class="article-meta__tags" href="/tags/mysql/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>mysql</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Mysql面试题目</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-03-14T16:00:00.000Z" title="发表于 2025-03-15 00:00:00">2025-03-15</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-28T11:43:05.570Z" title="更新于 2025-06-28 19:43:05">2025-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">37k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>117分钟</span></span><span class="post-meta-separator"></span><span id="" data-flag-title="Mysql面试题目"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为济南"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>济南</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=b0078bfc-8718-be24-66f8-bd95f158e9ac"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blog.tokenlen.top/2025/03/15/mysql/mysql12/"><header><a class="post-meta-categories" href="/categories/sql/" itemprop="url">sql</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><a href="/tags/mysql/" tabindex="-1" itemprop="url">mysql</a><h1 id="CrawlerTitle" itemprop="name headline">Mysql面试题目</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">mengnankkzhou</span><time itemprop="dateCreated datePublished" datetime="2025-03-14T16:00:00.000Z" title="发表于 2025-03-15 00:00:00">2025-03-15</time><time itemprop="dateCreated datePublished" datetime="2025-06-28T11:43:05.570Z" title="更新于 2025-06-28 19:43:05">2025-06-28</time></header><h1 id="原理概念"><a href="#原理概念" class="headerlink" title="原理概念"></a>原理概念</h1><h2 id="1-什么是mysql"><a href="#1-什么是mysql" class="headerlink" title="1.什么是mysql"></a>1.什么是mysql</h2><p>MySQL 是一个<strong>开源的关系型数据库</strong>，现在隶属于 Oracle 公司。是我们国内使用频率最高的一种数据库，我在本地安装的是最新的 8.3 版本。</p>
<p><strong>怎么删除建立一张表？</strong></p>
<p>使用DROP TABLE 来删除表</p>
<p>CREATE TABLE来创建表</p>
<p>创建表的时候可以使用PRIMARY KEY来创建主键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    email VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>写一个升序/降序的sql语句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>, name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<p>排序的第一依据是salary 降序，第二一依据是name 升序</p>
<p><strong>MYsql出现性能差的原因是什么？</strong></p>
<p>可能是sql查询的时候使用了全表扫描，也可能是查询语句过于复杂</p>
<p>也有可能是单表数据量过大。</p>
<p>我们可以添加索引来解决大部分问题，对于一些热点数据，可以使用Redis缓存</p>
<h2 id="2-表的连接"><a href="#2-表的连接" class="headerlink" title="2.表的连接"></a>2.表的连接</h2><p>内连接：</p>
<p>返回两个表中有<strong>匹配关系</strong>的行，找出两张表的<strong>交集</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT users.name, orders.order_id</span><br><span class="line">FROM users</span><br><span class="line">INNER JOIN orders ON users.id = orders.user_id;</span><br></pre></td></tr></table></figure>
<p>INNER JOIN orders ON users.id = orders.user_id;连接条件：</p>
<p>users.id = orders.user_id</p>
<p>外连接：</p>
<p>不仅返回两个表中匹配的行，<strong>还返回没有匹配的行</strong>，用 <code>null</code> 来填充。</p>
<p>想当与找<strong>并集</strong></p>
<p>left join右表没匹配的null填充</p>
<p>right join左表没匹配的null填充</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.id, users.name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure>
<p>交叉连接：</p>
<p>返回两张表的<strong>笛卡尔积</strong>，也就是将左表的每一行与右表的每一行进行组合，返回的行数是两张表行数的<strong>乘积</strong>。</p>
<p>一般用于生成排列组合或固定模板数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B;</span><br></pre></td></tr></table></figure>
<p>全外连接：</p>
<p>保留<strong>左右两表所有行</strong>，<strong>能匹配的就匹配</strong>，<strong>不能匹配的用 NULL 补足</strong>。</p>
<p>最多为 <code>左表行数 + 右表行数</code></p>
<p>FULL JOIN 需要使用 UNION 来实现，因为 MySQL 不直接支持 FULL JOIN。<strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.name, departments.name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.id</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments</span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.id;</span><br></pre></td></tr></table></figure>
<h2 id="3-数据库的三大范式"><a href="#3-数据库的三大范式" class="headerlink" title="3.数据库的三大范式"></a>3.数据库的三大范式</h2><p>第一范式：确保表的每一列都是<strong>不可分割的基本数据单元</strong>，比如说用户地址，应该拆分成省、市、区、详细地址等 4 个字段。</p>
<p>第二范式：要求表中的<strong>每一列都和主键直接相关</strong>。比如在订单表中，商品名称、单位、商品价格等字段应该拆分到商品表中。<strong>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</strong></p>
<p><strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</strong></p>
<p>第三范式：<strong>非主键列应该只依赖于主键列</strong>。比如说在设计订单信息表的时候，可以把客户名称、所属公司、联系方式等信息拆分到客户信息表中，然后在订单信息表中用客户编号进行关联。</p>
<p><strong>在2NF基础上，任何非主属性 (opens new window)不依赖于其它非主属性（在2NF基础上消除传递依赖）</strong></p>
<p><strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong></p>
<p>建表的原则：</p>
<p>考虑表是否符合数据库的三大范式，确保字段不可再分，消除非主键依赖，确保字段仅依赖于主键等。</p>
<p>然后在选择字段类型时，应该尽量选择合适的数据类型。</p>
<p>在字符集上，尽量选择 utf8mb4，这样不仅可以支持中文和英文，还可以支持表情符号等。</p>
<p>当数据量较大时，比如上千万行数据，需要考虑分表。比如订单表，可以采用水平分表的方式来分散单表存储压力。</p>
<p>说白了就是：</p>
<p>1NF:必须是原子性的</p>
<p>2NF:必须跟主键相关</p>
<p>3NF：必须跟主键直接相关，就是订单只放订单，客户在客户表里面</p>
<h2 id="4-NOSQL和SQL的区别？"><a href="#4-NOSQL和SQL的区别？" class="headerlink" title="4.NOSQL和SQL的区别？"></a>4.NOSQL和SQL的区别？</h2><p>SQL数据库，指关系型数据库 - 主要代表：SQL Server，Oracle，MySQL(开源)，PostgreSQL(开源)。</p>
<p>关系型数据库<strong>存储结构化数据。这些数据逻辑上以行列二维表的形式存在，每一列代表数据的一种属性，每一行代表一个数据实体。</strong>是一个实体类的映射，一个实体类就相当于一个行，他的属性就是列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240725232218438.png" alt="image-20240725232218438"></p>
<p>NoSQL指非关系型数据库 ，主要代表：MongoDB，Redis。NoSQL 数据库逻辑上提供了不同于二维表的存储方式，存储方式可以是JSON文档、哈希表或者其他方式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240725232206455.png" alt="image-20240725232206455"></p>
<p>选择 SQL vs NoSQL，考虑以下因素。</p>
<blockquote>
<p>ACID vs BASE</p>
</blockquote>
<p>关系型数据库支持 ACID 即<strong>原子性，一致性，隔离性和持续性</strong>。相对而言，NoSQL 采用更宽松的模型 BASE ， 即基本可用，软状态和最终一致性。</p>
<p>从实用的角度出发，我们需要考虑对于面对的应用场景，ACID 是否是必须的。比如银行应用就必须保证 ACID，否则一笔钱可能被使用两次；又比如社交软件不必保证 ACID，因为一条状态的更新对于所有用户读取先后时间有数秒不同并不影响使用。</p>
<p>对于需要保证 ACID 的应用，我们可以优先考虑 SQL。反之则可以优先考虑 NoSQL。</p>
<blockquote>
<p>扩展性对比</p>
</blockquote>
<p><strong>NoSQL数据之间无关系，这样就非常容易扩展</strong>，也无形之间，在架构的层面上带来了可扩展的能力。比如 redis 自带主从复制模式、哨兵模式、切片集群模式。</p>
<p>相反关系型数据库的数据之间存在关联性，水平扩展较难 ，需要解决跨服务器 JOIN，分布式事务等问题。</p>
<h2 id="5-说一下外键约束"><a href="#5-说一下外键约束" class="headerlink" title="5.说一下外键约束"></a>5.说一下外键约束</h2><p>外键约束的作用是<strong>维护表与表之间的关系</strong>，确保数据的完整性和一致性。让我们举一个简单的例子：</p>
<p>假设你有两个表，一个是学生表，另一个是课程表，这两个表之间有一个关系，即一个学生可以选修多门课程，而一门课程也可以被多个学生选修。在这种情况下，我们可以在<strong>学生表中定义一个指向课程表的外键，如下所示：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  course_id <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (course_id) <span class="keyword">REFERENCES</span> courses(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里，<code>students</code>表中的<code>course_id</code>字段是一个外键，它指向<code>courses</code>表中的<code>id</code>字段。<strong>这个外键约束确保了每个学生所选的课程在<code>courses</code>表中都存在，从而维护了数据的完整性和一致性。</strong></p>
<p>如果没有定义外键约束，那么就有可能出现学生选了不存在的课程或者删除了一个课程而忘记从学生表中删除选修该课程的学生的情况，这会破坏数据的完整性和一致性。因此，使用外键约束可以帮助我们避免这些问题。</p>
<h1 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h1><h2 id="1-MySQL如何避免重复插入数据？"><a href="#1-MySQL如何避免重复插入数据？" class="headerlink" title="1.MySQL如何避免重复插入数据？"></a>1.MySQL如何避免重复插入数据？</h2><p><strong>方式一：使用UNIQUE约束</strong></p>
<p>在表的相关列上添加UNIQUE约束，确保每个值在该列中唯一。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果尝试插入重复的email，MySQL会返回错误。</p>
<p><strong>方式二：使用INSERT … ON DUPLICATE KEY UPDATE</strong></p>
<p>这种语句允许在插入记录时处理重复键的情况。如果插入的记录与现有记录冲突，可以选择更新现有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (email, name) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;example@example.com&#x27;</span>, <span class="string">&#x27;John Doe&#x27;</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> name <span class="operator">=</span> <span class="keyword">VALUES</span>(name);</span><br></pre></td></tr></table></figure>
<p><strong>方式三：使用INSERT IGNORE</strong>： 该语句会在插入记录时<strong>忽略那些因重复键而导致的插入错误</strong>。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> users (email, name) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;example@example.com&#x27;</span>, <span class="string">&#x27;John Doe&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>如果email已经存在，这条插入语句将被忽略而不会返回错误。</p>
<p>选择哪种方法取决于具体的需求：</p>
<ul>
<li>如果需要保证全局唯一性，使用UNIQUE约束是最佳做法。</li>
<li>如果需要插入和更新结合可以使用<code>ON DUPLICATE KEY UPDATE</code>。</li>
<li>对于快速忽略重复插入，<code>INSERT IGNORE</code>是合适的选择。</li>
</ul>
<h2 id="2-int-1-int-10-在mysql有什么不同？"><a href="#2-int-1-int-10-在mysql有什么不同？" class="headerlink" title="2.int(1) int(10) 在mysql有什么不同？"></a>2.int(1) int(10) 在mysql有什么不同？</h2><p><code>INT(1)</code> 和 <code>INT(10)</code> 的区别主要在于 <strong>显示宽度</strong>，而不是存储范围或数据类型本身的大小。以下是核心区别的总结：</p>
<ul>
<li>本质是显示宽度，不改变存储方式：<code>INT</code> 的存储固定为 <strong>4 字节</strong>，所有 <code>INT</code>（无论写成 <code>INT(1)</code> 还是 <code>INT(10)</code>）占用的存储空间 均为 4 字节。括号内的数值（如 <code>1</code> 或 <code>10</code>）是<strong>显示宽度，用于在 特定场景下 控制数值的展示格式。</strong></li>
<li>唯一作用场景：<code>ZEROFILL</code> 补零显示，当字段设置 <code>ZEROFILL</code> 时：数字显示时会用前导零填充至指定宽度。比如，字段类型为 <code>INT(4) ZEROFILL</code>，实际存入 <code>5</code> → 显示为 <code>0005</code>，实际存入 <code>12345</code> → 显示仍为 <code>12345</code>（<strong>宽度超限时不截断</strong>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个包含 INT(<span class="number">1</span>) 和 INT(<span class="number">10</span>) 字段的表，并设置 ZEROFILL 属性</span><br><span class="line">CREATE TABLE <span class="title function_">test_int</span> <span class="params">(</span></span><br><span class="line"><span class="params">    num1 INT(<span class="number">1</span>)</span> ZEROFILL,</span><br><span class="line">    num2 <span class="title function_">INT</span><span class="params">(<span class="number">10</span>)</span> ZEROFILL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO <span class="title function_">test_int</span> <span class="params">(num1, num2)</span> VALUES (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">-- 查询数据</span><br><span class="line">SELECT * FROM test_int;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>num1</code> 字段由于设置为 <code>INT(1) ZEROFILL</code>，其显示宽度为 1，插入数据 <code>1</code> 时会显示为 <code>1</code>。</li>
<li><code>num2</code> 字段设置为 <code>INT(10) ZEROFILL</code>，显示宽度为 10，插入数据 <code>1</code> 时会在前面填充零，显示为 <code>0000000001</code>。</li>
</ul>
<h2 id="3-Text数据类型可以无限大吗？"><a href="#3-Text数据类型可以无限大吗？" class="headerlink" title="3.Text数据类型可以无限大吗？"></a>3.Text数据类型可以无限大吗？</h2><p>MySQL 3 种text类型的最大长度如下：</p>
<ul>
<li>TEXT：65,535 bytes ~64kb</li>
<li>MEDIUMTEXT：16,777,215 bytes ~16Mb</li>
<li>LONGTEXT：4,294,967,295 bytes ~4Gb</li>
</ul>
<h2 id="4-varchar和char的区别"><a href="#4-varchar和char的区别" class="headerlink" title="4.varchar和char的区别"></a>4.varchar和char的区别</h2><p>varchar是<strong>可变长度</strong>的字符类型，原则上最多可以容纳 65535 个字符，但考虑字符集，以及 MySQL 需要 1 到 2 个字节来表示字符串长度，所以实际上最大可以设置到 65533。</p>
<ul>
<li>如果字符集是 ASCII 字符集：ASCII 字符集每个字符占用 1 个字节，那么 VARCHAR(10) 最多可以存储 10 个 ASCII 字符，同时占用的存储空间最多为 10 个字节（不考虑额外的长度记录开销）。</li>
<li>如果字符集是 UTF - 8 字符集，它的每个字符可能占用 1 到 4 个字节，对于 <code>VARCHAR(10)</code> 的字段，它最多可以存储 10 个字符，但占用的字节数会根据字符的不同而变化。</li>
</ul>
<p><strong>varch中空格也要占一个字节</strong></p>
<p>char是<strong>固定长度</strong>的字符类型，当定义一个 <code>CHAR(10)</code> 字段时，不管实际存储的字符长度是多少，都只会占用 10 个字符的空间。如果插入的数据小于 10 个字符，剩余的部分会用空格填充。分配多少就是多少。</p>
<h2 id="5-blob和text有什么区别"><a href="#5-blob和text有什么区别" class="headerlink" title="5.blob和text有什么区别"></a>5.blob和text有什么区别</h2><p>blob用于存储二进制数据，如图片音频等等，但是实际应用中，我们会把这些文件存储到oss或者文件服务器上，数据库存储文件的url</p>
<p>text用于存储文本数据，如文章评论等。</p>
<h2 id="6-DATETIME和TIMESTAMP有什么区别"><a href="#6-DATETIME和TIMESTAMP有什么区别" class="headerlink" title="6.DATETIME和TIMESTAMP有什么区别"></a>6.DATETIME和TIMESTAMP有什么区别</h2><p>DATETIME直接存储日期和时间的完整值，与时区无关。</p>
<p>TIMESTAMP存储的是 <strong>Unix</strong> 时间戳，1970-01-01 00:00:01 UTC 以来的秒数，受<strong>时区</strong>影响。</p>
<p>DATETIME 的默认值为 <strong>null</strong>，占用 <strong>8</strong> 个字节；TIMESTAMP 的默认值为当前时间——<strong>CURRENT_TIMESTAMP</strong>，占 <strong>4</strong> 个字节，实际开发中更常用，因为可以自动更新。</p>
<h2 id="7-in和exists的区别"><a href="#7-in和exists的区别" class="headerlink" title="7.in和exists的区别"></a>7.in和exists的区别</h2><p>使用 IN 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着<strong>子查询的结果集需要全部加载到内存</strong>中。</p>
<p>EXISTS 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 <code>EXISTS</code> 条件为真。<code>EXISTS</code> 关注的是<strong>子查询是否返回行</strong>，而不是返回的具体值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 可以利用关联索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o </span><br><span class="line">            <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> u.id <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>In适用于子查询结果集较小的情况。如果子查询返回大量数据，<code>IN</code> 的性能可能会下降，因为它需要将整个结果集加载到内存。</p>
<p>EXISTS适用于子查询结果集可能很大的情况。由于 <code>EXISTS</code> <strong>只需要判断子查询是否返回行，而不需要加载整个结果集</strong>，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p>
<p><strong>NUll值陷？</strong></p>
<p>IN：如果子查询的结果集中包含 <code>NULL</code> 值，可能会导致意外的结果。例如，<code>WHERE column IN (subquery)</code>，如果 <code>subquery</code> 返回 <code>NULL</code>，则 <code>column IN (subquery)</code> 永远不会为真，除非 <code>column</code> 本身也为 <code>NULL</code>。</p>
<p>EXISTS：对 <code>NULL</code> 值的处理更加直接。<code>EXISTS</code> 只是检查子查询是否返回行，不关心行的具体值，因此不受 <code>NULL</code> 值的影响。</p>
<ul>
<li><strong>性能差异</strong>：在很多情况下，<code>EXISTS</code> 的性能优于 <code>IN</code>，特别是当子查询的表很大时。这是因为<code>EXISTS</code> 一旦找到匹配项就会立即停止查询，而<code>IN</code>可能会扫描整个子查询结果集。</li>
<li><strong>使用场景</strong>：如果子查询结果集较小且不频繁变动，<code>IN</code> 可能更直观易懂。而当子查询涉及外部查询的每一行判断，并且子查询的效率较高时，<code>EXISTS</code> 更为合适。</li>
<li><strong>NULL值处理</strong>：<code>IN</code> 能够正确处理子查询中包含NULL值的情况，而<code>EXISTS</code> 不受子查询结果中NULL值的影响，因为它关注的是行的存在性，而不是具体值。</li>
</ul>
<h2 id="10-drop-delete-turncate的区别"><a href="#10-drop-delete-turncate的区别" class="headerlink" title="10.drop,delete,turncate的区别"></a>10.drop,delete,turncate的区别</h2><p>都表示删除，但是三者有一些差别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>区别</th>
<th>delete</th>
<th>truncate</th>
<th>drop</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>属于 DML</td>
<td>属于 DDL</td>
<td>属于 DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody>
</table>
</div>
<p>因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。</p>
<h2 id="11-UNION和UNION-ALL的区别"><a href="#11-UNION和UNION-ALL的区别" class="headerlink" title="11.UNION和UNION ALL的区别"></a>11.UNION和UNION ALL的区别</h2><ul>
<li>如果使用 UNION，会在表链接后<strong>筛选掉重复</strong>的记录行</li>
<li>如果使用 UNION ALL，不会合并重复的记录行</li>
<li>从效率上说，UNION ALL 要比 UNION 快很多，如果合并<strong>没有刻意要删除重复行，那么就使用 UNION All</strong></li>
</ul>
<h2 id="12-count-，count-1-，count-列-，这三种有什么区别"><a href="#12-count-，count-1-，count-列-，这三种有什么区别" class="headerlink" title="12.count(*)，count(1)，count(列)，这三种有什么区别"></a>12.count(*)，count(1)，count(列)，这三种有什么区别</h2><p><code>COUNT(*)</code> —— <strong>统计总行数（包括 NULL）</strong></p>
<p>会读取表中的所有行，但不访问具体字段的数据，只是计数。</p>
<p>在大多数数据库（如 MySQL、Oracle）中，数据库优化器会对其进行优化，<strong>性能非常好</strong>。</p>
<p>比较推荐</p>
<p><code>COUNT(1)</code> —— <strong>统计总行数，本质类似 COUNT(*)</strong></p>
<p>数据库会把 <code>1</code> 作为一个常量值，对所有行都有效。</p>
<p><strong>与 COUNT(*) 区别</strong>：</p>
<ul>
<li><strong>理论上相同</strong>，因为 <code>1</code> 永远不为 NULL，相当于每行都有值；</li>
<li><strong>实际执行时性能几乎一致</strong>，有些数据库会将其优化为 <code>COUNT(*)</code>；</li>
<li>有些人误以为 <code>COUNT(1)</code> 比 <code>COUNT(*)</code> 快，这在现代数据库中已经不成立。</li>
</ul>
<p><code>COUNT(列)</code> —— <strong>统计指定列中非 NULL 的行数</strong></p>
<p><strong>关键区别</strong>：</p>
<ul>
<li>会忽略该列为 <code>NULL</code> 的记录；</li>
<li>需要访问该列的值，性能可能稍低；</li>
<li>可用于判断某一字段是否完整填充或做数据质量检查；</li>
</ul>
<h2 id="13-mysql中的一些基本函数，你知道哪些？"><a href="#13-mysql中的一些基本函数，你知道哪些？" class="headerlink" title="13.mysql中的一些基本函数，你知道哪些？"></a>13.mysql中的一些基本函数，你知道哪些？</h2><blockquote>
<p>一、字符串函数</p>
</blockquote>
<p><strong>CONCAT(str1, str2, …)</strong>：连接多个字符串，返回一个合并后的字符串。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;World&#x27;</span>) <span class="keyword">AS</span> Greeting;</span><br></pre></td></tr></table></figure>
<p><strong>LENGTH(str)</strong>：返回字符串的长度（字符数）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;Hello&#x27;</span>) <span class="keyword">AS</span> StringLength;</span><br></pre></td></tr></table></figure>
<p><strong>SUBSTRING(str, pos, len)</strong>：从指定位置开始，截取指定长度的子字符串。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>) <span class="keyword">AS</span> SubStr;</span><br></pre></td></tr></table></figure>
<p><strong>REPLACE(str, from_str, to_str)</strong>：将字符串中的某部分替换为另一个字符串。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> REPLACE(<span class="string">&#x27;Hello World&#x27;</span>, <span class="string">&#x27;World&#x27;</span>, <span class="string">&#x27;MySQL&#x27;</span>) <span class="keyword">AS</span> ReplacedStr;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二、数值函数</p>
</blockquote>
<p><strong>ABS(num)</strong>：返回数字的绝对值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-10</span>) <span class="keyword">AS</span> AbsoluteValue;</span><br></pre></td></tr></table></figure>
<p><strong>POWER(num, exponent)</strong>：返回指定数字的指定幂次方。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">POWER</span>(<span class="number">2</span>, <span class="number">3</span>) <span class="keyword">AS</span> PowerValue;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三、日期和时间函数</p>
</blockquote>
<p><strong>NOW()</strong>：返回当前日期和时间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NOW() <span class="keyword">AS</span> CurrentDateTime;</span><br></pre></td></tr></table></figure>
<p><strong>CURDATE()</strong>：返回当前日期。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CURDATE() <span class="keyword">AS</span> CurrentDate;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>四、聚合函数</p>
</blockquote>
<p><strong>COUNT(column)</strong>：计算指定列中的非NULL值的个数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> RowCount <span class="keyword">FROM</span> my_table;</span><br></pre></td></tr></table></figure>
<p><strong>SUM(column)</strong>：计算指定列的总和。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(price) <span class="keyword">AS</span> TotalPrice <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
<p><strong>AVG(column)</strong>：计算指定列的平均值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(price) <span class="keyword">AS</span> AveragePrice <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
<p><strong>MAX(column)</strong>：返回指定列的最大值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">AS</span> MaxPrice <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
<p><strong>MIN(column)</strong>：返回指定列的最小值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(price) <span class="keyword">AS</span> MinPrice <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
<h2 id="14-sql语句的执行顺序"><a href="#14-sql语句的执行顺序" class="headerlink" title="14.sql语句的执行顺序"></a>14.sql语句的执行顺序</h2><p><strong>FROM</strong>: 首先确定查询数据来源的表，包括进行表的连接操作（JOIN）。在这个阶段，会根据 FROM 子句和 JOIN 子句生成一个虚拟表。</p>
<p><strong>ON</strong>: 针对 JOIN 子句中的 ON 条件进行筛选，满足条件的行会进入下一步。</p>
<p><strong>JOIN</strong>: 根据 JOIN 类型（如 INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN）将 ON 条件过滤后的结果与主表或连接表进行组合，生成一个新的虚拟表。</p>
<p><strong>WHERE</strong>: 对上一步生成的虚拟表进行行级别的过滤。所有不满足 WHERE 条件的行都会被排除。</p>
<p><strong>GROUP BY</strong>: 将满足 WHERE 条件的行按照 GROUP BY 子句中指定的列进行分组。</p>
<p><strong>HAVING</strong>: 对 GROUP BY 聚合后的结果进行组级别的过滤。只有满足 HAVING 条件的组才会被保留。</p>
<p><strong>SELECT</strong>: 根据 SELECT 列表中指定的列、表达式或聚合函数，从过滤后的组中选择数据。</p>
<p><strong>DISTINCT</strong>: 如果 SELECT 子句中包含 DISTINCT 关键字，则会在此步骤移除重复的行。</p>
<p><strong>ORDER BY</strong>: 对 SELECT 语句返回的结果集进行排序。</p>
<p><strong>LIMIT/OFFSET (或 TOP)</strong>: 最后根据 LIMIT 或 OFFSET（SQL Server 中为 TOP）子句，限制返回的行数或指定从哪一行开始返回。</p>
<h2 id="15-UPDATE-语句的原理-amp-过程"><a href="#15-UPDATE-语句的原理-amp-过程" class="headerlink" title="15.UPDATE 语句的原理&amp;过程"></a>15.UPDATE 语句的原理&amp;过程</h2><p>核心目标是在确保数据完整性和一致性的前提下，修改数据库中的现有记录。</p>
<p><strong>事务层面：</strong></p>
<p>每次 UPDATE 操作通常都在一个事务中执行。即使你没有显式地使用 <code>BEGIN TRANSACTION</code> 或 <code>COMMIT</code>，数据库系统也会隐式地为每个 UPDATE 语句创建一个事务。</p>
<p>在修改数据之前，数据库会将修改前的数据和修改后的数据写入redo log。这个日志主要用于崩溃恢复，确保即使系统发生故障，也能够通过重放日志来恢复数据到一致状态。</p>
<p>同时，为了支持事务回滚（ROLLBACK），数据库还会记录undo log。Undo Log 记录了数据修改前的状态，如果事务需要回滚，数据库就可以利用 Undo Log 将数据恢复到更新之前的状态。</p>
<p><strong>锁层面：</strong></p>
<p>为了保证数据在并发更新时的正确性，数据库会使用锁定机制。</p>
<p><strong>行级锁 (Row-level Lock)</strong>：UPDATE 语句通常会尽可能地使用<strong>行级锁</strong>。这意味着只有被更新的行才会被锁定，从而最大限度地提高并发性。其他事务仍然可以访问或修改表中未被锁定的行。</p>
<p><strong>锁的持有时间</strong>：锁的粒度取决于数据库系统和具体的配置。锁会在事务提交 (COMMIT) 或回滚 (ROLLBACK) 时被释放。</p>
<p><strong>死锁 (Deadlock)</strong>：如果多个事务互相等待对方释放锁，就可能发生死锁。数据库系统通常有死锁检测和解决机制，例如通过回滚其中一个事务来打破死锁。</p>
<p><strong>数据页层面：</strong></p>
<p><strong>读取数据页</strong>：数据库首先会从磁盘读取包含待更新数据的页到内存（缓冲池/Buffer Pool）。</p>
<p><strong>在内存中修改</strong>：在内存中，数据库会对数据页中的相关记录进行修改。</p>
<p><strong>脏页 (Dirty Page)</strong>：被修改过的内存中的数据页被称为“<strong>脏页</strong>”。</p>
<p><strong>刷盘 (Flushing)</strong>：脏页不会立即写回磁盘，而是由后台进程（如 Buffer Pool Flush 线程）在适当的时候<strong>异步地写入磁盘</strong>。这样做可以减少磁盘 I/O，提高性能。事务日志的写入通常比数据页的写入更快且更频繁，因为日志是顺序写入的，而数据页的写入是随机的。</p>
<p>先写入redo log，再进行异步刷盘，这就是WAL</p>
<p><strong>索引层面：</strong></p>
<p>如果 UPDATE 操作修改了包含索引的列，那么相关的索引也需要同步更新。</p>
<ul>
<li><strong>B-Tree 索引</strong>：对于 B-Tree 索引，更新操作可能导致索引树的结构调整，例如节点分裂或合并，以保持索引的平衡和查询效率。</li>
</ul>
<p>比如新建节点的时候，会把当前节点一分为二，后面的作为新节点，新节点连接旧节点的兄弟节点，旧节点连接新节点的兄弟节点</p>
<p><strong>MVCC层面：</strong></p>
<p>当 UPDATE 发生时，MVCC 通常不是直接修改现有行，而是创建该行的一个新版本，并标记旧版本为已删除或不可见。这样，正在读取旧版本的事务就不会受到影响。</p>
<p><strong>执行过程</strong></p>
<p>sql解析：数据库接收到 UPDATE 语句后，首先对其进行词法分析、语法分析，生成一个<strong>抽象语法树</strong> (AST)。检查语句中的表名、列名是否存在，数据类型是否匹配，以及用户是否有足够的权限执行更新操作。查询优化器会根据统计信息和各种优化算法，生成<strong>一个或多个执行计划</strong>。对于 UPDATE 语句，优化器会确定最有效的方式来定位需要更新的行，这可能涉及到选择合适的索引。</p>
<p>事务开始和锁定：如果当前没有活跃的事务，数据库会为这条 UPDATE 语句隐式地开始一个新事务。为了保证数据在更新过程中的一致性和隔离性，数据库会获取必要的锁。通常是针对被更新的行获取 <strong>行级排他锁 (Exclusive Row Lock)</strong>。这意味着其他事务在当前事务提交或回滚前，无法修改这些被锁定的行。</p>
<p>数据读取和修改：<strong>读取数据页</strong>：数据库将包含待更新数据行的磁盘数据页读取到内存的 <strong>缓冲池 (Buffer Pool)</strong> 中。在修改数据之前，数据库会将这些行修改前的原始数据（即“旧版本”）写入到 <strong>撤销日志 (Undo Log)</strong> 中。Undo Log 主要用于事务回滚，如果 UPDATE 语句失败或被回滚，数据库可以利用 Undo Log 将数据恢复到原始状态。</p>
<p>在缓冲池中，数据库对数据行进行实际的修改。这包括更新列的值，如果涉及到变长字段，可能还需要调整记录的物理大小。</p>
<p>被修改过的内存数据页被称为 <strong>脏页 (Dirty Page)</strong>。</p>
<p>写入redo:在内存中的数据被修改后，数据库会将此次修改操作的详细信息（“新版本”数据以及修改操作本身）写入到 <strong>重做日志 (Redo Log)</strong> 中。Redo Log 是保证 <strong>持久性</strong> 的关键，它记录了对数据库所做的所有修改。即使数据库崩溃，也可以通过重放 Redo Log 来恢复数据。</p>
<p>Redo Log 的写入通常遵循 <strong>预写日志 (WAL)</strong> 原则，即在数据页写入磁盘之前，必须先将对应的 Redo Log 记录写入磁盘。这保证了即使系统崩溃，内存中的脏页没有来得及刷回磁盘，也能通过 Redo Log 恢复数据。</p>
<p>索引更新：如果 UPDATE 语句修改了包含索引的列，数据库还需要更新这些相关的 <strong>索引</strong>。</p>
<p>事务提交和锁的释放：当 UPDATE 语句成功执行，并且其所在的事务被提交 (COMMIT) 时，事务日志（Redo Log）会确保已经刷写到磁盘。</p>
<p>一旦事务提交，所有由该事务持有的锁都会被释放，使得其他等待的事务可以继续执行。</p>
<p>内存中的脏页会由后台线程异步地刷写到磁盘，通常不需要等待事务提交后立即刷盘，以提高性能。</p>
<p>事务回滚：如果在 UPDATE 过程中发生错误或者事务被显式回滚 (ROLLBACK)，数据库会利用之前记录的 <strong>Undo Log</strong>，将所有已经进行的修改操作撤销，使数据回到事务开始之前的状态。</p>
<h1 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h1><h2 id="1-记录货币"><a href="#1-记录货币" class="headerlink" title="1.记录货币"></a>1.记录货币</h2><p>货币在数据库中 MySQL 常用 <strong>Decimal</strong> 和 <strong>Numeric</strong> 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。</p>
<p> salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。</p>
<p>不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有<strong>一定的误差</strong>。</p>
<p>会出现大问题的！</p>
<h2 id="2-如何存储emoji"><a href="#2-如何存储emoji" class="headerlink" title="2.如何存储emoji"></a>2.如何存储emoji</h2><p>utf8 字符集仅支持最多 3 个字节的 UTF-8 字符，但是 emoji 表情（😊）是 4 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 表情时，需要使用 <strong>utf8mb4</strong> 字符集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<h2 id="3-IP地址如何在数据库里存储？"><a href="#3-IP地址如何在数据库里存储？" class="headerlink" title="3.IP地址如何在数据库里存储？"></a>3.IP地址如何在数据库里存储？</h2><p>IPv4 地址是一个 32 位的二进制数，通常以点分十进制表示法呈现，例如 <code>192.168.1.1</code>。</p>
<p><strong>字符串类型的存储方式</strong>：直接将 IP 地址作为<strong>字符串</strong>存储在数据库中，比如可以用 <code>VARCHAR(15)</code>来存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个表，使用VARCHAR类型存储IPv4地址</span><br><span class="line">CREATE TABLE <span class="title function_">ip_records</span> <span class="params">(</span></span><br><span class="line"><span class="params">    id INT AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="params">    ip_address VARCHAR(<span class="number">15</span>)</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO <span class="title function_">ip_records</span> <span class="params">(ip_address)</span> VALUES (<span class="string">&#x27;192.168.1.1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优点</strong>：直观易懂，方便直接进行数据的插入、查询和显示，不需要进行额外的转换操作。</li>
<li><strong>缺点</strong>：占用存储空间较大，字符串比较操作的性能相对较低，不利于进行范围查询。</li>
</ul>
<p>整数类型的存储方式：<strong>将 IPv4 地址转换为 32 位无符号整数进行存储，常用的数据类型有</strong> <code>INT UNSIGNED</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个表，使用INT UNSIGNED类型存储IPv4地址</span><br><span class="line">CREATE TABLE <span class="title function_">ip_records</span> <span class="params">(</span></span><br><span class="line"><span class="params">    id INT AUTO_INCREMENT PRIMARY KEY,</span></span><br><span class="line"><span class="params">    ip_address INT UNSIGNED</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">-- 插入数据，需要先将IP地址转换为整数</span><br><span class="line">INSERT INTO <span class="title function_">ip_records</span> <span class="params">(ip_address)</span> VALUES (INET_ATON(<span class="string">&#x27;192.168.1.1&#x27;</span>));</span><br><span class="line"></span><br><span class="line">-- 查询时将整数转换回IP地址</span><br><span class="line">SELECT <span class="title function_">INET_NTOA</span><span class="params">(ip_address)</span> FROM ip_records;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优点</strong>：占用存储空间小，整数比较操作的性能较高，便于进行范围查询。</li>
<li><strong>缺点</strong>：需要进行额外的转换操作，不够直观，增加了开发的复杂度。</li>
</ul>
<h2 id="4-数据管理里，数据文件大体分成哪几种数据文件？"><a href="#4-数据管理里，数据文件大体分成哪几种数据文件？" class="headerlink" title="4.数据管理里，数据文件大体分成哪几种数据文件？"></a>4.数据管理里，数据文件大体分成哪几种数据文件？</h2><p>我们每创建一个 database（数据库） 都会在 <strong>/var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</strong></p>
<p>比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1716792105334-854b63c4-0b44-43c9-b808-c5efe4f602fd.webp" alt="img"></p>
<p>然后，我们进入 /var/lib/mysql/my_test 目录，看看里面有什么文件？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaolin ~]#ls /var/lib/mysql/my_test</span><br><span class="line">db.opt  </span><br><span class="line">t_order.frm  </span><br><span class="line">t_order.ibd</span><br></pre></td></tr></table></figure>
<p>可以看到，共有三个文件，这三个文件分别代表着：</p>
<ul>
<li>db.opt，用来存储当前数据库的<strong>默认字符集和字符校验规则。</strong></li>
<li>t_order.frm ，t_order 的表结构会保存在这个文件。<strong>在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</strong></li>
<li>t_order.ibd，t_order 的表数据会保存在这个文件。<strong>表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）</strong>。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li>
</ul>
<h1 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h1><h2 id="1-慢sql问题怎么排查和解决"><a href="#1-慢sql问题怎么排查和解决" class="headerlink" title="1.慢sql问题怎么排查和解决"></a>1.慢sql问题怎么排查和解决</h2><p><strong>分析查询语句</strong>：使用<strong>EXPLAIN</strong>命令分析SQL执行计划，找出慢查询的原因，比如是否使用了<strong>全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改</strong>。</p>
<p><strong>创建或优化索引</strong>：根据查询条件创建合适的索引，特别是经常<strong>用于WHERE子句的字段、Orderby 排序的字段、Join 连表查询的字典、 group by的字段，</strong>并且如果查询中经常涉及多个字段，考虑创建<strong>联合索引</strong>，使用联合索引要符合<strong>最左匹配原则</strong>，不然会索引失效</p>
<p><strong>避免索引失效</strong>：比如不要用左模糊匹配、函数计算、表达式计算等等。</p>
<p><strong>查询优化</strong>：避免使用SELECT <em>，<strong>只查询真正需要的列</strong>；使用覆盖索引，<strong>即索引包含所有查询的字段</strong>；联表查询最好要以<strong>小表驱动大表</strong>，并且<em>*被驱动表的字段要有索引</em></em>，当然最好通过冗余字段的设计，避免联表查询。</p>
<p><strong>分页优化</strong>：针对 limit n,y 深分页的查询优化，<strong>可以把Limit查询转换成某个位置的查询</strong>：select * from tb_sku where id&gt;20000 limit 10，该方案适用于主键自增的表。</p>
<p><strong>读写分离：</strong>搭建<strong>主从架构</strong>， 利用数据库的读写分离，Web服务器在写数据的时候，访问主数据库（master），主数据库通过主从复制将数据更新同步到从数据库（slave），这样当Web服务器读数据的时候，就可以通过从数据库获得数据。这一方案使得在大量读操作的Web应用可以轻松地读取数据，而主数据库也只会承受少量的写入操作，还可以实现数据热备份，可谓是一举两得。</p>
<p><strong>优化数据库表</strong>：如果单表的数据超过了千万级别，<strong>考虑是否需要将大表拆分为小表，减轻单个表的查询压力。</strong>也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。</p>
<p><strong>使用缓存技术</strong>：引入缓存层，<strong>如Redis</strong>，<strong>存储热点数据和频繁查询的结果</strong>，<strong>但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新 db，再删除缓存的策略。</strong></p>
<h2 id="2-有sql索引优化的经验吗？"><a href="#2-有sql索引优化的经验吗？" class="headerlink" title="2.有sql索引优化的经验吗？"></a>2.有sql索引优化的经验吗？</h2><p>常见优化索引的方法：</p>
<ul>
<li><p><strong>前缀索引优化</strong>：使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p>
</li>
<li><p><strong>覆盖索引优化</strong>：覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p>
</li>
<li><p><strong>主键索引最好是自增的：</strong></p>
</li>
<li><p>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p>
</li>
<li><p>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p>
</li>
<li><p><strong>防止索引失效：</strong></p>
</li>
<li><ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="1-你了解mysql的哪些存储引擎，请详细的讲讲？"><a href="#1-你了解mysql的哪些存储引擎，请详细的讲讲？" class="headerlink" title="1.你了解mysql的哪些存储引擎，请详细的讲讲？"></a>1.你了解mysql的哪些存储引擎，请详细的讲讲？</h2><p>InnoDB：InnoDB是MySQL的默认存储引擎，<strong>具有ACID事务支持、行级锁、外键约束</strong>等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。</p>
<p>MyISAM：MyISAM是MySQL的另一种常见的存储引擎，<strong>具有较低的存储空间和内存消耗，适用于大量读操作的场景。</strong>然而，MyISAM<strong>不支持事务、行级锁和外键约束</strong>，因此在并发写入和数据完整性方面有一定的限制。</p>
<p>Memory：Memory引擎将<strong>数据存储在内存中</strong>，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它<strong>不支持事务、行级锁和外键约束</strong>。</p>
<h2 id="2-执行一条SQL请求的过程是什么？"><a href="#2-执行一条SQL请求的过程是什么？" class="headerlink" title="2.执行一条SQL请求的过程是什么？"></a>2.执行一条SQL请求的过程是什么？</h2><p>先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720155840218-b95c4217-6502-42b8-bcc5-384b297de75d.png" alt="img"></p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句<strong>如果命中查询缓存则直接返回</strong>，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，<strong>通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树</strong>，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号<strong>扩展为表上的所有列</strong>。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；比如索引</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h2 id="3-MySQL为什么InnoDB是默认引擎？"><a href="#3-MySQL为什么InnoDB是默认引擎？" class="headerlink" title="3.MySQL为什么InnoDB是默认引擎？"></a>3.MySQL为什么InnoDB是默认引擎？</h2><p>InnoDB引擎在事务支持、并发性能、崩溃恢复等方面具有优势，因此被MySQL选择为默认的存储引擎。</p>
<ul>
<li>事务支持：InnoDB引擎提供了对<strong>事务的支持</strong>，可以进行ACID（原子性、一致性、隔离性、持久性）属性的操作。Myisam存储引擎是不支持事务的。</li>
<li>并发性能：InnoDB引擎采用了<strong>行级锁定的机制</strong>，可以提供更好的并发性能，Myisam存储引擎只支持表锁，锁的粒度比较大。</li>
<li>崩溃恢复：InnoDB引引擎通过 <strong>redolog 日志实现了崩溃恢复</strong>，可以在数据库发生异常情况（如断电）时，通过日志文件进行恢复，保证数据的<strong>持久性和一致性</strong>。Myisam是不支持崩溃恢复的。</li>
</ul>
<h2 id="4-说一下mysql的innodb与MyISAM的区别？"><a href="#4-说一下mysql的innodb与MyISAM的区别？" class="headerlink" title="4.说一下mysql的innodb与MyISAM的区别？"></a>4.说一下mysql的innodb与MyISAM的区别？</h2><ul>
<li><strong>事务</strong>：InnoDB 支持事务，MyISAM 不支持事务，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。</li>
<li><strong>索引结构</strong>：InnoDB <strong>是聚簇索引</strong>，MyISAM 是非聚簇索引。聚簇索引的<strong>文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。</strong>但是辅助索引需要<strong>两次查询，先查询到主键，然后再通过主键查询到数据。</strong>因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非<strong>聚簇索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</strong></li>
<li><strong>锁粒度</strong>：<strong>InnoDB 最小的锁粒度是行锁</strong>，<strong>MyISAM 最小的锁粒度是表锁</strong>。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。</li>
<li><strong>count 的效率</strong>：InnoDB 不保存表的具体行数，执行 select count(<em>) from table 时需要全表扫描。而<em>*MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</em></em></li>
</ul>
<p>5.</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="1-索引是什么？有什么好处？"><a href="#1-索引是什么？有什么好处？" class="headerlink" title="1.索引是什么？有什么好处？"></a>1.索引是什么？有什么好处？</h2><p>索引类似于书籍的目录，可以减少扫描的数据量，提高查询效率。</p>
<ul>
<li>如果查询的时候，没有用到索引就会全表扫描，这时候查询的时间复杂度是On</li>
<li>如果用到了索引，那么查询的时候，可以基于二分查找算法，通过索引快速定位到目标数据， mysql 索引的数据结构一般是 b+树，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。</li>
</ul>
<h2 id="2-讲讲索引的分类是什么？"><a href="#2-讲讲索引的分类是什么？" class="headerlink" title="2.讲讲索引的分类是什么？"></a>2.讲讲索引的分类是什么？</h2><p>MySQL可以按照四个角度来分类索引。</p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<p>接下来，按照这些角度来说说各类索引的特点。</p>
<blockquote>
<p>按数据结构分类</p>
</blockquote>
<p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。</p>
<p>每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719803663459-11b9a82a-6bf2-46cd-b882-e0b85e5a4256.png" alt="img"></p>
<p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用<strong>主键作为聚簇索引的索引键</strong>（key）；</li>
<li>如果没有主键，就选择<strong>第一个不包含 NULL 值的唯一列作为聚簇索引</strong>的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成<strong>一个隐式自增 id</strong> 列作为聚簇索引的索引键（key）；</li>
</ul>
<p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p>
<blockquote>
<p>按物理存储分类</p>
</blockquote>
<p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p>
<p>这两个区别在前面也提到了：</p>
<ul>
<li><strong>主键索引的 B+Tree 的叶子节点存放的是实际数据</strong>，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li>
<li>二级索引的 <strong>B+Tree 的叶子节点存放的是主键值，而不是实际数据。</strong></li>
</ul>
<p>所以，在查询时使用了二级索引，<strong>如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p>
<blockquote>
<p>按字段特性分类</p>
</blockquote>
<p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p>
<ul>
<li>主键索引</li>
</ul>
<p>主键索引就是<strong>建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</strong></p>
<p>在创建表时，创建主键索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>唯一索引</li>
</ul>
<p>唯一索引建立在 <strong>UNIQUE</strong> 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，<strong>但是允许有空值。</strong></p>
<p>在创建表时，创建唯一索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...);</span><br></pre></td></tr></table></figure>
<ul>
<li>普通索引</li>
</ul>
<p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p>
<p>在<strong>创建表时，创建普通索引的方式如下</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>建表后，如果要创建普通索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(index_column_1,index_column_2,...);</span><br></pre></td></tr></table></figure>
<ul>
<li>前缀索引</li>
</ul>
<p>前缀索引是<strong>指对字符类型字段的前几个字符建立的索引</strong>，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 <strong>char、 varchar、binary、varbinary 的列上。</strong></p>
<p>使用前缀索引的目的是为了<strong>减少索引占用的存储空间，提升查询效率</strong>。</p>
<p>在创建表时，创建前缀索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX(column_name(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name(column_name(length));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>按字段个数分类</p>
</blockquote>
<p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p>
<ul>
<li>建立在单列上的索引称为单列索引，比如主键索引；</li>
<li>建立在<strong>多列上的索引称为联合索引；</strong></li>
</ul>
<p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p>
<p>比如，将商品表中的 product_no 和 name 字段组合成联合索引(product_no, name)，创建联合索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure>
<p>联合索引(product_no, name) 的 B+Tree 示意图如下（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719803664258-9a1579a3-abd6-44e4-9393-6720d53a53b4.png" alt="img"></p>
<p>可以看到，<strong>联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</strong></p>
<p>也就是说，联合索引查询的 B+Tree <strong>是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</strong></p>
<p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照<strong>最左优先的方式</strong>进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a=1；</li>
<li>where a=1 and b=2 and c=3；</li>
<li>where a=1 and b=2；</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b=2；</li>
<li>where c=3；</li>
<li>where b=2 and c=3；</li>
</ul>
<p>上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p>
<p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
<h2 id="3-MySQL聚簇索引和非聚簇索引的区别是什么？"><a href="#3-MySQL聚簇索引和非聚簇索引的区别是什么？" class="headerlink" title="3.MySQL聚簇索引和非聚簇索引的区别是什么？"></a>3.MySQL聚簇索引和非聚簇索引的区别是什么？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1721709935338-fe01a58d-da89-47b5-9288-0f0e966937ca.png" alt="img"></p>
<ul>
<li><strong>数据存储</strong>：在聚簇索引中，数据行按照<strong>索引键值的顺序存储</strong>，也就是说，索引的叶子节点包含了<strong>实际的数据行</strong>。这意味着索引结构本身就是数据的物理存储结构。非聚簇索引的叶子节点不包含完整的数据行，而是<strong>包含指向数据行的指针或主键值。数据行本身存储在聚簇索引中。</strong></li>
<li><strong>索引与数据关系</strong>：由于数据与索引紧密相连，<strong>当通过聚簇索引查找数据时，可以直接从索引中获得数据行</strong>，而不需要额外的步骤去查找数据所在的位置。当通过非聚簇索引查找数据时，首先在<strong>非聚簇索引中找到对应的主键值，然后通过这个主键值回溯到聚簇索引中查找实际的数据行，这个过程称为“回表”。</strong></li>
<li><strong>唯一性</strong>：聚簇索引通常是基于<strong>主键构建</strong>的，因此每个表只能有一个聚簇索引，因为数据只能有一种物理排序方式。一个表可以有多个非聚簇索引，因为它们不直接影响数据的物理存储位置。</li>
<li><strong>效率</strong>：对于范围查询和排序查询，聚簇索引通常更有效率，因为它避免了额外的寻址开销。非聚簇索引在使用覆盖索引进行查询时效率更高，因为它不需要读取完整的数据行。但是需要进行回表的操作，使用非聚簇索引效率比较低，因为需要进行额外的回表操作。</li>
</ul>
<h2 id="4-如果聚簇索引的数据更新，它的存储要不要变化？"><a href="#4-如果聚簇索引的数据更新，它的存储要不要变化？" class="headerlink" title="4.如果聚簇索引的数据更新，它的存储要不要变化？"></a>4.如果聚簇索引的数据更新，它的存储要不要变化？</h2><ul>
<li>如果更新的数据是非索引数据，也就是普通的用户记录，那么存储结构是不会发生变化</li>
<li>如果更新的数据是<strong>索引数据</strong>，那么存储结构是有变化的，<strong>因为要维护 b+树的有序性</strong></li>
</ul>
<h2 id="5-MySQL主键是聚簇索引吗？"><a href="#5-MySQL主键是聚簇索引吗？" class="headerlink" title="5.MySQL主键是聚簇索引吗？"></a>5.MySQL主键是聚簇索引吗？</h2><p>在MySQL的InnoDB存储引擎中，<strong>主键确实是以聚簇索引的形式存储的。</strong></p>
<p>InnoDB将数据存储在B+树的结构中，其中主键索引的B+树就是所谓的聚簇索引。这意味着表中的数据行在物理上是按照主键的顺序排列的，聚簇索引的叶节点包含了实际的数据行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1721710061075-2cc270e3-0324-4856-8d67-bd633a620e06.png" alt="img"></p>
<p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li>
</ul>
<p><strong>一张表只能有一个聚簇索引</strong>，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p>
<h2 id="6-什么字段适合当做主键？"><a href="#6-什么字段适合当做主键？" class="headerlink" title="6.什么字段适合当做主键？"></a>6.什么字段适合当做主键？</h2><ul>
<li><strong>字段具有唯一性，且不能为空的特性</strong></li>
<li>字段最好的是有递增的趋势的，如果字段的值是随机无序的，可能会引发页分裂的问题，造型性能影响。</li>
<li>不建议用业务数据作为主键，比如会员卡号、订单号、学生号之类的，因为我们无法预测未来会不会因为业务需要，而出现业务字段重复或者重用的情况。</li>
<li>通常情况下<strong>会用自增字段来做主键</strong>，对于单机系统来说是没问题的。但是，如果有多台服务器，各自都可以录入数据，那就不一定适用了。因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题，<strong>这时候就需要考虑分布式 id 的方案了。</strong></li>
</ul>
<h2 id="7-性别字段能加索引么？为啥？"><a href="#7-性别字段能加索引么？为啥？" class="headerlink" title="7.性别字段能加索引么？为啥？"></a>7.性别字段能加索引么？为啥？</h2><p>不建议针对性别字段加索引。</p>
<p>实际上与索引创建规则之一区分度有关，性别字段假设有100w数据，50w男、50w女，区别度几乎等于 0 。</p>
<p>区分度的计算方式 ：select count(DISTINCT sex)/count(*) from sys_user</p>
<p>实际上对于性别字段不适合创建索引，<strong>是因为select * 操作</strong>，还得进行50w次回表操作，根据主键从聚簇索引中找到其他字段 ，这一部分开销从上面的测试来说还是比较大的，所以从性能角度来看不建议性别字段加索引，加上索引并不是索引失效，<strong>而是回表操作使得变慢的。</strong></p>
<p>既然走索引的查询的成本比全表扫描高，优化器就会选择全表扫描的方向进行查询，这时候建立的性别字段索引就没有启到加快查询的作用，反而还因为创建了索引占用了空间。</p>
<h2 id="8-表中十个字段，你主键用自增ID还是UUID，为什么？"><a href="#8-表中十个字段，你主键用自增ID还是UUID，为什么？" class="headerlink" title="8.表中十个字段，你主键用自增ID还是UUID，为什么？"></a>8.表中十个字段，你主键用自增ID还是UUID，为什么？</h2><p>用的是自增 id。</p>
<p>因为 uuid 相对顺序的自增 id 来说是<strong>毫无规律</strong>可言的，新行的值不一定要比之前的主键的值要大，所以 innodb 无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。</p>
<p>这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：</p>
<ul>
<li>写入的目标页很可能已经刷新到<strong>磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb 在插入之前不得不先找到并从磁盘读取目标页到内存中</strong>，这将导致大量的随机 IO。</li>
<li>因为写入是乱序的，innodb <strong>不得不频繁的做页分裂操作</strong>，以便为新的行分配空间，页分裂导致移动大量的数据，影响性能。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致<strong>数据会有碎片</strong>。</li>
</ul>
<p>结论：使用 InnoDB 应该尽可能的<strong>按主键的自增顺序插入</strong>，并且尽可能使用单调的增加的聚簇键的值来插入新行。</p>
<h2 id="9-什么自增ID更快一些，UUID不快吗，它在B-树里面存储是有序的吗"><a href="#9-什么自增ID更快一些，UUID不快吗，它在B-树里面存储是有序的吗" class="headerlink" title="9.什么自增ID更快一些，UUID不快吗，它在B+树里面存储是有序的吗?"></a>9.什么自增ID更快一些，UUID不快吗，它在B+树里面存储是有序的吗?</h2><p>自增的主键的值是顺序的，所以 Innodb 把每一条记录都存储在一条记录的后面，所以自增 id 更快的原因：</p>
<ul>
<li>下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，<strong>主键页就会近乎于顺序的记录填满</strong>，提升了页面的最大填充率，不会有页的浪费</li>
<li><strong>新插入的行一定会在原有的最大数据行下一行</strong>，mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗</li>
<li>减少了页分裂和碎片的产生</li>
</ul>
<p>但是 UUID 不是递增的，MySQL 中索引的数据结构是 B+Tree，这种数据结构的特点是索引树上的节点的数据是有序的，而如果使用 UUID 作为主键，那么每次插入数据时，因为<strong>无法保证每次产生的 UUID 有序，所以就会出现新的 UUID 需要插入到索引树的中间去</strong>，这样可能会频繁地导致页分裂，使性能下降。</p>
<p>而且，<strong>UUID 太占用内存。每个 UUID 由 36 个字符组成</strong>，在字符串进行比较时，需要从<strong>前往后比较，字符串越长，性能越差。另外字符串越长，占用的内存越大，由于页的大小是固定的，</strong>这样一个页上能存放的关键字数量就会越少，这样最终就会导致索引树的高度越大，在索引搜索的时候，发生的磁盘 IO 次数越多，性能越差。</p>
<h2 id="10-Mysql中的索引是怎么实现的-？"><a href="#10-Mysql中的索引是怎么实现的-？" class="headerlink" title="10.Mysql中的索引是怎么实现的 ？"></a>10.Mysql中的索引是怎么实现的 ？</h2><p>MySQL InnoDB 引擎是用了B+树作为了索引的数据结构。</p>
<p>B+Tree 是一种多叉树，<strong>叶子节点才存放数据，非叶子节点只存放索引</strong>，而且每个节点里的数据是<strong>按主键顺序存放</strong>的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，<strong>分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</strong></p>
<p>主键索引的 B+Tree 如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717479903616-831081f3-45bc-4436-a066-2702266abfce.png" alt="img"></p>
<p>比如，我们执行了下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id<span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：</p>
<ul>
<li>将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；</li>
<li>在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；</li>
<li>在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。</li>
</ul>
<p>数据库的索引和数据都是存储在硬盘的，我们可以把<strong>读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。</strong></p>
<p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。</strong></p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="11-查询数据时，到了B-树的叶子节点，之后的查找数据是如何做？"><a href="#11-查询数据时，到了B-树的叶子节点，之后的查找数据是如何做？" class="headerlink" title="11.查询数据时，到了B+树的叶子节点，之后的查找数据是如何做？"></a>11.查询数据时，到了B+树的叶子节点，之后的查找数据是如何做？</h2><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。那 InnoDB 是如何给记录创建页目录的呢？</p>
<p>页目录与记录的关系如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png" alt="图片"></p>
<p>页目录创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，这些记录包括<strong>最小记录和最大记录</strong>，但不包括标记为“已删除”的记录；</li>
<li><strong>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</strong>（上图中粉红色字段）</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的<strong>地址偏移量也被称之为槽</strong>（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
<p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p>
<ul>
<li>先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li>
<li>再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li>
<li>再从 3 号槽指向的主键值为 9 记录开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。</li>
</ul>
<h2 id="12-B-树的特性是什么？"><a href="#12-B-树的特性是什么？" class="headerlink" title="12.B+树的特性是什么？"></a>12.B+树的特性是什么？</h2><ul>
<li><strong>所有叶子节点都在同一层</strong>：这是B+树的一个重要特性，<strong>确保了所有数据项的检索都具有相同的I/O延迟</strong>，提高了搜索效率。<strong>每个叶子节点都包含指向相邻叶子节点的指针，形成一个链表</strong>，由于叶子节点之间的链接，B+树非常适合进行范围查询和排序扫描。可以沿着叶子节点的链表顺序访问数据，而无需进行多次随机访问。</li>
<li><strong>非叶子节点存储键值</strong>：非叶子节点仅存储键值和指向子节点的指针，不包含数据记录。这些键值用于指导搜索路径，帮助快速定位到正确的叶子节点。并且，<strong>由于非叶子节点只存放键值，当数据量比较大时</strong>，相对于B树，B+树的层高更少，查找效率也就更高。</li>
<li><strong>叶子节点存储数据记录</strong>：与B树不同，B+树的叶子节点存储实际的数据记录或指向数据记录的指针。<strong>这意味着每次搜索都会到达叶子节点，才能找到所需数据。</strong></li>
<li><strong>自平衡</strong>：B+树在插入、删除和更新操作后会<strong>自动重新平衡</strong>，<strong>确保树的高度保持相对稳定</strong>，从而保持良好的搜索性能。每个节点最多可以有M个子节点，最少可以有ceil(M/2)个子节点（除了根节点），这里的M是树的阶数。</li>
</ul>
<h2 id="13-说说B-树和B树的区别"><a href="#13-说说B-树和B树的区别" class="headerlink" title="13.说说B+树和B树的区别"></a>13.说说B+树和B树的区别</h2><ul>
<li>在B+树中，数据都存储在叶子节点上，而非叶子节点只存储索引信息；<strong>而B树的非叶子节点既存储索引信息也存储部分数据。</strong></li>
<li>B+树的叶子节点使用链表相连，便于范围查询和顺序访问；<strong>B树的叶子节点没有链表连接。</strong></li>
<li>B+树的查找性能更稳定，每次查找都需要查找到叶子节点；而B树的查找可能会在非叶子节点找到数据，性能相对不稳定。</li>
</ul>
<h2 id="14-B-树的好处是什么？"><a href="#14-B-树的好处是什么？" class="headerlink" title="14.B+树的好处是什么？"></a>14.B+树的好处是什么？</h2><p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。</p>
<p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719383425822-763f8efe-c2bd-4880-8a48-75b96d4c059e.png" alt="img"></p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，<strong>仅存放索引</strong>，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，<strong>查询底层节点的磁盘 I/O次数会更少。</strong></li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），<strong>这些冗余索引让 B+ 树在插入、删除的效率都更高</strong>，比如删除根节点的时候，<strong>不会像 B 树那样会发生复杂的树的变化；</strong></li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于0范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<h2 id="15-B-树的叶子节点链表是单向还是双向？"><a href="#15-B-树的叶子节点链表是单向还是双向？" class="headerlink" title="15.B+树的叶子节点链表是单向还是双向？"></a>15.B+树的叶子节点链表是单向还是双向？</h2><p>双向的，为了实现<strong>倒序遍历或者排序。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240725232027951.png" alt="image-20240725232027951"></p>
<p>Innodb 使用的 B+ 树有一些特别的点，比如：</p>
<ul>
<li>B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。</li>
<li>B+ 树点节点内容是<strong>数据页</strong>，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。</li>
</ul>
<p>Innodb 根据索引类型不同，分为聚集和二级索引。他们区别在于，<strong>聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</strong></p>
<p>因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。</p>
<h2 id="16-MySQL为什么用B-树结构？和其他结构比的优点？"><a href="#16-MySQL为什么用B-树结构？和其他结构比的优点？" class="headerlink" title="16.MySQL为什么用B+树结构？和其他结构比的优点？"></a>16.MySQL为什么用B+树结构？和其他结构比的优点？</h2><ul>
<li><strong>B+Tree vs B Tree：</strong>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</li>
<li><strong>B+Tree vs 二叉树：</strong>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。<strong>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少</strong>，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</li>
<li><strong>B+Tree vs Hash：</strong>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。但是 Hash 表<strong>不适合做范围查询</strong>，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因</li>
</ul>
<h2 id="17-为什么-MysSQL-不用-跳表？"><a href="#17-为什么-MysSQL-不用-跳表？" class="headerlink" title="17.为什么 MysSQL 不用 跳表？"></a>17.为什么 MysSQL 不用 跳表？</h2><p>B+树的高度<strong>在3层时存储的数据可能已达千万级别</strong>，但对于跳表而言同样去维护千万的数据量那么所造成的<strong>跳表层数过高而导致的磁盘io次数增多</strong>，也就是使用B+树在存储同样的数据下磁盘io次数更少</p>
<h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><h2 id="1-联合索引的实现原理？"><a href="#1-联合索引的实现原理？" class="headerlink" title="1.联合索引的实现原理？"></a>1.联合索引的实现原理？</h2><p>将将多个字段组合成一个索引，<strong>该索引就被称为联合索引。</strong></p>
<p>比如，将商品表中的 product_no 和 name 字段组合成联合索引(product_no, name)，创建联合索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure>
<p>联合索引(product_no, name) 的 B+Tree 示意图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719977405693-4cc4e63b-d869-490f-a9fc-a19962a75a87.png" alt="img"></p>
<p>可以看到，联合索引的<strong>非叶子节点用两个字段的值作为 B+Tree 的 key 值</strong>。当在联合索引查询数据时，<strong>先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</strong></p>
<p>也就是说，联合索引查询的 B+Tree 是先<strong>按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</strong></p>
<p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照<strong>最左优先的</strong>方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a=1；</li>
<li>where a=1 and b=2 and c=3；</li>
<li>where a=1 and b=2；</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b=2；</li>
<li>where c=3；</li>
<li>where b=2 and c=3；</li>
</ul>
<p>上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<p>我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719977405675-a650711f-437b-4abf-b4b5-e65e7fbec2bb.png" alt="img"></p>
<p>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行where b = 2这种查询条件没有办法利用联合索引的，<strong>利用索引的前提是索引里的 key 是有序的</strong>。</p>
<p>只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行where a = 2 and b = 7是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。</p>
<h2 id="2-创建联合索引时需要注意什么？"><a href="#2-创建联合索引时需要注意什么？" class="headerlink" title="2.创建联合索引时需要注意什么？"></a>2.创建联合索引时需要注意什么？</h2><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p>
<p>区分度就是<strong>某个字段 column 不同值的个数「除以」表的总行数</strong>，计算公式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720939575546-c5659e14-45f9-478e-8c91-11a707675a14.png" alt="img"></p>
<p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p>
<p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，<strong>因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描</strong></p>
<h2 id="3-联合索引ABC，现在有个执行语句是A-XXX-and-C-lt-XXX，索引怎么走"><a href="#3-联合索引ABC，现在有个执行语句是A-XXX-and-C-lt-XXX，索引怎么走" class="headerlink" title="3.联合索引ABC，现在有个执行语句是A = XXX and C &lt; XXX，索引怎么走"></a>3.联合索引ABC，现在有个执行语句是A = XXX and C &lt; XXX，索引怎么走</h2><p>根据最左匹配原则，A可以走联合索引，C不会走联合索引，但是C可以<strong>走索引下推</strong></p>
<h2 id="4-联合索引-a-b-c-，查询条件-where-b-gt-xxx-and-a-x-会生效吗"><a href="#4-联合索引-a-b-c-，查询条件-where-b-gt-xxx-and-a-x-会生效吗" class="headerlink" title="4.联合索引(a,b,c) ，查询条件 where b &gt; xxx and a = x 会生效吗"></a>4.联合索引(a,b,c) ，查询条件 where b &gt; xxx and a = x 会生效吗</h2><p>索引会生效，a 和 b 字段都能利用联合索引，符合联合索引最左匹配原则。</p>
<h2 id="5-联合索引-a-b，c-，where条件是-a-2-and-c-1，能用到联合索引吗？"><a href="#5-联合索引-a-b，c-，where条件是-a-2-and-c-1，能用到联合索引吗？" class="headerlink" title="5.联合索引 (a, b，c)，where条件是 a=2 and c = 1，能用到联合索引吗？"></a>5.联合索引 (a, b，c)，where条件是 a=2 and c = 1，能用到联合索引吗？</h2><p>会用到联合索引，但是只有 a 才能走索引，c 无法走索引，因为<strong>不符合最左匹配原则</strong>。虽然 c 无法走索引， 但是 c 字段在 5.6 版本之后，<strong>会有索引下推的优化，能减少回表查询的次数。</strong></p>
<h2 id="6-索引失效有哪些？"><a href="#6-索引失效有哪些？" class="headerlink" title="6.索引失效有哪些？"></a>6.索引失效有哪些？</h2><p>6 种会发生索引失效的情况：</p>
<ul>
<li>当我们使用<strong>左或者左右模糊匹配</strong>的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中<strong>对索引列使用函数</strong>，就会导致索引失效。</li>
<li>当我们在查询条件中对索引列进行<strong>表达式计算</strong>，也是无法走索引的。</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果<strong>字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</strong></li>
<li>联合索引要能正确使用需要遵循<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 <strong>OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong>，那么索引会失效。</li>
</ul>
<h2 id="7-什么情况下会回表查询"><a href="#7-什么情况下会回表查询" class="headerlink" title="7.什么情况下会回表查询"></a>7.什么情况下会回表查询</h2><p>从物理存储的角度来看，索引分为<strong>聚簇索引（主键索引）、二级索引（辅助索引）。</strong></p>
<p>它们的主要区别如下：</p>
<ul>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。</p>
<p><strong>如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表</strong>。</p>
<h1 id="索引原则"><a href="#索引原则" class="headerlink" title="索引原则"></a>索引原则</h1><h2 id="1-什么是覆盖索引？"><a href="#1-什么是覆盖索引？" class="headerlink" title="1.什么是覆盖索引？"></a>1.什么是覆盖索引？</h2><p>覆盖索引是指一个<strong>索引包含了查询所需的所有列</strong>，因此不需要访问表中的数据行就能完成查询。</p>
<p>换句话说，查询所需的所有数据都能从索引中直接获取，而<strong>不需要进行回表查询</strong>。覆盖索引能够显著提高查询性能，因为<strong>减少了访问数据页的次数</strong>，从而减少了I/O操作。</p>
<p>假设有一张表 employees，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  age <span class="type">INT</span>,</span><br><span class="line">  department <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age_department <span class="keyword">ON</span> employees(name, age, department);</span><br></pre></td></tr></table></figure>
<p>如果我们有以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, department <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，idx_name_age_department 是一个覆盖索引，因为它包含了查询所需的所有列：name、age 和 department。查询可以完全在索引层完成，而不需要访问表中的数据行。</p>
<h2 id="2-如果一个列即使单列索引，又是联合索引，单独查它的话先走哪个？"><a href="#2-如果一个列即使单列索引，又是联合索引，单独查它的话先走哪个？" class="headerlink" title="2.如果一个列即使单列索引，又是联合索引，单独查它的话先走哪个？"></a>2.如果一个列即使单列索引，又是联合索引，单独查它的话先走哪个？</h2><p>mysql 优化器会分析每个索引的查询成本，然后选择成本最低的方案来执行 sql。</p>
<p>如果单列索引是 a，联合索引是（a ，b），那么针对下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a, b <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a <span class="operator">=</span> ? <span class="keyword">and</span> b <span class="operator">=</span>?</span><br></pre></td></tr></table></figure>
<p>优化器会选择<strong>联合索引</strong>，因为查询成本更低，查询也不需要回表，直接索引覆盖了。</p>
<h2 id="3-索引已经建好了，那我再插入一条数据，索引会有哪些变化？"><a href="#3-索引已经建好了，那我再插入一条数据，索引会有哪些变化？" class="headerlink" title="3.索引已经建好了，那我再插入一条数据，索引会有哪些变化？"></a>3.索引已经建好了，那我再插入一条数据，索引会有哪些变化？</h2><p>插入新数据可能导致B+树结构的调整和索引信息的更新，以保持B+树的平衡性和正确性，这些变化通常由数据库系统自动处理，确保数据的一致性和索引的有效性。</p>
<p>如果<strong>插入的数据导致叶子节点已满，可能会触发叶子节点的分裂操作</strong>，以保持B+树的平衡性。</p>
<h2 id="4-索引字段是不是建的越多越好？"><a href="#4-索引字段是不是建的越多越好？" class="headerlink" title="4.索引字段是不是建的越多越好？"></a>4.索引字段是不是建的越多越好？</h2><p>不是，建的的越多会占用越多的空间，而且在写入频繁的场景下，对于B+树的维护所付出的性能消耗也会越大</p>
<h2 id="5-索引的优缺点？"><a href="#5-索引的优缺点？" class="headerlink" title="5.索引的优缺点？"></a>5.索引的优缺点？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p>
<ul>
<li>需要占用<strong>物理空间</strong>，数量越大，占用空间越大；</li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>
<li>会降低表的增删改的效率，因为每次增删改索引，<strong>B+ 树为了维护索引有序性，都需要进行动态维护。</strong></li>
</ul>
<p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p>
<h2 id="6-怎么决定建立哪些索引"><a href="#6-怎么决定建立哪些索引" class="headerlink" title="6.怎么决定建立哪些索引?"></a>6.怎么决定建立哪些索引?</h2><blockquote>
<p>什么时候适用索引？</p>
</blockquote>
<ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常<strong>用于 <code>WHERE</code> 查询条件的字段</strong>，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<blockquote>
<p>什么时候不需要创建索引？</p>
</blockquote>
<ul>
<li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里<strong>用不到的字段</strong>，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li>字段中存在<strong>大量重复数据</strong>，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li><strong>经常更新的字段不用创建索引</strong>，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，</li>
</ul>
<h2 id="7-索引优化详细讲讲"><a href="#7-索引优化详细讲讲" class="headerlink" title="7.索引优化详细讲讲"></a>7.索引优化详细讲讲</h2><p>常见优化索引的方法：</p>
<ul>
<li>前缀索引优化：使用前缀索引是为了<strong>减小索引字段大小</strong>，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</li>
<li>覆盖索引优化：覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</li>
<li><strong>主键索引最好是自增的：</strong><ul>
<li>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</li>
<li>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</li>
</ul>
</li>
<li>防止索引失效：<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
</li>
</ul>
<h2 id="8-了解过前缀索引吗？"><a href="#8-了解过前缀索引吗？" class="headerlink" title="8.了解过前缀索引吗？"></a>8.了解过前缀索引吗？</h2><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些<strong>大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</strong></p>
<h2 id="9-索引覆盖是什么"><a href="#9-索引覆盖是什么" class="headerlink" title="9.索引覆盖是什么"></a>9.索引覆盖是什么</h2><p><strong>查询所需要的所有字段都能从索引中直接获取，无需回表（访问原始数据行）</strong>。</p>
<p>查询的字段<strong>都包含在某个联合索引中</strong>；</p>
<p>查询条件中的字段顺序 <strong>满足最左前缀原则</strong>；</p>
<p>查询语句中的字段<strong>都在索引中出现</strong>（<code>SELECT</code> 的字段 + <code>WHERE</code> 条件字段）；</p>
<p><strong>不能使用 <code>SELECT \*</code></strong>，因为 <code>*</code> 可能包含未在索引中的字段。</p>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT name, age FROM user WHERE name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="10-索引跳跃式什么？"><a href="#10-索引跳跃式什么？" class="headerlink" title="10.索引跳跃式什么？"></a>10.索引跳跃式什么？</h2><blockquote>
<p><strong>索引跳跃</strong>指的是：<strong>查询未命中联合索引前缀中的某一列时，跳过该列条件，退化为对索引的部分范围扫描</strong>，导致<strong>扫描数据量增大、效率变差</strong>。</p>
</blockquote>
<p>假设有如下联合索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">CREATE INDEX idx_user ON user (a, b, c);</span><br></pre></td></tr></table></figure>
<p>联合索引 <code>(a, b, c)</code> 遵循<strong>最左前缀匹配原则</strong>，即：</p>
<ul>
<li>查询中必须先用到 <code>a</code>，再用到 <code>b</code> 才能用到 <code>c</code>；</li>
<li>如果<strong>跳过中间某一列</strong>，后面的列索引就失效。</li>
</ul>
<p>假设查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT * FROM user WHERE a = 1 AND c = 3;</span><br></pre></td></tr></table></figure>
<p>这时问题就来了：</p>
<ul>
<li>✅ <code>a</code> 是第一列，能命中索引；</li>
<li>❌ <strong><code>b</code> 被跳过</strong>，直接使用了 <code>c</code>；</li>
<li>✅ <code>c</code> 是索引中的一列，但由于 <code>b</code> 被跳过，<strong><code>c</code> 不生效</strong>。</li>
</ul>
<p>🔍 实际执行效果：</p>
<ul>
<li>MySQL 会使用 <code>(a)</code> 的范围扫描；</li>
<li>对满足 <code>a=1</code> 的所有记录，还要<strong>回表检查 <code>c=3</code> 是否成立</strong>；</li>
<li><code>c</code> 的索引效果完全丧失，造成了<strong>索引跳跃</strong>。</li>
</ul>
<p>其本质是 <strong>违反了最左前缀原则</strong>，在 <code>WHERE a = ? AND c = ?</code> 这类场景中，<code>c</code> 字段的索引无法生效，性能下降。</p>
<p>避免索引跳跃：</p>
<p><strong>不要跳过联合索引中间的字段</strong></p>
<ul>
<li>联合索引中间字段若没在 <code>WHERE</code> 中使用，后面的字段无法生效；</li>
</ul>
<p><strong>调整索引字段顺序</strong></p>
<ul>
<li>把常用的查询条件字段放在索引前缀中；</li>
</ul>
<p><strong>考虑建多个单列索引或覆盖多个查询场景的联合索引</strong></p>
<h2 id="11-mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？"><a href="#11-mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？" class="headerlink" title="11.mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？"></a>11.mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？</h2><p>MySQL 从 <strong>5.6 开始引入的优化技术</strong>，用于提升通过索引查询的效率。它通过<strong>将部分 WHERE 条件“下推”到存储引擎层</strong>，避免回表，提高性能。</p>
<p>先用索引筛选出更符合条件的记录，再决定是否回表取数据。</p>
<ul>
<li>存储引擎读取索引记录</li>
<li><strong>先在索引字段中判断 WHERE 条件是否成立</strong></li>
<li>满足条件才回表取整行数据</li>
</ul>
<blockquote>
<p>优点：<strong>减少不必要的回表次数 → 提升性能</strong></p>
</blockquote>
<p>条件：</p>
<p>查询条件中涉及了 <strong>联合索引的多个字段</strong></p>
<p>被下推的字段在 <strong>索引中存在</strong></p>
<p>WHERE 条件中使用的字段顺序与索引字段顺序 <strong>不冲突</strong></p>
<p><strong>仅支持 InnoDB 引擎</strong></p>
<p>Using index condition，说明使用了索引下推</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1-事务的特性是什么？如何实现的？"><a href="#1-事务的特性是什么？如何实现的？" class="headerlink" title="1.事务的特性是什么？如何实现的？"></a>1.事务的特性是什么？如何实现的？</h2><ul>
<li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li>
<li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li>
<li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li>
<li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p>MySQL InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p>
<ul>
<li>持久性是通过 <strong>redo log</strong> （重做日志）来保证的；</li>
<li>原子性是通过 <strong>undo log</strong>（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>
<h2 id="2-mysql可能出现什么和并发相关问题？"><a href="#2-mysql可能出现什么和并发相关问题？" class="headerlink" title="2.mysql可能出现什么和并发相关问题？"></a>2.mysql可能出现什么和并发相关问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p>
<p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p>
<p>接下来，通过举例子给大家说明，这些问题是如何发生的。</p>
<blockquote>
<p>脏读</p>
</blockquote>
<p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p>
<p>举个栗子。</p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717913436378-906c5ccf-b284-4fa8-89ea-3e832afd7cc9.png" alt="img"></p>
<p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p>
<blockquote>
<p>不可重复读</p>
</blockquote>
<p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p>
<p>举个栗子。</p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，**在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</p>
<p>**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717913436386-ec8e4aa9-6bd9-4555-9802-c18567b762df.png" alt="img"></p>
<blockquote>
<p>幻读</p>
</blockquote>
<p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p>
<p>举个栗子。</p>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717913436123-4db9c815-cc4b-4861-b2ff-3a293e37416d.png" alt="img"></p>
<p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p>
<p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p>
<h2 id="3-哪些场景不适合脏读，举个例子？"><a href="#3-哪些场景不适合脏读，举个例子？" class="headerlink" title="3.哪些场景不适合脏读，举个例子？"></a>3.哪些场景不适合脏读，举个例子？</h2><p><strong>脏读是指一个事务在读取到另一个事务未提交的数据时发生</strong>。脏读可能会导致不一致的数据被读取，并可能引起问题。以下是一些不适合脏读的场景：</p>
<ul>
<li><strong>银行系统</strong>：在银行系统中，如果一个账户的余额正在被调整但尚未提交，另一个事务读取了这个临时的余额，可能会导致客户看到不正确的余额。</li>
<li><strong>库存管理系统</strong>：在一个库存管理系统中，如果一个商品的数量正在被更新但尚未提交，另一个事务读取了这个临时的数量，可能会导致库存管理错误。</li>
<li><strong>在线订单系统</strong>：在一个在线订单系统中，如果一个订单正在被修改但尚未提交，另一个事务读取了这个临时的订单状态，可能导致订单状态显示错误，客户收到不准确的信息。</li>
</ul>
<p>在以上这些场景中，脏读可能导致严重的问题，因此应该避免发生脏读，保证数据的一致性和准确性。</p>
<h2 id="4-mysql的是怎么解决并发问题的？"><a href="#4-mysql的是怎么解决并发问题的？" class="headerlink" title="4.mysql的是怎么解决并发问题的？"></a>4.mysql的是怎么解决并发问题的？</h2><ul>
<li>锁机制：Mysql提供了多种锁机制来保证数据的一致性，<strong>包括行级锁、表级锁、页级锁等</strong>。通过锁机制，可以在读写操作时对数据进行加锁，确保同时只有一个操作能够访问或修改数据。</li>
<li>事务隔离级别：Mysql提供了多种事务隔离级别，包括<strong>读未提交、读已提交、可重复读和串行化</strong>。通过设置合适的事务隔离级别，可以在多个事务并发执行时，控制事务之间的隔离程度，以避免数据不一致的问题。</li>
<li>MVCC（多版本并发控制）：Mysql使用<strong>MVCC</strong>来管理并发访问，它通过在数据库中保存不同版本的数据来实现不同事务之间的隔离。在读取数据时，Mysql会根据事务的隔离级别来选择合适的数据版本，从而保证数据的一致性。</li>
</ul>
<h2 id="5-事务的隔离级别有哪些？"><a href="#5-事务的隔离级别有哪些？" class="headerlink" title="5.事务的隔离级别有哪些？"></a>5.事务的隔离级别有哪些？</h2><ul>
<li><strong>读未提交（read uncommitted）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li><strong>读提交（read committed）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li><strong>可重复读（repeatable read）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li>
<li><strong>串行化（serializable）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p>按隔离水平高低排序如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2024/webp/29791029/1719915429467-c898c6a3-b1ed-4cb6-83e3-a669c33a90d5.webp#averageHue=%23f5ece3&amp;clientId=uf0d36b72-0b14-4&amp;from=paste&amp;id=u6640a0ec&amp;originHeight=144&amp;originWidth=962&amp;originalType=url&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf49dbf46-7e2a-43f0-910d-4760225a191&amp;title=" alt="img"></p>
<p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2024/webp/29791029/1719915429433-f7de575e-083a-4fea-b756-7737ae75c646.webp#averageHue=%23f7f6df&amp;clientId=uf0d36b72-0b14-4&amp;from=paste&amp;id=ubc5e8407&amp;originHeight=464&amp;originWidth=1080&amp;originalType=url&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf4d37617-5ee5-4baf-9670-5b8208826c0&amp;title=" alt="img">也就是说：</p>
<ul>
<li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li>
<li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生<strong>脏读现象；</strong></li>
<li>在「可重复读」隔离级别下，可能发生幻读现象，但是<strong>不可能脏读和不可重复读现象；</strong></li>
<li>在「串行化」隔离级别下，<strong>脏读、不可重复读和幻读现象都不可能会发生。</strong></li>
</ul>
<p>接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720420603198-9b6bd2b1-9c0e-46b5-ae0b-fcc9035c6fbc.webp" alt="img"></p>
<p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p>
<ul>
<li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li>
<li>在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li>
<li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li>
<li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li>
</ul>
<p>这四种隔离级别具体是如何实现的呢？</p>
<ul>
<li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，<strong>所以直接读取最新的数据就好了；</strong></li>
<li>对于「串行化」隔离级别的事务来说，通过<strong>加读写锁的方式来避免并行访问</strong>；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View来实现的，它们的区别在于创建 Read View 的时机不同，<strong>「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li>
</ul>
<h2 id="6-可重复读隔离级别下，A事务提交的数据，在B事务能看见吗？"><a href="#6-可重复读隔离级别下，A事务提交的数据，在B事务能看见吗？" class="headerlink" title="6.可重复读隔离级别下，A事务提交的数据，在B事务能看见吗？"></a>6.可重复读隔离级别下，A事务提交的数据，在B事务能看见吗？</h2><p>不能。。</p>
<p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的。</p>
<h2 id="7-Mysql-设置了可重读隔离级后，怎么保证不发生幻读？"><a href="#7-Mysql-设置了可重读隔离级后，怎么保证不发生幻读？" class="headerlink" title="7.Mysql 设置了可重读隔离级后，怎么保证不发生幻读？"></a>7.Mysql 设置了可重读隔离级后，怎么保证不发生幻读？</h2><p><strong>尽量在开启事务之后，马上执行 select … for update 这类锁定读的语句</strong>，因为它会对记录加 <strong>next-key lock</strong>，从而避免其他事务插入一条新记录，就避免了幻读的问题。</p>
<h2 id="8-举个例子说可重复读下的幻读问题"><a href="#8-举个例子说可重复读下的幻读问题" class="headerlink" title="8.举个例子说可重复读下的幻读问题"></a>8.举个例子说可重复读下的幻读问题</h2><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p>
<p>我举例一个可重复读隔离级别发生幻读现象的场景。以这张表作为例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717913623026-b457c2fd-d09d-4cd7-940a-eec8f2478e79.png" alt="img"></p>
<p>事务 A 执行查询 id = 5 的记录，此时表中是没有该记录的，所以查询不出来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>然后事务 B 插入一条 id = 5 的记录，并且提交了事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 事务 B</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t_stu <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;小美&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>此时，<strong>事务 A 更新 id = 5 这条记录，对没错，事务 A 看不到 id = 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id = 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_stu <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小林coding&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 小林coding   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>整个发生幻读的时序图如下：</p>
<p>在可重复读隔离级别下，事务 A <strong>第一次执行普通的 select 语句时生成了一个 ReadView</strong>，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，<strong>事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</strong></p>
<p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p>
<h2 id="9-串行化隔离级别是通过什么实现的？"><a href="#9-串行化隔离级别是通过什么实现的？" class="headerlink" title="9.串行化隔离级别是通过什么实现的？"></a>9.串行化隔离级别是通过什么实现的？</h2><p>是通过<strong>行级锁</strong>来实现的，序列化隔离级别下，普通的 select 查询是会对记录加 S 型的 <strong>next-key 锁</strong>，其他事务就没没办法对这些已经加锁的记录进行增删改操作了，从而避免了脏读、不可重复读和幻读现象。</p>
<h2 id="10-一条update是不是原子性的？为什么？"><a href="#10-一条update是不是原子性的？为什么？" class="headerlink" title="10.一条update是不是原子性的？为什么？"></a>10.一条update是不是原子性的？为什么？</h2><p>是原子性，主要通过<strong>锁+undolog 日志</strong>保证原子性的</p>
<ul>
<li>执行 update 的时候，会加<strong>行级别锁</strong>，保证了一个事务更新一条记录的时候，不会被其他事务干扰。</li>
<li>事务执行过程中，会生成 undolog，如果事务执行失败，<strong>就可以通过 undolog 日志进行回滚。</strong></li>
</ul>
<h2 id="11-滥用事务，或者一个事务里有特别多sql的弊端？"><a href="#11-滥用事务，或者一个事务里有特别多sql的弊端？" class="headerlink" title="11.滥用事务，或者一个事务里有特别多sql的弊端？"></a>11.滥用事务，或者一个事务里有特别多sql的弊端？</h2><p>事务的资源在<strong>事务提交之后才会释放的，比如存储资源、锁。</strong></p>
<p>如果一个事务特别多 sql，那么会带来这些问题：</p>
<ul>
<li>如果一个事务特别多 sql，锁定的数据太多，容易造成<strong>大量的死锁和锁超时</strong>。</li>
<li><strong>回滚</strong>记录会占用大量存储空间，事务回滚时间长。在MySQL opens new window中，<strong>实际上每条记录在更新的时候都会同时记录一条回滚操作</strong>。记录上的最新值，通过回滚操作，都可以得到前一个状态的值，<strong>sql 越多，所需要保存的回滚数据就越多。</strong></li>
<li>执行时间长，容易造成<strong>主从延迟</strong>，主库上必须等<strong>事务执行完成才会写入binlog</strong>，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟</li>
</ul>
<h2 id="12-事务的两阶段提交"><a href="#12-事务的两阶段提交" class="headerlink" title="12.事务的两阶段提交"></a>12.事务的两阶段提交</h2><p>1.prepare</p>
<p>InnoDB 写入 redo log 的 prepare 状态并刷盘:</p>
<p>InnoDB 引擎将事务修改的数据写入内存（Buffer Pool）；</p>
<p>然后生成一条 redo log，标记为 <code>&quot;prepare&quot;</code> 状态；</p>
<p>调用 <code>fsync</code> 将 redo log 刷入磁盘，保证崩溃后能恢复；</p>
<p>2.binlogcommit:</p>
<p>Server 层将整个事务的逻辑操作记录为一条 binlog；</p>
<p>将 binlog 持久化刷盘，<code>fsync()</code> 确保落地。</p>
<p>3.redocommit:</p>
<p>Server 层写 binlog 成功后，通知 InnoDB；</p>
<p>InnoDB 将之前 prepare 状态的 redo log 更新为 <code>&quot;commit&quot;</code> 状态；</p>
<p>这一步是关键确认步骤，表示事务已完全提交。</p>
<p>如果 <strong>先写 binlog 再写 redo log</strong>：InnoDB 崩溃了但 binlog 有记录，主从同步出错；</p>
<p>如果 <strong>只写 redo log，不写 binlog</strong>：主库恢复没问题，但从库根本不会同步这条事务，数据不一致；</p>
<p>所以必须保证 <strong>redo log 与 binlog 一致性落盘</strong>，2PC 正是为了解决这一问题。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-讲一下mysql里有哪些锁？"><a href="#1-讲一下mysql里有哪些锁？" class="headerlink" title="1.讲一下mysql里有哪些锁？"></a>1.讲一下mysql里有哪些锁？</h2><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png" alt="img"></p>
<ul>
<li><strong>全局锁</strong>：通过<strong>flush tables with read lock</strong> 语句会将<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，增删改或者表结构修改都会阻塞。全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</li>
<li><strong>表级锁</strong>：MySQL 里面表级别的锁有这几种：<ul>
<li>表锁：通过<strong>lock tables</strong> 语句可以对表加表锁，表锁除了会限制别的线程的读写外，<strong>也会限制本线程接下来的读写操作。</strong></li>
<li>元数据锁：当我们对数据库表进行操作时，会自动给这个表加上 <strong>MDL</strong>，对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</li>
<li>意向锁：当执行插入、更新、删除操作，<strong>需要先对表加上「意向独占锁」</strong>，然后对该记录加独占锁。<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</li>
</ul>
</li>
<li><strong>行级锁</strong>：InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</li>
<li>记录锁，<strong>锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的，满足读写互斥，写写互斥</strong></li>
<li>间隙锁，<strong>只存在于可重复读隔离级别</strong>，目的是为了<strong>解决可重复读隔离级别下幻读的现</strong>象。</li>
<li>Next-Key Lock 称为临键锁，是 <strong>Record Lock + Gap Lock</strong> 的组合，<strong>锁定一个范围，并且锁定记录本身。</strong></li>
</ul>
<h2 id="2-数据库的表锁和行锁有什么作用？"><a href="#2-数据库的表锁和行锁有什么作用？" class="headerlink" title="2.数据库的表锁和行锁有什么作用？"></a>2.数据库的表锁和行锁有什么作用？</h2><p>表锁的作用：</p>
<ul>
<li><strong>整体控制</strong>：表锁可以用来控制整个表的并发访问，当一个事务获取了表锁时，其他事务无法对该表进行任何读写操作，从而确保数据的完整性和一致性。</li>
<li><strong>粒度大</strong>：表锁的<strong>粒度</strong>比较大，在锁定表的情况下，可能会影响到整个表的其他操作，可能会引起锁竞争和性能问题。</li>
<li><strong>适用于大批量操作</strong>：表锁<strong>适合于需要大批量操作表中数据的场景，例如表的重建、大量数据的加载等。</strong></li>
</ul>
<p>行锁的作用：</p>
<ul>
<li><strong>细粒度控制</strong>：行锁可以<strong>精确控制对表中某行数据的访问</strong>，使得其他事务可以同时访问表中的其他行数据，在并发量大的系统中能够提高并发性能。</li>
<li><strong>减少锁冲突</strong>：行锁不会像表锁那样造成整个表的锁冲突，减少了锁竞争的可能性，提高了并发访问的效率。</li>
<li><strong>适用于频繁单行操作</strong>：行锁适合于需要<strong>频繁对表中单独行进行操作的场景</strong>，例如订单系统中的订单修改、删除等操作。</li>
</ul>
<h2 id="3-MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？"><a href="#3-MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？" class="headerlink" title="3.MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？"></a>3.MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？</h2><p>如果是两个事务同时更新了 id = 1，比如 update … where id = 1，那么是会阻塞的。因为 <strong>InnoDB 存储引擎实现了行级锁。</strong></p>
<p>当A事务对 id =1 这行记录进行更新时，会对<strong>主键 id 为 1 的记录加X类型的记录锁</strong>，这样第二事务对 id = 1 进行更新时，发现已经有记录锁了，就会陷入阻塞状态。</p>
<h2 id="4-两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？"><a href="#4-两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？" class="headerlink" title="4.两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？"></a>4.两条update语句处理一张表的不同的主键范围的记录，一个<10，一个>15，会不会遇到阻塞？底层是为什么的？</h2><p>不会，因为锁住的范围不一样，不会形成冲突。</p>
<ul>
<li>第一条 update sql 的话（ id&lt;10），锁住的范围是（-♾️，10）</li>
<li>第二条 update sql 的话（id &gt;15），锁住的范围是（15，+♾️）</li>
</ul>
<p>这里用的是间隙锁，锁的范围不一样</p>
<h2 id="5-如果2个范围不是主键或索引？还会阻塞吗？"><a href="#5-如果2个范围不是主键或索引？还会阻塞吗？" class="headerlink" title="5.如果2个范围不是主键或索引？还会阻塞吗？"></a>5.如果2个范围不是主键或索引？还会阻塞吗？</h2><p>如果2个范围查询的字段不是索引的话，那就<strong>代表 update 没有用到索引，这时候触发了全表扫描，全部索引都会加行级锁</strong>，这时候第二条 update 执行的时候，就会阻塞了。</p>
<p>因为如果 update 没有用到索引，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 <strong>4 个记录锁和 5 个间隙锁</strong>，相当于锁住了全表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1711526947543-96b555cc-646f-4194-b2b3-343b3b6dd769.png" alt="img"></p>
<h2 id="6-索引和锁的联系"><a href="#6-索引和锁的联系" class="headerlink" title="6.索引和锁的联系"></a>6.索引和锁的联系</h2><p>InnoDB 的行级锁依赖索引加锁，只有<strong>通过索引</strong>才能真正实现行级锁，否则会升级为表锁。</p>
<p>InnoDB 的行级锁是 <strong>通过索引来定位数据行并加锁的</strong>，底层并不直接锁行，而是锁 <strong>B+树索引上的记录</strong>。</p>
<ul>
<li>所以必须使用 <strong>索引列</strong> 来过滤数据，InnoDB 才能<strong>锁中具体的行</strong>。</li>
<li>如果你不用索引定位记录，InnoDB 会<strong>扫描整张表</strong>，此时加锁范围会扩大，可能会变成<strong>表锁</strong>或者加锁更多记录，<strong>大大降低并发能力</strong>。</li>
</ul>
<p>按照索引的分类开始：</p>
<p>🟩 ① 主键索引（聚簇索引）</p>
<p>InnoDB 的数据存储就是按照主键索引组织的，所有主键更新时默认使用的是聚簇索引：</p>
<ul>
<li><code>UPDATE users SET ... WHERE id = 1</code> → 加<strong>主键索引上的记录锁</strong></li>
</ul>
<p>🟦 ② 唯一索引</p>
<p>唯一索引也是可定位唯一记录的，因此使用它加锁也是<strong>记录锁</strong>，不会锁多余的数据。</p>
<p>🟥 ③ 普通索引（非唯一）</p>
<p>非唯一索引加锁时，InnoDB 还会<strong>回表</strong>（<strong>从辅助索引查到主键后再访问聚簇索引</strong>），这个过程可能会涉及：</p>
<ul>
<li>对辅助索引加锁（因为是查询入口）</li>
<li>对主键记录加锁（因为实际行数据在主键索引上）</li>
</ul>
<p>⚠️ 注意：<strong>非唯一索引可能导致锁的扩大。</strong></p>
<p>没有索引，InnoDB 无法使用索引定位，就必须 <strong>全表扫描</strong>，从而加锁过程中会对<strong>所有记录逐个加锁</strong>，甚至退化为 <strong>表锁</strong>，这就是 <strong>锁失效</strong> 问题。</p>
<p>即便 <code>id</code> 是主键，这种范围查询也会触发 <strong>Next-Key Lock（间隙锁 + 行锁）</strong>，锁定多个记录区间。</p>
<p>所以范围查询更容易引起锁冲突或“幻读”，这是 InnoDB 使用“间隙锁”防止幻读的手段。</p>
<p>对高并发系统，慎用范围查询（<code>&gt;、&lt;、BETWEEN</code>），必要时用 <code>READ COMMITTED</code> 隔离级别避免间隙锁。</p>
<p><strong>WHERE 子句一定要走索引</strong>，否则行锁会变成表锁，严重影响性能；</p>
<p>设计表时，考虑<strong>在经常更新/查询的字段上加索引</strong>；</p>
<h2 id="7-如何避免-MDL-死锁或阻塞？"><a href="#7-如何避免-MDL-死锁或阻塞？" class="headerlink" title="7.如何避免 MDL 死锁或阻塞？"></a>7.如何避免 MDL 死锁或阻塞？</h2><div class="table-container">
<table>
<thead>
<tr>
<th>做法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 尽快提交事务</td>
<td>不要让事务长时间挂起</td>
</tr>
<tr>
<td>✅ 使用小事务</td>
<td>减少长事务持有 MDL 的风险</td>
</tr>
<tr>
<td>✅ 表结构变更前踢人</td>
<td>使用 <code>SHOW PROCESSLIST</code> 找出持有锁的线程</td>
</tr>
<tr>
<td>✅ DDL 操作选择低峰期</td>
<td>尽量避免业务高峰期执行 DDL</td>
</tr>
<tr>
<td>✅ 从 MySQL 8.0 起可用 <code>NOWAIT</code>/<code>SKIP LOCKED</code></td>
<td>避免 DDL 被阻塞</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure>
<p>你可以通过如下 SQL 查看是否存在 MDL 锁阻塞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCESSLIST;</span><br></pre></td></tr></table></figure>
<p>查出阻塞来源</p>
<h2 id="8-范围索引会造成的问题"><a href="#8-范围索引会造成的问题" class="headerlink" title="8.范围索引会造成的问题"></a>8.范围索引会造成的问题</h2><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>❶ 间隙锁（Gap Lock）</td>
<td>InnoDB 的 <strong>Next-Key Lock</strong> 策略会锁住满足范围条件的记录<strong>及其之间的间隙</strong>，防止幻读</td>
</tr>
<tr>
<td>❷ 锁范围不明确，导致<strong>并发能力下降</strong></td>
<td>锁粒度大、容易阻塞其他事务</td>
</tr>
<tr>
<td>❸ 影响覆盖索引使用（索引失效）</td>
<td>范围查询容易导致 <strong>无法使用覆盖索引或索引下推</strong></td>
</tr>
<tr>
<td>❹ 不能用索引的后续列</td>
<td>索引中范围条件后面的列不会被用于索引（即<strong>索引失效的分界点</strong>）</td>
</tr>
<tr>
<td>❺ 查询计划不稳定</td>
<td>范围值的不同可能导致 MySQL 执行计划不一致（甚至变慢）</td>
</tr>
</tbody>
</table>
</div>
<p>1.间隙锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 假设表中已有 id=1, id=3</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM t WHERE id &gt; 1 AND id &lt; 3 FOR UPDATE;</span><br></pre></td></tr></table></figure>
<p>🔹 InnoDB 使用 <strong>Next-Key Lock</strong>（记录锁 + 间隙锁），锁定的范围是：</p>
<ul>
<li><code>(1,3)</code> 之间的 <strong>所有值的“间隙”</strong></li>
<li>即使 <code>id=2</code> 不存在，也会被锁住，防止别的事务插入这个范围内的值（避免幻读）</li>
</ul>
<p>2.并发下降 / 发生阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A：</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user SET score = score + 1 WHERE id BETWEEN 10 AND 20;</span><br><span class="line"></span><br><span class="line">-- 事务 B：</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user SET score = score + 1 WHERE id BETWEEN 15 AND 25;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个事务都用了范围查询，<strong>锁定的范围存在重叠</strong>（id 15~20），就会发生阻塞甚至死锁。</p>
<p>3.范围查询导致 <strong>索引失效</strong>（无法使用复合索引后面的列）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name_age ON user(name, age);</span><br><span class="line"></span><br><span class="line">-- 以下查询中，范围条件在前，后面的字段索引无法使用：</span><br><span class="line">SELECT * FROM user WHERE name LIKE &#x27;Tom%&#x27; AND age = 18;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MySQL 遇到范围查询就不再使用索引后面的列做过滤优化。</p>
<p>4.范围查询的执行计划可能不稳定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM orders WHERE price &lt; 10000;</span><br></pre></td></tr></table></figure>
<p>你可能在小表数据量时表现很好，但随着数据增长，MySQL 的 <strong>优化器可能改变执行计划</strong>，比如：</p>
<ul>
<li>从 <strong>索引扫描</strong> → 变为 <strong>全表扫描</strong></li>
<li>或选择了 <strong>不合适的索引</strong></li>
</ul>
<p>这会导致执行效率波动。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>应对策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>间隙锁影响</td>
<td>使用更精确的等值查询，必要时开启 <code>READ COMMITTED</code> 隔离级别（不使用 gap lock）</td>
</tr>
<tr>
<td>并发低下</td>
<td>避免大范围更新；更新分批提交；合理控制事务粒度</td>
</tr>
<tr>
<td>索引失效</td>
<td>避免在复合索引前面使用范围条件；或考虑索引调整</td>
</tr>
<tr>
<td>执行计划不稳定</td>
<td>使用 <code>FORCE INDEX</code> 或分析 <code>EXPLAIN</code> 调整查询</td>
</tr>
</tbody>
</table>
</div>
<h2 id="9-两段锁协议"><a href="#9-两段锁协议" class="headerlink" title="9.两段锁协议"></a>9.两段锁协议</h2><p>是数据库并发控制中保证<strong>事务隔离性（特别是串行化）\</strong>的关键协议，常用于实现事务的*<em>封锁调度（Locking Scheduling）*</em>。</p>
<p><strong>两段锁协议</strong>要求：一个事务中加锁和解锁必须严格分为两个阶段——</p>
<ul>
<li><strong>加锁阶段</strong>：只允许加锁，不允许解锁；</li>
<li><strong>解锁阶段</strong>：只允许解锁，不允许再加锁。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>加锁阶段</strong></td>
<td>事务可以随意对数据项加锁（共享锁 / 排它锁），但<strong>一旦开始释放锁，就不能再加新锁</strong>了</td>
</tr>
<tr>
<td><strong>解锁阶段</strong></td>
<td>从第一个锁释放开始，事务<strong>只能解锁，不能再加锁</strong></td>
</tr>
</tbody>
</table>
</div>
<p><strong>保证事务的调度是可串行化的</strong>（即并发执行效果等价于串行执行），是实现<strong>事务隔离性</strong>的重要基础。</p>
<p>分类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>基本两段锁协议（Basic 2PL）</strong></td>
<td>满足加锁-解锁阶段划分</td>
<td>只保证可串行性，不一定防死锁</td>
</tr>
<tr>
<td><strong>严格两段锁协议（Strict 2PL）</strong></td>
<td>所有锁<strong>直到事务提交或回滚时才释放</strong></td>
<td>InnoDB 默认采用，防止脏读、保证恢复安全</td>
</tr>
<tr>
<td><strong>强两段锁协议（Strong / Rigorous 2PL）</strong></td>
<td>所有锁直到<strong>事务结束才统一释放</strong>，读写锁都这样</td>
<td>更严格，安全性更高</td>
</tr>
</tbody>
</table>
</div>
<h2 id="10-mysql中的死锁和死锁的解决办法，检测机制"><a href="#10-mysql中的死锁和死锁的解决办法，检测机制" class="headerlink" title="10.mysql中的死锁和死锁的解决办法，检测机制"></a>10.mysql中的死锁和死锁的解决办法，检测机制</h2><p><strong>死锁定义</strong>：两个或多个事务因争夺锁资源而形成互相等待的局面，<strong>永远无法释放</strong>，除非外部干预。</p>
<p>事务 A：先锁定资源 1，再等待资源 2；</p>
<p>事务 B：先锁定资源 2，再等待资源 1；</p>
<p>→ 互相等待，导致死锁。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>场景</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>不同事务更新相同的几行但顺序不同</td>
<td>最典型</td>
</tr>
<tr>
<td>事务未提交而持有锁太久</td>
<td>导致其他事务阻塞</td>
</tr>
<tr>
<td>大事务中穿插小事务</td>
<td>小事务一直等待，大事务一直不释放</td>
</tr>
<tr>
<td>行锁升级为表锁或间隙锁干扰</td>
<td>特别是 InnoDB 的间隙锁和 Next-Key Lock</td>
</tr>
</tbody>
</table>
</div>
<p>检测机制：</p>
<p>MySQL 的 InnoDB 引擎具备<strong>死锁自动检测机制</strong>：</p>
<ul>
<li><p>遇到死锁时，<strong>自动选择回滚其中一个事务</strong>，通常选择代价最小（影响最小）的事务。</p>
</li>
<li><p>返回错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure>
<p>最近一次死锁的事务编号</p>
<p>死锁涉及的 SQL 语句</p>
<p>被回滚的事务</p>
<p><strong>避免死锁</strong></p>
<p>✅ 1. <strong>尽量保证一致的访问顺序</strong></p>
<p>多个事务访问相同的表或记录时，应按照相同顺序加锁。</p>
<p>✅ 2. <strong>尽量减少锁定范围</strong></p>
<ul>
<li>避免一次锁定过多数据；</li>
<li>使用合理的索引，避免全表扫描；</li>
</ul>
<p>✅ 3. <strong>缩短事务执行时间</strong></p>
<ul>
<li>不在事务中执行耗时操作，如 HTTP 请求、文件操作等；</li>
<li>事务越短，锁持有时间越短，冲突越少。</li>
</ul>
<p>✅ 4. <strong>使用更高粒度的锁（慎重）</strong></p>
<ul>
<li>行锁 &gt; 表锁；</li>
<li>如果确实冲突频繁，可考虑调整为表锁或使用乐观锁；</li>
</ul>
<p>✅ 5. <strong>开启合理的事务隔离级别</strong></p>
<ul>
<li>如不需要强一致性，可考虑 <code>READ COMMITTED</code> 而非 <code>REPEATABLE READ</code>；</li>
<li>减少间隙锁产生的可能性。</li>
</ul>
<p><strong>处理策略</strong></p>
<p>业务端重试机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; MAX_RETRY; i++) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行业务逻辑</span><br><span class="line">        break;</span><br><span class="line">    &#125; catch (DeadlockException e) &#123;</span><br><span class="line">        if (i == MAX_RETRY - 1) throw e; // 最后一次抛出</span><br><span class="line">        // else 重试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动加锁顺序、分解事务</p>
<ul>
<li>拆成多个子事务；</li>
<li>控制加锁顺序，避免交叉；</li>
</ul>
<p>或者是我们设置事务的最大等待时间，超过这个时间直接回滚。</p>
<p>或者是把造成死锁的进程直接kill -9掉</p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="1-介绍MVCC实现原理"><a href="#1-介绍MVCC实现原理" class="headerlink" title="1.介绍MVCC实现原理"></a>1.介绍MVCC实现原理</h2><p>MVCC<strong>允许多个事务同时读取同一行数据，而不会彼此阻塞，每个事务看到的数据版本是该事务开始时的数据版本。</strong>这意味着，如果其他事务在此期间修改了数据，正在运行的事务仍然看到的是它开始时的数据状态，从而实现了非阻塞读操作。</p>
<p><strong>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的</strong>，它们的区别在于<strong>创建 Read View 的时机不同</strong>，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。</p>
<ul>
<li>「读提交」隔离级别是在「<strong>每个select语句执行前」都会重新生成一个 Read View；</strong></li>
<li>「可重复读」<strong>隔离级别是执行第一条select时，生成一个 Read View，然后整个事务期间都在用这个 Read View。</strong></li>
</ul>
<p>Read View 有四个重要的字段：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中<strong>「活跃事务」</strong>中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中<strong>最大的事务 id 值 + 1；</strong></li>
<li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li>
</ul>
<p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/f595d13450878acd04affa82731f76c5.png" alt="图片"></p>
<ul>
<li>trx_id，当<strong>一个事务对某条聚簇索引记录进行改动</strong>时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是<strong>就可以通过它找到修改前的记录。</strong></li>
</ul>
<p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719905850875-89fa5b61-e48c-4171-9248-c966c8d474ce.webp" alt="img"></p>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li>如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以<strong>该版本的记录对当前事务**</strong>可见**。</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以<strong>该版本的记录对当前事务不可见。</strong></li>
<li>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要<strong>判断 trx_id 是否在 m_ids 列表中</strong>：</li>
<li>如果记录的 trx_id <strong>在</strong> m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（<strong>还没提交事务</strong>），所以该版本的记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id <strong>不在</strong> m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li>
</ul>
<p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p>
<h2 id="2-MVCC的具体实现"><a href="#2-MVCC的具体实现" class="headerlink" title="2.MVCC的具体实现"></a>2.MVCC的具体实现</h2><p>一、MVCC 基本原理</p>
<ol>
<li><strong>多版本数据</strong><ul>
<li>每条记录并不只有“当前值”，还保留了若干历史版本。</li>
<li>版本链通过 <strong>Undo 日志</strong> 串联。原子性也是通过这个的undo log来实现回滚</li>
</ul>
</li>
<li><strong>快照读 vs. 当前读</strong><ul>
<li><strong>快照读（Snapshot Read）</strong>：不加锁，读取某个时刻的“事务一致性视图”（Read View）。</li>
<li><strong>当前读（Current Read）</strong>：加锁读（如 <code>SELECT … FOR UPDATE</code> 或 <code>UPDATE</code>），<strong>直接读取最新版本。</strong></li>
</ul>
</li>
<li><strong>Read View（读视图）</strong><ul>
<li>事务启动时，构造一个 “活跃事务列表” 快照。</li>
<li>每次快照读遇到版本时，判断该版本的创建/删除事务是否在视图中，决定可见性。</li>
</ul>
</li>
</ol>
<hr>
<p>二、InnoDB 中的 MVCC 实现细节</p>
<ol>
<li><strong>隐藏列</strong><ul>
<li>每行记录额外维护两个隐藏列：<code>trx_id</code>（创建该版本的事务 ID）和 <code>roll_pointer</code>（指向上一个版本的 Undo 日志）。</li>
</ul>
</li>
<li><strong>Undo 日志存储历史版本</strong><ul>
<li>修改<strong>操作先写 Undo 日志，再写 Redo 日志和数据页。</strong></li>
<li>Undo 日志负责回滚和给其他事务做 Read View 时提供旧版本。</li>
</ul>
</li>
<li><strong>插入/修改/删除的版本链</strong><ul>
<li><strong>INSERT</strong>：新版本的 <code>trx_id=当前事务</code>，<code>roll_pointer=NULL</code></li>
<li><strong>UPDATE</strong>：先把<strong>老版本写到 Undo 日志，创建新版本并链入</strong></li>
<li><strong>DELETE</strong>：相当于创建一个<strong>“删除标记”</strong>版本</li>
</ul>
</li>
<li><strong>可见性判断</strong><br> 对比版本的 <code>trx_id</code> 与事务的 Read View 中的最小/最大事务 ID 列表，决定该版本是否对当前快照可见。</li>
</ol>
<hr>
<p>三、事务隔离级别与 MVCC</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>幻读</th>
<th>并发写锁</th>
<th>优点</th>
<th>注意点</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>会出现脏读</td>
<td>无</td>
<td>并发最高</td>
<td>脏读、不可重复读、幻读都可能</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>不会脏读</td>
<td>无</td>
<td>脏读消除</td>
<td>不可重复读、幻读</td>
</tr>
<tr>
<td>REPEATABLE READ（MySQL 默认）</td>
<td>不会幻读（Next-Key Lock + MVCC）</td>
<td>无（快照读）+ 间隙锁阻止幻读</td>
<td>无幻读、可重复读</td>
<td>注意：单纯快照读不锁行；范围写锁防幻读</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>——</td>
<td>读写都加锁</td>
<td>最严格</td>
<td>并发最差</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>四、常见面试题及回答要点</p>
<ol>
<li><strong>什么是 MVCC？为什么要用 MVCC？</strong><ul>
<li><strong>答</strong>：MVCC 为每个事务提供一个数据快照，避免读写冲突，提高并发性能。</li>
</ul>
</li>
<li><strong>InnoDB 中 MVCC 如何实现？</strong><ul>
<li><strong>答</strong>：基于 Undo 日志存储历史版本，通过<strong>隐藏列记录事务 ID 和回滚链指针</strong>；快照读构造 Read View，判断版本可见性；当前读直接加行锁。</li>
</ul>
</li>
<li><strong>快照读和当前读有什么区别？</strong><ul>
<li><strong>答</strong>：快照读使用 Read View，<code>SELECT</code> 默认不加锁；<strong>当前读（<code>SELECT … FOR UPDATE</code>、<code>UPDATE</code>）会加行锁</strong>，读取最新版本。</li>
</ul>
</li>
<li><strong>为什么 REPEATABLE READ 能防止幻读？</strong><ul>
<li><strong>答</strong>：结合 <strong>MVCC 快照读+Next-Key Lock</strong>（范围写时锁定间隙）共同防幻读。</li>
</ul>
</li>
<li><strong>Undo 日志何时会被清理？</strong><ul>
<li><strong>答</strong>：当所有<strong>活跃事务的 Read View 都不需要该版本</strong>时，后台的 Purge 线程会清除。</li>
</ul>
</li>
<li><strong>长事务对 MVCC 有什么影响？</strong><ul>
<li><strong>答</strong>：会延迟 Undo 日志的清理，导致 Undo 文件增长，甚至使查询回滚链过长，影响性能。</li>
</ul>
</li>
</ol>
<hr>
<p>五、示例演示</p>
<p>假设初始表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  balance <span class="type">INT</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>快照读示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;    <span class="comment">-- 读取 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span><span class="number">200</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;    <span class="comment">-- 仍读取快照中的 100</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>当前读示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment">-- 加 X 锁，读 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance<span class="operator">=</span><span class="number">200</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;          <span class="comment">-- 阻塞，直到 A 提交</span></span><br></pre></td></tr></table></figure>
<p>幻读防护示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表中记录：id=1, id=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- Next-Key Lock 锁定 [1,3) 间隙，防止 id=2 被插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">150</span>);  <span class="comment">-- 阻塞，直到 A 提交</span></span><br></pre></td></tr></table></figure>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1-日志文件是分成了哪几种？"><a href="#1-日志文件是分成了哪几种？" class="headerlink" title="1.日志文件是分成了哪几种？"></a>1.日志文件是分成了哪几种？</h2><ul>
<li>redo log 重做日志，是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；事务提交的时候重做</li>
<li>undo log 回滚日志，是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。事务未提交回滚</li>
<li>bin log 二进制日志，是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
<li>relay log 中继日志，用于主从复制场景下，slave通过io线程拷贝master的bin log后本地生成的日志</li>
<li>慢查询日志，用于记录执行时间过长的sql，需要设置阈值后手动开启</li>
</ul>
<h2 id="2-讲一下binlog"><a href="#2-讲一下binlog" class="headerlink" title="2.讲一下binlog"></a>2.讲一下binlog</h2><p>MySQL 在完成一条更新操作后，<strong>Server 层还会生成一条 binlog</strong>，等之后<strong>事务提交</strong>的时候，会将该事物执行过程中产生的所有 <strong>binlog 统一写 入 binlog 文件，binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用。</strong></p>
<p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志，用于备份恢复、主从复制；</p>
<p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<p>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：</p>
<ul>
<li>STATEMENT：<strong>每一条修改数据的 SQL 都会被记录到 binlog 中</strong>（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：<strong>记录行数据最终被修改成什么样了</strong>（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：<strong>包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</strong></li>
</ul>
<h2 id="3-UndoLog日志的作用是什么？"><a href="#3-UndoLog日志的作用是什么？" class="headerlink" title="3.UndoLog日志的作用是什么？"></a>3.UndoLog日志的作用是什么？</h2><p>undo log 是一种用于撤销回退的日志，<strong>它保证了事务的</strong> <strong>ACID 特性中的原子性</strong>（Atomicity）。</p>
<p>在事务没提交之前，MySQL 会先<strong>记录更新前的数据到 undo log 日志文件</strong>里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717920811388-2146eb90-98bd-4b2d-b6a8-9c207fbdacc4.png" alt="img"></p>
<p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
<p>在<strong>发生回滚时，就读取 undo log 里的数据</strong>，然后做原先相反操作。比如<strong>当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。</strong></p>
<h2 id="4-有了undolog为啥还需要redolog呢？"><a href="#4-有了undolog为啥还需要redolog呢？" class="headerlink" title="4.有了undolog为啥还需要redolog呢？"></a>4.有了undolog为啥还需要redolog呢？</h2><p>Buffer Pool 是提高了读写效率没错，但是问题来了，<strong>Buffer Pool 是基于内存的，而内存总是不可靠</strong>，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，<strong>InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来</strong>，<strong>这个时候更新就算完成了</strong>。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p>
<p>过程如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717920899043-30125c0d-bd83-4ca7-9784-07b70c362168.png" alt="img"></p>
<p>redo log 是<strong>物理日志</strong>，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当<strong>执行一个事务就会产生这样的一条或者多条物理日志</strong>。</p>
<p><strong>在事务提交时，只要先将 redo log 持久化到磁盘即可</strong>，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<p>redo log 和 undo log 这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1717920935536-45ceca35-c79c-48eb-a240-96d580e399b5.png" alt="img"></p>
<p>所以<strong>有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启</strong>，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p>
<p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p>
<p><strong>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</strong></p>
<p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p>
<p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p>
<p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<h2 id="5-redo-log怎么保证持久性的？"><a href="#5-redo-log怎么保证持久性的？" class="headerlink" title="5.redo log怎么保证持久性的？"></a>5.redo log怎么保证持久性的？</h2><p>Redo log是MySQL中用于保证持久性的重要机制之一。它通过以下方式来保证持久性：</p>
<ol>
<li>Write-ahead logging（WAL）：<strong>在事务提交之前，将事务所做的修改操作记录到redo log中，然后再将数据写入磁盘。</strong>这样即使在数据写入磁盘之前发生了宕机，系统可以通过redo log中的记录来恢复数据。保证了事务的持久性</li>
<li>Redo log的顺序写入：<strong>redo log采用追加写入的方式，将redo日志记录追加到文件末尾</strong>，而不是随机写入。这样可以减少磁盘的随机I/O操作，提高写入性能。</li>
<li>Checkpoint机制：<strong>MySQL会定期将内存中的数据刷新到磁盘，同时将最新的LSN（Log Sequence Number）记录到磁盘中</strong>，这个LSN可以<strong>确保redo log中的操作是按顺序执行的</strong>。在恢复数据时，系统会根据LSN来确定从哪个位置开始应用redo log。</li>
</ol>
<h2 id="6-能不能只用binlog不用relo-log？"><a href="#6-能不能只用binlog不用relo-log？" class="headerlink" title="6.能不能只用binlog不用relo log？"></a>6.能不能只用binlog不用relo log？</h2><p>不行，binlog是 server 层的日志，没办法记录哪些脏页还没有刷盘，redolog 是存储引擎层的日志，可以<strong>记录哪些脏页还没有刷盘</strong>，这样崩溃恢复的时候，就能恢复那些还没有被刷盘的脏页数据。</p>
<h2 id="7-binlog-两阶段提交过程是怎么样的？"><a href="#7-binlog-两阶段提交过程是怎么样的？" class="headerlink" title="7.binlog 两阶段提交过程是怎么样的？"></a>7.binlog 两阶段提交过程是怎么样的？</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>
<p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。</p>
<p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240725231904598.png" alt="image-20240725231904598"></p>
<p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段</strong>：<strong>将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘</strong>（innodb_flush_log_at_trx_commit = 1 的作用）；</li>
<li><strong>commit 阶段</strong>：<strong>把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（</strong>sync_binlog = 1 的作用），接着调用引擎的提交事务接口，<strong>将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了</strong>，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li>
</ul>
<p>我们来看看在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？下图中有时刻 A 和时刻 B 都有可能发生崩溃：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/image-20240725231850469.png" alt="image-20240725231850469"></p>
<p>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。</p>
<p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p>
<ul>
<li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</li>
<li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</li>
</ul>
<p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p>
<p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>
<h2 id="8-update语句的具体执行过程是怎样的？"><a href="#8-update语句的具体执行过程是怎样的？" class="headerlink" title="8.update语句的具体执行过程是怎样的？"></a>8.update语句的具体执行过程是怎样的？</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：<ul>
<li>如果 id=1 这一行所在的<strong>数据页本来就在 buffer pool 中</strong>，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将<strong>数据页从磁盘读入到 buffer pool</strong>，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下<strong>更新前的记录和更新后的记录</strong>是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把<strong>更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</strong></li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要<strong>记录相应的 undo log</strong>，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，<strong>不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</strong></li>
<li>InnoDB 层开始更新记录，会先<strong>更新内存</strong>（同时标记为脏页），然后将<strong>记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘</strong>。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后<strong>开始记录该语句对应的 binlog</strong>，<strong>此时记录的 binlog 会被保存到 binlog cache</strong>，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<h2 id="9-MySQL是如何保障数据不丢失的？"><a href="#9-MySQL是如何保障数据不丢失的？" class="headerlink" title="9.MySQL是如何保障数据不丢失的？"></a>9.MySQL是如何保障数据不丢失的？</h2><p>主要是通过 redolog 来实现事务持久性的，事务执行过程，会把对 innodb 存储引擎中数据页修改操作记录到 redolog 里，事务提交的时候，就直接把 redolog 刷入磁盘，即使脏页中途没有刷盘成功， mysql 宕机了，也能通过 redolog 重放，恢复到之前事务修改数据页后的状态，从而保障了数据不丢失。</p>
<h2 id="10-RedoLog是在内存里吗？"><a href="#10-RedoLog是在内存里吗？" class="headerlink" title="10.RedoLog是在内存里吗？"></a>10.RedoLog是在内存里吗？</h2><p>事务执行过程中，生成的 redolog 会在 redolog buffer 中，也就是在内存中，等事务提交的时候，会把 redolog 写入磁盘。</p>
<h2 id="11-为什么要写RedoLog，而不是直接写到B-树里面？"><a href="#11-为什么要写RedoLog，而不是直接写到B-树里面？" class="headerlink" title="11.为什么要写RedoLog，而不是直接写到B+树里面？"></a>11.为什么要写RedoLog，而不是直接写到B+树里面？</h2><p>因为 <strong>redolog 写入磁盘是顺序写</strong>，而 <strong>b+树里数据页写入磁盘是随机写</strong>，顺序写的性能会比随机写好，这样可以提升事务提交的效率。</p>
<p>最重要的是redolog<strong>具备故障恢复的能力</strong>，Redo Log 记录的是物理级别的修改，包括页的修改，如插入、更新、删除操作在磁盘上的物理位置和修改内容。例如，当执行一个更新操作时，<strong>Redo Log 会记录修改的数据页的地址和更新后的数据</strong>，而不是 SQL 语句本身。</p>
<p>在数据页实际更新之前，先将修改操作写入 Redo Log。当数据库重启时，会进行恢复操作。首先，<strong>根据 Redo Log 检查哪些事务已经提交但数据页尚未完全写入磁盘。然后，使用 Redo Log 中的记录对这些事务进行重做（Redo）操作，将未完成的数据页修改完成，确保事务的修改生效。</strong></p>
<h2 id="12-mysql-两次写（double-write-buffer）了解吗？"><a href="#12-mysql-两次写（double-write-buffer）了解吗？" class="headerlink" title="12.mysql 两次写（double write buffer）了解吗？"></a>12.mysql 两次写（double write buffer）了解吗？</h2><p>我们常见的服务器一般都是Linux操作系统，<strong>Linux文件系统页（OS Page）的大小默认是4KB</strong>。而<strong>MySQL的页（Page）大小默认是16KB。</strong></p>
<p>MySQL程序是跑在Linux操作系统上的，需要跟操作系统交互，所以MySQL中一页数据刷到磁盘，<strong>要写4个文件系统里的页。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1737301125998-6ecd9068-6603-4932-81c4-b54cf2984fb6.png" alt="img"></p>
<p>需要注意的是，这个<strong>操作并非原子操作</strong>，比如我操作系统写到第二个页的时候，Linux机器断电了，这时候就会出现问题了。造成”页数据损坏“。并且这种”页数据损坏“靠 redo日志是无法修复的。</p>
<p>Doublewrite Buffer的出现就是为了解决上面的这种情况，虽然名字带了Buffer，但实际上<strong>Doublewrite Buffer是内存+磁盘的结构。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1737302055987-847a5e01-f883-4b5c-8c36-26ffad1f6f69.png" alt="img"></p>
<p>Doublewrite Buffer 作用是，<strong>在把页写到数据文件之前，InnoDB先把它们写到一个叫doublewrite buffer（双写缓冲区）的共享表空间内，在写doublewrite buffer完成后，InnoDB才会把页写到数据文件的适当的位置。</strong>如果在写页的过程中发生意外崩溃，InnoDB在稍后的恢复过程中在<strong>doublewrite buffer中找到完好的page副本用于恢复</strong>，所以本质上是一个<strong>最近写回的页面的备份拷贝。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1737301211946-81988282-fb5d-44f9-b8d8-94f7396db723.png" alt="img"></p>
<p>如上图所示，当有页数据要刷盘时：</p>
<ul>
<li>页数据先通过<strong>memcpy函数拷贝至内存中的Doublewrite Buffer</strong>（大小为约 2MB）中，Doublewrite Buffer 分为两个区域，每次写入一个区域（最多 1MB 的数据）。</li>
<li>Doublewrite Buffer的内存里的数据页，会<strong>fsync刷到Doublewrite Buffer的磁盘上，写两次到到共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</strong></li>
<li>写入完成后，<strong>再将脏页刷到数据磁盘存储.ibd文件上（随机写）；</strong></li>
</ul>
<p>当MySQL出现异常崩溃时，有如下几种情况发生：</p>
<ul>
<li>情况一：步骤1前宕机，刷盘未开始，<strong>数据在redo log</strong>，后期可以恢复</li>
<li>情况二：步骤1后，步骤2前宕机，因为是<strong>在内存中，宕机清空内存，和情况1一样</strong></li>
<li>情况三：步骤2后，步骤3前宕机，因为DWB的磁盘有完整的数据，可以修复损坏的页数据</li>
</ul>
<p>由此我们可以得出结论，double write buffer是针对实际的buffer数据页的原子性保证，就是避免MySQL异常崩溃时，写的那几个data page不会出错，要么都写了，要么什么都没有做。</p>
<blockquote>
<p>为什么redolog无法代替double write buffer？</p>
</blockquote>
<p>redolog的设计之初，是“<strong>账本的作用”，是一种操作日志，用于MySQL异常崩溃恢复使用</strong>，是InnoDB引擎特有的日志，本质上是物理日志，记录的是 “ 在某个数据页上做了什么修改 ” ，但如果数据页本身已经发生了损坏，redolog来恢复已经损坏的数据块是无效的，<strong>数据块的本身已经损坏</strong>，再次重做依然是一个坏块。 所以此时需要<strong>一个数据块的副本来还原该损坏的数据块，再利用重做日志进行其他数据块的重做操作，这就是double write buffer的原因作用。</strong></p>
<h1 id="sql调优"><a href="#sql调优" class="headerlink" title="sql调优"></a>sql调优</h1><h2 id="1-mysql的explain有什么作用？"><a href="#1-mysql的explain有什么作用？" class="headerlink" title="1.mysql的explain有什么作用？"></a>1.mysql的explain有什么作用？</h2><p>explain 是查看 sql 的执行计划，主要用来分析 sql 语句的执行过程，比如有没有走索引，有没有外部排序，有没有索引覆盖等等。</p>
<p>如下图，就是一个没有使用索引，并且是一个全表扫描的查询语句。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720420604941-9fafd933-6a90-4f02-a23c-0e577790f040.webp" alt="img"></p>
<p>对于执行计划，参数有：</p>
<ul>
<li>possible_keys 字段表示可能用到的索引；</li>
<li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li>
<li>key_len 表示索引的长度；</li>
<li>rows 表示扫描的数据行数。</li>
<li>type 表示<strong>数据扫描类型</strong>，我们需要重点看这个。</li>
</ul>
<p>type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p>
<ul>
<li>All（全表扫描）：在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。</li>
<li>index（全索引扫描）：index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。</li>
<li>range（索引范围扫描）：range 表示采用了<strong>索引范围扫描</strong>，一般在 where 子句中使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。<strong>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong>。</li>
<li>ref（非唯一索引扫描）：ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</li>
<li>eq_ref（唯一索引扫描）：eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</li>
<li>const（结果只有一条的主键或唯一索引扫描）：const 类型表示使用了<strong>主键或者唯一索引与常量值进行比较</strong>，比如 select name from product where id=1。需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。</li>
</ul>
<p>extra 显示的结果，这里说几个重要的参考指标：</p>
<ul>
<li>Using filesort ：当查询语句中<strong>包含 group by 操作，而且无法利用索引完成排序操作的时候</strong>， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li>
<li>Using temporary：使了用<strong>临时表保存中间结果</strong>，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li>
<li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li>
</ul>
<h2 id="2-给你张表，发现查询速度很慢，你有那些解决方案"><a href="#2-给你张表，发现查询速度很慢，你有那些解决方案" class="headerlink" title="2.给你张表，发现查询速度很慢，你有那些解决方案"></a>2.给你张表，发现查询速度很慢，你有那些解决方案</h2><ul>
<li><strong>分析查询语句</strong>：使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了<strong>全表扫描，是否存在索引未被利用的情况等</strong>，并根据相应情况对索引进行适当修改。</li>
<li><strong>创建或优化索引</strong>：根据查询条件创建合适的索引，特别是经常<strong>用于WHERE子句的字段</strong>、Orderby 排序的字段、Join 连表查询的字典、 group by的字段，并且如果查询中经常涉及多个字段，考虑创建联合索引，使用联合索引要符合最左匹配原则，不然会索引失效</li>
<li><strong>避免索引失效：</strong>比如不要用<strong>左模糊匹配、函数计算、表达式计算等等。</strong></li>
<li><strong>查询优化</strong>：避免使用SELECT <em>，只查询真正需要的列；使用<em>*覆盖索引，即索引包含所有查询的字段；联表查询最好要以小表驱动大表</em></em>，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。</li>
<li><strong>分页优化：</strong>针对 limit n,y 深分页的查询优化，可以把<strong>Limit查询转换成某个位置的查询：select * from tb_sku where id&gt;20000 limit 10，该方案适用于主键自增的表，</strong></li>
<li><strong>优化数据库表</strong>：如果单表的数据超过了千万级别，考虑是否需要将<strong>大表拆分为小表</strong>，减轻单个表的查询压力。也可以将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开。</li>
<li><strong>使用缓存技术</strong>：引入缓存层，如Redis，存储热点数据和频繁查询的结果，但是要考虑缓存一致性的问题，对于读请求会选择旁路缓存策略，对于写请求会选择先更新 db，再删除缓存的策略。</li>
</ul>
<h2 id="3-如果Explain用到的索引不正确的话，有什么办法干预吗？"><a href="#3-如果Explain用到的索引不正确的话，有什么办法干预吗？" class="headerlink" title="3.如果Explain用到的索引不正确的话，有什么办法干预吗？"></a>3.如果Explain用到的索引不正确的话，有什么办法干预吗？</h2><p>可以使用 force index，强制走索引。</p>
<p>比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT </span><br><span class="line">    productName, buyPrice</span><br><span class="line"><span class="selector-tag">FROM</span></span><br><span class="line">    products </span><br><span class="line">FORCE INDEX (idx_buyprice)</span><br><span class="line">WHERE</span><br><span class="line">    buyPrice BETWEEN <span class="number">10</span> AND <span class="number">80</span></span><br><span class="line"><span class="attribute">ORDER</span> BY buyPrice; </span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1715425169012-fcd6a89d-c073-4f3c-a395-c70d8045eec7.png" alt="img"></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">mengnankkzhou</div><div class="post-copyright__author_desc">不要走捏</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.tokenlen.top/2025/03/15/mysql/mysql12/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.tokenlen.top/2025/03/15/mysql/mysql12/')">Mysql面试题目</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.tokenlen.top/2025/03/15/mysql/mysql12/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Mysql面试题目&amp;url=https://blog.tokenlen.top/2025/03/15/mysql/mysql12/&amp;pic=https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=b0078bfc-8718-be24-66f8-bd95f158e9ac" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.tokenlen.top" target="_blank">mengnankkのblog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/sql/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>sql<span class="categoryesPageCount">21</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">18</span></a><a class="post-meta__box__tags" href="/tags/mysql/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>mysql<span class="tagsPageCount">16</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712179.jpg?_r_=84487f0c-e761-a90b-3875-d2128b619920" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/07/mysql/sql3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221818490.jpeg?_r_=b4f20faa-fbd8-5a9f-522e-8a3dff4f30c0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">sql原理之索引</div></div></a></div><div class="next-post pull-right"><a href="/2025/04/01/leetcode/leetcodedayone/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712177.jpg?_r_=79663a75-4120-3ed8-5724-f04591d13f32" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Leetcode 每日一题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/05/21/mysql/mysqlstack/" title="Mysql进阶技术栈"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221838345.jpg?_r_=7588d9ef-26ee-860e-0baf-d6ab925be072" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-21</div><div class="title">Mysql进阶技术栈</div></div></a></div><div><a href="/2025/07/14/new-stack/cache1/" title="Cache缓存"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712179.jpg?_r_=84487f0c-e761-a90b-3875-d2128b619920" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-14</div><div class="title">Cache缓存</div></div></a></div><div><a href="/2025/07/06/new-stack/MQ2/" title="MQ面试场景题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=4c5cee05-935d-797f-edc2-85bae5779e1c" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-06</div><div class="title">MQ面试场景题</div></div></a></div><div><a href="/2025/07/06/new-stack/es1/" title="Elasticsearch"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=8af18a17-99b6-e0ee-2e17-9dd8f7146e32" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-06</div><div class="title">Elasticsearch</div></div></a></div><div><a href="/2025/06/30/towork/wokiing2/" title="面试面经"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=f685bfae-2ed2-fe21-2e7d-a6e0cafe0b39" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-30</div><div class="title">面试面经</div></div></a></div><div><a href="/2025/06/24/new-stack/MQ1/" title="MQ面试题目hot"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722380.jpg?_r_=d64452ae-7e6b-04b1-63dc-ac7575a65c12" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-24</div><div class="title">MQ面试题目hot</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Valine</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407230955363.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">清风拂柳影，碧水映花香。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">mengnankkzhou</h1><div class="author-info__desc">不要走捏</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/mengnankkkk" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/440831872" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410021212939.jpg) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">原理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFmysql"><span class="toc-number">1.1.</span> <span class="toc-text">1.什么是mysql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A1%A8%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.</span> <span class="toc-text">2.表的连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3.数据库的三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-NOSQL%E5%92%8CSQL%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4.NOSQL和SQL的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5.说一下外键约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">sql语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-MySQL%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1.MySQL如何避免重复插入数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-int-1-int-10-%E5%9C%A8mysql%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.int(1) int(10) 在mysql有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Text%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E5%A4%A7%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3.Text数据类型可以无限大吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-varchar%E5%92%8Cchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">4.varchar和char的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-blob%E5%92%8Ctext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">5.blob和text有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-DATETIME%E5%92%8CTIMESTAMP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">6.DATETIME和TIMESTAMP有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-in%E5%92%8Cexists%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">7.in和exists的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-drop-delete-turncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.8.</span> <span class="toc-text">10.drop,delete,turncate的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-UNION%E5%92%8CUNION-ALL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">11.UNION和UNION ALL的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-count-%EF%BC%8Ccount-1-%EF%BC%8Ccount-%E5%88%97-%EF%BC%8C%E8%BF%99%E4%B8%89%E7%A7%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.10.</span> <span class="toc-text">12.count(*)，count(1)，count(列)，这三种有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-mysql%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">13.mysql中的一些基本函数，你知道哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.12.</span> <span class="toc-text">14.sql语句的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-UPDATE-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8E%9F%E7%90%86-amp-%E8%BF%87%E7%A8%8B"><span class="toc-number">2.13.</span> <span class="toc-text">15.UPDATE 语句的原理&amp;过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8"><span class="toc-number">3.</span> <span class="toc-text">数据库存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%B0%E5%BD%95%E8%B4%A7%E5%B8%81"><span class="toc-number">3.1.</span> <span class="toc-text">1.记录货币</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8emoji"><span class="toc-number">3.2.</span> <span class="toc-text">2.如何存储emoji</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-IP%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8C%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3.IP地址如何在数据库里存储？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E9%87%8C%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%A7%E4%BD%93%E5%88%86%E6%88%90%E5%93%AA%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">4.数据管理里，数据文件大体分成哪几种数据文件？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">sql优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%85%A2sql%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-number">4.1.</span> <span class="toc-text">1.慢sql问题怎么排查和解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9C%89sql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%90%97%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.有sql索引优化的经验吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">5.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%A0%E4%BA%86%E8%A7%A3mysql%E7%9A%84%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%8C%E8%AF%B7%E8%AF%A6%E7%BB%86%E7%9A%84%E8%AE%B2%E8%AE%B2%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1.你了解mysql的哪些存储引擎，请详细的讲讲？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2.执行一条SQL请求的过程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MySQL%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E6%98%AF%E9%BB%98%E8%AE%A4%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3.MySQL为什么InnoDB是默认引擎？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%B4%E4%B8%80%E4%B8%8Bmysql%E7%9A%84innodb%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">4.说一下mysql的innodb与MyISAM的区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">6.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1.索引是什么？有什么好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%B2%E8%AE%B2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2.讲讲索引的分类是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MySQL%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.MySQL聚簇索引和非聚簇索引的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A6%82%E6%9E%9C%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AD%98%E5%82%A8%E8%A6%81%E4%B8%8D%E8%A6%81%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4.如果聚簇索引的数据更新，它的存储要不要变化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-MySQL%E4%B8%BB%E9%94%AE%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">5.MySQL主键是聚簇索引吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E5%AD%97%E6%AE%B5%E9%80%82%E5%90%88%E5%BD%93%E5%81%9A%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">6.什么字段适合当做主键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%A7%E5%88%AB%E5%AD%97%E6%AE%B5%E8%83%BD%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%B9%88%EF%BC%9F%E4%B8%BA%E5%95%A5%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">7.性别字段能加索引么？为啥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%A1%A8%E4%B8%AD%E5%8D%81%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%BD%A0%E4%B8%BB%E9%94%AE%E7%94%A8%E8%87%AA%E5%A2%9EID%E8%BF%98%E6%98%AFUUID%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">8.表中十个字段，你主键用自增ID还是UUID，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BB%80%E4%B9%88%E8%87%AA%E5%A2%9EID%E6%9B%B4%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%8CUUID%E4%B8%8D%E5%BF%AB%E5%90%97%EF%BC%8C%E5%AE%83%E5%9C%A8B-%E6%A0%91%E9%87%8C%E9%9D%A2%E5%AD%98%E5%82%A8%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97"><span class="toc-number">6.9.</span> <span class="toc-text">9.什么自增ID更快一些，UUID不快吗，它在B+树里面存储是有序的吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84-%EF%BC%9F"><span class="toc-number">6.10.</span> <span class="toc-text">10.Mysql中的索引是怎么实现的 ？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E5%88%B0%E4%BA%86B-%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%8C%E4%B9%8B%E5%90%8E%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">11.查询数据时，到了B+树的叶子节点，之后的查找数据是如何做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-B-%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">12.B+树的特性是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E8%AF%B4%E8%AF%B4B-%E6%A0%91%E5%92%8CB%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.3.</span> <span class="toc-text">13.说说B+树和B树的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-B-%E6%A0%91%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">14.B+树的好处是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-B-%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8%E6%98%AF%E5%8D%95%E5%90%91%E8%BF%98%E6%98%AF%E5%8F%8C%E5%90%91%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">15.B+树的叶子节点链表是单向还是双向？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E7%BB%93%E6%9E%84%EF%BC%9F%E5%92%8C%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E6%AF%94%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">16.MySQL为什么用B+树结构？和其他结构比的优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%B8%BA%E4%BB%80%E4%B9%88-MysSQL-%E4%B8%8D%E7%94%A8-%E8%B7%B3%E8%A1%A8%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">17.为什么 MysSQL 不用 跳表？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">8.</span> <span class="toc-text">联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">1.联合索引的实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">2.创建联合索引时需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95ABC%EF%BC%8C%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%AA%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E6%98%AFA-XXX-and-C-lt-XXX%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E8%B5%B0"><span class="toc-number">8.3.</span> <span class="toc-text">3.联合索引ABC，现在有个执行语句是A &#x3D; XXX and C &lt; XXX，索引怎么走</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-a-b-c-%EF%BC%8C%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6-where-b-gt-xxx-and-a-x-%E4%BC%9A%E7%94%9F%E6%95%88%E5%90%97"><span class="toc-number">8.4.</span> <span class="toc-text">4.联合索引(a,b,c) ，查询条件 where b &gt; xxx and a &#x3D; x 会生效吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-a-b%EF%BC%8Cc-%EF%BC%8Cwhere%E6%9D%A1%E4%BB%B6%E6%98%AF-a-2-and-c-1%EF%BC%8C%E8%83%BD%E7%94%A8%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">5.联合索引 (a, b，c)，where条件是 a&#x3D;2 and c &#x3D; 1，能用到联合索引吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">6.索引失效有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.7.</span> <span class="toc-text">7.什么情况下会回表查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">索引原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">1.什么是覆盖索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%88%97%E5%8D%B3%E4%BD%BF%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8F%88%E6%98%AF%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8D%95%E7%8B%AC%E6%9F%A5%E5%AE%83%E7%9A%84%E8%AF%9D%E5%85%88%E8%B5%B0%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">2.如果一个列即使单列索引，又是联合索引，单独查它的话先走哪个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%B7%B2%E7%BB%8F%E5%BB%BA%E5%A5%BD%E4%BA%86%EF%BC%8C%E9%82%A3%E6%88%91%E5%86%8D%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">3.索引已经建好了，那我再插入一条数据，索引会有哪些变化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BB%BA%E7%9A%84%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">4.索引字段是不是建的越多越好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">5.索引的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%80%8E%E4%B9%88%E5%86%B3%E5%AE%9A%E5%BB%BA%E7%AB%8B%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95"><span class="toc-number">9.6.</span> <span class="toc-text">6.怎么决定建立哪些索引?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%AE%B2"><span class="toc-number">9.7.</span> <span class="toc-text">7.索引优化详细讲讲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BA%86%E8%A7%A3%E8%BF%87%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%90%97%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">8.了解过前缀索引吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.9.</span> <span class="toc-text">9.索引覆盖是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%B4%A2%E5%BC%95%E8%B7%B3%E8%B7%83%E5%BC%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.10.</span> <span class="toc-text">10.索引跳跃式什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.11.</span> <span class="toc-text">11.mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">1.事务的特性是什么？如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-mysql%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">2.mysql可能出现什么和并发相关问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8D%E9%80%82%E5%90%88%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">3.哪些场景不适合脏读，举个例子？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-mysql%E7%9A%84%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">4.mysql的是怎么解决并发问题的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.5.</span> <span class="toc-text">5.事务的隔离级别有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8CA%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%9C%A8B%E4%BA%8B%E5%8A%A1%E8%83%BD%E7%9C%8B%E8%A7%81%E5%90%97%EF%BC%9F"><span class="toc-number">10.6.</span> <span class="toc-text">6.可重复读隔离级别下，A事务提交的数据，在B事务能看见吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Mysql-%E8%AE%BE%E7%BD%AE%E4%BA%86%E5%8F%AF%E9%87%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%90%8E%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%8D%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">10.7.</span> <span class="toc-text">7.Mysql 设置了可重读隔离级后，怎么保证不发生幻读？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8B%E7%9A%84%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="toc-number">10.8.</span> <span class="toc-text">8.举个例子说可重复读下的幻读问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%B8%B2%E8%A1%8C%E5%8C%96%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">10.9.</span> <span class="toc-text">9.串行化隔离级别是通过什么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%80%E6%9D%A1update%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.10.</span> <span class="toc-text">10.一条update是不是原子性的？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%BB%A5%E7%94%A8%E4%BA%8B%E5%8A%A1%EF%BC%8C%E6%88%96%E8%80%85%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E9%87%8C%E6%9C%89%E7%89%B9%E5%88%AB%E5%A4%9Asql%E7%9A%84%E5%BC%8A%E7%AB%AF%EF%BC%9F"><span class="toc-number">10.11.</span> <span class="toc-text">11.滥用事务，或者一个事务里有特别多sql的弊端？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">10.12.</span> <span class="toc-text">12.事务的两阶段提交</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%B2%E4%B8%80%E4%B8%8Bmysql%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">1.讲一下mysql里有哪些锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">2.数据库的表锁和行锁有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MySQL%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84update%E8%AF%AD%E5%8F%A5%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%9C%89%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">3.MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%A4%E6%9D%A1update%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%BB%E9%94%AE%E8%8C%83%E5%9B%B4%E7%9A%84%E8%AE%B0%E5%BD%95%EF%BC%8C%E4%B8%80%E4%B8%AA15%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E9%81%87%E5%88%B0%E9%98%BB%E5%A1%9E%EF%BC%9F%E5%BA%95%E5%B1%82%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">4.两条update语句处理一张表的不同的主键范围的记录，一个&lt;10，一个&gt;15，会不会遇到阻塞？底层是为什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A6%82%E6%9E%9C2%E4%B8%AA%E8%8C%83%E5%9B%B4%E4%B8%8D%E6%98%AF%E4%B8%BB%E9%94%AE%E6%88%96%E7%B4%A2%E5%BC%95%EF%BC%9F%E8%BF%98%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F"><span class="toc-number">11.5.</span> <span class="toc-text">5.如果2个范围不是主键或索引？还会阻塞吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%94%81%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">11.6.</span> <span class="toc-text">6.索引和锁的联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-MDL-%E6%AD%BB%E9%94%81%E6%88%96%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">7.如何避免 MDL 死锁或阻塞？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%8C%83%E5%9B%B4%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.8.</span> <span class="toc-text">8.范围索引会造成的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.9.</span> <span class="toc-text">9.两段锁协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-mysql%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%8C%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">11.10.</span> <span class="toc-text">10.mysql中的死锁和死锁的解决办法，检测机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVCC"><span class="toc-number">12.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8DMVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.</span> <span class="toc-text">1.介绍MVCC实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MVCC%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.2.</span> <span class="toc-text">2.MVCC的具体实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">13.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%98%AF%E5%88%86%E6%88%90%E4%BA%86%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">1.日志文件是分成了哪几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%B2%E4%B8%80%E4%B8%8Bbinlog"><span class="toc-number">13.2.</span> <span class="toc-text">2.讲一下binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-UndoLog%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.3.</span> <span class="toc-text">3.UndoLog日志的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%89%E4%BA%86undolog%E4%B8%BA%E5%95%A5%E8%BF%98%E9%9C%80%E8%A6%81redolog%E5%91%A2%EF%BC%9F"><span class="toc-number">13.4.</span> <span class="toc-text">4.有了undolog为啥还需要redolog呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-redo-log%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">13.5.</span> <span class="toc-text">5.redo log怎么保证持久性的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%83%BD%E4%B8%8D%E8%83%BD%E5%8F%AA%E7%94%A8binlog%E4%B8%8D%E7%94%A8relo-log%EF%BC%9F"><span class="toc-number">13.6.</span> <span class="toc-text">6.能不能只用binlog不用relo log？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-binlog-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">13.7.</span> <span class="toc-text">7.binlog 两阶段提交过程是怎么样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-update%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">13.8.</span> <span class="toc-text">8.update语句的具体执行过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%EF%BC%9F"><span class="toc-number">13.9.</span> <span class="toc-text">9.MySQL是如何保障数据不丢失的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-RedoLog%E6%98%AF%E5%9C%A8%E5%86%85%E5%AD%98%E9%87%8C%E5%90%97%EF%BC%9F"><span class="toc-number">13.10.</span> <span class="toc-text">10.RedoLog是在内存里吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99RedoLog%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%86%99%E5%88%B0B-%E6%A0%91%E9%87%8C%E9%9D%A2%EF%BC%9F"><span class="toc-number">13.11.</span> <span class="toc-text">11.为什么要写RedoLog，而不是直接写到B+树里面？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-mysql-%E4%B8%A4%E6%AC%A1%E5%86%99%EF%BC%88double-write-buffer%EF%BC%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">13.12.</span> <span class="toc-text">12.mysql 两次写（double write buffer）了解吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sql%E8%B0%83%E4%BC%98"><span class="toc-number">14.</span> <span class="toc-text">sql调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-mysql%E7%9A%84explain%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">1.mysql的explain有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%99%E4%BD%A0%E5%BC%A0%E8%A1%A8%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E9%82%A3%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">14.2.</span> <span class="toc-text">2.给你张表，发现查询速度很慢，你有那些解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9CExplain%E7%94%A8%E5%88%B0%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%B9%B2%E9%A2%84%E5%90%97%EF%BC%9F"><span class="toc-number">14.3.</span> <span class="toc-text">3.如果Explain用到的索引不正确的话，有什么办法干预吗？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/14/new-stack/cache1/" title="Cache缓存"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/20250126175712179.jpg?_r_=84487f0c-e761-a90b-3875-d2128b619920" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cache缓存"/></a><div class="content"><a class="title" href="/2025/07/14/new-stack/cache1/" title="Cache缓存">Cache缓存</a><time datetime="2025-07-13T16:00:00.000Z" title="发表于 2025-07-14 00:00:00">2025-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/06/leetcode/leetcodehot2/" title="Leetcode HOT面试题目2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202410051722380.jpg?_r_=1699bf72-866b-5422-aa6f-2377ce78bc9a" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode HOT面试题目2"/></a><div class="content"><a class="title" href="/2025/07/06/leetcode/leetcodehot2/" title="Leetcode HOT面试题目2">Leetcode HOT面试题目2</a><time datetime="2025-07-05T16:00:00.000Z" title="发表于 2025-07-06 00:00:00">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/06/new-stack/MQ2/" title="MQ面试场景题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=4c5cee05-935d-797f-edc2-85bae5779e1c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MQ面试场景题"/></a><div class="content"><a class="title" href="/2025/07/06/new-stack/MQ2/" title="MQ面试场景题">MQ面试场景题</a><time datetime="2025-07-05T16:00:00.000Z" title="发表于 2025-07-06 00:00:00">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/06/new-stack/es1/" title="Elasticsearch"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221837601.jpeg?_r_=8af18a17-99b6-e0ee-2e17-9dd8f7146e32" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Elasticsearch"/></a><div class="content"><a class="title" href="/2025/07/06/new-stack/es1/" title="Elasticsearch">Elasticsearch</a><time datetime="2025-07-05T16:00:00.000Z" title="发表于 2025-07-06 00:00:00">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/workmenu/dianping1/" title="黑马点评项目逻辑功能分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://skymirror-1322372781.cos.ap-beijing.myqcloud.com/202407221811725.jpeg?_r_=71900f77-0f12-20bd-9708-a083924e2bff" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="黑马点评项目逻辑功能分析"/></a><div class="content"><a class="title" href="/2025/07/01/workmenu/dianping1/" title="黑马点评项目逻辑功能分析">黑马点评项目逻辑功能分析</a><time datetime="2025-06-30T16:00:00.000Z" title="发表于 2025-07-01 00:00:00">2025-07-01</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Framework-Hexo-4e88f8?style=flat&logo=hexo" 
       title="博客框架为 Hexo" alt="Hexo">
</a>
<a style="margin-inline:5px" target="_blank" href="https://github.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Source-Github-24292f?style=flat&logo=github" 
       title="本站项目由 GitHub 托管" alt="GitHub">
</a>
<a style="margin-inline:5px" target="_blank" href="https://vercel.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-Vercel-000000?style=flat&logo=vercel" 
       title="使用 Vercel 部署" alt="Vercel">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.qlu.edu.cn/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/University-齐鲁工业大学-0056a2?style=flat&logo=university" 
       title="齐鲁工业大学" alt="齐鲁工业大学">
</a>
<a style="margin-inline:5px" target="_blank" href="https://www.aliyun.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-阿里云-ff6a00?style=flat&logo=aliyun" 
       title="使用阿里云服务" alt="阿里云">
</a>
<a style="margin-inline:5px" target="_blank" href="https://cloud.tencent.com/">
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/Cloud-腾讯云-0a73b8?style=flat&logo=tencent-cloud" 
       title="使用腾讯云服务" alt="腾讯云">
</a></p>
</div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="mengnankkzhou" target="_blank">mengnankkzhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="鲁ICP备2024110758号">鲁ICP备2024110758号</a><a class="footer-bar-link" href="https://blog.tokenlen.top/rss2.xml" title="Rss">Rss</a><a class="footer-bar-link cc" href="/pravite" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">148</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">25</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.tokenlen.top/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://img.mengnankk.top:9001/" title="mengnankk图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="mengnankk图床"/><span class="back-menu-item-text">mengnankk图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 生活</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Message/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 其他</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> home</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://status.mengnankk.asia/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 站点检测</span></a></li><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://home.tokenlen.top/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 心里话</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/BF/" style="font-size: 0.88rem;">BF<sup>1</sup></a><a href="/tags/BigData/" style="font-size: 0.88rem;">BigData<sup>1</sup></a><a href="/tags/C/" style="font-size: 0.88rem;">C<sup>4</sup></a><a href="/tags/CE/" style="font-size: 0.88rem;">CE<sup>1</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem;">CSRF<sup>1</sup></a><a href="/tags/Cache/" style="font-size: 0.88rem;">Cache<sup>1</sup></a><a href="/tags/Elasticsearch/" style="font-size: 0.88rem;">Elasticsearch<sup>1</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>9</sup></a><a href="/tags/FI/" style="font-size: 0.88rem;">FI<sup>1</sup></a><a href="/tags/Hadoop/" style="font-size: 0.88rem;">Hadoop<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>12</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem;">XSS<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>52</sup></a><a href="/tags/juc/" style="font-size: 0.88rem;">juc<sup>2</sup></a><a href="/tags/jvm/" style="font-size: 0.88rem;">jvm<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>9</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>16</sup></a><a href="/tags/net/" style="font-size: 0.88rem;">net<sup>6</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>5</sup></a><a href="/tags/pip/" style="font-size: 0.88rem;">pip<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>3</sup></a><a href="/tags/redis/" style="font-size: 0.88rem;">redis<sup>3</sup></a><a href="/tags/rocketmq/" style="font-size: 0.88rem;">rocketmq<sup>1</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>4</sup></a><a href="/tags/spring/" style="font-size: 0.88rem;">spring<sup>2</sup></a><a href="/tags/spring-boot/" style="font-size: 0.88rem;">spring boot<sup>13</sup></a><a href="/tags/sql/" style="font-size: 0.88rem;">sql<sup>5</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/" style="font-size: 0.88rem;">数字逻辑<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">数据库原理<sup>3</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>19</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>2</sup></a><a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">汇编语言<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>9</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>18</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 mengnankkzhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.tokenlen.top/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, "siu~~~~~"))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.tokenlen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '3ZpuzQHHKWfFH59QFYmcuCvr-gzGzoHsz',
      appKey: '8DIvljObQp853ueQMZzpb9Gx',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Twikoo' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.tokenlen.top/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>