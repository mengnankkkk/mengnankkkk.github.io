<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Thu, 27 Feb 2025 13:46:50 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>sql原理</title>
      <link>https://blog.tokenlen.top/2025/02/25/sql1/</link>
      <guid>https://blog.tokenlen.top/2025/02/25/sql1/</guid>
      <pubDate>Mon, 24 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;事务&lt;/h1&gt;
&lt;p&gt;事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。&lt;/p&gt;
&lt;p&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>事务</h1><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png" alt=""></p><p>ACID特性</p><p>原子性（Atomicity）</p><p><strong>事务</strong>被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><p>一致性（Consistency）</p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><p>隔离性（Isolation）</p><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><p>持久性（Durability）</p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><p>但是这几个特性不是有一种平级关系</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png" alt=""></p><p>在mysql中一般采用autocommit自动提交模式</p><p>除非使用<code>START TRANSACTION</code>开启一个事务</p><p>否则每一个语句都被视作一个事务</p><p>mysql中事务的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">SET @@AUTOCOMIIT = 0;</span><br></pre></td></tr></table></figure><p>设置为手动提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><p>回滚事务</p><p>开启事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION 或 BEGIN;</span><br></pre></td></tr></table></figure><p><strong>实例银行：</strong></p><p>没有发生错误的时候，不需要rollback的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询账户A的余额</span><br><span class="line"><span class="keyword">SELECT</span> MONEY <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 更新账户A的余额，减去<span class="number">1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>更新账户B的余额，增加<span class="number">1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发生错误的时候，则需要rollback</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 查询账户A的余额</span><br><span class="line">    <span class="keyword">SELECT</span> MONEY <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>更新账户A的余额，减去<span class="number">1000</span></span><br><span class="line">    <span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 更新账户B的余额，增加<span class="number">1000</span></span><br><span class="line">    <span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 提交事务</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 如果发生错误，回滚事务</span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 可以添加错误处理的代码，比如记录日志或者返回错误信息</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改：">丢失修改：</h2><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><h2 id="读取脏数据">读取脏数据</h2><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h2 id="不可重复读">不可重复读</h2><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h2 id="幻读">幻读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是<strong>通过并发控制来保证隔离性</strong>。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p><h1>锁</h1><h2 id="封锁粒度">封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡</p><h2 id="锁类型">锁类型</h2><p>1.读写锁</p><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</p><p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png" alt=""></p><p>2.意向锁</p><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png" alt=""></p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/25/sql1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络-网络核心概念</title>
      <link>https://blog.tokenlen.top/2025/02/23/net2/</link>
      <guid>https://blog.tokenlen.top/2025/02/23/net2/</guid>
      <pubDate>Sat, 22 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本概念</h1><h2 id="传输方式">传输方式</h2><p>网络根据传输方式可以进行分类，一般分为<strong>面向连接型和面向无连接型</strong>。</p><ul><li>面向连接型中，在发送数据之前，需要在主机之间建立一条通信线路。</li><li>面向无连接型则不要求建立和断开连接，发送方可用于任何时候发送数据。接收端也不知道自己何时从哪里接收到数据。</li></ul><h2 id="分组交换">分组交换</h2><p>处在互联网边缘部分的机器，也就是互联网终端主机，它们官方一点的话术就是端系统。</p><p>在互联网应用中，每个终端系统都可以彼此交换信息，这种信息也被称为<code>报文(Message)</code>，报文是一个超集的概念，它可以包括你想要的任何东西，比如文字、数据、电子邮件、音频、视频等。为了从源目的地向端系统发送报文，需要把长报文切分为一个个小的数据块，这种数据块称为<code>分组(Packets)</code>，也就是说，报文是由一个个小块的分组组成。</p><p>这些分组其实就是<strong>包</strong></p><p>在分组的传输过程中，每个分组都要经过通信链路和分组交换机，分组要在端系统之间传输需要经过一定的时间，如果两个端系统之间需要传输的分组为 L 比特，链路的传输速率问 R 比特/秒，那么传输时间就是 L / R秒。</p><p>一个端系统需要经过交换机给其他端系统发送分组，当分组到达分组交换机时，交换机会如何操作？交换机会直接进行转发吗？不是的，交换机可没有这么无私，你想让我帮你转发分组？好，首先你需要先把整个分组数据都给我，我再考虑给你发送的问题，这就是<strong>存储转发传输</strong>。</p><h2 id="IP地址">IP地址</h2><p><strong>网络ip地址：</strong></p><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p><strong>广播地址：</strong></p><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p><strong>组播地址：</strong></p><p>D类地址就是组播地址。</p><p><strong>A，B，C，D类地址</strong></p><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p><p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>255.255.255.255</strong></p><p><strong>该IP地址指的是受限的广播地址</strong>。受限广播地址与一般广播地址（直接广播地址）的区别在于，<strong>受限广播地址只能用于本地网络</strong>，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p><strong>0.0.0.0</strong></p><p><strong>常用于寻找自己的IP地址</strong>，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p>回环地址：</p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是<strong>127.0.0.1。</strong> 也可以用<strong>localhost</strong>来表示</p><p><strong>A、B、C类私有地址</strong></p><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h2 id="子网掩码">子网掩码</h2><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。</p><p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即&quot; 0&quot;地址和广播地址，它们是指主机地址或网络地址全为&quot; 0&quot;或&quot; 1&quot;时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><h3 id="子网掩码的计算">子网掩码的计算</h3><p>无需划分：</p><p>在这个无须划分子网里面是按ip地址的类别决定的。比如A类地址占8个网络位，所以是255.0.0.0</p><p>B类地址占16个网络位，所以子网掩码就是255.255.0.0</p><p>C类地址占24个网络位，所以子网掩码就是255.255.255.0</p><p>固定大小的子网：</p><p>通常用于根据特定的网络需求（如特定数量的主机或子网）来划分。计算的关键是确定所需的网络位数和主机位数，并根据此来计算掩码。</p><ul><li><p>确定需要多少个子网，或者每个子网需要多少主机。</p></li><li><p>使用<strong>2的幂</strong>来推算所需的主机位数或子网位数。</p></li><li><p>将其与默认子网掩码结合，进行扩展。</p></li></ul><p>实例：</p><p>假设你有一个<strong>A类地址</strong><code>10.0.0.0</code>，默认子网掩码是<code>255.0.0.0</code>。你希望把这个地址划分为<strong>4个子网</strong>。</p><p>需要划分为4个子网，那么就需要2个子网位，然后又是A类地址，8个网络位。所以一共是10个网络位</p><p>所以新的子网掩码就是（前10位是1，其余是0）</p><p>11111111.11000000.00000000.00000000</p><p>转化为10进制就是</p><p><strong>255.192.0.0</strong></p><p>根据主机数来确定：</p><p>这种方法是通过需求来计算每个子网所能容纳的最大主机数，从而确定子网掩码。</p><ul><li><p>根据你想要的每个子网中的主机数，反推所需的主机位数。</p></li><li><p>用<strong>2的幂</strong>来计算能容纳的最大主机数。公式：<code>2^n - 2</code>（减去2是因为网络地址和广播地址不能用作主机地址）。</p></li><li><p>然后确定剩下的位数就是网络位数，从而确定子网掩码。</p></li></ul><p>实例：</p><p>假设你想要为每个子网容纳50个主机</p><p>2^n - 2 &gt;= 50</p><p><code>2^6 - 2 = 62</code>，所以需要6个主机位。</p><p>如果是C类地址，默认掩码是<code>255.255.255.0</code>，即24个网络位。</p><p>所以那么子网掩码用二进制表示就是</p><p>现在，给定6个主机位，网络位数是：<code>32 - 6 = 26</code></p><p>11111111.11111111.11111111.11000000</p><p>转化为10进制就是<strong>255.255.255.192</strong></p><p>CIDR表示法：</p><p>它允许你直接指定子网掩码的位数，而不是依赖于IP地址的类别。CIDR表示法用斜杠后跟数字的形式表示子网掩码。</p><ul><li><p>CIDR表示法是通过直接指明网络部分的位数来计算子网掩码。例如，<code>/24</code> 表示前24位是网络位，后8位是主机位。</p></li><li><p>你可以通过CIDR来指定任何IP地址和子网掩码，而不仅仅是A类、B类或C类地址。</p></li></ul><p><code>10.0.0.0/8</code>：表示A类地址 <code>10.0.0.0</code>，子网掩码为 <code>255.0.0.0</code>。</p><p><code>172.16.0.0/16</code>：表示B类地址 <code>172.16.0.0</code>，子网掩码为 <code>255.255.0.0</code>。</p><p><code>192.168.1.0/24</code>：表示C类地址 <code>192.168.1.0</code>，子网掩码为 <code>255.255.255.0</code>。</p><p>主机和子网的地址进行计算：</p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10＋1＋1＋1＝13</span><br></pre></td></tr></table></figure><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址</strong></p><p>网关也是要占地址的</p><p>13小于16（2的四次方）所以主机位是4位。256-16=240</p><p>所以子网掩码是<strong>255.255.255.240</strong></p><h2 id="ARP-RARP协议">ARP/RARP协议</h2><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议</strong></p><p>ARP 把 IP 地址解析为硬件地址</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</p><p><strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>ARP工作流程：</p><ul><li><p><strong>主机A查询ARP缓存</strong>：主机A检查是否有主机B的IP地址和MAC地址映射。如果有，直接使用该映射进行通信。</p></li><li><p><strong>ARP请求广播</strong>：如果ARP缓存中没有对应的映射，主机A会向网络广播ARP请求，询问目标IP（192.168.1.2）的MAC地址，ARP请求包括主机A的IP和MAC地址。</p></li><li><p><strong>主机B接收ARP请求</strong>：网络中的所有主机接收到ARP请求，检查IP地址是否匹配。如果匹配，则继续处理请求；否则丢弃请求。</p></li><li><p><strong>主机B发送ARP回复</strong>：主机B回复ARP请求，发送自己的MAC地址给主机A。</p></li><li><p><strong>主机A更新ARP缓存</strong>：主机A接收到主机B的ARP回复后，更新ARP缓存，并使用主机B的MAC地址进行通信。</p></li><li><p><strong>缓存生存期</strong>：ARP缓存的条目有生存期，生存期过后，主机A需要重新进行ARP过程以更新MAC地址映射。</p></li></ul><p>RARP工作流程：</p><ul><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/23/net2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English二月篇</title>
      <link>https://blog.tokenlen.top/2025/02/01/en6/</link>
      <guid>https://blog.tokenlen.top/2025/02/01/en6/</guid>
      <pubDate>Fri, 31 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;每日一话+单词遗忘表2.1&lt;/h1&gt;
&lt;p&gt;The more you experience and appreciate the goodness of life, the more there is to be lived.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pearl</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>每日一话+单词遗忘表2.1</h1><p>The more you experience and appreciate the goodness of life, the more there is to be lived.</p><ul><li>pearl 珍珠</li><li>peasant 农民</li><li>peculiar 特殊的</li><li>pedestrian 步行者</li><li>peer 凝视</li><li>penalty 处罚</li><li>penetrate 刺入</li><li>perhaps 也许</li><li>peril 危险</li><li>persevere 坚持</li><li>persist 持续</li><li>perspective 远景</li><li>persuade 说服</li></ul><h1>每日一话+单词遗忘表2.2</h1><p>Your generation has come of age facing a challenge like no other generation before you.</p><ul><li>pessimism 悲观的</li><li>petroleum 石油</li><li>phase 相位</li><li>phrase 成语</li><li>pile 堆</li><li>pillar 柱子</li><li>pinch 捏</li></ul><h1>每日一话+单词遗忘表2.3</h1><p>Don’t try to win a friend by presenting gifts.</p><ul><li>pipe 烟斗</li><li>pistol 手枪</li><li><strong>plague</strong> 瘟疫</li><li>implicit 暗示的</li><li><strong>platform</strong> 月台</li><li>pledge 发誓</li><li>inflate 使充气</li><li>plough 耕</li><li>plunge 投入</li><li><strong>plural</strong> 复数的</li></ul><h1>每日一话+单词遗忘表2.4</h1><p>Sometimes I have thought it would be an excellent rule to live each day as if we should die tomorrow.</p><ul><li>politics 政治学</li><li>pond 池塘</li><li>pool 水池</li><li>portion 部分</li><li>pause 暂停</li></ul><h1>每日一话+单词遗忘表2.5</h1><p>The best preparation for good work tomorrow is to do good work today.</p><ul><li>postpone 使。。延期</li><li>pour 倾泻</li><li>poverty 贫困</li><li>powder 火药</li><li>practical 明智的</li><li>praise 称赞</li><li><strong>preach</strong> 说教</li><li>precaution 预防</li><li>precise 精确的</li><li><strong>preface</strong> 前言</li><li>prejudice 成见</li><li>preliminar 初步的</li><li>premier 第一的</li><li>prescribe 开药方</li></ul><h1>每日一话+单词遗忘表2.6</h1><p>As selfishness and complaint cloud the mind, so love with its joy clears and sharpens the vision.</p><ul><li>preserve 保护</li><li><strong>prevail</strong> 盛行</li><li>priest 牧师</li><li>prince 王子</li><li>principal 主要的</li><li>principle 原则</li><li>prior 先前的</li><li>privilege 特权</li><li>conceal 隐藏</li></ul><h1>每日一话+单词遗忘表2.7</h1><p>If you don’t design your own life plan, chances are you’ll fall into someone else’s. And guess what they might have planned for you? Not much.</p><ul><li>principal 本金</li><li>pirate 海盗</li><li>contempt 轻视</li><li>procession 队列</li><li>procliam 宣称</li><li>contaminate 污染</li><li>proficient 精通的</li><li>profound 深度的</li><li>prominemt 显著的</li><li><strong>prompt</strong> 敏捷的</li><li>proof 证明</li><li>proportion 部分</li><li>prose 散文</li><li>protein 蛋白质</li><li>constitution 宪法</li></ul><h1>每日一话+单词遗忘表2.8</h1><p>Keep your friends close, but your enemies closer.</p><ul><li>protest 抗议</li><li>proverb 谚语</li><li>provoke 激怒</li><li>pulse 脉搏</li><li>punch 按键</li><li>purchase 购买</li><li>pure 纯的</li><li>purse 钱包</li><li>pursue 追求</li></ul><h1>每日一话+单词遗忘表2.11</h1><p>We delight in the beauty of the butterfly, but rarely admit the changes it has gone through to achieve that beauty.</p><ul><li>quarrel 吵架</li><li>quiz 考察</li><li><strong>quota</strong> 配额</li><li>quote 引述</li><li>rack 行李架</li><li><strong>radical</strong> 根本的</li><li>rag 破布</li><li>raid 袭击</li></ul><h1>每日一话+单词遗忘表2.12</h1><p>I look for her in vain. When all at once I turn my head, I find her there where lantern light is dimly shed.</p><ul><li>rapid 快速的</li><li>realistic 现实的</li><li>realm 领域</li><li><strong>reap</strong> 收割</li><li>rear 后面的</li><li>rebel 造反</li><li>recite 背诵</li><li>reckon 猜想</li></ul><h1>每日一话+单词遗忘表2.13</h1><p>It never will rain roses. When we want to have more roses we must plant trees.</p><ul><li>recognize 承认</li><li><strong>recreation</strong> 娱乐</li><li>recruit 招聘</li><li><strong>refine</strong> 精炼</li><li>refrain 制止</li><li>reform 改革</li><li>counterpart 地位相当的</li><li>rebel 反抗分子</li><li>intangible 难以琢磨的</li><li>reckon 猜想</li><li>proficient 精炼的</li><li>relative 相对的</li><li>instalment 一部分</li></ul><h1>每日一话+单词遗忘表2.14</h1><p>The love that lasts the longest is the love that is never returned.</p><ul><li>relay 转播</li><li>relevant 有关的</li><li>religion 宗教</li><li>reluctant 不情愿的</li><li>remedy 药品</li><li>render 提出</li><li>renovate 革新</li></ul><h1>每日一话+单词遗忘表2.15</h1><p>The worst tragedy for a poet is to be admired through being misunderstood.</p><ul><li>rescue 营救</li><li>resent 怨恨</li><li>respective 各自的</li><li>retail 零售</li><li>reunite 使…结合</li><li>loophole 弹孔</li></ul><h1>每日一话+单词遗忘表2.16</h1><p>We soon believe what we desire.</p><ul><li>reveal 揭示</li><li>revenue 税收</li><li>revise 修订</li><li>rhythm 节奏</li><li>riddle 解密</li><li>ridicule 嘲笑</li><li>rifle 步枪</li><li>riot 暴乱</li><li>rival 竞争者</li><li>roar 吼叫</li><li>procliam 宣布占领</li></ul><h1>每日一话+单词遗忘表2.17</h1><p>Gather sweet blossoms while you may; And not the twig devoid of flowers!</p><ul><li>rob 抢劫</li><li>rod 棒</li><li>rouse 醒来</li><li>route 路线</li><li>rubber 橡胶</li><li>ruin 毁灭</li><li>rumor 谣言</li></ul><h1>每日一话+单词遗忘表2.18</h1><p>I am no bird; and no net ensnares me: I am a free human being with an independent will.</p><ul><li>sacrifice 牺牲</li><li>saint 圣徒</li><li>sausage 香肠</li><li>scandal 传闻</li></ul><h1>每日一话+单词遗忘表2.19</h1><p>I cannot teach anybody anything, I can only make them think</p><ul><li>scarce 缺少</li><li>scatter 分散的</li><li>scheme 计划</li><li>scissors 剪刀</li><li>scold 责骂</li><li>scount 侦察机</li><li>scratch 抓痕</li><li>screw 旋</li></ul><h1>每日一话+单词遗忘表2.20</h1><p>Tenderness and kindness are not signs of weakness and despair, but manifestations of strength and resolution.</p><ul><li>sector 部门</li><li>secure 安全</li><li>seminar 讨论会</li><li>sentence 宣判</li><li>separate 分局</li><li>servant 仆人</li><li>naughty 顽皮的</li></ul><h1>每日一话+单词遗忘表2.21</h1><p>Morality is not really the doctrine of how to make ourselves happy but of how we are to be worthy of happiness.</p><ul><li>sew 缝上</li><li>sharp 急促的</li><li>shave 剃</li><li>shed 棚子</li><li>sheeer 陡峭的</li><li>shelter 避难所</li></ul><h1>每日一话+单词遗忘表2.22</h1><p>The best way to find out if you can trust somebody is to trust them.</p><ul><li>shiver 颤抖</li><li>shrimp 虾</li><li>shrug 耸肩</li><li>siege 围攻</li></ul><h1>每日一话+单词遗忘表2.23</h1><p>Sometimes you have to travel a long way to find what is near.</p><ul><li>script 轨迹</li><li>silk 蚕丝</li><li>sin 过失</li><li>sip 抿</li><li>situation 形式</li><li>skate 滑冰</li><li>skeleton 骨架</li></ul><h1>每日一话+单词遗忘表2.24</h1><p>The pain of parting is nothing to the joy of meeting again.</p><ul><li>sketch 素描</li><li>skyscraper 摩天大楼</li><li>slap 拍击</li><li>sleeve 袖子</li><li>slender 苗条的</li><li>slide 滑动</li><li>slim 苗条的</li><li>slogan 标语</li><li>smash 打碎</li></ul><h1>每日一话+单词遗忘表2.25</h1><p>A fool thinks he is clever, the wise man knows himself to be a fool.</p><ul><li>soar 高飞</li><li>soil 土壤</li><li>solemn 庄严的</li><li>sophisticated 老练的</li><li>sorrow 悲伤的</li><li>spacecraft 宇宙飞船</li><li>spade 铁锹</li><li>spare 备用的</li><li>sparkle 发火花</li></ul><h1>每日一话+单词遗忘表2.26</h1><p>A man’s reading program should be as carefully planned as his diet, for that too is food, without which he cannot grow mentally.</p><p>今天四级出分了，成功的没过。哎下次再考吧。</p><ul><li>species 物种</li><li>specific 特殊的</li><li>specify 指定</li><li>speculate 思索</li><li>sphere 范围</li><li>spill 溢出</li><li>spite 恶意</li><li>splash 溅</li><li>spoil 溺爱</li><li>spot 斑点</li></ul><h1>每日一话+单词遗忘表2.27</h1><p>A man can fail many times, but he isn’t a failure until he begins to blame somebody else.</p><ul><li>spray 喷雾</li><li>spur 马刺</li><li>spy 侦察</li><li>squeeze 挤压</li><li>stable 马厩</li><li>stadium 体育场</li><li>stain 玷污</li><li>staple 订书钉</li><li>startle 吓一跳</li></ul><h1>每日一话+单词遗忘表2.28</h1><p>Many people waste a whole life waiting for the chance to meet their desire.</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/01/en6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>毛泽东选集阅读体会&amp;杂谈</title>
      <link>https://blog.tokenlen.top/2025/01/26/mao1/</link>
      <guid>https://blog.tokenlen.top/2025/01/26/mao1/</guid>
      <pubDate>Sat, 25 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;2025.1.26&lt;/h1&gt;
&lt;p&gt;在革命的过程中，我们要注意谁是我们的朋友。谁是我们的敌人，团结我们能所团结的，打到我们的敌人。&lt;/p&gt;
&lt;p&gt;地主阶级是国际资产主义的附庸，特别是大地主阶级和大买办阶级，他们是完全靠着国际资本主义，来压榨底层的百姓的。小地主阶级和小买办</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>2025.1.26</h1><p>在革命的过程中，我们要注意谁是我们的朋友。谁是我们的敌人，团结我们能所团结的，打到我们的敌人。</p><p>地主阶级是国际资产主义的附庸，特别是大地主阶级和大买办阶级，他们是完全靠着国际资本主义，来压榨底层的百姓的。小地主阶级和小买办阶级是可以团结的，给与他们扩大的实力，他们可以为革命所用。要团结一切可以团结的力量。</p><p>中产阶级代表跟小地主阶级类似，他们是矛盾的，他们是人数较少的。可以对他们进行团结，扩大他们的生产，扩大他们的力量，在革命的大旗下进行扩大化。进行革命化的特色改造。</p><p>小资产阶级或者说是无产阶级是我们革命的主力军，他们的力量是强大的，他们的力量是可以翻天覆地的。他们有很少或者没有生产资料，他们处于社会的最底层，其中有很大一部分人有很强的向上的力量，很强的革命的力量。我们要从他们之中去发展力量，积蓄力量，给大地主阶级和大买办阶级或者说是大官僚阶级沉重的打击。</p><h1>2025.1.27</h1><p>组织运动，农民是我国力量最大的，人数最多的阶层。这里的农民不单单是指农村户口的农民，而是指的是出生于农村，从农村长大。祖祖辈辈和土地和农村相关联的人。他们是任劳任怨的，不到迫不得已的的时候，是不会反抗的。他们自发的进行革命力量的组织的力量是弱小的，是没有把力量集中到一起的。</p><p>需要的革命的组织进行正确的领导，这就是农会。农会是从农民中来，到农民中去的。农会中的领导者是农民选举出来的，是农民阶级的代言人。他们领导农民的革命方向，代表着广大农民的利益。</p><h1>2025.1.29</h1><p>资本主义，或者说是资产阶级。他们在很久之前是社会的进步的力量，引导人们从封建主义到了资本主义，这是生产力发展的必然结果。但是资本是逐利的，资本是冒险的。他们很多会不思进取，开源节流，在经济形式不好的时候</p><p>，他们第一想到的就是节流，即降低工人的待遇。降低工人的工资，压榨工人。将工人的剩余价值剥削的更多。工人因为承担着养家糊口的责任，他们不能丢失这个工作，失去了这个工作他们无法生存。只能继续承担着资本的剥削。</p><p>资本在剥削之中会合并资本，大资本跟更大的资本进行结合。阶级实现了固化，普通人向上发展的道路被堵塞了，而资本或者说是特权阶级，一出生就拥有着百分之九十五的人一生都无法获得的生产资料。</p><p>在资本逐利的过程中，他们为了扩大生产，提高自己的影响力。他们会和官员也就是权力勾结起来，形成官商勾结体。官商勾结自古由来已久，大商人或者说是资本有钱，而官员们有权。官商勾结起来，就形成了一个即有权又又钱的利益集团。俗话说有钱有权可以做到世界上的一切事情，如果做不到就是钱还不够多，权还不够大。</p><h1>2025.1.31</h1><p>特权阶级也就是说的官僚阶级和资本他们一旦联合起来，形成一个利益集团。他们只会看着自己眼前的利益，不会把一分一毫的利益分享给其他的平民。利益集团会侵占国家利益，他们不会以国家利益为基础，将整个国家绑在他们的战车之上。整个国家都会变成他们的私有财产。然后在权力和钱财的追逐之下，政府其实就代表这些利益集团的集合利益。</p><h1>2025.2.6</h1><p>我们不能忘记民族矛盾，虽然民族矛盾可以算是阶级矛盾在具体方面的一种体现，按照托洛斯基的理念，或者说激进的马克思主义者的观念来说，国家和民族最终都要消亡的。但是这毕竟是千年可能都完不成的目标，可以说在近一百年这是不可能的。我们是中华民族，我们和日本人，是有着血海深仇的。这是绝对不可以忘掉了，一个甲子之前我们刚刚才把日本人赶出了中国。我们现在和日本人的矛盾是不可以忘却的，南京的三十万百姓惨案不可忘掉。不仅仅是日本人，有一个国家或者说是一个民族，对我们的伤害不亚于日本人，那就是俄罗斯。在特殊的历史条件下，大鹅是我们的朋友。但是我们和大鹅的血海深仇是不可以忘的。二战后期借着打击关东军的民意，侵略我国东北，我国东北人民遭受了巨大的灾难，机械等大型产业被掠夺，非常非常多的资源也被掠夺，更不要说侵占了我们那么多的土地，把我们的人民屠杀了许多。这个仇是不可以忘的！</p><h1>2025.2.12</h1><p>前前后后多少事，还得是将军说的对啊。文化工作者一定要有文化！</p><p>最近刘诗诗主演的电视剧《掌心》正在热播中，这个电视剧拍的怎么样我不敢说，但是以武周时期为蓝本的电视剧，派王子出去和亲实在是太不符合历史了，再说我们着一般说是皇子，一般不说王子。当时武则天他派的是他的一个侄子。根本称不上皇子。而电视剧虽然是里面那个也不是李唐的皇子，但他说的的确是王子和亲。编剧在改编的时候，能不能动点脑子，给抄错了。</p><p>所以说文化工作者要有文化，这句话果然是有大道理的啊。</p><h1>2025.2.13</h1><p>明天就是情人节，但是这个情人节值得是国外传过来的情人节，而我们中国自己的情人节是在农历的七月七，也就是我们常说的七夕。我们长久以来过的是这个情人节。传说这是牛郎织女相会的日子,鹊桥会出现，然后牛郎织女就可以通过鹊桥来相会。然后人们总是会在这个时候举办灯会，女子男子可以通过看灯会来寻找自己的另一半。但是如今，七夕大家都不过了，反而大家都去过国外传过来的情人节，我们自己的文化传统都丢失了。这就是文化入侵！这就是我们为什么要提高我们的文化自信力，我们的上千年的文化是比他们这些国外的蛮人只有近几百年的文化要强大的，我们要对我们的文化要有自信！</p><h1>2025.2.14</h1><p>四十年来家国，三千里地山河。凤阁龙楼连霄汉，玉树琼枝作烟萝，几曾识干戈。</p><p>一旦归为臣虏，沈腰潘鬓消磨。最是仓皇辞庙日，教坊犹奏别离歌，垂泪对宫娥。</p><p>最近又学了什么诗词啊~</p><p>不禁潸然泪下，一生转战三千里，流落异乡倍思亲。</p><h1>2025.2.15</h1><p>不管用什么方法，最终的目的都是社会主义。一个人无论今天穿男装还是女装，并不会影响实际性别。因为性别是由染色体决定的。许多修正主义者就是在这里歪曲了马克思主义道路。宣称的正大光明，实际就是在找借口，篡改和歪曲马克思主义的原则性问题。马克思主义当然需要探索和发展，但绝不是背叛无产阶级革命的探索与发展。如果是为了剥削者而进行发展，那这究竟是马克思主义的探索还是资本主义的探索呢？</p><p>在历史的长河之中，探索道路一定要选择对方向。无论你走的多远，方向错了，那走再多也白费。</p><p>世界上没有不透风的墙，无论在多么封闭的地方，终究最后消息会传出去。可能消息传着传着可能就变了味道。与其被人调侃，不如一开始就处在开放的时候。</p><h1>2025.2.16</h1><p>观史可以明智，世界上是没有新鲜事的。人类的所有，其实都是一个轮回。所有的事情都可以在历史上找到类似的事情，和与其对应的后果和解决方法。</p><p>所以历史是必须要看的，而且是必须要认真看的。</p><p>韩信自大自以为是汉朝离不开他，最后终究还是落个被杀的下场。哎</p><h1>2025.2.18</h1><p>普天之下，莫非王土。率土之滨，莫非王臣。我们无论如何都不能放弃自己科技的发展，虽然国外的可能更加好用，更加便宜。但我们自身必须要有可以研究使用的能力。但是，研究研发不是一味的标榜自己是国产。国产不代表这是一个消费的标签。不能用国货的名义来消费消费者。这样可能一段时间内是比较有效的，但是长久来看，这是非常非常不利的。</p><h1>2025.2.19</h1><p>天行健，君子以自强不息。我们需要在我们的传统文化中，汲取优秀美好的力量，我们上下五千年的历史是悠久的，可以说是文化是没有断绝过的。是非常有利的，我们古人上下总结的文化，是可以实实在运用到我们的生活和实践中的。这就是中国文化的魅力，这就是历史长的好处。我们应该不能放弃我们的文化，不能被外来文化完全入侵了。无论是好的还是坏的，他们都不能改变我们中国的文化！</p><h1>2025.2.22</h1><p>至此天下唯有大秦，我们中华自打秦朝以来，就有着必须大一统的心念存在我们心中。现在我们的领土并不完整，我们的许多自古以来的土地被他人占据，这些土地是我们必须要拿回来的，要不然我们就算不上大一统。比如虎踞夷州岛，比如我们的藏南地区，比如外西北，外东北，我们的第一大岛库页岛。比如我们的三宣六慰，我们的旧港都是我们自古以来的领土。这些是必须一定要收回的！</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/Marxists/">Marxists</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%AF%9B%E9%80%89/">毛选</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/26/mao1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络-七层体系结构</title>
      <link>https://blog.tokenlen.top/2025/01/13/net1/</link>
      <guid>https://blog.tokenlen.top/2025/01/13/net1/</guid>
      <pubDate>Sun, 12 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础引入&lt;/h1&gt;
&lt;p&gt;两个计算机设备想要通信，可以用一根线连接起来，两台设备使用电信号传播数据&lt;/p&gt;
&lt;p&gt;如果都是用一根线连接两台设备的话，所需要的线数C等于&lt;br&gt;
$$&lt;br&gt;
C=(n-1)n/2&lt;br&gt;
$$&lt;br&gt;
但这样不太理想&lt;/p&gt;
&lt;p&gt;所以我们</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础引入</h1><p>两个计算机设备想要通信，可以用一根线连接起来，两台设备使用电信号传播数据</p><p>如果都是用一根线连接两台设备的话，所需要的线数C等于<br>$$<br>C=(n-1)n/2<br>$$<br>但这样不太理想</p><p>所以我们可以使用一个hub就是一个集线器</p><p>比如</p><p>设备1可以通过<strong>hub</strong>然后转发给设备3，但这样的话是群发，不太安全</p><p>而且只能单向的交流，也不太好</p><p>所以使用了<strong>交换机</strong>，使用<strong>mac值</strong>来区分设备</p><p>这个是全球唯一的</p><p>允许两台设备双向交流，也可以两台交换机来交换数据，这叫<strong>桥接网络</strong></p><p>内网这样是可以使用的，但是不能使用很多，因为交换机的存储mac地址的数量是有限的。</p><p><strong>路由器</strong>可以适用于网络的转发</p><p><strong>不同网络连接到路由器的ip叫做默认网关</strong></p><p><strong>ip</strong>只是一个过程使用，最后还是使用<strong>mac地址</strong>来转发数据</p><h1>概述</h1><h2 id="1-1基本术语">1.1基本术语</h2><p><strong>结点 （node）</strong>：网络中的结点可以是计算机，集线器，交换机或路由器等。</p><p><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</p><p><strong>主机（host）</strong>：连接在因特网上的计算机。</p><p><strong>ISP（Internet Service Provider）</strong>：因特网服务提供者（提供商）。</p><p><img src="https://oss.javaguide.cn/p3-juejin/e77e26123d404d438d0c5943e3c65893~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>IXP（Internet eXchange Point）</strong>：互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p><p><strong>RFC(Request For Comments)</strong>：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</p><p><strong>广域网 WAN（Wide Area Network）</strong>：任务是通过长距离运送主机发送的数据。</p><p><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</p><p><strong>局域网 LAN（Local Area Network）</strong>：学校或企业大多拥有多个互连的局域网。</p><p><img src="https://oss.javaguide.cn/p3-juejin/eb48d21b2e984a63a26250010d7adac4~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>个人区域网 PAN（Personal Area Network）</strong>：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</p><p><strong>分组（packet ）</strong>：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</p><p><strong>存储转发（store and forward ）</strong>：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发 送的输出端口地址，然后将该包发送出去。</p><p><img src="https://oss.javaguide.cn/p3-juejin/addb6b2211444a4da9e0ffc129dd444f~tplv-k3u1fbpfcp-zoom-1.gif" alt=""></p><p><strong>带宽（bandwidth）</strong>：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</p><p><strong>吞吐量（throughput ）</strong>：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</p><h2 id="1-2知识点总结">1.2知识点总结</h2><p><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></p><p>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</p><p>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据段的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</p><p>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</p><p>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</p><p>这里介绍一下C/S模式和P2P模式：</p><p>C/S 模式是一种计算机网络通信架构，其中通信由客户端（Client）发起，请求服务，服务器（Server）响应并提供服务。</p><p>特点：</p><p><strong>集中管理</strong>：服务器通常拥有强大的计算和存储能力，负责集中管理资源和处理请求。</p><p><strong>固定角色</strong>：客户端负责发送请求，服务器负责响应。角色明确。</p><p><strong>典型应用</strong>：</p><ul><li>Web浏览器和Web服务器（HTTP/HTTPS通信）</li><li>数据库客户端与数据库服务器（如MySQL）</li></ul><p>服务器是里面的重中之重，服务器承担着接发消息和处理消息的功能。如果服务器瘫痪了，这个功能就可以说是完蛋了。</p><p>P2P 模式是一种网络通信架构，其中所有参与者（节点）既是服务的消费者（Client），又是服务的提供者（Server）。</p><p>特点：</p><p><strong>分布式管理</strong>：网络中的每个节点都可以直接通信，无需中央服务器。</p><p><strong>动态角色</strong>：节点既能发送请求，也能响应其他节点的请求。</p><p><strong>典型应用</strong>：</p><ul><li>文件共享系统（如BitTorrent）</li><li>区块链网络（如比特币、以太坊）</li></ul><p>p2p模式可以说是点对点模式，扩展性高，但是不太安全。</p><h3 id="对比总结"><strong>对比总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>C/S 模式</strong></th><th><strong>P2P 模式</strong></th></tr></thead><tbody><tr><td><strong>架构特点</strong></td><td>集中式架构</td><td>分布式架构</td></tr><tr><td><strong>节点角色</strong></td><td>固定（客户端和服务器）</td><td>动态（节点既是客户端又是服务器）</td></tr><tr><td><strong>适用场景</strong></td><td>Web服务、数据库查询</td><td>文件共享、区块链等分布式服务</td></tr><tr><td><strong>优势</strong></td><td>易管理、高效率</td><td>去中心化、高扩展性</td></tr><tr><td><strong>劣势</strong></td><td>单点故障、扩展性有限</td><td>资源协调和安全性挑战</td></tr></tbody></table><p><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></p><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</p><p><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></p><p><img src="https://oss.javaguide.cn/p3-juejin/acec0fa44041449b8088872dcd7c0b3a~tplv-k3u1fbpfcp-zoom-1.gif" alt=""></p><h1>物理层</h1><h2 id="2-1基本术语">2.1基本术语</h2><ol><li><strong>数据（data）</strong>：运送消息的实体。</li><li><strong>信号（signal）</strong>：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li><li><strong>码元（ code）</strong>：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li><li><strong>单工（simplex ）</strong>：只能有一个方向的通信而没有反方向的交互。</li><li><strong>半双工（half duplex ）</strong>：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</li><li><strong>全双工（full duplex）</strong>：通信的双方可以同时发送和接收信息。</li><li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li><li><strong>奈氏准则</strong>：在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li><li><strong>基带信号（baseband signal）</strong>：来自信源的信号。指没有经过调制的数字信号或模拟信号。</li><li><strong>带通（频带）信号（bandpass signal）</strong>：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li><li><strong>调制（modulation ）</strong>：对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li><li><strong>信噪比（signal-to-noise ratio ）</strong>：指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li><li><strong>信道复用（channel multiplexing ）</strong>：指多个用户共享同一个信道。（并不一定是同时）。</li><li><strong>比特率（bit rate ）</strong>：单位时间（每秒）内传送的比特数</li></ol><p><img src="https://oss.javaguide.cn/p3-juejin/5d9bf7b3db324ae7a88fcedcbace45d8~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>波特率（baud rate）</strong>：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</p><p><strong>复用（multiplexing）</strong>：共享信道的方法。</p><p><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong>：非对称数字用户线。</p><p><strong>光纤同轴混合网（HFC 网）</strong>：在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</p><h2 id="2-2知识点总结">2.2知识点总结</h2><p><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></p><ol><li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li><li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电气或电磁的表现。</strong></li><li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li><li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li><li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li><li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li><li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li><li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li></ol><p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状和尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能的各种可能事件的出现顺序）。</p><p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p><p><strong>常用的信道复用技术</strong></p><ol><li><strong>频分复用(FDM)</strong>：所有用户在同样的时间占用不同的带宽资源。</li><li><strong>时分复用（TDM）</strong>：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li><li><strong>统计时分复用 (Statistic TDM)</strong>：改进的时分复用，能够明显提高信道的利用率。</li><li><strong>码分复用(CDM)</strong>：用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li><strong>波分复用( WDM)</strong>：波分复用就是光的频分复用。</li></ol><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ADSL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p><h1>数据链路层</h1><h2 id="3-1基本术语">3.1基本术语</h2><p><strong>链路（link）</strong>：一个结点到相邻结点的一段物理链路。</p><p><strong>数据链路（data link）</strong>：把实现控制<strong>数据运输的协议</strong>的硬件和软件加到链路上就构成了数据链路。</p><p><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong>：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</p><p><strong>帧（frame）</strong>：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</p><p><strong>MTU（Maximum Transfer Uint ）</strong>：最大传送单元。帧的数据部分的的长度上限。</p><p><strong>误码率 BER（Bit Error Rate ）</strong>：在一段时间内，传输错误的比特占所传输比特总数的比率。</p><p><strong>PPP（Point-to-Point Protocol ）</strong>：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路</p><p><img src="https://oss.javaguide.cn/p3-juejin/6b0310d3103c4149a725a28aaf001899~tplv-k3u1fbpfcp-zoom-1.jpeg" alt=""></p><p><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong>：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。”</p><p><strong>网桥（bridge）</strong>：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</p><p><strong>交换机（switch ）</strong>：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</p><h2 id="3-2重要知识点总结">3.2重要知识点总结</h2><p>链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</p><p>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></p><p><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</p><p><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</p><p>PPPoE 是为宽带上网的主机使用的链路层协议</p><p><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></p><p>计算机与外接局域网通信需要通过<strong>通信适配器</strong>（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</p><p>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</p><p>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上的各站点平等地争用以太网信道</p><p>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</p><p>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</p><hr><h2 id="3-3补充问题">3.3补充问题</h2><p>数据链路层的点对点信道与广播信道的特点</p><ol><li><strong>点对点信道</strong>：<ul><li><strong>特点</strong>：数据在两个设备之间进行直接传输，通常不涉及多设备之间的干扰。信号只在发送端和接收端之间传输。</li><li><strong>协议</strong>：常用协议为<strong>PPP（Point-to-Point Protocol）</strong>。PPP是点对点协议，支持多种网络层协议。它提供了封装数据、认证、压缩以及错误检测功能。</li></ul></li><li><strong>广播信道</strong>：<ul><li><strong>特点</strong>：信号在多个设备间广播，所有连接到该信道的设备都能接收到传输的数据。需要控制如何解决多设备争用信道的问题。</li><li><strong>协议</strong>：常用协议为<strong>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）</strong>。CSMA/CD用于以太网，允许多个设备共享同一信道。它通过侦测信道是否空闲，避免冲突；如果发生冲突，设备会退避一段时间后重试。</li></ul></li></ol><p>数据链路层的三个基本问题</p><ol><li><strong>封装成帧</strong>：<ul><li>数据链路层将网络层传来的数据封装成帧，添加头部和尾部信息，如目标地址、源地址、帧校验序列（FCS）等。</li></ul></li><li><strong>透明传输</strong>：<ul><li>保证数据的传输不会受到链路中可能出现的特殊符号的影响（如数据流中的帧分隔符）。通过位填充等技术确保数据在链路上传输时的完整性和正确性。</li></ul></li><li><strong>差错检测</strong>：<ul><li>数据链路层通过CRC（循环冗余校验）等技术对数据进行差错检测，确保数据传输过程中没有发生错误。如果检测到错误，通常会丢弃该帧并要求重传。</li></ul></li></ol><hr><p>以太网的 MAC 层硬件地址</p><ul><li><strong>MAC地址</strong>（媒体访问控制地址）是网络适配器（如网卡）在局域网中的唯一标识符。它通常是由硬件生产商分配的 48 位地址，表示网络接口设备。MAC地址通常以16进制形式表示，如：<code>00:1A:2B:3C:4D:5E</code>。</li></ul><hr><p>适配器、转发器、集线器、网桥、以太网交换机的作用及适用场</p><ol><li><strong>适配器（网络适配器）</strong>：<ul><li><strong>作用</strong>：网络适配器（如网卡）用于连接计算机与网络，通过物理层传输数据。它提供了与网络进行数据通信的接口。</li></ul></li><li><strong>转发器</strong>：<ul><li><strong>作用</strong>：转发器用于在不同的网络之间进行数据转发，通常用于协议转换或将不同网络技术的设备连接起来。</li></ul></li><li><strong>集线器（Hub）</strong>：<ul><li><strong>作用</strong>：集线器是一个简单的网络设备，能够将信号广播到所有端口，适用于小型网络。但它不具备智能，仅用于物理层的信号传输。</li></ul></li><li><strong>网桥（Bridge）</strong>：<ul><li><strong>作用</strong>：网桥用于连接不同的局域网，能够根据MAC地址转发数据帧，从而分割流量，提高网络效率。网桥工作在数据链路层。</li></ul></li><li><strong>以太网交换机（Switch）</strong>：<ul><li><strong>作用</strong>：以太网交换机可以通过MAC地址来转发数据包，只将数据包发送到目标设备所在的端口，相比集线器，它能有效减少网络冲突并提高网络效率。它工作在数据链路层，具有一定的智能，能动态学习和维护MAC地址表。</li></ul></li></ol><h1>网络层</h1><h2 id="4-1基本术语">4.1基本术语</h2><p><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</p><p><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</p><p><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</p><p><strong>ICMP（Internet Control Message Protocol ）</strong>：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</p><p><strong>子网掩码（subnet mask ）</strong>：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p><p><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</p><p><strong>默认路由（default route）</strong>：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</p><p><strong>路由选择算法（Virtual Circuit）</strong>：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</p><h2 id="4-2重要知识总结">4.2重要知识总结</h2><p><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责</strong></p><p>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</p><p>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</p><p>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</p><p><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组</strong></p><p>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法在 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</p><p>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><p><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</p><p><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></p><p>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</p><h1>传输层</h1><h2 id="5-1基本术语">5.1基本术语</h2><p><strong>进程（process）</strong>：指计算机中正在运行的程序实体。</p><p><strong>应用进程互相通信</strong>：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</p><p><strong>传输层的复用与分用</strong>：复用指发送方不同的进程都可以通过同一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</p><p><strong>TCP（Transmission Control Protocol）</strong>：传输控制协议。</p><p><strong>UDP（User Datagram Protocol）</strong>：用户数据报协议</p><p><img src="https://oss.javaguide.cn/p3-juejin/b136e69e0b9b426782f77623dcf098bd~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>端口（port）</strong>：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</p><p><strong>停止等待协议（stop-and-wait）</strong>：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</p><p><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p><p><strong>拥塞控制</strong>：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p><h2 id="5-2重要知识点总结">5.2重要知识点总结</h2><p><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></p><p><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></p><p>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供<strong>面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p><p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</p><p>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</p><p>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</p><p><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></p><p><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></p><p><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一地被通信两端的两个端点所确定。</strong></p><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p>TCP 报文段的前 20 个字节是固定的，其后有 40 字节长度的可选字段。如果加入可选字段后首部长度不是 4 的整数倍字节，需要在再在之后用 0 填充。因此，TCP 首部的长度取值为 20+4n 字节,最长为 60 字节。</p><p><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></p><ol><li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li><li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li><li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li><li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li><li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li></ol><h2 id="5-3补充重要知识">5.3补充重要知识</h2><p>端口和套接字的意义</p><p><strong>端口</strong>：端口是网络协议（如 TCP 或 UDP）中用于标识特定应用进程的数字。端口通常在 0 到 65535 之间，分为不同的范围：</p><p><strong>知名端口（0-1023）</strong>：通常分配给常见的服务（例如 HTTP 用端口 80，HTTPS 用端口 443）。</p><p><strong>注册端口（1024-49151）</strong>：用于不太常见的应用程序和服务。</p><p><strong>动态或私有端口（49152-65535）</strong>：通常由操作系统分配给临时连接。</p><p><strong>套接字</strong>：套接字（Socket）是操作系统提供的一种接口，用于实现进程间的网络通信。它是通过 IP 地址和端口号的组合来唯一标识网络中的一个通信端点。可以通过套接字在应用程序间建立通信，支持 TCP 或 UDP 协议。</p><p>tcp和udp的区别</p><p><strong>TCP（Transmission Control Protocol）</strong>：</p><ul><li><strong>可靠性</strong>：TCP 是面向连接的协议，确保数据按顺序到达，且不会丢失。如果丢包，TCP 会进行重传。</li><li><strong>流量控制</strong>：TCP 使用流量控制（滑动窗口）来避免发送方过快地发送数据，超出了接收方的处理能力。</li><li><strong>拥塞控制</strong>：TCP 会根据网络的负载情况动态调整数据传输速度，以避免网络拥塞。</li><li><strong>连接管理</strong>：需要在通信前建立连接（三次握手），通信结束后需要关闭连接（四次挥手）。</li></ul><p><strong>UDP（User Datagram Protocol）</strong>：</p><ul><li><strong>不可靠性</strong>：UDP 是无连接的协议，不保证数据的可靠到达。数据包可能会丢失、重复或乱序。</li><li><strong>无流量控制和拥塞控制</strong>：UDP 不会进行流量控制或拥塞控制，发送数据时不考虑接收方的处理能力。</li><li><strong>轻量级</strong>：由于其无连接、简单的特性，UDP 的开销较小，适合实时传输等对时延要求高的应用。</li></ul><p>应用场景：</p><p><strong>TCP</strong>：</p><ul><li>适用于需要高可靠性、顺序传输的场景，比如文件传输（FTP）、网页浏览（HTTP/HTTPS）、电子邮件等。</li></ul><p><strong>UDP</strong>：</p><ul><li>适用于对时延要求高、容忍数据丢失的场景，比如视频会议、VoIP（语音通信）、在线游戏等。</li></ul><p>在不可靠网络上实现可靠传输的技术</p><p>在不可靠的网络上实现可靠传输，通常依赖于<strong>自动重传请求（ARQ）协议</strong>和<strong>确认机制</strong>。TCP 就是通过 ARQ 协议来实现数据的可靠传输。</p><ul><li><strong>ARQ 协议</strong>：通过发送方和接收方之间的确认消息（ACK）来确保数据的正确传输。如果接收方未能成功接收到数据，发送方会重新发送数据。</li><li><strong>停止等待协议</strong>：发送方发送一个数据包后，等待接收方的确认消息（ACK）。如果收到确认，则继续发送下一个数据包。如果超时未收到确认，重新发送该数据包。</li><li><strong>滑动窗口协议</strong>：相比停止等待协议，滑动窗口协议允许发送方在等待确认的同时继续发送多个数据包，提高了传输效率。</li></ul><p><strong>tcp的三次握手和三次挥手</strong></p><p><strong>三次握手</strong>：用来建立 TCP 连接，确保双方都准备好进行数据传输：</p><ol><li>客户端发送 SYN 请求，表示希望建立连接。</li><li>服务器回复 SYN-ACK，表示同意建立连接。</li><li>客户端发送 ACK 确认，连接建立成功。</li></ol><p><strong>四次挥手</strong>：用来关闭连接，确保双方都完成数据的传输后才断开连接：</p><ol><li>客户端发送 FIN 请求，表示数据发送完毕，准备关闭连接。</li><li>服务器回复 ACK，确认收到客户端的关闭请求。</li><li>服务器发送 FIN 请求，表示服务器也准备关闭连接。</li><li>客户端回复 ACK，连接正式关闭。</li></ol><h1>应用层</h1><h2 id="6-1基本术语">6.1基本术语</h2><p><strong>域名系统（DNS）</strong>：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</p><p>说明白了就是一个解析的过程</p><p><strong>文件传输协议（FTP）</strong>：FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：“下载”（Download）和&quot;上传&quot;（Upload）。 &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p><p><strong>简单文件传输协议（TFTP）</strong>：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</p><p><strong>远程终端协议（TELNET）</strong>：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</p><p><strong>万维网（WWW）</strong>：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“‘W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</p><p><strong>统一资源定位符（URL）</strong>：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p><strong>超文本传输协议（HTTP）</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</p><p><img src="https://oss.javaguide.cn/p3-juejin/8e3efca026654874bde8be88c96e1783~tplv-k3u1fbpfcp-zoom-1.jpeg" alt=""></p><p><strong>代理服务器（Proxy Server）</strong>：代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</p><p><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</p><p><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</p><p><strong>垂直搜索引擎</strong>：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</p><p><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</p><p><strong>目录索引</strong>：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</p><h2 id="6-2重要知识点总结">6.2重要知识点总结</h2><p>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</p><p>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</p><p>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</p><p>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</p><h2 id="6-3补充重要知识">6.3补充重要知识</h2><p>常见的http方法</p><p><strong>GET</strong>：请求服务器返回指定的资源（例如网页）。</p><p><strong>POST</strong>：向服务器提交数据（例如表单数据）。</p><p><strong>PUT</strong>：更新资源。</p><p><strong>DELETE</strong>：删除资源。</p><p>http状态码</p><p><strong>2xx</strong>：成功，例如 200 OK 表示请求成功。</p><p><strong>3xx</strong>：重定向，例如 301 Moved Permanently 表示资源已永久移动。</p><p><strong>4xx</strong>：客户端错误，例如 404 Not Found 表示请求的资源不存在。</p><p><strong>5xx</strong>：服务器错误，例如 500 Internal Server Error 表示服务器发生错误。</p><p>https和http的区别</p><p>HTTPS 在 HTTP 上加入了 SSL/TLS 协议，通过加密保护数据的机密性和完整性，防止中间人攻击。</p><p>dns工作流程：</p><p><strong>用户输入网址</strong>：当你在浏览器中输入一个 URL（如 <code>www.example.com</code>）时，浏览器首先需要通过 DNS 查找这个域名对应的 IP 地址。</p><p><strong>查询 DNS 服务器</strong>：</p><ul><li><strong>本地缓存</strong>：浏览器或操作系统首先查看是否缓存了该域名的 IP 地址。如果有缓存且未过期，直接使用缓存的地址。</li><li><strong>递归查询</strong>：如果没有缓存，DNS 客户端向 DNS 服务器发送查询请求。DNS 服务器将从根服务器、顶级域名服务器、权威域名服务器层层查询，直到找到该域名的对应 IP 地址。</li></ul><p><strong>返回 IP 地址</strong>：一旦找到，DNS 服务器将域名对应的 IP 地址返回给浏览器。</p><p><strong>建立连接</strong>：浏览器使用获取到的 IP 地址向目标服务器发起 HTTP 请求，开始页面加载过程。</p><p>访问一个网站的过程：</p><p><strong>输入网址</strong>：用户在浏览器中输入 URL（如 <code>https://www.example.com</code>）。</p><p><strong>DNS 解析</strong>：浏览器通过 DNS 将域名解析为对应的 IP 地址。</p><p><strong>TCP 连接建立</strong>：</p><ul><li>浏览器通过 TCP 协议与服务器建立连接，使用三次握手完成连接建立（对于 HTTPS，还涉及到 TLS 握手以确保数据安全性）。</li></ul><p><strong>发送 HTTP 请求</strong>：浏览器向服务器发送 HTTP 请求，获取网页资源（如 HTML、CSS、JavaScript、图片等）。</p><p><strong>服务器响应</strong>：服务器处理请求后返回 HTTP 响应，包括网页的 HTML 内容和其他相关资源。</p><p><strong>渲染页面</strong>：浏览器接收到响应后，解析并渲染网页，显示给用户。</p><p><strong>关闭连接</strong>：HTTP/1.1 使用持久连接（通过 <code>Connection: keep-alive</code>），但最终浏览器会关闭与服务器的 TCP 连接。</p><h1>其他层次</h1><p>除了常见的OSI七层体系结构外，还有tcp/ip四层协议和tcp/ip五层协议</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-7490-20150904094019903-1923900106.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-8668-20150904095142060-1017190812.gif" alt=""></p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/13/net1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown语法</title>
      <link>https://blog.tokenlen.top/2025/01/12/markdown1/</link>
      <guid>https://blog.tokenlen.top/2025/01/12/markdown1/</guid>
      <pubDate>Sat, 11 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;Markdown是啥&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种轻量级&lt;strong&gt;标记语言&lt;/strong&gt;，它以纯文本形式(&lt;em&gt;易读、易写、易更改&lt;/em&gt;)编写文档，并最终以HTML格式发布。&lt;br&gt;
&lt;strong&gt;Markdo</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>Markdown是啥</h1><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。</p><h1>语法</h1><h2 id="标题">标题</h2><p>用=和-来标记一级和二级标题</p><p>一级</p><p>二级</p><hr><p>#一级</p><p>##二级</p><p>###三级</p><h2 id="段落">段落</h2><ul><li>可以用&gt; &gt;&gt; &gt;&gt;&gt;或者是-</li><li></li></ul><p>代码快就在每行加上四个空格或者一个制表符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="强调">强调</h2><p>使用<em>啊</em>  *</p><p>或者是_fff_    -</p><p>·呆呆·  ··使用这个</p><h2 id="列表">列表</h2><p>使用-</p><ul><li></li></ul><p>或者是直接使用符号</p><h2 id="分割线">分割线</h2><p>直接使用三个—</p><hr><h2 id="链接">链接</h2><p>【】（）</p><p>然后图片就是</p><p>！【】（）</p><p>注意是英文的符号好吧</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/Markdown/">Markdown</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/markdown/">markdown</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/12/markdown1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql练习 寒假篇</title>
      <link>https://blog.tokenlen.top/2025/01/10/sqltest3/</link>
      <guid>https://blog.tokenlen.top/2025/01/10/sqltest3/</guid>
      <pubDate>Thu, 09 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础语法回顾&lt;/h1&gt;
&lt;h2 id=&quot;1-SQL110-插入记录（一）&quot;&gt;1.&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础语法回顾</h1><h2 id="1-SQL110-插入记录（一）">1.<a href="https://www.nowcoder.com/practice/5d2a42bfaa134479afb9fffd9eee970c?tpId=240&amp;tqId=2221797&amp;ru=/exam/oj&amp;qru=/ta/sql-advanced/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page"><strong>SQL110</strong> <strong>插入记录（一）</strong></a></h2><p>牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下：</p><ul><li>用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分；</li><li>用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。</li></ul><p>试卷作答记录表exam_record中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Extra</th><th>Default</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>auto_increment</td><td>(NULL)</td><td>自增ID</td></tr><tr><td>uid</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>用户ID</td></tr><tr><td>exam_id</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>试卷ID</td></tr><tr><td>start_time</td><td>datetime</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>开始时间</td></tr><tr><td>submit_time</td><td>datetime</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>提交时间</td></tr><tr><td>score</td><td>tinyint(4)</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>得分</td></tr></tbody></table><p>该题最后会通过执行SELECT uid, exam_id, start_time, submit_time, score FROM exam_record;来对比结果</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into exam_record(uid,exam_id,start_time,submit_time,score) </span><br><span class="line">VALUES (1001,9001,&#x27;2021-09-01 22:11:12&#x27;,&#x27;2021-09-01 23:01:12&#x27; ,90),</span><br><span class="line">(1002,9002,&#x27;2021-09-04 07:01:02&#x27;,null,NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照顺序插入即可，注意一一对应</p><ol start="2"><li></li></ol><p>牛客的运营同学想要查看大家在SQL类别中高难度试卷的得分情况。</p><p>请你帮她从exam_record数据表中计算所有用户完成SQL类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p><p>示例数据：examination_info（exam_id试卷ID, tag试卷类别, difficulty试卷难度, duration考试时长, release_time发布时间）</p><table><thead><tr><th>id</th><th>exam_id</th><th>tag</th><th>difficulty</th><th>duration</th><th>release_time</th></tr></thead><tbody><tr><td>1</td><td>9001</td><td>SQL</td><td>hard</td><td>60</td><td>2020-01-01 10:00:00</td></tr><tr><td>2</td><td>9002</td><td>算法</td><td>medium</td><td>80</td><td>2020-08-02 10:00:00</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">示例数据：exam_record（uid用户ID, exam_id试卷ID, start_time开始作答时间, submit_time交卷时间, score得分）iduidexam_idstart_timesubmit_time</span><br><span class="line">score1100190012020-01-02 09:01:012020-01-02 09:21:01</span><br><span class="line">8021001</span><br><span class="line">9001</span><br><span class="line">2021-05-02 10:01:012021-05-02 10:30:01</span><br><span class="line">81310019001</span><br><span class="line">2021-06-02 19:01:01</span><br><span class="line">2021-06-02 19:31:01</span><br><span class="line">84</span><br><span class="line">410019002</span><br><span class="line">2021-09-05 19:01:01</span><br><span class="line">2021-09-05 19:40:0189</span><br><span class="line">51001</span><br><span class="line">90012021-09-02 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">61001</span><br><span class="line">9002</span><br><span class="line">2021-09-01 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">710029002</span><br><span class="line">2021-02-02 19:01:01</span><br><span class="line">2021-02-02 19:30:01</span><br><span class="line">87810029001</span><br><span class="line">2021-05-05 18:01:01</span><br><span class="line">2021-05-05 18:59:02909</span><br><span class="line">10039001</span><br><span class="line">2021-09-07 12:01:01</span><br><span class="line">2021-09-07 10:31:01</span><br><span class="line">501010049001</span><br><span class="line">2021-09-06 10:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br></pre></td></tr></table></figure><p>根据输入你的查询结果如下：</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT tag, difficulty,</span><br><span class="line">    ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br><span class="line">FROM exam_record</span><br><span class="line">JOIN examination_info USING(exam_id)</span><br><span class="line">WHERE tag = &#x27;SQL&#x27; AND difficulty = &#x27;hard&#x27;</span><br><span class="line">GROUP BY tag, difficulty;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据sql查询的分别出现的列，然后来根据这些列来写</p><p>主要是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br></pre></td></tr></table></figure><p>这个保留一位小数，计算平均数</p><p>然后使用联合查询</p><p>将examination_info和exam_record连接起来，其主键是exam_id</p><p>然后where条件</p><p>最后可以来个按组排序</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/10/sqltest3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English一月篇</title>
      <link>https://blog.tokenlen.top/2025/01/01/en5/</link>
      <guid>https://blog.tokenlen.top/2025/01/01/en5/</guid>
      <pubDate>Tue, 31 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;每日一话+单词遗忘表1.1&lt;/h1&gt;
&lt;p&gt;A New Year is like a blank book, and the pen is in your hands. Go write yourself a beautiful</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>每日一话+单词遗忘表1.1</h1><p>A New Year is like a blank book, and the pen is in your hands. Go write yourself a beautiful story.</p><ul><li>masterpiece 杰作</li><li>mate 匹配</li><li>mature 成年人的</li><li>meantime 其间</li><li>measure 措施</li><li>mechanic 技工</li><li>medal 奖章</li></ul><h1>每日一话+单词遗忘表1.2</h1><p>There is more day to dawn. The sun is but a morning star.</p><ul><li>medicine 药</li><li>melon 瓜</li><li>melt 融化</li><li>memoorandum 信函</li><li>memorial 纪念物</li><li>merchant 商人</li><li>mercy 仁慈</li><li>mere 仅仅</li><li>merit 优点</li><li>microscope 显微镜</li><li>microwave 微波</li><li>marsh 沼泽</li></ul><h1>每日一话+单词遗忘表1.3</h1><p>Not everything that is faced can be changed, but nothing can be changed until it is faced.</p><ul><li>asset 资产</li><li>migrate 移动</li><li>mild 温和的</li><li>military 军事的</li><li>mill 磨坊</li><li>minor 较小的</li><li>minus 减去</li><li>miracle 奇迹</li><li>miserable 悲惨的</li><li>mist 薄雾</li><li></li></ul><h1>每日一话+单词遗忘表1.8</h1><p>They always say time changes things, but you actually have to change them yourself.</p><ul><li>mistress 情妇</li><li>misunderstand 误解</li><li>moderate 适当的</li><li>modify 修改</li><li>moist 潮湿的</li><li>monument 纪念碑</li><li>mop 擦干</li><li>mortgage 抵押</li></ul><h1>每日一话+单词遗忘表1.10</h1><p>Curious things, habits. People themselves never knew they had them.</p><ul><li>motel 汽车旅馆</li><li>motion 动作</li><li>mud 泥浆</li><li>mug 脸</li><li>mule 骡子</li><li>municipal 市政的</li><li>murder 谋杀</li><li>muscle 肌肉</li><li>mushroom 蘑菇</li><li>exterior 外部的</li></ul><h1>每日一话+单词遗忘表1.11</h1><p>While the blanket is short, learn how to bend.</p><ul><li>nyth 神话</li><li>nail 钉子</li><li>naked 裸体的</li><li>namely 即是</li><li>nap 小睡</li><li>napkin 纸巾</li><li><strong>narrate</strong> 叙述</li><li>nasty 下流的</li><li>naughty 调皮的</li><li>navy 海军</li><li>neat 整洁的</li><li>negate 否定</li><li>neglect 疏忽</li></ul><h1>每日一话+单词遗忘表1.13</h1><p>The world is little, people are little, human life is little. There is only one big thing – desire.</p><ul><li>nephew 侄子</li><li>nevertheless 仍然</li><li>niece 外甥女</li><li>nonsense 废话</li></ul><h1>每日一话+单词遗忘表1.25</h1><p>Habit is habit, and not to be flung out of the window by any man, but coaxed downstairs a step a time.</p><ul><li>norm 规范</li><li>massage 按摩</li><li><strong>nourish</strong> 滋养</li><li>nude 裸体的</li><li>nuisance 讨厌的东西</li><li>numerous 许多的</li><li>nurse 看护</li><li>nursery 托儿所</li><li>nut 坚果</li><li>negate 否定的</li></ul><h1>每日一话+单词遗忘表1.26</h1><p>You cannot find peace by avoiding life.</p><ul><li>nutrition 营养</li><li><strong>obese</strong> 肥胖的</li><li>obey 服从</li><li>oblige 强制的</li><li>obstacle 障碍</li><li>obtain 获得</li><li>municipal 市政的</li><li>obvious 显而易见的</li><li><strong>occasiion</strong> 场合</li><li>occupation 工作</li><li>occupy 占领</li><li><strong>occur</strong> 发生</li><li>odor 气味</li><li><strong>offend</strong> 冒犯</li><li>liable 易患的</li></ul><h1>每日一话+单词列表1.27</h1><p>Have no fear of perfection ---- you’ll never reach it.</p><ul><li>occasion 场合</li><li>omit 省略</li><li>ongoing 前进的</li><li>onward 向前的</li><li>opera 歌剧</li><li>operate 运转</li><li>opposite 相反的</li><li>oral 口头的</li><li>orbit 轨道</li><li>orchestra 管弦乐队</li><li>gamble 赌博</li><li></li></ul><h1>每日一话+单词遗忘表1.28</h1><p>May your new year be filled with abundance of smiles and happiness!</p><p>新的一年，祝大家新年快乐哈哈哈哈</p><ul><li>geometry 几何学</li><li>ore 矿</li><li>organ 器官</li><li>organic 有机的</li><li>organism 有机体</li><li>orient 确定方向  东方</li><li>ornament 装饰</li><li>orphan 孤儿</li><li>ought to 应该</li><li>ounce 盎司</li><li>outlet 出口</li><li>outline 轮廓</li><li>orchestra 管弦乐队</li><li>giant 巨大的</li></ul><h1>每日一话+单词遗忘表1.29</h1><p>As the new sun rises in a brand new year may it bring you good luck, prosperity, joy, and contentment.</p><ul><li>outset 开端</li><li>outskirts 郊区</li><li>oval 椭圆的</li><li>oven 烤箱</li><li>overcoat 大衣</li><li>overdue 迟到的</li><li>noun 名词</li><li>overthrow 打到</li><li>overwhelm 淹没</li><li>oxygen 氧气</li><li>ozone 臭氧</li><li>pace 步速</li></ul><h1>每日一话+单词遗忘表1.30</h1><p>To realize the value of one minute, ask the traveler who has just missed his train.</p><ul><li>pad 护具</li><li>paint 油漆</li><li>palace 宫殿</li><li>pale 苍白的</li><li>palm 手掌</li><li>parade 游行</li><li>paralel 平行线</li><li>parcel 包裹</li><li>pardon 原谅</li><li>particle 颗粒</li></ul><h1>每日一话+单词遗忘表1.31</h1><p>Children have more need of models than of critics.</p><ul><li>pastime 娱乐</li><li>patch 小片</li><li>patent 专利</li><li>pause 暂停</li><li>pave 铺设</li><li>pea 豌豆</li><li>peanut 花生</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/01/en5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构期末复习</title>
      <link>https://blog.tokenlen.top/2024/12/16/data7/</link>
      <guid>https://blog.tokenlen.top/2024/12/16/data7/</guid>
      <pubDate>Sun, 15 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;名词解析&lt;/h1&gt;
&lt;h3</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>名词解析</h1><h3 id="1、逻辑结构和存储结构">1、逻辑结构和存储结构</h3><ul><li><strong>逻辑结构</strong>：指的是<strong>数据元素</strong>之间的<strong>相互关系和组织方式</strong>，描述数据元素之间如何连接、关联。常见的逻辑结构有线性结构（如数组、链表）、树形结构（如二叉树）、图形结构等。</li><li><strong>存储结构</strong>：指的是数据在<strong>计算机内存中具体的存储方式</strong>，是实现逻辑结构的具体方式。常见的存储 结构有顺序存储（如数组）、链式存储（如链表）等。</li></ul><h3 id="2、稳定的排序方法和不稳定的排序方法">2、稳定的排序方法和不稳定的排序方法</h3><ul><li><strong>稳定的排序方法</strong>：在排序过程中，相等的元素在排序后相对位置不变。例如，冒泡排序、插入排序、归并排序。</li><li><strong>不稳定的排序方法</strong>：在排序过程中，相等的元素在排序后相对位置可能发生改变。例如，快速排序、选择排序、堆排序。</li></ul><h3 id="3-完全二叉树">3.完全二叉树</h3><ul><li><strong>完全二叉树</strong>：是一种特殊的二叉树，除了最底层外，其余每一层的节点数都达到最大，并且最底层的节点从左到右排列。完全二叉树的节点编号是按照从上到下、从左到右的顺序编号的。</li></ul><h3 id="4-什么是关键路径？什么是关键活动？">4.什么是关键路径？什么是关键活动？</h3><ul><li><strong>关键路径</strong>：在项目管理中，关键路径是指从<strong>项目开始</strong>到<strong>项目结束</strong>的<strong>所有任务所组成的路径</strong>，这条路径上的每个任务都不能延误，否则整个项目的完成时间将延长。关键路径上的活动即为<strong>关键活动</strong>。</li><li><strong>关键活动</strong>：指在项目中，任何延误都将直接影响项目总工期的活动。它们位于关键路径上，是项目中最重要的活动。</li></ul><h3 id="5-什么是前缀编码？哈夫曼编码为什么是前缀编码？">5.什么是前缀编码？哈夫曼编码为什么是前缀编码？</h3><ul><li><strong>前缀编码</strong>：是一种编码方式，<strong>任何一个编码都不是另一个编码的前缀。即没有任何一个编码是另一个编码的开头部分</strong>。常见的前缀编码有哈夫曼编码。</li><li><strong>哈夫曼编码是前缀编码</strong>：因为在哈夫曼编码中，编码的构造保证了<strong>任何一个字符的编码都不可能是另一个字符编码的前缀</strong>，因此满足前缀编码的性质。哈夫曼编码通过使用<strong>变长的编码</strong>，使得<strong>频繁出现</strong>的字符用<strong>短的编码表示</strong>，而不常见的字符用长的编码表示，从而提高了编码效率。</li></ul><h3 id="6-什么是数据结构？常见的数据结构类型有哪些？">6.什么是数据结构？常见的数据结构类型有哪些？</h3><ul><li><strong>数据结构</strong>：是计算机中<strong>存储、组织数据</strong>的方式，它定义了数据元素之间的<strong>关系</strong>以及<strong>存取数据</strong>的方法。数据结构是实现算法的<strong>基础</strong>，它影响程序的执行效率和资源使用。</li><li>常见的数据结构类型:<ol><li><strong>线性数据结构</strong>：如数组、链表、栈、队列。</li><li><strong>树形数据结构</strong>：如二叉树、AVL树、红黑树、B树、堆。</li><li><strong>图形数据结构</strong>：如无向图、有向图、加权图、邻接矩阵、邻接表。</li><li><strong>哈希表</strong>：通过哈希函数实现高效的查找和插入。</li><li><strong>集合与映射</strong>：如集合、字典、集合运算等。</li></ol></li></ul><h3 id="其他基础名词">其他基础名词</h3><ol><li><strong>线性表</strong>：由若干数据元素构成的<strong>集合</strong>，其中的元素之间存在<strong>一对一</strong>的关系。常见的线性表有数组、链表、栈、队列等。</li><li><strong>栈</strong>：一种<strong>线性数据</strong>结构，遵循<strong>后进先出</strong>（LIFO）原则，只有一个端口可以插入和删除元素。</li><li><strong>队列</strong>：一种<strong>线性数据</strong>结构，遵循<strong>先进先出</strong>（FIFO）原则，元素从队尾插入，从队头删除。</li><li><strong>数组</strong>：一种<strong>线性数据</strong>结构，通过<strong>连续的内存单元存储相同类型的数据元素</strong>，可以通过索引进行访问。</li><li><strong>链表</strong>：一种<strong>线性数据</strong>结构，元素通过指针连接，每个元素包含<strong>数据</strong>和<strong>指向下一个元素的指针</strong>。</li><li><strong>双向链表</strong>：一种<strong>链表结构</strong>，除了每个元素指向下一个元素的指针外，还包含指向前一个元素的指针。</li><li><strong>树</strong>：由<strong>若干个节点</strong>组成的非线性数据结构，节点之间有<strong>父子关系</strong>。</li><li><strong>二叉树</strong>：每个节点最多有两个子节点的树。</li><li><strong>二叉搜索树</strong>：一种特殊的二叉树，<strong>左子树的值小于根节点的值</strong>，<strong>右子树的值大于根节点的值</strong>。</li><li><strong>平衡二叉树</strong>：一种特殊的二叉树，**任何节点的左右子树的高度差不超过1。**时间复杂度为 O(log n)</li><li><strong>哈希表</strong>：通过<strong>哈希函数</strong>将<strong>键值</strong>映射到一个位置，常用于实现高效的查找、插入操作。</li><li><strong>图</strong>：由<strong>顶点</strong>和<strong>边</strong>组成的数据结构，边表示顶点之间的关系。一般用数字表示。</li><li><strong>邻接矩阵</strong>：一种表示图的方式，使用二维数组表示顶点之间的连接关系。</li><li><strong>邻接表</strong>：另一种表示图的方式，使用链表或动态数组表示每个顶点的邻接节点。</li><li><strong>深度优先搜索（DFS）</strong>：一种图的遍历方法，优先访问<strong>深层节点</strong>，直到没有未访问的邻接节点时返回。</li><li><strong>广度优先搜索（BFS）</strong>：一种图的遍历方法，优先访问<strong>浅层节点</strong>，逐层遍历图的节点。</li><li><strong>递归</strong>：一种函数调用<strong>自身</strong>的编程方式，通常用于解决可以分解为更小规模相同问题的任务。</li><li><strong>动态数组</strong>：一种数组类型，具有可变大小的特性，支持动态扩展</li><li><strong>堆</strong>：一种完全二叉树结构，用于实现优先队列。最大堆或最小堆根据优先级决定元素的排列。</li><li><strong>动态规划</strong>：一种将复杂问题分解成<strong>小问题</strong>，<strong>解决小问题并存储其解</strong>，最后合成<strong>大问题解</strong>的算法设计方法。</li><li><strong>迭代</strong>：通过<strong>循环结构</strong>逐步逼近目标结果的方法，适用于不需要递归的场景。</li><li><strong>并查集</strong>：一种用于<strong>处理不相交集合合并</strong>和<strong>查询</strong>的问题的数据结构。支持两种操作：<strong>查找</strong>（判断两个元素是否属于同一集合）和 <strong>合并</strong>（将两个集合合并成一个）。<ul><li><strong>路径压缩</strong>：优化查找操作，减少树的高度。</li><li><strong>按秩合并</strong>：优化合并操作，避免形成过高的树</li></ul></li><li><strong>哈希冲突</strong>：当<strong>两个不同的键值</strong>通过哈希函数映射到<strong>相同的位置时</strong>，称为哈希冲突。常见的解决方法有链式法和开放地址法。<ul><li><strong>链式法</strong>：使用链表来解决冲突，多个元素可以存储在同一个位置。</li><li><strong>开放地址法</strong>：当发生冲突时，寻找下一个空闲位置进行插入。</li></ul></li><li><strong>红黑树</strong>：一种自平衡的二叉搜索树，具有更多的约束条件，能够保证最坏情况下的 O(log n) 查找、插入和删除操作。</li><li><strong>时间复杂度</strong>：衡量<strong>算法执行时间</strong>随输入<strong>规模变化的增长率</strong>。常用的时间复杂度有 O(1)、O(log n)、O(n)、O(n log n)、O(n²) 等。</li><li><strong>空间复杂度</strong>：衡量算法<strong>所需空间随输入规模变化</strong>的增长率</li><li><strong>最小生成树</strong><ul><li><strong>Prim算法</strong>：从一个点开始逐步加入最小的边，直到包含所有点。</li><li><strong>Kruskal算法</strong>：从最小的边开始逐步加入，不形成环，直到生成树完整。</li></ul></li><li>常见排序算法：<ul><li><strong>冒泡排序</strong>：O(n^2)</li><li><strong>选择排序</strong>：O(n^2)</li><li><strong>插入排序</strong>：O(n^2)</li><li><strong>归并排序</strong>：O(n log n)</li><li><strong>快速排序</strong>：O(n log n)（平均）</li><li><strong>堆排序</strong>：O(n log n)</li></ul></li><li>图的存储方式<ul><li><strong>邻接矩阵</strong>：适用于稠密图。</li><li><strong>邻接表</strong>：适用于稀疏图。</li></ul></li><li>线索二叉树是对二叉树的一个改进，用来避免在遍历时使用栈或递归，使用线索指针替代空指针。</li><li></li></ol><h3 id="图片展示">图片展示</h3><p><img src="https://qcdn.itcharge.cn/images/20220218173007.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20220218174000.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20220221103552.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20240511171423.png" alt=""></p><h1>简答</h1><h2 id="队列计算">队列计算</h2><p>队列的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length=(r-f+m)%m</span><br></pre></td></tr></table></figure><p>队满的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(r+1)%m == f</span><br></pre></td></tr></table></figure><p>队列不满的时候入队</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r=(r+1)%m</span><br></pre></td></tr></table></figure><p>队空的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f == r</span><br></pre></td></tr></table></figure><p>队列不为空时出队</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = (f+1)%m</span><br></pre></td></tr></table></figure><ul><li>r 是队尾指针</li><li>f 是队头指针</li><li>m 是队列的最大容量</li></ul><h2 id="广义表计算">广义表计算</h2><p>广义表的表长是指广义表中<strong>直接包含</strong>的元素个数，而这些元素可以是原子（如 <code>a</code>、<code>b</code>）或者子表。注意是直接包含</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LS = (a, b, c), (d, e, f)</span><br></pre></td></tr></table></figure><p>上面LS的表长即为<strong>2</strong></p><p>广义表的提取：</p><p>下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(tail(tail(head(LS))))</span><br></pre></td></tr></table></figure><p>即结果为元素<strong>c</strong></p><p>就是先分析里面的，然后一层一层的套，<strong>最后只剩下一个了得head取出</strong></p><p>例如：</p><p>取出元素e</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(tail(head(tail(LS)))) = e</span><br></pre></td></tr></table></figure><h2 id="树的计算">树的计算</h2><p>对于完全二叉树来说，<strong>n</strong>为总节点树，[x]为向上取整</p><p>叶子节点的数量L</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L=[n/2]</span><br></pre></td></tr></table></figure><p>对于完全二叉树，除了最后一层外，其他层的结点都是满的，所以大部分叶子结点都在最后一层或倒数第二层。</p><p>树的深度：</p><p>是指从根结点到最深叶子结点的路径长度，对于完全二叉树则<strong>深度d</strong>为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d=⌈log2(n)⌉</span><br></pre></td></tr></table></figure><p>完全二叉树的深度为 <code>d</code>，则结点数 <code>n</code> 满足：<br>$$<br>2^{d-1} \leq n \leq 2^d - 1<br>$$</p><ul><li>一个完全二叉树的最小结点数发生在只有根节点的情况下，深度为 d<em>d</em> 的完全二叉树的最小结点数是 2d−12<em>d</em>−1。</li><li>完全二叉树的最大结点数是满二叉树的结点数，即 2d−12<em>d</em>−1。</li></ul><p>非叶子结点的个数可以通过以下公式计算：</p><p>$$<br>N_{non-leaf} = n - L<br>$$</p><h2 id="图的计算">图的计算</h2><p>完全图的边和顶点的关系，假设m条边和n个顶点，图的边数为<br>$$<br>m= n(n−1)/2<br>$$<br>非连通无向图考虑<strong>至少</strong>顶点数的情况下，该图由两个子图构成，一个是完全图一个是只有一个顶点，所以如果边数为28的话，最后至少<strong>9</strong>个顶点。</p><p>那我们接下来来考虑<strong>至多</strong>的情况</p><p>对于非连通无向图，最多顶点数的情况是图中每个连通分量都为一个孤立的顶点，即每个顶点都没有边。但是题目限定了28条边，那我们就每个连通分量都拥有尽可能少的边数，也就是两个顶点一条边。边数为28的话，那么顶点数就是<strong>56</strong>。所以至多顶点数为<strong>56</strong></p><h2 id="时间复杂度分析">时间复杂度分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 0;</span><br><span class="line">for(i = l; i &lt; n; i++)</span><br><span class="line">  for(j = l; j &lt;= n - i; j++)</span><br><span class="line">    x++;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度为<strong>O(n^2)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = -l;</span><br><span class="line">for(j = l; j &lt;= n; j++)</span><br><span class="line">  while(i &lt;= n)</span><br><span class="line">    i = i * 2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度为*<em>O(n <em>log n)</em></em></p><p><strong>在简单for循环中时间复杂度可以为</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外层时间复杂度*内层时间复杂度</span><br></pre></td></tr></table></figure><h2 id="数组计算">数组计算</h2><p>1、设有一个二维数组 A[m][n]按行优先顺序存储，假设 A[0][0]存放位置在<br>644(10)，A[2][2]存放位置在 676(10)，每个元素占一个字节的空间，问 A[3]<a href="10">3</a><br>存放在什么位置？脚注(10)表示用 10 进制表示。</p><p>元素 A[i][j]<em>A</em>[<em>i</em>][<em>j</em>] 的存储地址可以通过以下公式计算：<br>$$<br>地址(A[i][j])=地址(A[0][0])+(i×n+j)<br>$$</p><ul><li><em>i</em> 是行号，</li><li>j 是列号，</li><li><em>n</em> 是数组的列数，</li><li>地址(A[0][0])地址(<em>A</em>[0][0]) 是数组的起始位置。</li></ul><p>这样解出n=15然后获得a33的位置</p><h2 id="查找算法">查找算法</h2><h3 id="折半查找">折半查找</h3><p>在折半查找中，判定树是根据每次比较将序列分为两部分来进行的</p><p>假设我们有一个长度为 12 的序列，元素的下标从 1 到 12。</p><ul><li><p><strong>初始查找范围</strong>：整个序列，长度为 12，范围是从 1 到 12。</p></li><li><p>选择中间的元素。中间元素的下标是 <code>(1 + 12) / 2 = 6</code>，所以在第一次比较时，根结点的值是序列中的第 6 个元素。</p></li><li><p>如果要找的值比根结点的值小，查找范围变为 1 到 5。</p></li><li><p>如果要找的值比根结点的值大，查找范围变为 7 到 12。</p></li><li><p>如果查找范围是 7 到 12，那么新的中间元素下标为 <code>(7 + 12) / 2 = 9</code>。此时，根结点的右孩子的值对应的是序列中的第 9 个元素。</p></li></ul><p><strong>在折半查找中，若得到的中间元素位置是小数，则需要向下取整。</strong></p><p>孩子节点就是子节点</p><h1>真题练习</h1><h2 id="哈夫曼树的构建">哈夫曼树的构建</h2><p>已知下列字符 A、B、C、D、E、F、G 的权值分别为 3、12、7、4、<br>2、8，11，试填写出其对应哈夫曼树 HT 的存储结构的终态，完成表 1。<br>表 1 哈夫曼树 HT 的存储结构的终态<br>weight parent lchild rchild<br>1<br>2<br>3<br>4<br>5<br>6<br>7</p><p>因为哈夫曼树是从最小的节点一次累加最后聚合到根节点</p><p>所以把上面权按照大小顺序排列</p><p>【2,3,4,7,8,11,12】</p><p>然后按照大小顺序合并</p><p>第一次：[4,5,7,8,11,12]</p><p>第二次：[7,8,9,11,12]</p><p>第三次：[9,11,12,15]</p><p>第四次：[12,15,20]</p><p>第五次：[20,27]</p><p>第六次：[47]</p><p>所以最后的根节点就是47</p><p>所以最后得到的哈夫曼树就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                  (47)</span><br><span class="line">                /     \</span><br><span class="line">             (20)     (27)</span><br><span class="line">            /   \     /     \</span><br><span class="line">       (9)     (11) (12)   (15)</span><br><span class="line">      /  \           /   \</span><br><span class="line">   (4)    (5) (7)   (8) </span><br><span class="line">   /  \</span><br><span class="line">（2） (3)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>哈夫曼编码就是从根节点开始，往左走是0，往右走是1</p><p>所以权值为2的节点可以表示为0010,3可以表示为0011</p><p>然后分别按照出现的先后顺序填写好编号，再把节点的表填完</p><table><thead><tr><th>编号</th><th>weight</th><th>parent</th><th>lchild</th><th>rchild</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>1</th><th>2</th><th>8</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>2</th><th>3</th><th>8</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>3</th><th>4</th><th>9</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>4</th><th>7</th><th>9</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>5</th><th>8</th><th>10</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>6</th><th>11</th><th>10</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>7</th><th>12</th><th>11</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>8</th><th>5</th><th>9</th><th>1</th><th>2</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>9</th><th>9</th><th>12</th><th>3</th><th>4</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>10</th><th>15</th><th>12</th><th>5</th><th>6</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>11</th><th>20</th><th>13</th><th>7</th><th>8</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>27</th><th>13</th><th>9</th><th>10</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>13</th><th>47</th><th>-</th><th>11</th><th>12</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="图-网">图-网</h2><p>2、如下图所示的 AOE-网：<br>（1） 求这个工程最早可能在什么时间结束；<br>（2） 求每个活动的最早开始时间和最迟开始时间；<br>（3） 确定哪些活动是关键活动。</p><p>这个主要就是带权图的知识</p><p>设使用每个步骤所用的最早可能开始时间<strong>为e</strong>，所用的最迟可能开始时间<strong>为l</strong></p><p>当l-e=0的时候为关键活动。</p><h2 id="查找长度">查找长度</h2><p>设哈希函数 H（K）=3 K mod 11，哈希地址空间为 0～10，对关键字<br>序列（32，13，49，24，38，21，4，12），按链地址法（拉链法）构造哈希表，并<br>分别求出等概率下查找成功时和查找失败时的平均查找长度 ASLsucc 和<br>ASLunsucc。</p><p>其中mod11是指取余的意思</p><p>那么根据运算公式h(k)=3kmod11</p><p>h(32)=32*3mod11=8</p><p>h(13)=13*3mod11=6</p><p>h(49)=48*3mod11=4</p><p>h(24)=24*3mod11=6</p><p>h(38)=38*3mod11=3</p><p>h(21)=21*3mod11=8</p><p>h(4)=4*3mod11=1</p><p>h(12)=12*3mod11=3</p><p>所以链表的构造为</p><p>位置 data length</p><p>0 null</p><p>1 4 1</p><p>2 null</p><p>3 38-&gt;12 2</p><p>4 49 1</p><p>5 null</p><p>6 13-&gt;24 2</p><p>7 null</p><p>8 32-&gt;21 2</p><p>9 null</p><p>10 null</p><p>查找成功时的平均查找长度是所有成功查找的查找长度的平均值。每个位置的查找长度等于该位置链表的长度。假设每个位置的链表长度为 <code>L(i)</code>，则查找成功的平均查找长度为：<br>$$<br>ASLsucc=<br>成功查找次数<br>∑L(i)/成功查找次数<br>$$<br><strong>所以Aslsucc=8/8=1</strong></p><p>查找失败时的平均查找长度是所有失败查找的查找长度的平均值。查找失败时的查找长度是从位置 0 到位置 10 的每个位置的查找深度（即链表长度）。如果某个位置没有元素（空），则查找长度为 1。</p><p><strong>Aslunsucc=13/10=1.3</strong></p><p>设一组有序的记录关键字序列为(13，18，24，35，47，50，62，83，90)，查找方法用二分查找，要求计算出查找关键字62时的比较次数并计算出查找成功时的平均查找长度。</p><p>索引是从[0-8]所以中间元素是47，47&lt;62所以范围是[5-8]</p><p>中间元素正好是62</p><p>所以比较次数为<strong>2</strong><br>$$<br>ASL=</p><p>1×C<br>1<br>​<br>+2×C<br>2<br>​<br>+⋯+n×C<br>n/n<br>$$<br>最坏情况下，需要 log⁡2n\log_2 nlog2n 次比较（如果是成功查找）。对于这个数组，n=9n = 9n=9，所以最多需要 log⁡2 9≈3.17次比较，四舍五入就是 <strong>4</strong> 次比较。</p><p>对于数组长度 n=9n = 9n=9，各个元素成功查找时的比较次数：这个是需要四舍五入的</p><p>1个是1次，两个三个是2次，四个五个六个是3次，七个八个九个是4次<br>$$<br>ASL=</p><h1>（1+4+2+9+6+6+8+4+8）/9</h1><p>9/<br>48<br>​<br>≈2.67<br>$$</p><h2 id="二叉树的遍历和森林转换">二叉树的遍历和森林转换</h2><p>设一棵二叉树的先序序列： A B D F C E G H ，中序序列： B F D A<br>G E H C</p><p>先序遍历的顺序是 根-&gt;左-&gt;右；中序遍历的顺序是 左-&gt;根-&gt;右</p><p>后序遍历是左-&gt;右-&gt;根</p><p>根据先序遍历获得根节点A</p><p>已知先序遍历和后序遍历是不能唯一确定一颗二叉树的，但是其他序列的组合是可以的。也就是确定唯一的二叉树必须要有中序遍历</p><p>根据中序遍历，D在B的右边，所以D是B的右子树。同样的E在C的左边，所以E是C的左子树</p><p>所以还原出来的二叉树是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> /   \</span><br><span class="line">B     C</span><br><span class="line"> \     /</span><br><span class="line">  D   E</span><br><span class="line"> /   / \</span><br><span class="line"> F  G   H</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后他的后序遍历是</p><p>FDBGHECA</p><p>在这部分，我们要将二叉树转换为<strong>树或森林</strong>。要构建森林，我们将树的结构分为多个独立的子树。</p><p>分成两棵树</p><p>只要看这棵二叉树的根结点有没有右孩子，有的话就是森林，没有的话就是一棵树</p><p>第一步，若结点 <code>x</code> 是其双亲 <code>y</code> 的左孩子，则把 <code>x</code> 的右孩子，右孩子的右孩子等等等等，依次都与 <code>y</code> 用连连连接起来。</p><p>第二部，去掉所有双亲到右孩子之间到连线</p><p>然后从森林变成树的话就是这个操作的逆向</p><p>就是先把去掉右孩子的连线</p><p>然后把一棵树上相同深度的节点连起来</p><p>再把根节点连在一起</p><p>整理一下就得到了二叉树</p><p>设一棵树T中边的集合为{(A，B)，(A，C)，(A，D)，(B，E)，(C，F)，(C，G))，要求用孩子兄弟表示法（二叉链表）表示出该树的存储结构并将该树转化成对应的二叉树。</p><p>根据上面的信息，树应该是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">   / | \</span><br><span class="line">  B  C  D</span><br><span class="line"> /   / \</span><br><span class="line">E   F   G</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设有一组初始记录关键字为(45，80，48，40，22，78)，要求构造一棵二又排序树并给出构造过程</p><p>根据插入顺序插入元素，大于根节点的为右子树，小于的则为左子树</p><p>对于每个节点，左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。通过这种方式保证了树的结构满足二叉排序树的特性。所以二叉搜索树如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     45</span><br><span class="line">    /  \</span><br><span class="line">  40    80</span><br><span class="line"> /     /  \</span><br><span class="line">22    48  78</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序">排序</h2><p>设待排序的关键字序列为{12，6，16，30，10，20，2，18}，试分别写<br>出使用以下排序方法第一趟排序结束后关键字序列的状态，并写出该算法是稳定的<br>还是不稳定的。<br>① 希尔排序（d1=3）<br>② 冒泡排序<br>③ 快速排序<br>④ 二路归并排序</p><p>⑤选择排序</p><p>希尔排序：</p><p><strong>希尔排序</strong>的基本思路是：先将待排序序列按一定增量分组，分别对每组元素进行插入排序，最后逐步缩小增量，直到增量为 1，再进行一次插入排序。</p><p>给定增量序列：d1=3d_1 = 3d1=3，所以分组的方式是每隔 3 个元素一组。</p><p>首先，将序列按增量 3 分成 3 组：</p><ul><li>组 1：{12, 30, 2}</li><li>组 2：{6, 10, 18}</li><li>组 3：{16, 20}</li></ul><p>对每组分别进行插入排序：</p><ul><li>组 1：{12, 30, 2} -&gt; 排序后为 {2, 12, 30}</li><li>组 2：{6, 10, 18} -&gt; 排序后为 {6, 10, 18}</li><li>组 3：{16, 20} -&gt; 排序后为 {16, 20}</li></ul><p>然后重新合并这些组，得到：</p><p><strong>{2,6,16,12,10,20,30,18}</strong></p><p>在这之中，<strong>插入排序是稳定的</strong>。因为在排序过程中，当遇到相同的元素时，它们的相对顺序不会改变。最坏的结果下，时间复杂度是o(n^2)</p><p>希尔排序通常被认为是<strong>不稳定的</strong>，因为它在分组排序过程中可能会改变元素的相对顺序，特别是在增量较大时。</p><p>冒泡排序：</p><p>{12，6，16，30，10，20，2，18}</p><p>直接进行相互比较，后边的小就往前移动，大就不移动</p><p>然后经过第一趟之后是：</p><p><strong>{6，12，16，10，20，2，18，30}</strong></p><p><strong>冒泡排序是稳定的</strong>。即使相同的元素出现，也会保留它们原来的相对顺序。</p><p>快速排序：</p><p><strong>快速排序</strong>的基本思路是：选择一个基准元素，将数组分成两个部分，左边部分小于基准，右边部分大于基准，再递归排序两个部分。</p><p>{12，6，16，30，10，20，2，18}</p><p>以12为基准，小于12的{6,10,2}</p><p>大于12的{16,30,20,18}</p><p>然后合并，把基准12放在合适的位置，得到</p><p><strong>{6,10,2,12,16,30,20,18}</strong></p><p><strong>快速排序是非稳定的</strong>，因为相同的元素在分区过程中可能会改变原有的相对位置。</p><p>二路归并排序:</p><p><strong>二路归并排序</strong>的基本思路是：将序列不断分成两部分，递归地对两部分排序，最后合并排序好的两部分。</p><p>如何根据长度n划分部分</p><p>如果 <strong>n</strong> 是偶数，两个子序列的长度相等。</p><p>如果 <strong>n</strong> 是奇数，前一个子序列的长度是 <strong>n // 2</strong>，后一个子序列的长度是 <strong>n // 2 + 1</strong>。</p><p>{12，6，16，30，10，20，2，18}</p><p>分成两部分，然后每部分进行排序</p><p>{12，6，16，30}-&gt;{6,12,16,30}</p><p>{10，20，2，18}-&gt;{2,10,18,20}</p><p>然后合并两部分</p><p><strong>{6,12,16,30,2,10,18,20}</strong></p><p><strong>归并排序是稳定的</strong>。在合并过程中，如果两个元素相等，它们的顺序会保留。</p><p><strong>选择排序</strong></p><p>简单 <strong>选择排序</strong>通过每一趟选择剩余序列中的最小值并将其放到已排序部分的末尾。</p><p>{12，6，16，30，10，20，2，18}</p><p>第一次找到最小值2与12交换，得到</p><p><strong>{2,6,16,30,10,20,12,18}</strong></p><p><strong>稳定性</strong>：不稳定。因为最小元素可能会被交换，从而改变相等元素的相对顺序。</p><p>然后还有<strong>直接插入排序</strong></p><p>从第二个元素开始，与前面的已排序部分逐一比较，找到合适的位置插入当前元素。</p><h2 id="最小堆和最大堆">最小堆和最大堆</h2><p>最小堆（即根节点是最小值）。最小堆是一个完全二叉树，它满足每个父节点的值都不大于其子节点的值。每次向堆中插入数据时，都需要通过&quot;上浮&quot;（bubble-up）操作来维持堆的性质。</p><p>画出向小根堆中加入数据4，2，5，8，3时，每加入一个数据后堆的变化。</p><p>首先加入4，4是根节点</p><p>然后加入2，2小于4,所以交换2和4，2为根节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后加入5，因为5比2大，所以不用上浮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后加入8，8大于2，不需要上浮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> /</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>插入3，3小于4交换3和4，然后3大于2，不需要再上浮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br><span class="line"> / \</span><br><span class="line">8   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以这就是最终的堆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br><span class="line"> / \</span><br><span class="line">8   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后大根堆的话就是根节点是最大的值，其他的操作和最小堆一样</p><p>比如加入2, 3, 5, 8, 4</p><p>先加入2，作为根节点</p><p>然后加入3，3比2大，然后23交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> /</span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加入5，5比2大，25交换，5比3大，53交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加入8，8大于5，85交换，8大于3交换83</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   / \</span><br><span class="line">  5   3</span><br><span class="line"> /  </span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后插入4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   / \</span><br><span class="line">  5   3</span><br><span class="line"> / \  </span><br><span class="line">2   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="大根堆和堆排序">大根堆和堆排序</h2><p><strong>堆排序是一种选择排序</strong></p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong></p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong></p><p>左子节点就是2i+1,右子节点就是2i+2</p><p>父节点在(i-1)/2</p><p>将序列（5，26，77，1，61，11）构造成大根堆并实现排序，请画出<br>初始形态和最终的大根堆，并写出第一趟堆排序的结果。</p><p>在这里构造大根堆的时候，根节点要最大</p><p>从最后一个非叶子节点开始（也就是数组中的 <code>n//2 - 1</code> 位置），依次向前执行&quot;堆化&quot;操作，确保每个子树都满足大根堆的性质。</p><p>堆化节点1 index=2</p><p>左子节点：77，右子节点：11。最大值是 77。<strong>左子节点是2i+1</strong> 右子节点是2i+2</p><p>交换 77 和 5，得到 <code>[77, 26, 5, 1, 61, 11]</code>。</p><p>然后堆化节点0 index=1</p><p>左子节点是26 右子节点是61</p><p>交换26和61</p><p><strong>[77，61，5，1，26，11]</strong></p><p>堆化节点0 index=0</p><p>77是最大不用堆化</p><p>所以大根堆是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    77</span><br><span class="line">   /  \</span><br><span class="line">  61   5</span><br><span class="line"> /  \   \</span><br><span class="line">1   26  11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆排序的方法：</p><p>将堆顶（最大元素）与堆的最后一个元素交换。</p><p>调整堆，重新保证堆的性质。</p><p>重复步骤 1 和 2，直到堆的大小为 1。</p><p>实例：</p><p>最后肯定是堆化排序成[1, 5, 11, 26, 61, 77]</p><p>第一步是交换77和11</p><p>所以其顺序变成了</p><p><strong>[11，61，5，1，26，77]</strong></p><h2 id="迪杰拉斯特算法和prim算法">迪杰拉斯特算法和prim算法</h2><p>迪杰斯特拉（Dijkstra）算法是一种用于解决单源最短路径问题的算法，尤其适用于图的边权重为非负数的情况。它的目标是找到从一个起点（源节点）到图中所有其他节点的最短路径。</p><p><strong>初始化</strong>：给定图的每个节点，设定起点的最短路径为0，其余节点的最短路径为无穷大。</p><p><strong>选择当前节点</strong>：在尚未确定最短路径的节点中，选择一个具有最短路径估计值的节点。</p><p><strong>更新邻居节点的最短路径</strong>：对当前节点的每个邻居节点，通过比较现有的最短路径和通过当前节点到该邻居的路径来更新邻居节点的最短路径。</p><p><strong>标记当前节点为已处理</strong>：一旦确定了当前节点的最短路径，就将其标记为“已处理”。</p><p><strong>重复</strong>：重复步骤2至步骤4，直到所有节点的最短路径都被确定。</p><p>就是找最小的路径，然后访问所有的节点，注意是<strong>无向图</strong>还是<strong>有向图</strong></p><p>在表格中，没有办法直接到达的写无穷，然后能直接俄到达的直接写，然后写出路径，权值。已经到达的不写用\</p><p><strong>prim算法</strong>就是找到最小生成树，方法是通过起点，然后依次出发找到下一个点，使其经过的路程的和最小，<strong>只要是经过的点</strong>，都可以在那里出发去没有经过的点。</p><h2 id="DFS和BFS遍历树">DFS和BFS遍历树</h2><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>0</strong></th><th>0</th><th>1</th><th>0</th><th>0</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>1</strong></th><th>0</th><th>0</th><th>1</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>2</strong></th><th>1</th><th>0</th><th>0</th><th>0</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>3</strong></th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>4</strong></th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>比如上面的邻接矩阵，0代表图没用相连，1代表相连了。</p><p>然后实现 <strong>深度优先搜索（DFS）</strong></p><p>首先是深度，尽可能的往下扎</p><table><thead><tr><th>来源</th><th></th><th>0</th><th>1</th><th>1</th><th>3</th></tr></thead><tbody><tr><td>结点</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p>实现<strong>广度优先搜索（BFS）</strong></p><table><thead><tr><th></th><th>0</th><th>1</th><th>4</th><th>2</th><th>3</th></tr></thead></table><h2 id="线性表的计算（邻接矩阵和邻接表）">线性表的计算（邻接矩阵和邻接表）</h2><p>如图下列数组中存储了一个线性表，表头指针是A[0].next那么这个线性表是</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>data</td><td></td><td>60</td><td>50</td><td>40</td><td>30</td><td>20</td><td>10</td></tr><tr><td>next</td><td>3</td><td>5</td><td>6</td><td>2</td><td>1</td><td></td><td>4</td></tr></tbody></table><p>就是看next指针，然后按顺序读取数据就行</p><p>{40,50,10,30,60,20}</p><p>然后画邻接矩阵和邻接表的时候</p><p>邻接矩阵就是图中1和5有连接，那么(1,5)和(5,1)的话就是1，如果是单向的箭头注意分清方向</p><p>然后邻接图的话类似用箭头和方块表示，最后没了的话就在后面的next画上**^**</p><h1>算法设计</h1><h2 id="折半查找-2">折半查找</h2><p>试写出折半查找的递归算法。<br>//r 是有序表，查找关键字 k，若查找成功，返回 k 所在位置，查找失败返回 0。<br>int BinSearch（int r[ ]，int k，low，high）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include    &lt;stdio.h&gt;</span><br><span class="line">int BinSearch(int r[],int k,int low,int high)&#123;</span><br><span class="line">    if(low&gt;high)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (low+high)/2;</span><br><span class="line">    if(r[mid]==k)&#123;</span><br><span class="line">        return mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(r[mid]&gt;k)&#123;</span><br><span class="line">        return BinSearch(r,k,low,mid-1);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return BinSearch(r,k,mid+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写出折半查找的非递归算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int BinSearchNotFor(int r[],int k ,int low ,int high)&#123;</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        int mid = (low+high)/2;</span><br><span class="line">        if(r[mid]==k)&#123;</span><br><span class="line">            return mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(r[mid]&gt;k)&#123;</span><br><span class="line">            high = mid-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            low =mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表查找">单链表查找</h2><p>设计算法：统计单链表 HL 中结点的值等于给定值 x 的结点数。<br>int CountX(LNode* HL,ElemType x)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef int ElemType;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode;</span><br><span class="line">int CountX(LNode* HL,ElemType x)&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    LNode* current = HL;</span><br><span class="line">    while (current!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(current-&gt;data == x)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>单链表查找最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define MM -1000</span><br><span class="line">typedef int ElemType;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line">ElemType Max(LinkList L)&#123;</span><br><span class="line">    if(L==NULL||L-&gt;next ==NULL)&#123;</span><br><span class="line">        return MM;</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType maxval = MM;</span><br><span class="line">    LNode* current = L-&gt;next;</span><br><span class="line">    while(current!=NULL)&#123;</span><br><span class="line">        if(current-&gt;data&gt;maxval)&#123;</span><br><span class="line">            maxval = current-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>链表中节点的插入：</p><p>设指针变量p指向双向链表中结点A，指针变量g指向被插入结点B，要求给出在结点A的后面插入结点B的操作序列（设双向链表中结点的两个指针域分别为llink和 rlink)。</p><p>插入一个节点的时候，首先两个节点连接起来，然后把两个节点的前驱和后继再连接起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;rlink = B;</span><br><span class="line">B-&gt;llink = A;</span><br><span class="line">B-&gt;rlink = A-&gt;rlink;</span><br><span class="line"><span class="keyword">if</span>(A-&gt;rlink !=null)&#123;</span><br><span class="line">A-&gt;rlink-&gt;llink = B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序实现">快速排序实现</h2><p>设有一组初始记录关键字序列（K1，K2，，Kn），要求设计一个算法能够　在○(n)的时间复杂度内将线性表划分成两部分，其中左半部分的每个关键字均小于 Ki，右半部分的每个关键字均大于等于Ki。</p><p><strong>快速排序</strong>的基本思路是：选择一个基准元素，将数组分成两个部分，左边部分小于基准，右边部分大于基准，再递归排序两个部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n,<span class="type">int</span> pivoIndex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[pivoIndex];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp = arr[pivoIndex];</span><br><span class="line">    arr[pivoIndex] = arr[right];</span><br><span class="line">    arr[right] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;pivot)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=pivot)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            temp = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[n<span class="number">-1</span>] = arr[left];</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求交集，设有两个集合A和集合B，要求设计生成集合C=AnB的算法，其中集合A 、B和C用链式存储结构表示。 （分析采用何种数据结构表示集合</p><p>使用链表来解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Node** head,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *head = createNode(data);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node* temp = *head;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = createNode(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">existINList</span><span class="params">(Node* head,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;data == data)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* <span class="title function_">andList</span><span class="params">(Node* A,Node* B)</span>&#123;</span><br><span class="line">    Node* C = <span class="literal">NULL</span>;</span><br><span class="line">    Node* temp = A;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(existINList(B,temp-&gt;data))&#123;</span><br><span class="line">            insertNode(&amp;C,temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/16/data7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>python期末复习</title>
      <link>https://blog.tokenlen.top/2024/12/10/python2/</link>
      <guid>https://blog.tokenlen.top/2024/12/10/python2/</guid>
      <pubDate>Mon, 09 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;正则表达式&lt;/h1&gt;
&lt;p&gt;Python 的正则表达式通过 &lt;code&gt;re&lt;/code&gt; 模块实现，用于处理复杂的字符串匹配和提取操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用函数：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;re.match(pattern,</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>正则表达式</h1><p>Python 的正则表达式通过 <code>re</code> 模块实现，用于处理复杂的字符串匹配和提取操作。</p><ul><li>常用函数：<ul><li><code>re.match(pattern, string)</code><br>从字符串的开头匹配，返回匹配对象或 <code>None</code>。</li><li><code>re.search(pattern, string)</code><br>搜索整个字符串，找到第一个匹配。</li><li><code>re.findall(pattern, string)</code><br>返回所有匹配的结果（列表形式）。</li><li><code>re.finditer(pattern, string)</code><br>返回所有匹配结果的迭代器。</li><li><code>re.sub(pattern, repl, string)</code><br>替换匹配的内容。</li><li><code>re.split(pattern, string)</code><br>根据模式分割字符串。</li></ul></li></ul><p><strong>. 常用正则表达式语法</strong></p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意单个字符（除换行符）。</td></tr><tr><td><code>^</code></td><td>匹配字符串的开头。</td></tr><tr><td><code>$</code></td><td>匹配字符串的结尾。</td></tr><tr><td><code>*</code></td><td>匹配前面的字符 0 次或多次。</td></tr><tr><td><code>+</code></td><td>匹配前面的字符 1 次或多次。</td></tr><tr><td><code>?</code></td><td>匹配前面的字符 0 次或 1 次。</td></tr><tr><td><code>&#123;n&#125;</code></td><td>匹配前面的字符恰好 n 次。</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>匹配前面的字符至少 n 次。</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>匹配前面的字符至少 n 次，至多 m 次。</td></tr><tr><td><code>[]</code></td><td>匹配字符集合中的任意一个，例如 <code>[a-z]</code> 匹配小写字母。</td></tr><tr><td>`</td><td>`</td></tr><tr><td><code>()</code></td><td>分组，用于提取子模式。</td></tr><tr><td><code>\</code></td><td>转义字符，用于匹配特殊字符。</td></tr></tbody></table><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">email = &quot;example@domain.com&quot;</span><br><span class="line">pattern = r&quot;^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$&quot;</span><br><span class="line">if re.match(pattern, email):</span><br><span class="line">    print(&quot;有效的邮箱地址&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无效的邮箱地址&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th><code>\d</code></th><th>匹配任意数字，等价于 <code>[0-9]</code>。</th></tr></thead><tbody><tr><td><code>\D</code></td><td>匹配任意非数字。</td></tr><tr><td><code>\w</code></td><td>匹配任意字母、数字、下划线，等价于 <code>[a-zA-Z0-9_]</code>。</td></tr><tr><td><code>\W</code></td><td>匹配任意非字母、数字、下划线。</td></tr><tr><td><code>\s</code></td><td>匹配任意空白字符（包括空格、制表符等）。</td></tr><tr><td><code>\S</code></td><td>匹配任意非空白字符。</td></tr></tbody></table><p>对于需要多次使用的正则表达式，可以通过 <code>re.compile()</code> 提前编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python复制代码import re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(r&quot;\d+&quot;)</span><br><span class="line">result = pattern.findall(&quot;订单号123，总金额456元&quot;)</span><br><span class="line">print(result)  # 输出 [&#x27;123&#x27;, &#x27;456&#x27;]</span><br></pre></td></tr></table></figure><p>编译时可以指定标志（flags）：</p><ul><li><code>re.IGNORECASE</code> (<code>re.I</code>)：忽略大小写。</li><li><code>re.MULTILINE</code> (<code>re.M</code>)：多行模式。</li><li><code>re.DOTALL</code> (<code>re.S</code>)：使 <code>.</code> 匹配换行符。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&quot;hello&quot;, re.IGNORECASE)</span><br><span class="line">print(pattern.findall(&quot;Hello, hello, HELLO&quot;))  # 输出 [&#x27;Hello&#x27;, &#x27;hello&#x27;, &#x27;HELLO&#x27;]</span><br></pre></td></tr></table></figure><h1>概念理解</h1><p>1.编写程序的目的是“使用计算机解决问题”，写出使用计算机解决问题的常见步骤</p><p><strong>问题定义与理解</strong>：明确问题及需求，确定输入输出。</p><p><strong>问题分析</strong>：分析问题细节，识别关键点和约束。</p><p><strong>设计算法</strong>：设计解决问题的算法，选择合适的数据结构。</p><p><strong>选择工具</strong>：选择适合的编程语言和开发环境。</p><p><strong>编写程序</strong>：根据算法编写清晰的代码，确保正确性。</p><p><strong>调试与测试</strong>：检测和修复错误，进行功能和边界测试。</p><p><strong>优化与改进</strong>：提高程序性能和可维护性。</p><p><strong>文档化与维护</strong>：编写使用文档，定期维护和更新程序。</p><p>2.python语言时一种被广泛使用的高级通用脚本编程语言，请结合本学期的学习，列举不少于5个Python语言的特点。</p><p><strong>简洁易读</strong>：代码清晰，使用缩进结构。</p><p><strong>跨平台</strong>：可在不同操作系统上运行。</p><p><strong>动态类型</strong>：变量类型在运行时确定。</p><p><strong>解释型语言</strong>：无需编译，直接运行。</p><p><strong>丰富的库</strong>：大量标准库和第三方库支持。</p><p>3.根据自己的理解，说明为什么应尽量从列表的尾部进行元素的添加与删除操作。</p><p><strong>时间复杂度为O(1)</strong>：在列表尾部添加或删除元素，不需要移动其他元素，操作时间固定。</p><p><strong>避免元素移动</strong>：从头部或中间添加/删除元素时，需要移动大量元素，时间复杂度为O(n)，效率低。</p><p>4.阐述说明Python语言编程时为什么要导入扩展库？导入的途径有哪些？</p><ol><li><strong>功能增强</strong>：扩展库提供了丰富的功能，避免重复造轮子，节省开发时间。</li><li><strong>简化代码</strong>：扩展库封装了复杂的功能，使用者可以直接调用简洁的接口，减少代码量。</li><li><strong>提高效率</strong>：许多扩展库经过优化，能提高程序的性能。</li></ol><p><strong>导入途径</strong>：</p><ol><li><strong><code>import</code></strong>：导入整个模块，使用时需要加模块名，例如 <code>import math</code>。</li><li><strong><code>from ... import ...</code></strong>：只导入模块中的某个部分，例如 <code>from math import sqrt</code>。</li><li><strong><code>import ... as ...</code></strong>：为模块指定别名，简化代码，例如 <code>import numpy as np</code>。</li></ol><p>5.<strong>变量</strong>：用于存储数据的命名位置。Python 是动态类型语言，变量不需要事先声明类型，类型由赋值时自动推导。</p><p><strong>数据类型</strong>：Python 支持多种数据类型，包括 <code>int</code>（整数）、<code>float</code>（浮点数）、<code>str</code>（字符串）、<code>list</code>（列表）、<code>tuple</code>（元组）、<code>dict</code>（字典）、<code>set</code>（集合）等。</p><p><strong>List（列表）</strong>：有序，可变，可以包含重复元素。{}</p><p><strong>Tuple（元组）</strong>：有序，不可变，通常用于表示不希望修改的数据。（）</p><p><strong>Dict（字典）</strong>：无序，由键值对组成，键是唯一的，适用于映射关系。{}</p><p><strong>Set（集合）</strong>：无序，不能包含重复元素，常用于去重或集合运算。{}</p><p>6.<strong>控制结构</strong></p><ul><li><strong>条件语句</strong>：<code>if</code>、<code>elif</code>、<code>else</code> 用于根据条件执行不同的代码块。</li><li><strong>循环语句</strong>：<code>for</code> 和 <code>while</code> 循环用来重复执行代码。<code>for</code> 用于遍历序列（如列表、字典等），<code>while</code> 用于基于条件的循环。</li><li><strong>循环控制</strong>：<code>break</code>、<code>continue</code> 和 <code>pass</code> 用于控制循环的执行。</li></ul><p>7.<strong>定义函数</strong>：通过 <code>def</code> 关键字定义函数，函数可以带参数、返回值。</p><p><strong>内置函数</strong>：Python 提供了许多常用的内置函数，如 <code>len()</code>、<code>max()</code>、<code>min()</code>、<code>range()</code> 等。</p><p>8.面向对象</p><p><strong>类与对象</strong>：Python 是面向对象的语言，可以通过 <code>class</code> 定义类。类是对象的蓝图，而对象是类的实例。</p><p><strong>继承</strong>：子类继承父类的属性和方法，能够扩展和重写父类的功能。</p><p><strong>多态与封装</strong>：多态使得不同的类可以以相同的方式调用，封装则通过访问控制保护数据。</p><p><strong>构造函数 <code>__init__</code></strong>：每次创建对象时调用，用于初始化对象的状态。</p><p>9.异常处理</p><ul><li><strong><code>try</code>、<code>except</code>、<code>else</code>、<code>finally</code></strong>：用于捕获和处理异常，避免程序崩溃。<code>finally</code> 块中的代码会始终执行，通常用于资源清理。</li><li><strong>自定义异常</strong>：可以通过继承 <code>Exception</code> 类自定义异常类型。</li></ul><p>10.字典推导式</p><p><strong>列表推导式</strong>：一种简洁的创建列表的方式，通常包含条件和表达式。</p><p><strong>字典推导式</strong>：类似于列表推导式，用于创建字典。</p><p>11.生成器和迭代器</p><p><strong>生成器</strong>：使用 <code>yield</code> 关键字创建的迭代器。生成器可以按需生成数据，避免一次性生成所有数据，节省内存。</p><p><strong>迭代器</strong>：Python 中的迭代器协议（<code>__iter__()</code> 和 <code>__next__()</code>），用于按序访问容器中的元素。</p><h1>真题解析</h1><ol><li><p>表达式[3] not in [1，3，4，5]的值为（  <strong>false</strong>    ）。</p></li><li><p>你认为“在编写Python程序时，不管一条语句有多长，都必须写在同一行中，不能换行。”这种观点对吗？（  <strong>不对</strong>    ）。</p></li><li><p>假设已导入模块re，那么表达式re.findall(‘\d{1,3}’,‘a12b345ccc567890’)的结果为（ <strong>12,345,567，890</strong>   ）</p></li><li><p>已知vec=[[1，2]，[3，4]]，则表达式[col for row in vec for col in row]的值为（  <strong>[1, 2, 3, 4]</strong>    ）。</p></li><li><p>表达式max（[1，2，3]，[2，3，5]，[5，3，7，6]，[5，1，3，8，9]，key=len）的值为（   <strong>[5，1，3，8，9]</strong>    ）。</p></li><li><p>在导入模块re后，设s=‘a s d e’，则re.sub(‘a|s|d|e’,‘well’,s)的结果为（<strong>well well well well</strong>     ）。</p></li><li><p>s=’qlu，upc，jlu，pear，qinghua’，则s.split(‘，’)的输出结果是（ [<strong>‘qlu,upc,jlu,pear,qinghua’]</strong>        ）。</p></li><li><p>对于文本文件，使用Python的内置函数open（）以读模式成功打开后返回的文件对象（  <strong>可以</strong>  ）使用for循环直接迭代。</p></li><li><p>设f=lambda x，y，z：x+y*z，则print（f（1，2，3））的输出结果为（ <strong>7</strong>）</p></li><li><p>导入re模块后，若ch=’aaa   bb c d e  fff   ’则执行语句：’ ’.join（ch.split( )）后的输出结果为（ <strong>‘aaa bb c d e fff’</strong>   ）。</p></li></ol><p>11.下面代码的运行后的结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def demo(a, b, c=3, d=100):</span><br><span class="line">    return sum((a, b, c, d))</span><br><span class="line"></span><br><span class="line">print(demo(1, 2, 3, 4))  # (1)</span><br><span class="line">print(demo(1, 2, d=3))   # (2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10，9</span><br></pre></td></tr></table></figure><p>解析：</p><p>因为<strong>如果函数的参数给了值的话，就用给的值。没给的话，就要用默认值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list2 = [5, 6, 7, 8, 9]</span><br><span class="line">print(list2[])       # (1)</span><br><span class="line">print(list2[2:])     # (2)</span><br><span class="line">print(list2[:-2])    # (3)</span><br><span class="line">print(list2[1:3])    # (4)</span><br><span class="line">print(list2[1] &lt;= 3 or list2[3] &gt; 5)  # (5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># (1) 错误：SyntaxError</span><br><span class="line"># (2) [7, 8, 9]</span><br><span class="line"># (3) [5, 6, 7]</span><br><span class="line"># (4) [6, 7]</span><br><span class="line"># (5) True</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解析：</p><p>因为在列表中没有index的话，是输出不了东西的</p><p>然后从前面开始分别是为0123…</p><p>从后面开始分别是-1-2-3…</p><p>然后【1:3】是不包括后面的，和for循环中的range一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import types</span><br><span class="line"></span><br><span class="line">class Car:</span><br><span class="line">    price = 100000                               # 定义类属性</span><br><span class="line">    def __init__(self, c):</span><br><span class="line">        self.color = c                           # 定义实例属性</span><br><span class="line"></span><br><span class="line">car1 = Car(&quot;Red&quot;)                                # 实例化对象</span><br><span class="line">car2 = Car(&quot;Blue&quot;)</span><br><span class="line">print(car1.color, Car.price)                     # 查看实例属性和类属性的值</span><br><span class="line">Car.price = 110000                               # 修改类属性</span><br><span class="line">Car.name = &#x27;QQ&#x27;                                  # 动态增加类属性</span><br><span class="line">car1.color = &quot;Yellow&quot;                            # 修改实例属性</span><br><span class="line">print(car2.color, Car.price, Car.name)</span><br><span class="line">print(car1.color, Car.price, Car.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Red 100000</span><br><span class="line">Blue 110000 QQ</span><br><span class="line">Yellow 110000 QQ</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就不解释了，直接能看懂哈哈哈☺</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dcountry = &#123;</span><br><span class="line">    &quot;中国&quot;: &quot;北京&quot;,</span><br><span class="line">    &quot;美国&quot;: &quot;华盛顿&quot;,</span><br><span class="line">    &quot;法国&quot;: &quot;巴黎&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(list(Dcountry.values()))  # (1)</span><br><span class="line">print(list(Dcountry.keys()))    # (2)</span><br><span class="line">print(Dcountry.get(&quot;德国&quot;, &quot;伦敦&quot;))  # (3)</span><br><span class="line">print(Dcountry.get(&quot;美国&quot;, &quot;伦敦&quot;))  # (4)</span><br><span class="line"></span><br><span class="line">for key in Dcountry:  # (5)</span><br><span class="line">    print(key)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;北京&#x27;, &#x27;华盛顿&#x27;, &#x27;巴黎&#x27;]  # (1)</span><br><span class="line">[&#x27;中国&#x27;, &#x27;美国&#x27;, &#x27;法国&#x27;]  # (2)</span><br><span class="line">伦敦  # (3)</span><br><span class="line">华盛顿  # (4)</span><br><span class="line">中国</span><br><span class="line">美国</span><br><span class="line">法国  # (5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面的不解释，主要就是键值对，前面的为key 后面的为value</p><p><code>get</code> 方法用于获取字典中指定键的值。如果键不存在，则返回默认值</p><p>so,print(Dcountry.get(“德国”, “伦敦”))找不到key=德国所以return默认值伦敦</p><p>print(Dcountry.get(“美国”, “伦敦”))找到key=美国，返回他的value华盛顿</p><h1>编程题</h1><p>1.在软件设计和实现时，用户登录模块必不可少。请使用python语言编程实现该功能，要求：每次登录提供3次机会，只有账户名和密码完全匹配才“登录成功！”，否则提示“请注意剩余尝试次数为X次”，超过3次，则提示“3次用户名或者密码均有误，请退出程序！”。（提示：用户名和密码可以提前自行设定好。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 设定用户名和密码</span><br><span class="line">username = &quot;admin&quot;</span><br><span class="line">password = &quot;123456&quot;</span><br><span class="line"></span><br><span class="line"># 最大尝试次数</span><br><span class="line">max_attempts = 3</span><br><span class="line"></span><br><span class="line"># 登录验证</span><br><span class="line">for attempt in range(max_attempts):</span><br><span class="line">    input_username = input(&quot;请输入用户名: &quot;)</span><br><span class="line">    input_password = input(&quot;请输入密码: &quot;)</span><br><span class="line"></span><br><span class="line">    if input_username == username and input_password == password:</span><br><span class="line">        print(&quot;登录成功！&quot;)</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        remaining_attempts = max_attempts - attempt - 1</span><br><span class="line">        if remaining_attempts &gt; 0:</span><br><span class="line">            print(f&quot;请注意，剩余尝试次数为&#123;remaining_attempts&#125; 次&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;3次用户名或者密码均有误，请退出程序！&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.编程实现对键盘接受的整数进行奇偶数判断。</p><p>要求：包括主函数和is­_odd()子函数，其中is­_odd（）函数，用于实现数值奇偶数判断，参数为整数，如果参数为奇数，返回true，否则返回false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 判断奇偶数的子函数</span><br><span class="line">def is_odd(num):</span><br><span class="line">    return num % 2 != 0</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    # 从键盘接受整数输入</span><br><span class="line">    try:</span><br><span class="line">        num = int(input(&quot;请输入一个整数: &quot;))</span><br><span class="line">        </span><br><span class="line">        # 判断奇偶数</span><br><span class="line">        if is_odd(num):</span><br><span class="line">            print(f&quot;&#123;num&#125; 是奇数&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;num&#125; 是偶数&quot;)</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&quot;请输入有效的整数&quot;)</span><br><span class="line"></span><br><span class="line"># 调用主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.中文里,有回文诗句、对联,如:“灵山大佛,佛大山灵”,&quot;客上天然居,居然天上客&quot;等等,都是美妙的符合正念倒念都一样的回文句；设n是一个任意自然数，如果n的各位数字反向排列所得自然数与n相等，则n称为回文数。从键盘输入5位数字，请编写程序判断这个数字是不是回文数（自行设置退出条件）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 判断回文数的函数</span><br><span class="line">def is_palindrome(num):</span><br><span class="line">    return str(num) == str(num)[::-1]</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    while True:</span><br><span class="line">        # 从键盘输入5位数字</span><br><span class="line">        try:</span><br><span class="line">            num = int(input(&quot;请输入一个5位数字（输入0退出程序）: &quot;))</span><br><span class="line">            </span><br><span class="line">            if num == 0:</span><br><span class="line">                print(&quot;程序退出&quot;)</span><br><span class="line">                break</span><br><span class="line">            </span><br><span class="line">            if 10000 &lt;= num &lt;= 99999:  # 判断是否为5位数字</span><br><span class="line">                if is_palindrome(num):</span><br><span class="line">                    print(f&quot;&#123;num&#125; 是回文数&quot;)</span><br><span class="line">                else:</span><br><span class="line">                    print(f&quot;&#123;num&#125; 不是回文数&quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;请输入一个有效的5位数字！&quot;)</span><br><span class="line">        except ValueError:</span><br><span class="line">            print(&quot;输入无效，请输入一个数字！&quot;)</span><br><span class="line"></span><br><span class="line"># 调用主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.编写程序，在D盘根目录下创建一个文本文件test.txt，并向其中写入字符串“Beautiful is better than ugly.Explicit is better than implicit.”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 文件路径</span><br><span class="line">file_path = &quot;D:/test.txt&quot;</span><br><span class="line"></span><br><span class="line"># 要写入的字符串</span><br><span class="line">text = &quot;Beautiful is better than ugly.\nExplicit is better than implicit.&quot;</span><br><span class="line"></span><br><span class="line"># 打开文件并写入</span><br><span class="line">with open(file_path, &quot;w&quot;) as file:</span><br><span class="line">    file.write(text)</span><br><span class="line"></span><br><span class="line">print(&quot;文件已成功创建并写入内容。&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.\1. IT时代信息安全更为重要，无论是国家安全领域、商业领域还是个人信息都要有一定的保护措施。利用python课程中所学知识，批量产生50个人的信息，每个人的信息内容由以下字段组成：</p><table><thead><tr><th>姓名（XM）</th><th>性别（XB）</th><th>身份证号（ID）</th><th>电话号码（TEL)</th><th>家庭住址（ADRESS）</th></tr></thead><tbody><tr><td>XXX</td><td>男</td><td>3709…</td><td>136…</td><td>aaaaaaaaaaaaaaaa</td></tr><tr><td>YYY</td><td>女</td><td>3701…</td><td>184…</td><td>bbbbbbbbbbbbbbbb</td></tr></tbody></table><p>身份证号和电话号码长度按实际长度产生，其它字段信息长度自行设定，编写程序完成以下要求：</p><p>（1）按照凯撒加密算法对产生的每项信息进行加密。</p><p>（2）把加密后每个人的信息写入到excel文件中，每一行存储一个人的信息。</p><p>（3）把加密后每个人的信息写入到写入到SQLite数据库中，每条记录存储一个人的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sqlite3</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># 凯撒加密函数</span><br><span class="line">def caesar_encrypt(text, shift=3):</span><br><span class="line">    return &#x27;&#x27;.join([chr((ord(char) - ord(&#x27;a&#x27;) + shift) % 26 + ord(&#x27;a&#x27;)) if char.isalpha() else char for char in text])</span><br><span class="line"></span><br><span class="line"># 生成随机信息</span><br><span class="line">def generate_info():</span><br><span class="line">    name = random.choice([&#x27;张伟&#x27;, &#x27;李娜&#x27;, &#x27;王磊&#x27;, &#x27;刘敏&#x27;, &#x27;陈静&#x27;])</span><br><span class="line">    gender = random.choice([&#x27;男&#x27;, &#x27;女&#x27;])</span><br><span class="line">    id_number = &#x27;&#x27;.join([str(random.randint(0, 9)) for _ in range(18)])</span><br><span class="line">    tel = &#x27;1&#x27; + str(random.randint(3, 9)) + &#x27;&#x27;.join([str(random.randint(0, 9)) for _ in range(9)])</span><br><span class="line">    address = &#x27;&#x27;.join(random.choices(&#x27;abcdefghijklmnopqrstuvwxyz0123456789&#x27;, k=15))</span><br><span class="line">    return [name, gender, id_number, tel, address]</span><br><span class="line"></span><br><span class="line"># 生成50条数据</span><br><span class="line">people_info = [generate_info() for _ in range(50)]</span><br><span class="line"></span><br><span class="line"># 对数据进行凯撒加密</span><br><span class="line">shift = 3</span><br><span class="line">encrypted_info = [[caesar_encrypt(field, shift) for field in person] for person in people_info]</span><br><span class="line"></span><br><span class="line"># 写入Excel</span><br><span class="line">def write_to_excel(data):</span><br><span class="line">    df = pd.DataFrame(data, columns=[&#x27;姓名&#x27;, &#x27;性别&#x27;, &#x27;身份证号&#x27;, &#x27;电话号码&#x27;, &#x27;家庭住址&#x27;])</span><br><span class="line">    df.to_excel(&#x27;encrypted_people_info.xlsx&#x27;, index=False)</span><br><span class="line"></span><br><span class="line"># 写入SQLite</span><br><span class="line">def write_to_sqlite(data):</span><br><span class="line">    conn = sqlite3.connect(&#x27;people_info.db&#x27;)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(&#x27;&#x27;&#x27;</span><br><span class="line">    CREATE TABLE IF NOT EXISTS people (</span><br><span class="line">        name TEXT, gender TEXT, id_number TEXT, phone_number TEXT, address TEXT)</span><br><span class="line">    &#x27;&#x27;&#x27;)</span><br><span class="line">    cursor.executemany(&#x27;&#x27;&#x27;</span><br><span class="line">    INSERT INTO people (name, gender, id_number, phone_number, address)</span><br><span class="line">    VALUES (?, ?, ?, ?, ?)</span><br><span class="line">    &#x27;&#x27;&#x27;, data)</span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"># 执行写入操作</span><br><span class="line">write_to_excel(encrypted_info)</span><br><span class="line">write_to_sqlite(encrypted_info)</span><br><span class="line"></span><br><span class="line">print(&quot;数据已成功写入 Excel 和 SQLite 数据库。&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.π（圆周率）是一个无理数，即无限不循环小数。精确求解圆周率π是几何学、物理学和很多工程学科的关键。对π的精确求解曾经是数学历史上一直难以解决的问题之一，因为π无法用任何精确公式表示，在电子计算机出现以前，π只能通过一些近似公式的求解得到，如BBP公式。结合自己了解的数学方法和Python编程技术，设计一种近似计算π的程序，并给出设计步骤和主要思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"># 1. 使用莱布尼茨级数法近似计算 π</span><br><span class="line">def leibniz_formula(n_terms):</span><br><span class="line">    pi_approx = 0</span><br><span class="line">    for i in range(n_terms):</span><br><span class="line">        pi_approx += ((-1) ** i) / (2 * i + 1)</span><br><span class="line">    return 4 * pi_approx</span><br><span class="line"></span><br><span class="line"># 2. 使用蒙特卡罗方法近似计算 π</span><br><span class="line">def monte_carlo_pi(n_points):</span><br><span class="line">    inside_circle = 0</span><br><span class="line">    for _ in range(n_points):</span><br><span class="line">        x = random.random()</span><br><span class="line">        y = random.random()</span><br><span class="line">        # 计算点是否在单位圆内</span><br><span class="line">        if x**2 + y**2 &lt;= 1:</span><br><span class="line">            inside_circle += 1</span><br><span class="line">    return 4 * inside_circle / n_points</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    n_terms = 1000000  # 莱布尼茨级数法迭代次数</span><br><span class="line">    n_points = 1000000  # 蒙特卡罗方法随机点数</span><br><span class="line"></span><br><span class="line">    # 使用莱布尼茨级数法计算 π</span><br><span class="line">    pi_leibniz = leibniz_formula(n_terms)</span><br><span class="line">    print(f&quot;莱布尼茨级数法计算 π：&#123;pi_leibniz&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 使用蒙特卡罗方法计算 π</span><br><span class="line">    pi_monte_carlo = monte_carlo_pi(n_points)</span><br><span class="line">    print(f&quot;蒙特卡罗方法计算 π：&#123;pi_monte_carlo&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$$<br>\pi = 4 \times \left(1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \dots \right)<br>$$<br>7.个滴滴快车是怎么计费的？请你用所学Python语言编写一个计费程序。根据实际情况，回答问题。</p><p>（一）收集、分析数据，运用数理思维建模</p><p>登录滴滴出行官网，得到了如下信息，即“滴滴快车（普通型）计价规则”：</p><p><img src="C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>小萌同学19：33从“济南泉城广场”到“千佛山景区”乘坐滴滴快车（普通车型），里程4.1公里，时长约21分钟，按照表中的计费规则，此次出行应该支付的车费是：车费=8+（4.1-3.3）×1.35+（21-9）×0.2=9.68。</p><p>假设Tot1表示时长费，Tot2表示里程费，S表示实际里程，T表示实际时长，Cost表示应支付费用。运用数学解析式归纳出计费公式。</p><p>答:</p><p>（二）运用算法描述方法将问题解决步骤化</p><p>明晰了滴滴快车车费的计算方法之后，设计求解滴滴快车普通时段车费的算法，并用IPO算法设计法和流程图的方式表述出来。</p><p><img src="C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"> 1、IPO（输入-处理-输出）算法描述：</p><p>I：</p><p>P：</p><p>O：</p><p>2、流程图描述：如图所示，请添加序号（1）</p><p>~（5）处的语句。</p><p>（1）：</p><p>（2）：</p><p>（3）：</p><p>（4）：</p><p>（5）：</p><p>（三）编写、调试、运行程序解决问题。</p><p>根据滴滴快车计价规则，可以推导出车费计算的公式：</p><ol><li><strong>基本费用</strong>：8 元</li><li><strong>里程费用</strong>：如果实际行驶里程超过 3.3 公里，则超出的部分按每公里 1.35 元计费。即，实际里程 S 大于 3.3 时，超出部分按 <code>(S - 3.3) * 1.35</code> 计算。</li><li><strong>时长费用</strong>：如果实际时长超过 9 分钟，则超出的部分按每分钟 0.2 元计费。即，实际时长 T 大于 9 分钟时，超出部分按 <code>(T - 9) * 0.2</code> 计算。</li></ol><p>根据这些规则，最终的车费可以通过以下公式计算：<br>$$<br>Cost=8+(S−3.3)×1.35+(T−9)×0.2<br>$$</p><ol><li><p><strong>IPO（输入-处理-输出）算法描述</strong>：</p><ul><li><strong>I（输入）</strong>：输入实际的行驶里程 <code>S</code> 和实际的时长 <code>T</code>。</li><li><strong>P（处理）</strong>：根据上述的计费规则，计算里程费用和时长费用，并求出总车费。</li><li><strong>O（输出）</strong>：输出应支付的车费。</li></ul></li><li><p><strong>流程图描述</strong>：</p><p>以下是步骤化的描述：</p><ul><li><strong>(1)</strong>：输入实际里程 <code>S</code> 和时长 <code>T</code>。</li><li><strong>(2)</strong>：计算里程费用：如果实际里程 <code>S</code> 大于 3.3 公里，则计算 <code>(S - 3.3) * 1.35</code>；否则里程费用为 0。</li><li><strong>(3)</strong>：计算时长费用：如果实际时长 <code>T</code> 大于 9 分钟，则计算 <code>(T - 9) * 0.2</code>；否则时长费用为 0。</li><li><strong>(4)</strong>：计算总费用：<code>Cost = 8 + 里程费用 + 时长费用</code>。</li><li><strong>(5)</strong>：输出车费 <code>Cost</code>。</li></ul></li></ol><p>根据上面的计费公式和流程，下面是一个用 Python 编写的滴滴快车车费计算程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> calculate_fare(distance, duration):</span><br><span class="line">    # 基本费用</span><br><span class="line">    base_fare = 8.0</span><br><span class="line">    </span><br><span class="line">    # 计算里程费用</span><br><span class="line">    if distance &gt; 3.3:</span><br><span class="line">        distance_fare = (distance - 3.3) * 1.35</span><br><span class="line">    else:</span><br><span class="line">        distance_fare = 0</span><br><span class="line">    </span><br><span class="line">    # 计算时长费用</span><br><span class="line">    if duration &gt; 9:</span><br><span class="line">        duration_fare = (duration - 9) * 0.2</span><br><span class="line">    else:</span><br><span class="line">        duration_fare = 0</span><br><span class="line">    </span><br><span class="line">    # 总车费</span><br><span class="line">    total_fare = base_fare + distance_fare + duration_fare</span><br><span class="line">    return total_fare</span><br><span class="line"></span><br><span class="line"># 获取用户输入的实际里程和时长</span><br><span class="line">distance = float(input(&quot;请输入实际行驶里程（公里）：&quot;))</span><br><span class="line">duration = float(input(&quot;请输入实际行驶时长（分钟）：&quot;))</span><br><span class="line"></span><br><span class="line"># 计算车费</span><br><span class="line">fare = calculate_fare(distance, duration)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">print(f&quot;此次出行的车费为：&#123;fare:.2f&#125; 元&quot;)</span><br></pre></td></tr></table></figure><p>假设用户输入：</p><ul><li>实际里程：<code>4.1</code> 公里</li><li>实际时长：<code>21</code> 分钟</li></ul><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制代码请输入实际行驶里程（公里）：4.1</span><br><span class="line">请输入实际行驶时长（分钟）：21</span><br><span class="line">此次出行的车费为：9.68 元</span><br></pre></td></tr></table></figure><h1>基础知识补充</h1><p>1.eval()会执行字符串中的表达式</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(500/10)</span><br><span class="line">输出</span><br><span class="line">50.0</span><br></pre></td></tr></table></figure><p>2.在列表中，空格也是占一个字符位置的，然后[3:8]前面的闭口的，后面是开口的，即3-7</p><p>3.Python 提供的一个元素全为字符串的列表写入文件的函数是</p><p><code>writelines()</code> 方法将一个列表的所有字符串写入文件</p><p><code>readlines()</code>是读取的方法，把</p><p>4.字典的键必须是不可变类型（例如，元组、字符串），而列表是可变的</p><p>5.jieba库应用</p><p>利用 Python 内置函数及 jieba 库中已有函数，计算字符串 s 的中文字符个数及中文词语 个数。</p><p>import jieba s = “中国举办冬奥会”</p><p>n = __________</p><p>m = __________</p><p>print(“中文字符数为{}，中文词语数为{}。”.format(n, m))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line">s = &quot;中国举办冬奥会&quot;</span><br><span class="line"></span><br><span class="line">n = len([ch for ch in s if &#x27;\u4e00&#x27; &lt;= ch &lt;= &#x27;\u9fa5&#x27;])  # 统计中文字符数</span><br><span class="line">m = len(list(jieba.cut(s)))  # 统计中文词语数</span><br><span class="line"></span><br><span class="line">print(&quot;中文字符数为&#123;&#125;，中文词语数为&#123;&#125;。&quot;.format(n, m))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jieba.lcut()返回一个列表，而不是生成器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line">text = &quot;我来到北京清华大学&quot;</span><br><span class="line">words = jieba.lcut(text)</span><br><span class="line">print(words)  # 返回列表</span><br></pre></td></tr></table></figure><p>jieba.posseg.cut()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import jieba.posseg as pseg</span><br><span class="line">text = &quot;我来到北京清华大学&quot;</span><br><span class="line">words = pseg.cut(text)</span><br><span class="line">for word, flag in words:</span><br><span class="line">    print(f&quot;&#123;word&#125; &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p>jieba.analyse.extract_tags()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import jieba.analyse</span><br><span class="line">text = &quot;我爱北京天安门，天安门是北京的标志性建筑。&quot;</span><br><span class="line">keywords = jieba.analyse.extract_tags(text, topK=5, withWeight=False)</span><br><span class="line">print(keywords)  # 返回前5个关键词</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>jieba.cut()</code></strong>: 精确模式分词。</p><p><strong><code>jieba.lcut()</code></strong>: 返回列表形式的精确模式分词。</p><p><strong><code>jieba.cut_for_search()</code></strong>: 搜索引擎模式分词。</p><p><strong><code>jieba.posseg.cut()</code></strong>: 词性标注分词。</p><p><strong><code>jieba.load_userdict()</code></strong>: 加载自定义词典。</p><p><strong><code>jieba.analyse.extract_tags()</code></strong>: 提取关键词。</p><p><strong><code>jieba.add_word()</code></strong>: 动态添加新词。</p><p><strong><code>jieba.del_word()</code></strong>: 删除词典中的词。</p><p>6.type函数</p><p>type函数获取里面数据的类型</p><p><code>val = (3)</code> 定义的是一个包含单一元素 <code>3</code> 的元组，但元组中的单个元素没有使用逗号，Python 会将其视为整数 <code>3</code>，因此它的类型是 <code>int</code>。</p><p>如果是多个元素，Python 会正确地识别为元组。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = (3, 4)</span><br></pre></td></tr></table></figure><p>此时，<code>val</code> 是一个包含两个元素 <code>3</code> 和 <code>4</code> 的元组，类型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(val)  # 输出 &lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：当定义元组时，至少需要一个逗号来表示这是一个元组。即使只有一个元素，但只要加上逗号，它就会被识别为元组。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = (3,)  # 正确的单元素元组</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>val</code> 仍然是一个元组，类型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(val)  # 输出 &lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure><p>如果没有逗号，<code>val = (3)</code> 会被当作普通的括号表达式，<code>val</code> 只是一个整数 <code>3</code>。</p><ol start="7"><li></li></ol><p>对于 <code>ls = list(range(5))</code>，<code>print(ls)</code> 的输出是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>输入列表为xxxx</p><ol start="8"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for s in &quot;python&quot;:</span><br><span class="line">    if s == &quot;h&quot;:</span><br><span class="line">        continue</span><br><span class="line">    print(s, end=&quot;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码等于在遇到<code>h</code>的时候跳过，然后print</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyhon</span><br></pre></td></tr></table></figure><ol start="9"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = 1</span><br><span class="line"></span><br><span class="line">def func(a, b):</span><br><span class="line">    n = b</span><br><span class="line">    return a * b</span><br><span class="line"></span><br><span class="line">s = func(&quot;Hello~&quot;, 2)</span><br><span class="line"></span><br><span class="line">print(s, n)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello~Hello~ 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>因为n=2是局部变量，n=1是全局变量</strong></p><ol start="10"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def func(s, i, j):</span><br><span class="line">    if i &lt; j:</span><br><span class="line">        func(s, i+1, j-1)  # 递归调用</span><br><span class="line">        s[i], s[j] = s[j], s[i]  # 交换元素</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    a = [10, 6, 23, -90, 0, 3]</span><br><span class="line">    func(a, 0, len(a)-1)  # 调用函数进行交换</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是找到规律</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[3, 0, -90, 23, 6, 10]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>递归</strong>：每次递归将 <code>i</code> 和 <code>j</code> 向中间靠拢，直到 <code>i &gt;= j</code>。</li><li><strong>交换</strong>：在递归返回时，交换 <code>i</code> 和 <code>j</code> 位置的元素，直到列表被反转。</li></ol><ul><li><code>func</code> 函数使用递归和回溯来实现反转。</li><li>最终输出的结果是反转后的列表。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/python/">python</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/python/">python</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/10/python2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>大数据期末复习</title>
      <link>https://blog.tokenlen.top/2024/12/08/bigdata/</link>
      <guid>https://blog.tokenlen.top/2024/12/08/bigdata/</guid>
      <pubDate>Sat, 07 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;p&gt;大数据的四个特点：数据量大，数据类型繁多，处理速度快和价值密度低。&lt;/p&gt;
&lt;p&gt;大数据对科学研究的影响：&lt;/p&gt;
&lt;p&gt;第一种范式：实验科学， 第二种范式：理论科学，第三种范式：计算科学，第</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本概念</h1><p>大数据的四个特点：数据量大，数据类型繁多，处理速度快和价值密度低。</p><p>大数据对科学研究的影响：</p><p>第一种范式：实验科学， 第二种范式：理论科学，第三种范式：计算科学，第 四种范式：数据密集型科学。</p><p>云计算的关键技术包括虚拟化，分布式存储，分布式计算和多租户等</p><p>大数据和云计算物联网之间的关系：</p><p>大数据、云计算和物联网（IoT）紧密相关，互为支撑：</p><ol><li><strong>物联网与大数据</strong>：物联网设备生成海量数据，需要大数据技术进行存储、处理和分析，提取有价值的信息。</li><li><strong>物联网与云计算</strong>：云计算提供弹性计算和存储资源，支持物联网设备的数据存储、实时分析和处理。</li><li><strong>大数据与云计算</strong>：云计算为大数据提供基础设施支持，提供存储、计算能力和弹性扩展，使大数据处理更加高效。</li></ol><h1>简答题</h1><h2 id="1-MapReduce工作流程的描述">1. <strong>MapReduce工作流程的描述</strong></h2><p>MapReduce工作流程主要分为两个阶段：Map阶段和Reduce阶段。</p><ul><li><strong>Map阶段</strong>：在Map阶段，输入数据被分为多个片段，每个片段由一个Map任务处理。Map任务将输入数据（键值对）映射为中间结果（也为键值对）。每个Map任务输出的中间结果都会被按键进行分组，分组后的结果会被传递给Reduce阶段。</li><li><strong>Shuffle阶段</strong>：Map阶段完成后，Shuffle阶段会按照键对Map的输出进行排序和分组，确保同一键的值被发送到同一台Reducer机器上。此过程是MapReduce中的一个重要过程，称为Shuffle。</li><li><strong>Reduce阶段</strong>：在Reduce阶段，系统会接收到Map输出的分组结果，并对每个键的所有值进行处理，通常是进行聚合操作，如求和、求平均等，最后输出结果。</li></ul><h2 id="2-Flink核心组件栈的层次及具体内容">2. <strong>Flink核心组件栈的层次及具体内容</strong></h2><ul><li><p><strong>Flink Runtime</strong>：执行任务调度和资源管理。</p></li><li><p><strong>Flink API</strong>：包括流处理的DataStream API和批处理的DataSet API，Table API/SQL支持声明性查询。</p></li><li><p><strong>Connectors</strong>：用于连接外部数据源和数据接收端（如Kafka、HDFS等）。</p></li><li><p><strong>State &amp; Time Layer</strong>：用于处理有状态计算及时间处理（如事件时间和窗口操作）。</p></li><li><p><strong>Fault Tolerance &amp; Checkpointing</strong>：确保作业容错性和状态一致性。</p><ul><li><p>内部容错机制包括：</p><ul><li>at-least-once 至少执行一次</li><li>exactully-once 仅执行一次（跟storm一样）</li></ul><p>还有手动的checkpoint检查机制（spark streaming一样）</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+     +-------------------+      +-------------------+</span><br><span class="line">|    Client         |----&gt;|    JobManager     |-----&gt;|   TaskManager     |</span><br><span class="line">+-------------------+     +-------------------+      +-------------------+</span><br><span class="line">       |                        |                        |</span><br><span class="line">       v                        v                        v</span><br><span class="line">+-------------------+    +-------------------+     +-------------------+</span><br><span class="line">|   Data Source     |    |    Task Execution  |     |   State &amp; Fault    |</span><br><span class="line">|  (Kafka, HDFS,    |    |   (Map, Reduce)    |     |   Tolerance       |</span><br><span class="line">|    DB, etc.)      |    |                    |     |                   |</span><br><span class="line">+-------------------+    +-------------------+     +-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-YARN架构及MapReduce程序执行过程">3. <strong>YARN架构及MapReduce程序执行过程</strong></h2><ul><li><p><strong>YARN架构</strong>： YARN（Yet Another Resource Negotiator）是<strong>Hadoop的资源管理层</strong>，负责资源调度和管理。YARN的主要组件有：</p><ul><li><strong>ResourceManager</strong>：负责集群资源的管理和调度。</li><li><strong>NodeManager</strong>：每个节点上的代理，负责向ResourceManager汇报节点的资源使用情况，并管理任务的执行。</li><li><strong>ApplicationMaster</strong>：每个应用程序（例如MapReduce）会有一个独立的ApplicationMaster，负责与ResourceManager协作，获取资源并管理作业的生命周期。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+        +-------------------+       +-------------------+</span><br><span class="line">|    Client         |-------&gt;|  ResourceManager  |&lt;-----&gt;|  NodeManager      |</span><br><span class="line">|  (Submit Job)     |        |   (Resource Mgmt) |       |   (Task Execution)|</span><br><span class="line">+-------------------+        +-------------------+       +-------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                          +---------------------+</span><br><span class="line">                          |   ApplicationMaster |</span><br><span class="line">                          |    (App Life Cycle) |</span><br><span class="line">                          +---------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                         +------------------------+</span><br><span class="line">                         |   Task Execution       |</span><br><span class="line">                         |   (Map/Reduce Tasks)   |</span><br><span class="line">                         +------------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                          +---------------------+</span><br><span class="line">                          |    Shuffle &amp; Sort   |</span><br><span class="line">                          +---------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                           +---------------------+</span><br><span class="line">                           |   HDFS Output       |</span><br><span class="line">                           +---------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>MapReduce程序执行过程</strong>：</p><ol><li><p><strong>提交作业</strong>：用户提交MapReduce作业，JobClient与ResourceManager通信，申请资源。</p></li><li><p><strong>资源分配</strong>：ResourceManager分配资源，启动ApplicationMaster。</p></li><li><p><strong>Map阶段</strong>：ApplicationMaster向NodeManager请求启动Map任务，Map任务处理输入数据并生成中间结果。</p></li><li><p><strong>Shuffle阶段</strong>：Map任务完成后，进行数据的shuffle和排序，保证每个Reduce任务处理的数据是同一键的所有值。</p></li><li><p><strong>Reduce阶段</strong>：Reducer处理Map输出的中间结果，完成最终的数据计算。</p></li><li><p><strong>作业完成</strong>：所有任务完成后，ResourceManager会收集任务的状态，标记作业结束。</p><p>总结：YARN架构包括ResourceManager、NodeManager、ApplicationMaster三个主要组件。</p></li></ol><p>ResourceManager负责资源调度，NodeManager负责管理节点资源，ApplicationMaster负责管理每个应用的生命周期。</p><p>MapReduce作业执行时，ApplicationMaster请求资源并启动Map、Shuffle、Reduce任务，NodeManager负责执行具体任务。</p></li></ul><h2 id="4-Hadoop系统要求、安装准备和配置文件介绍">4. <strong>Hadoop系统要求、安装准备和配置文件介绍</strong></h2><ul><li><strong>系统要求</strong>： Hadoop运行在分布式环境下，通常需要多个节点。每个节点至少需要安装Java（推荐使用JDK 8或更高版本）。节点之间需要通过SSH进行通信。</li><li><strong>安装准备</strong>：<ul><li>下载并解压Hadoop发行包。</li><li>配置Java环境变量。</li><li>配置Hadoop配置文件，如<code>core-site.xml</code>、<code>hdfs-site.xml</code>、<code>mapred-site.xml</code>和<code>yarn-site.xml</code>。</li></ul></li><li><strong>配置文件介绍</strong>：<ul><li><code>core-site.xml</code>：配置Hadoop核心服务，如HDFS文件系统的URI。</li><li><code>hdfs-site.xml</code>：配置HDFS的具体设置，如数据存储路径、副本数等。</li><li><code>mapred-site.xml</code>：配置MapReduce作业的相关设置。</li><li><code>yarn-site.xml</code>：配置YARN的资源管理和任务调度。</li></ul></li></ul><h1>大数据概念</h1><h3 id="三次信息浪潮及核心问题：">三次信息浪潮及核心问题：</h3><ol><li><strong>第一次浪潮</strong>：计算机引入，解决了自动化数据处理问题。</li><li><strong>第二次浪潮</strong>：互联网普及，解决了信息传递和共享问题。</li><li><strong>第三次浪潮</strong>：大数据、物联网、云计算兴起，解决了数据存储、处理、分析和价值提取问题。</li></ol><h3 id="大数据4V：">大数据4V：</h3><ol><li><strong>Volume</strong>：数据量大。</li><li><strong>Velocity</strong>：数据生成速度快。</li><li><strong>Variety</strong>：数据种类多。</li><li><strong>Veracity</strong>：数据真实性。</li></ol><h2 id="大数据特点">大数据特点</h2><ol><li><strong>数据量大</strong>：数据规模庞大，通常以TB、PB为单位。</li><li><strong>数据类型繁多</strong>：包括结构化、半结构化和非结构化数据。</li><li><strong>处理速度快</strong>：实时处理或近实时处理数据。</li><li><strong>价值密度低</strong>：数据中的有用信息较少。</li></ol><h3 id="大数据技术层面：">大数据技术层面：</h3><ol><li><strong>数据采集层</strong>：获取原始数据。</li><li><strong>数据存储层</strong>：存储数据，常用HDFS、NoSQL。</li><li><strong>数据处理层</strong>：数据清洗与分析，使用MapReduce、Spark。</li><li><strong>数据分析层</strong>：高级分析与建模，使用机器学习等。</li><li><strong>数据应用层</strong>：业务应用，如推荐系统、预测分析。</li></ol><h3 id="典型计算模式：">典型计算模式：</h3><ol><li><strong>批处理模式</strong>：Hadoop MapReduce。</li><li><strong>流处理模式</strong>：Kafka、Flink。</li><li><strong>混合处理模式</strong>：Spark。</li></ol><h3 id="三者关系：">三者关系：</h3><ul><li><strong>物联网</strong>生成数据。</li><li><strong>大数据</strong>处理、分析数据。</li><li><strong>云计算</strong>提供存储和计算资源。</li></ul><h2 id="云计算的关键：">云计算的关键：</h2><p>包括<strong>虚拟化</strong>、<strong>分布式存储</strong>、<strong>分布式计算</strong>和<strong>多租户</strong>技术。</p><h1>Hadoop</h1><h3 id="Hadoop项目架构图-（画图）">Hadoop项目架构图 （画图）</h3><p><strong>这个感觉必考</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------+</span><br><span class="line">|        Client Application  |</span><br><span class="line">+----------------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------------------------+</span><br><span class="line">|      ResourceManager        |  </span><br><span class="line">+----------------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">|        NodeManager         | &lt;--&gt; |         HDFS            |</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">           |                                 |</span><br><span class="line">           v                                 v</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">|     JobHistoryServer       | &lt;--&gt; |       HDFS NameNode      |</span><br><span class="line">+----------------------------+       +-------------------------+</span><br></pre></td></tr></table></figure><h3 id="Hadoop组件功能：-必考">Hadoop组件功能：(必考)</h3><ol><li><strong>HDFS</strong>：分布式文件系统，存储大数据。</li><li><strong>MapReduce</strong>：处理大规模数据集，基于分布式计算。</li><li><strong>YARN (Yet Another Resource Negotiator)</strong>：资源管理框架，管理集群资源。</li><li><strong>JobHistoryServer</strong>：存储和查看MapReduce任务的历史信息。</li><li><strong>ResourceManager</strong>：负责资源调度和分配。</li><li><strong>NodeManager</strong>：管理单个节点的资源，执行任务。</li><li><strong>Zookeeper</strong>：协调分布式系统中的分布式应用。</li><li><strong>HBase</strong>：一个分布式、可扩展的NoSQL数据库。</li><li><strong>Hive</strong>：基于Hadoop的数据仓库，支持SQL查询。</li><li><strong>Pig</strong>：为大数据处理提供更高层次的抽象，类似SQL。</li><li><strong>Mahout</strong>：机器学习算法库。</li><li><strong>Sqoop</strong>：用于在Hadoop与关系型数据库之间传输数据。</li><li><strong>Flume</strong>：用于数据流的采集、聚合和传输。</li><li><strong>Ambari</strong>：Hadoop集群的管理工具。</li><li><strong>MapReduce</strong>：分布式数据处理框架。</li></ol><h3 id="Hadoop特性：">Hadoop特性：</h3><ol><li><strong>可扩展性</strong>：支持PB级别的数据存储。</li><li><strong>容错性</strong>：数据复制，节点失败时数据不丢失。</li><li><strong>高性能</strong>：支持并行计算，大数据处理效率高。</li><li><strong>经济性</strong>：开源，低成本。</li></ol><h3 id="Hadoop集群节点类型：">Hadoop集群节点类型：</h3><ol><li><p><strong>NameNode</strong>：管理HDFS元数据，负责文件系统的命名和目录管理。</p></li><li><p><strong>DataNode</strong>：存储实际数据，执行数据读取和写入操作。</p></li><li><p><strong>ResourceManager</strong>：管理和调度集群资源。</p></li><li><p><strong>NodeManager</strong>：管理每个节点上的资源和任务执行。</p></li><li><p><strong>JobHistoryServer</strong>：保存MapReduce作业的历史信息。</p><h2 id="Hadoop伪分布式安装过程："><strong>Hadoop伪分布式安装过程</strong>：</h2></li></ol><ul><li><strong>core-site.xml</strong>：配置Hadoop的核心设置，如文件系统、默认的文件路径等。</li><li><strong>hdfs-site.xml</strong>：配置HDFS的设置，如块大小、复制因子、NameNode和DataNode的地址等。</li></ul><h3 id="SecondaryNameNode："><strong>SecondaryNameNode</strong>：</h3><ul><li>解决EditLog过大问题，通过定期合并EditLog和FsImage，减少EditLog大小。</li></ul><h3 id="SecondaryNameNode工作原理：">SecondaryNameNode工作原理：</h3><ol><li><strong>合并过程</strong>：SecondaryNameNode定期检查EditLog文件。如果EditLog有新的内容，它会将EditLog与当前的FsImage合并，并生成一个新的FsImage文件。</li><li><strong>更新FsImage</strong>：合并后，新的FsImage会被传回给NameNode，更新HDFS的元数据。</li><li><strong>清空EditLog</strong>：完成合并后，EditLog文件被清空，防止其过大。</li></ol><h1>Hdfs</h1><h2 id="hdfs结构">hdfs结构</h2><ul><li><strong>块</strong>：大数据文件被切分为多个固定大小的块。</li><li><strong>名称节点（NameNode）</strong>：管理文件系统的元数据。</li><li><strong>数据节点（DataNode）</strong>：实际存储数据块的节点。</li><li><strong>第二名称节点（SecondaryNameNode）</strong>：帮助减轻NameNode的负担，通过定期合并编辑日志来创建文件系统的检查点。</li></ul><h2 id="HDFS冗余数据保存策略："><strong>HDFS冗余数据保存策略</strong>：</h2><p>默认复制因子为3，确保数据冗余存储，避免丢失。</p><ul><li><strong>数据复制策略</strong>：第一个副本存储在写请求发起的DataNode上，第二个副本存储在<strong>不同机架</strong>的DataNode上，第三个副本存储在<strong>另一个机架</strong>的DataNode上。</li></ul><h2 id="HDFS的写数据流程："><strong>HDFS的写数据流程</strong>：</h2><p>采用流水线方式进行数据写入，数据从客户端开始依次写入多个DataNode，直到所有副本都完成写入。</p><h3 id="HDFS读写过程：（画图）（感觉必考）">HDFS读写过程：（画图）（感觉必考）</h3><h4 id="写过程：">写过程：</h4><ol><li>客户端与NameNode通信，获取文件块的存储位置。</li><li>客户端将数据分块，并发送到DataNode。</li><li>DataNode接收数据并存储，同时向客户端确认。</li></ol><p><strong>写过程示意图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client ----&gt; NameNode ----&gt; DataNode1 ----&gt; DataNode2 ----&gt; DataNode3</span><br><span class="line">       获取存储位置            存储数据块            存储数据块           存储数据块</span><br></pre></td></tr></table></figure><h4 id="读过程：">读过程：</h4><ol><li>客户端向NameNode请求文件的块位置。</li><li>NameNode返回文件块的位置信息。</li><li>客户端直接从相应的DataNode读取数据。</li></ol><p><strong>读过程示意图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client ----&gt; NameNode ----&gt; DataNode1 ----&gt; DataNode2</span><br><span class="line">        获取块位置              读取数据                读取数据</span><br></pre></td></tr></table></figure><h3 id="判断文件是否存在（HDFS编程实现）：（编程）">判断文件是否存在（HDFS编程实现）：（编程）</h3><p><strong>这个感觉也会考</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = new Configuration();</span><br><span class="line">FileSystem fs = FileSystem.get(conf);</span><br><span class="line">Path filePath = new Path(&quot;/user/hadoop/hdfsfle.txt&quot;);</span><br><span class="line"></span><br><span class="line">if (fs.exists(filePath)) &#123;</span><br><span class="line">    System.out.println(&quot;File exists.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;File does not exist.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>fs.exists(filePath)</strong>：检查指定路径的文件是否存在。</li></ul><h1>HBase</h1><h3 id="HBase-三级寻址与Region个数计算：（计算）（必考）">HBase 三级寻址与Region个数计算：（计算）（必考）</h3><ol><li></li><li>三级寻址<ul><li><strong>RowKey</strong> → <strong>RegionServer</strong> → <strong>HRegion</strong></li></ul></li><li>Region个数计算<ul><li>初始情况下，HBase有一个默认Region，随着数据增长，Region会自动分裂，Region数目与数据量和Region大小有关。</li><li>计算公式：Region数量=数据总量/每个Region的最大大小</li></ul></li></ol><h3 id="HBase系统架构及组件功能：">HBase系统架构及组件功能：</h3><ol><li><strong>HMaster</strong>：管理RegionServer的调度与分配，负责Region的分裂和负载均衡。</li><li><strong>RegionServer</strong>：处理客户端请求，存储数据。</li><li><strong>Zookeeper</strong>：协调HBase集群的节点，确保一致性和监控。</li><li><strong>HRegion</strong>：存储HBase的数据表分区。</li><li><strong>HBase Client</strong>：与HBase交互的客户端程序，执行读写操作。</li><li><strong>表</strong>：数据存储的基本单元。</li><li><strong>行键</strong>：唯一标识每一行的数据。</li><li><strong>列族</strong>：列的集合。</li><li><strong>列限定符</strong>：列族下的具体列名。</li><li><strong>单元格</strong>：数据存储的位置。</li><li><strong>时间戳</strong>：每个数据的版本标识。</li></ol><h2 id="HBase运行机制："><strong>HBase运行机制</strong>：</h2><ul><li><strong>RegionServe</strong>：处理数据表的分区，负责存储与读写。</li><li><strong>Store</strong>：物理存储的数据结构。</li><li><strong>HLog</strong>：记录所有变更的日志。</li></ul><h3 id="HBase-Shell命令操作：">HBase Shell命令操作：</h3><ol><li><p>创建表</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x27;my_table&#x27;, &#x27;cf1&#x27;, &#x27;cf2&#x27;</span><br></pre></td></tr></table></figure></li><li><p>添加数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put &#x27;my_table&#x27;, &#x27;row1&#x27;, &#x27;cf1:col1&#x27;, &#x27;value1&#x27;</span><br></pre></td></tr></table></figure></li><li><p>浏览数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;my_table&#x27;</span><br></pre></td></tr></table></figure></li><li><p>获得单元格数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#x27;my_table&#x27;, &#x27;row1&#x27;</span><br></pre></td></tr></table></figure></li><li><p>删除表格</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable &#x27;my_table&#x27;</span><br><span class="line">drop &#x27;my_table&#x27;</span><br></pre></td></tr></table></figure></li></ol><h1>Nosql</h1><h3 id="CAP理论的含义：">CAP理论的含义：</h3><ol><li><strong>Consistency</strong>（一致性）：所有节点的数据保持一致。</li><li><strong>Availability</strong>（可用性）：每个请求都会收到响应，不管数据是否最新。</li><li><strong>Partition Tolerance</strong>（分区容错性）：系统在网络分区的情况下仍然能够继续工作。</li></ol><h3 id="处理CAP问题的选择：">处理CAP问题的选择：</h3><ul><li><strong>CP</strong>（一致性 + 分区容错）：如HBase。</li><li><strong>AP</strong>（可用性 + 分区容错）：如Cassandra。</li><li><strong>CA</strong>（一致性 + 可用性）：适用于单机系统，无法容忍分区。</li></ul><p>NoSQL数据库提供灵活的数据模型，适用于大数据场景，相较于传统关系数据库，NoSQL在横向扩展和高并发上有优势。</p><h3 id="NoSQL数据库的四大类型：">NoSQL数据库的四大类型：</h3><ol><li><p>键值存储（Key-Value Stores）</p><p>：存储数据以键值对的形式，如Redis。</p><ul><li><strong>特征</strong>：高效查询、可扩展性强，适合存储简单的数据。</li></ul></li><li><p>列族存储（Column-Family Stores）</p><p>：数据按列存储，如HBase、Cassandra。</p><ul><li><strong>特征</strong>：适合高吞吐量、高并发的场景，存储稀疏数据。</li></ul></li><li><p>文档存储（Document Stores）</p><p>：数据以JSON、XML等文档格式存储，如MongoDB。</p><ul><li><strong>特征</strong>：适合存储复杂的结构化数据，灵活性高。</li></ul></li><li><p>图数据库（Graph Databases）</p><p>：用于存储图结构数据，如Neo4j。</p><ul><li><strong>特征</strong>：适合复杂的关系数据，查询效率高。</li></ul></li></ol><h2 id="BASE理论："><strong>BASE理论</strong>：</h2><ul><li><strong>基本可用</strong>：部分系统可用。</li><li><strong>软状态</strong>：系统状态可能暂时不一致。</li><li><strong>最终一致性</strong>：系统最终会达到一致状态。</li></ul><h1>MyReduce</h1><h3 id="MapReduce体系架构图-画图-感觉必考哈">MapReduce体系架构图(画图)感觉必考哈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       +-------------------+</span><br><span class="line">       |   Client          |</span><br><span class="line">       +-------------------+</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">       +-------------------+</span><br><span class="line">       |   JobTracker      |     (Resource Management)</span><br><span class="line">       +-------------------+</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">+--------------------------+  +--------------------------+</span><br><span class="line">|   TaskTracker (Map Task)  |  |   TaskTracker (Reduce Task)|</span><br><span class="line">+--------------------------+  +--------------------------+</span><br><span class="line">                |                       |</span><br><span class="line">                v                       v</span><br><span class="line">        +-------------------+    +-------------------+</span><br><span class="line">        |   HDFS Storage    |    |   HDFS Storage    |</span><br><span class="line">        +-------------------+    +-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MapReduce流程：">MapReduce流程：</h3><ol><li><strong>Map端</strong>：输入数据（如文件）被切分成多个块，分配给不同的Map任务处理。</li><li><strong>Shuffle过程</strong>：Map任务的输出会根据键进行分组，并被传输到相应的Reduce任务。</li><li><strong>Reduce端</strong>：根据分组的键，Reduce任务聚合数据，输出最终结果。</li></ol><h3 id="MapReduce实现两个数据库表的自然连接：">MapReduce实现两个数据库表的自然连接：</h3><ol><li><strong>Map端</strong>：将两个表的数据按主键进行映射。</li><li><strong>Reduce端</strong>：对相同主键的数据进行连接。</li></ol><h3 id="MapReduce实现WordCount：（编程）">MapReduce实现WordCount：（编程）</h3><ol><li><p><strong>Map函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String[] words = value.toString().split(&quot;\\s+&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            context.write(new Text(word), new IntWritable(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Reduce函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">    public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (IntWritable val : values) &#123;</span><br><span class="line">            sum += val.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, new IntWritable(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>简短总结：</p><ul><li><strong>MapReduce架构</strong>：分为Map任务、Shuffle过程、Reduce任务。</li><li><strong>连接过程</strong>：Map端根据主键映射，Reduce端进行连接。</li><li><strong>WordCount</strong>：Map函数分词计数，Reduce函数汇总计数。</li></ul><h1>Storm</h1><h3 id="Storm中的各个组件及功能：">Storm中的各个组件及功能：</h3><ol><li><strong>Topology</strong>：整个Storm应用，包含所有的spouts和bolts。</li><li><strong>Spout</strong>：数据源，负责向Storm系统发送原始数据。</li><li><strong>Bolt</strong>：处理数据的单元，接收数据并进行处理后输出。</li><li><strong>Nimbus</strong>：集群的主控节点，负责任务调度、分配。</li><li><strong>Supervisors</strong>：工作节点，负责运行bolts和spouts。</li></ol><h3 id="Storm的工作流程：">Storm的工作流程：</h3><ol><li>Spout从外部系统读取数据。</li><li>数据经过Bolt处理。</li><li>数据通过Storm集群进行分发和处理。</li></ol><h3 id="Storm的特点：">Storm的特点：</h3><ul><li><strong>实时性</strong>：低延迟处理。</li><li><strong>可扩展性</strong>：能够处理大规模数据流。</li><li><strong>容错性</strong>：自动处理失败任务，保证数据处理完整。</li></ul><h3 id="编写Storm代码示例（Topology-Bolt）：">编写Storm代码示例（Topology &amp; Bolt）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyBolt extends BaseBasicBolt &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Tuple input, BasicOutputCollector collector) &#123;</span><br><span class="line">        String word = input.getStringByField(&quot;word&quot;);</span><br><span class="line">        collector.emit(new Values(word, 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTopology &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TopologyBuilder builder = new TopologyBuilder();</span><br><span class="line">        builder.setSpout(&quot;spout&quot;, new MySpout(), 1);</span><br><span class="line">        builder.setBolt(&quot;bolt&quot;, new MyBolt(), 1).shuffleGrouping(&quot;spout&quot;);</span><br><span class="line"></span><br><span class="line">        Config conf = new Config();</span><br><span class="line">        StormSubmitter.submitTopology(&quot;my-topology&quot;, conf, builder.createTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Spark</h1><h3 id="Spark-Streaming和Storm的区别：感觉必考哈">Spark Streaming和Storm的区别：感觉必考哈</h3><ul><li><strong>实时性</strong>：Storm是基于流的实时处理，适合低延迟需求；Spark Streaming是基于微批处理，延迟相对较高。</li><li><strong>容错</strong>：Storm具有内建的容错机制，Spark Streaming通过checkpoint机制。</li><li><strong>架构</strong>：Storm的架构较为简洁，直接处理数据流，Spark Streaming依赖于Spark的批处理架构，支持复杂操作。</li></ul><h3 id="Spark中RDD的理解和运用：">Spark中RDD的理解和运用：</h3><ul><li><p><strong>RDD（Resilient Distributed Dataset）</strong>：分布式数据集，Spark的核心抽象，支持并行计算、容错和分布式存储。</p></li><li><p>RDD的操作</p><p>：</p><ul><li><strong>转换操作</strong>：如<code>map</code>、<code>filter</code>、<code>flatMap</code>，懒执行。</li><li><strong>行动操作</strong>：如<code>collect</code>、<code>count</code>、<code>reduce</code>，触发实际计算。</li></ul><p>区别</p><p>：转换操作会返回新的RDD，行动操作会触发实际的计算和结果返回。</p></li></ul><h3 id="窄依赖和宽依赖的区别：">窄依赖和宽依赖的区别：</h3><ul><li><strong>窄依赖</strong>：每个父RDD的分区对应着子RDD的一个分区（如<code>map</code>、<code>filter</code>）。</li><li><strong>宽依赖</strong>：父RDD的一个分区可能会对应子RDD的多个分区（如<code>groupByKey</code>、<code>reduceByKey</code>）。</li></ul><h3 id="如何进行stage划分：">如何进行stage划分：</h3><ul><li>根据<strong>宽依赖</strong>进行Stage划分，不同Stage之间的数据需要shuffle操作（如<code>groupByKey</code>）。</li><li>每个Stage的操作会在同一节点内部进行，不需要跨节点的数据传输。</li></ul><h3 id="park-shell命令解读：">park shell命令解读：</h3><ul><li><code>spark-shell</code>：启动Spark交互式shell。</li><li><code>sc.textFile(&quot;path&quot;)</code>：加载文本文件。</li><li><code>rdd.map(func)</code>：对每个元素应用<code>func</code>。</li><li><code>rdd.collect()</code>：获取RDD的所有数据。</li><li><code>rdd.reduce(func)</code>：对RDD数据进行聚合。</li></ul><h3 id="Spark编程实现统计字符个数：">Spark编程实现统计字符个数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val textFile = sc.textFile(&quot;path/to/file.txt&quot;)</span><br><span class="line">val charCount = textFile.flatMap(line =&gt; line.split(&quot;&quot;)).map(char =&gt; (char, 1)).reduceByKey(_ + _)</span><br><span class="line">charCount.collect().foreach(println)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>RDD</strong>：Spark的核心数据结构，支持转换和行动操作。</li><li><strong>窄/宽依赖</strong>：窄依赖跨分区小，宽依赖跨分区大。</li><li><strong>Stage划分</strong>：宽依赖会引起Stage划分</li></ul><h1>概念</h1><h3 id="可视化的基本概念：">可视化的基本概念：</h3><ul><li><strong>数据可视化</strong>：通过图形、图表、地图等方式呈现数据，帮助理解、分析和展示数据。</li><li><strong>目的</strong>：将复杂的数据转化为易于理解的形式，揭示数据中的模式、趋势和关系。</li><li>类型：<ul><li><strong>静态可视化</strong>：如条形图、折线图、饼图等。</li><li><strong>动态可视化</strong>：交互式图表，能够实时更新数据。</li></ul></li><li><strong>常用工具</strong>：如Tableau、Power BI、D3.js等。</li></ul><p>简短总结： 数据可视化通过图形化展示数据，帮助更直观地理解信息。</p><h3 id="基于商品和基于用户的协同过滤算法：">基于商品和基于用户的协同过滤算法：</h3><ol><li><p><strong>基于商品的协同过滤（Item-based CF）</strong>：</p><ul><li><p><strong>原理</strong>：根据用户对商品的评分，找到相似商品并推荐给用户。</p></li><li><p>步骤</p><p>：</p><ul><li>计算商品之间的相似度（如余弦相似度）。</li><li>根据用户历史评分，推荐相似商品。</li></ul></li><li><p><strong>优点</strong>：相对稳定，推荐的商品相似度较高。</p></li><li><p><strong>缺点</strong>：冷启动问题（新商品推荐困难）。</p></li></ul></li><li><p><strong>基于用户的协同过滤（User-based CF）</strong>：</p><ul><li><p><strong>原理</strong>：根据用户之间的相似度，推荐其他相似用户喜欢的商品。</p></li><li><p>步骤</p><p>：</p><ul><li>计算用户之间的相似度。</li><li>根据相似用户的评分，推荐商品。</li></ul></li><li><p><strong>优点</strong>：个性化较强，易于理解。</p></li><li><p><strong>缺点</strong>：计算复杂度高，冷启动问题。</p></li></ul></li></ol><h3 id="Pregel求最大值-最小值计算过程：（画图）">Pregel求最大值/最小值计算过程：（画图）</h3><ol><li><p><strong>基本思想</strong>：Pregel通过“顶点”的消息传递来处理大规模图数据，适用于图计算任务，如最大值/最小值计算。</p></li><li><p><strong>计算过程</strong>：</p><ul><li><strong>初始化</strong>：每个顶点初始化为其自身的值（最大值或最小值）。</li><li><strong>迭代</strong>：每个顶点将其当前值传递给相邻的顶点。每个接收到消息的顶点更新自己的值为当前值和收到的值中的最大值或最小值。</li><li><strong>终止条件</strong>：当图中所有顶点的值不再发生变化时，算法结束。</li></ul><p><strong>图示说明</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C</span><br><span class="line"> /     \</span><br><span class="line">D       E</span><br></pre></td></tr></table></figure><p>初始状态：顶点A、B、C、D、E的值分别为其初始值。通过迭代传递消息，直到最大值或最小值稳定。</p></li></ol><h3 id="迪杰斯特拉算法求解单源最短路径问题：">迪杰斯特拉算法求解单源最短路径问题：</h3><ol><li><strong>基本思想</strong>：从源顶点出发，逐步更新每个顶点的最短路径值，直到所有顶点的最短路径值确定。</li><li><strong>算法步骤</strong>：<ul><li><strong>初始化</strong>：将源顶点的最短路径值设为0，其余顶点设为无穷大。</li><li><strong>选择最短路径</strong>：选择尚未确定最短路径的顶点中最短的一个，更新其相邻顶点的最短路径。</li><li><strong>迭代</strong>：重复选择顶点并更新路径，直到所有顶点的最短路径确定。</li></ul></li></ol><h3 id="利用Pregel实现单源最短路径计算过程：">利用Pregel实现单源最短路径计算过程：</h3><ol><li><p><strong>初始化</strong>：</p><ul><li>源顶点的最短路径为0，其他顶点初始化为无穷大。</li></ul></li><li><p><strong>消息传递</strong>：</p><ul><li>每个顶点将其当前最短路径值传递给相邻的顶点。</li><li>接收到消息的顶点更新最短路径值，取当前值和从邻居收到的值的较小值。</li></ul></li><li><p><strong>迭代</strong>：</p><ul><li>继续进行消息传递，直到最短路径值不再变化。</li></ul></li><li><p><strong>计算过程</strong>（表格形式）：</p><table><thead><tr><th>顶点</th><th>当前最短路径值</th><th>邻居</th><th>接收到的消息</th><th>更新后的最短路径值</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>B, D</td><td>∞, ∞</td><td>0</td></tr><tr><td>B</td><td>∞</td><td>A, C</td><td>0, ∞</td><td>1</td></tr><tr><td>C</td><td>∞</td><td>B, E</td><td>1, ∞</td><td>2</td></tr><tr><td>D</td><td>∞</td><td>A, E</td><td>0, ∞</td><td>1</td></tr><tr><td>E</td><td>∞</td><td>C, D</td><td>2, 1</td><td>2</td></tr></tbody></table></li><li><p><strong>终止条件</strong>：当所有顶点的最短路径值稳定，算法结束。</p></li></ol><h1>Hive</h1><h3 id="Hive中SQL语句转换成MapReduce的基本原理：">Hive中SQL语句转换成MapReduce的基本原理：</h3><ul><li><p><strong>原理</strong>：Hive使用HiveQL语言查询数据，查询语句会被转换为一系列的MapReduce任务。<strong>Hive的查询处理器将SQL解析为一个逻辑执行计划，然后通过优化转换成物理执行计划（MapReduce作业）。</strong></p></li><li><p>过程</p><p>：</p><ol><li><strong>解析</strong>：HiveQL语句被解析成抽象语法树（AST）。</li><li><strong>优化</strong>：对AST进行优化，去除冗余操作。</li><li><strong>生成MapReduce作业</strong>：根据查询逻辑生成MapReduce作业，并执行。</li></ol></li></ul><h3 id="Hive中SQL查询转换成MapReduce作业的过程：">Hive中SQL查询转换成MapReduce作业的过程：</h3><ol><li><p>SQL查询</p><p>：例如查询表中某字段的总和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT SUM(amount) FROM transactions;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析阶段</strong>：Hive将此SQL语句转换为一个抽象的查询计划。</p></li><li><p><strong>优化阶段</strong>：Hive进行查询优化，合并某些操作。</p></li><li><p><strong>生成MapReduce作业</strong>：Hive将最终的查询计划转化为MapReduce作业。Map任务执行数据扫描，Reduce任务聚合计算结果。</p></li><li><p><strong>执行</strong>：Hive提交MapReduce作业到Hadoop集群执行。</p></li></ol><h3 id="Hive中Shell环境下常用操作代码：">Hive中Shell环境下常用操作代码：</h3><p><strong>就是Mysql的语法</strong></p><ol><li><p><strong>创建数据库</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE DATABASE mydb;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT,</span><br><span class="line">    name STRING,</span><br><span class="line">    salary DOUBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE employees ADD COLUMNS (address STRING);</span><br></pre></td></tr></table></figure></li><li><p><strong>查看表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure></li><li><p><strong>描述表结构</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DESCRIBE employees;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入数据</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO TABLE employees VALUES (1, &#x27;John&#x27;, 5000.0);</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/Hadoop/">Hadoop</category>
      
      <category domain="https://blog.tokenlen.top/tags/BigData/">BigData</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/08/bigdata/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English十二月篇</title>
      <link>https://blog.tokenlen.top/2024/12/01/en4/</link>
      <guid>https://blog.tokenlen.top/2024/12/01/en4/</guid>
      <pubDate>Sat, 30 Nov 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;每日一话+单词遗忘表12.1&lt;/h1&gt;
&lt;p&gt;Working hard is important, but there is something that matters even more: believing in</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>每日一话+单词遗忘表12.1</h1><p>Working hard is important, but there is something that matters even more: believing in yourself</p><ul><li>forest 森林</li><li>forge 熔炉</li><li>explore 探寻</li><li>formal 正式的</li><li>former 从前的</li><li><strong>formula</strong> 公式</li><li><strong>formulate</strong> 构想出</li><li>forth 向前</li><li>forthcoming 即将到来的</li><li>fortune 运气</li><li>forum 论坛</li><li>fossil 化石</li><li>fountain 喷泉</li><li>fraction 小部分</li><li>fragment 碎片</li><li>frame 构架</li><li>explicit 详细的</li></ul><h1>每日一话+单词遗忘表12.2</h1><p>A man may well bring a horse to the water, but he cannot make him drink.</p><ul><li>freight 运送</li><li>contempt 轻蔑</li><li>frog 青蛙</li><li><strong>frontier</strong> 边境</li><li>frost 结霜</li><li><strong>frustrate</strong> 挫败</li><li>fry 油炸</li><li>fuel 燃料</li><li>fulfil 履行</li><li>fulfill 履行实践</li><li>fundamental 基本的</li><li>contrary 相反的</li><li>funeral 葬礼</li><li>fur 皮毛</li><li>furnace 火炉</li></ul><h1>每日一话+单词遗忘表12.3</h1><p>Mistakes are an essential part of education.</p><ul><li>furnish 提供</li><li>furniture 家具</li><li>furthermore 而且</li><li>fuss 小题大作</li><li>gadget 小玩意</li><li>gallery 走廊</li><li>gamble 赌博</li><li>gang 一伙</li><li>gap 缺口</li><li>garage 车库</li><li>frustrate 阻止</li><li>garden 花园</li><li><strong>garment</strong> 衣服</li><li>gasoline 汽油</li><li>gaze 注视</li><li>gear 齿轮</li><li>gene 基因</li></ul><h1>每日一话+单词遗忘表12.4</h1><p>A man never discloses his own character so clearly as when he describes another’s.</p><ul><li>generous 慷慨的</li><li>genius 天才</li><li>gentle 温和的</li><li>genuine 真实的</li><li>germ 细菌</li><li>gesture 姿态</li><li>ghost 鬼</li><li><strong>giant</strong> 巨人</li><li>glance 一瞥</li><li><strong>glimpse</strong> 一瞥</li><li>glory 光荣的</li><li>glow 发热</li><li></li></ul><h1>每日一话+单词遗忘表12.5</h1><p>I think probably kindness is my number one attribute in a human being. I’ll put it before any of the things like courage or bravery or generosity or anything else.</p><ul><li>goodness 善良</li><li>goods商品</li><li><strong>gorgeous</strong> 华丽的</li><li>gossip 随笔</li><li>govern 统治</li><li>gown 长袍</li><li>gradual 逐渐的</li><li><strong>grain</strong> 粮食</li><li>gram 克</li><li>gramme 克</li><li>grant 授予</li><li><strong>grasp</strong> 抓住</li><li>gloom 悲伤的</li></ul><h1>每日一话+单词遗忘表12.6</h1><p>Snowflakes are one of nature’s most fragile things, but just look what they can do when they stick together.</p><ul><li>grave 严肃的</li><li>gravitation吸引力</li><li>gravity 重力</li><li>gray 灰色的</li><li><strong>greet</strong> 欢迎</li><li><strong>grief</strong> 悲伤</li><li>grin 笑</li><li><strong>grind</strong> 磨碎</li><li>grip 紧握</li><li>gross 总共的</li><li>guarantee 保证</li><li>guard 警戒</li><li><strong>guilt</strong> 内疚</li><li>guitar 吉他</li><li>gulf 海湾</li><li>gum 树胶</li></ul><h1>每日一话+单词遗忘表12.7</h1><p>When obstacles arise, you change your direction to reach your goal; you do not change your decision to get there.</p><ul><li><strong>gut</strong> 内脏内情</li><li>hack 砍出租</li><li>guy 男人</li><li>gymnasium 健身房</li><li>hail 招呼</li><li>hall 走廊</li><li><strong>halt</strong> 停止</li><li>ham 火腿</li><li>hammer 敲打</li><li>handicap 障碍</li><li>handle 把手</li><li>gum 牙龈</li><li>harbor 海港</li><li>harbour 藏匿</li><li>hardship 困苦的</li></ul><h1>每日一话+单词遗忘表12.8</h1><p>If one cannot enjoy reading a book over and over again, there is no use in reading it at all.</p><ul><li><strong>hardware</strong> 计算机硬件</li><li>harmony 协调</li><li>harness 马具</li><li>harsh 粗糙</li><li>harvest 收获</li><li>halt 停止</li><li>haste 匆忙</li><li>hatch 孵化</li><li>haul 拖拉</li><li>haunt 经常出没</li><li>hazard 冒险，危险</li><li>haze 疑惑，雾霾</li></ul><h1>每日一话+单词遗忘表12.9</h1><p>Anyone who conducts an argument by appealing to authority is not using his intelligence; he is just using his memory.</p><ul><li>heaven 天堂</li><li>hectare 公顷</li><li>hedge 避免正面回答</li><li>helicopter 直升机</li><li>hell 地狱</li><li>hence 因此</li><li><strong>heritage</strong> 遗产</li><li>hesitate 犹豫</li><li>hijack 抢劫</li></ul><h1>每日一话+单词遗忘表12.10</h1><p>The most efficient way to live reasonably is every morning to make a plan of one’s day and every night to examine the results obtained.</p><ul><li>hill 小山丘</li><li>hinder 阻碍</li><li><strong>hint</strong> 暗示</li><li>hip 臀部</li><li>hollow 空的</li><li>holy 神圣的</li><li>homeland 祖国</li><li>homosexual 同性恋的</li><li>honest 诚实的</li><li>horror 惊骇</li></ul><h1>每日一话+单词遗忘表12.11</h1><p>Heaven has made us talents, we’re not made in vain. A thousand gold coins spent, more will turn up again.</p><ul><li>horsepower 马力</li><li>hospitable 好客的</li><li>hotdog 卖弄</li><li>hammer 敲打</li><li>humble 谦逊的</li><li>humor 幽默的</li><li>hundred 一百</li></ul><p>题目词汇：</p><ul><li>renovate 修复</li><li>deserted 荒芜的</li><li>desperate 绝望的</li><li>interaction 合作活动</li><li>fulfilled 履行</li><li>embrace 拥护</li><li>contradictory 矛盾的</li><li>detailed 详细的</li><li>dipping 蘸</li><li>distinction 区别</li><li>involves 包含</li><li>moderate 中等的</li><li>vigorous 强有力的</li><li>notifiled 通知的</li><li>falling 下降的</li><li>optimum 最佳选择</li><li>constitutes 由…组成</li><li>prisoner 监狱</li></ul><h1>每日一话+单词遗忘表12.12</h1><p>Regret is an appalling waste of energy. You can’t build on it. It’s only good for wallowing in.</p><ul><li>hyphen 连字号</li><li>ill 坏的</li><li>illusion 幻觉</li><li>illustrate 说明</li><li>imitate 模仿</li><li>immediate 立即的</li><li><strong>immense</strong> 巨大的</li><li>immigrate 移入</li><li>immune 免疫</li><li>impatient 不耐烦的</li><li>imperial 皇帝的</li><li>implement 使生效</li><li><strong>implicit</strong> 盲目的</li></ul><h1>每日一话+单词遗忘表12.13</h1><ul><li>impose 强加</li><li><strong>impulse</strong> 冲动</li><li>incentive 刺激的</li><li><strong>incidence</strong> 发生率</li><li>incident 事件</li><li>incline 倾斜</li><li>income 收入</li><li>indeed 真正的</li><li>industry 工业</li><li><strong>infant</strong> 未成年的</li></ul><h1>四级高频词汇</h1><ul><li>resident 居民</li><li>direction 方向</li><li>sheet 床单一张纸</li><li>correspond 符合</li><li>accounted  解释</li><li>counterprouductive 适得其反</li><li>translate 转化</li><li>varous measures 多种举措</li><li>rational nutrition 合理的营养</li><li>vigorous 强有力的</li><li><strong>circumstance</strong> 环境</li><li>resume 简历</li><li>total 总计</li><li>identify 鉴定</li><li>digital 数码的</li><li>rate 速度，价格</li><li>feature 特征</li><li>individual 个人的</li><li>academic 学院的</li><li>obesity 肥胖的</li><li>recession 经济衰退的</li><li>regulation 章程</li><li>relsease 发布</li><li>pose 引起</li><li>compound 合成物</li><li>occasion 场合</li><li>derive 起源</li><li>divorce 离婚</li><li>association 协会</li><li>potential 潜在的</li><li>participate 参加</li><li>motivate 激发</li><li><strong>ingredient</strong> 成分</li><li>previous 先前的</li><li>boost 提高</li><li>emission 排放</li><li>document 文件</li><li>excellent 优秀的</li><li>budget 预算</li><li>commercial 贸易的</li><li>secretary 秘书</li><li>alternative 可供选择的</li><li>ultimately 最终</li><li>tobacco 烟草</li><li>revolution 革命</li><li>appetite 食欲</li><li>princiiple 原则</li><li>suspect 嫌疑犯</li><li>spouse 配偶</li><li>prospect 前景</li><li>pursue 追求</li><li>corporate 团体的</li><li>journal 日志</li><li>contract 合同</li><li>penalty 惩罚</li><li>perception 感知</li><li>vulnerable 脆弱的</li><li>conference 大型会议</li><li>restrict 限制</li><li>portion 部分</li><li>sustain 支撑</li><li>estate 庄园</li><li><strong>grasffti</strong> 涂鸦</li><li><strong>perspective</strong> 观点</li><li><strong>elementary</strong> 初级的</li><li>revenue 税收</li><li>interity 完整</li><li>margin 边缘的</li><li>tunnel 隧道</li><li>nurition 营养</li><li>counterpart 对应的人</li><li>heritage 遗产</li><li>suffcient 足够的</li><li>interpret 口译</li><li>institute 学院</li><li>demonstrate 展示</li><li>dramatic 戏剧性的</li><li>fulfill 履行</li><li>episode 一集</li><li>density 密度</li><li>cognitive 认知的</li><li>disorder 混乱的</li><li>relieve 减轻</li><li>negotiate 谈判</li><li>pediatrician 儿科医生</li><li>gadget 小物件</li><li>marvelous 极好的</li><li><strong>contaminat</strong>e 污染</li><li>restict 限制</li></ul><h1>单词遗忘表+每日一话12.14</h1><p>Water is a pioneer which the settler follows, taking advantage of its improvements.</p><ul><li>infer 推断</li><li>inferior 下级</li><li>infinite 无线的</li><li><strong>inflate</strong> 使充气</li><li>influenza 流行性感冒</li><li>ingredient 配料</li><li>inherit 继承</li><li>initial 最初的</li><li><strong>ink</strong> 墨水</li><li>impose 欺骗</li><li>innocent 无罪的</li><li><strong>inquiry</strong> 调查</li><li>insane 精神病的</li><li>infant 婴儿</li></ul><h1>单词遗忘表+每日一话12.15</h1><p>There is no greater agony than bearing an untold story inside you.</p><ul><li>instant 立即的</li><li>instead 反而</li><li>instinct 本能</li><li>institute 建立</li><li>instrument 仪器</li><li><strong>insult</strong> 侮辱</li><li>inferior 下级的</li><li><strong>intact</strong> 原装的</li><li>intangible 难以捉摸的</li><li><strong>integrity</strong> 正直</li><li>intellectual 智力的</li><li>haul 拖拉</li><li>intense 紧张的</li><li>interfere 干预</li><li>interior 内部的</li></ul><h1>每日一话+单词遗忘表12.16</h1><p>Hope sees the invisible, feels the intangible, and achieves the impossible.</p><ul><li>interpret 解释</li><li>interval 间隔</li><li>intimate 亲密的</li><li>invade 侵略</li><li>invalid 无效的</li><li>invest 投资</li><li>investigate 调查</li><li>deny 否认</li><li>inward 内向的</li><li>iron 铁</li><li><strong>irregular</strong> 不对称的</li><li><strong>irrigate</strong> 冲洗</li><li>isolate 孤立</li><li>idle 懒惰</li></ul><h1>每日一话+单词遗忘表12.17</h1><p>Sometimes people don’t want to hear the truth, because they don’t want their illusions destroyed.</p><ul><li>incentive 动机</li><li>jail 监狱</li><li>jam 果酱</li><li>jar 震荡</li><li>jaw 下巴</li><li>jazz 爵士舞</li><li><strong>jealous</strong> 嫉妒的</li><li><strong>jet</strong> 喷射</li><li>jetlag 时差综合症</li><li><strong>jewel</strong> 宝石</li><li>jog 慢跑</li><li><strong>joint</strong> 关节</li><li>impulse 脉冲</li></ul><h1>每日一话+单词遗忘表12.18</h1><ul><li>jungle 丛林</li><li>justify 证明合法</li><li>keen 敏锐的</li><li>kettle 罐</li><li>detect 发现</li><li>kin 亲戚</li><li>kindergarten 幼儿园</li></ul><h1>每日一话+单词遗忘表12.22</h1><p>One cannot think well, love well, sleep well, if one has not dined well.</p><ul><li>knot 结</li><li>label 标签</li><li>intangible 无形的</li><li>labour 劳动力</li><li>ladder 阶梯</li><li>lag 延后</li><li>lamb 羔羊</li><li><strong>lame</strong> 瘸的</li><li>lamp 灯</li><li>landlord 房东</li><li>lap 膝盖</li><li>knee 脚踝</li><li>laser 激光</li></ul><h1>每日一话+单词遗忘表12.23</h1><p>A happy life consists in the tranquility of mind.</p><ul><li>lanundry 洗衣店</li><li>lavatory 厕所</li><li>lawn 草坪</li><li>lay 放置</li><li>layoff 失业期</li><li>leaf 叶子</li><li>league 联盟</li><li>leak 漏洞</li><li>leap 跳跃</li><li>lease 租期</li><li>leather 皮革</li><li>irrigate 灌溉</li></ul><h1>每日一话+单词遗忘表12.24</h1><p>Christmas Eve was a night of song that wrapped itself about you like a shawl.</p><ul><li>legal 合法的</li><li>legend 传奇</li><li>legislate 制定法律</li><li>leisure 闲暇的</li><li>lend 贷</li><li>lest 以免</li><li>liable 有责任的</li><li>liberal 慷慨的</li><li>liberate 解放</li><li>license 执照</li><li>lid 盖子</li><li>lily 百合花</li><li>limb 四肢</li></ul><h1>每日一话+单词遗忘表12.25</h1><p>Christmas is not a time nor a season, but a state of mind. To cherish peace and goodwill, to be plenteous in mercy, is to have the real spirit of Christmas.</p><ul><li>lip 嘴唇</li><li>liquid 液体的</li><li>liquor 酒</li><li>literal 字面意义上的</li><li>livelihood 生计</li><li>liver肝脏</li><li><strong>loaf</strong> 块</li><li>loan 贷款</li><li>lodge 门房</li><li>log 原木</li><li>logic 逻辑学</li></ul><h1>每日一话+单词遗忘表12.26</h1><p>I gotta keep breathing because tomorrow the sun will rise. Who knows what the tide could bring?</p><p><strong>今天是伟大领袖毛主席的131年诞辰，几千年来麦子熟了多少次，人民万岁第一次！</strong></p><ul><li>lodge 房间</li><li>loophole 枪眼</li><li>loose 不牢固的</li><li><strong>lord</strong> 上帝</li><li>lorry 卡车</li><li>loyal 忠诚的</li><li>lump 块</li><li>luxury 奢侈的</li><li>mad 疯狂的</li><li>magnet 磁体</li><li>magnificent 壮丽的</li><li>maid 女仆</li></ul><h1>每日一话+单词遗忘表12.27</h1><p>A man on a thousand-mile walk has to forget his goal and say to himself every morning, “Today I’m going to cover twenty-five miles and then rest up and sleep.”</p><ul><li>mainstream 主流的</li><li>mammal 哺乳动物</li><li><strong>manipulate</strong> 熟练操作</li><li>manual 体力的</li><li>manufacture 制造</li><li>marathon 马拉松</li><li>margin 边缘</li><li>marine 海军</li><li>marshal 元帅</li><li>marvel 奇迹</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/01/en4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux编程基础期末复习</title>
      <link>https://blog.tokenlen.top/2024/11/25/linux11/</link>
      <guid>https://blog.tokenlen.top/2024/11/25/linux11/</guid>
      <pubDate>Sun, 24 Nov 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;真题在现&lt;/h1&gt;
&lt;h2 id=&quot;概述题&quot;&gt;概述题&lt;/h2&gt;
&lt;p&gt;1、简述 GNU、GPL 的含义，及其对 Linux 的影响。&lt;/p&gt;
&lt;p&gt;GNU 计划开始于 1984 年 1 月。其创始人是理查德•马修•斯托曼（Richard</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>真题在现</h1><h2 id="概述题">概述题</h2><p>1、简述 GNU、GPL 的含义，及其对 Linux 的影响。</p><p>GNU 计划开始于 1984 年 1 月。其创始人是理查德•马修•斯托曼（Richard Matthew<br>Stallman）。“GNU”是“GNU’s Not UNIX”的递归首字母缩写词。“GNU”的发音为 g’noo。<br>GNU 计划的目的是开发一个完全类似于 UNIX 的免费操作系统。其内核 Hurd 的开发工作始于<br>1990 年，但是至今尚未成熟。GNU 计划代表性的产品包括 GCC、Emacs、Bash Shell、GLIBC<br>等，这些都在 Linux 中被广泛使用。（3 分）<br>GPL（GNU General Public License，GNU 通用公共许可证）于 1985 年被提出。GPL 试<br>图保证您共享和修改自由软件的自由。GPL 适用于大多数自由软件基金会的软件。GNU 计划<br>一共提出了 3 个协议条款：GPL，LGPL（GNU Lesser General Public License，GNU 较宽松<br>公共许可证），GFDL（GNU Free Documentation License，GNU 自由文档许可证）。（4 分）</p><p><strong>这个题真就是概念的问题，真的很难记</strong></p><p>2.简述进程状态及其转换。</p><p>运行（running）态：进程占有处理器正在运行。<br>就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行。<br>等待（wait）态：又称为阻塞（blocked）态或睡眠（sleep）态，指进程不具备运行条件，正<br>在等待某个事件的完成。（4 分）</p><p>还要画个图</p><p><strong>wait状态可以变成ready状态，然后再变成running状态，或者是由running状态转换成wait或者ready状态</strong></p><p>3、Linux 目录结构与 Windows 有何不同？</p><p>(1). Linux 中文件名是区分大小写的，所有的 UNIX 系列操作系统都遵循这个规则。（2<br>分）<br>(2). Linux 文件通常没有扩展名。给 Linux 文件设置扩展名通常是为了方便用户使用。<br>Linux 文件的扩展名和它的种类没有任何关系。例如，zp.exe 可以是文本文件，而 zp.txt<br>也可以是可执行文件。（2 分）<br>2<br>(3). Linux 中没有盘符的概念（如 Windows 下的 C 盘）。Linux 的目录结构为树状结构，<br>顶级的目录为根目录“/”。其他目录通过挂载可以将它们添加到目录树中。例如，对于文件<br>zp.txt，它在 Linux 中的绝对路径可能是/home/john/zp.txt，而在 Windows 中的绝对路径<br>可能是 E:\document\zp.txt。（3 分）</p><p>4.用户账户的配置文件有哪些？它们各自用途如何？（7 分）<br>参考答案：<br>用户账户管理主要涉及 passwd 和 shadow 两个配置文件（3 分）。<br>passwd 是系统识别用户的一个重要文件，Linux 操作系统中所有的用户都记录在该文件<br>中（2 分）。<br>文件 shadow 是文件 passwd 的影子文件。主要保存用户密码配置情况（2 分）。</p><p>5.若使用 rmdir 命令来删除某个目录，但无法成功，请说明可能的原因。（7 分）</p><p>此目录可能不存在，（2 分）<br>或者目录不为空，（2 分）<br>或者目录中有隐含文件存在，（1 分）<br>或者目录被设置了权限，（1 分）<br>解决方法就是先修改权限，在使用 rm -r 命令删除。（1 分）</p><p><strong>桀桀桀，或者是直接rm -rf直接强制删除，管他啥呢</strong></p><h2 id="实操题">实操题</h2><p>1、 完成以下进程管理操作（5 分）<br>（1）用 vi 编辑 test.txt 文件，然后使用 ctrl+z 将其挂起。<br>（2）查看当前进程的状态。<br>（3）将 test.txt 进程（假设进程 pid 为 36357）的优先级设置为 8，再终止该进程。<br>（4）查看 CPU 和内存的使用情况和进程状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt ctrl+z</span><br><span class="line">ps -l</span><br><span class="line">renice 8 pid</span><br><span class="line">kill -9 pid</span><br><span class="line">top</span><br></pre></td></tr></table></figure><p>2、当前用户为管理员，且在根目录下，完成以下文件和目录操作（5 分）<br>（1）在/mnt 目录下创建三个文件夹，dir1、dir2、dir3，并查看是否创建成功；<br>（2）在 dir1 文件夹内创建 <a href="http://test.sh">test.sh</a> 文件，并查看是否创建成功；<br>（3）将/mnt/dir1 下 <a href="http://test.sh">test.sh</a> 文件复制到 dir2 目录下，复制后的新文件名为 <a href="http://newtest.sh">newtest.sh</a>,并查看<br>是否复制成功；<br>（4）给文件 <a href="http://newtest.sh">newtest.sh</a> 添加可执行权限。<br>（5）删除文件 <a href="http://newtest.sh">newtest.sh</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/dir&#123;1..3&#125;</span><br><span class="line">ls /mnt</span><br><span class="line">touch /mnt/dir1/test.sh</span><br><span class="line">ls /mnt/dir1</span><br><span class="line">cp /mnt/dir1/test.sh /mnt/dir2/newtest.sh</span><br><span class="line">ls /mnt/dir2</span><br><span class="line">chmod 700 /mnt/dir2/newtest.sh</span><br><span class="line">rm -rf /mnt/dir2/newtest.sh</span><br></pre></td></tr></table></figure><p>3、请写出以下操作的完整指令（包括命令选项及参数）：假设你是系统管理员，需要增加一<br>个新的用户账号 Jack，为新用户设置初始密码，锁定用户账号 Jerry，并删除用户账号 Kate。<br>（5 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd Jack</span><br><span class="line">passwd Jack</span><br><span class="line">passwd -1 Jack</span><br><span class="line">usedel Jack</span><br></pre></td></tr></table></figure><p>4 、执行命令 ls -1 时，某行显示如下:<br>-rw-r–r-- 1 teacher teacher 744 3 月 18 11:58 studentdata<br>(1)用户 teacher 对该文件具有什么权限?<br>(2)执行命令 useradd student 后，用户 student 对该文件具有什么权限?<br>(3)如何使任何用户都可以读写执行该文件?<br>(4)如何把该文件所有者改为用户 root ?<br>（5 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">读写</span><br><span class="line"></span><br><span class="line">只读</span><br><span class="line">chmod 777 stduentdata</span><br><span class="line">chown root studentdata</span><br></pre></td></tr></table></figure><p>5、叙述 Linux 虚拟机如何增加一块硬盘（设备名为/dev/sdb，文件系统格式 ext4)，如何<br>实现开机自动挂载硬盘。写出详细的步骤和相关命令。（10 分）<br>参考答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先虚拟机新建一块硬盘</span><br><span class="line">分区fdisk /dev/sdb</span><br><span class="line">格式化 mkfs -t ext4 /dev/sdb1</span><br><span class="line">挂载挂载， 先创建一个/home/newdisk,挂载 mount /dev/sdb1 /home/newdisk </span><br><span class="line">然后设置自动挂载</span><br><span class="line">设置自动挂载，打开/etc/fstab 添加一行 </span><br><span class="line">/dev/sdb1 /home/newdisk ext4 defaults 0 0 </span><br></pre></td></tr></table></figure><h2 id="编程题">编程题</h2><p>1.创建一个 shell 脚本，它从用户那里接收 20 个数，并显示已输入的最小的数。（10 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">min=2147483647</span><br><span class="line">for((count=0;count&lt;20;count=count+1))</span><br><span class="line">do</span><br><span class="line">echo -n &quot;输入数字:&quot;</span><br><span class="line">read value</span><br><span class="line">if [ $min -gt $value ]</span><br><span class="line">then</span><br><span class="line">min=$value</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol start="2"><li>编写 shell 脚本程序来分析某班某一课程平均成绩，从键盘输入若干个考试分数（分数为<br>整数），计算并输出所有分数的平均值。要求如下：<br>（1）使用 while 或 until 循环实现整数输入，如果输入为字符 q，则退出键盘输入；<br>（2）如果输入分数不在 0—100 范围内，提示用户输入有误；<br>（3）平均值计算不需要考虑小数部分，只需要得到整数部分即可。<br>（10 分）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">sum=0</span><br><span class="line">count=0</span><br><span class="line">while true;</span><br><span class="line">do</span><br><span class="line">read -p &quot;输入一个整数&quot; score</span><br><span class="line">if [[ $score==&quot;q&quot; ]];then</span><br><span class="line">break</span><br><span class="line">elif [[ !&quot;$score&quot; =~^[0-9]+$ ]];then</span><br><span class="line">echo &quot;输入错误&quot;</span><br><span class="line">elif(( score &lt;0|| score &gt;100 ));then</span><br><span class="line">echo &quot;输入错误&quot;</span><br><span class="line">else</span><br><span class="line">sum=$((sum+score))</span><br><span class="line">count=$((count+1))</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">if((count == 0));then</span><br><span class="line">echo &quot;没有输入&quot;</span><br><span class="line">else</span><br><span class="line">avg=$((sum/count))</span><br><span class="line">echo &quot;平均分为&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h1>作业再现复习</h1><p>1.什么是shell? 它有什么作用?<br>2.简述管道的用途.<br>3.重定向是什么?有哪些常见类型?<br>4.获取Linux命令行帮助信息的方法有哪些?<br>5.简述命令行命令的语法格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shell是一个用户和操作系统内核之间的一个接口，类似与命令解释器，</span><br><span class="line">输入命令，shell负责解析命令，启动程序和进程等操作</span><br><span class="line">作用：</span><br><span class="line">命令执行</span><br><span class="line">脚本编程</span><br><span class="line">文件操作</span><br><span class="line">进程管理</span><br><span class="line"></span><br><span class="line">|管道符号</span><br><span class="line">将多个命令连接起来，前面命令的输出作为下一个命令的输入，用来连接两个或者更多的命令。也可以用来过滤数据</span><br><span class="line"></span><br><span class="line">重定向是将命令的输入和输出重定向到文件或者设备中，有&gt;&gt; &lt;&lt; &gt; &lt; 2&gt;&gt;</span><br><span class="line">2&gt;这些等</span><br><span class="line"></span><br><span class="line">获取帮助</span><br><span class="line">man ls</span><br><span class="line">ls --help</span><br><span class="line">info ls</span><br><span class="line">whatis ls</span><br><span class="line"></span><br><span class="line">格式是：</span><br><span class="line">命令 选项 参数</span><br></pre></td></tr></table></figure><p>1.常见的Linux文件类型有哪些?<br>2.用户账户的配置文件有哪些?各有什么用途?<br>3.简述用户账户配置文件的记录格式。<br>4.组账户的配置文件有哪些?它们各自有什么用途?<br>5.简述组账户配置文件的记录格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">普通文件，目录，符号连接，字符设备文件，管道文件，块设备文件</span><br><span class="line"></span><br><span class="line">/etc/passwd 基本信息</span><br><span class="line">/etc/shadow 密码等</span><br><span class="line">/etc/group 组的信息</span><br><span class="line"></span><br><span class="line">/etc/passwd</span><br><span class="line">用户名:密码:UID:GID:描述:家目录:默认Shell</span><br><span class="line">/etc/shadow</span><br><span class="line">用户名:密码:最后修改时间:最小密码年龄:最大密码年龄:警告期:不活动期:过期时间</span><br><span class="line">/etc/group</span><br><span class="line">组名:密码:GID:成员列表</span><br><span class="line"></span><br><span class="line">/etc/group：存储组的信息，包括组名、GID 和组成员列表。</span><br><span class="line">/etc/gshadow：存储与组相关的密码信息（通常为空）。</span><br><span class="line"></span><br><span class="line">/etc/group 的记录格式为：</span><br><span class="line">组名:密码:GID:成员列表</span><br><span class="line">/etc/gshadow 的记录格式为：</span><br><span class="line">组名:密码:管理员列表:成员列表</span><br></pre></td></tr></table></figure><p>1.简述Linux软件包管理的发展历史。<br>2.常见的软件包安装方法有哪些?<br>3.简述apt命令的基本用法。<br>4.简述基于源代码的程序安装流程<br>5.使用apt命令安装apache。<br>6.使用apt命令安装vim。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Linux 软件包管理工具相对简单，用户通常需要手动下载并编译源代码。</span><br><span class="line">二进制包管理：随着 Debian 和 Red Hat 的出现，二进制包管理系统（如 .deb 和 .rpm）得到了广泛采用。</span><br><span class="line">现代化管理：如 apt、yum 和 zypper 等工具使得软件包管理更加简化，支持自动更新和依赖关系管理。</span><br><span class="line"></span><br><span class="line">源代码编译</span><br><span class="line">.deb或者是rpm安装</span><br><span class="line">第三方安装工具</span><br><span class="line"></span><br><span class="line">apt install 包名</span><br><span class="line">apt update 更新</span><br><span class="line">apt grade 升级</span><br><span class="line">apt remove 包名</span><br><span class="line"></span><br><span class="line">下载源代码</span><br><span class="line">解压</span><br><span class="line">cd进入</span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br><span class="line">如果少包的话，那就进行安装</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install vim</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.Shell的变量类型有哪几种?<br>2.简述Shel1脚本的常见方式。<br>3.简述She11分支结构的实现方式。<br>4.简述She1l循环结构的实现方式。<br>5.设计一个Shell程序，添加一个新组group1，然后添加个组的50个用户，用户名的形式为stu**，**从01-50。</p><p>6.设计一个Shel1程序，该程序能接收用户从键盘输入的数，然后求出其总和、最大值和最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">位置参数，环境变量，局部变量，特殊变量，只读变量</span><br><span class="line"></span><br><span class="line">直接执行，交互执行，脚本中嵌入命令，解释器执行</span><br><span class="line"></span><br><span class="line">if-elif-else</span><br><span class="line">case</span><br><span class="line"></span><br><span class="line">for,while,until</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">sudo groupadd group1</span><br><span class="line">for i in $(seq -f &quot;%02g&quot; 1 50)</span><br><span class="line">do </span><br><span class="line">sudo useradd stu$i -g group1</span><br><span class="line">sudo passwd -d stu$i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">sum=0</span><br><span class="line">max=-9999999</span><br><span class="line">min=9999999</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">    read -p &quot;请输入数字 (或输入&#x27;q&#x27;退出): &quot; num</span><br><span class="line">    </span><br><span class="line">    if [ &quot;$num&quot; == &quot;q&quot; ]; then</span><br><span class="line">        break</span><br><span class="line">    elif ! [[ &quot;$num&quot; =~ ^[0-9]+$ ]]; then</span><br><span class="line">        echo &quot;无效输入，请输入一个数字！&quot;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    sum=$((sum + num))</span><br><span class="line">    </span><br><span class="line">    if [ $num -gt $max ]; then</span><br><span class="line">        max=$num</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    if [ $num -lt $min ]; then</span><br><span class="line">        min=$num</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;总和: $sum&quot;</span><br><span class="line">echo &quot;最大值: $max&quot;</span><br><span class="line">echo &quot;最小值: $min&quot;</span><br></pre></td></tr></table></figure><p>1.使用mkdir创建一个父目录不存在的目录时，需添加什么参数?<br>2.Linux操作系统中有哪些常见的文件类型?<br>3.使用什么命令可以删除包括子目录的目录?<br>4.Linux目录结构和windows目录结构有何不同?<br>5.简述软链接文件和硬链接文件的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/memgnankk/aaa</span><br><span class="line"></span><br><span class="line">普通文件</span><br><span class="line">块设备文件</span><br><span class="line">目录文件</span><br><span class="line">符号链接</span><br><span class="line">管道文件</span><br><span class="line">字符设备文件</span><br><span class="line">套接字文件</span><br><span class="line"></span><br><span class="line">rm -rf /home/mengnankk/temp</span><br><span class="line"></span><br><span class="line">Linux的根目录/，所有的文件都从/开始</span><br><span class="line">windows有各个驱动器分区，而Linux只有一个跟目录</span><br><span class="line">Linux分隔符是/</span><br><span class="line">windows是\</span><br><span class="line"></span><br><span class="line">软链接是一个指向原文件的链接，删除原文件后失效,ln- s创建</span><br><span class="line">硬链接是指向文件数据块的，相对于另一个名字，删除原文件后不会失效，直到硬数据全部删除</span><br><span class="line">使用ln创建</span><br></pre></td></tr></table></figure><p>1.简述进程的分类。<br>2.PID是什么，如何查看进程的pid?<br>3.如何向进程发送信号?如何结束进程?<br>4.如何调整进程的优先级?<br>5.常见的进程启动方式有哪些?<br>6.如何使用top命令监控进程的运行状态?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">前台进程，后台进程，守护进程</span><br><span class="line"></span><br><span class="line">Pid是操作系统给每个进程分配的唯一进程符号，用ps aus 或者top查看</span><br><span class="line"></span><br><span class="line">kill pid 删除进程 kill -9 强制删除 -15优雅的删除</span><br><span class="line"></span><br><span class="line">renice -n 10 -p pid直接调整</span><br><span class="line">修改正在进行的程序的优先级</span><br><span class="line">nice -n 10 command 命令的优先级</span><br><span class="line"></span><br><span class="line">命令直接启动</span><br><span class="line">命令 &amp;来启动</span><br><span class="line">nohup 命令来启动</span><br><span class="line"></span><br><span class="line">top直接查看包括 CPU 使用率、内存占用等信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.请解释磁盘分区的含义?<br>2.请解释格式化的含义?<br>3.新磁盘在可以进行文件存取之前需要经过哪些操作?<br>4.简述Linux磁盘设备命名方法。<br>5.简述Linux磁盘分区命令方法。<br>6.简述MBR和GPT的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">磁盘分区是指将一个物理硬盘分割成多个逻辑区域，每个区域可以作为一个独立的磁盘来使用。每个分区可以用于存储不同类型的数据（如操作系统、数据文件、备份等），从而提高磁盘的管理效率和数据安全性。分区还可以帮助操作系统更好地管理硬盘资源，如文件系统的创建、文件存取等。</span><br><span class="line"></span><br><span class="line">格式化是对磁盘或者分区进行初始化的的过程，在磁盘上创建一个文件系统，然后情空之前的其他数据</span><br><span class="line"></span><br><span class="line">先虚拟机新建一块硬盘</span><br><span class="line">分区fdisk /dev/sdb</span><br><span class="line">格式化 mkfs -t ext4 /dev/sdb1</span><br><span class="line">挂载挂载， 先创建一个/home/newdisk,挂载 mount /dev/sdb1 /home/newdisk </span><br><span class="line">然后设置自动挂载</span><br><span class="line">设置自动挂载，打开/etc/fstab 添加一行 </span><br><span class="line">/dev/sdb1 /home/newdisk ext4 defaults 0 0 </span><br><span class="line"></span><br><span class="line">dev/sda、/dev/sdb：表示SATA、SCSI或USB等磁盘设备，a、b、c等字母表示磁盘的顺序。</span><br><span class="line">/dev/sda1、/dev/sda2：表示 /dev/sda 磁盘上的第一个和第二个分区。</span><br><span class="line">/dev/nvme0n1：表示 NVMe 固态硬盘（SSD）设备，n1 是该设备的标识符。</span><br><span class="line">/dev/loop0、/dev/loop1：表示环回设备，通常用于挂载ISO文件等。</span><br><span class="line"></span><br><span class="line">fdisk/parted/lsblk</span><br><span class="line"></span><br><span class="line">MBR 主要用于旧版操作系统（如Windows 7之前的版本），且支持的磁盘容量有限（最大2TB）。</span><br><span class="line">GPT 是现代磁盘的标准，支持大容量磁盘，并且支持更多的分区，适用于较新版本的操作系统（如Windows 10、Linux等）。</span><br></pre></td></tr></table></figure><h1>补充</h1><p><code>lsof</code>（List Open Files）是一个用于列出进程打开的文件的命令，可以显示哪些文件被哪些进程占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br><span class="line">lsof /path/to/file  # 查看某个文件被哪个进程打开</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Linux系统中，用于将标准输出和标准错误重定向到文件的符号是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&gt;</span><br></pre></td></tr></table></figure><p>Linux系统中，将标准错误重定向到文件里的符号是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&gt;</span><br></pre></td></tr></table></figure><p><strong>free命令可以显示系统的内存使用情况</strong></p><p><strong>df是查看硬盘的使用情况</strong></p><p><code>diff</code> 是用于比较文件内容差异的命令，它会显示两个文件之间的不同之处。常用于源代码管理、配置文件比较等场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff file1.txt file2.txt  # 比较 file1.txt 和 file2.txt 文件的差异</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ls -i</code> 命令用于显示文件或目录的 inode 信息。它会在文件名旁边显示该文件的 inode 号</p><p>stat令用于显示文件的详细信息，包括文件的大小、权限、时间戳、inode 等，但它并不是专门用于查看 inode 信息的命令。</p><p><code>lscpu</code> 是一个用于显示 CPU 架构信息的命令，它提供了有关 CPU 的简明概览，包括架构类型、核心数、线程数、CPU 架构、时钟速度等信息。</p><h2 id="补充简答">补充简答</h2><p>在 Linux 中查看设备信息，可以通过多种命令来查看不同类型的硬件设备信息，如 CPU、内存、硬盘、网络设备等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lscup</span><br><span class="line">free -h</span><br><span class="line">lsblk</span><br><span class="line">df -h </span><br><span class="line">sudo fdisk -l </span><br><span class="line">ipconfig</span><br><span class="line">ip addr </span><br><span class="line">lspci -v</span><br><span class="line">lsusb</span><br><span class="line">sudo lshw</span><br><span class="line">uname -a</span><br><span class="line">sudo dimidcode</span><br><span class="line">lspci |grep VGA</span><br><span class="line">ls /dev</span><br><span class="line">sudo parted -l</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简述 Linux 中文件系统的卸载选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux 中，卸载文件系统使用 `umount` 命令</span><br><span class="line">其实就是取消挂载</span><br><span class="line">-l是懒卸载，就是自动卸载</span><br><span class="line">-f是强制卸载</span><br><span class="line">-a 是卸载所有</span><br></pre></td></tr></table></figure><p>怎样在 Linux 中为内核模块传递参数?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 Linux 中，可以通过 `modprobe` 命令或在 `/etc/modules-load.d/` 配置文件中为内核模块传递参数。</span><br><span class="line">sudo modprobe my_module param=5</span><br><span class="line">options my_module param=5</span><br><span class="line">也可以将模块参数配置在系统文件中，以便在系统启动时自动传递。将配置写入 /etc/modprobe.d/ 目录下的某个文件，如 my_module.conf。</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Linux/">Linux</category>
      
      
      <comments>https://blog.tokenlen.top/2024/11/25/linux11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>查找算法</title>
      <link>https://blog.tokenlen.top/2024/11/11/data6/</link>
      <guid>https://blog.tokenlen.top/2024/11/11/data6/</guid>
      <pubDate>Sun, 10 Nov 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;查找算法主要用于在集合（如数组、列表、树等）中寻找特定的元素。以下是几种常见的查找算法以及相应的代码示例。&lt;/p&gt;
&lt;h1&gt;线性查找&lt;/h1&gt;
&lt;p&gt;线性查找是一种简单的查找方法，它逐个检查每个元素，直到找到目标元素或遍历完整个集合。&lt;/p&gt;
&lt;figure</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>查找算法主要用于在集合（如数组、列表、树等）中寻找特定的元素。以下是几种常见的查找算法以及相应的代码示例。</p><h1>线性查找</h1><p>线性查找是一种简单的查找方法，它逐个检查每个元素，直到找到目标元素或遍历完整个集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LinearSearch &#123;</span><br><span class="line">    public static int linearSearch(int[] arr, int target) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] == target) &#123;</span><br><span class="line">                return i;  // 返回目标元素的索引</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;  // 如果找不到，返回-1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;2, 5, 8, 3, 6, 9&#125;;</span><br><span class="line">        int target = 3;</span><br><span class="line">        int result = linearSearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><strong>二分查找</strong></h1><p>二分查找是对已经排序的数组进行查找的有效算法。每次通过中间元素来缩小查找范围，直到找到目标元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static int binarysearch(int[] arr,int target)&#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = arr.length - 1;</span><br><span class="line">        while (left&lt;=right)&#123;</span><br><span class="line">            int mid = left + (right - left)/2;</span><br><span class="line">            if (arr[mid] == target)&#123;</span><br><span class="line">                return  mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[mid]&lt;target)&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 3, 5, 7, 9, 11&#125;;</span><br><span class="line">        int target = 7;</span><br><span class="line">        int result = binarysearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>哈希查找</h1><p>哈希查找通过使用哈希表来进行查找，时间复杂度通常为 O(1)，是查找速度最快的方法之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">public class HashSearch &#123;</span><br><span class="line">    public static boolean hashSearch(HashSet&lt;Integer&gt; set,int target)&#123;</span><br><span class="line">        return set.contains(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(1);</span><br><span class="line">        set.add(5);</span><br><span class="line">        set.add(3);</span><br><span class="line">        set.add(6);</span><br><span class="line">        set.add(7);</span><br><span class="line">        int target  = 3;</span><br><span class="line">        if (hashSearch(set,target))&#123;</span><br><span class="line">            System.out.println(target+&quot;yes&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(target+&quot;no&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hash查找主要是看该数据的hash值，hash值一般是不相同的，所以能通过hash值来进行查找</p><h1>dfs</h1><p>是一种遍历或查找图、树的算法，常用于图形和树形结构的查找。它通过尽可能深入地访问每个分支来遍历整个结构。</p><p>主要是用递归来解决</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class DFS &#123;</span><br><span class="line">    static class TreeNode &#123;</span><br><span class="line">        int value;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        TreeNode(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean dfs(TreeNode node, int target) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.value == target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 递归地搜索左子树和右子树</span><br><span class="line">        return dfs(node.left, target) || dfs(node.right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        root.left = new TreeNode(2);</span><br><span class="line">        root.right = new TreeNode(3);</span><br><span class="line">        root.left.left = new TreeNode(4);</span><br><span class="line">        root.left.right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">        int target = 4;</span><br><span class="line">        if (dfs(root, target)) &#123;</span><br><span class="line">            System.out.println(&quot;找到了目标元素 &quot; + target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;未找到目标元素 &quot; + target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>bfs</h1><p>用于查找图或树结构中的元素。与深度优先搜索不同，广度优先搜索逐层扫描，首先访问每一层的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class BFS &#123;</span><br><span class="line">    static class TreeNode &#123;</span><br><span class="line">        int value;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        TreeNode(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean bfs(TreeNode root, int target) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.value == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        root.left = new TreeNode(2);</span><br><span class="line">        root.right = new TreeNode(3);</span><br><span class="line">        root.left.left = new TreeNode(4);</span><br><span class="line">        root.left.right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">        int target = 5;</span><br><span class="line">        if (bfs(root, target)) &#123;</span><br><span class="line">            System.out.println(&quot;找到了目标元素 &quot; + target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;未找到目标元素 &quot; + target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>插入查找</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class InterpolationSearch &#123;</span><br><span class="line">    public static int interpolationSearch(int[] arr,int target)&#123;</span><br><span class="line">        int left = 0,right = arr.length - 1;</span><br><span class="line">        while (left&lt;=right&amp;&amp;target&gt;=arr[left]&amp;&amp;target&lt;=arr[right])&#123;</span><br><span class="line">            if (arr[right] == arr[left])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            int mid = left + ((target - arr[left]*(right-left))/(arr[right]-arr[left]));</span><br><span class="line">            if(arr[mid] == target)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[mid]&lt;target)&#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&#125;;</span><br><span class="line">        int target = 70;</span><br><span class="line">        int result = interpolationSearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实现</p><h1>选择排序</h1><p>每次在未排序部分选择最小（或最大）元素，然后与未排序部分的第一个元素交换，直到整个数组有序。</p><p>每次只进行一次交换操作。</p><p>时间复杂度：O(n^2)，无论数据是否已经有序。</p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void selectionSort(int[] arr) &#123;</span><br><span class="line">        int comparisons = 0;</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                comparisons++;</span><br><span class="line">                if (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;！：&quot; + comparisons);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;5, 2, 9, 1, 5, 6&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        for (int num : arr) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>起泡排序</h1><p>每次比较相邻的两个元素，如果顺序错误则交换它们，经过一轮比较后，最大（或最小）元素会“浮”到数组的末端。重复这个过程，直到数组有序。</p><p>其实可以也叫做冒泡排序</p><p>时间复杂度：O(n^2)，如果数据已经有序，可以优化为 O(n)。</p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void bubbleSort(int[] arr)&#123;</span><br><span class="line">        int comparisons =0;</span><br><span class="line">        for (int i =0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            for ( int j = 0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">                comparisons++;</span><br><span class="line">                if (arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                    int temp =  arr[j];</span><br><span class="line">                    arr[j] = arr[j+1];</span><br><span class="line">                    arr[j+1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(comparisons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://blog.tokenlen.top/2024/11/11/data6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English十一月篇</title>
      <link>https://blog.tokenlen.top/2024/11/01/en3/</link>
      <guid>https://blog.tokenlen.top/2024/11/01/en3/</guid>
      <pubDate>Thu, 31 Oct 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;每日一话+单词遗忘表11.1&lt;/h1&gt;
&lt;p&gt;Who partakes in another’s joys is a more humane character than he who partakes in his</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>每日一话+单词遗忘表11.1</h1><p>Who partakes in another’s joys is a more humane character than he who partakes in his griefs.</p><ul><li>counsel 忠告</li><li>counterpart 相当的</li><li>coupon 卷</li><li>coward 胆小的</li><li>crab 螃蟹</li><li>crane 吊车</li><li>crawl 爬行</li></ul><h1>每日一话+单词遗忘表11.2</h1><p>The highest possible stage in moral culture is when we recognize that we ought to control thoughts.</p><ul><li>creep 爬行</li><li>crew 组</li><li>crisis 危机</li><li><strong>criterion</strong> 准则</li><li>crocodile 鳄鱼</li><li>crop 农作物</li><li>crucial 决定性的</li><li>cruise 巡游</li><li>crustal 水晶</li><li>cucumber 黄瓜</li><li><strong>cultivate</strong> 耕种</li><li>crub 遏制</li></ul><h1>每日一话+单词遗忘表11.4</h1><p>Do the best you can, until you know better. Then when you know better, do better.</p><ul><li><strong>curse</strong> 诅咒</li><li>curtain 窗帘</li><li>curve 曲线</li><li>cushion 垫子</li><li>bait 引诱</li><li>cyberspace 数字空间</li><li>damp 潮湿</li><li>crown 王冠</li></ul><h1>每日一话+单词遗忘表11.7</h1><p>Winter is the time for comfort, for good food and warmth, for the touch of a friendly hand and for a talk beside the fire: it is the time for home.</p><ul><li>dawn 黎明</li><li>deaf 聋的</li><li>dean 院长</li><li><strong>decay</strong> 腐烂</li><li><strong>deceive</strong> 欺骗</li><li>currency 货币</li><li><strong>decent</strong> 得体的</li><li>deck 甲板</li><li><strong>deed</strong> 行动</li><li><strong>deem</strong> 认为</li><li>curriculum 课程</li></ul><h1>每日一话+单词遗忘表11.9</h1><p>It is silly of you, for there is only one thing in the world worse than being talked about, and that is not being talked about.</p><ul><li>defend 防守</li><li>deficient 有缺点的</li><li>deficit 赤字</li><li>definite 确切的</li><li>defy 蔑视</li><li><strong>delegate</strong> 代表</li><li>deliberate 从容不错的</li><li>delicate 精妙的</li><li>democracy 民主的</li><li>demonstrate 证明</li><li>dense 浓厚的</li><li>deposit 放置</li><li><strong>deprive</strong> 使丧失</li><li></li></ul><h1>每日一话+单词遗忘表11.10</h1><p>In the first 30 years of your life, you make your habits. For the last 30 years of your life, your habits make you.</p><ul><li>deputy 代理人</li><li>derive 源于</li><li>descend 下降</li><li>desert 遗弃</li><li><strong>deserve</strong> 应得的</li><li>despair 绝望</li><li>despatch 派遣</li><li>despite 尽管</li><li>detect 发现</li><li>deteriorate 恶化</li><li>dew 露水</li><li>diabetes 糖尿病</li><li>dial 打电话</li><li>devil 魔鬼</li><li></li></ul><h1>每日一话+单词遗忘表11.13</h1><p>Most of the change we think we see in life is due to truths being in and out of favor.</p><ul><li>dialect 方言</li><li>dialog 对话</li><li>deed 行动</li><li>diameter 直径</li><li>dictate 命令</li><li>curse 诅咒</li><li>dignity 尊严</li><li>dilemma 困境</li><li>diligent 勤勉的</li><li>dim 模糊的</li><li>dimension 尺寸</li><li>diplomat 外交家</li><li></li></ul><h1>每日一话+单词遗忘表11.14</h1><p>I do not think the forest would be so bright, nor the water so warm, nor love so sweet, if there were no danger in the lakes.</p><ul><li>disaster 不幸的</li><li>discadrd 丢弃</li><li>dischange 排出</li><li>discipline 纪律</li><li>discriminate 分别</li><li>disguise 假装</li><li><strong>disgust</strong> 厌恶</li><li>disintegrate 使分裂</li><li>delegate 代表</li><li>dispute 争论</li><li>disrupt 分裂</li><li><strong>disslove</strong> 使溶解</li><li>distinct 清楚的</li><li></li></ul><h1>每日一话+单词遗忘表11.15</h1><p>We must be willing to get rid of the life we’ve planned, so as to have the life that is waiting for us. The old skin has to be shed before the new one can come.</p><ul><li>distingguish 辨别</li><li>distract 分心</li><li>distress 忧虑</li><li><strong>district</strong> 区域</li><li>disturb 打扰</li><li><strong>ditch</strong> 丢弃</li><li>dive 跳水</li><li>dizzy 眩晕的</li><li>dock 码头</li><li>domestic 国内的</li><li>doominate 支配</li></ul><h1>每日一话+单词遗忘表11.16</h1><p>Love is an untamed force.</p><ul><li>dove 鸽子</li><li>dozen 一打</li><li>draft 草稿</li><li>drain 流水</li><li>drastic 激烈的</li><li>drawer 抽屉</li><li><strong>drift</strong> 漂流</li><li><strong>drill</strong> 钻子</li><li>drip 滴下</li><li>dropout 中途退学</li><li>dose 一剂量</li><li></li></ul><h1>每日一话+单词遗忘表11.18</h1><p>The great thing in this world is not so much where we are, but in what direction we are going.</p><ul><li><p>dual 双的</p></li><li><p>dull 钝的</p></li><li><p>dumb 哑的</p></li><li><p><strong>durable</strong> 耐用的</p></li><li><p><strong>duration</strong> 持续</p></li><li><p>dye 染料</p></li><li><p>decay 腐烂</p></li><li><p>ease 减轻</p></li></ul><h1>每日一话+单词遗忘表11.20</h1><p>A man who dares to waste one hour of time has not discovered the value of life.</p><ul><li>economy 节约</li><li>editorial 编辑的</li><li>eggplant 茄子</li><li>elbow 肘</li><li>elect 选出</li><li>elegant 高雅的</li><li>elevate 举起</li></ul><h1>每日一话+单词遗忘表11.21</h1><p>When everything seems to be going against you, remember that the airplane takes off against the wind, not with it.</p><ul><li>eliminate 消除</li><li>elite 精英</li><li>embrace 包含</li><li>emerge 浮现</li><li>emit 发出</li><li>emphasis 强调</li><li>encounter 遇到</li><li>enforce 强迫</li></ul><h1>每日一话+单词遗忘表11.22</h1><p>To travel hopefully is a better thing than to arrive.</p><ul><li>enlarge 扩大</li><li>enlighten 启发</li><li>enormous 庞大的</li><li>enrol 登记</li><li>enroll 登记</li><li>enterprise 事业</li><li>entertain 娱乐</li><li>entrepreneur 企业家</li><li>envelope 信封</li><li>envy 羡慕</li><li>episode 插曲</li><li>equip 装备</li><li>equivalent 等同的</li><li>essay 散文</li></ul><h1>每日一话+单词遗忘表11.23</h1><p>Fate fears the brave and bullies the timid.</p><ul><li>estimate 估计</li><li>eternal 永恒的</li><li>ethic 道德规范</li><li>ethnic 种族的</li><li>evident 明白的</li><li>evil 邪恶的</li><li>evolve 发展</li><li>exact 精确的</li><li>exceed 胜过</li><li>exceed 超过</li></ul><h1>每日一话+单词遗忘表11.24</h1><p>Since olden days there’s never been a man but dies; I’d leave a loyalist’s name in history only.</p><ul><li><strong>excess</strong> 超过</li><li>excite 刺激</li><li>exclaim 呼喊</li><li>exclude 排除</li><li>excursion 远足</li><li>excuse 理由</li><li>exert 运用</li><li>exhaust 耗尽</li><li>exile 流放</li><li>expel 驱逐</li><li>expense 开支</li><li><strong>expertise</strong> 专业知识</li><li>explicit 清楚的</li><li>explode 爆发</li><li>exploit 开发</li></ul><h1>每日一话+单词遗忘表11.25</h1><p>Time flies over us, but leaves its shadow behind.</p><ul><li>expose 使曝光</li><li>expel 开除</li><li>extent 范围</li><li>exterior 外表的</li><li>external 外部的</li><li>extingguish 熄灭</li><li>extraordinary 非常奇怪的</li><li>eyebrow 眉毛</li><li>faabric 布</li><li>facility 设备</li><li>faculty 能力</li><li>faint 头晕的</li><li>faith 信心</li></ul><h1>每日一话+单词遗忘表11.26</h1><p>Happiness always looks small while you hold it in your hands, but let it go, and you learn at once how big and precious it is.</p><ul><li>fame 名声</li><li><strong>famine</strong> 饥荒</li><li>fancy 想象力</li><li>fantasy 幻想</li><li>fare 票</li><li>farewell 告别</li><li>fascinate 使着迷</li><li>fasten 扎牢</li><li>fatal 致命的</li><li><strong>fatigue</strong> 疲劳</li><li>fault 故障</li><li>feasible 可行的</li><li>feather 羽毛</li></ul><h1>每日一话+单词遗忘表11.27</h1><p>Perhaps the best cure for the fear of death is to reflect that life has a beginning as well as an end.</p><ul><li>federal 联邦的</li><li>feed 喂养</li><li>ferry 渡口</li><li>fertile 富饶的</li><li>fever 发烧</li><li><strong>fiber</strong> 纤维</li><li>field 领域</li><li>fierce 凶猛的</li><li><strong>figure</strong> 图形</li><li><strong>filter</strong> 过滤</li></ul><h1>每日一话+单词遗忘表11.28</h1><p>We can be knowledgeable with other men’s knowledge, but we can not be wise with other men’s wisdom.</p><ul><li>finance 财经</li><li>fingerprint 指纹</li><li>fireplace 壁炉</li><li>flat 平坦的</li><li>flavor 滋味</li><li>flaw 瑕疵</li><li>fleet 快速的</li><li>flesh 肉体</li><li>flock 群</li></ul><h1>每日一话+单词遗忘表11.29</h1><p>it is a true great man whom no money and rank can confuse, no poverty and hardship can shake, and no power and force can suffocate.</p><ul><li>flour 面粉</li><li>flourish 兴盛</li><li>fluctuate 波动</li><li>fluent 流畅的</li><li>fluid 流动的</li><li>focus 中心</li><li>fog 雾</li><li>fold 折叠</li><li>forbid 禁止</li><li>forecast 预测</li><li>foresee 预知</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2024/11/01/en3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构 图</title>
      <link>https://blog.tokenlen.top/2024/10/30/data5/</link>
      <guid>https://blog.tokenlen.top/2024/10/30/data5/</guid>
      <pubDate>Tue, 29 Oct 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;定义-各种分类&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;图（Graph）&lt;/strong&gt;：由顶点的非空有限集合 V&lt;em&gt;V&lt;/em&gt; （由 n&amp;gt;0&lt;em&gt;n&lt;/em&gt;&amp;gt;0 个顶点组成）与边的集合 E&lt;em&gt;E&lt;/em&gt;（顶点之间的关系）构成的结构。其形式化定义为</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>定义-各种分类</h1><p><strong>图（Graph）</strong>：由顶点的非空有限集合 V<em>V</em> （由 n&gt;0<em>n</em>&gt;0 个顶点组成）与边的集合 E<em>E</em>（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)<em>G</em>=(<em>V</em>,<em>E</em>)。</p><ul><li><strong>顶点（Vertex）</strong>：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。</li><li><strong>边（Edge）</strong>：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=⟨u,v⟩<em>e</em>=⟨<em>u</em>,<em>v</em>⟩，表示从 u<em>u</em> 到 v<em>v</em> 的一条边，其中 u<em>u</em> 称为起始点，v<em>v</em> 称为终止点。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220307145142.png" alt=""></p><p>特别的，根据定义，G<em>G</em> 也是其自身的子图。</p><p><img src="https://qcdn.itcharge.cn/images/20220317163120.png" alt=""></p><ul><li><strong>无向图（Undirected Graph）</strong>：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。</li><li><strong>有向图（Directed Graph）</strong>：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220307160017.png" alt=""></p><p>如果无向图中有 n<em>n</em> 个顶点，则无向图中最多有 n×(n−1)/2<em>n</em>×(<em>n</em>−1)/2 条边。而具有 n×(n−1)/2<em>n</em>×(<em>n</em>−1)/2 条边的无向图称为 <strong>「完全无向图（Completed Undirected Graph）」</strong>。</p><p>如果有向图中有 n<em>n</em> 个顶点，则有向图中最多有 n×(n−1)<em>n</em>×(<em>n</em>−1) 条弧。而具有 n×(n−1)<em>n</em>×(<em>n</em>−1) 条弧的有向图称为 <strong>「完全有向图（Completed Directed Graph）」</strong>。</p><p><strong>说白了就是全都连起来了</strong></p><p><img src="https://qcdn.itcharge.cn/images/20220308151436.png" alt=""></p><ul><li><strong>顶点的度</strong>：与该顶点 vi<em>v**i</em> 相关联的边的条数，记为 TD(vi)<em>T**D</em>(<em>v**i</em>)。</li></ul><p>例如上图左侧的完全无向图中，顶点 v3的度为 3。</p><p>而对于有向图，我们可以将顶点的度分为 <strong>「顶点的出度」</strong> 和 <strong>「顶点的入度」</strong>。</p><ul><li><strong>顶点的出度</strong>：以该顶点 vi<em>v**i</em> 为出发点的边的条数，记为 OD(vi)<em>O**D</em>(<em>v**i</em>)。</li><li><strong>顶点的入度</strong>：以该顶点 vi<em>v**i</em> 为终止点的边的条数，记为 ID(vi)<em>I**D</em>(<em>v**i</em>)。</li><li>有向图中某顶点的度 = 该顶点的出度 + 该顶点的入度，即 TD(vi)=OD(vi)+ID(vi)<em>T**D</em>(<em>v**i</em>)=<em>O**D</em>(<em>v**i</em>)+<em>I**D</em>(<em>v**i</em>)。</li></ul><p><strong>例如顶点v3的度就是6，3+3=6</strong></p><ul><li><p><strong>环（Circle）</strong>：如果一条路径的起始点和终止点相同（即 vi0==vim<em>v**i</em>0==<em>v<strong>i</strong>m</em> ），则称这条路径为「回路」或者「环」。</p></li><li><p><strong>简单路径</strong>：顶点序列中顶点不重复出现的路径称为「简单路径」。</p></li></ul><p>而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。</p><ul><li><strong>环形图（Circular Graph）</strong>：如果图中存在至少一条环路，则该图称为「环形图」。</li><li><strong>无环图（Acyclic Graph）</strong>：如果图中不存在环路，则该图称为「无环图」。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317115641.png" alt=""></p><p>在无向图中，如果从顶点 vi<em>v**i</em> 到顶点 vj<em>v**j</em> 有路径，则称顶点 vi<em>v**i</em> 和 vj<em>v**j</em> 是连通的。</p><ul><li><strong>连通无向图</strong>：在无向图中，如果图中任意两个顶点之间都是连通的，则称该图为连通无向图。</li><li><strong>非连通无向图</strong>：在无向图中，如果图中至少存在一对顶点之间不存在任何路径，则该图称为非连通无向图。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317163249.png" alt=""></p><p>有些无向图可能不是连通无向图，但是其子图可能是连通的。这些子图称为原图的连通子图。而无向图的一个极大连通子图（不存在包含它的更大的连通子图）则称为该图的「连通分量」。</p><ul><li><p><strong>连通子图</strong>：如果无向图的子图是连通无向图，则该子图称为原图的连通子图。</p></li><li><p><strong>连通分量</strong>：无向图中的一个极大连通子图（不存在包含它的更大的连通子图）称为该图的连通分量。</p></li><li><p><strong>极⼤连通⼦图</strong>：无向图中的一个连通子图，并且不存在包含它的更大的连通子图。</p></li><li><p><strong>强连通有向图</strong>：如果图中任意两个顶点 vi<em>v**i</em> 和 vj<em>v**j</em>，从 vi<em>v**i</em> 到 vj<em>v**j</em> 和从 vj<em>v**j</em> 到 vi<em>v**i</em> 都有路径，则称该图为强连通有向图。</p></li><li><p><strong>非强连通有向图</strong>：如果图中至少存在一对顶点之间不存在任何路径，则该图称为非强连通有向图。</p></li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317133500.png" alt=""></p><p>与无向图类似，有向图的一个极大强连通子图称为该图的 <strong>强连通分量</strong>。</p><ul><li><strong>强连通子图</strong>：如果有向图的子图是连通有向图，则该子图称为原图的强连通子图。</li><li><strong>强连通分量</strong>：有向图中的一个极⼤强连通⼦图，称为该图的强连通分量。</li><li><strong>极⼤强连通⼦图</strong>：有向图中的一个强连通子图，并且不存在包含它的更大的强连通子图。</li></ul><p>有时，图不仅需要表示顶点之间是否存在某种关系，还需要表示这一关系的具体细节。这时候我们需要在边上带一些数据信息，这些数据信息被称为 <strong>权</strong>。在具体应用中，权值可以具有某种具体意义，比如权值可以代表距离、时间以及价格等不同属性。</p><ul><li><strong>带权图</strong>：如果图的每条边都被赋以⼀个权值，这种图称为带权图。</li><li><strong>网络</strong>：带权的连通⽆向图称为⽹络。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317135207.png" alt=""></p><p>根据图中边的稀疏程度，我们可以将图分为「稠密图」和「稀疏图」。这是一个模糊的概念，目前为止还没有给出一个量化的定义。</p><ul><li><strong>稠密图（Dense Graph）</strong>：有很多条边或弧（边的条数 e<em>e</em> 接近于完全图的边数）的图称为稠密图。</li><li><strong>稀疏图（Sparse Graph）</strong>：有很少条边或弧（边的条数 e<em>e</em> 远小于完全图的边数，如 e&lt;n×log⁡2n<em>e</em>&lt;<em>n</em>×log2<em>n</em>）的图称为稀疏图。</li></ul><h1>存储结构</h1><p>我们在实现图的存储时，重点需要关注边与顶点之间的关联关系，这是图的存储的关键。</p><p>图的存储可以通过「顺序存储结构」和「链式存储结构」来实现。其中顺序存储结构包括邻接矩阵和边集数组。链式存储结构包括邻接表、链式前向星、十字链表和邻接多重表。</p><h2 id="邻接矩阵">邻接矩阵</h2><p><strong>邻接矩阵（Adjacency Matrix）</strong>：使用一个二维数组 adj‾matrix<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em> 来存储顶点之间的邻接关系。</p><ul><li>对于无权图来说，如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 11，则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 存在边，如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 00，则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 不存在边。</li><li>对于带权图来说，如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 w<em>w</em>，并且 w≠∞<em>w</em>\=∞（即 <code>w != float('inf')</code>），则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 的权值为 w<em>w</em>。如果 adj‾matrix[i][j]<em>a<strong>d</strong>j<strong>ma</strong>t<strong>r</strong>i**x</em>[<em>i</em>][<em>j</em>] 为 ∞∞（即 <code>float('inf')</code>），则说明顶点 vi<em>v**i</em> 到 vj<em>v**j</em> 不存在边。</li></ul><p><img src="https://qcdn.itcharge.cn/images/20220317144826.png" alt=""></p><p>邻接矩阵的特点：</p><ul><li><p>优点：实现简单，并且可以直接查询顶点 vi<em>v**i</em> 与 vj<em>v**j</em> 之间是否有边存在，还可以直接查询边的权值。</p></li><li><p>缺点：初始化效率和遍历效率较低，空间开销大，空间利用率低，并且不能存储重复边，也不便于增删节点。如果当顶点数目过大（比如当 n&gt;105<em>n</em>&gt;105）时，使用邻接矩阵建立一个 n×n<em>n</em>×<em>n</em> 的二维数组不太现实。</p></li><li><p><strong>时间复杂度</strong>：</p><ul><li><strong>初始化操作</strong>：O(n2)<em>O</em>(<em>n</em>2)。</li><li><strong>查询、添加或删除边操作</strong>：O(1)<em>O</em>(1)。</li><li><strong>获取某个点的所有边操作</strong>：O(n)<em>O</em>(<em>n</em>)。</li><li><strong>图的遍历操作</strong> ：O(n2)<em>O</em>(<em>n</em>2)。</li></ul></li><li><p><strong>空间复杂度</strong>：O(n2)<em>O</em>(<em>n</em>2)。</p></li></ul><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Graph &#123;</span><br><span class="line">    private int verCount;</span><br><span class="line">    private Integer[][] adjMatrix;</span><br><span class="line">    public Graph(int verCount)&#123;</span><br><span class="line">        this.verCount = verCount;</span><br><span class="line">        adjMatrix = new Integer[verCount][verCount];</span><br><span class="line">        for (Integer[] row:adjMatrix)&#123;</span><br><span class="line">            Arrays.fill(row,null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isValid(int v) &#123;</span><br><span class="line">        return 0 &lt;= v &amp;&amp; v &lt; verCount; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createGraph(int[][] edges)&#123;</span><br><span class="line">        for (int[] edge:edges)&#123;</span><br><span class="line">            addEdge(edge[0],edge[1],edge[2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addEdge(int vi,int vj,int val)&#123;</span><br><span class="line">        if (!isValid(vi) || !isValid(vj))&#123;</span><br><span class="line">            throw new IllegalArgumentException(vi+&quot;or&quot;+vj+&quot;is not&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMatrix[vi][vj] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getEdge(int vi,int vj)&#123;</span><br><span class="line">        if (!isValid(vi) || !isValid(vj))&#123;</span><br><span class="line">            throw new IllegalArgumentException(vi+&quot;or&quot;+vj+&quot;is not&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return adjMatrix[vi][vj];</span><br><span class="line">    &#125;</span><br><span class="line">    public void printGraph()&#123;</span><br><span class="line">        for (int vi=0;vi&lt;verCount;vi++)&#123;</span><br><span class="line">            for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">                Integer val = getEdge(vi,vj);</span><br><span class="line">                if (val!=null)&#123;</span><br><span class="line">                    System.out.println(vi + &quot;-&quot; + vj + &quot;-&quot; + val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Graph graph = new Graph(5);</span><br><span class="line">        int[][] edges = &#123;</span><br><span class="line">                &#123;1, 2, 5&#125;,</span><br><span class="line">                &#123;2, 1, 5&#125;,</span><br><span class="line">                &#123;1, 3, 30&#125;,</span><br><span class="line">                &#123;3, 1, 30&#125;,</span><br><span class="line">                &#123;2, 3, 14&#125;,</span><br><span class="line">                &#123;3, 2, 14&#125;,</span><br><span class="line">                &#123;2, 4, 26&#125;,</span><br><span class="line">                &#123;4, 2, 26&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        graph.createGraph(edges);</span><br><span class="line">        graph.getEdge(3,4);</span><br><span class="line">        graph.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在写代码的时候，出现了一些小小的问题</p><p>主要是异常处理没完成的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!isValid(vi) || !isValid(vj)) </span><br></pre></td></tr></table></figure><p>应该是这个逻辑，我写错了，大家注意</p><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">1-2-5</span><br><span class="line">1-3-30</span><br><span class="line">2-1-5</span><br><span class="line">2-3-14</span><br><span class="line">2-4-26</span><br><span class="line">3-1-30</span><br><span class="line">3-2-14</span><br><span class="line">4-2-26</span><br></pre></td></tr></table></figure><p>稍微修改了下，把检测权给输出出来了</p><h2 id="边集数组">边集数组</h2><p><strong>边集数组（Edgeset Array）</strong>：使用一个数组来存储存储顶点之间的邻接关系。数组中每个元素都包含一条边的起点 vi<em>v**i</em>、终点 vj<em>v**j</em> 和边的权值 val<em>v<strong>a</strong>l</em>（如果是带权图）。</p><p><img src="https://qcdn.itcharge.cn/images/20220317161454.png" alt=""></p><p>边集数组的时间复杂度：</p><ul><li>图的初始化和创建操作：O(m)<em>O</em>(<em>m</em>)。</li><li>查询是否存在某条边：O(m)<em>O</em>(<em>m</em>)。</li><li>遍历某个点的所有边：O(m)<em>O</em>(<em>m</em>)。</li><li>遍历整张图：O(nm)<em>O</em>(<em>nm</em>)。</li></ul><p>边集数组的空间复杂度：</p><ul><li>空间复杂度：O(m)<em>O</em>(<em>m</em>)。</li></ul><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">class EdgeNode&#123;</span><br><span class="line">    int vi;</span><br><span class="line">    int vj;</span><br><span class="line">    int val;</span><br><span class="line"></span><br><span class="line">    public EdgeNode(int vi, int vj, int val) &#123;</span><br><span class="line">        this.vi = vi;</span><br><span class="line">        this.vj = vj;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class EdgeListGraph &#123;</span><br><span class="line">    private List&lt;EdgeNode&gt; edges;</span><br><span class="line">    public EdgeListGraph()&#123;</span><br><span class="line">        edges = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public void  createGraph(int[][] edgesArray)&#123;</span><br><span class="line">        for (int[] edge:edgesArray)&#123;</span><br><span class="line">            addEdge(edge[0],edge[1],edge[2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addEdge(int vi,int vj,int val)&#123;</span><br><span class="line">        EdgeNode edge = new EdgeNode(vi,vj,val);</span><br><span class="line">        edges.add(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getEdge(int vi,int vj)&#123;</span><br><span class="line">        for (EdgeNode edge:edges)&#123;</span><br><span class="line">            if (vi==edge.vi&amp;&amp;vj==edge.vj)&#123;</span><br><span class="line">                return edge.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public void printGraph()&#123;</span><br><span class="line">        for (EdgeNode edge:edges)&#123;</span><br><span class="line">            System.out.println(edge.vi + &quot;-&quot; + edge.vj + &quot;-&quot; + edge.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EdgeListGraph graph = new EdgeListGraph();</span><br><span class="line">        int[][] edgesArray = &#123;</span><br><span class="line">                &#123;1, 2, 5&#125;,</span><br><span class="line">                &#123;1, 5, 6&#125;,</span><br><span class="line">                &#123;2, 4, 7&#125;,</span><br><span class="line">                &#123;4, 3, 9&#125;,</span><br><span class="line">                &#123;3, 1, 2&#125;,</span><br><span class="line">                &#123;5, 6, 8&#125;,</span><br><span class="line">                &#123;6, 4, 3&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        graph.createGraph(edgesArray);</span><br><span class="line">        System.out.println(graph.getEdge(3, 4));</span><br><span class="line">        graph.printGraph();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">1-2-5</span><br><span class="line">1-5-6</span><br><span class="line">2-4-7</span><br><span class="line">4-3-9</span><br><span class="line">3-1-2</span><br><span class="line">5-6-8</span><br><span class="line">6-4-3</span><br></pre></td></tr></table></figure><p>一般来说，边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任何一条边的运算。</p><h1>图的遍历</h1><h2 id="深度优先搜索">深度优先搜索</h2><p><strong>深度优先搜索算法（Depth First Search）</strong>：英文缩写为 DFS，是一种用于搜索树或图结构的算法。深度优先搜索算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void depthFirstSearch(int start)&#123;</span><br><span class="line">        boolean[] visited = new boolean[verCount];</span><br><span class="line">        System.out.println(&quot;Dfs&quot; + start + &quot;:&quot;);</span><br><span class="line">        dfsHelper(start,visited);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    private void  dfsHelper(int vertex,boolean[] visited)&#123;</span><br><span class="line">        visited[vertex] = true;</span><br><span class="line">        System.out.println(vertex + &quot; &quot;);</span><br><span class="line">        for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">            if (adjMatrix[vertex][vj]!=null&amp;&amp;!visited[vj])&#123;</span><br><span class="line">                dfsHelper(vj,visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dfs4:</span><br><span class="line">4 </span><br><span class="line">2 </span><br><span class="line">1 </span><br><span class="line">3 </span><br></pre></td></tr></table></figure><p>但是一般使用递归的时候会出现不可控的错误</p><p>所以我们使用另一种方法</p><p>采用栈堆实现</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void DfsStack(int start)&#123;</span><br><span class="line">        boolean[] visited = new boolean[verCount];</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(start);</span><br><span class="line">        System.out.println(&quot;DFS is &quot; + start + &quot;:&quot;);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            int vertex = stack.pop();</span><br><span class="line">            if (!visited[vertex])&#123;</span><br><span class="line">                visited[vertex] = true;</span><br><span class="line">                System.out.println(vertex + &quot; &quot;);</span><br><span class="line">                for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">                    if (adjMatrix[vertex][vj]!=null&amp;&amp;!visited[vj])&#123;</span><br><span class="line">                        stack.push(vj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索">广度优先搜索</h2><p><strong>广度优先搜索算法（Breadth First Search）</strong>：英文缩写为 BFS，又译作宽度优先搜索 / 横向优先搜索，是一种用于搜索树或图结构的算法。广度优先搜索算法从起始节点开始，逐层扩展，先访问离起始节点最近的节点，后访问离起始节点稍远的节点。以此类推，直到完成整个搜索过程。</p><p><strong>就是一层一层的访问呗</strong></p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void bfs(int start)&#123;</span><br><span class="line">        boolean[] visited = new boolean[verCount];</span><br><span class="line">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        visited[start] = true;</span><br><span class="line">        System.out.println(&quot;Bfs&quot; + start + &quot; :&quot;);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            int vertex = queue.poll();</span><br><span class="line">            System.out.println(vertex + &quot; &quot;);</span><br><span class="line">            for (int vj=0;vj&lt;verCount;vj++)&#123;</span><br><span class="line">                if (adjMatrix[vertex][vj]!=null&amp;&amp;!visited[vj])&#123;</span><br><span class="line">                    visited[vj] = true;</span><br><span class="line">                    queue.add(vj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以借助队列来实现</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://blog.tokenlen.top/2024/10/30/data5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JAVA 练习金秋篇</title>
      <link>https://blog.tokenlen.top/2024/10/26/javatest2/</link>
      <guid>https://blog.tokenlen.top/2024/10/26/javatest2/</guid>
      <pubDate>Fri, 25 Oct 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;1.leetcode &lt;a href=&quot;https://leetcode.cn/problems/satisfiability-of-equality-equations/&quot;&gt;990.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>1.leetcode <a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>'='</code>，要么是 <code>'!'</code></li><li><code>equations[i][2]</code> 是 <code>'='</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class UF &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    private int[] parent;</span><br><span class="line">    private int[] size;</span><br><span class="line">    public UF(int n)&#123;</span><br><span class="line">        this.count = n;</span><br><span class="line">        parent = new int[n];</span><br><span class="line">        size = new int[n];</span><br><span class="line">        for (int i =0;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i] =i;</span><br><span class="line">            size[i] =1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void union(int p,int q)&#123;</span><br><span class="line">        int rootP = find(p);</span><br><span class="line">        int rootQ = find(q);</span><br><span class="line">        if (rootQ==rootP)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (size[rootP]&gt;size[rootQ])&#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] +=size[rootQ];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] +=size[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean connected(int p,int q)&#123;</span><br><span class="line">        int rootQ = find(q);</span><br><span class="line">        int rootP = find(p);</span><br><span class="line">        return rootP ==rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    private int find(int x)&#123;</span><br><span class="line">        while (parent[x]!=x)&#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    public int count()&#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Solution&#123;</span><br><span class="line">    public boolean equationsPossible(String[] equations) &#123;</span><br><span class="line">        UF uf = new UF(26);</span><br><span class="line">        for (String eq : equations) &#123;</span><br><span class="line">            if (eq.charAt(1) == &#x27;=&#x27;) &#123;</span><br><span class="line">                char x = eq.charAt(0);</span><br><span class="line">                char y = eq.charAt(3);</span><br><span class="line">                uf.union(x - &#x27;a&#x27;, y - &#x27;a&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (String eq : equations) &#123;</span><br><span class="line">            if (eq.charAt(1) == &#x27;!&#x27;) &#123;</span><br><span class="line">                char x = eq.charAt(0);</span><br><span class="line">                char y = eq.charAt(3);</span><br><span class="line">                if (uf.connected(x - &#x27;a&#x27;, y - &#x27;a&#x27;)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接使用并查集秒了喵喵喵</p><h1>2.leetcode <a href="https://leetcode.cn/problems/number-of-provinces/description/">省份数量</a></h1><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n == isConnected.length</code></li><li><code>n == isConnected[i].length</code></li><li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li><li><code>isConnected[i][i] == 1</code></li><li><code>isConnected[i][j] == isConnected[j][i]</code></li></ul><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DFS &#123;</span><br><span class="line">    private void dfs(int[] [] isConnected,boolean[] visited,int i)&#123;</span><br><span class="line">        for (int j=0;j&lt;isConnected.length;j++)&#123;</span><br><span class="line">            if (isConnected[i][j]==1&amp;&amp;!visited[j])&#123;</span><br><span class="line">                visited[j] = true;</span><br><span class="line">                dfs(isConnected,visited,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Solution&#123;</span><br><span class="line">        public int findCircleNUm(int[][] isconnected)&#123;</span><br><span class="line">            int n = isconnected.length;</span><br><span class="line">            boolean[] visited = new boolean[n];</span><br><span class="line">            int provinces = 0;</span><br><span class="line">            for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">                if (!visited[i])&#123;</span><br><span class="line">                    dfs(isconnected,visited,i);</span><br><span class="line">                    provinces++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return provinces;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>遍历矩阵 isConnected<em>i<strong>s</strong>C<strong>o</strong>nn<strong>ec</strong>t<strong>e</strong>d</em>。如果 <code>isConnected[i][j] = 1</code>，将 i<em>i</em> 节点和 j<em>j</em> 节点相连。</li><li>然后判断每个城市节点的根节点，然后统计不重复的根节点有多少个，也就是集合个数，即为「省份」的数量。</li></ul><h1>3.leetcode 200. <a href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></h1><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li></ul><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class dfs_leetcode &#123;</span><br><span class="line">    private void dfs(char[][] grid,int i ,int j)&#123;</span><br><span class="line">        int n = grid.length;</span><br><span class="line">        int m = grid[0].length;</span><br><span class="line">        if (i&lt;0||i&gt;=n||j&lt;0||j&gt;=m||grid[i][j]==&#x27;0&#x27;)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=&#x27;0&#x27;;</span><br><span class="line">        dfs(grid, i + 1, j); // 向下</span><br><span class="line">        dfs(grid, i - 1, j); // 向上</span><br><span class="line">        dfs(grid, i, j + 1); // 向右</span><br><span class="line">        dfs(grid, i, j - 1); // 向左</span><br><span class="line">    &#125;</span><br><span class="line">    public int numIslands(char[][] grid)&#123;</span><br><span class="line">        if (grid==null||grid.length==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i=0;i&lt;grid.length;i++)&#123;</span><br><span class="line">            for (int j=0;j&lt;grid[0].length;j++)&#123;</span><br><span class="line">                if (grid[i][j]==&#x27;1&#x27;)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要就是运用了递归，然后一点一点去找，这个过程就是深度搜索</p><ul><li><strong>时间复杂度</strong>：O(m×n)<em>O</em>(<em>m</em>×<em>n</em>)。其中 m<em>m</em> 和 n<em>n</em> 分别为行数和列数。</li><li><strong>空间复杂度</strong>：O(m×n)<em>O</em>(<em>m</em>×<em>n</em>)。</li></ul><h1>4.leetcode <a href="https://leetcode.cn/problems/clone-graph/">133. 克隆图</a></h1><p>给你无向 <strong><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>这张图中的节点数在 <code>[0, 100]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 100</code></li><li>每个节点值 <code>Node.val</code> 都是唯一的，</li><li>图中没有重复的边，也没有自环。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ul><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Node&#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">    public Node()&#123;</span><br><span class="line">        val = 0;</span><br><span class="line">        neighbors = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    public Node(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        neighbors = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(int val, List&lt;Node&gt; neighbors) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.neighbors = neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class cloneGraph &#123;</span><br><span class="line">    public Node cloneGraph(Node node)&#123;</span><br><span class="line">        Map&lt;Node,Node&gt; lookup = new HashMap&lt;&gt;();</span><br><span class="line">        if (node ==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        Node clone  = new Node(node.val,new ArrayList&lt;&gt;());</span><br><span class="line">        lookup.put(node,clone);</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            Node curr = queue.poll();</span><br><span class="line">            for (Node neighbor:curr.neighbors)&#123;</span><br><span class="line">                if (!lookup.containsKey(neighbor))&#123;</span><br><span class="line">                    Node neighborClone = new Node(neighbor.val,new ArrayList&lt;&gt;());</span><br><span class="line">                    lookup.put(neighbor,neighborClone);</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                lookup.get(curr).neighbors.add(lookup.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：O(V + E)，其中 V 是图中节点的数量，E 是图中边的数量。每个节点和每条边都会被访问一次。</p><p><strong>空间复杂度</strong>：O(V)，用于存储 <code>lookup</code> 映射表和 BFS 队列。</p><p><strong><code>lookup</code> Map</strong>：这个 <code>HashMap</code> 用于存储原图中的每个节点及其对应的克隆节点。通过这个映射，我们可以避免多次克隆相同的节点。</p><p><strong>空图处理</strong>：如果输入的 <code>node</code> 为 <code>null</code>，则直接返回 <code>null</code>，因为图为空不需要进行克隆。</p><p><strong><code>clone</code></strong>：首先克隆起始节点。克隆时创建了一个新的 <code>Node</code> 对象，并将它放入 <code>lookup</code> 映射中，将原节点 <code>node</code> 和它的克隆节点 <code>clone</code> 关联起来。</p><p><strong>队列初始化</strong>：创建一个队列 <code>queue</code>，用于广度优先搜索（BFS）。把原图的起始节点 <code>node</code> 加入队列中。</p><p><strong>BFS 循环</strong>：当队列非空时，继续从队列中取出节点 <code>curr</code>，并访问它的邻居。</p><ul><li><p>访问邻居节点</p><p>：对于当前节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curr</span><br></pre></td></tr></table></figure><p>的每个邻居</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neighbor</span><br></pre></td></tr></table></figure><p>，检查它是否已经被克隆过：</p><ul><li>如果该邻居尚未被克隆，则创建一个新节点 <code>neighborClone</code>，并将其加入到 <code>lookup</code> 中。</li><li>如果该邻居已经被克隆过，直接通过 <code>lookup.get(neighbor)</code> 获取该邻居的克隆节点。</li></ul></li><li><p><strong>建立邻接关系</strong>：无论邻居节点是否是第一次被克隆，都要将克隆的邻居节点添加到当前节点 <code>curr</code> 的克隆节点的 <code>neighbors</code> 列表中。</p></li></ul><p>通过这个过程，我们逐渐构建出图的克隆，且保证每个节点和邻居关系都能被正确地克隆出来。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://blog.tokenlen.top/2024/10/26/javatest2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux shell编程进阶</title>
      <link>https://blog.tokenlen.top/2024/10/18/linux10/</link>
      <guid>https://blog.tokenlen.top/2024/10/18/linux10/</guid>
      <pubDate>Thu, 17 Oct 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本脚本&lt;/h1&gt;
&lt;h3 id=&quot;echo-使用&quot;&gt;echo 使用&lt;/h3&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本脚本</h1><h3 id="echo-使用">echo 使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出普通字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="comment"># Output: hello, world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含变量的字符串</span></span><br><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, \&quot;<span class="variable">$&#123;name&#125;</span>\&quot;&quot;</span></span><br><span class="line"><span class="comment"># Output: hello, &quot;zp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;YES\nNO&quot;</span> </span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># YES</span></span><br><span class="line"><span class="comment"># NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出内容定向至文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出执行结果</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment"># Output: (当前目录路径)</span></span><br></pre></td></tr></table></figure><p>示例脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;aaa,mmmmmmmm&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;aaaa\naaaa&quot;</span></span><br><span class="line">name=woshini</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;name is <span class="variable">$&#123;name&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaa,mmmmmmmm</span><br><span class="line">aaaa</span><br><span class="line">name is woshini</span><br><span class="line">/home/mengnankk/shellcode</span><br></pre></td></tr></table></figure><h3 id="exit">exit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">var1=4</span><br><span class="line">var2=6</span><br><span class="line">var3=$((<span class="variable">$var1</span> + <span class="variable">$var2</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var3</span>&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 5</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="printf">printf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%d %s\n&#x27;</span> 1 <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment"># Output: 1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 姓名 性别 体重kg</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br></pre></td></tr></table></figure><h3 id="expr">expr</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line">r=$[2+3]</span><br><span class="line">temp=`<span class="built_in">expr</span> 2 + 4`</span><br><span class="line">res=`<span class="built_in">expr</span> <span class="variable">$temp</span> \* 4`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ress=<span class="variable">$res</span>&quot;</span></span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ress=24</span><br></pre></td></tr></table></figure><h3 id="bc">bc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=`<span class="built_in">echo</span> <span class="string">&quot;scale=4; <span class="variable">$var1</span> / <span class="variable">$var2</span>&quot;</span> | bc`</span><br><span class="line"><span class="built_in">echo</span> The answer <span class="keyword">for</span> this is <span class="variable">$var3</span></span><br></pre></td></tr></table></figure><h3 id="字符串操作">字符串操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">&quot;qinjx&quot;</span></span><br><span class="line">greeting=<span class="string">&quot;hello, <span class="variable">$&#123;your_name&#125;</span> !&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span></span><br><span class="line"><span class="comment"># 获取字符串长度</span></span><br><span class="line">string=<span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment"># 输出：4</span></span><br><span class="line"><span class="comment"># 提取子字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment"># 输出：liba</span></span><br></pre></td></tr></table></figure><h3 id="数组">数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums=( [2]=2 [0]=0 [1]=1 )</span><br><span class="line">colors=( red yellow <span class="string">&quot;dark blue&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问数组的单个元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span> <span class="comment"># Output: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span> <span class="comment"># Output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向数组中添加元素</span></span><br><span class="line">colors=( white <span class="string">&quot;<span class="variable">$&#123;colors[@]&#125;</span>&quot;</span> green black )</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span> <span class="comment"># Output: white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure><h1>信号</h1><h2 id="捕捉信号">捕捉信号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;sorry&#x27;&quot;</span> SIGINT SIGTERM</span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 10 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;loop #<span class="variable">$count</span>&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> 5</span><br><span class="line">    count=$((count + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="捕捉脚本的退出">捕捉脚本的退出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo bybyb&quot;</span> EXIT</span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Loop #<span class="variable">$count</span>&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> 3</span><br><span class="line">    count=$((count + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1>操作符</h1><h2 id="关系运算符">关系运算符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="comment"># 10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="comment"># 10 -gt 20: x 大于 y</span></span><br><span class="line"><span class="comment"># 10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="comment"># 10 -ge 20: x 大于或等于 y</span></span><br><span class="line"><span class="comment"># 10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure><h2 id="字符串运算符">字符串运算符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ -n string ]] <span class="comment"># 判断字符串非空</span></span><br><span class="line">[[ -z string ]] <span class="comment"># 判断字符串为空</span></span><br><span class="line">[[ string1 = string2 ]] <span class="comment"># 判断字符串相等</span></span><br><span class="line">[[ string1 != string2 ]] <span class="comment"># 判断字符串不相等</span></span><br></pre></td></tr></table></figure><h2 id="文件测试运算符">文件测试运算符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-r <span class="comment"># 检测文件是否可读</span></span><br><span class="line">-w <span class="comment"># 检测文件是否可写</span></span><br><span class="line">-x <span class="comment"># 检测文件是否可执行</span></span><br><span class="line">-f <span class="comment"># 检测是否为普通文件</span></span><br><span class="line">-d <span class="comment"># 检测是否为目录</span></span><br><span class="line">-s <span class="comment"># 检测是否非空</span></span><br><span class="line">-e <span class="comment"># 检测文件是否存在</span></span><br></pre></td></tr></table></figure><p>这份内容结构更加清晰，方便阅读和理解！如果需要进一步修改或添加，请告诉我。</p><h2 id="逻辑运算符">逻辑运算符</h2><p>主要还是&amp;&amp;和||</p><p>除了这些还有</p><p><strong>!表示非</strong></p><p><strong><code>-o</code> 和 <code>-a</code></strong>：在 <code>[ ... ]</code> 或 <code>test</code> 命令中使用，分别表示逻辑或和逻辑与（不推荐使用，建议使用 <code>||</code> 和 <code>&amp;&amp;</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码[ condition1 -o condition2 ]  # condition1 或 condition2</span><br><span class="line">[ condition1 -a condition2 ]  # condition1 和 condition2</span><br></pre></td></tr></table></figure><h1>文件操作</h1><h2 id="创建临时文件">创建临时文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">tempFile=`mktemp test.XXXXXX`</span><br><span class="line">exec 3&gt;$&#123;tempFile&#125;</span><br><span class="line">echo &quot;This is the first line&quot; &gt;&amp;3</span><br><span class="line">echo &quot;This is the second line&quot; &gt;&amp;3</span><br><span class="line">echo &quot;This is the last line&quot; &gt;&amp;3</span><br><span class="line">exec 3&gt;&amp;-</span><br><span class="line">cat $&#123;tempFile&#125;</span><br><span class="line">rm -f $&#123;tempFile&#125; 2&gt; /dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ ./file.sh</span><br><span class="line">This is the first line</span><br><span class="line">This is the second line</span><br><span class="line">This is the last line</span><br></pre></td></tr></table></figure><p>注意mktemp 命令创建临时文件的时候</p><p><strong>mktemp<code>命令要求模板中包含至少 6 个</code>X</strong></p><h2 id="创建临时目录">创建临时目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">tempFile=mktemp -d dir.XXXXXX</span><br><span class="line">cd $&#123;tempFile&#125;|exit 1</span><br><span class="line">tempFile1=mktemp temp.XXXXXX</span><br><span class="line">tempFile2=mktemp temp2.XXXXXX</span><br><span class="line">exec 7&gt; $&#123;tempFile1&#125;</span><br><span class="line">exec 8&gt; $&#123;tempFile2&#125;</span><br><span class="line">echo &quot;This is a test line of data for $tempFile1&quot; &gt;&amp;7</span><br><span class="line">echo &quot;This is a test line of data for $tempFile2&quot; &gt;&amp;8</span><br></pre></td></tr></table></figure><p>return</p><p>创建成功</p><p>还有一个改进版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line"></span><br><span class="line"># 创建一个临时目录</span><br><span class="line">tempFile=$(mktemp -d dir.XXXXXX)</span><br><span class="line"></span><br><span class="line"># 切换到临时目录</span><br><span class="line">cd &quot;$&#123;tempFile&#125;&quot; || exit 1</span><br><span class="line"></span><br><span class="line"># 在临时目录中创建临时文件</span><br><span class="line">tempFile1=$(mktemp temp.XXXXXX)</span><br><span class="line">tempFile2=$(mktemp temp2.XXXXXX)</span><br><span class="line"></span><br><span class="line"># 打开文件描述符并向临时文件写入数据</span><br><span class="line">exec 7&gt; &quot;$&#123;tempFile1&#125;&quot;</span><br><span class="line">exec 8&gt; &quot;$&#123;tempFile2&#125;&quot;</span><br><span class="line">echo &quot;This is a test line of data for $tempFile1&quot; &gt;&amp;7</span><br><span class="line">echo &quot;This is a test line of data for $tempFile2&quot; &gt;&amp;8</span><br><span class="line"></span><br><span class="line"># 关闭文件描述符</span><br><span class="line">exec 7&gt;&amp;-</span><br><span class="line">exec 8&gt;&amp;-</span><br><span class="line"></span><br><span class="line"># 显示临时文件内容</span><br><span class="line">echo &quot;Contents of $tempFile1:&quot;</span><br><span class="line">cat &quot;$&#123;tempFile1&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Contents of $tempFile2:&quot;</span><br><span class="line">cat &quot;$&#123;tempFile2&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 删除临时文件</span><br><span class="line">rm -f &quot;$&#123;tempFile1&#125;&quot; &quot;$&#123;tempFile2&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 删除临时目录</span><br><span class="line">rmdir &quot;$&#123;tempFile&#125;&quot; || echo &quot;Failed to remove directory $&#123;tempFile&#125;: It may not be empty.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Linux/">Linux</category>
      
      <category domain="https://blog.tokenlen.top/tags/shell/">shell</category>
      
      
      <comments>https://blog.tokenlen.top/2024/10/18/linux10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>瑞吉外卖解析</title>
      <link>https://blog.tokenlen.top/2024/10/18/reggie/</link>
      <guid>https://blog.tokenlen.top/2024/10/18/reggie/</guid>
      <pubDate>Thu, 17 Oct 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;公共字段解析&lt;/h1&gt;
&lt;p&gt;在使用的时候，有一些字段是一直在使用的。我们为了方便会使用MyBatis-Plus 提供的注解来完成这个功能&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>公共字段解析</h1><p>在使用的时候，有一些字段是一直在使用的。我们为了方便会使用MyBatis-Plus 提供的注解来完成这个功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 创建时间 *公共字段要进行加注解/</span><br><span class="line">   @TableField(fill = FieldFill.INSERT) // 自动填充，插入时自动填充</span><br><span class="line">   private LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">   /** 更新时间 */</span><br><span class="line">   @TableField(fill = FieldFill.INSERT_UPDATE) // 自动填充，插入和更新时自动填充</span><br><span class="line">   private LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">   @TableField(fill = FieldFill.INSERT) // 自动填充，插入时自动填充</span><br><span class="line">   private Long createUser;</span><br><span class="line"></span><br><span class="line">   @TableField(fill = FieldFill.INSERT_UPDATE) // 自动填充，插入和更新时自动填充</span><br><span class="line">   private Long updateUser;</span><br></pre></td></tr></table></figure><p>比如这四个是经常使用的公共字段</p><p>给他们加上注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@TableField(fill = FieldFill.INSERT)</span><br></pre></td></tr></table></figure><p>前面是注解，后面fill后面的是文件填充的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum FieldFill &#123;</span><br><span class="line">    DEFAULT,</span><br><span class="line">    INSERT,</span><br><span class="line">    UPDATE,</span><br><span class="line">    INSERT_UPDATE;</span><br><span class="line"></span><br><span class="line">    private FieldFill() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看源码就会发现他有四种填充的方式</p><p><strong><code>DEFAULT</code></strong>: 不进行自动填充。</p><p><strong><code>INSERT</code></strong>: 仅在插入时自动填充。</p><p><strong><code>UPDATE</code></strong>: 仅在更新时自动填充。</p><p><strong><code>INSERT_UPDATE</code></strong>: 在插入和更新时都会自动填充。</p><p>然后我们在common包下加入一个类用来实现这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br></pre></td></tr></table></figure><p>使用这两个注解</p><p>分别使用日志和Spring的注解</p><p>分别实现两个方法</p><p>一个是insertFill</p><p>一个是updateFill</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;公共字段自动填充[insert]...&quot;);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line">        metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(&quot;createUser&quot;, BaseContext.getCurrentId());     // 从 ThreadLocal 中获取当前用户的 id</span><br><span class="line">        metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId());     // 从 ThreadLocal 中获取当前用户的 id</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;公共字段自动填充[update]...&quot;);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line"></span><br><span class="line">        long id = Thread.currentThread().getId();                            // 获取当前线程的id</span><br><span class="line">        log.info(&quot;当前线程id=&#123;&#125;&quot;, id);                                        // Slf4j的日志输出</span><br><span class="line"></span><br><span class="line">        metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId());  // 从ThreadLocal中获取当前线程的用户id</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1>菜品分类解析</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/category&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CategoryService categoryService;</span><br><span class="line">    @PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;添加分类成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @PostMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&lt;Category&gt;&gt; page(int page, int pageSize) &#123;</span><br><span class="line">        Page&lt;Category&gt; categoryPage = new Page&lt;&gt;(page, pageSize);</span><br><span class="line">        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br><span class="line"></span><br><span class="line">        // 通过实例调用 page 方法</span><br><span class="line">        categoryService.page(categoryPage, queryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(categoryPage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>要做一个新的Controller</p><p>必须有一个类，然后里面定义各种数据</p><p>然后有一个Serivice接口</p><p>一个Serviceimpl类</p><p>一个Mapper接口</p><p>然后在Controller 里写具体的方法</p><h2 id="1-添加分类">1.添加分类</h2><p>先设计一个Api请求的方法</p><p>然后定义</p><p><strong><code>@Autowired private CategoryService categoryService;</code></strong>：使用 <code>@Autowired</code> 注解，将 <code>CategoryService</code> 服务自动注入到控制器中。<code>CategoryService</code> 包含保存 <code>Category</code> 对象的逻辑。</p><p>然后开始写具体的方法，save作为添加方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public R&lt;String&gt; save(@RequestBody Category category)</span><br></pre></td></tr></table></figure><p><strong><code>@PostMapping</code></strong>：标注该方法为 HTTP POST 请求的映射。客户端通过发送 POST 请求来触发该方法。就是接受浏览器的post请求</p><p><strong><code>public R&lt;String&gt; save</code></strong>：方法返回类型为 <code>R&lt;String&gt;</code>，其中 <code>R</code> 是一个泛型响应包装类，返回一个包含字符串信息的响应。</p><p><strong><code>@RequestBody Category category</code></strong>：使用 <code>@RequestBody</code> 注解，将请求中的 JSON 数据反序列化为一个 <code>Category</code> 对象，作为 <code>save</code> 方法的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;添加分类成功&quot;);</span><br></pre></td></tr></table></figure><p>首先是日志提示</p><p>然后**<code>categoryService.save(category);</code>**：调用 <code>CategoryService</code> 的 <code>save</code> 方法，将 <code>category</code> 对象存储到数据库中。这个 <code>save</code> 方法通常由 MyBatis-Plus 框架提供，<code>CategoryService</code> 通过继承 <code>IService&lt;Category&gt;</code> 或实现相关接口来提供该方法。这个需要在接口的时候继承</p><p>然后返回响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return R.success(&quot;添加分类成功&quot;);</span><br></pre></td></tr></table></figure><p>总体代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody Category category)&#123;</span><br><span class="line">        log.info(&quot;category:&#123;&#125;&quot;,category);</span><br><span class="line">        categoryService.save(category);</span><br><span class="line">        return R.success(&quot;添加分类成功&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-分页查询">2.分页查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/page&quot;)</span><br></pre></td></tr></table></figure><p>接受post请求，然后url栏中做出响应的回应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public R&lt;Page&lt;Category&gt;&gt; page(int page, int pageSize)</span><br></pre></td></tr></table></figure><p>定义page方法</p><p>里面加入page和pageSize参数，注意要使用大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;Category&gt; categoryPage = new Page&lt;&gt;(page, pageSize);</span><br></pre></td></tr></table></figure><p>新建一个Page构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.orderByAsc(Category::getSort);</span><br></pre></td></tr></table></figure><p>这里面是条件过滤，按照升序进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过实例调用 page 方法</span><br><span class="line">        categoryService.page(categoryPage, queryWrapper);</span><br></pre></td></tr></table></figure><p>调用接口的page方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return R.success(categoryPage);</span><br></pre></td></tr></table></figure><p>返回数据</p><p>一般的分页查询都是这样做的</p><p>例如：</p><p>之前的Employee</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/page&quot;)</span><br><span class="line">    public R&lt;Page&lt;Employee&gt;&gt; page(int page, int pageSize, String name) &#123;</span><br><span class="line">        log.info(&quot;分页查询，page=&#123;&#125;, pageSize=&#123;&#125;, name=&#123;&#125;&quot;, page, pageSize, name);</span><br><span class="line"></span><br><span class="line">        // 分页构造器</span><br><span class="line">        com.baomidou.mybatisplus.extension.plugins.pagination.Page&lt;Employee&gt; pageInfo = new Page&lt;&gt;(page, pageSize);</span><br><span class="line"></span><br><span class="line">        // 条件构造器</span><br><span class="line">        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        if (StringUtils.hasText(name)) &#123;  // 修正为 hasText 以避免空白字符串的情况</span><br><span class="line">            queryWrapper.like(Employee::getName, name);</span><br><span class="line">        &#125;</span><br><span class="line">        queryWrapper.orderByDesc(Employee::getUpdateTime);</span><br><span class="line"></span><br><span class="line">        // 执行查询</span><br><span class="line">        employeeService.page(pageInfo, queryWrapper);</span><br><span class="line"></span><br><span class="line">        // 返回分页结果</span><br><span class="line">        return R.success(pageInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>差不多都是一个模板</p><h2 id="3-删除分类">3.删除分类</h2><p>首先还是和之前的controller一样，先新建mapper 和Service和ServiceImpl</p><p>因为需要检测是不是和其他的东西（例如菜品，菜单有关联）所以他们的mapper和Service和Serviceimpl也需要新建</p><p>然后controller调用的时候需要一个remove方法</p><p>所以在CategoryService下需要实现一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ublic void remove(Long id);</span><br></pre></td></tr></table></figure><p>remove方法</p><p>在CategoryServiceimpl写具体的remove方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SetmealService setmealService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param id</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Long id) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);</span><br><span class="line">        int count1 =  dishService.count(dishLambdaQueryWrapper);</span><br><span class="line">        if (count1&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了菜品，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);</span><br><span class="line">        int count2 = setmealService.count();</span><br><span class="line">        if (count2&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        super.removeById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先新建remove方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br></pre></td></tr></table></figure><p>条件过滤器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);</span><br></pre></td></tr></table></figure><p>通过等于id来过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count1 =  dishService.count(dishLambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>然后记录次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (count1&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了菜品，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>非0的时候不能删除</p><p>然后下面的相似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);</span><br><span class="line">        int count2 = setmealService.count();</span><br><span class="line">        if (count2&gt;0)&#123;</span><br><span class="line">            throw new CustomException(&quot;当前分类下关联了套餐，不能删除&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>最后如果上面的都没成立的话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.removeById(id);</span><br></pre></td></tr></table></figure><p>再去调用父类的remove方法，就是mybatisplus所提供的removeById的方法</p><p>然后最后在controller里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@DeleteMapping//注意是ids哦</span><br><span class="line">   public R&lt;String&gt; delete(Long ids)&#123;</span><br><span class="line">       log.info(&quot;删除id为&#123;&#125;&quot;,ids);</span><br><span class="line">       categoryService.remove(ids);</span><br><span class="line">       return R.success(&quot;分类信息删除成功&quot;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用上面自定义的remove方法</p><h1>文件上传和下载</h1><p>文件上传和下载是一个重要的功能</p><p>直接创建一个commonController.java</p><p>然后注解为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/common&quot;)</span><br><span class="line">@Slf4j</span><br></pre></td></tr></table></figure><p>代表是controller</p><p>然后页面为./common</p><p>日志</p><p>然后导入文件地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br><span class="line">   private String basePath;</span><br></pre></td></tr></table></figure><p>注意@value是spring包下面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reggie:</span><br><span class="line">  # 文件存储位置信息|必填</span><br><span class="line">  path: C:\Users\river\code\work\javaProjects\rikky-takeaway\img\</span><br></pre></td></tr></table></figure><p>application配置</p><h2 id="upload方法">upload方法</h2><p>然后开始写upload方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/upload&quot;)</span><br><span class="line">    public R&lt;String&gt; upload(MultipartFile file) &#123;</span><br><span class="line">        log.info(file.toString());</span><br><span class="line"></span><br><span class="line">        String orginname = file.getOriginalFilename();//原始文件名</span><br><span class="line">        String suffix = orginname.substring(orginname.lastIndexOf(&quot;.&quot;));</span><br><span class="line">        String uuidname = UUID.randomUUID().toString()+suffix;</span><br><span class="line"></span><br><span class="line">        File dir  = new File(basePath);</span><br><span class="line">        if (!dir.exists())&#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            file.transferTo(new File(basePath+uuidname));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        return R.success(uuidname);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>文件上传在浏览器中以post请求来实现</p><p>所以注解为postMapping</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String orginname = file.getOriginalFilename();//原始文件名</span><br><span class="line">String suffix = orginname.substring(orginname.lastIndexOf(&quot;.&quot;));</span><br><span class="line">String uuidname = UUID.randomUUID().toString()+suffix;</span><br></pre></td></tr></table></figure><p>suffix代表 的是文件的后缀名</p><p>uuid生成一个uuid</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File dir  = new File(basePath);</span><br><span class="line">if (!dir.exists())&#123;</span><br><span class="line">    dir.mkdirs(</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一下是否存在</p><p>不存在创建</p><p>]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.transferTo(new File(basePath+uuidname));</span><br></pre></td></tr></table></figure><p>最后上传，为地址加上uuid的Name</p><p>然后返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return R.success(uuidname);</span><br></pre></td></tr></table></figure><h2 id="download方法">download方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/download&quot;)</span><br><span class="line">    public void download(String name, HttpServletResponse response) &#123;</span><br><span class="line">        try (FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));</span><br><span class="line">             ServletOutputStream servletOutputStream = response.getOutputStream()) &#123;</span><br><span class="line"></span><br><span class="line">            response.setContentType(&quot;image/jpeg&quot;);</span><br><span class="line">            byte[] bytes = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line"></span><br><span class="line">            while ((len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">                servletOutputStream.write(bytes, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            servletOutputStream.flush();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            // 文件未找到的处理逻辑</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            log.error(&quot;File not found: &quot; + name, e);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // 其他I/O异常处理</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">            log.error(&quot;Error occurred during file download&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>download就是get方法了</p><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));</span><br><span class="line">             ServletOutputStream servletOutputStream = response.getOutputStream())</span><br></pre></td></tr></table></figure><p>去读取这个文件</p><p>设置类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;image/jpeg&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byte[] bytes = new byte[1024];</span><br><span class="line">            int len;</span><br><span class="line"></span><br><span class="line">            while ((len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">                servletOutputStream.write(bytes, 0, len);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>去讲文件内的内容给读取出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servletOutputStream.flush();</span><br></pre></td></tr></table></figure><p>刷新流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catch (FileNotFoundException e) &#123;</span><br><span class="line">            // 文件未找到的处理逻辑</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            log.error(&quot;File not found: &quot; + name, e);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // 其他I/O异常处理</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">            log.error(&quot;Error occurred during file download&quot;, e);</span><br></pre></td></tr></table></figure><p>异常处理</p><p>使用这个结构的时候，流会自动关闭所以不用了</p><h1>新建菜品</h1><p>还是跟之前的一样，先新建Mapping，然后新建Service，然后再新建ServiceImpl</p><p>最后写Controller</p><h2 id="所选分类">所选分类</h2><p>这个和分类有关，所以放在Categorycontroller下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据条件查询数据</span><br><span class="line"> * @param category</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">public R&lt;List&lt;Category&gt;&gt; list(Category category)&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.eq(category.getType()!=null,Category::getType,category.getType());</span><br><span class="line">    lambdaQueryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br><span class="line">    categoryService.list(lambdaQueryWrapper);</span><br><span class="line">    List&lt;Category&gt; list = categoryService.list(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">    return R.success(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/list&quot;)</span><br></pre></td></tr></table></figure><p>和前端像对应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Category&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lambdaQueryWrapper.eq(category.getType()!=null,Category::getType,category.getType());</span><br><span class="line">lambdaQueryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);</span><br></pre></td></tr></table></figure><p>条件过滤一下啊</p><p>瞎看type是不是等于空，然后按sort来升序，再按更新时间来降序排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categoryService.list(lambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>然后Service列出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Category&gt; list = categoryService.list(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">        return R.success(list);</span><br></pre></td></tr></table></figure><p>把结果放List里面然后返回结果</p><h2 id="提交数据">提交数据</h2><p>想要把前端所写的数据提交到后端，对数据库进行更改就要将其用json格式提交</p><p>就要导入dto类型</p><p>在项目的包下新建dto包，然后导入类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.mengnankk.dto;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.mengnankk.entity.Dish;</span><br><span class="line">import com.mengnankk.entity.DishFlavor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class DishDto extends Dish &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private String categoryName;</span><br><span class="line"></span><br><span class="line">    private Integer copies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为是新增菜品，所以要在DishController下新增方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/dish&quot;)</span><br><span class="line">public class DishController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DishService dishService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DishFlavorServiceImpl dishFlavorService;</span><br><span class="line"></span><br><span class="line">@PostMapping</span><br><span class="line">    public R&lt;String&gt; save(@RequestBody DishDto dishDto)&#123;</span><br><span class="line">        log.info(dishDto.toString());</span><br><span class="line"></span><br><span class="line">        return R.success(&quot;新增成功&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>新增save方法，将其转为类型后回显</p><p>然后还涉及到菜品的口味，所以DishFlavor相关的Service和ServiceImpl都要建立对应的实现</p><p>Service建立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface DishFlavorService extends IService&lt;DishFlavor&gt; &#123;</span><br><span class="line">    // 保存菜品及其口味</span><br><span class="line">    R&lt;String&gt; saveWithFlavor(DishDto dishDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Impl进行具体方法的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private DishService dishService;  // 注入 DishService 用于保存菜品</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public R&lt;String&gt; saveWithFlavor(DishDto dishDto) &#123;</span><br><span class="line">        log.info(&quot;开始录入信息&quot;);</span><br><span class="line">        // 1. 保存菜品信息</span><br><span class="line">        Dish dish = new Dish();</span><br><span class="line">        // 假设 DishDto 中有名称、类别等属性，复制到 Dish 实体</span><br><span class="line">        dish.setName(dishDto.getName());</span><br><span class="line">        dish.setCategoryId(dishDto.getCategoryId());</span><br><span class="line">        // 其他属性的复制...</span><br><span class="line"></span><br><span class="line">        // 保存菜品实体</span><br><span class="line">        dishService.save(dish);  // 调用 DishService 保存菜品</span><br><span class="line"></span><br><span class="line">        // 2. 获取保存后的菜品 ID</span><br><span class="line">        Long dishID = dish.getId();</span><br><span class="line">        if (dishID == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;保存菜品时未能生成 ID&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 保存口味数据</span><br><span class="line">        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors().stream().map(item -&gt; &#123;</span><br><span class="line">            item.setDishId(dishID);  // 设置每个口味的菜品 ID</span><br><span class="line">            return item;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        // 批量保存口味</span><br><span class="line">        this.saveBatch(flavors);</span><br><span class="line">        return R.success(&quot;新增成功&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体的注释上都写了</p><p>然后这项功能算是这样就写完了</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/springboot/">springboot</category>
      
      
      <comments>https://blog.tokenlen.top/2024/10/18/reggie/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux 运维篇</title>
      <link>https://blog.tokenlen.top/2024/10/14/linux9/</link>
      <guid>https://blog.tokenlen.top/2024/10/14/linux9/</guid>
      <pubDate>Sun, 13 Oct 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;网络运维&lt;/h1&gt;
&lt;h2 id=&quot;无法访问外网的域名&quot;&gt;无法访问外网的域名&lt;/h2&gt;
&lt;p&gt;应该就是dns解析出了问题&lt;/p&gt;
&lt;p&gt;我们就要在hosts解析里进行修改&lt;/p&gt;
&lt;figure class=&quot;highlight</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>网络运维</h1><h2 id="无法访问外网的域名">无法访问外网的域名</h2><p>应该就是dns解析出了问题</p><p>我们就要在hosts解析里进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;192.168.0.1 hostname&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><p>在文件中添加本机ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ hostname</span><br><span class="line">mengnankk-linux</span><br></pre></td></tr></table></figure><p>配置信赖的 DNS 服务器</p><p>执行 <code>vi /etc/resolv.conf</code> ，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>一个是国内老牌的</p><p>一个是谷歌的dns解析</p><p>然后ping一下是不是能ping通</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">❯ ping mengnankk.asia</span><br><span class="line">PING mengnankk.asia (76.76.21.93) 56(84) bytes of data.</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=1 ttl=128 time=95.4 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=2 ttl=128 time=121 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=3 ttl=128 time=118 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=4 ttl=128 time=106 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=5 ttl=128 time=149 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=6 ttl=128 time=97.2 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=7 ttl=128 time=125 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=8 ttl=128 time=116 ms</span><br><span class="line">64 bytes from 76.76.21.93 (76.76.21.93): icmp_seq=9 ttl=128 time=103 ms</span><br><span class="line">^C</span><br><span class="line">--- mengnankk.asia ping statistics ---</span><br><span class="line">9 packets transmitted, 9 received, 0% packet loss, time 8015ms</span><br><span class="line">rtt min/avg/max/mdev = 95.444/114.418/148.506/15.561 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok了可以ping通说明我们已经配置成功了</p><h2 id="网卡配置">网卡配置</h2><p>使用root权限编辑</p><p><code>/etc/sysconfig/network-scripts/ifcfg-eno16777736X</code> 文件</p><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet                        # 网络类型：Ethernet以太网</span><br><span class="line">BOOTPROTO=none                       # 引导协议：自动获取、static静态、none不指定</span><br><span class="line">DEFROUTE=yes                         # 启动默认路由</span><br><span class="line">IPV4_FAILURE_FATAL=no                # 不启用IPV4错误检测功能</span><br><span class="line">IPV6INIT=yes                         # 启用IPV6协议</span><br><span class="line">IPV6_AUTOCONF=yes                    # 自动配置IPV6地址</span><br><span class="line">IPV6_DEFROUTE=yes                    # 启用IPV6默认路由</span><br><span class="line">IPV6_FAILURE_FATAL=no                # 不启用IPV6错误检测功能</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_PRIVACY=&quot;no&quot;</span><br><span class="line"></span><br><span class="line">NAME=eno16777736                     # 网卡设备的别名（需要和文件名同名）</span><br><span class="line">UUID=90528772-9967-46da-b401-f82b64b4acbc  # 网卡设备的UUID唯一标识号</span><br><span class="line">DEVICE=eno16777736                   # 网卡的设备名称</span><br><span class="line">ONBOOT=yes                           # 开机自动激活网卡</span><br><span class="line">IPADDR=192.168.1.199                 # 网卡的固定IP地址</span><br><span class="line">PREFIX=24                            # 子网掩码</span><br><span class="line">GATEWAY=192.168.1.1                  # 默认网关IP地址</span><br><span class="line">DNS1=8.8.8.8                         # DNS域名解析服务器的IP地址</span><br></pre></td></tr></table></figure><p>修改完后，执行 <code>systemctl restart network.service</code> 重启网卡服务。</p><h2 id="系统维护">系统维护</h2><h3 id="Linux-开机自启动脚本">Linux 开机自启动脚本</h3><p><strong>（1）在 <code>/etc/rc.local</code> 文件中添加命令</strong></p><p>如果不想将脚本粘来粘去，或创建链接，可以在 <code>/etc/rc.local</code> 文件中添加启动命令</p><ol><li>先修改好脚本，使其所有模块都能在任意目录启动时正常执行;</li><li>再在 <code>/etc/rc.local</code> 的末尾添加一行以绝对路径启动脚本的行;</li></ol><p>例：</p><p>执行 <code>vim /etc/rc.local</code> 命令，输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line"># This script will be executed *after* all the other init scripts.</span><br><span class="line"># You can put your own initialization stuff in here if you don&#x27;t</span><br><span class="line"># want to do the full Sys V style init stuff.</span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/opt/pjt_test/test.pl</span><br></pre></td></tr></table></figure><p>这个感觉比较舒服</p><p><strong>（2）在 <code>/etc/rc.d/init.d</code> 目录下添加自启动脚本</strong></p><p>Linux 在 <code>/etc/rc.d/init.d</code> 下有很多的文件，每个文件都是可以看到内容的，其实都是一些 shell 脚本或者可执行二进制文件。</p><p>Linux 开机的时候，会加载运行 <code>/etc/rc.d/init.d</code> 目录下的程序，因此我们可以把想要自动运行的脚本放到这个目录下即可。系统服务的启动就是通过这种方式实现的。</p><p><strong>(3)现在新使用systemctl服务来添加自启动的脚本</strong></p><p>先保存好要使用的脚本，然后确定对脚本有可执行权限</p><p><strong>创建一个 <code>systemd</code> 服务文件</strong>： 在 <code>/etc/systemd/system/</code> 目录下创建一个服务文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo nano /etc/systemd/system/clashvpn.service</span><br></pre></td></tr></table></figure><p>然后对文件进行编辑</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Run the shell script at startup</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/zsh /home/mengnankk/shellcoode/clash.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后重新加载，设置自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">❯ sudo systemctl enable clashvpn.service</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/clashvpn.service → /etc/systemd/system/clashvpn.service.</span><br></pre></td></tr></table></figure><p>然后查看启动，查看当前状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo systemctl start clashvpn.service</span><br><span class="line">❯ sudo systemctl status clashvpn.service</span><br><span class="line">● clashvpn.service - Run the clash shell script at startup</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/clashvpn.service; enabled; vendor pres&gt;</span><br><span class="line">     Active: active (running) since Wed 2024-10-16 18:31:28 CST; 20s ago</span><br><span class="line">   Main PID: 18080 (zsh)</span><br><span class="line">      Tasks: 12 (limit: 4551)</span><br></pre></td></tr></table></figure><p>ps和查看一下自启动是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ ps -aux|rg clash</span><br><span class="line">mengnan+   11952  0.0  0.0  13712  3840 pts/0    S+   18:24   0:00 /bin/zsh ./shclash.sh</span><br><span class="line">root       18080  0.0  0.0  13708  3840 ?        Ss   18:31   0:00 /bin/zsh /home/mengnankk/shellcode/shclash.sh</span><br><span class="line">mengnan+   18339  0.0  0.1   8456  5888 pts/1    S+   18:32   0:00 rg clash</span><br><span class="line">❯ sudo systemctl is-enabled clashvpn.service</span><br><span class="line">enabled</span><br></pre></td></tr></table></figure><p>发现成功了捏</p><p>我们重新启动一下，看看是不能用上哈</p><h1>环境配置</h1><h2 id="maven的安装">maven的安装</h2><p>进入官网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://maven.apache.org/download.cgi</span><br></pre></td></tr></table></figure><p>然后下载合适的版本</p><p>然后解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo tar -xzvf apache-maven-3.9.9-bin.tar.gz -C /opt/maven --strip-components=1</span><br></pre></td></tr></table></figure><p>输入 <code>vim /etc/profile</code> ，添加环境变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/opt/maven/apache-maven-3.9.9</span><br><span class="line">export PATH=$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>编辑然后执行生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo vim /etc/profile</span><br><span class="line">❯ source /etc/profile</span><br></pre></td></tr></table></figure><p>mvn -v 查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ mvn -v</span><br><span class="line">Apache Maven 3.9.9 (8e8579a9e76f7d015ee5ec7bfcdc97d260186937)</span><br><span class="line">Maven home: /opt/maven</span><br><span class="line">Java version: 11.0.24, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;6.8.0-47-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure><h2 id="nodejs安装">nodejs安装</h2><p>执行安装脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">❯ rm -rf ~/.nvm</span><br><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br><span class="line">. ~/.nvm/nvm.sh</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 12540  100 12540    0     0  14905      0 --:--:-- --:--:-- --:--:-- 14928</span><br><span class="line">=&gt; Downloading nvm from git to &#x27;/home/mengnankk/.nvm&#x27;</span><br><span class="line">=&gt; 正克隆到 &#x27;/home/mengnankk/.nvm&#x27;...</span><br><span class="line">remote: Enumerating objects: 264, done.</span><br><span class="line">remote: Counting objects: 100% (264/264), done.</span><br><span class="line">remote: Compressing objects: 100% (230/230), done.</span><br><span class="line">remote: Total 264 (delta 31), reused 102 (delta 24), pack-reused 0 (from 0)</span><br><span class="line">接收对象中: 100% (264/264), 116.38 KiB | 384.00 KiB/s, 完成.</span><br><span class="line">处理 delta 中: 100% (31/31), 完成.</span><br><span class="line">注意：正在切换到 &#x27;7ad6d98cedde01809e32d56ab8ced064f6f28175&#x27;。</span><br><span class="line"></span><br><span class="line">您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换</span><br><span class="line">回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。</span><br><span class="line"></span><br><span class="line">如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令</span><br><span class="line">中添加参数 -c 来实现（现在或稍后）。例如：</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">或者撤销此操作：</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">通过将配置变量 advice.detachedHead 设置为 false 来关闭此建议</span><br><span class="line"></span><br><span class="line">=&gt; Compressing and cleaning up git repository</span><br><span class="line"></span><br><span class="line">=&gt; Appending nvm source string to /home/mengnankk/.zshrc</span><br><span class="line">=&gt; Appending bash_completion source string to /home/mengnankk/.zshrc</span><br><span class="line">=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:</span><br><span class="line"></span><br><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br><span class="line">[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</span><br><span class="line">❯  nvm --version</span><br><span class="line">0.33.8</span><br></pre></td></tr></table></figure><p>然后查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 8.9.4</span><br><span class="line">nvm use 8.9.4</span><br></pre></td></tr></table></figure><p>使用指令安装指定版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ nvm install 8.9.4</span><br><span class="line">nvm use 8.9.4</span><br><span class="line">Version &#x27;8.9.4&#x27; not found - try `nvm ls-remote` to browse available versions.</span><br><span class="line">N/A: version &quot;8.9.4 -&gt; N/A&quot; is not yet installed.</span><br><span class="line"></span><br><span class="line">You need to run &quot;nvm install 8.9.4&quot; to install it before using it.</span><br></pre></td></tr></table></figure><p>但我折腾了半天，还是不能使用npm来下载</p><p>所以就是用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   ~  sudo apt install -y nodejs   </span><br></pre></td></tr></table></figure><p>这个来直接下载了</p><p>检查一下版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line"></span><br><span class="line">v3.3.1</span><br><span class="line">4.6.1</span><br></pre></td></tr></table></figure><p>ok完成</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Linux/">Linux</category>
      
      
      <comments>https://blog.tokenlen.top/2024/10/14/linux9/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
