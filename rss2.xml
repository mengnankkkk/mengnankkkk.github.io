<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Fri, 27 Jun 2025 14:30:37 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>大麦网业务分析-1</title>
      <link>https://blog.tokenlen.top/2025/06/27/workmenu/damai1/</link>
      <guid>https://blog.tokenlen.top/2025/06/27/workmenu/damai1/</guid>
      <pubDate>Thu, 26 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;h2 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>分库分表是解决海量数据存储和高并发访问的有效手段，但其设计并非一蹴而就，需要深入思考以下几个核心原则和复杂性。</p><h3 id="分片键—-重要"><a href="#分片键—-重要" class="headerlink" title="分片键—-重要"></a><strong>分片键</strong>—-重要</h3><p>分片键是数据分布的依据，其选择直接决定了分片策略的有效性和未来的可维护性。</p><ul><li><strong>业务相关性</strong>: 分片键应与核心业务逻辑紧密相关。例如，用户相关数据以 <code>user_id</code> 分片，订单相关数据可能也以 <code>user_id</code> 分片以保证用户维度的数据局部性。</li><li><strong>数据均匀性</strong>: 理想的分片键能够将数据均匀地分散到各个分片中，避免出现“<strong>热点</strong>”（某个分片数据量过大或访问压力过高）。通常采用哈希（如 <code>MD5(user_id) % N</code> 或更复杂的哈希算法）或自定义算法来确保均匀分布。</li></ul><p>可以通过<strong>历史数据分析</strong>来模拟不同分片键策略下的数据分布情况，评估其均匀性。对于哈希取模，可以考虑使用<strong>一致性哈希</strong>，它在节点增减时能更好地保持数据分布的均衡性，减少数据迁移量。</p><ul><li><p><strong>稳定性</strong>: 分片键一旦确定，通常不应改变。如果分片键的值会频繁更新，会带来数据迁移和维护的巨大挑战。</p><p>对于那些<strong>不含分片键的查询</strong>，需要特别关注。这类查询通常会触发<strong>全表扫描</strong>（或全分片扫描），性能极低。在设计业务功能时，应尽量引导业务方在查询条件中包含分片键。如果无法避免，则需要考虑其他方案，例如：</p></li></ul><p><strong>数据冗余：</strong> 将少量高频查询但无分片键的数据冗余到所有分片或单独的热点库中。</p><p><strong>ES/Solr等搜索引擎：</strong> 对于复杂查询、模糊查询或多维度查询，可以考虑将部分数据同步到Elasticsearch或Solr等搜索引擎中，利用其强大的查询能力，将查询压力从关系型数据库中剥离。</p><p><strong>数仓或OLAP系统：</strong> 对于报表、统计等分析类查询，应将其导入到数仓或OLAP系统中进行处理，避免直接冲击在线事务数据库。</p><ul><li><strong>查询命中率</strong>: 绝大部分查询应该能够<strong>通过分片键直接路由到唯一的分片</strong>，避免跨分片查询，从而提高效率。</li><li><strong>数据类型</strong>: 通常选择整数类型（如 <code>bigint</code>）作为分片键，因为它们计算和比较效率高。</li></ul><h3 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a><strong>分片策略</strong></h3><p>​    <strong>水平分片 (Horizontal Sharding/Row-based Sharding)</strong>: 将表中行数据分散到不同的物理表或数据库中。这是最常见的模式，也是您文件中的 <code>_0</code>, <code>_1</code> 后缀所体现的。</p><p><strong>好处</strong>: 扩展性强，可以根据数据增长动态增加分片。查询通常只涉及少量数据，性能高。</p><p><strong>常见实现</strong>:</p><ul><li><strong>哈希取模</strong>: <code>sharding_key % N</code>（N为分片总数），<strong>数据分布最均匀</strong>，但扩容时需要数据迁移（弹性伸缩性差）。</li><li><strong>范围分片</strong>: 根据分片键的值范围划分，例如用户ID 1-100万在一个分片，100万-200万在另一个。优点是扩容方便（直接增加新范围分片），缺点是容易出现热点。</li><li><strong>一致性哈希</strong>: 一种更高级的哈希算法，在增加或减少分片时，只需要迁移少量数据，弹性伸缩性更好。</li><li><strong>时间分片</strong>: 例如按年或月创建新表，用于日志、流水等时间序列数据。</li></ul><p>对于用户数据，哈希取模通常是首选，因为它能带来更好的均匀性。而对于按时间产生的日志或流水数据，时间分片则更为合适。<strong>一致性哈希：</strong> 这是一种更高级且更灵活的策略，值得深入研究和应用，尤其是在需要频繁扩容或缩容的场景。它能有效降低数据迁移的成本。</p><p><strong>垂直分片 (Vertical Sharding/Column-based Sharding)</strong>:</p><p>​    <strong>按业务功能分库</strong>: 将不同业务模块的数据（例如用户服务、订单服务、商品服务）分别存储在独立的数据库中。这通常是微服务架构中的常见实践。</p><ul><li><strong>好处</strong>: 职责分离，团队独立开发维护，数据库之间互不影响，方便根据业务特点进行优化。</li><li><strong>例子</strong>: <code>damai_base_data</code>, <code>damai_customize</code>, <code>damai_order_0/1</code>, <code>damai_pay_0/1</code>, <code>damai_program_0/1</code>, <code>damai_user_0/1</code> 等数据库的划分，明显是按业务领域（基础数据、定制、订单、支付、节目、用户）进行的垂直分库。</li></ul><p>​    <strong>按字段分表</strong>: 将一张表中不同业务含义或访问频率差异大的列拆分到不同的表中，以减少单表宽度，提高查询效率。<strong>解决大宽表问题</strong>上非常有效。过多的垂直分表可能会增加数据管理的复杂性。</p><ul><li><strong>好处</strong>: 减少I/O开销，热点数据和非热点数据分离存储，提高查询效率。</li></ul><p>在决定按字段分表时，应<strong>仔细分析字段的访问频率、更新频率以及是否包含大文本或二进制数据</strong>。通常将不常用的大字段、或者单独查询频率高的字段拆分出去。</p><h3 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a><strong>数据路由</strong></h3><p>分片后，应用程序如何知道数据存在哪个分片上？这需要一个路由层。</p><ul><li><strong>应用层路由</strong>: 应用程序代码根据分片键和分片算法直接计算出目标分片，然后连接到对应的数据库。实现简单，但应用逻辑与分片规则耦合。</li><li><strong>中间件路由</strong>: 使用专门的数据库中间件（如MyCAT, ShardingSphere, Vitess）作为代理层，应用程序连接中间件，中间件负责解析SQL、计算分片、路由请求、聚合结果。这是最推荐的方式，实现了分片逻辑与应用解耦，提供了更丰富的功能（如分布式事务、读写分离）。</li></ul><p><strong>ShardingSphere</strong>作为一套成熟的开源分布式数据库解决方案，提供了丰富的特性，包括数据分片、分布式事务、数据加密、影子库压测等，且支持多种部署模式，是目前非常受欢迎的选择。</p><p><strong>MyCAT</strong>更偏向于一个数据库代理层，配置相对简单。</p><p><strong>Vitess</strong>源自YouTube，更侧重于自动化运维和大规模部署，适合超大规模的场景。</p><h3 id="全局唯一ID生成"><a href="#全局唯一ID生成" class="headerlink" title="全局唯一ID生成"></a>全局唯一ID生成</h3><p>在分库分表后，数据库的自增ID不能再使用，因为它们只能保证单库内的唯一性。需要引入全局唯一ID生成策略。</p><ul><li><strong>UUID/GUID</strong>: 优点是全局唯一，生成简单；缺点是无序，作为主键索引性能差，存储空间大。</li></ul><p>虽然生成简单且全局唯一，但作为主键<strong>索引性能差</strong>是其致命缺点，因为其无序性导致B+树索引频繁分裂，影响写入性能和查询效率。应尽量避免作为主键。</p><ul><li><strong>基于时间戳+机器ID+序列号</strong>: 如Snowflake算法，生成趋势递增的ID，有助于索引性能。</li></ul><p>这是目前<strong>最推荐</strong>的方案。它生成的ID<strong>趋势递增</strong>，有利于数据库索引性能。同时，通过机器ID和序列号保证了全局唯一性。引入<strong>时钟回拨问题</strong>的应对策略。Snowflake算法依赖于系统时钟，如果系统时钟发生回拨，可能会生成重复ID或阻塞。需要有机制检测并处理这种情况（例如，等待时钟恢复或暂停ID生成服务）。</p><ul><li><strong>独立ID生成服务</strong>: 单独部署一个服务来生成和分配ID。</li></ul><p>部署一个独立的ID生成服务，可以提供更强的可控性和定制性，但增加了系统复杂度和维护成本。在没有特殊需求的情况下，Snowflake算法通常足以满足需求。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>当一个业务操作涉及多个分片的数据修改时，需要保证这些操作的原子性（要么都成功，要么都失败）。</p><ul><li><strong>2PC (Two-Phase Commit)</strong>: 传统的关系型数据库分布式事务协议，但性能差，有阻塞风险。</li></ul><p>理论上能保证强一致性，但由于其同步阻塞、性能低、易死锁等缺点，<strong>在线业务中极少使用</strong>，尤其是在高并发场景下。</p><ul><li><strong>TCC (Try-Confirm-Cancel)</strong>: 业务层面的分布式事务解决方案，需要侵入业务代码，但性能较好。</li></ul><p>是一种业务侵入性较强的柔性事务方案，需要业务开发人员在每个参与者服务中实现Try、Confirm、Cancel三个操作。 TCC适用于<strong>对实时性要求较高，且业务逻辑相对独立</strong>的场景。它的优点是性能比2PC好，但<strong>开发成本和维护成本较高</strong>，需要仔细设计补偿逻辑。</p><ul><li><strong>消息最终一致性</strong>: 通过消息队列（MQ）实现异步补偿，保证最终一致性，适用于对实时性要求不高的场景。</li></ul><p>通过可靠消息队列（如Kafka, RocketMQ）实现，将<strong>业务操作拆分为多个本地事务</strong>，通过消息通知其他服务进行后续操作。即使某个操作失败，也可以通过重试或补偿机制最终达到一致。</p><p>最终一致性，可能存在短暂的数据不一致窗口期；需要引入消息队列，增加系统复杂度。</p><p>在设计消息最终一致性方案时，需要考虑<strong>消息的幂等性消费</strong>、<strong>消息的可靠投递</strong>（本地消息表/事务消息）、<strong>死信队列</strong>和<strong>补偿机制</strong>。</p><h3 id="跨分片查询与Join"><a href="#跨分片查询与Join" class="headerlink" title="跨分片查询与Join"></a>跨分片查询与Join</h3><p>分片的主要目的是避免跨分片操作。如果业务逻辑不可避免地需要跨分片Join或聚合查询，会非常复杂和低效。</p><ul><li><strong>尽量避免</strong>: 优化业务逻辑，将需要Join的数据放在同一个分片上（如关联表也使用相同的分片键）。</li><li><strong>应用层Join</strong>: 从各个分片查询数据，然后在应用层进行内存Join。</li><li><strong>数据冗余</strong>: 少量关键数据在不同分片上进行冗余存储，以避免跨分片Join。</li><li><strong>数据同步/ETL</strong>: 将需要Join的数据通过ETL同步到数仓或专门的分析数据库中进行分析。</li></ul><h3 id="数据迁移和扩容"><a href="#数据迁移和扩容" class="headerlink" title="数据迁移和扩容"></a>数据迁移和扩容</h3><p>当业务增长，分片容量不足时，需要进行扩容，这涉及数据迁移。这是一个复杂且风险高的操作，通常需要专门的工具和详细的预案。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/27/workmenu/damai1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RocketMQ</title>
      <link>https://blog.tokenlen.top/2025/06/26/new-stack/rocketMQ1/</link>
      <guid>https://blog.tokenlen.top/2025/06/26/new-stack/rocketMQ1/</guid>
      <pubDate>Wed, 25 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;RocketMQ 是阿里巴巴开源的分布式消息中间件，后贡献给 Apache</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>RocketMQ 是阿里巴巴开源的分布式消息中间件，后贡献给 Apache 基金会，具有以下特点：</p><ul><li>高性能、高可靠</li><li>支持顺序消息、事务消息、延迟消息</li><li>分布式部署、可横向扩展</li><li>支持多种消费模式（集群 / 广播）</li><li>支持 Java 原生 API，客户端丰富</li></ul><div class="table-container"><table><thead><tr><th>问题</th><th>MQ 的解决方案</th></tr></thead><tbody><tr><td>系统间耦合</td><td>解耦，异步通信</td></tr><tr><td>接口调用慢</td><td>异步投递，提高响应速度</td></tr><tr><td>流量高峰</td><td>削峰填谷</td></tr><tr><td>操作失败</td><td>重试机制</td></tr><tr><td>通知机制复杂</td><td>发布/订阅</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Producer（生产者）</span><br><span class="line">    |</span><br><span class="line">    ↓</span><br><span class="line">NameServer（名称服务） ← Broker 启动时注册路由</span><br><span class="line">    ↑</span><br><span class="line">    |</span><br><span class="line">Broker（消息中转和存储） ←→ Consumer（消费者）</span><br></pre></td></tr></table></figure><p><strong>Producer</strong>：发送消息，支持同步、异步、单向、事务等方式</p><p><strong>Broker</strong>：消息存储/转发中枢（核心组件）</p><p><strong>NameServer</strong>：维护 Broker 列表和 Topic 路由信息</p><p><strong>Consumer</strong>：消费消息，支持 push（推）/ pull（拉）模式</p><p><strong>Topic</strong>：逻辑分类，一个 Topic 可有多个 Queue</p><p><strong>MessageQueue (队列)</strong>：消息的物理存储单位（一个文件）</p><div class="table-container"><table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>Topic</td><td>消息主题，逻辑分类（如：order_create）</td></tr><tr><td>Queue</td><td>实际消息存储的分片单位，一个 Topic 会被分到多个 Queue</td></tr><tr><td>Producer Group</td><td>同一类生产者的集合（事务回查会用）</td></tr><tr><td>Consumer Group</td><td>同一类消费者的集合，实现负载均衡或广播</td></tr><tr><td>Tag</td><td>同一 Topic 下用于细分消息的标识，消费者可按 Tag 过滤消息</td></tr><tr><td>Offset</td><td>消费者在队列中的消费位置</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>模式</th><th>特点</th></tr></thead><tbody><tr><td>集群消费（Clustering）</td><td>同一个 Consumer Group 内部负载均衡消费</td></tr><tr><td>广播消费（Broadcasting）</td><td>每个消费者都接收完整消息</td></tr></tbody></table></div><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>下单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ 订单服务中</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(OrderDTO orderDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 保存订单到数据库</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 发送事务消息到 RocketMQ</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;order-topic&quot;</span>, <span class="string">&quot;create&quot;</span>, JSON.toJSONString(order).getBytes());</span><br><span class="line">    <span class="type">TransactionSendResult</span> <span class="variable">result</span> <span class="operator">=</span> txProducer.sendMessageInTransaction(message, orderDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受扣库存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RocketMQ 事务监听器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">    <span class="type">OrderDTO</span> <span class="variable">orderDTO</span> <span class="operator">=</span> (OrderDTO) arg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stockService.tryLockStock(orderDTO.getProductId()); <span class="comment">// 扣库存逻辑</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/rocketmq/">rocketmq</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/26/new-stack/rocketMQ1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MQ面试题目hot</title>
      <link>https://blog.tokenlen.top/2025/06/24/new-stack/MQ1/</link>
      <guid>https://blog.tokenlen.top/2025/06/24/new-stack/MQ1/</guid>
      <pubDate>Mon, 23 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h1&gt;&lt;h2 id=&quot;1-什么是消息队列？&quot;&gt;&lt;a href=&quot;#1-什么是消息队列？&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="1-什么是消息队列？"><a href="#1-什么是消息队列？" class="headerlink" title="1.什么是消息队列？"></a>1.什么是消息队列？</h2><p>你可以把消息队列理解为一个<strong>使用队列来通信</strong>的组件。它的本质，就是个<strong>转发器</strong>，包含<strong>发消息、存消息、消费消息</strong>的过程。最简单的消息队列模型如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20250407141749839.png" alt="img"></p><p>我们通常说的消息队列，简称<strong>MQ（Message Queue）</strong>，它其实就指<strong>消息中间件</strong>，当前业界比较流行的开源消息中间件包括：<code>RabbitMQ、RocketMQ、Kafka</code>。</p><h2 id="2-消息队列怎么选型？"><a href="#2-消息队列怎么选型？" class="headerlink" title="2.消息队列怎么选型？"></a>2.消息队列怎么选型？</h2><p>Kafka、ActiveMQ、RabbitMQ、RocketMQ来进行不同维度对比。</p><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10 万级</td><td>10 万级</td></tr><tr><td>时效性</td><td>毫秒级</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td></tr><tr><td>可用性</td><td>高（主从）</td><td>高（主从）</td><td>非常高（分布式）</td><td>非常高（分布式）</td></tr><tr><td>消息重复</td><td>至少一次</td><td>至少一次</td><td>至少一次 最多一次</td><td>至少一次最多一次</td></tr><tr><td>消息顺序性</td><td>有序</td><td>有序</td><td>有序</td><td>分区有序</td></tr><tr><td>支持主题数</td><td>千级</td><td>百万级</td><td>千级</td><td>百级，多了性能严重下滑</td></tr><tr><td>消息回溯</td><td>不支持</td><td>不支持</td><td>支持（按时间回溯）</td><td>支持（按offset回溯）</td></tr><tr><td>管理界面</td><td>普通</td><td>普通</td><td>完善</td><td>普通</td></tr></tbody></table></div><p>选型的时候，我们需要根据业务场景，结合上述特性来进行选型。</p><p>比如你要支持天猫双十一类超大型的秒杀活动，这种一锤子买卖，那管理界面、消息回溯啥的不重要。</p><p>我们需要看什么？看吞吐量！</p><p>所以优先选Kafka和RocketMQ这种更高吞吐的。</p><p>比如做一个公司的中台，对外提供能力，那可能会有很多主题接入，这时候主题个数又是很重要的考量，像Kafka这样百级的，就不太符合要求，可以根据情况考虑千级的RocketMQ，甚至百万级的RabbitMQ。</p><p>又比如是一个金融类业务，那么重点考虑的就是稳定性、安全性，分布式部署的Kafka和Rocket就更有优势。</p><p>特别说一下时效性，<strong>RabbitMQ以微秒的时效作为招牌</strong>，但实际上毫秒和微秒，在绝大多数情况下，都没有感知的区别，加上网络带来的波动，这一点在生产过程中，反而不会作为重要的考量。</p><p>其它的特性，如消息确认、消息回溯，也经常作为考量的场景，管理界面的话试公司而定了，反正我呆过的地方，都不看重这个，毕竟都有自己的运维体系。</p><h2 id="3-消息队列使用场景有哪些？"><a href="#3-消息队列使用场景有哪些？" class="headerlink" title="3.消息队列使用场景有哪些？"></a>3.消息队列使用场景有哪些？</h2><ul><li><strong>解耦</strong>：可以在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，只要该操作不是需要同步的，就可以改为使用MQ进行不同系统之间的联系，这样项目之间不会存在耦合，系统之间不会产生太大的影响，就算一个系统挂了，也只是消息挤压在MQ里面没人进行消费而已，不会对其他的系统产生影响。</li><li><strong>异步</strong>：加入一个操作设计到好几个步骤，这些步骤之间不需要同步完成，比如客户去创建了一个订单，还要去客户轨迹系统添加一条轨迹、去库存系统更新库存、去客户系统修改客户的状态等等。这样如果这个系统都直接进行调用，那么将会产生大量的时间，这样对于客户是无法接收的；并且像添加客户轨迹这种操作是不需要去同步操作的，如果使用MQ将客户创建订单时，将后面的轨迹、库存、状态等信息的更新全都放到MQ里面然后去异步操作，这样就可加快系统的访问速度，提供更好的客户体验。</li><li><strong>削峰</strong>：一个系统访问流量有高峰时期，也有低峰时期，比如说，中午整点有一个抢购活动等等。比如系统平时流量并不高，一秒钟只有100多个并发请求，系统处理没有任何压力，一切风平浪静，到了某个抢购活动时间，系统并发访问了剧增，比如达到了每秒5000个并发请求，而我们的系统每秒只能处理2000个请求，那么由于流量太大，我们的系统、数据库可能就会崩溃。这时如果使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，就可以保证系统的稳定，只是可能要跟进业务逻辑，给用户返回特定页面或者稍后通过其他方式通知其结果</li></ul><h2 id="4-消息重复消费怎么解决？"><a href="#4-消息重复消费怎么解决？" class="headerlink" title="4.消息重复消费怎么解决？"></a>4.消息重复消费怎么解决？</h2><p>生产端为了保证消息发送成功，可能会重复推送(直到收到成功ACK)，会产生重复消息。但是一个成熟的MQ Server框架一般会想办法解决，避免存储重复消息(比如：空间换时间，存储已处理过的message_id)，给生产端提供一个幂等性的发送消息接口。</p><p>但是消费端却无法根本解决这个问题，在高并发标准要求下，拉取消息+业务处理+提交消费位移需要做事务处理，另外消费端服务可能宕机，很可能会拉取到重复消息。</p><p>所以，只能业务端自己做控制，<strong>对于已经消费成功的消息，本地数据库表或Redis缓存业务标识，每次处理前先进行校验，保证幂等。</strong></p><h2 id="5-消息丢失怎么解决的？"><a href="#5-消息丢失怎么解决的？" class="headerlink" title="5.消息丢失怎么解决的？"></a>5.消息丢失怎么解决的？</h2><p>使用一个消息队列，其实就分为三大块：<strong>生产者、中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719381898719-af6c00bf-8760-4639-bd21-e6d422ef7779.webp" alt="img"></p><ul><li><strong>消息生产阶段</strong>：生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。从消息被生产出来，然后提交给 MQ 的过程中，<strong>只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功</strong>，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</li><li><strong>消息存储阶段</strong>：Kafka 在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</li><li><strong>消息消费阶段</strong>：消费者<strong>接收消息+消息处理</strong>之后，才回复 ack 的话，那么消息阶段的消息不会丢失。不能收到消息就回 ack，否则可能消息处理中途挂掉了，消息就丢失了。</li></ul><h2 id="6-消息队列的可靠性、顺序性怎么保证？"><a href="#6-消息队列的可靠性、顺序性怎么保证？" class="headerlink" title="6.消息队列的可靠性、顺序性怎么保证？"></a>6.消息队列的可靠性、顺序性怎么保证？</h2><p>消息<strong>可靠性</strong>可以通过下面这些方式来保证</p><ul><li><strong>消息持久化</strong>：确保<strong>消息队列能够持久化消息</strong>是非常关键的。在系统崩溃、重启或者网络故障等情况下，未处理的消息不应丢失。例如，像 RabbitMQ 可以通过配置将<strong>消息持久化到磁盘，通过将队列和消息都设置为持久化的方式</strong>（设置<code>durable = true</code>），这样在服务器重启后，消息依然可以被重新读取和处理。</li><li><strong>消息确认机制</strong>：消费者在成功处理消息后，应该向消息队列发送确认（acknowledgment）。<strong>消息队列只有收到确认后，才会将消息从队列中移除</strong>。如果没有收到确认，消息队列可能会在一定时间后重新发送消息给其他消费者或者再次发送给同一个消费者。以 Kafka 为例，消费者通过<code>commitSync</code>或者<code>commitAsync</code>方法来提交偏移量（offset），从而确认消息的消费。</li><li><strong>消息重试策略</strong>：当消费者处理消息失败时，需要有<strong>合理的重试策略</strong>。可以设置重试次数和重试间隔时间。例如，在第一次处理失败后，等待一段时间（如 5 秒）后进行第二次重试，如果重试多次（如 3 次）后仍然失败，可以将消息发送到死信队列，以便后续人工排查或者采取其他特殊处理。</li></ul><p>消息顺序性保证的方式如下：</p><ul><li><strong>有序消息处理场景识别</strong>：首先需要明确业务场景中哪些消息是<strong>需要保证顺序的</strong>。例如，在金融交易系统中，对于同用户的转账操作顺序是不能打乱的。对于需要顺序处理的消息，要确保消息队列和消费者能够按照特定的顺序进行处理。</li><li><strong>消息队列对顺序性的支持</strong>：部分消息队列本身提供了顺序性保证的功能。比如 Kafka 可以通过将消息划分到<strong>同一个分区</strong>（Partition）来保证消息在分区内是有序的，<strong>消费者按照分区顺序读取消息就可以保证消息顺序</strong>。但这也可能会限制消息的并行处理程度，需要在顺序性和吞吐量之间进行权衡。</li><li><strong>消费者顺序处理策略</strong>：消费者在处理顺序消息时，<strong>应该避免并发处理可能导致顺序打乱的情况</strong>。例如，可以通过<strong>单线程或者使用线程池并对顺序消息进行串行化处理</strong>等方式，确保消息按照正确的顺序被消费。</li></ul><h2 id="7-如何保证幂等写？"><a href="#7-如何保证幂等写？" class="headerlink" title="7.如何保证幂等写？"></a>7.如何保证幂等写？</h2><p>幂等性是指 <strong>同一操作的多次执行对系统状态的影响与一次执行结果一致</strong>。例如，支付接口若因网络重试被多次调用，最终应确保仅扣款一次。实现幂等写的核心方案：</p><ul><li>唯一标识（幂等键）：客户端为每个请求生成全局唯一ID（如 UUID、业务主键），服务端校验该ID是否已处理，适用场景接口调用、消息消费等。</li><li>数据库事务 + 乐观锁：通过版本号或状态字段控制并发更新，确保多次更新等同于单次操作，适用场景数据库记录更新（如余额扣减、订单状态变更）。</li><li>数据库唯一约束：利用数据库唯一索引防止重复数据写入，适用场景数据插入场景（如订单创建）。</li><li>分布式锁：通过锁机制保证同一时刻仅有一个请求执行关键操作，适用场景高并发下的资源抢夺（如秒杀）。</li><li>消息去重：消息队列生产者为每条消息生成唯一的消息 ID，消费者在处理消息前，先检查该消息 ID 是否已经处理过，如果已经处理过则丢弃该消息。</li></ul><h2 id="8-如何处理消息队列的消息积压问题？"><a href="#8-如何处理消息队列的消息积压问题？" class="headerlink" title="8.如何处理消息队列的消息积压问题？"></a>8.如何处理消息队列的消息积压问题？</h2><p>消息积压是因为生产者的生产速度，大于消费者的消费速度。遇到消息积压问题时，我们需要先排查，是不是有bug产生了。</p><p>如果不是bug，我们可以<strong>优化一下消费的逻辑</strong>，比如之前是一条一条消息消费处理的话，我们可以确认是不是可以优为<strong>批量处理消息</strong>。如果还是慢，我们可以考虑水平扩容，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。</p><p>如果是bug导致几百万消息持续积压几小时。有如何处理呢？需要解决bug，<strong>临时紧急扩容</strong>，大概思路如下：</p><blockquote><ol><li>先修复consumer消费者的问题，以确保其恢复消费速度，然后将现有consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先10倍的queue 数量。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ol></blockquote><h2 id="9-如何保证数据一致性，事务消息如何实现？"><a href="#9-如何保证数据一致性，事务消息如何实现？" class="headerlink" title="9.如何保证数据一致性，事务消息如何实现？"></a>9.如何保证数据一致性，事务消息如何实现？</h2><p>一条普通的MQ消息，从产生到被消费，大概流程如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20250407142107477.png" alt="image-20250407142107477"></p><ol><li>生产者产生消息，发送带MQ服务器</li><li>MQ收到消息后，将消息持久化到存储系统。</li><li>MQ服务器返回ACk到生产者。</li><li>MQ服务器把消息push给消费者</li><li>消费者消费完消息，响应ACK</li><li>MQ服务器收到ACK，认为消息消费成功，即在存储中删除消息。</li></ol><p>我们举个<strong>下订单</strong>的例子吧。订单系统创建完订单后，再发送消息给下游系统。如果订单创建成功，然后消息没有成功发送出去，下游系统就无法感知这个事情，出导致数据不一致。</p><p>如何保证数据一致性呢？可以使用<strong>事务消息</strong>。一起来看下事务消息是如何实现的吧。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20250407142122992.png" alt="image-20250407142122992"></p><ol><li>生产者产生消息，发送一条<strong>半事务消息</strong>到MQ服务器</li><li>MQ收到消息后，将消息持久化到存储系统，这条消息的状态是<strong>待发送</strong>状态。</li><li>MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件</li><li>生产者执行本地事务</li><li>如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。</li><li>如果是正常的commit，MQ服务器更新消息状态为<strong>可发送</strong>；如果是rollback，即删除消息。</li><li>如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。</li><li>如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。</li></ol><h2 id="10-消息队列是参考哪种设计模式？"><a href="#10-消息队列是参考哪种设计模式？" class="headerlink" title="10.消息队列是参考哪种设计模式？"></a>10.消息队列是参考哪种设计模式？</h2><p>是参考了观察者模式和发布订阅模式，两种设计模式思路是一样的，举个生活例子：</p><ul><li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li><li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li></ul><p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p><blockquote><p>观察者模式</p></blockquote><p>观察者模式实际上就是<strong>一个一对多的关系</strong>，在观察者模式中存在一个主题和多个观察者，主题也是被观察者，当我们主题发布消息时，会通知各个观察者，观察者将会收到最新消息，图解如下：<strong>每个观察者首先订阅主题，订阅成功后当主题发送消息时会循环整个观察者列表，逐一发送消息通知。</strong> <img src="https://cdn.xiaolincoding.com//picgo/1723798409094-5099fa2a-c72c-4c67-bab7-09bbca9e0834.webp" alt="img"></p><blockquote><p>发布订阅模式</p></blockquote><p>发布订阅模式和观察者模式的区别就是发布者和订阅者完全解耦，通过<strong>中间的发布订阅中心</strong>进行消息通知，发布者并不知道自己发布的消息会通知给谁，因此发布订阅模式有三个重要角色，发布者-&gt;发布订阅中心-&gt;订阅者。</p><p>图解如下：当发布者发布消息到发布订阅中心后，发布订阅中心会将消息通知给所有订阅该发布者的订阅者 <img src="https://cdn.xiaolincoding.com//picgo/1723798423949-97ae81c8-3536-40c6-bcc6-1509a3056a04.webp" alt="img"></p><h2 id="11-让你写一个消息队列，该如何进行架构设计？"><a href="#11-让你写一个消息队列，该如何进行架构设计？" class="headerlink" title="11.让你写一个消息队列，该如何进行架构设计？"></a>11.让你写一个消息队列，该如何进行架构设计？</h2><ol><li>首先是消息队列的整体流程，producer发送消息给broker，broker存储好，broker再发送给consumer消费，consumer回复消费确认等。</li><li>producer发送消息给broker，broker发消息给consumer消费，那就需要两次RPC了，RPC如何设计呢？可以参考开源框架Dubbo，你可以说说服务发现、序列化协议等等</li><li>broker考虑如何持久化呢，是放文件系统还是数据库呢，会不会消息堆积呢，消息堆积如何处理呢。</li><li>消费关系如何保存呢？点对点还是广播方式呢？广播关系又是如何维护呢？zk还是config server</li><li>消息可靠性如何保证呢？如果消息重复了，如何幂等处理呢？</li><li>消息队列的高可用如何设计呢？可以参考Kafka的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li><li>消息事务特性，与本地业务同个事务，本地消息落库;消息投递到服务端，本地才删除；定时任务扫描本地消息库，补偿发送。</li><li>MQ得伸缩性和可扩展性，如果消息积压或者资源不够时，如何支持快速扩容，提高吞吐？可以参照一下 Kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了。</li></ol><h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="1-消息队列为什么选择RocketMQ的？"><a href="#1-消息队列为什么选择RocketMQ的？" class="headerlink" title="1.消息队列为什么选择RocketMQ的？"></a>1.消息队列为什么选择RocketMQ的？</h2><p>项目用的是 RocketMQ 消息队列。选择RocketMQ的原因是：</p><ul><li><strong>开发语言优势</strong>。RocketMQ 使用 Java 语言开发，比起使用 Erlang 开发的 RabbitMQ 来说，有着更容易上手的阅读体验和受众。在遇到 RocketMQ 较为底层的问题时，大部分熟悉 Java 的同学都可以深入阅读其源码，分析、排查问题。</li><li><strong>社区氛围活跃</strong>。RocketMQ 是阿里巴巴开源且内部在大量使用的消息队列，说明 RocketMQ 是的确经得起残酷的生产环境考验的，并且能够针对线上环境复杂的需求场景提供相应的解决方案。</li><li><strong>特性丰富</strong>。根据 RocketMQ 官方文档的列举，其高级特性达到了 <code>12 种</code>，例如顺序消息、事务消息、消息过滤、定时消息等。顺序消息、事务消息、消息过滤、定时消息。RocketMQ 丰富的特性，能够为我们在复杂的业务场景下尽可能多地提供思路及解决方案。</li></ul><h2 id="2-RocketMQ和Kafka的区别是什么？如何做技术选型？"><a href="#2-RocketMQ和Kafka的区别是什么？如何做技术选型？" class="headerlink" title="2.RocketMQ和Kafka的区别是什么？如何做技术选型？"></a>2.RocketMQ和Kafka的区别是什么？如何做技术选型？</h2><p>Kafka的优缺点：</p><ul><li>优点：首先，Kafka的最大优势就在于它的高吞吐量，在普通机器4CPU8G的配置下，一台机器可以抗住十几万的QPS，这一点还是相当优越的。Kafka支持集群部署，如果部分机器宕机不可用，则不影响Kafka的正常使用。</li><li>缺点：Kafka有可能会造成数据丢失，因为它在收到消息的时候，并不是直接写到物理磁盘的，而是先写入到磁盘缓冲区里面的。Kafka功能比较的单一 主要的就是支持收发消息，高级功能基本没有，就会造成适用场景受限。</li></ul><p>RocketMQ是阿里巴巴开源的消息中间件，优缺点</p><ul><li>优点：支持功能比较多，比如延迟队列、消息事务等等，吞吐量也高，单机吞吐量达到 10 万级，支持大规模集群部署，线性扩展方便，Java语言开发，满足了国内绝大部分公司技术栈</li><li>缺点：性能相比 kafka 是弱一点，因为 kafka 用到了 sendfile 的零拷贝技术，而 RocketMQ 主要是用 mmap+write 来实现零拷贝。</li></ul><p>该怎么选择呢？</p><ul><li>如果我们业务只是收发消息这种单一类型的需求，而且可以允许小部分数据丢失的可能性，但是又要求极高的吞吐量和高性能的话，就直接选Kafka就行了，就好比我们公司想要收集和传输用户行为日志以及其他相关日志的处理，就选用的Kafka中间件。</li><li>如果公司的需要通过 mq 来实现一些业务需求，比如延迟队列、消息事务等，公司技术栈主要是Java语言的话，就直接一步到位选择RocketMQ，这样会省很多事情。</li></ul><h2 id="3-RocketMQ延时消息的底层原理"><a href="#3-RocketMQ延时消息的底层原理" class="headerlink" title="3.RocketMQ延时消息的底层原理"></a>3.RocketMQ延时消息的底层原理</h2><p>总体的原理示意图，如下所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720428795952-bba954e9-c9b6-45c5-aa05-8cc1d49c0e3c.png" alt="img"></p><p>broker 在接收到延时消息的时候，会将延时消息存入到<strong>延时Topic</strong>的队列中，然后ScheduleMessageService中，每个 queue 对应的定时任务会不停地被执行，检查 queue 中哪些消息已到设定时间，然后转发到消息的原始Topic，这些消息就会被各自的 producer 消费了。</p><p>也可以使用这个思路用redis的stream流来实现延时消息</p><h2 id="4-RocektMQ怎么处理分布式事务？"><a href="#4-RocektMQ怎么处理分布式事务？" class="headerlink" title="4.RocektMQ怎么处理分布式事务？"></a>4.RocektMQ怎么处理分布式事务？</h2><p><strong>RocketMQ是一种最终一致性的分布式事务</strong>，就是说它保证的是消息最终一致性，而不是像2PC、3PC、TCC那样强一致分布式事务</p><p>假设 <strong>A</strong> 给 <strong>B</strong> 转 <strong>100块钱</strong>，同时它们不是同一个服务上，现在目标是就是 <strong>A</strong> 减100块钱，<strong>B</strong> 加100块钱。</p><p>实际情况可能有四种：</p><ul><li>1）就是A账户减100 （成功），B账户加100 （成功）</li><li>2）就是A账户减100（失败），B账户加100 （失败）</li><li>3）就是A账户减100（成功），B账户加100 （失败）</li><li>4）就是A账户减100 （失败），B账户加100 （成功）</li></ul><p>这里 <strong>第1和第2</strong> 种情况是能够保证事务的一致性的，但是 <strong>第3和第4</strong> 是无法保证事务的一致性的。</p><p>那我们来看下RocketMQ是如何来保证事务的一致性的。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1714663418978-cb16a341-5eef-4f2a-ac2f-2331f5249c31.png" alt="img"></p><p>分布式事务的流程如上图：</p><ul><li>1、A服务先发送个Half Message（是指暂不能被Consumer消费的消息。Producer 已经把消息成功发送到了Broker 端，但此消息被标记为暂不能投递状态，处于该种状态下的消息称为半消息。需要 Producer对消息的二次确认后，Consumer才能去消费它）给Brock端，消息中携带 B服务 即将要+100元的信息。</li><li>2、当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。</li><li>3、执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应)</li><li>4.1)、如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。</li><li>4.2)、如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。</li><li>4.3)、如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口，来进行事务的回查。</li></ul><p>从上面流程可以得知 只有A服务本地事务执行成功 ，B服务才能消费该message。</p><p><strong>那么</strong> <strong>A账户减100 （成功），B账户加100 （失败），这时候B服务失败怎么办？</strong></p><p>如果B最终执行失败，几乎可以断定就是代码有问题所以才引起的异常，因为消费端RocketMQ有重试机制，如果不是代码问题一般重试几次就能成功。</p><p>如果是代码的原因引起多次重试失败后，也没有关系，将该异常记录下来，由人工处理，人工兜底处理后，就可以让事务达到最终的一致性。</p><h2 id="5-RocketMQ消息顺序怎么保证？"><a href="#5-RocketMQ消息顺序怎么保证？" class="headerlink" title="5.RocketMQ消息顺序怎么保证？"></a>5.RocketMQ消息顺序怎么保证？</h2><p>消息的有序性是指<strong>消息的消费顺序能够严格保存与消息的发送顺序一致</strong>。例如，一个订单产生了3条消息，分别是订单创建、订单付款和订单完成。在消息消费时，同一条订单要严格按照这个顺序进行消费，否则业务会发生混乱。同时，不同订单之间的消息又是可以并发消费的，比如可以先执行第三个订单的付款，再执行第二个订单的创建。</p><p>RocketMQ采用了<strong>局部顺序一致性的机制</strong>，<strong>实现了单个队列中的消息严格有序</strong>。也就是说，如果想要保证顺序消费，必须将一组消息发送到同一个队列中，然后再由消费者进行注意消费。</p><p>RocketMQ推荐的顺序消费解决方案是：安装业务划分不同的队列，然后将需要顺序消费的消息发往同一队列中即可，不同业务之间的消息仍采用并发消费。这种方式在满足顺序消费的同时提高了消息的处理速度，在一定程度上避免了消息堆积问题</p><p>RocketMQ 顺序消息的原理是：</p><ul><li>在 Producer（生产者） 把一批需要保证顺序的消息发送到同一个 MessageQueue</li><li>Consumer（消费者） 则<strong>通过加锁的机制来保证消息消费的顺序性</strong>，Broker 端通过对 MessageQueue 进行加锁，保证同一个 MessageQueue 只能被同一个 Consumer 进行消费。</li></ul><h2 id="6-RocketMQ怎么保证消息不被重复消费"><a href="#6-RocketMQ怎么保证消息不被重复消费" class="headerlink" title="6.RocketMQ怎么保证消息不被重复消费"></a>6.RocketMQ怎么保证消息不被重复消费</h2><p>在业务逻辑中实现<strong>幂等性</strong>，确保即使消息被重复消费，也不会影响业务状态。例如，对于支付或转账类操作，可以<strong>使用唯一订单号或事务ID作为幂等性的标识符</strong>，确保同样的操作只会被执行一次。</p><p>消息投递时，<strong>网络中断</strong>或<strong>消费失败重试</strong>可能会导致 <strong>重复消费</strong></p><p>消息投递给消费者后，<strong>消费者处理异常</strong> 或返回失败，会被 RocketMQ <strong>重新投递</strong></p><ul><li>数据库表加“唯一约束 + 去重表”【最常用】</li><li>使用 Redis 实现幂等控制</li><li>利用 RocketMQ 提供的 <code>msg.getKeys()</code> 做幂等键</li></ul><h2 id="7-RocketMQ消息积压了，怎么办？"><a href="#7-RocketMQ消息积压了，怎么办？" class="headerlink" title="7.RocketMQ消息积压了，怎么办？"></a>7.RocketMQ消息积压了，怎么办？</h2><p>导致消息积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了。</p><p>要解决积压的问题，可以通过<strong>扩容消费端的实例数来提升总体的消费能力</strong>。</p><p>如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将<strong>系统降级</strong>，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。</p><h2 id="8-什么是零拷贝"><a href="#8-什么是零拷贝" class="headerlink" title="8.什么是零拷贝"></a>8.什么是零拷贝</h2><p>传统的数据传输流程中，用户数据通常会经过如下多次拷贝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘 → 内核缓冲区 → 用户态 → Socket 缓冲区 → 网卡</span><br></pre></td></tr></table></figure><p>而“零拷贝”技术通过内核优化和 API 支持，能<strong>避免数据在用户态与内核态间的多次拷贝</strong>，从而提升性能。常用技术：</p><div class="table-container"><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td><code>mmap</code></td><td>将文件映射到内存地址空间，避免文件拷贝</td></tr><tr><td><code>sendfile</code></td><td>直接将文件从磁盘发送到 Socket，避免数据进入用户态</td></tr><tr><td><code>writev</code></td><td>批量写入多个内存区域，减少系统调用</td></tr><tr><td><code>DirectByteBuffer</code>（Java NIO）</td><td>Java 堆外内存，提高 I/O 性能</td></tr></tbody></table></div><p>RocketMQ使用零拷贝的场景：<br>RocketMQ 使用 <strong>顺序写入磁盘</strong> + <strong><code>MappedByteBuffer</code>（mmap）机制</strong></p><ul><li>CommitLog 文件通过 <code>mmap</code> 映射为<strong>内存地址空间</strong>，写消息时直接写入这段地址</li><li>消息写完之后由 <strong>刷盘线程 flush</strong> 到磁盘（异步或同步）</li></ul><p>➡️ 优点：避免了传统写文件的 <strong>内核缓冲区 → 用户缓冲区 → 文件系统缓存</strong> 的多次复制。</p><p>消息消费（拉取时）</p><p>RocketMQ 使用 <strong>零拷贝 + SendFile 技术</strong> 实现高效消息下发：</p><ul><li>消费者从 Broker 拉取消息时，Broker 会读取 CommitLog 中的内容</li><li>若消息在 OS PageCache 中，可直接使用 <code>FileChannel.transferTo</code>（即 sendfile）将消息直接写入 socket 输出流</li></ul><p>➡️ 相比传统读入用户空间再写出，<code>sendfile</code> 直接 <strong>在内核中完成数据搬运</strong>，性能极高。</p><p>ConsumeQueue 与 IndexFile</p><p>RocketMQ 的 ConsumeQueue（消费队列）和 IndexFile（索引文件）同样是基于 <strong>mmap 方式读写</strong>，提升顺序读性能，避免 GC 干扰。</p><ul><li>ConsumeQueue 中记录了消息的偏移量、大小和 tag hash</li><li>查询或消费时不需要实际读取 CommitLog 内容，而是通过偏移快速定位</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th>优势</th></tr></thead><tbody><tr><td>mmap</td><td>减少内存复制、提高 I/O 吞吐</td></tr><tr><td>sendfile</td><td>内核空间直接完成数据搬运</td></tr><tr><td>writev（部分使用）</td><td>多个 buffer 一次写出</td></tr><tr><td>堆外内存使用（DirectByteBuffer）</td><td>降低 GC 压力，提升 I/O 性能</td></tr></tbody></table></div>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/rocketmq/">rocketmq</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/24/new-stack/MQ1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://blog.tokenlen.top/2025/06/24/new-stack/nginx/</link>
      <guid>https://blog.tokenlen.top/2025/06/24/new-stack/nginx/</guid>
      <pubDate>Mon, 23 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的<strong>反向代理</strong>和<strong>负载均衡</strong>。</p><p><img src="https://pic1.zhimg.com/v2-e1826bab1d07df8e97d61aa809b94a10_1440w.jpg" alt=""></p><p>上图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。</p><p>正向代理：</p><p><img src="https://picx.zhimg.com/v2-c8ac111c267ae0745f984e326ef0c47f_1440w.jpg" alt=""></p><p>反向代理：</p><p><img src="https://pic2.zhimg.com/v2-4787a512240b238ebf928cd0651e1d99_1440w.jpg" alt=""></p><p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，<strong>正向代理“代理”的是客户</strong>端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</p><p>当我们在外网访问百度的时候，其实会进行一个转发，<strong>代理到内网去，这就是所谓的反向代理</strong>，<strong>即反向代理“代理”的是服务器端</strong>，而且这一个过程对于客户端而言是透明的。</p><ol><li>保障应用服务器的安全（增加一层代理，可以屏蔽危险攻击，更方便的控制权限）</li><li>实现负载均衡（稍等~下面会讲）</li><li>实现跨域（号称是最简单的跨域方式）</li></ol><h2 id="Nginx的Master-Worker模式"><a href="#Nginx的Master-Worker模式" class="headerlink" title="Nginx的Master-Worker模式"></a>Nginx的Master-Worker模式</h2><p>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p><p>Master进程的作用是？</p><p><strong>读取并验证配置文件nginx.conf；管理worker进程；</strong></p><p>Worker进程的作用是？</p><p><strong>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</strong></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>启动 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx` 或 `sudo brew services start nginx</span><br></pre></td></tr></table></figure><p>停止 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s stop` 或 `sudo brew services stop nginx</span><br></pre></td></tr></table></figure><p>热重启 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>强制停止 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -9 nginx</span><br></pre></td></tr></table></figure><p><code>/usr/local/etc/nginx/nginx.conf</code> （nginx配置文件路径）</p><p><code>/usr/local/var/www</code> （nginx服务器默认的根目录）</p><p><code>/usr/local/Cellar/nginx/1.17.9</code> （nginx的安装路径）</p><p><code>/usr/local/var/log/nginx/error.log</code> (nginx默认的日志路径)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 首尾配置暂时忽略</span><br><span class="line">server &#123;  </span><br><span class="line">        # 当nginx接到请求后，会匹配其配置中的service模块</span><br><span class="line">        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配</span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # Nginx默认值</span><br><span class="line">            # 设定Nginx服务器返回的文档名</span><br><span class="line">            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 首尾配置暂时忽略</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server{ } 其实是包含在 http{ } 内部的。每一个 server{ } 是一个虚拟主机（站点）。</p><p>上面代码块的意思是：当一个请求叫做<code>localhost:8080</code>请求nginx服务器时，该请求就会被匹配进该代码块的 server{ } 中执行。</p><p>当然 nginx 的配置非常多，用的时候可以根据文档进行配置。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>动静分离：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/17/171867d175eae45f~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>Nginx 服务器将接收到的请求分为<strong>动态请求</strong>和<strong>静态请求</strong>。</p><p>静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。</p><p>这样做不仅能给应用服务器减轻压力，将后台api接口服务化，还能将前后端代码分开并行开发和部署。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8080</span>;        </span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html; <span class="comment"># Nginx默认值</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$</span> &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/local/var/www/my-project; <span class="comment"># 静态请求所代理到的根目录</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 动态请求匹配到path为&#x27;node&#x27;的就转发到8002端口处理</span></span><br><span class="line">        <span class="section">location</span> /node/ &#123;  </span><br><span class="line">            <span class="attribute">proxy_pass</span> http://localhost:8002; <span class="comment"># 充当服务代理</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # Nginx默认值</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        proxy_pass http://localhost:8000; # 反向代理配置，请求会被转发到8000端口</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反向代理的表现很简单。那上面的代码块来说，其实就是向nginx请求<code>localhost:8080</code>跟请求 <code>http://localhost:8000</code> 是一样的效果。（跟代购的原理一样）</p><p>这是一个反向代理最简单的模型，只是为了说明反向代理的配置。但是现实中反向代理多数是用在负载均衡中。</p><p>nginx 就是充当图中的 proxy。左边的3个 client 在请求时向 nginx 获取内容，是感受不到3台 server 存在的。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/16/17183720f7a66978~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>反向代理应用十分广泛，CDN 服务就是反向代理经典的应用场景之一。除此之外，反向代理也是实现负载均衡的基础，很多大公司的架构都应用到了反向代理。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器 集群。</p><p>在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做<strong>负载均衡</strong>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/17/171862efada16376~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>Nginx还带有<strong>健康检查</strong>（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。</p><p>一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 负载均衡：设置domain</span><br><span class="line">upstream domain &#123;</span><br><span class="line">    server localhost:8000;</span><br><span class="line">    server localhost:8001;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;  </span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # root   html; # Nginx默认值</span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line">            </span><br><span class="line">            proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口</span><br><span class="line">            proxy_set_header Host $host:$server_port;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8000和8001是我本地用 Node.js 起的两个服务，负载均衡成功后可以看到访问 <code>localhost:8080</code> 有时会访问到8000端口的页面，有时会访问到8001端口的页面。</p><p>受集群单台服务器内存等资源的限制，负载均衡集群的服务器也不能无限增多。但因其良好的容错机制，负载均衡成为了实现<strong>高可用架构</strong>中必不可少的一环。</p><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。刚开始的时候，代理多数是帮助内网client访问外网server用的（比如HTTP代理），从内到外 . 后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网client的请求forward到内网server，从外到内</p><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="1-Nginx-实现负载均衡有哪几种方式？"><a href="#1-Nginx-实现负载均衡有哪几种方式？" class="headerlink" title="1.Nginx 实现负载均衡有哪几种方式？"></a>1.Nginx 实现负载均衡有哪几种方式？</h2><p><strong>轮询（Round Robin）</strong>：默认策略，顺序转发请求；</p><p><strong>加权轮询（Weighted Round Robin）</strong>：给服务器设置权重，权重大就多分配请求；</p><p><strong>IP Hash</strong>：根据客户端 IP 做哈希，把同一个 IP 的请求固定分配给同一台服务器；</p><p><strong>最少连接数（Least Connections）</strong>：优先转发给当前连接数最少的服务器（需要开启 <code>least_conn</code> 模块）；</p><p><strong>健康检查</strong>（可选）：检查服务器是否存活，不可用的服务器不会被请求到。</p><h2 id="2-你项目中用的是什么负载均衡策略？为什么选这个？"><a href="#2-你项目中用的是什么负载均衡策略？为什么选这个？" class="headerlink" title="2.你项目中用的是什么负载均衡策略？为什么选这个？"></a>2.你项目中用的是什么负载均衡策略？为什么选这个？</h2><p>我使用的是默认的轮询（round-robin）策略，因为我们集群内的服务节点配置基本一致，响应时间也相差不大，这样的简单策略就足够满足负载均衡需求。如果后期出现性能差异，再考虑使用加权轮询或 IP Hash 策略来优化。</p><h2 id="3-负载均衡后-session-如何保持？（Sticky-Session）"><a href="#3-负载均衡后-session-如何保持？（Sticky-Session）" class="headerlink" title="3.负载均衡后 session 如何保持？（Sticky Session）"></a>3.负载均衡后 session 如何保持？（Sticky Session）</h2><p>默认情况下，用户的请求会轮流打到不同的服务器，这样可能会导致 session 丢失。解决方案有：</p><ul><li><strong>使用 IP Hash 策略</strong>：让同一 IP 的请求打到同一台服务器；</li><li><strong>使用 cookie 记录和识别客户端，前端转发到固定节点</strong>；</li><li><strong>服务端使用 session 共享机制</strong>，如 Redis 分布式 session；</li><li><strong>客户端使用 token（如 JWT），实现无状态认证</strong>；</li></ul><h2 id="4-Nginx-如何判断服务器挂了？"><a href="#4-Nginx-如何判断服务器挂了？" class="headerlink" title="4.Nginx 如何判断服务器挂了？"></a>4.Nginx 如何判断服务器挂了？</h2><p>Nginx 的 <strong>openresty</strong> 或第三方模块（如 <code>nginx_upstream_check_module</code>）可以启用<strong>主动健康检查机制</strong>，通过定期向后端发送请求，判断其状态。</p><p>如果是默认配置，Nginx 并<strong>不会主动健康检查</strong>，只有当某个请求失败时，才会暂时标记服务器为不可用（被动方式）。</p><h2 id="5-upstream-模块中配置多个服务，如果其中一个挂了怎么办？"><a href="#5-upstream-模块中配置多个服务，如果其中一个挂了怎么办？" class="headerlink" title="5.upstream 模块中配置多个服务，如果其中一个挂了怎么办？"></a>5.upstream 模块中配置多个服务，如果其中一个挂了怎么办？</h2><p>如果使用了<strong>健康检查模块</strong>，Nginx 会主动检测并自动将该节点剔除；如果没开启，用户请求到挂掉的服务会失败一部分。</p><p>可以手动配置 <code>max_fails</code> 和 <code>fail_timeout</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server localhost:8000 max_fails=3 fail_timeout=30s;</span><br><span class="line">    server localhost:8001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示在 30 秒内失败超过 3 次就会暂时踢掉该节点。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Nginx/">Nginx</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/24/new-stack/nginx/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://blog.tokenlen.top/2025/06/22/new-stack/docker/</link>
      <guid>https://blog.tokenlen.top/2025/06/22/new-stack/docker/</guid>
      <pubDate>Sat, 21 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;困难现状&quot;&gt;&lt;a href=&quot;#困难现状&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="困难现状"><a href="#困难现状" class="headerlink" title="困难现状"></a>困难现状</h1><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><hr><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>但是会有以下的问题：</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><hr><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，<strong>一个 image 文件往往通过继承另一个 image 文件</strong>，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 列出本机的所有 image 文件。</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"># 删除 image 文件</span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure></blockquote><p><code>ocker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 列出本机正在运行的容器</span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括终止运行的容器</span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"># 或者</span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure></blockquote><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，<strong>因此需要定义容器与物理机的端口映射（map）。</strong></p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container <span class="built_in">ls</span> --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container <span class="built_in">rm</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --<span class="built_in">rm</span> -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>cmd:</p><p>容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --<span class="built_in">rm</span> -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong>docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p>stop更像是一个建议，而kill是强制性的</p><p><strong>docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p><strong>docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">cp</span> [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></blockquote><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="自建服务-1"><a href="#自建服务-1" class="headerlink" title="自建服务-1"></a>自建服务-1</h2><p>首先，新建一个工作目录，并进入该目录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> docker-demo &amp;&amp; <span class="built_in">cd</span> docker-demo</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">  --rm \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --volume &quot;$PWD/&quot;:/var/www/html \</span><br><span class="line">  php:5.6-apache</span><br></pre></td></tr></table></figure><p>上面的命令基于<code>php</code>的 image 文件新建一个容器，并且运行该容器。<code>php</code>的标签是<code>5.6-apache</code>，说明装的是 PHP 5.6，并且自带 Apache 服务器。该命令的三个参数含义如下。</p><ul><li><code>--rm</code>：停止运行后，自动删除容器文件。</li><li><code>--name wordpress</code>：容器的名字叫做<code>wordpress</code>。</li><li><code>--volume &quot;$PWD/&quot;:/var/www/html</code>：将当前目录（<code>$PWD</code>）映射到容器的<code>/var/www/html</code>（Apache 对外访问的默认目录）。因此，<strong>当前目录的任何修改，都会反映到容器里面，进而被外部访问到。</strong></li></ul><p>安装mysql:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  --rm \</span><br><span class="line">  --name wordpressdb \</span><br><span class="line">  --env MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  --env MYSQL_DATABASE=wordpress \</span><br><span class="line">  mysql:5.7</span><br></pre></td></tr></table></figure><ul><li><code>-d</code>：容器启动后，在后台运行。</li><li><code>--rm</code>：容器终止运行后，自动删除容器文件。</li><li><code>--name wordpressdb</code>：容器的名字叫做<code>wordpressdb</code></li><li><code>--env MYSQL_ROOT_PASSWORD=123456</code>：向容器进程传入一个环境变量<code>MYSQL_ROOT_PASSWORD</code>，该变量会被用作 MySQL 的根密码。</li><li><code>--env MYSQL_DATABASE=wordpress</code>：向容器进程传入一个环境变量<code>MYSQL_DATABASE</code>，容器里面的 MySQL 会根据该变量创建一个同名数据库（本例是<code>WordPress</code>）。</li></ul><p>这样把mysql和php连接起来：</p><p>在<code>docker-demo</code>目录里面，新建一个<code>Dockerfile</code>文件，写入下面的内容。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM php:5.6-apache</span><br><span class="line">RUN docker-php-ext-install mysqli</span><br><span class="line">CMD apache2-foreground</span><br></pre></td></tr></table></figure></blockquote><p>上面代码的意思，就是在原来 PHP 的 image 基础上，安装<code>mysqli</code>的扩展。然后，启动 Apache。</p><p>基于这个 Dockerfile 文件，新建一个名为<code>phpwithmysql</code>的 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t phpwithmysql .</span><br></pre></td></tr></table></figure></blockquote><p>现在基于 phpwithmysql image，重新新建一个 WordPress 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --volume <span class="string">&quot;<span class="variable">$PWD</span>/&quot;</span>:/var/www/html \</span><br><span class="line">  --<span class="built_in">link</span> wordpressdb:mysql \</span><br><span class="line">  phpwithmysql</span><br></pre></td></tr></table></figure></blockquote><p>跟上一次相比，上面的命令多了一个参数<code>--link wordpressdb:mysql</code>，表示 WordPress 容器要连到<code>wordpressdb</code>容器，冒号表示该容器的别名是<code>mysql</code>。</p><p>这时还要改一下<code>wordpress</code>目录的权限，让容器可以将配置信息写入这个目录（容器内部写入的<code>/var/www/html</code>目录，会映射到这个目录）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> -R 777 wordpress</span><br></pre></td></tr></table></figure></blockquote><p>接着，回到浏览器的<code>http://172.17.0.2/wordpress</code>页面，点击”现在就开始！”按钮，开始安装。</p><p>然后在界面里面输入用户名和密码</p><h2 id="自建服务-2"><a href="#自建服务-2" class="headerlink" title="自建服务-2"></a>自建服务-2</h2><p>首先，新建并启动 MySQL 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  --name wordpressdb \</span><br><span class="line">  --<span class="built_in">env</span> MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  --<span class="built_in">env</span> MYSQL_DATABASE=wordpress \</span><br><span class="line">  mysql:5.7</span><br></pre></td></tr></table></figure></blockquote><p>然后，基于官方的 WordPress image，新建并启动 WordPress 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --<span class="built_in">env</span> WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line">  --<span class="built_in">link</span> wordpressdb:mysql \</span><br><span class="line">  wordpress</span><br></pre></td></tr></table></figure></blockquote><p>上面命令中，各个参数的含义前面都解释过了，其中环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码。</p><p>上面命令指定<code>wordpress</code>容器在后台运行，导致前台看不见输出，使用下面的命令查出<code>wordpress</code>容器的 IP 地址。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container inspect wordpress</span><br></pre></td></tr></table></figure></blockquote><p>上面命令运行以后，会输出很多内容，找到<code>IPAddress</code>字段即可。我的机器返回的 IP 地址是<code>172.17.0.3</code>。</p><p>浏览器访问<code>172.17.0.3</code>，就会看到 WordPress 的安装提示。</p><p>官方 WordPress 容器的安装就已经成功了。但是，这种方法有两个很不方便的地方。</p><blockquote><ul><li>每次新建容器，返回的 IP 地址不能保证相同，导致要更换 IP 地址访问 WordPress。</li><li>WordPress 安装在容器里面，本地无法修改文件。</li></ul></blockquote><p>使用下面的命令新建并启动 WordPress 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line"> -d \</span><br><span class="line"> -p 127.0.0.2:8080:80 \</span><br><span class="line"> --<span class="built_in">rm</span> \</span><br><span class="line"> --name wordpress \</span><br><span class="line"> --<span class="built_in">env</span> WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line"> --<span class="built_in">link</span> wordpressdb:mysql \</span><br><span class="line"> --volume <span class="string">&quot;<span class="variable">$PWD</span>/wordpress&quot;</span>:/var/www/html \</span><br><span class="line"> wordpress</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令跟前面相比，命令行参数只多出了两个。</p><blockquote><ul><li><code>-p 127.0.0.2:8080:80</code>：将容器的 80 端口映射到<code>127.0.0.2</code>的<code>8080</code>端口。</li><li><code>--volume &quot;$PWD/wordpress&quot;:/var/www/html</code>：将容器的<code>/var/www/html</code>目录映射到当前目录的<code>wordpress</code>子目录。</li></ul></blockquote><p>浏览器访问<code>127.0.0.2:8080:80</code>就能看到 WordPress 的安装提示了。而且，你在<code>wordpress</code>子目录下的每次修改，都会反映到容器里面。</p><p>最后，终止这两个容器（容器文件会自动删除）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop wordpress wordpressdb</span><br></pre></td></tr></table></figure></blockquote><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>可以管理多个 Docker 容器组成一个应用。你需要定义一个 <a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML</a> 格式的配置文件<code>docker-compose.yml</code>，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动所有服务</span></span><br><span class="line">$ docker-compose up</span><br><span class="line"><span class="comment"># 关闭所有服务</span></span><br><span class="line">$ docker-compose stop</span><br></pre></td></tr></table></figure></blockquote><p>在<code>docker-demo</code>目录下，新建<code>docker-compose.yml</code>文件，写入下面的内容。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">     - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">     - MYSQL_DATABASE=wordpress</span><br><span class="line">web:</span><br><span class="line">    image: wordpress</span><br><span class="line">    links:</span><br><span class="line">     - mysql</span><br><span class="line">    environment:</span><br><span class="line">     - WORDPRESS_DB_PASSWORD=123456</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;127.0.0.3:8080:80&quot;</span></span><br><span class="line">    working_dir: /var/www/html</span><br><span class="line">    volumes:</span><br><span class="line">     - wordpress:/var/www/html</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，两个顶层标签表示有两个容器<code>mysql</code>和<code>web</code>。每个容器的具体设置，前面都已经讲解过了，还是挺容易理解的。</p><p>启动两个容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure></blockquote><p>浏览器访问 <a href="http://127.0.0.3:8080，应该就能看到">http://127.0.0.3:8080，应该就能看到</a> WordPress 的安装界面。</p><p>现在关闭两个容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose stop</span><br></pre></td></tr></table></figure></blockquote><p>关闭以后，这两个容器文件还是存在的，写在里面的数据不会丢失。下次启动的时候，还可以复用。下面的命令可以把这两个容器文件删除（容器必须已经停止运行）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">rm</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="1-Docker-和虚拟机的区别？"><a href="#1-Docker-和虚拟机的区别？" class="headerlink" title="1.Docker 和虚拟机的区别？"></a>1.Docker 和虚拟机的区别？</h2><p>Docker 是<strong>操作系统级别</strong>的轻量虚拟化，虚拟机是硬件级别的虚拟化。Docker 启动快、资源占用小，适合快速交付和微服务架构部署。docker是一个进程级别的，基于linux容器</p><h2 id="2-Docker-的工作原理？"><a href="#2-Docker-的工作原理？" class="headerlink" title="2.Docker 的工作原理？"></a>2.Docker 的工作原理？</h2><p>基于 Linux 的 <strong>Namespace（命名空间）</strong> 实现进程隔离；</p><p>利用 <strong>Cgroups（控制组）</strong> 限制资源；</p><p>使用 <strong>UnionFS（联合文件系统）</strong> 构建分层的镜像结构；</p><p>容器本质上是运行在宿主机内核上的一个普通进程。</p><h2 id="3-镜像的分层结构理解？"><a href="#3-镜像的分层结构理解？" class="headerlink" title="3.镜像的分层结构理解？"></a>3.镜像的分层结构理解？</h2><p>每个 Docker 镜像由多个<strong>只读层（Read-Only Layer）</strong>构成；</p><p>容器运行时会在镜像最上层添加一层可写层；</p><p>修改只会影响写层，原始镜像不变；</p><p>优点是<strong>节省空间、加速构建、共享层数据</strong>。</p><h2 id="4-Dockerfile-常见优化技巧有哪些？"><a href="#4-Dockerfile-常见优化技巧有哪些？" class="headerlink" title="4.Dockerfile 常见优化技巧有哪些？"></a>4.Dockerfile 常见优化技巧有哪些？</h2><p>使用官方的精简基础镜像，如 <code>alpine</code>；</p><p>合并 RUN 命令，减少中间层数量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure><p>使用 <code>.dockerignore</code> 忽略不必要文件；</p><p>尽量减少镜像大小，加快构建和传输。</p><h2 id="5-CMD-和-ENTRYPOINT-的区别？"><a href="#5-CMD-和-ENTRYPOINT-的区别？" class="headerlink" title="5.CMD 和 ENTRYPOINT 的区别？"></a>5.CMD 和 ENTRYPOINT 的区别？</h2><p><code>CMD</code> 提供默认参数，可被 <code>docker run</code> 的命令参数覆盖；</p><p><code>ENTRYPOINT</code> 提供主命令，不会被覆盖，适合制作“工具型镜像”；</p><p>一般组合使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;python&quot;]</span><br><span class="line">CMD [&quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>比如我们有两个文件，一个main 一个master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">FROM python:3.9-slim</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;python&quot;]</span><br><span class="line">CMD [&quot;main.py&quot;]</span><br></pre></td></tr></table></figure><h2 id="6-容器间通信方式？"><a href="#6-容器间通信方式？" class="headerlink" title="6.容器间通信方式？"></a>6.容器间通信方式？</h2><p><strong>同一个 Docker 网络下，容器可以通过服务名互相访问</strong>；比如link</p><p>例如 Docker Compose 会默认创建一个网络，服务名可作为 hostname；</p><p>跨主机通信需使用 Docker Swarm / Kubernetes 等编排工具。</p><h2 id="7-Docker-的数据持久化方案？"><a href="#7-Docker-的数据持久化方案？" class="headerlink" title="7.Docker 的数据持久化方案？"></a>7.Docker 的数据持久化方案？</h2><p><strong>数据卷（Volume）</strong>：推荐，独立于容器生命周期；</p><p><strong>绑定挂载（Bind Mount）</strong>：挂载宿主机路径，开发测试方便；</p><p><strong>tmpfs 挂载</strong>：内存中临时文件系统，适合敏感数据或缓存。</p><h2 id="8-docker-compose-yml-常用字段详解"><a href="#8-docker-compose-yml-常用字段详解" class="headerlink" title="8.docker-compose.yml 常用字段详解"></a>8.docker-compose.yml 常用字段详解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    environment:</span><br><span class="line">      - ENV=prod</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p><code>build</code>: 指定构建上下文；</p><p><code>depends_on</code>: 依赖关系，控制容器启动顺序；</p><p><code>volumes</code>: 数据卷，持久化数据；</p><p><code>environment</code>: 设置环境变量；</p><p><code>networks</code>: 自定义网络支持跨服务通信。</p><h2 id="9-Docker-Registry"><a href="#9-Docker-Registry" class="headerlink" title="9.Docker Registry"></a>9.Docker Registry</h2><p>私有镜像仓库搭建（Docker Registry）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --name registry registry:2</span><br></pre></td></tr></table></figure><ul><li>将镜像推送到私有仓库：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag myapp localhost:5000/myapp</span><br><span class="line">docker push localhost:5000/myapp</span><br></pre></td></tr></table></figure><ul><li>为啥需要私有仓库？答：用于公司内部部署，避免依赖公网 DockerHub，提升安全性和私有化能力。</li><li>如何保证私有仓库安全？答：<strong>启用 TLS、身份认证、访问控制策略</strong>。</li></ul><div class="table-container"><table><thead><tr><th>问题</th><th>建议简答</th></tr></thead><tbody><tr><td>容器和镜像的区别？</td><td>镜像是只读模板，容器是镜像运行的实例，有可写层。</td></tr><tr><td>Docker 为什么快？</td><td>因为它是进程级别的隔离，不启动完整 OS。</td></tr><tr><td>你如何优化 Docker 镜像大小？</td><td>使用小镜像、合并 RUN、清理缓存、使用多阶段构建等。</td></tr><tr><td>多容器协作怎么做？</td><td>用 Docker Compose 或 Kubernetes 进行编排和通信。</td></tr><tr><td>镜像构建失败怎么调试？</td><td>使用分层构建+缓存机制逐步调试，也可以手动进入中间镜像。</td></tr></tbody></table></div>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/docker/">docker</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/22/new-stack/docker/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试题目hot2web开发</title>
      <link>https://blog.tokenlen.top/2025/06/21/javase/javaweb1/</link>
      <guid>https://blog.tokenlen.top/2025/06/21/javase/javaweb1/</guid>
      <pubDate>Fri, 20 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;web基础&quot;&gt;&lt;a href=&quot;#web基础&quot; class=&quot;headerlink&quot; title=&quot;web基础&quot;&gt;&lt;/a&gt;web基础&lt;/h1&gt;&lt;h2 id=&quot;1-JavaWeb是什么（静态资源和动态资源）&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="web基础"><a href="#web基础" class="headerlink" title="web基础"></a>web基础</h1><h2 id="1-JavaWeb是什么（静态资源和动态资源）"><a href="#1-JavaWeb是什么（静态资源和动态资源）" class="headerlink" title="1.JavaWeb是什么（静态资源和动态资源）"></a>1.JavaWeb是什么（静态资源和动态资源）</h2><blockquote><p><strong>JavaWeb 是基于 Java 技术的 Web 开发体系，用于构建浏览器/服务器（B/S）架构的动态网站或服务。</strong></p></blockquote><p>核心组成部分：</p><div class="table-container"><table><thead><tr><th>模块</th><th>说明</th></tr></thead><tbody><tr><td>Servlet</td><td>JavaWeb 的核心，用于处理 HTTP 请求</td></tr><tr><td>JSP / Thymeleaf</td><td>页面展示层，用于动态生成 HTML 内容</td></tr><tr><td>Filter / Listener</td><td>过滤器和监听器，提供请求过滤、生命周期监听等功能</td></tr><tr><td>Web.xml</td><td>部署描述文件，用于配置 Servlet、Filter 等组件（Spring Boot 多用注解配置）</td></tr><tr><td>静态资源</td><td>纯前端文件，如 HTML、JS、CSS、图片等</td></tr><tr><td>动态资源</td><td>由 Servlet / Controller 处理、运行时生成的内容</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>类型</th><th>描述</th><th>是否经过服务端处理</th></tr></thead><tbody><tr><td>静态资源</td><td>浏览器请求后直接返回内容（如 HTML/CSS/JS/图片）</td><td>❌ 不经过 Java 代码处理，直接由服务器返回</td></tr><tr><td>动态资源</td><td>运行时由后端生成（如 .jsp、Servlet、Controller 响应 JSON）</td><td>✅ 由 Java 程序处理后动态生成响应</td></tr></tbody></table></div><p>静态资源：</p><ul><li>URL: <code>http://example.com/static/index.html</code></li><li>返回：静态 HTML 页面</li><li>存储位置：<code>/static/</code>、<code>/public/</code>、<code>/resources/</code>（Spring Boot 默认支持）</li></ul><p>动态资源：</p><ul><li>URL: <code>http://example.com/user/list</code></li><li>后端：调用 Controller → Service → Dao → 数据库 → 生成动态 HTML / JSON</li><li>常见技术：Servlet、JSP、Spring MVC、Thymeleaf、FreeMarker</li></ul><p>流程：：：</p><p>浏览器请求 → Tomcat（Servlet 容器）接收 → 判断资源类型：<br>  ├─ 静态资源：直接读取文件返回<br>  └─ 动态资源：交给 Servlet/DispatcherServlet 执行 → 处理请求 → 返回响应</p><p>总结：：：</p><p>JavaWeb 是基于 Java 的 Web 应用开发技术，主要通过 Servlet 处理 HTTP 请求，支持静态与动态资源的服务。<br> 静态资源如 HTML、CSS、JS 不经后端处理直接响应；<br> 动态资源（如 Servlet、JSP、Controller）通过服务器运行 Java 逻辑动态生成响应内容。<br> 在现代开发中，JavaWeb 往往结合 Spring MVC + 前端页面模板或前后端分离架构使用。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/21/javase/javaweb1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>汇编语言期末复习</title>
      <link>https://blog.tokenlen.top/2025/06/21/lastteam/huibian/</link>
      <guid>https://blog.tokenlen.top/2025/06/21/lastteam/huibian/</guid>
      <pubDate>Fri, 20 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;题目解答&quot;&gt;&lt;a href=&quot;#题目解答&quot; class=&quot;headerlink&quot; title=&quot;题目解答&quot;&gt;&lt;/a&gt;题目解答&lt;/h1&gt;&lt;h2 id=&quot;一-基础知识&quot;&gt;&lt;a href=&quot;#一-基础知识&quot; class=&quot;headerlink&quot; title=&quot;一</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h1><h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一 基础知识"></a>一 基础知识</h2><p>1.若CPU的寻址能力是 2^n字节（Byte），那么地址总线宽度为 n 位。</p><p> 8KB = 2^13byte</p><p>所以为13</p><p>2.1KB存储器的地址范围， 1KB = 1024个存储单元，地址从0开始编号</p><p>所以为0-1023</p><p>3.1KB存储器可存储的数据量，1KB = 2^13bit</p><p>可存储 <strong>2^13</strong> bit</p><p>可存储 <strong>2^10</strong> Byte</p><p>4.常见的转换：：：</p><p>1KB = 2^10Byte</p><p>1MB = 2^20Byte</p><p>1GB = 2^30Byte</p><p>6.传输1024字节所需次数</p><p>若数据总线宽度为 n 位，则每次传输 n/8 字节</p><p>所需次数 = 总字节数 ÷ 每次字节数</p><p>8086（16位）→ 一次2B → =512 次</p><p>80386（32位）→ 一次4B → =256 次</p><p>8080：8位 → 1B</p><p>8088：8位 → 1B</p><p>8086：16位 → 2B</p><p>80286：16位 → 2B</p><p>80386：32位 → 4B</p><h2 id="二-寄存器"><a href="#二-寄存器" class="headerlink" title="二 寄存器"></a>二 寄存器</h2><p>1.补充完整：</p><p><code>mov</code> 是赋值指令，不影响标志位。</p><p><code>add</code> 是加法指令，结果存入目标寄存器。</p><p><code>ax</code> 包括 <code>ah</code>（高8位）和 <code>al</code>（低8位）。</p><p>指令演示：</p><div class="table-container"><table><thead><tr><th>指令</th><th>执行后寄存器值</th><th>说明</th></tr></thead><tbody><tr><td><code>mov ax,62627</code></td><td>AX = F4A3H</td><td>62627₁ = F4A3₁₆</td></tr><tr><td><code>mov ah,31H</code></td><td>AX = 31A3H</td><td>修改高 8 位</td></tr><tr><td><code>mov al,23H</code></td><td>AX = 3123H</td><td>修改低 8 位</td></tr><tr><td><code>add ax,ax</code></td><td>AX = 6246H</td><td>3123H + 3123H</td></tr><tr><td><code>mov bx,826CH</code></td><td>BX = 826CH</td><td>直接赋值</td></tr><tr><td><code>mov cx,ax</code></td><td>CX = 6246H</td><td>AX → CX</td></tr><tr><td><code>mov ax,bx</code></td><td>AX = 826CH</td><td>BX → AX</td></tr><tr><td><code>add ax,bx</code></td><td>AX = 04D8H</td><td>826CH + 826CH = 104D8H → 截断为 04D8H</td></tr><tr><td><code>mov al,bh</code></td><td>AX = 0482H</td><td>BH → AL（AL = 82H），AH 未变（仍为 04H）</td></tr><tr><td><code>mov ah,bl</code></td><td>AX = 6C82H</td><td>BL → AH（AH = 6CH）</td></tr><tr><td><code>add ah,ah</code></td><td>AX = D882H</td><td>AH = 6C + 6C = D8H</td></tr><tr><td><code>add al,6</code></td><td>AX = D888H</td><td>AL = 82H + 06H = 88H</td></tr><tr><td><code>add al,al</code></td><td>AX = D810H</td><td>AL = 88H + 88H = 110H → 截断为 10H</td></tr><tr><td><code>mov ax,cx</code></td><td>AX = 6246H</td><td>CX → AX</td></tr></tbody></table></div><p>2.用最多4条指令计算 2⁴</p><p>每次 <code>add ax, ax</code> 就是乘以 2，相当于左移 1 位</p><p>mov ax,2<br>add ax,ax   ; 2 × 2 = 4<br>add ax,ax   ; 4 × 2 = 8<br>add ax,ax   ; 8 × 2 = 16</p><p>3.段地址 0001H 时的寻址范围</p><p>实地址 = 段地址 × 16 + 偏移地址</p><p>段地址 0001H → 00010H 实起始地址</p><p>最大偏移 = <strong>FFFFH</strong> → 最大地址 = 00010H + FFFFH = 1000FH</p><p>所以寻址的范围就是00010H-1000FH</p><p>4.要访问实地址 20000H，求段地址 SA 的范围</p><p>实地址 = SA × 10H + 偏移</p><p>设偏移 = 0 → SA 最小 = 20000H ÷ 10H = 2000H</p><p>设偏移最大 = FFFFH → SA 最大 = (20000H - FFFFH) ÷ 10H ≈ 1001H</p><p>最小段地址：<strong>1001H</strong></p><p>最大段地址：<strong>2000H</strong></p><p>5.</p><p>sub ax, ax  用 <code>AX</code> 自己减自己，结果赋给 <code>AX</code> 这样的结果为0</p><p>清零首选 <code>xor ax, ax</code></p><p>jmp ax，跳转到 <code>AX</code> 中存储的地址</p><p><strong>IP 修改次数：4 次</strong></p><p><strong>修改时机：</strong></p><ol><li><code>mov</code> 指令加载 → IP++</li><li><code>sub</code> 指令加载 → IP++</li><li><code>jmp</code> 指令加载 → IP++</li><li><code>jmp</code> 执行 → IP ← AX</li></ol><p><strong>最后 IP 的值：</strong> <strong>0000H</strong></p><h2 id="九-跳跃"><a href="#九-跳跃" class="headerlink" title="九 跳跃"></a>九 跳跃</h2><p>1.段内转移指令 <code>jmp word ptr [bx+1]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">?</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,<span class="number">0</span></span><br><span class="line">jmp word ptr [bx+<span class="number">1</span>]  ; 段内跳转，偏移地址来自ds:[bx+<span class="number">1</span>]</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>jmp word ptr [bx+1]</code> 表示从内存地址 <code>ds:[1]</code> 和 <code>ds:[2]</code> 处读取2字节构成目标偏移地址，CS不变。</p><p>要跳到 <code>IP = 0000H</code>，那么 <code>ds:[1~2] = 0000H</code>。</p><p>所以只需确保 data 段的第二、三字节是 0。</p><p><strong>db 4 dup (0)  ; 定义4字节，确保ds:[1]和ds:[2]都是0</strong></p><p>2.段间跳跃，jmp dword ptr ds:[0]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">dd 12345678H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,<span class="number">0</span></span><br><span class="line">mov [bx],____</span><br><span class="line">mov [bx+<span class="number">2</span>],____</span><br><span class="line">jmp dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">mov ax,4c00h</span><br><span class="line"><span class="type">int</span> 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>jmp dword ptr ds:[0]</code> 是<strong>段间跳转</strong>，执行时：</p><ul><li><code>ds:[0]~[1]</code> → 被解释为 IP（偏移地址）</li><li><code>ds:[2]~[3]</code> → 被解释为 CS（段地址）</li></ul><p>当前指令起始处 IP = 0000H（或 <code>offset start</code>）</p><p>当前 CS = cs，跳转目标就是 <code>CS:0</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov [bx], bx    ; 相当于 mov [0], 0</span><br><span class="line">mov [bx+2], cs  ; 相当于 mov [2], cs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.指令 <code>jmp dword ptr es:[1000H]</code>，查看内存内容分析跳转结果</p><p>2000:1000 BE 00 06 00 00 00 …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov es,ax</span><br><span class="line">jmp dword ptr es:[1000H]</span><br></pre></td></tr></table></figure><p>段间跳转，目标是 <code>es:[1000H]</code> 开始的4字节：</p><ul><li><code>低地址两字节（BE 00）</code> → IP = 00BEH</li><li><code>高地址两字节（06 00）</code> → CS = 0006H</li></ul><p>跳转后：CS = 0006H, IP = 00BEH</p><p>4.使用 <code>jcxz</code> 查找第一个值为0的字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">s:mov cl,ds:[bx]   ; 将内存内容加载到CL</span><br><span class="line">mov ch,0         ; 组成CX = 0000 ~ 00FF</span><br><span class="line">jcxz ok          ; 如果 CX = 0, 跳转</span><br><span class="line">add bx,1</span><br><span class="line">jmp short s</span><br><span class="line">ok:mov dx,bx        ; BX 即偏移位置</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次加载一个字节到 CL，然后组成 16 位 CX（CH=0）</p><p>如果 <code>CX=0</code>，说明找到了值为0的字节</p><p>用 <code>jcxz</code> 检查，找到后跳转到 <code>ok</code></p><p>最终将偏移地址保存在 DX 中</p><p>5.使用 <code>loop</code> 查找第一个为0的 byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">s:mov cl,[bx]</span><br><span class="line">mov ch,0</span><br><span class="line">add cx,1        ; 如果 cx = 0，add cx,1 得到 1，loop 继续</span><br><span class="line">inc bx          ; 查下一个字节</span><br><span class="line">loop s </span><br><span class="line">ok:dec bx         ; 多加了一次 bx，回退</span><br><span class="line">mov dx,bx</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>loop指令减少 CX 并跳转，直到 CX=0</li><li>用 <code>cl=[bx]</code> 加载内存，若为0，则 <code>cx=0</code>，<code>add cx,1</code> 变成 1，<code>loop</code>执行后 cx=0，跳出</li><li>最终偏移值存在 <code>bx</code> 中，但已多加一，因此 <code>dec bx</code> 修正偏移</li></ul><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>1.内存查看与汇编执行分析(x)</p><p>0000:0000 70 80 F0 30 EF 60 30 E2 00 80 80 12 66 20 22 60<br>0000:0010 62 26 E6 D6 CC 2E 3C 3B AB BA 00 00 26 06 66 88</p><div class="table-container"><table><thead><tr><th>汇编指令</th><th>AX</th><th>BX</th><th>说明</th></tr></thead><tbody><tr><td><code>mov ax,1</code></td><td>0001</td><td>0000</td><td>AX ← 1</td></tr><tr><td><code>mov ds,ax</code></td><td>0001</td><td>0000</td><td>DS ← AX，不影响 AX/BX</td></tr><tr><td><code>mov ax,[0000]</code></td><td>2662</td><td>0000</td><td>AX ← DS:0000 = 0x8026（注意是低地址在前）</td></tr><tr><td><code>mov bx,[0001]</code></td><td>2662</td><td>E626</td><td>BX ← DS:0001 = 0x26E6（从地址0001开始读两个字节）</td></tr><tr><td><code>mov ax,bx</code></td><td>E626</td><td>E626</td><td>AX ← BX</td></tr><tr><td><code>mov ax,[0000]</code></td><td>2662</td><td>E626</td><td>AX ← DS:0000</td></tr><tr><td><code>mov bx,[0002]</code></td><td>2662</td><td>D6E6</td><td>BX ← DS:0002 = 0xE6D6</td></tr><tr><td><code>add ax,bx</code></td><td>FD48</td><td>D6E6</td><td>AX = 2662 + D6E6 = FD48</td></tr><tr><td><code>add ax,[0004]</code></td><td>2C14</td><td>D6E6</td><td>AX += DS:0004 = 0x602C → FD48+602C=15D74 → 截断为2C14</td></tr><tr><td><code>mov ax,0</code></td><td>0000</td><td>D6E6</td><td>清零 AX</td></tr><tr><td><code>mov al,[0002]</code></td><td>00E6</td><td>D6E6</td><td>AL ← E6（AX低字节），AH=0 → AX=00E6</td></tr><tr><td><code>mov bx,0</code></td><td>00E6</td><td>0000</td><td>BX 清零</td></tr><tr><td><code>mov bl,[000C]</code></td><td>00E6</td><td>0026</td><td>BL ← DS:000C = 26H → BX=0026</td></tr><tr><td><code>add al,bl</code></td><td>000C</td><td>0026</td><td>AL=E6+26=10C → 截断为 0C，AX=000C</td></tr></tbody></table></div><p>2.程序执行追踪 + 汇编流程图(x)</p><p>mov ax,6622H<br>jmp 0ff0:0100H<br>mov ax,2000H<br>mov ds,ax<br>mov ax,[0008]<br>mov ax,[0002]</p><div class="table-container"><table><thead><tr><th>指令</th><th>AX</th><th>BX</th><th>CS</th><th>IP</th><th>DS</th></tr></thead><tbody><tr><td><code>mov ax,6622H</code></td><td>6622</td><td>0000</td><td>2000</td><td>0003</td><td>1000</td></tr><tr><td><code>jmp 0ff0:0100H</code></td><td>6622</td><td>0000</td><td>0FF0</td><td>0100</td><td>1000</td></tr><tr><td><code>mov ax,2000H</code></td><td>2000</td><td>0000</td><td>0FF0</td><td>0103</td><td>1000</td></tr><tr><td><code>mov ds,ax</code></td><td>2000</td><td>0000</td><td>0FF0</td><td>0105</td><td>2000</td></tr><tr><td><code>mov ax,[0008]</code></td><td>C189</td><td>0000</td><td>0FF0</td><td>0108</td><td>2000</td></tr><tr><td><code>mov ax,[0002]</code></td><td>EA66</td><td>0000</td><td>0FF0</td><td>010B</td><td>2000</td></tr></tbody></table></div><p>3.逆序拷贝程序（使用栈）</p><p>将 <code>10000H~1000FH</code> 的 8 个字（<strong>16 字节</strong>）将 10000H~1000FH 中的 8 个字逆序拷贝到 20000H~2000FH 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax           ; 数据段指向 10000H，就是原始地址</span><br><span class="line"></span><br><span class="line">mov ax,2000H</span><br><span class="line">mov ss,ax           ; 栈段指向 20000H,就是目的地址</span><br><span class="line">mov sp,0010H        ; 栈顶为 20000:0010</span><br><span class="line"></span><br><span class="line">push [0]</span><br><span class="line">push [2]</span><br><span class="line">push [4]</span><br><span class="line">push [6]</span><br><span class="line">push [8]</span><br><span class="line">push [0AH]</span><br><span class="line">push [0CH]</span><br><span class="line">push [0EH]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栈是从高地址向低地址存储，push 后栈内容为 <code>[0EH], [0CH], ..., [0]</code></p><p>注意 <code>[0]</code> 等都是 <code>ds</code> 段内偏移地址</p><p>出栈写入（pop）将 10000H~1000FH 中的 8 个字逆序拷贝到 20000H~2000FH 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,0000H</span><br><span class="line">pop [E]</span><br><span class="line">pop [C]</span><br><span class="line">pop [A]</span><br><span class="line">pop [8]</span><br><span class="line">pop [6]</span><br><span class="line">pop [4]</span><br><span class="line">pop [2]</span><br><span class="line">pop [0]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>DS（Data Segment，数据段寄存器）</strong><br> 指向当前程序使用的数据段基地址，用于访问数据。</p><p><strong>SS（Stack Segment，栈段寄存器）</strong><br> 指向当前栈所在的段基地址。</p><p><strong>SP（Stack Pointer，栈指针寄存器）</strong><br> 指示当前栈顶（栈顶指针）的偏移地址，结合 SS 寄存器，确定栈顶的线性地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>说明数据段 DS 指向段地址 <code>1000H</code>，即内存中以 <code>10000H</code> 为起始的地址区域。</p><p><code>SP</code> 是栈顶偏移量，相对于 SS 指定的段地址。</p><h2 id="十"><a href="#十" class="headerlink" title="十"></a>十</h2><p>1.利用 <code>retf</code> 实现远跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">    db <span class="number">16</span> dup(<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,<span class="number">16</span></span><br><span class="line">    mov ax,1000h</span><br><span class="line">    push ax</span><br><span class="line">    mov ax,<span class="number">0</span></span><br><span class="line">    push ax</span><br><span class="line">    retf</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000h   ; 目标段地址</span><br><span class="line">push ax        ; 压栈：目标段</span><br><span class="line">mov ax,<span class="number">0</span>       ; 目标偏移地址</span><br><span class="line">push ax        ; 压栈：目标偏移</span><br><span class="line">retf           ; 弹出两个字：IP ← [SP]，CS ← [SP+<span class="number">2</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从当前程序跳转到 1000:0000 开始执行。</p><p>2.<code>call 段内过程</code> 的本质</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span>:<span class="number">0000</span> b8 <span class="number">00</span> <span class="number">00</span>        mov ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">0003</span> e8 <span class="number">01</span> <span class="number">00</span>        call s</span><br><span class="line"><span class="number">1000</span>:<span class="number">0006</span> <span class="number">40</span>              inc ax</span><br><span class="line"><span class="number">1000</span>:<span class="number">0007</span> <span class="number">58</span>          s: pop ax</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">0</span></span><br><span class="line">call s       ; 将下一条指令地址（<span class="number">1000</span>:<span class="number">06</span>）压栈</span><br><span class="line">inc ax       ; IP 跳转后这句不会先执行</span><br><span class="line">s: pop ax    ; 从栈中弹出 <span class="number">1000</span>:<span class="number">06</span>，ax=<span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>call s</code> 将<strong>返回地址 1000:06</strong> 压入栈</p><p>pop ax<code>弹出该地址，</code>ax=6</p><p>3.机械码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span>:<span class="number">0000</span> b8 <span class="number">00</span> <span class="number">00</span>        mov ax,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">0003</span> 9a 09 <span class="number">00</span> <span class="number">00</span> <span class="number">10</span>  call far ptr s  ; 调用 <span class="number">1000</span>:0009</span><br><span class="line"><span class="number">1000</span>:0008 <span class="number">40</span>              inc ax</span><br><span class="line"><span class="number">1000</span>:0009 <span class="number">58</span>          s: pop ax</span><br><span class="line">           <span class="number">05</span> <span class="number">00</span>           add ax, ax</span><br><span class="line">           <span class="number">1f</span>              pop bx</span><br><span class="line">           <span class="number">03</span> d8           add ax, bx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行后，<strong>ax的值为多少？</strong></p><p><code>pop ax</code> → ax = 0008h（返回地址）</p><p><code>add ax, ax</code> → ax = 0x10</p><p><code>pop bx</code> → bx = 1000h（段）</p><p><code>add ax, bx</code> → ax = 0x10 + 0x1000 = 0x1010</p><p>4.call ax（寄存器间接调用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1000:0000 b8 06 00       mov ax,6</span><br><span class="line">1000:0003 ff d0          call ax</span><br><span class="line">1000:0005 40             inc ax</span><br><span class="line">1000:0006 58             pop ax</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>call ax</code> 相当于 <code>call 0006h</code>，先把返回地址 1000:05 压栈</p><p>到 <code>1000:06</code>，执行 <code>pop ax</code> → ax = 0005</p><p>5.间接调用 call word ptr ds:[0eh]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">call word ptr ds:[0eh]</span><br><span class="line">inc ax</span><br><span class="line">inc ax</span><br><span class="line">inc ax</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>已知 <code>[ds:0eh] = 0011h</code>，<strong>call跳转到0011h后执行 inc ax 三次</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0</span><br><span class="line">    call word ptr ds:[0eh]</span><br><span class="line">    inc ax</span><br><span class="line">    inc ax</span><br><span class="line">    inc ax</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>栈段 <code>stack</code> 定义了 8 个 word 空间，共 16 字节（从 0 到 15）。</li><li>初始化：<code>ss = stack</code>, <code>sp = 16</code>，即栈顶从偏移 <code>0010h</code> 开始。</li><li><code>ds = ax = stack</code></li><li><code>call word ptr ds:[0eh]</code><br> 查找 <code>ds:0eh</code> 处的内容，即偏移地址（设为 0011h）</li></ul><blockquote><p>因为 call 是段内调用，所以：</p></blockquote><ul><li><p><strong>执行 <code>call 0011h</code>：</strong></p><ul><li><code>call</code> 会将 <strong>返回地址 (call 下一条指令地址) = 0011h</strong> 压入栈</li><li>IP ← 0011h</li></ul></li><li><p>IP 跳转到 offset=0011h 的位置，接着执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inc ax</span><br><span class="line">inc ax</span><br><span class="line">inc ax</span><br></pre></td></tr></table></figure><p>初始 ax = 0 → 1 → 2 → 3</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10h</span><br><span class="line">    mov word ptr ss:[0],offset s ; (ss:[0]) = 1Ah</span><br><span class="line">    mov ss:[2],cs                ; (ss:[2]) = 当前代码段 CS</span><br><span class="line">    call dword ptr ss:[0]        ; 相当于 call far ptr cs:1Ah</span><br><span class="line">                                 ; 执行前压栈：cs 和 IP=19h</span><br><span class="line">                                 ; (ss:[4]) = cs, (ss:[6]) = 19h</span><br><span class="line">    nop</span><br><span class="line">s:</span><br><span class="line">    mov ax,offset s              ; ax = 1Ah</span><br><span class="line">    sub ax,ss:[0ch]              ; ax = 1Ah - ss:[0Ch] = 1Ah - 19h = 1</span><br><span class="line">    mov bx,cs                    ; bx = cs</span><br><span class="line">    sub bx,ss:[0eh]              ; bx = cs - ss:[0eh] = cs - cs = 0</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>ss:[0] = 1Ah</code>，即跳转到当前段偏移地址 1Ah</li><li><code>ss:[2] = cs</code>，即段地址</li><li><code>call dword ptr ss:[0]</code> → <strong>跳转到 cs:1Ah</strong></li><li>call 指令将 <strong>返回地址 IP=19h</strong> 和 <strong>CS=cs</strong> 入栈：<ul><li><code>ss:[4] = cs</code></li><li><code>ss:[6] = 0019h</code></li></ul></li></ul><p>进入 <code>s:</code> 标签后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, offset s      ; ax = 1Ah</span><br><span class="line">sub ax, ss:[0ch]      ; ss:[0ch] = 19h → ax = 1Ah - 19h = 1</span><br><span class="line">mov bx, cs            ; bx = cs</span><br><span class="line">sub bx, ss:[0eh]      ; ss:[0eh] = cs → bx = cs - cs = 0</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax = 1</span><br><span class="line">bx = 0</span><br></pre></td></tr></table></figure><h1 id="十一"><a href="#十一" class="headerlink" title="十一"></a>十一</h1><p>写出每条指令执行后，标志位的值：</p><div class="table-container"><table><thead><tr><th>指令</th><th>CF</th><th>OF</th><th>SF</th><th>ZF</th><th>PF</th></tr></thead><tbody><tr><td><code>sub al, al</code></td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td><code>mov al,10H</code></td><td>—</td><td>—</td><td>0</td><td>0</td><td>1</td></tr><tr><td><code>add al,90H</code></td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td><code>mov al,80H</code></td><td>—</td><td>—</td><td>1</td><td>0</td><td>1</td></tr><tr><td><code>add al,80H</code></td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td><code>mov al,0FCH</code></td><td>—</td><td>—</td><td>1</td><td>0</td><td>1</td></tr><tr><td><code>add al,05H</code></td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td><code>mov al,7DH</code></td><td>—</td><td>—</td><td>0</td><td>0</td><td>0</td></tr><tr><td><code>add al,0BH</code></td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table></div><h1 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h1><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="1-对汇编语言的理解"><a href="#1-对汇编语言的理解" class="headerlink" title="1.对汇编语言的理解"></a>1.对汇编语言的理解</h3><p><strong>概念</strong>：面向机器的低级语言，使用符号化指令（助记符）</p><p><strong>优点</strong>：</p><ul><li>执行效率高（直接操作寄存器/内存）</li><li>控制力强（可精细操控硬件）</li><li>有助于理解计算机体系结构</li></ul><p><strong>缺点</strong>：</p><ul><li>语法繁琐、代码量大</li><li>可读性差、维护难度高</li><li>不可移植，依赖具体 CPU 架构</li></ul><h3 id="2-寄存器体系及其使用"><a href="#2-寄存器体系及其使用" class="headerlink" title="2.寄存器体系及其使用"></a>2.寄存器体系及其使用</h3><div class="table-container"><table><thead><tr><th>标志位</th><th>含义</th><th>触发条件示例</th></tr></thead><tbody><tr><td><strong>ZF</strong></td><td>Zero Flag，零标志</td><td>运算结果为0时置位1</td></tr><tr><td><strong>SF</strong></td><td>Sign Flag，符号标志</td><td>运算结果最高位为1时置位1</td></tr><tr><td><strong>CF</strong></td><td>Carry Flag，进位/借位标志</td><td>无符号加法产生进位或减法借位时置1</td></tr><tr><td><strong>OF</strong></td><td>Overflow Flag，溢出标志</td><td>有符号运算超出范围时置1</td></tr><tr><td><strong>PF</strong></td><td>Parity Flag，奇偶标志（低8位偶数个1）</td><td>结果低8位中1的个数为偶数时置1</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub al,al    → ZF=1, PF=1, SF=0</span><br><span class="line">mov al,10H   → ZF=0, PF=1, SF=0</span><br><span class="line">add al,90H   → SF=1, ZF=0, PF=1</span><br><span class="line">add al,80H   → OF=1, CF=1, ZF=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-程序加载与段：偏移机制"><a href="#3-程序加载与段：偏移机制" class="headerlink" title="3.程序加载与段：偏移机制"></a>3.程序加载与段：偏移机制</h3><p><strong>段地址（Segment Address）</strong>：指内存中一个<strong>64KB段的起始地址</strong>，由段寄存器（如 CS、DS、SS、ES）给出。</p><p><strong>偏移地址（Offset Address）</strong>：表示<strong>该段内的相对地址位置</strong>，通常由 IP、BX、SI、DI 等寄存器提供。</p><p><strong>物理地址计算公式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编辑物理地址 = 段地址 × 16 + 偏移地址</span><br><span class="line">        = 段地址 &lt;&lt; 4 + 偏移地址</span><br></pre></td></tr></table></figure><h3 id="4-条件与无条件跳转"><a href="#4-条件与无条件跳转" class="headerlink" title="4.条件与无条件跳转"></a>4.条件与无条件跳转</h3><p><code>jmp</code>/ <code>je</code>/ <code>jne</code>/ <code>jg</code>… 指令格式</p><p>近跳转 vs 远跳转 vs 间接跳转</p><p>跳转目标：立即数、寄存器、内存</p><p><strong>jmp 指令</strong>：</p><p><strong>jmp 段内跳转</strong>：只修改 IP，CS 不变。<strong>jmp 段间跳转</strong>：同时修改 CS 和 IP</p><p><strong>call 指令：</strong></p><p>实现<strong>子程序调用</strong>，会将<strong>返回地址入栈</strong>，然后跳转到目标地址。</p><ul><li>近调用（段内）：只入栈 IP</li><li>远调用（段间）：先入栈 CS，再入栈 IP</li></ul><p>调用完成后跳转到子程序开始位置执行。</p><p><strong>ret / retf 指令</strong>：</p><p><strong>ret</strong>：弹出栈顶内容（IP）并跳回（适用于近调用）；</p><p><strong>retf</strong>：弹出两个字节恢复 IP，然后再弹出两个字节恢复 CS，实现段间返回。</p><h3 id="5-基本结构"><a href="#5-基本结构" class="headerlink" title="5.基本结构"></a>5.基本结构</h3><p>汇编程序的基本结构：由代码段（存放指令）、数据段（存放数据）、栈段（管理栈空间）组成，程序入口标签（如 <code>start:</code>）指明执行起点，<code>end</code> 标记程序结束</p><p>段寄存器的作用及设置：CS 指向代码段，DS 指向数据段，SS 指向栈段。设置时先用 <code>mov ax, 段地址</code>，再用 <code>mov 段寄存器, ax</code> 装载段地址。</p><p>汇编程序的执行流程：CPU 从 CS:IP 指向位置开始执行指令，执行后 IP 自动加指令长度，跳转指令可修改 CS 和 IP 以改变执行流。</p><p>内存访问方式：内存地址由段寄存器和偏移地址组合计算，数据访问用 DS，代码访问用 CS，栈操作用 SS。</p><p>汇编指令的基本作用：<code>mov</code> 指令实现数据在寄存器和内存间传送，段寄存器初始化通过先装载到通用寄存器再转移。</p><h3 id="6-DOS-如何加载-EXE-可执行程序？"><a href="#6-DOS-如何加载-EXE-可执行程序？" class="headerlink" title="6.DOS 如何加载 EXE 可执行程序？"></a>6.DOS 如何加载 EXE 可执行程序？</h3><p>DOS 从内存中找到一块空闲区域，段地址为 SA，偏移为 0000。</p><p>在 SA:0 开始的 256 字节内创建 PSP（程序段前缀），用于 DOS 和程序通信。</p><p>程序本体加载到 SA+10H:0 处，即从 256 字节后开始执行。</p><p>PSP 和程序在物理地址上连续，但逻辑段地址不同。</p><p>最后设置 DS=SA，CS:IP=SA+10H:0，准备开始执行程序。</p><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="1-栈操作细节，push-pop-对-SP、SS-的影响"><a href="#1-栈操作细节，push-pop-对-SP、SS-的影响" class="headerlink" title="1.栈操作细节，push/ pop 对 SP、SS 的影响"></a>1.栈操作细节，<code>push</code>/ <code>pop</code> 对 SP、SS 的影响</h3><h3 id="2-转移指令格式，机器码长度、操作数类型"><a href="#2-转移指令格式，机器码长度、操作数类型" class="headerlink" title="2.转移指令格式，机器码长度、操作数类型"></a>2.转移指令格式，机器码长度、操作数类型</h3><h3 id="3-子程序调用，call-ret-的入栈、出栈顺序"><a href="#3-子程序调用，call-ret-的入栈、出栈顺序" class="headerlink" title="3.子程序调用，call/ ret 的入栈、出栈顺序"></a>3.子程序调用，<code>call</code>/ <code>ret</code> 的入栈、出栈顺序</h3><h3 id="4-标志寄存器，ZF、SF、CF、OF-置位条件，哪些算术-逻辑指令影响哪些标志"><a href="#4-标志寄存器，ZF、SF、CF、OF-置位条件，哪些算术-逻辑指令影响哪些标志" class="headerlink" title="4.标志寄存器，ZF、SF、CF、OF 置位条件，哪些算术/逻辑指令影响哪些标志"></a>4.标志寄存器，ZF、SF、CF、OF 置位条件，哪些算术/逻辑指令影响哪些标志</h3><h2 id="程序分析题"><a href="#程序分析题" class="headerlink" title="程序分析题"></a>程序分析题</h2><p>1.<code>loop</code> 循环 &amp; CX 计数寄存器变化，<code>loop label</code> 的执行流程——取指、CX–1、ZF检查、跳转，执行次数与初始 CX 的关系</p><p>2.子程序/间接跳转跟踪，</p><p><code>call</code>/ <code>jmp reg</code>/ <code>ret</code> 全流程：</p><ol><li>IP 入栈</li><li>CS:IP 更新</li><li>返回地址弹栈</li></ol><p>3.复制程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    mov ax, 0020h</span><br><span class="line">    mov ds, ax        ; DS = 源数据段 → <span class="number">0020</span>:<span class="number">0000</span> 起</span><br><span class="line">    mov ax, 0021h</span><br><span class="line">    mov es, ax        ; ES = 目标数据段 → <span class="number">0021</span>:<span class="number">0000</span> 起</span><br><span class="line"></span><br><span class="line">    mov bx, <span class="number">0</span></span><br><span class="line">    mov cx, <span class="number">10</span>        ; 拷贝 <span class="number">10</span> 个字节（或字符）</span><br><span class="line"></span><br><span class="line">s:  mov al, [bx]      ; 从 DS:[BX] 取数据（即 <span class="number">0020</span>:BX）</span><br><span class="line">    mov es:[bx], al   ; 写入 ES:[BX]（即 <span class="number">0021</span>:BX）</span><br><span class="line">    inc bx</span><br><span class="line">    loop s            ; 循环 CX 次，CX ← CX - <span class="number">1</span>，直到 CX=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    mov ax, 4c00h</span><br><span class="line">    <span class="type">int</span> 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将 DS:0000（0020:0000）开始的 <strong>10 个字节</strong> 拷贝到 ES:0000（0021:0000）开始的地址。</p><p><code>mov al, [bx]</code> 表示：从 <strong>DS:BX</strong> 指向的内存地址中读取一个字节到 AL（间接寻址）</p><p><code>mov es:[bx], al</code> 表示：将 AL 的值存入 ES:BX 指向的内存地址</p><p><code>loop s</code> = <code>dec cx; if cx != 0 then jmp s</code>，循环控制语句，用于固定次数循环</p><p><code>mov ds, ax</code> 和 <code>mov es, ax</code> 是设置数据段和额外段，访问内存前必须设置段寄存器</p><h1 id="编程题目"><a href="#编程题目" class="headerlink" title="编程题目"></a>编程题目</h1><ol><li><strong>基于 <code>loop</code> 的计数/求和程序（第5章）</strong></li></ol><ol><li><p><strong>段:偏移 数据搬运 + 栈管理（第6章）</strong></p><p>如：从数据段读字符串，压栈→子程序处理→弹栈</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H</span><br><span class="line">start:mov ax,<span class="number">0</span></span><br><span class="line">mov ds,ax              ; DS → <span class="number">0</span>，即访问 <span class="number">0</span>:<span class="number">0</span>~<span class="number">0</span>:F</span><br><span class="line">mov bx,<span class="number">0</span></span><br><span class="line">mov cx,<span class="number">8</span></span><br><span class="line">s:mov ax,[bx]            ; 从内存 <span class="number">0000</span>:BX 处读两个字节到 AX</span><br><span class="line">mov cs:[bx],ax         ; 把 AX 写入代码段 CS:BX 位置的数据</span><br><span class="line">add bx,<span class="number">2</span></span><br><span class="line">loop s</span><br><span class="line">mov ax,4C00H</span><br><span class="line"><span class="type">int</span> 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据从<strong>0:0 ~ 0:F</strong>（16 字节，8 个字）依次读取，<strong>覆盖 CS 段中的初始数据区</strong></p><p>原始数据如 <code>0123H,0456H...</code> 将被替换为内存中读取的新数据</p><p>效果：<strong>程序数据区被外部数据动态更新</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H</span><br><span class="line">dw <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>   ; 共<span class="number">16</span>字节空间，用作栈区</span><br><span class="line">start:mov ax,cs             ; 设定 SS = CS，栈在代码段中</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,<span class="number">36</span>             ; SP = <span class="number">36</span> → 栈顶指向代码段偏移 24h</span><br><span class="line">mov ax,<span class="number">0</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,<span class="number">0</span></span><br><span class="line">mov cx,<span class="number">8</span></span><br><span class="line">s:push [bx]            ; 从 DS:BX（即 <span class="number">0</span>:<span class="number">0</span> 开始）压栈</span><br><span class="line">pop cs:[bx]          ; 从栈中弹出数据写入 CS:BX（覆盖初始数据）</span><br><span class="line">add bx,<span class="number">2</span></span><br><span class="line">loop s</span><br><span class="line">mov ax,4C00H</span><br><span class="line"><span class="type">int</span> 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>stack</code> 完成数据搬运，相当于：<br> <code>ax ← ds:[bx] → push → 栈 → pop → cs:[bx]</code></p><p>使用 <code>push/pop</code> 方式达到 <strong>数据传送效果</strong></p><p>栈顶设为 24h（即 36 十进制）→ 从 <code>cs:0024h</code> 处开始使用栈</p><p>栈段的起始位置由 <code>ss = cs</code> 指定，即栈放在当前代码段末尾的空区域</p><ol><li><p><strong>大小写转换（第7章）</strong></p><ul><li>利用 <code>AL</code>/<code>AH</code> 与 ASCII 区别</li><li>不同寻址方式：立即、直接、寄存器间接</li></ul></li></ol><p><strong>将 <code>datasg</code> 段中每个字符串的前 4 个字母转换为大写字母</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg, ss:stacksg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">    dw <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">    db <span class="string">&#x27;1. display&#x27;</span></span><br><span class="line">    db <span class="string">&#x27;2. brows&#x27;</span></span><br><span class="line">    db <span class="string">&#x27;3. replace&#x27;</span></span><br><span class="line">    db <span class="string">&#x27;4. modify&#x27;</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">    mov ax, datasg</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">    mov bx, <span class="number">3</span>      ; 第<span class="number">1</span>行，跳过 <span class="string">&#x27;1. &#x27;</span></span><br><span class="line">    call upper4</span><br><span class="line">    mov bx, <span class="number">13</span>     ; 第<span class="number">2</span>行，跳过 <span class="string">&#x27;2. &#x27;</span></span><br><span class="line">    call upper4</span><br><span class="line">    mov bx, <span class="number">21</span>     ; 第<span class="number">3</span>行，跳过 <span class="string">&#x27;3. &#x27;</span></span><br><span class="line">    call upper4</span><br><span class="line">    mov bx, <span class="number">31</span>     ; 第<span class="number">4</span>行，跳过 <span class="string">&#x27;4. &#x27;</span></span><br><span class="line">    call upper4</span><br><span class="line"></span><br><span class="line">    mov ax, 4C00h</span><br><span class="line">    <span class="type">int</span> 21h</span><br><span class="line"></span><br><span class="line">; 子程序：将 [bx] 开始的<span class="number">4</span>个字母改为大写</span><br><span class="line">upper4:</span><br><span class="line">    mov cx, <span class="number">4</span></span><br><span class="line">next:</span><br><span class="line">    mov al, [bx]</span><br><span class="line">    cmp al, <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    jb skip</span><br><span class="line">    cmp al, <span class="string">&#x27;z&#x27;</span></span><br><span class="line">    ja skip</span><br><span class="line">    sub al, 20h</span><br><span class="line">    mov [bx], al</span><br><span class="line">skip:</span><br><span class="line">    inc bx</span><br><span class="line">    loop next</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>每条字符串偏移</strong>分别是：3、13、21、31（跳过编号和点空格）。</p><p><strong>upper4 子程序</strong>：处理从 <code>[bx]</code> 开始的 4 个字符。</p><p>利用了 <code>cmp</code> 和 <code>sub</code> 判断是否是小写字母。</p><ol><li><p><strong>字符串操作指令综合（第8章）</strong></p><ul><li><code>MOVS</code>/<code>LODS</code>/<code>STOS</code>/<code>CMPS</code>/<code>SCAS</code> 实现功能</li></ul></li></ol><p>编写程序，将 <code>data</code> 段中：</p><ul><li>21个年份（每个4字节字符串）</li><li>21个年收入（每个4字节 dword）</li><li>21个雇员数（每个2字节 word）</li></ul><p>分别搬运进 <code>table</code> 段中（每行16字节），<strong>并计算人均收入（dword / word → word，单位：千美元）</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:dataseg, es:tablesg</span><br><span class="line"></span><br><span class="line">dataseg segment</span><br><span class="line">years db <span class="string">&#x27;1975&#x27;</span>,<span class="string">&#x27;1976&#x27;</span>,<span class="string">&#x27;1977&#x27;</span>,<span class="string">&#x27;1978&#x27;</span>,<span class="string">&#x27;1979&#x27;</span>,<span class="string">&#x27;1980&#x27;</span>,<span class="string">&#x27;1981&#x27;</span>,<span class="string">&#x27;1982&#x27;</span>,<span class="string">&#x27;1983&#x27;</span></span><br><span class="line">      db <span class="string">&#x27;1984&#x27;</span>,<span class="string">&#x27;1985&#x27;</span>,<span class="string">&#x27;1986&#x27;</span>,<span class="string">&#x27;1987&#x27;</span>,<span class="string">&#x27;1988&#x27;</span>,<span class="string">&#x27;1989&#x27;</span>,<span class="string">&#x27;1990&#x27;</span>,<span class="string">&#x27;1991&#x27;</span>,<span class="string">&#x27;1992&#x27;</span></span><br><span class="line">      db <span class="string">&#x27;1993&#x27;</span>,<span class="string">&#x27;1994&#x27;</span>,<span class="string">&#x27;1995&#x27;</span></span><br><span class="line">sums  dd <span class="number">16</span>,<span class="number">22</span>,<span class="number">382</span>,<span class="number">1356</span>,<span class="number">2390</span>,<span class="number">8000</span>,<span class="number">16000</span>,<span class="number">24486</span>,<span class="number">50065</span>,<span class="number">97479</span></span><br><span class="line">      dd <span class="number">140417</span>,<span class="number">197514</span>,<span class="number">345980</span>,<span class="number">590827</span>,<span class="number">803530</span>,<span class="number">1183000</span>,<span class="number">1843000</span></span><br><span class="line">      dd <span class="number">2759000</span>,<span class="number">3753000</span>,<span class="number">4649000</span>,<span class="number">5937000</span></span><br><span class="line">nums  dw <span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">38</span>,<span class="number">130</span>,<span class="number">220</span>,<span class="number">476</span>,<span class="number">778</span></span><br><span class="line">      dw <span class="number">1001</span>,<span class="number">1442</span>,<span class="number">2258</span>,<span class="number">2793</span>,<span class="number">4037</span>,<span class="number">5635</span>,<span class="number">8226</span>,<span class="number">11542</span>,<span class="number">14430</span>,<span class="number">15257</span>,<span class="number">17800</span></span><br><span class="line">dataseg ends</span><br><span class="line"></span><br><span class="line">tablesg segment</span><br><span class="line">table db <span class="number">21</span> dup (<span class="number">16</span> dup (<span class="number">0</span>))  ; <span class="number">21</span>个结构，每个<span class="number">16</span>字节清零初始化</span><br><span class="line">tablesg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">    mov ax, dataseg</span><br><span class="line">    mov ds, ax         ; 数据段 → DS</span><br><span class="line"></span><br><span class="line">    mov ax, tablesg</span><br><span class="line">    mov es, ax         ; 表格段 → ES</span><br><span class="line"></span><br><span class="line">    xor si, si         ; si 用于索引年份</span><br><span class="line">    xor di, di         ; di = 结构偏移 = ES:table[i * <span class="number">16</span>]</span><br><span class="line">    xor bx, bx         ; bx 用于访问 sums 和 nums</span><br><span class="line">    mov cx, <span class="number">21</span>         ; 共 <span class="number">21</span> 年数据</span><br><span class="line"></span><br><span class="line">write_loop:</span><br><span class="line">    ; 拷贝年份 (<span class="number">4</span> 字节)</span><br><span class="line">    mov al, [years + si]</span><br><span class="line">    mov es:[di], al</span><br><span class="line">    mov al, [years + si + <span class="number">1</span>]</span><br><span class="line">    mov es:[di + <span class="number">1</span>], al</span><br><span class="line">    mov al, [years + si + <span class="number">2</span>]</span><br><span class="line">    mov es:[di + <span class="number">2</span>], al</span><br><span class="line">    mov al, [years + si + <span class="number">3</span>]</span><br><span class="line">    mov es:[di + <span class="number">3</span>], al</span><br><span class="line"></span><br><span class="line">    ; 拷贝收入 (dword, <span class="number">4</span> 字节)</span><br><span class="line">    mov ax, word ptr [sums + bx]</span><br><span class="line">    mov es:[di + <span class="number">4</span>], ax</span><br><span class="line">    mov ax, word ptr [sums + bx + <span class="number">2</span>]</span><br><span class="line">    mov es:[di + <span class="number">6</span>], ax</span><br><span class="line"></span><br><span class="line">    ; 拷贝雇员数 (word, <span class="number">2</span> 字节)</span><br><span class="line">    mov ax, word ptr [nums + bx]</span><br><span class="line">    mov es:[di + <span class="number">8</span>], ax</span><br><span class="line"></span><br><span class="line">    ; 计算人均收入 = dword / word</span><br><span class="line">    ; dx:ax = 总收入</span><br><span class="line">    ; cx = 雇员数</span><br><span class="line">    mov ax, word ptr [sums + bx]</span><br><span class="line">    mov dx, word ptr [sums + bx + <span class="number">2</span>]  ; dx:ax = dword</span><br><span class="line">    mov cx, word ptr [nums + bx]</span><br><span class="line">    cmp cx, <span class="number">0</span></span><br><span class="line">    je skip_div                       ; 避免除 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    div cx                            ; AX = 商（人均收入），DX = 余数</span><br><span class="line"></span><br><span class="line">    mov es:[di + <span class="number">10</span>], ax             ; 写入人均收入（word）</span><br><span class="line"></span><br><span class="line">skip_div:</span><br><span class="line">    add si, <span class="number">4</span>       ; 下一年年份字符串偏移</span><br><span class="line">    add di, <span class="number">16</span>      ; 下一结构偏移</span><br><span class="line">    add bx, <span class="number">4</span>       ; sums + nums 的索引前进</span><br><span class="line">    loop write_loop</span><br><span class="line"></span><br><span class="line">    ; 退出程序</span><br><span class="line">    mov ax, 4C00h</span><br><span class="line">    <span class="type">int</span> 21h</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/21/lastteam/huibian/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算方法期末复习</title>
      <link>https://blog.tokenlen.top/2025/06/18/lastteam/jisuanfangfa/</link>
      <guid>https://blog.tokenlen.top/2025/06/18/lastteam/jisuanfangfa/</guid>
      <pubDate>Tue, 17 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;hr&gt;
&lt;h1 id=&quot;计算方法——公式汇总&quot;&gt;&lt;a href=&quot;#计算方法——公式汇总&quot; class=&quot;headerlink&quot; title=&quot;计算方法——公式汇总&quot;&gt;&lt;/a&gt;计算方法——公式汇总&lt;/h1&gt;&lt;h2 id=&quot;第一章：误差分析&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<hr><h1 id="计算方法——公式汇总"><a href="#计算方法——公式汇总" class="headerlink" title="计算方法——公式汇总"></a>计算方法——公式汇总</h1><h2 id="第一章：误差分析"><a href="#第一章：误差分析" class="headerlink" title="第一章：误差分析"></a>第一章：误差分析</h2><ol><li><p><strong>绝对误差</strong></p><p> Δ=∣x∗−x∣\Delta = \bigl|x^* - x\bigr|</p></li><li><p><strong>相对误差</strong></p><p> δ=∣x∗−x∣∣x∗∣\delta = \frac{\bigl|x^<em> - x\bigr|}{\lvert x^</em>\rvert}</p></li><li><p><strong>四舍五入误差限</strong>（保留到第 nn 位有效数字）</p><p> Δmax⁡=12×10−n,δmax⁡=Δmax⁡∣x∣\Delta_{\max} = \tfrac12 \times 10^{-n}, \quad \delta_{\max} = \frac{\Delta_{\max}}{\lvert x\rvert}</p></li><li><p><strong>有效数字与相对误差关系</strong><br> 若已知相对误差 ε\varepsilon，则有效数字位数 nn 满足</p><p> 12 10−(n−1)  ≤  ε  &lt;  12 10−(n−2).\frac12 \,10^{-(n-1)} \;\le\; \varepsilon \;&lt;\; \frac12 \,10^{-(n-2)}.</p></li><li><p><strong>误差传播</strong></p><ul><li><p>乘除法：</p><p>  δ(f(x1,…,xk))≈∑i=1kδ(xi).\delta\bigl(f(x_1,\dots,x_k)\bigr) \approx \sum_{i=1}^k \delta(x_i).</p></li><li><p>加减法：</p><p>  Δ(f(x1,…,xk))≈∑i=1kΔ(xi).\Delta\bigl(f(x_1,\dots,x_k)\bigr) \approx \sum_{i=1}^k \Delta(x_i).</p></li><li><p>例：若 A=LWA = L W，则</p><p>  Δ(A)  ≤  ∣W∣ Δ(L)+∣L∣ Δ(W),δ(A)≈δ(L)+δ(W).\Delta(A) \;\le\; |W|\,\Delta(L) + |L|\,\Delta(W), \quad \delta(A)\approx\delta(L)+\delta(W).</p></li></ul></li></ol><hr><h2 id="第二章：非线性方程求解"><a href="#第二章：非线性方程求解" class="headerlink" title="第二章：非线性方程求解"></a>第二章：非线性方程求解</h2><ol><li><p><strong>根存在性</strong><br> 若 ff 在 [a,b][a,b] 连续且</p><p> f(a) f(b)&lt;0,f(a)\,f(b) &lt; 0,</p><p> 则 (a,b)(a,b) 内至少有一实根。</p></li><li><p><strong>二分法误差界</strong></p><p> ∣xn−x∗∣≤b−a2n,n≥⌈log⁡2b−aε⌉.\bigl|x_n - x^*\bigr| \le \frac{b-a}{2^n}, \quad n \ge \bigl\lceil \log_2\tfrac{b-a}{\varepsilon}\bigr\rceil.</p></li><li><p><strong>不动点迭代</strong><br> 写成 x=g(x)x = g(x)，迭代</p><p> xn+1=g(xn),x_{n+1} = g(x_n),</p><p> 收敛条件：∣g′(x)∣&lt;1\lvert g’(x)\rvert &lt; 1（根附近）。</p></li><li><p><strong>牛顿法</strong></p><p> xn+1=xn−f(xn)f′(xn).x_{n+1} = x_n - \frac{f(x_n)}{f’(x_n)}.</p><p> 如为重根 mm，可修正为</p><p> xn+1=xn−m f(xn)f′(xn).x_{n+1} = x_n - m\,\frac{f(x_n)}{f’(x_n)}.</p></li><li><p><strong>割线法</strong></p><p> xn+1=xn−f(xn) xn−xn−1f(xn)−f(xn−1).x_{n+1} = x_n - f(x_n)\, \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}.</p></li></ol><hr><h2 id="第三章：线性方程组数值解法"><a href="#第三章：线性方程组数值解法" class="headerlink" title="第三章：线性方程组数值解法"></a>第三章：线性方程组数值解法</h2><ol><li><p><strong>高斯消去法</strong><br> 增广矩阵 [A∣b][A\mid b] → 逐列消元 → 回代求解。</p></li><li><p><strong>列主元策略</strong><br> 每列选绝对值最大的元素作为主元，交换后再消元。</p></li><li><p><strong>Jacobi 迭代</strong><br> 令 A=D+L+UA=D+L+U，则</p><p> xi(k+1)=1aii(bi−∑j≠iaij xj(k)).x_i^{(k+1)} = \frac{1}{a_{ii}} \Bigl(b_i - \sum_{j\ne i} a_{ij}\,x_j^{(k)}\Bigr).</p></li><li><p><strong>Gauss–Seidel 迭代</strong></p><p> xi(k+1)=1aii(bi−∑j<iaij xj(k+1)−∑j>iaij xj(k)).x_i^{(k+1)} = \frac{1}{a_{ii}} \Bigl( b_i - \sum_{j<i} a_{ij}\,x_j^{(k+1)} - \sum_{j>i} a_{ij}\,x_j^{(k)} \Bigr).</p></li><li><p><strong>SOR（超松弛方法）</strong></p><p> xi(k+1)=(1−ω) xi(k)+ωaii(bi−∑j<iaij xj(k+1)−∑j>iaij xj(k)),x_i^{(k+1)} = (1-\omega)\,x_i^{(k)} + \frac{\omega}{a_{ii}} \Bigl( b_i - \sum_{j<i} a_{ij}\,x_j^{(k+1)} - \sum_{j>i} a_{ij}\,x_j^{(k)} \Bigr),</p><p> 其中 1&lt;ω&lt;21&lt;\omega&lt;2。</p></li></ol><hr><h2 id="第四章：插值与拟合"><a href="#第四章：插值与拟合" class="headerlink" title="第四章：插值与拟合"></a>第四章：插值与拟合</h2><ol><li><p><strong>拉格朗日插值</strong><br> 给定 (x0,y0),…,(xn,yn)(x_0,y_0),\dots,(x_n,y_n)，</p><p> L(x)=∑j=0nyj ℓj(x),ℓj(x)=∏i=0, i≠jnx−xixj−xi.L(x) = \sum_{j=0}^n y_j\,\ell_j(x), \quad \ell_j(x) = \prod_{i=0,\,i\ne j}^n \frac{x - x_i}{x_j - x_i}.</p></li><li><p><strong>牛顿插值</strong><br> 利用差商，</p><p> Pn(x)=f[x0]+f[x0,x1] (x−x0)+⋯+f[x0,…,xn] ∏i=0n−1(x−xi).P_n(x) = f[x_0] + f[x_0,x_1]\,(x-x_0) + \cdots + f[x_0,\dots,x_n]\,\prod_{i=0}^{n-1}(x-x_i).</p></li><li><p><strong>插值余项</strong></p><p> Rn+1(x)=f(x)−Pn(x)=f(n+1)(ξ)(n+1)!∏i=0n(x−xi),ξ∈[a,b].R_{n+1}(x) = f(x) - P_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!} \prod_{i=0}^n (x - x_i),\quad \xi\in[a,b].</p></li></ol><hr><h2 id="第五章：最小二乘拟合"><a href="#第五章：最小二乘拟合" class="headerlink" title="第五章：最小二乘拟合"></a>第五章：最小二乘拟合</h2><ol><li><p><strong>一元线性拟合（直线）</strong><br> 设 y=ax+by = a x + b，构造正则方程：</p><p> {a∑xi2+b∑xi=∑xiyi,a∑xi+nb=∑yi.\begin{cases} a\sum x_i^2 + b\sum x_i = \sum x_i y_i,\ a\sum x_i + nb = \sum y_i. \end{cases}</p></li><li><p><strong>二次多项式拟合</strong><br> 设 y=a0+a1x+a2x2y = a_0 + a_1 x + a_2 x^2，正则方程：</p><p> {na0+(∑xi)a1+(∑xi2)a2=∑yi,(∑xi)a0+(∑xi2)a1+(∑xi3)a2=∑xiyi,(∑xi2)a0+(∑xi3)a1+(∑xi4)a2=∑xi2yi.\begin{cases} n a_0 + (\sum x_i)a_1 + (\sum x_i^2)a_2 = \sum y_i,\ (\sum x_i)a_0 + (\sum x_i^2)a_1 + (\sum x_i^3)a_2 = \sum x_i y_i,\ (\sum x_i^2)a_0 + (\sum x_i^3)a_1 + (\sum x_i^4)a_2 = \sum x_i^2 y_i. \end{cases}</p></li><li><p><strong>加权最小二乘</strong><br> 使加权残差平方和最小：</p><p> min⁡∑iwi(yi−P(xi))2.\min \sum_{i} w_i \bigl(y_i - P(x_i)\bigr)^2.</p></li></ol><hr><p>以上公式皆为 <strong>LaTeX</strong> 标准形式，复制到支持 MathJax 或 LaTeX 渲染的 Markdown 编辑器中即可正确显示。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/C/">C</category>
      
      <category domain="https://blog.tokenlen.top/categories/C/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/18/lastteam/jisuanfangfa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mydb自定义数据库</title>
      <link>https://blog.tokenlen.top/2025/06/12/workmenu/mydb1/</link>
      <guid>https://blog.tokenlen.top/2025/06/12/workmenu/mydb1/</guid>
      <pubDate>Wed, 11 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>项目分为四个主要模块：</p><ul><li>backend：数据库核心功能实现</li><li>client：客户端实现</li><li>transport：网络传输层</li><li>common：公共工具和异常处理</li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>dm/数据管理：实现数据页面的管理和持久化</p><ul><li>DataManager.java：数据管理器接口</li><li>DataManagerImpl.java：数据管理器实现</li><li>PageOne.java：特殊页面，存储元数据</li><li>PageX.java：数据页面</li><li>Logger.java：日志管理</li></ul><p>im/索引管理：实现B+树索引</p><ul><li>BPlusTree.java：B+树实现</li><li>Node.java：B+树节点</li><li>LeafNode.java：叶子节点</li><li>InternalNode.java：内部节点</li></ul><p>tbm/表管理：实现表的创建、删除和管理</p><ul><li>Table.java：表的抽象</li><li>TableManager.java：表管理器接口</li><li>TableManagerImpl.java：表管理器实现</li><li>Field.java：字段定义和管理</li></ul><p>tm/事务管理：实现事务的ACID特性</p><ul><li>ransactionManager.java：事务管理器接口</li><li>TransactionManagerImpl.java：事务管理器实现</li></ul><p>vm/MVCC管理：</p><ul><li>VersionManager.java：版本管理器接口</li><li>VersionManagerImpl.java：版本管理器实现</li><li>Entry.java：数据项</li><li>Transaction.java：事务实现</li></ul><p>parser/sql语句的解析：</p><ul><li>Parser.java：SQL解析器</li><li>Tokenizer.java：词法分析器</li><li>statement/*.java：各类SQL语句的数据结构</li></ul><p>server/服务器功能：</p><ul><li>erver.java：服务器实现</li><li>Executor.java：SQL执行器</li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li>Client.java：客户端实现</li><li>Shell.java：命令行交互</li><li>Launcher.java：启动器</li></ul><h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><ul><li>Package.java：通信包</li><li>Packager.java：包处理器</li><li>Transporter.java：传输器</li></ul><h2 id="公共模块"><a href="#公共模块" class="headerlink" title="公共模块"></a>公共模块</h2><ul><li>Error.java：错误定义</li><li>Config.java：配置管理</li></ul><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="Logger模块"><a href="#Logger模块" class="headerlink" title="Logger模块"></a>Logger模块</h2><p>实现<strong>日志的持久化、校验、读取、校正和截断非法数据</strong>，确保数据库的<strong>崩溃恢复能力（crash recovery）</strong></p><p>日志的文件格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Size(4字节)][Checksum(4字节)][Data(N字节)]</span><br></pre></td></tr></table></figure><p>文件头部还有一个全局 <code>xChecksum</code>（4字节）作为整个日志序列的校验值，存储在文件开头，用于<strong>崩溃恢复期间检查文件是否完整</strong>。</p><div class="table-container"><table><thead><tr><th>位置</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>0-3</td><td>4B</td><td><code>xChecksum</code> 全局校验</td></tr><tr><td>4+</td><td>多条日志</td><td>每条日志如下结构：<code>[Size][Checksum][Data]</code></td></tr></tbody></table></div><p><code>LoggerImpl</code>：核心实现类</p><p><code>Logger</code>：接口 + 工厂方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogEntry`：封装完整日志条目 `[fullBytes, data]</span><br></pre></td></tr></table></figure><p><strong>init方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">headerBuf</span> <span class="operator">=</span> ByteBuffer.allocate(HEADER_SIZE);</span><br><span class="line">fc.position(<span class="number">0</span>);</span><br><span class="line">fc.read(headerBuf);</span><br><span class="line"><span class="built_in">this</span>.xChecksum = Parser.parseInt(headerBuf.array());</span><br><span class="line">validateAndTruncateTail();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先读取 <code>xChecksum</code>，然后进入日志校验逻辑 <code>validateAndTruncateTail()</code>。</p><p><strong>日志校验：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rewind();</span><br><span class="line"><span class="type">int</span> <span class="variable">calcXCheck</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">validEnd</span> <span class="operator">=</span> HEADER_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> readNextLog();</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">    calcXCheck = calChecksum(calcXCheck, entry.fullBytes);</span><br><span class="line">    validEnd += entry.fullBytes.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (calcXCheck != xChecksum) &#123;</span><br><span class="line">    Panic.panic(Error.BadLogFileException);</span><br><span class="line">&#125;</span><br><span class="line">truncate(validEnd);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件头部开始读取每条日志。</p><p>校验每条日志的 <code>checksum</code> 是否匹配。</p><p>若都匹配，则将尾部位置 <code>validEnd</code> 更新为新的合法文件末尾</p><p>如果算出的 <code>calcXCheck</code> 不一致，说明日志文件可能被破坏，抛出异常。否则，<strong>截断非法尾部</strong>。</p><p><strong>log写入：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] logEntry = wrapLog(data);</span><br><span class="line">fc.position(fc.size());</span><br><span class="line">fc.write(ByteBuffer.wrap(logEntry));</span><br><span class="line">updateXChecksum(logEntry);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先计算 data 的 <code>checksum</code></p><p>用 <code>size + checksum + data</code> 拼接为一条日志</p><p>将新的 <code>xChecksum</code> 写入文件头部，用于下次校验。</p><p>读取逻辑：</p><p>先读 <code>[size][checksum]</code> 共 8 字节</p><p>再根据 <code>size</code> 读取 <code>data</code>，并进行校验</p><p>如果不匹配说明日志损坏，返回 null。</p><p><strong>update校验日志：</strong></p><p>设置文件取到文件头，然后写入新的校验和，调用策略接口，执行具体的策略，增加了提示，累计写入数据</p><p>实现了刷盘，采用策略类，实现了同步刷盘，定时异步刷盘，和不刷盘。根据不同的情况进行选择</p><p>用来处理不同的情况。</p><p>定时大小双阈值异步刷盘：</p><p>满足任一条件即可刷盘，提升灵活性与性能保障</p><p>多次 <code>flush()</code> 只设置标志，合并后统一刷盘</p><p>使用原子变量 + <code>synchronized</code> 保证数据一致性</p><p>可通过 <code>shutdown()</code> 停止任务，或动态调整周期</p><p>可通过参数设定周期，如每 100ms 刷一次</p><p>最长可能延迟 <code>flushIntervalMillis</code>，适合非关键日志</p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><p>node节点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B+树节点结构</span></span><br><span class="line"><span class="comment">// [LeafFlag][KeyNumber][SiblingUid] 是头部信息</span></span><br><span class="line"><span class="comment">// 后面是 [Son0][Key0][Son1][Key1]...[SonN][KeyN]</span></span><br><span class="line"><span class="comment">// 每个 son 是一个子节点 UID；key 是关键字。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IS_LEAF_OFFSET</span> <span class="operator">=</span> <span class="number">0</span>;           <span class="comment">// 是否为叶子节点（1字节）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO_KEYS_OFFSET</span> <span class="operator">=</span> IS_LEAF_OFFSET+<span class="number">1</span>;   <span class="comment">// 当前 key 数量（2字节）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIBLING_OFFSET</span> <span class="operator">=</span> NO_KEYS_OFFSET+<span class="number">2</span>;   <span class="comment">// 兄弟节点 UID（8字节）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_HEADER_SIZE</span> <span class="operator">=</span> SIBLING_OFFSET+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BALANCE_NUMBER</span> <span class="operator">=</span> <span class="number">32</span>;          <span class="comment">// 节点最多存储 64 个 key</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_SIZE</span> <span class="operator">=</span> NODE_HEADER_SIZE + (<span class="number">2</span>*<span class="number">8</span>)*(BALANCE_NUMBER*<span class="number">2</span>+<span class="number">2</span>); <span class="comment">// 最大容量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>setRawIsLeaf()</code> / <code>getRawIfLeaf()</code>: 设置/获取是否为叶子节点</li><li><code>setRawNoKeys()</code> / <code>getRawNoKeys()</code>: 设置/获取 key 数</li><li><code>setRawSibling()</code> / <code>getRawSibling()</code>: 设置/获取兄弟节点 UID</li><li><code>setRawKthSon()</code> / <code>getRawKthSon()</code>: 设置/获取第 k 个子节点 UID</li><li><code>setRawKthKey()</code> / <code>getRawKthKey()</code>: 设置/获取第 k 个 key</li><li><code>shiftRawKth()</code>: 从第 k 位右移 key/son，为插入腾位置</li><li><code>copyRawFromKth()</code>: 将后半部分节点数据拷贝出来，用于分裂</li><li><code>newRootRaw()</code>：构造新根节点（中间节点）</li><li><code>newNilRootRaw()</code>：构造空的叶子节点</li></ul><p>读取逻辑：</p><p>boolean isLeaf(): 判断是否为叶子节点</p><p>SearchNextRes searchNext(long key): 在中间节点中<strong>查找适合 key 所在的子节点 UID，如果 key 超过最大 key，则返回 sibling 节点 UID。</strong></p><p>LeafSearchRangeRes leafSearchRange(long leftKey, long rightKey):</p><ul><li>仅在叶子节点中执行，从 leftKey 找到 rightKey 范围内的所有 UID。</li><li>如果未覆盖完全，返回 siblingUid 供上层继续搜索。</li></ul><p>插入分裂逻辑：</p><p>InsertAndSplitRes insertAndSplit(long uid, long key):</p><ul><li>调用 insert() 插入一个键值对 [key, uid]</li><li>若插入后 key 数超限，调用 split() 分裂节点</li></ul><p>内部插入逻辑，根据是叶子节点或内部节点采取不同插入策略：</p><ul><li>叶子节点插入：直接插入 [key, uid]</li><li>中间节点插入：先保存原 key，覆盖当前 key，再右移一位插入 [uid, oldKey]</li></ul><p>节点分裂操作：</p><ul><li>创建新节点并复制后半部分 key/son</li><li>新节点插入 DM 中生成新 UID</li><li>当前节点更新 siblingUid 指向新节点</li><li>返回分裂后新节点和新 key（新 key 是新节点的最小 key</li></ul><p>缓存：</p><p>实现了LRU缓存策略，简单的hashmap+sychronized实现</p><p>和concurrenthashmap+readwirtelock实现</p><p>B+tree索引实现：</p><p>新增 <code>NodeCache</code> 来缓存热点节点，减少频繁磁盘读。</p><p><code>BPlusTree</code> 里新增 <code>loadNode</code> 方法，用缓存优先加载节点。</p><p>联合索引：</p><h1 id="问题文档"><a href="#问题文档" class="headerlink" title="问题文档"></a>问题文档</h1><h2 id="1-”bug”-sql解释器-：修复了sql语句会有-lt-lt-的问题"><a href="#1-”bug”-sql解释器-：修复了sql语句会有-lt-lt-的问题" class="headerlink" title="1.”bug”(sql解释器)：修复了sql语句会有&lt;&lt;的问题"></a>1.”bug”(sql解释器)：修复了sql语句会有&lt;&lt;的问题</h2><p>运行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn exec:java --% -Dexec.mainClass=com.mengnankk.mydatabase.backend.Launcher -Dexec.args=&quot;-create ./data&quot;</span><br><span class="line">mvn exec:java --% -Dexec.mainClass=com.mengnankk.mydatabase.backend.Launcher -Dexec.args=&quot;-open ./data&quot;</span><br><span class="line">mvn exec:java --% -Dexec.mainClass=com.mengnankk.mydatabase.client.Launcher -Dexec.args=&quot;./data&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> ikeife    MYDB   master ≡  ~1     1.602s⠀   mvn exec:java --% -Dexec.mainClass=top.guoziyang.mydb.client.Launcher -Dexec.args=&quot;./data&quot;</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -------------------------&lt; top.guoziyang:MyDB &gt;-------------------------</span><br><span class="line">[INFO] Building MyDB 1.0-SNAPSHOT</span><br><span class="line">[INFO]   from pom.xml</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- exec:3.5.1:java (default-cli) @ MyDB ---</span><br><span class="line">:&gt; create table test1</span><br><span class="line">Invalid command!</span><br><span class="line">:&gt; create table test1;</span><br><span class="line">Invalid statement: create table test1&lt;&lt; ;</span><br><span class="line">:&gt; create table test1 (id int, name varchar);</span><br><span class="line">Invalid statement: create table test1 (id &lt;&lt; int, name varchar);</span><br><span class="line">:&gt; create table test1 (id int);</span><br><span class="line">Invalid statement: create table test1 (id &lt;&lt; int);</span><br><span class="line">:&gt; show tables;</span><br><span class="line">Invalid statement: show tables&lt;&lt; ;</span><br><span class="line">:&gt;</span><br></pre></td></tr></table></figure><p>运行之后这个发现总是多了个&lt;&lt;感觉应该是命令行接收输入或者读取输入流的方式出现了问题。</p><p>第一步：修复SQL解析器（Parser.java）</p><ul><li><p>修改了isType方法，使其能识别标准SQL类型</p></li><li><p>新增了combineType方法，用于处理带括号的类型声明（如varchar(20)）</p></li><li><p>修改了parseCreate方法，改进了类型声明的处理逻辑</p></li><li><p>使索引定义成为可选项，不再强制要求必须有索引</p></li></ul><p>第二步：改进字段类型处理（Field.java）</p><ul><li><p>添加了convertType方法，实现SQL类型到内部类型的映射：</p></li><li><p>改进了typeCheck方法，增加了类型转换步骤</p></li><li><p>修改了Field构造函数，在构造时就进行类型转换</p></li></ul><p>主要解决的问题</p><ul><li><p>支持了标准SQL语法</p></li><li><p>处理了带长度的类型声明（如varchar(20)）</p></li><li><p>实现了SQL类型到内部类型的自动转换</p></li><li><p>修复了索引相关的语法解析</p></li></ul><p>最终效果</p><p>现在可以使用标准SQL语句创建表，也可以不带索引的创建sql语句</p><h2 id="2-”feat”-Server-替换成了NIO，单线程实现IO多路复用"><a href="#2-”feat”-Server-替换成了NIO，单线程实现IO多路复用" class="headerlink" title="2.”feat”(Server): 替换成了NIO，单线程实现IO多路复用"></a>2.”feat”(Server): 替换成了NIO，单线程实现IO多路复用</h2><p>问题在于客户端的Socket创建方式。在NIO模式下，我们需要使用SocketChannel来创建非阻塞的套接字。让我修改客户端的Launcher类：</p><ol><li><p>使用SocketChannel替代Socket</p></li><li><p>配置SocketChannel为非阻塞模式</p></li><li><p>使用connect和finishConnect方法来建立连接</p></li><li><p>添加了连接等待逻辑，因为非阻塞模式下连接可能不会立即完成</p></li><li><p>更新了错误处理逻辑</p></li></ol><h2 id="3-”feat”-Encoder-使用中文的话，使用UTF-8编码"><a href="#3-”feat”-Encoder-使用中文的话，使用UTF-8编码" class="headerlink" title="3.”feat”(Encoder):使用中文的话，使用UTF-8编码"></a>3.”feat”(Encoder):使用中文的话，使用UTF-8编码</h2><ol><li>字符串编码问题</li></ol><ul><li><p>问题表现：中文字符显示为乱码（”锟斤拷”）</p></li><li><p>原因：数据库在处理字符串时没有统一使用UTF-8编码</p></li></ul><p>解决方案：</p><p>在Parser类中修改字符串处理：</p><ul><li><p>使用StandardCharsets.UTF_8进行字符串编码和解码</p></li><li><p>修改string2Byte和parseString方法，确保正确处理UTF-8编码</p></li></ul><p>在DataManagerImpl类中修改数据存储：</p><ul><li><p>在insert方法中确保数据使用UTF-8编码</p></li><li><p>在存储前将数据转换为UTF-8编码的字符串</p></li></ul><p>在Table类中修改数据读取和显示：</p><ul><li><p>在parseEntry方法中确保字符串使用UTF-8编码</p></li><li><p>在entry2Raw方法中确保字符串使用UTF-8编码</p></li><li><p>在printEntry方法中确保字符串使用UTF-8编码</p></li></ul><p>Tokenizer访问权限问题</p><ul><li><p>问题表现：Parser类无法访问Tokenizer类的方法</p></li><li><p>原因：Tokenizer类中的方法访问权限设置不正确</p></li></ul><p>解决方案：</p><ul><li><p>将Tokenizer类中的peek和pop方法改为public</p></li><li><p>添加了isAlphaBeta和isDigit静态方法</p></li><li><p>修复了字符串解析中的边界条件问题</p></li></ul><p>数据存储问题</p><ul><li><p>问题表现：数据存储后读取出现异常</p></li><li><p>原因：数据存储和读取的编码不一致</p></li><li><p>解决方案：</p></li><li><p>统一使用UTF-8编码进行数据存储和读取</p></li><li><p>在数据转换过程中保持编码一致性</p></li><li><p>确保数据在存储前进行正确的编码转换</p></li></ul><p>主要修改点</p><ul><li><p>添加了StandardCharsets.UTF_8的导入</p></li><li><p>在所有涉及字符串操作的地方统一使用UTF-8编码</p></li><li><p>在数据存储、读取和显示三个环节都进行了编码处理</p></li><li><p>确保字符串在转换过程中不会丢失编码信息</p></li><li><p>修改了类的访问权限，确保正确的封装性</p></li><li><p>修复了字符串解析的边界条件问题</p></li></ul><p>经验教训</p><ul><li><p>在处理多语言（特别是中文）时，必须统一使用UTF-8编码</p></li><li><p>需要在数据处理的各个环节（存储、读取、显示）都进行编码处理</p></li><li><p>字符串编码问题往往表现为乱码，需要从数据流转的各个环节排查</p></li><li><p>在数据库系统中，编码问题需要从底层（存储）到上层（显示）都进行统一处理</p></li><li><p>类的访问权限设计需要仔细考虑，确保正确的封装性</p></li><li><p>字符串处理时需要注意边界条件</p></li></ul><h2 id="4-”feat”-bug-异常："><a href="#4-”feat”-bug-异常：" class="headerlink" title="4.”feat”(bug):异常："></a>4.”feat”(bug):异常：</h2><p>1.空指针：</p><p><code>AbstractCache.release(uid)</code> 里从某个 <code>Map</code> 结构中 <code>get(uid)</code> 后没有判空，直接 <code>.intValue()</code> 了。</p><p>加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(uid);</span><br><span class="line"><span class="keyword">if</span>(ref == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Release called on unknown UID: &quot;</span> + uid);</span><br><span class="line">&#125;</span><br><span class="line">ref = ref - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>Map.computeIfPresent()</code> 来减少并发风险，或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">references.compute(uid, (k, v) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Release called on unknown UID: &quot;</span> + uid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.NegativeArraySizeException: -16</p><p>说明你尝试创建一个长度为 <strong>负数</strong> 的数组</p><p><strong>数据文件未完整写入或写入错位</strong></p><ul><li>日志校验失败后仍尝试加载，导致读取偏移错误。</li></ul><p><strong>日志恢复不完整或逻辑错误</strong></p><ul><li>如果你的日志采用 <code>[Size][Checksum][Data]</code> 格式，可能在读取 <code>Size</code> 时读取了非法值（如内存残留数据）。</li></ul><p><strong><code>Parser.parseSize(raw)</code> 实现错误</strong></p><ul><li>可能字节序错、偏移错、字段解码逻辑错。</li></ul><p>添加 <code>size</code> 合法性检查</p><p>那么 <code>Size</code> 是前 4 个字节，你恢复时必须按顺序读</p><p>检查磁盘是否已被写入错位内容，加了边界校验代码。</p><p>3.数据库文件未正确关闭，导致恢复后残留了无效 Entry</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/12/workmenu/mydb1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mydb自定义数据库八股</title>
      <link>https://blog.tokenlen.top/2025/06/12/workmenu/mydb2/</link>
      <guid>https://blog.tokenlen.top/2025/06/12/workmenu/mydb2/</guid>
      <pubDate>Wed, 11 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;项目问题&quot;&gt;&lt;a href=&quot;#项目问题&quot; class=&quot;headerlink&quot; title=&quot;项目问题&quot;&gt;&lt;/a&gt;项目问题&lt;/h1&gt;&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><h2 id="1-在-Mydb-数据库中，日志模块是如何实现崩溃恢复的？请详细说明日志格式、校验机制、写入流程和恢复逻辑，并分析可能存在的性能瓶颈及优化方案。"><a href="#1-在-Mydb-数据库中，日志模块是如何实现崩溃恢复的？请详细说明日志格式、校验机制、写入流程和恢复逻辑，并分析可能存在的性能瓶颈及优化方案。" class="headerlink" title="1.在 Mydb 数据库中，日志模块是如何实现崩溃恢复的？请详细说明日志格式、校验机制、写入流程和恢复逻辑，并分析可能存在的性能瓶颈及优化方案。"></a>1.在 Mydb 数据库中，日志模块是如何实现崩溃恢复的？请详细说明日志格式、校验机制、写入流程和恢复逻辑，并分析可能存在的性能瓶颈及优化方案。</h2><h3 id="日志设计"><a href="#日志设计" class="headerlink" title="日志设计"></a>日志设计</h3><p>redo log:记录事务提交后的数据修改，用于崩溃后重做已提交事务（如数据页修改记录）；</p><p>undo log:记录事务提交前的原始状态，用于回滚未提交事务（如行版本号、旧值）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[全局校验码(4B)][日志条目1][日志条目2]...  </span><br><span class="line">日志条目格式：[条目长度(4B)][校验码(4B)][数据内容(N字节)]  </span><br></pre></td></tr></table></figure><p>日志文件头部 4 字节为全局校验码，每条日志以<code>[4字节长度+4字节校验码+数据]</code>组成。启动时会从头部开始校验每条日志的 checksum，若全局校验码不一致则截断文件尾部。”</p><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>校验</p><ul><li>从文件头部开始读取每条日志，校验单条日志的 checksum；</li><li>累计计算全局校验码，与文件头部校验码比对，不一致则截断文件尾部。</li></ul><p>redo</p><ul><li>扫描日志，提取所有状态为<code>COMMITTED</code>的事务记录；</li><li>按日志顺序重新执行数据修改操作（如更新数据页）。</li></ul><p>undo</p><ul><li>扫描日志，找到状态为<code>ACTIVE</code>或<code>ABORTED</code>的事务；</li><li>根据 Undo 日志恢复数据原始状态（如行版本号回退）。</li></ul><h3 id="日志写入和刷盘"><a href="#日志写入和刷盘" class="headerlink" title="日志写入和刷盘"></a>日志写入和刷盘</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志写入伪代码  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">appendLog</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;  </span><br><span class="line">    <span class="type">byte</span>[] entry = wrapLog(data); <span class="comment">// 封装[长度+校验码+数据]  </span></span><br><span class="line">    fileChannel.position(fileChannel.size());  </span><br><span class="line">    fileChannel.write(ByteBuffer.wrap(entry));  </span><br><span class="line">    updateGlobalChecksum(entry); <span class="comment">// 更新全局校验码  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>刷盘策略：</p><ul><li><strong>同步刷盘（SYNC）</strong>：每条日志写入后立即调用<code>force()</code>刷盘，可靠性高但性能低；</li><li><strong>异步刷盘（ASYNC）</strong>：使用双阈值策略（时间阈值 + 大小阈值）：</li></ul><p>使用一个异步的线程池来实现，满足任一条件即可刷盘，提升灵活性与性能保障</p><p>多次 <code>flush()</code> 只设置标志，合并后统一刷盘</p><p>使用原子变量 + <code>synchronized</code> 保证数据一致性</p><p>可通过 <code>shutdown()</code> 停止任务，或动态调整周期</p><p>可通过参数设定周期，如每 100ms 刷一次</p><p>最长可能延迟 <code>flushIntervalMillis</code>，适合非关键日志</p><p>异步刷盘使用<code>ScheduledThreadPoolExecutor</code>定时检查，当日志缓冲区大小超过 1MB 或距上次刷盘超过 2 秒时，加锁批量刷盘，避免多线程同时操作文件导致的一致性问题。”</p><ul><li><strong>不刷盘（NO_FLUSH）</strong>：仅用于测试，数据可能丢失。</li></ul><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p><strong>同步刷盘导致的 IO 阻塞</strong></p><p>高并发下刷盘成为瓶颈，TPS 下降（如单线程同步刷盘时 TPS≤1000）。</p><ul><li>采用<strong>组提交（Group Commit）</strong>：将多个日志条目批量刷盘（如每 100 条刷一次）；</li><li>引入<strong>内存映射文件（MappedByteBuffer）</strong>，减少用户态到内核态的拷贝。</li></ul><p><strong>异步刷盘的数据一致性风险</strong></p><ul><li>实现<strong>WAL（Write-Ahead Logging）</strong> 机制：事务提交前强制刷盘 Redo 日志；</li><li>增加<strong>刷盘回调机制</strong>：刷盘完成后通知事务提交。</li></ul><p><strong>日志校验的 CPU 开销</strong></p><ul><li>用<strong>CRC32C 算法</strong>替代自定义校验（JDK1.8 <code>java.util.zip.CRC32C</code>，性能提升 3 倍）；</li><li>对热数据日志启用<strong>校验缓存</strong>，避免重复计算。</li></ul><p>日志缓存可将<code>HashMap+ReentrantLock</code>改为<code>ConcurrentHashMap</code>，利用分段锁减少并发竞争。例如，缓存热点日志的校验结果时，读操作无需加锁，写操作仅锁定对应分段。”</p><p><strong>日志分段与归档</strong></p><ul><li>按时间或大小分割日志文件（如每 1GB 一个文件），避免单文件过大；</li><li>归档旧日志文件，定期清理无效日志（如已完成事务的 Undo 日志）。</li></ul><p><strong>异步刷盘策略下，系统崩溃导致 10 秒内的日志丢失（约 5000 条）。</strong></p><ul><li>调整双阈值为<code>大小阈值=1MB</code>+<code>时间阈值=2秒</code>，平衡性能与可靠性；</li><li>关键业务场景强制使用同步刷盘（如资金交易）。</li></ul><h2 id="2-在-Mydb-数据库中，B-树索引是如何实现高效查询和插入的？请详细说明节点结构、查询算法、插入分裂策略，并分析高并发场景下的性能瓶颈及优化方案。"><a href="#2-在-Mydb-数据库中，B-树索引是如何实现高效查询和插入的？请详细说明节点结构、查询算法、插入分裂策略，并分析高并发场景下的性能瓶颈及优化方案。" class="headerlink" title="2.在 Mydb 数据库中，B + 树索引是如何实现高效查询和插入的？请详细说明节点结构、查询算法、插入分裂策略，并分析高并发场景下的性能瓶颈及优化方案。"></a>2.在 Mydb 数据库中，B + 树索引是如何实现高效查询和插入的？请详细说明节点结构、查询算法、插入分裂策略，并分析高并发场景下的性能瓶颈及优化方案。</h2><h3 id="B-树核心结构设计"><a href="#B-树核心结构设计" class="headerlink" title="B + 树核心结构设计"></a>B + 树核心结构设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[叶子标志(1B)][键数量(2B)][兄弟节点UID(8B)][子节点UID/键值对]  </span><br><span class="line">叶子节点：[键<span class="number">1</span>][值<span class="number">1</span>][键<span class="number">2</span>][值<span class="number">2</span>]...[键n][值n]  </span><br><span class="line">非叶子节点：[子节点UID1][键<span class="number">1</span>][子节点UID2][键<span class="number">2</span>]...[子节点UIDn][键n]  </span><br></pre></td></tr></table></figure><ul><li><strong>叶子节点</strong>：存储实际键值对，通过双向链表连接（便于范围查询）；</li><li><strong>非叶子节点</strong>：仅存储键和子节点引用，加速检索。</li><li><strong>扇出（Fan-Out）</strong>：单个节点可容纳的子节点数，由键长和页大小决定（如 8KB 页 + 8B 键 + 8B 引用，扇出≈512）；</li><li><strong>阶数（Order）</strong>：节点的最小子节点数（通常为扇出的 1/2），保证树的平衡。</li></ul><p>B + 树节点包含叶子标志位（1 字节）、键数量（2 字节）、兄弟节点 UID（8 字节），叶子节点存储键值对，非叶子节点存储子节点 UID 和分隔键，通过页结构（如 4KB）组织数据。”</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>非叶子节点</strong>：用二分查找确定子节点方向；</p><p><strong>叶子节点</strong>：顺序遍历键值对（因叶子节点有序，可快速定位）。</p><p><strong>IO 次数</strong>：3 层 B + 树可存储约 1000 万条数据，查询仅需 3 次 IO（页大小 16KB，扇出 1000）；</p><p><strong>内存效率</strong>：非叶子节点仅存储键和引用，内存占用比二叉搜索树低 80%。</p><p>查询时非叶子节点用二分查找确定子节点方向，叶子节点因有序可快速定位，范围查询时通过叶子节点的双向链表遍历，避免全树扫描。</p><h3 id="插入与分裂"><a href="#插入与分裂" class="headerlink" title="插入与分裂"></a>插入与分裂</h3><p>插入</p><ul><li>定位到目标叶子节点，若空间足够则直接插入；</li><li>若空间不足，触发节点分裂。</li></ul><p>分裂逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">splitLeafNode</span><span class="params">(LeafNode node)</span> &#123;  </span><br><span class="line">    <span class="type">LeafNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafNode</span>();  </span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> node.keyCount / <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">// 复制后半部分键值对到新节点  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid; i &lt; node.keyCount; i++) &#123;  </span><br><span class="line">        newNode.insert(node.keys[i], node.values[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    node.keyCount = mid;  </span><br><span class="line">    <span class="comment">// 连接兄弟节点  </span></span><br><span class="line">    newNode.sibling = node.sibling;  </span><br><span class="line">    node.sibling = newNode.uid;  </span><br><span class="line">    <span class="comment">// 向父节点插入新节点引用  </span></span><br><span class="line">    insertIntoParent(node, newNode.smallestKey, newNode.uid);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><strong>分裂点</strong>：取节点中键的中间位置，前半部分保留，后半部分放入新节点；</li><li><strong>父节点更新</strong>：父节点插入新节点的最小键和 UID，若父节点也满则递归分裂。</li></ul><p>分裂时将节点后半部分数据移至新节点，新节点的兄弟<strong>指针指向原节点的兄弟</strong>，<strong>原节点的兄弟指针指向新节点</strong>，并向父节点插入新节点的最小键和 UID，若父节点已满则递归分裂。</p><p>插入 / 分裂时仅锁定目标节点,ReentrantLock.</p><h3 id="性能问题-1"><a href="#性能问题-1" class="headerlink" title="性能问题"></a>性能问题</h3><p><strong>节点锁竞争</strong></p><p>高并发插入时，多个线程争夺同一节点锁，导致吞吐量下降（如 1000TPS 时下降至 300TPS）</p><ul><li>分层锁（Locking Hierarchy）：<ul><li>非叶子节点用<code>ReadWriteLock</code>，读操作共享锁，写操作排他锁；</li><li>叶子节点用<code>ReentrantLock</code>，支持可重入和公平锁模式。</li></ul></li><li><p>使用乐观锁：</p></li><li><p>```java<br>boolean casInsert(Node node, long expectedVersion) {  </p><pre><code>if (node.version != expectedVersion) return false;  // 插入操作...  node.version++;  return true;  </code></pre><p>}  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**缓存失效与 IO 风暴**</span><br><span class="line"></span><br><span class="line">大量随机插入导致 B + 树重组，缓存命中率下降（如从 90% 降至 50%）。</span><br><span class="line"></span><br><span class="line">- **节点预读（Read-Ahead）**：查询时预判下一层节点，提前加载到缓存；</span><br><span class="line">- **冷热数据分离**：用`LRU缓存`存储热点节点，冷节点定期淘汰（如最近 10 分钟未访问的节点）。LRU可以使用hashmap+reentrantlock或者使用更加精细的concurrenthashmap+readwritrlock</span><br><span class="line"></span><br><span class="line">**范围查询性能衰减**</span><br><span class="line"></span><br><span class="line">大范围查询时遍历叶子链表，导致 CPU 占用过高（如查询 10 万条记录时 CPU 占比 100%）。</span><br><span class="line"></span><br><span class="line">- **批量读取（Batch Read）**：一次读取多个页（如 16 个页），减少 IO 次数；</span><br><span class="line">- **异步查询（Async Query）**：将大范围查询放入单独线程池，避免阻塞业务线程：</span><br><span class="line"></span><br><span class="line">### 优化</span><br><span class="line"></span><br><span class="line">**写入优化：批量插入与合并分裂**</span><br><span class="line"></span><br><span class="line">- **批量插入**：将多个插入操作合并为一批，减少分裂次数（如每 1000 条插入后统一分裂）；</span><br><span class="line">- **分裂合并**：当相邻节点利用率低于 50% 时，合并节点以减少树高。</span><br><span class="line"></span><br><span class="line">**索引覆盖与前缀索引**</span><br><span class="line"></span><br><span class="line">- **索引覆盖**：设计索引时包含查询所需全部字段，避免回表（如`SELECT id,name FROM table WHERE id&gt;100`）；</span><br><span class="line">- **前缀索引**：对长字符串取前缀建立索引（如取 URL 前 100 字节），减少索引体积。</span><br><span class="line"></span><br><span class="line">**监控与调优指标**</span><br><span class="line"></span><br><span class="line">节点锁等待时间（理想≤1ms）；</span><br><span class="line"></span><br><span class="line">缓存命中率（理想≥95%）；</span><br><span class="line"></span><br><span class="line">平均 IO 次数（理想≤3 次 / 查询）。</span><br><span class="line"></span><br><span class="line">调优工具：</span><br><span class="line"></span><br><span class="line">- 用`JProfiler`监控索引操作热点方法；</span><br><span class="line">- 用`BTrace`追踪节点锁竞争场景。</span><br><span class="line"></span><br><span class="line">**电商大促时，商品索引插入性能骤降，导致订单创建延迟从 50ms 升至 500ms。**</span><br><span class="line"></span><br><span class="line">高并发插入导致 B + 树频繁分裂，节点锁竞争激烈。</span><br><span class="line"></span><br><span class="line">- 启用**写入限流**（如每秒最多 1 万次插入），超出则返回 “系统繁忙”；</span><br><span class="line">- 采用**分段 B + 树**：按商品 ID 哈希分为 16 段，每段独立索引，减少锁冲突；</span><br><span class="line">- 大促前预扩容索引，预留 30% 空间（如初始扇出 512，大促时调整为 358）。</span><br><span class="line">- 高并发插入时，可采用写入分组（如按 UID 哈希分 16 组，每组独立索引），配合令牌桶限流（如每组每秒 1000 次插入），减少节点锁竞争；同时用乐观锁（CAS）避免频繁加锁。</span><br><span class="line"></span><br><span class="line">## 3.在 Mydb 数据库中，如何实现事务的 ACID 特性？请详细说明事务日志（Redo/Undo）、锁机制、MVCC 的作用，并分析高并发场景下的脏读、不可重复读、幻读解决方案。</span><br><span class="line"></span><br><span class="line">### ACID</span><br><span class="line"></span><br><span class="line">- **原子性（Atomicity）**：通过 Undo 日志记录事务前状态，回滚时恢复；</span><br><span class="line">- **一致性（Consistency）**：通过 Redo+Undo 共同保证（Redo 重做已提交事务，Undo 回滚未提交事务）；</span><br><span class="line">- **持久性（Durability）**：Redo 日志刷盘后，即使崩溃也能恢复数据；</span><br><span class="line">- **隔离性（Isolation）**：通过 MVCC + 锁机制实现不同隔离级别。</span><br><span class="line"></span><br><span class="line">事务提交时，先写 Undo 日志记录旧值，再写 Redo 日志记录新值，最后刷盘 Redo 日志（WAL 原则），确保崩溃后 Redo 已提交事务，Undo 回滚未提交事务。</span><br><span class="line"></span><br><span class="line">### MVCC</span><br><span class="line"></span><br><span class="line">“MVCC 通过版本号（或时间戳）实现快照读：</span><br><span class="line"></span><br><span class="line">1. 事务启动时记录当前最大活跃事务 ID（max_trx_id）；</span><br><span class="line">2. 读取数据时，若数据版本号 &lt; 当前事务 ID 且不在活跃事务列表中，可读；</span><br><span class="line">3. 若数据版本号 &gt;= max_trx_id，不可见</span><br><span class="line">3. 数据版本号在活跃事务id里面，不可见</span><br><span class="line">4. MVCC 通过快照读避免锁竞争，适合读多写少场景（如报表查询）；锁机制适合写多场景（如订单扣款），需根据业务场景选择。”</span><br><span class="line"></span><br><span class="line">隔离级别：</span><br><span class="line"></span><br><span class="line">- **读已提交（RC）**：每次查询加行级锁，读完释放，避免脏读；</span><br><span class="line">- **可重复读（RR）**：查询加快照读（MVCC），更新加行级锁 + 间隙锁，避免不可重复读和幻读；</span><br><span class="line">- **串行化（Serializable）**：全表加锁，串行执行。</span><br><span class="line"></span><br><span class="line">## 4.在 “MinaDB - 自研轻量级数据库系统” 项目里，你实现了基于 Java NIO 的数据页读写管理模块，提升了 3 倍访问效率，讲讲 Java NIO 是咋在这个模块里发挥作用的，和传统 I/O 相比，具体优化点在哪呀？</span><br><span class="line"></span><br><span class="line">BIO 与 NIO 的区别：</span><br><span class="line"></span><br><span class="line">**BIO（Blocking I/O）**：每个请求需要一个线程处理，线程阻塞在 I/O 操作上，连接数一多就容易造成线程资源耗尽，系统响应慢。</span><br><span class="line"></span><br><span class="line">**NIO（Non-blocking I/O）**：通过 **Selector + Channel + Buffer** 实现多路复用，单线程可监听多个 Channel，避免大量线程阻塞等待，提高了资源利用率。</span><br><span class="line"></span><br><span class="line">NIO 工作机制：</span><br><span class="line"></span><br><span class="line">- 客户端连接通过 `ServerSocketChannel` 接收；</span><br><span class="line">- 每个 `Channel` 注册到 `Selector` 上，监听感兴趣的事件（如 `READ`、`WRITE`）；</span><br><span class="line">- Selector 使用 `select()` **非阻塞轮询**就绪事件；</span><br><span class="line">- 当某个 Channel 有事件到达，就通过 `Buffer` 读写数据，由工作线程处理请求。</span><br><span class="line"></span><br><span class="line">这种模型的优势是：**少量线程可处理高并发请求**，适合 I/O 密集型场景。</span><br><span class="line"></span><br><span class="line">数据库应用：</span><br><span class="line"></span><br><span class="line">数据库系统天然是多并发场景，传统 BIO 每个连接对应一个线程，会造成线程浪费甚至上下文切换频繁；</span><br><span class="line"></span><br><span class="line">使用 NIO 模型后，我们**采用 Reactor 模式**，用**一个主线程监听所有连接事件**，用线程池异步处理真正的读写请求；</span><br><span class="line"></span><br><span class="line">每个客户端连接通过 Channel 注册到 Selector 上，提升了连接并发处理能力；</span><br><span class="line"></span><br><span class="line">底层页式读写通过 Buffer 显著减少了系统调用次数和数据拷贝成本，提高了磁盘 I/O 效率。</span><br><span class="line"></span><br><span class="line">并发控制说明：</span><br><span class="line"></span><br><span class="line">因为是数据库系统，多用户可能同时对同一数据页进行访问；</span><br><span class="line"></span><br><span class="line">在读写路径上，我们结合了**读写锁**机制和自实现的**MVCC（多版本并发控制）**，确保事务隔离的一致性；</span><br><span class="line"></span><br><span class="line">NIO 负责连接层的高效事件处理，MVCC 负责数据访问层的并发安全。</span><br><span class="line"></span><br><span class="line">## 5.在 “MinaDB” 项目中，你提到实现了基于 B + 树的索引结构，说说 B + 树相比 B 树在索引场景下的优势？如果数据库中某个表的查询频繁出现 “索引失效”，你会从哪些方面排查原因？</span><br><span class="line"></span><br><span class="line">B 树的非叶子节点同时存储索引键和数据行指针，而 B + 树非叶子节点仅存储索引键，相同空间可存储更多索引项，查询时 IO 次数更少。此外，B 树查询到数据后直接返回，而 B + 树需遍历到叶子节点，看似多一层，但 B + 树叶子节点数据更紧凑，且磁盘预读特性下，连续的叶子节点访问效率反而更高。</span><br><span class="line"></span><br><span class="line">索引失效一般都是不满足联合索引未满足最左前缀原则，</span><br><span class="line"></span><br><span class="line">比如，使用or前面的有索引，后面的没索引。</span><br><span class="line"></span><br><span class="line">使用了like模糊匹配，在查询的使用了函数或者运算</span><br><span class="line"></span><br><span class="line">没有遵守联合查询的最左匹配</span><br><span class="line"></span><br><span class="line">进行了索引跳跃</span><br><span class="line"></span><br><span class="line">还有**数据类型不匹配**：如索引列是`varchar`，查询时未加引号导致隐式转换</span><br><span class="line"></span><br><span class="line">**统计信息过时**：表数据大量更新后未重建索引或 analyze 表，优化器误判索引效率</span><br><span class="line"></span><br><span class="line">## 6.在 “MinaDB” 项目中，你实现了 SQL 解析器模块，将 SQL 语句转换为执行计划。如果遇到复杂查询（如多表 JOIN、子查询），解析器是如何处理语法树构建和优化的？有没有遇到过解析错误的场景，是如何调试和解决的？</span><br><span class="line"></span><br><span class="line">普通分析：</span><br><span class="line"></span><br><span class="line">整个sql解析过程分为三个阶段：</span><br><span class="line"></span><br><span class="line">词法分析：：：：</span><br><span class="line"></span><br><span class="line">我们使用正则表达式 + 手写有限状态机（手写有限状态机就是用代码明确写出“当前状态 + 输入 → 转移 + 处理”的逻辑流程）实现了一个轻量级的词法分析器，将输入 SQL 拆分成 Token 序列（如关键字、标识符、常量、运算符等）。每个 Token 类型都有枚举定义，便于后续语法分析器使用。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[SELECT] [IDENT(name)] [FROM] [IDENT(users)] [WHERE] [IDENT(age)] [&gt;] [NUMBER(18)]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">语法分析：：：：</span><br><span class="line"></span><br><span class="line">我们基于递归下降（Recursive Descent）实现了手写语法分析器，根据文法规则（Backus-Naur Form）构建**抽象语法树**（AST）。</span><br><span class="line"></span><br><span class="line">例如 `SELECT-FROM-WHERE` 子句会被解析为如下结构：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SelectNode<br>├── Projection: [name]<br>├── From: TableNode(“users”)<br>└── Filter: BinaryExpr(age &gt; 18)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">逻辑执行计划生成：：：：</span><br><span class="line"></span><br><span class="line">AST 会被转化为内部统一表示的 **LogicalPlan**，包括 `Scan`, `Filter`, `Project`, `Join`, `Aggregate` 等操作节点。这个计划结构便于后续执行器调度和优化器优化。</span><br><span class="line"></span><br><span class="line">多表查询：</span><br><span class="line"></span><br><span class="line">**JOIN 查询**</span><br><span class="line"></span><br><span class="line">当语法分析器检测到 `JOIN` 或 `LEFT JOIN` 等关键字时，会构建一个 `JoinNode`，将左右子表作为子节点，同时捕获 `ON` 条件表达式作为连接条件。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SELECT * FROM A JOIN B ON A.id = B.a_id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">构建的AST为</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JoinNode<br>├── Left: TableScan(“A”)<br>├── Right: TableScan(“B”)<br>└── Condition: A.id = B.a_id</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此结构可以支持后续优化器决定使用嵌套循环连接（Nested Loop Join）还是哈希连接（Hash Join）。</span><br><span class="line"></span><br><span class="line">**子循环嵌套**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SELECT name FROM users WHERE id IN (SELECT user_id FROM orders)<br>```</p><p>这种情况，解析器会递归调用自身处理内部子 SELECT，并将其嵌套成 <code>SubqueryExpr</code>，插入到父语句的 WHERE 条件表达式树中。</p><p>异常处理:</p><p>如关键字拼写错误、括号不匹配、非法表达式等，解析器通过异常机制抛出带位置信息的错误，并记录 Token 序列以便定位。</p><p>调试方式：</p><ul><li>打印词法 Token 序列</li><li>可视化 AST 结构（使用简易 tree dump 工具）</li><li>增加行列号定位信息</li></ul><p>曾遇到过解析器处理 SQL 文件时出现乱码，调查后发现部分文件编码为 GBK，解析器默认以 UTF-8 解读导致失败。解决方法是在读取输入流时统一使用 UTF-8 编码，并在 SQL 入口统一处理 BOM 头和非法字符替换。</p><p>错误恢复机制</p><p>在早期版本中，解析器一旦遇错就直接中断，影响批量 SQL 执行。后来加入了简单的错误恢复机制，例如：</p><ul><li>跳过非法 Token，尝试恢复到下一个合法语句起点（如分号 <code>;</code>）</li><li>将错误信息记录而不立即终止，提高系统健壮性</li></ul><h2 id="7-你如何实现-MVCC-和-2PL，两者如何配合确保事务隔离性？"><a href="#7-你如何实现-MVCC-和-2PL，两者如何配合确保事务隔离性？" class="headerlink" title="7.你如何实现 MVCC 和 2PL，两者如何配合确保事务隔离性？"></a>7.你如何实现 MVCC 和 2PL，两者如何配合确保事务隔离性？</h2><p>我们结合了<strong>MVCC</strong> 和 <strong>两阶段锁协议（2PL）</strong> 来实现并发控制和事务隔离。</p><ul><li><strong>MVCC：\</strong>为每条记录维护多个版本（写入时间戳 + 删除时间戳），读操作基于事务启动时的快照时间戳进行*<em>可见性判断*</em>，避免读写冲突。</li><li><strong>2PL：</strong>所有写操作必须获得写锁，锁管理器基于图结构维护加锁顺序，确保无冲突的串行调度。</li><li><strong>两者配合：</strong><ul><li><strong>读操作走 MVCC，非阻塞（Snapshot Read）</strong></li><li><strong>写操作基于 2PL 上锁（Exclusive Lock）</strong></li><li>事务提交前统一写日志 + 写入版本链</li><li>可配置事务隔离级别（Read Committed, Repeatable Read）</li></ul></li></ul><p>这种设计兼顾了<strong>高并发读性能（通过 MVCC）\</strong>与*<em>写入一致性保证（通过 2PL）*</em>，可以支持 SQL 标准的事务隔离模型。</p><h2 id="8-你实现的是哪种死锁检测方式？如何中止事务？"><a href="#8-你实现的是哪种死锁检测方式？如何中止事务？" class="headerlink" title="8.你实现的是哪种死锁检测方式？如何中止事务？"></a>8.你实现的是哪种死锁检测方式？如何中止事务？</h2><p>我们实现的是基于<strong>等待图（Wait-For Graph）</strong>的死锁检测机制：</p><ul><li>每次事务申请锁失败时，记录依赖关系 T1 → T2</li><li>定期运行死锁检测器，对等待图进行<strong>有向环检测</strong></li><li>一旦发现环，选择<strong>最小代价事务（如等待时间短、操作数少）回滚中止</strong></li><li>通知锁管理器释放锁资源，唤醒相关等待事务</li></ul><p>这种方式可以有效防止系统进入<strong>长时间互相等待状态</strong>，尤其在高并发写场景下非常关键。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/12/workmenu/mydb2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数字逻辑期末复习</title>
      <link>https://blog.tokenlen.top/2025/06/11/lastteam/shuziluoji/</link>
      <guid>https://blog.tokenlen.top/2025/06/11/lastteam/shuziluoji/</guid>
      <pubDate>Tue, 10 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;知识点分布&quot;&gt;&lt;a href=&quot;#知识点分布&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="知识点分布"><a href="#知识点分布" class="headerlink" title="知识点分布"></a>知识点分布</h1><p>计算：</p><p>1.进制转换</p><p>10进制，8进制，16进制，20进制</p><p>2.源码反码补码</p><p>3.余三码</p><p>4.公式运用转换</p><p>化简，卡诺图，公式</p><p>数字逻辑</p><p>两个简答，三个计算二进制转8 10 16饭吗不拿 雨伞吗</p><p>化简</p><p>函数化简，标准语或表达式</p><p>卡诺图化简</p><p>组合逻辑电路分析</p><p>函数逻辑表达，nc图，功能</p><p>隐含表</p><p>状态化简</p><p>时序逻辑电路，什么型的</p><p>死胎针指标</p><p>状态相应队列</p><h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><p><strong>与非门/或非门型R-S触发器差异</strong></p><p><strong>同步与异步时序电路对比</strong></p><p><strong>组合与时序逻辑区别</strong></p><p><strong>逻辑函数三种描述方式（真值表、代数表达式、卡诺图）</strong></p><p><strong>卡诺图化简步骤与规则</strong></p><h2 id="1-根据所采用的半导体器件不同，集成电路可分为哪两大类？各自的主要优缺点是什么。"><a href="#1-根据所采用的半导体器件不同，集成电路可分为哪两大类？各自的主要优缺点是什么。" class="headerlink" title="1.根据所采用的半导体器件不同，集成电路可分为哪两大类？各自的主要优缺点是什么。"></a>1.根据所采用的半导体器件不同，集成电路可分为哪两大类？各自的主要优缺点是什么。</h2><p>根据所采用的半导体器件不同，集成电路可分为两大类：一类是采用双极型半导体器件作为元件的<strong>双极型集成电路</strong>；双极型集成电路的主要特点是<strong>速度快、负载能力强，但功耗较大，集成度较低；</strong></p><p>另一类是采用金属-氧化物-半导体场效应管作为元件的单极型集成电路，又称MOS集成电路。MOS集成电路的特点是<strong>结构简单、制造方便、集成度高、功耗低，但速度较慢。</strong></p><h2 id="2-简述晶体二极管的静态特性"><a href="#2-简述晶体二极管的静态特性" class="headerlink" title="2.简述晶体二极管的静态特性"></a>2.简述晶体二极管的静态特性</h2><p>1.<strong>正向特性</strong> ：</p><p>正向电压 UF ≤ UTH ：管子截止，电阻很大、正向电流IF 接近于 0， 二极管类似于开关的断开状态 ；正向电压 UF= UTH ：管子开始导通，正向电流IF开始上<br>升；正向电压 UF ＞ UTH (一般锗管为0.3V，硅管为0.7V) ：管子充分导通，电阻很小，正向电流IF急剧增加，二极管类似于开关的接通状态。<br>2． <strong>反向特性</strong>：<br>二极管在反向电压UR作用下，处于截止状态，反向电阻很大，反向电流IR很小（将其称为反向饱和电流，用IS表示，通常可忽略不计），二极管的状态类似于开关断开。而且反向电压在一定范围内变化基本不引起反向电流的变化。</p><h2 id="3-晶体二极管的开关速度主要取决于什么？"><a href="#3-晶体二极管的开关速度主要取决于什么？" class="headerlink" title="3.晶体二极管的开关速度主要取决于什么？"></a>3.晶体二极管的开关速度主要取决于什么？</h2><p>晶体二极管的动态特性是指二极管在<strong>导通与截至</strong>两种状态转换过程中的特性，它表现在完成两种状态之间的转换需要一定的时间。通常把二极管从<strong>正向导通到反向截至所需要的时间称为反向恢复时间，而把二极管从反向截至到正向导通的时间称为开通时间。</strong>相比之下，<strong>开通时间很短</strong>，一般可以忽略不计。因此，晶体二极管的开关速度主要取决于反向恢复时间。</p><h2 id="4-数字电路中，晶体三极管一般工作在什么状态-？"><a href="#4-数字电路中，晶体三极管一般工作在什么状态-？" class="headerlink" title="4.数字电路中，晶体三极管一般工作在什么状态 ？"></a>4.数字电路中，晶体三极管一般工作在什么状态 ？</h2><p>在数字电路中，晶体三极管被作为开关元件一般工作在<strong>饱和与截至</strong>两种状态，相当于一个由基极信号控制的无触点开关，其作用对应于触点开关的“闭合”与“断开”</p><h2 id="5-晶体三极管的开关速度取决于哪些因素？为什么MOS管的开关速度比晶体三极管慢-？"><a href="#5-晶体三极管的开关速度取决于哪些因素？为什么MOS管的开关速度比晶体三极管慢-？" class="headerlink" title="5.晶体三极管的开关速度取决于哪些因素？为什么MOS管的开关速度比晶体三极管慢 ？"></a>5.晶体三极管的开关速度取决于哪些因素？为什么MOS管的开关速度比晶体三极管慢 ？</h2><p>开通时间ton和关闭时间toff是影响电路工作速度的主要因素。由于MOS管导通时的漏源电阻rDS比晶体三极管的饱和电阻rCES要大得多，漏极外接电阻RD也比晶体管集电极电阻RC大，所以，MOS管的充、放电时间较长，使MOS管的开关速度比晶体三极管的开关速度低。</p><h2 id="6-TTL与非门有哪些主要性能参数？"><a href="#6-TTL与非门有哪些主要性能参数？" class="headerlink" title="6.TTL与非门有哪些主要性能参数？"></a>6.TTL与非门有哪些主要性能参数？</h2><p>(1) 输出高电平VOH<br>(2) 输出低电平VOL<br>(3)开门电平VON 开门电平的大小反映了高电平抗干扰能力，VON 愈小，<br>在输入高电平时的抗干扰能力愈强。<br>(4)关门电平VOFF ：关门电平的大小反映了低电平抗干扰能力，VOFF越大，<br>在输入低电平时的抗干扰能力越强。<br>(5) 扇入系数Ni<br>(6) 扇出系数No<br>(7) 输入短路电流Iis<br>(8) 高电平输入电流Iih<br>(9) 平均传输延迟时间tpd<br>(10) 空载功耗P</p><h2 id="7-OC门和TS门的结构与一般TTL与非门有何不同？各有何主要应用-？"><a href="#7-OC门和TS门的结构与一般TTL与非门有何不同？各有何主要应用-？" class="headerlink" title="7.OC门和TS门的结构与一般TTL与非门有何不同？各有何主要应用 ？"></a>7.OC门和TS门的结构与一般TTL与非门有何不同？各有何主要应用 ？</h2><p>集电极开路门(Open Collector Gate)是一种输出端可以直接相互连接的特殊逻辑门，简称OC门。OC门电路将一般TTL与非门电路的推拉式输出级改为三极管集电极开路输出。集电极开路与非门在计算机中应用很广泛，可以用它实现”线与”逻辑、电平转换以及直接驱动发光二极管、干簧继电器等。三态输出门有三种输出状态：输出高电平、输出低电平和高阻状态，前两种状态为工作状态，后一种状态为禁止状态三态与非门主要应用于总线传送，它既可用于单向数据送，也可用于双向数据传送。</p><h2 id="8-简述时序逻辑电路与组合逻辑电路的区别（重点）"><a href="#8-简述时序逻辑电路与组合逻辑电路的区别（重点）" class="headerlink" title="8.简述时序逻辑电路与组合逻辑电路的区别（重点）"></a>8.简述时序逻辑电路与组合逻辑电路的区别（重点）</h2><p>时序逻辑电路在<strong>任何时刻产生的稳定输出信号不仅与该时刻电路的输入信号有关，而且与电路过去的输入信号有关</strong>；而组合逻辑电路仅仅与<strong>该时刻电路的输入信号</strong>有关。</p><h2 id="9-有两个相同型号的TTL与非门，对它们进行测试的结果如下："><a href="#9-有两个相同型号的TTL与非门，对它们进行测试的结果如下：" class="headerlink" title="9.有两个相同型号的TTL与非门，对它们进行测试的结果如下："></a>9.有两个相同型号的TTL与非门，对它们进行测试的结果如下：</h2><p>（1）甲的开门电平为1.4V，乙的开门电平为1.5V ；<br>（2）甲的关门电平为1.0V，乙的开门电平为0.9V ；</p><p>试问在输入相同的高电平时，哪个抗干扰能力强？在输入相同低电平时，哪个抗干扰能力强？</p><p>对于TTL与非门来说，<strong>开门电平愈小，输入高电平时的抗干扰能力愈强</strong>；关<strong>门电平愈大，在输入低电平时抗干扰能力愈强</strong>。因此，在两种情况下，均是甲的抗干扰能力强。</p><h2 id="10-用与非门组成的基本R-S触发器和用或非门组成的基本R-S触发器在逻辑功能上有什么区别？（重点）"><a href="#10-用与非门组成的基本R-S触发器和用或非门组成的基本R-S触发器在逻辑功能上有什么区别？（重点）" class="headerlink" title="10.用与非门组成的基本R-S触发器和用或非门组成的基本R-S触发器在逻辑功能上有什么区别？（重点）"></a>10.用与非门组成的基本R-S触发器和用或非门组成的基本R-S触发器在逻辑功能上有什么区别？（重点）</h2><div class="table-container"><table><thead><tr><th>项目</th><th>用 NAND（与非门）实现</th><th>用 NOR（或非门）实现</th></tr></thead><tbody><tr><td>构成门电路</td><td>与非门（NAND）</td><td>或非门（NOR）</td></tr><tr><td>电路图形态</td><td>输入为低电平触发</td><td>输入为高电平触发</td></tr></tbody></table></div><p>或与门:</p><p>看的是S的置位</p><div class="table-container"><table><thead><tr><th>R</th><th>S</th><th>Q(n+1)</th><th>功能说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Q</td><td>保持</td></tr><tr><td>0</td><td>1</td><td>1</td><td>置 1（Set）</td></tr><tr><td>1</td><td>0</td><td>0</td><td>置 0（Reset）</td></tr><tr><td>1</td><td>1</td><td>不定</td><td>无效（禁止）</td></tr></tbody></table></div><p>与非门：</p><p>看的是R置位</p><div class="table-container"><table><thead><tr><th>R</th><th>S</th><th>Q(n+1)</th><th>功能说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>不定</td><td>无效（禁止）</td></tr><tr><td>0</td><td>1</td><td>0</td><td>置 0（Reset）</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置 1（Set）</td></tr><tr><td>1</td><td>1</td><td>Q</td><td>保持</td></tr></tbody></table></div><p><strong>或非门 NOR 高电平有效”，“与非门 NAND 低电平有效</strong></p><h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><h2 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h2><p>十进制 123 转为八进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123 ÷ 8 = 15 余 3  </span><br><span class="line">15 ÷ 8 = 1 余 7  </span><br><span class="line">1 ÷ 8 = 0 余 1  </span><br><span class="line"></span><br><span class="line">倒序结果：173（八进制）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>十进制 123 转为十六进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 ÷ 16 = 7 余 11 → B  </span><br><span class="line">7 ÷ 16 = 0 余 7  </span><br><span class="line"></span><br><span class="line">倒序结果：7B（十六进制）</span><br></pre></td></tr></table></figure><p>就是除，然后倒叙的写余数。</p><p>然后小数部分，就是乘然后取整数部分</p><p>0.27 转八进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0.27 × 8 = 2.16      → 取整 2  </span><br><span class="line">0.16 × 8 = 1.28      → 取整 1  </span><br><span class="line">0.28 × 8 = 2.24      → 取整 2  </span><br><span class="line">0.24 × 8 = 1.92      → 取整 1  </span><br><span class="line">0.92 × 8 = 7.36      → 取整 7  </span><br><span class="line">0.36 × 8 = 2.88      → 取整 2  </span><br><span class="line">0.88 × 8 = 7.04      → 取整 7  </span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0.27≈0.2121727</p><h2 id="2-源码反码补码"><a href="#2-源码反码补码" class="headerlink" title="2.源码反码补码"></a>2.源码反码补码</h2><div class="table-container"><table><thead><tr><th>表示形式</th><th>正数</th><th>负数</th></tr></thead><tbody><tr><td>原码</td><td>符号位为0，数值位正常</td><td>符号位为1，数值位绝对值</td></tr><tr><td>反码</td><td>同原码</td><td>符号位为1，数值位按位取反</td></tr><tr><td>补码</td><td>同原码</td><td>反码 + 1</td></tr></tbody></table></div><p>十进制 -5 的表示（8位）</p><p>原码：<code>10000101</code></p><p>反码：<code>11111010</code>（符号位不变，数值部分取反）</p><p>补码：<code>11111011</code>（反码 +1）</p><p>0.1011 的源码反码补码：</p><p>0.1011都一样</p><p>－10110的源码反码补码：</p><p>110110</p><p>101001</p><p>101010</p><h2 id="3-各种编码"><a href="#3-各种编码" class="headerlink" title="3.各种编码"></a>3.各种编码</h2><p>BCD码：将十进制的<strong>每位分别转换为4位二进制</strong>（例如 9 → 1001）</p><p>余三码：= BCD码 + 0011</p><div class="table-container"><table><thead><tr><th>十进制</th><th>BCD (8421)</th><th>余三码</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td>0011</td></tr><tr><td>5</td><td>0101</td><td>1000</td></tr><tr><td>9</td><td>1001</td><td>1100</td></tr></tbody></table></div><p>余三码 → 减去 0011 → BCD → 十进制</p><p>2421码：<strong>十进制数字 0~9</strong> 编码为 4 位二进制</p><div class="table-container"><table><thead><tr><th>十进制</th><th>2421码（权值分别为 2-4-2-1）</th></tr></thead><tbody><tr><td>0</td><td>0000</td></tr><tr><td>1</td><td>0001</td></tr><tr><td>2</td><td>0010</td></tr><tr><td>3</td><td>0011</td></tr><tr><td>4</td><td>0100</td></tr><tr><td>5</td><td>1011</td></tr><tr><td>6</td><td>1100</td></tr><tr><td>7</td><td>1101</td></tr><tr><td>8</td><td>1110</td></tr><tr><td>9</td><td>1111</td></tr></tbody></table></div><p>Gray码：</p><p><strong>相邻两个数的编码只有一位不同</strong>，这也叫做 <strong>最小汉明距离编码</strong>。</p><p>十进制 <code>7</code> → 二进制：<code>0111</code></p><p>G0 = B0 （最高位相同）首位不变，其异或<br>Gi = Bi XOR B(i−1)（从第1位开始，每一位 = 当前位 XOR 前一位）</p><p>Gray 码计算：</p><ul><li>G0 = B0 = 0</li><li>G1 = B1 ⊕ B0 = 1 ⊕ 0 = 1</li><li>G2 = B2 ⊕ B1 = 1 ⊕ 1 = 0</li><li>G3 = B3 ⊕ B2 = 1 ⊕ 1 = 0</li></ul><p>Gray码为0100</p><h2 id="4-二进制运算"><a href="#4-二进制运算" class="headerlink" title="4.二进制运算"></a>4.二进制运算</h2><p>加法：<strong>规则</strong>（逢二进一）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 + 0 = 0  </span><br><span class="line">0 + 1 = 1  </span><br><span class="line">1 + 0 = 1  </span><br><span class="line">1 + 1 = 0 （进位1）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>减法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 - 0 = 0  </span><br><span class="line">1 - 0 = 1  </span><br><span class="line">1 - 1 = 0  </span><br><span class="line">0 - 1 = 1（向高位借1）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>乘法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   101   (5)</span><br><span class="line">×   11   (3)</span><br><span class="line">-------</span><br><span class="line">   101</span><br><span class="line">+ 1010</span><br><span class="line">-------</span><br><span class="line">  1111  (15)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1010 ÷ 10 = 101 (10 ÷ 2 = 5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与或非</p><div class="table-container"><table><thead><tr><th>运算符</th><th>含义</th><th>示例（1010 和 1100）</th><th>结果</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>1010 &amp; 1100</td><td>1000</td></tr><tr><td>`</td><td>`</td><td>或 只要一个为1就为1</td><td>1010</td></tr><tr><td><code>^</code></td><td>异或</td><td>1010 ^ 1100 两个二进制位相同则为0，不同则为1。</td><td>0110</td></tr><tr><td><code>~</code></td><td>非</td><td>~1010</td><td>0101（取反，视字长而定）</td></tr></tbody></table></div><h2 id="5-逻辑代数的运算"><a href="#5-逻辑代数的运算" class="headerlink" title="5.逻辑代数的运算"></a>5.逻辑代数的运算</h2><p><strong>运算：</strong></p><p>比较重要的：</p><p>A + ¬A · B = A + B</p><p>A · (¬A + B) = A · B</p><p><strong>A + A · B = A</strong></p><p>A · (A + B) = A</p><p>A · ¬A · B = 0</p><p><strong>A + B · C = (A + B) · (A + C)</strong></p><p>吸收律：A + AB = A</p><p>分配律：A(B + C) = AB + AC</p><p>对偶律：与或互换、0和1互换</p><p>结合律、德摩根定律等</p><p><strong>反函数</strong></p><p>反函数是对逻辑表达式整体进行<strong>逻辑取反（¬）</strong>，常借助<strong>德摩根定律</strong>进行变换。</p><p>对偶函数：</p><p>所有的 <code>·</code>（AND）换成 <code>+</code>（OR）</p><p>所有的 <code>+</code>（OR）换成 <code>·</code>（AND）</p><p>所有的常量 <code>1</code> 与 <code>0</code> 互换</p><p><strong>变量和非变量（A, ¬A）不变</strong></p><h2 id="6-最小项之和（Sum-of-Minterms）和最大项之积（x）卡诺图化简"><a href="#6-最小项之和（Sum-of-Minterms）和最大项之积（x）卡诺图化简" class="headerlink" title="6.最小项之和（Sum of Minterms）和最大项之积（x）卡诺图化简"></a>6.最小项之和（Sum of Minterms）和最大项之积（x）卡诺图化简</h2><p>最小项（minterm）：在某一组输入下，<strong>输出为 1</strong> 的项 求和符号</p><p>最大项（maxterm）：在某一组输入下，<strong>输出为 0</strong> 的项。 最大符号</p><p>这个真值表的编号从0开始</p><p><strong>卡诺图</strong>编号：</p><div class="table-container"><table><thead><tr><th>CD\AB</th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>00 C非D非</td><td>0000 (0)</td><td>0001 (1)</td><td>0011 (3)</td><td>0010 (2)</td></tr><tr><td>01 C非D</td><td>0100 (4)</td><td>0101 (5)</td><td>0111 (7)</td><td>0110 (6)</td></tr><tr><td>11 cd</td><td>1100 (12)</td><td>1101 (13)</td><td>1111 (15)</td><td>1110 (14)</td></tr><tr><td>10 cD非</td><td>1000 (8)</td><td>1001 (9)</td><td>1011 (11)</td><td>1010 (10)</td></tr></tbody></table></div><p>2^n来圈，圈的越大越好</p><p>然后找公共的地方，把这些圈给加（or）起来</p><p>与－或”表达式（SOP）：最后每项用或连接 F = AB + A’C + BC ∑m</p><p>或－与”表达式：F = (A + B)(A’ + C)(B + C) ∏M</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E7%94%B5%E8%B7%AF/">电路</category>
      
      <category domain="https://blog.tokenlen.top/categories/%E7%94%B5%E8%B7%AF/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/">数字逻辑</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/11/lastteam/shuziluoji/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试模拟-1</title>
      <link>https://blog.tokenlen.top/2025/06/11/towork/working1/</link>
      <guid>https://blog.tokenlen.top/2025/06/11/towork/working1/</guid>
      <pubDate>Tue, 10 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;6-11模拟面试&quot;&gt;&lt;a href=&quot;#6-11模拟面试&quot; class=&quot;headerlink&quot; title=&quot;6.11模拟面试&quot;&gt;&lt;/a&gt;6.11模拟面试&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-Java-的面向对象编程？它的核心特性有哪些？&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="6-11模拟面试"><a href="#6-11模拟面试" class="headerlink" title="6.11模拟面试"></a>6.11模拟面试</h1><h2 id="1-什么是-Java-的面向对象编程？它的核心特性有哪些？"><a href="#1-什么是-Java-的面向对象编程？它的核心特性有哪些？" class="headerlink" title="1.什么是 Java 的面向对象编程？它的核心特性有哪些？"></a>1.什么是 Java 的面向对象编程？它的核心特性有哪些？</h2><p>面向对象编程是OOP是说就是<strong>用“对象”来组织代码</strong>，java就是一门面向对象编程的语言。</p><p>java的面向对象的三大特征是封装继承多态</p><p>封装：反射，修饰符</p><p>继承：构造方法调用，final</p><p>多态：方法重载，方法重写</p><p>抽象：抽象和接口</p><p>静态：</p><h2 id="2-说说-Java-中-ArrayList-和-LinkedList-的区别，以及各自的适用场景"><a href="#2-说说-Java-中-ArrayList-和-LinkedList-的区别，以及各自的适用场景" class="headerlink" title="2.说说 Java 中 ArrayList 和 LinkedList 的区别，以及各自的适用场景"></a>2.说说 Java 中 ArrayList 和 LinkedList 的区别，以及各自的适用场景</h2><p>底层：</p><p>遍历和插入：</p><p>arrayList扩容：1.5，数组的复制</p><p>内存占比：</p><p>使用场景：</p><p>线程安全：</p><h2 id="3-HashMap-的底层原理"><a href="#3-HashMap-的底层原理" class="headerlink" title="3.HashMap 的底层原理"></a>3.HashMap 的底层原理</h2><p>特点：</p><p>底层实现，1.7/1.7之后，头插和尾插</p><p>put过程</p><p>转换红黑树/扩容：当链表长度≥8 且数组容量≥64 时转红黑树 为什么用红黑树</p><p>线程安全：</p><p>concurrenthashmap，底层，put过程</p><h2 id="4-Spring-框架中，Bean-的作用域有哪些？请分别说明它们的生命周期和应用场景"><a href="#4-Spring-框架中，Bean-的作用域有哪些？请分别说明它们的生命周期和应用场景" class="headerlink" title="4.Spring 框架中，Bean 的作用域有哪些？请分别说明它们的生命周期和应用场景"></a>4.Spring 框架中，Bean 的作用域有哪些？请分别说明它们的生命周期和应用场景</h2><p><strong>5 大标准作用域</strong>：</p><ul><li><strong>Singleton</strong>：全局唯一实例，Spring 容器加载时创建，适用于无状态服务；</li><li><strong>Prototype</strong>：每次获取新实例，适用于有状态对象（如 DAO 层）；</li><li><strong>Request</strong>：每次 HTTP 请求一个实例，需 Web 环境，适用于请求上下文数据；</li><li><strong>Session</strong>：每个用户会话一个实例，需 Web 环境，适用于会话级数据；</li><li><strong>Application</strong>：全局 ServletContext 共享实例，需 Web 环境。</li></ul><p>生命周期：实例化→属性注入→@PostConstruct→初始化完成→使用→@PreDestroy→销毁。</p><p>循环依赖：setter单例注入，三级缓存，</p><ul><li>一级缓存（singletonObjects）：存储完全初始化的单例 Bean；</li><li>二级缓存（earlySingletonObjects）：存储早期曝光的 Bean（解决 A→B→A 的循环依赖）；</li><li>三级缓存（singletonFactories）：存储 Bean 的工厂，用于生成代理对象（解决 A→B（代理）→A 的循环依赖）。</li></ul><h2 id="5-AOP-的实现原理"><a href="#5-AOP-的实现原理" class="headerlink" title="5.AOP 的实现原理"></a>5.AOP 的实现原理</h2><p>概念：适用场景</p><p>作用点：</p><ul><li><strong>切面（Aspect）</strong>：封装横切逻辑的类，用<code>@Aspect</code>注解标识；</li><li><strong>切点（Pointcut）</strong>：定义横切逻辑作用的目标方法（如<code>@Pointcut(&quot;execution(* com.service.*.*(..))&quot;)</code>）；</li><li><strong>通知（Advice）</strong>：横切逻辑的具体实现，包括 5 种类型</li><li><strong>连接点（Joinpoint）</strong>：程序执行中的具体点（如方法调用、字段修改），AOP 中主要指<strong>方法调用</strong></li></ul><p>动态代理：</p><ul><li><strong>JDK 动态代理</strong>：基于接口实现，生成<code>InvocationHandler</code>的代理对象，适用于目标类有接口的情况；</li><li><strong>CGLIB 代理</strong>：基于子类继承，生成目标类的子类代理对象，适用于无接口的类（需引入<code>cglib</code>依赖）；</li><li><strong>Spring 默认策略</strong>：有接口用 JDK 代理，无接口用 CGLIB 代理（可通过<code>proxy-target-class</code>属性强制使用 CGLIB）。</li><li>流程：</li><li>Spring 容器扫描到<code>@Aspect</code>注解的切面类，解析切点表达式和通知类型；</li><li>对目标类判断是否适用 JDK/CGLIB 代理，生成代理对象；</li><li>当调用代理对象的方法时，实际执行的是<strong>通知逻辑 + 目标方法</strong>的组合逻辑。</li></ul><p>细节：</p><ol><li><p><strong>开启 AOP 支持</strong>：在配置类中添加<code>@EnableAspectJAutoProxy</code>注解，或在 XML 中配置<code>&lt;aop:aspectj-autoproxy/&gt;</code>；</p></li><li><p>代理模式选择</p><p>：</p><ul><li>默认<code>proxyTargetClass=false</code>（优先 JDK 代理）；</li><li>若需强制 CGLIB 代理，设置<code>proxyTargetClass=true</code>或<code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>；</li></ul></li><li><p><strong>循环依赖与 AOP</strong>：若目标类被代理，注入的是代理对象，需注意<code>this.方法()</code>调用不会触发 AOP（因<code>this</code>指向原始对象）。</p></li></ol><p>场景：</p><ul><li><p><strong>日志记录</strong>：在方法执行前后记录入参 / 结果，避免业务代码污染；</p></li><li><p><strong>事务管理</strong>：<code>@Transactional</code>本质是 AOP 实现，在方法调用时开启 / 提交 / 回滚事务；</p></li><li><strong>权限校验</strong>：在接口调用前校验用户权限，拒绝非法请求；</li><li><strong>性能监控</strong>：统计方法执行耗时，用于性能优化。</li></ul><p>流程：</p><ol><li><strong>调用代理方法</strong>：客户端调用代理对象的方法（如<code>userService.save()</code>）；</li><li><strong>匹配切点</strong>：Spring 判断该方法是否匹配切面的切点表达式；</li><li>执行通知逻辑<ul><li><code>@Around</code>中先执行前置逻辑（如日志记录开始）；</li><li>调用<code>proceed()</code>触发目标方法执行；</li><li>执行后置逻辑（如日志记录结束、统计耗时）；</li></ul></li><li><strong>返回结果</strong>：通知逻辑执行完毕后，将结果返回给客户端。</li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 定义切点（匹配所有Service方法）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.service..*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">servicePointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 环绕通知实现耗时统计</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法 &quot;</span> + methodName + <span class="string">&quot; 执行耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-MySQL-中，索引是什么？常见的索引类型有哪些？请说明它们的适用场景和优缺点。"><a href="#6-MySQL-中，索引是什么？常见的索引类型有哪些？请说明它们的适用场景和优缺点。" class="headerlink" title="6.MySQL 中，索引是什么？常见的索引类型有哪些？请说明它们的适用场景和优缺点。"></a>6.MySQL 中，索引是什么？常见的索引类型有哪些？请说明它们的适用场景和优缺点。</h2><p>数据库中用于<strong>加快数据查询速度的一种数据结构</strong>，可以类比为书本的目录。通过索引，数据库可以更快地定位到目标数据，而无需全表扫描。</p><p>为什么使用b+树，层高，叶子节点/非叶子节点</p><p>聚簇索引，非聚簇索引，索引下推</p><p>联合索引，覆盖索引</p><p>普通索引，唯一索引，前缀索引，全文索引。</p><p>索引失效：</p><p>explain:</p><h2 id="7-MyBatis-的一级缓存和二级缓存机制？如何禁用缓存？"><a href="#7-MyBatis-的一级缓存和二级缓存机制？如何禁用缓存？" class="headerlink" title="7.MyBatis 的一级缓存和二级缓存机制？如何禁用缓存？"></a>7.<strong>MyBatis 的一级缓存和二级缓存机制？如何禁用缓存？</strong></h2><p>sqlsession:</p><p>在一次 SqlSession 生命周期内，相同的查询语句（SQL + 参数）会被缓存，第二次执行时直接从缓存中取值，不会发起数据库请求。当前会话有效，执行 <code>insert/update/delete</code>：任何更新操作会清空缓存。执行<code>sqlSession.clearCache()</code>。不同参数的时候也会失效</p><p>mapper：</p><p>二级缓存是 <strong>Mapper 级别</strong>（namespace）共享缓存。</p><p>多个 SqlSession 之间共享该 Mapper 的缓存数据。</p><p>启用条件：</p><p>在 MyBatis 配置中启用全局缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>在对应 Mapper 文件中配置 <code>&lt;cache&gt;</code> 标签：</p><p>查询的 POJO 实体类必须实现 <code>Serializable</code>。</p><p>查询语句不能使用 <code>flushCache=&quot;true&quot;</code>（默认查询是 false，更新是 true）。</p><p>SqlSession 必须关闭后，一级缓存的数据才会被写入二级缓存。</p><p>默认缓存实现是 <code>PerpetualCache + LRU</code>。</p><p>可自定义缓存策略（如 EhCache、Redis）。</p><h2 id="8-MyBatis-Plus-的-Wrapper-和原生-XML-写-SQL-的区别？什么时候该用-Wrapper？"><a href="#8-MyBatis-Plus-的-Wrapper-和原生-XML-写-SQL-的区别？什么时候该用-Wrapper？" class="headerlink" title="8.MyBatis Plus 的 Wrapper 和原生 XML 写 SQL 的区别？什么时候该用 Wrapper？"></a><strong>8.MyBatis Plus 的 Wrapper 和原生 XML 写 SQL 的区别？什么时候该用 Wrapper？</strong></h2><p>Wrapper 是 MyBatis Plus 提供的条件构造器，用于构建 SQL 的 WHERE、ORDER BY 等子句，简化代码书写。</p><p><code>QueryWrapper</code>：用于普通查询。</p><p><code>LambdaQueryWrapper</code>：使用 lambda 表达式避免写字段名字符串。</p><p><code>UpdateWrapper</code> / <code>LambdaUpdateWrapper</code>：用于更新条件构造。</p><p>XML 方式是传统 MyBatis 写 SQL 的方式，通过 Mapper.xml 文件自定义 SQL 语句，更加灵活和强大，支持复杂的多表连接、子查询等。</p><div class="table-container"><table><thead><tr><th>对比项</th><th>Wrapper（构造器）</th><th>XML 原生 SQL</th></tr></thead><tbody><tr><td>语法风格</td><td>Java 代码风格，链式调用</td><td>SQL 语法，放在 XML 中</td></tr><tr><td>可读性</td><td>简洁、类型安全（特别是 Lambda）</td><td>接近原生 SQL，清晰直观</td></tr><tr><td>编写速度</td><td>快速开发，尤其适合单表 CRUD</td><td>编写略慢，需额外维护 Mapper.xml 文件</td></tr><tr><td>SQL 灵活性</td><td>支持简单查询（单表、分页、排序）</td><td>支持复杂 SQL（多表连接、子查询、聚合）</td></tr><tr><td>维护性</td><td>逻辑分散在代码中，不易集中查看</td><td>逻辑集中在 XML，更适合团队协作维护</td></tr><tr><td>运行效率</td><td>两者本质上都由 MyBatis 执行，性能差异不大</td><td>性能主要看 SQL 写得是否合理</td></tr><tr><td>调试与日志</td><td>SQL 日志可查看</td><td>也可通过日志查看</td></tr></tbody></table></div><p>✅ 使用 Wrapper 的场景：</p><ul><li>快速开发、原型项目。</li><li>简单的单表查询、分页、筛选。</li><li>Controller/Service 中构造简单业务逻辑。</li><li>需要链式调用构造条件，代码更加优雅。</li><li>使用 Lambda 避免字段拼写错误风险。</li></ul><blockquote><p><strong>推荐：日常开发中能用 Wrapper 就用 Wrapper，提高开发效率。</strong></p></blockquote><hr><p>✅ 使用 XML 写 SQL 的场景：</p><ul><li>涉及复杂 SQL（多表关联、聚合函数、子查询、动态 SQL）。</li><li>查询语句过长、不适合写在 Java 代码中。</li><li>项目追求清晰的逻辑分层、SQL 可维护性。</li><li>性能调优场景，需要手写精细 SQL。</li><li>团队需要 DBA 审查 SQL。</li></ul><blockquote><p><strong>推荐：复杂业务、线上稳定项目，用 XML 更清晰、更可控。</strong></p></blockquote><h1 id="6-12模拟面试"><a href="#6-12模拟面试" class="headerlink" title="6.12模拟面试"></a>6.12模拟面试</h1><h2 id="1-单例模式有哪些实现方式？各自的优缺点是什么？（比如饿汉式、懒汉式、双重检查锁，还有静态内部类和枚举方式，有没有线程安全的坑呀？）"><a href="#1-单例模式有哪些实现方式？各自的优缺点是什么？（比如饿汉式、懒汉式、双重检查锁，还有静态内部类和枚举方式，有没有线程安全的坑呀？）" class="headerlink" title="1.单例模式有哪些实现方式？各自的优缺点是什么？（比如饿汉式、懒汉式、双重检查锁，还有静态内部类和枚举方式，有没有线程安全的坑呀？）"></a>1.<strong>单例模式有哪些实现方式？各自的优缺点是什么？（比如饿汉式、懒汉式、双重检查锁，还有静态内部类和枚举方式，有没有线程安全的坑呀？）</strong></h2><p>饿汉式：</p><p>同步模式</p><p>volatile+synchronized</p><p>静态内部类</p><p>枚举</p><h2 id="2-说下Spring-的ApplicationContext是单例模式”“策略模式在排序算法中的应用”"><a href="#2-说下Spring-的ApplicationContext是单例模式”“策略模式在排序算法中的应用”" class="headerlink" title="2.说下Spring 的ApplicationContext是单例模式”“策略模式在排序算法中的应用”"></a>2.说下Spring 的ApplicationContext是单例模式”“策略模式在排序算法中的应用”</h2><p><code>ApplicationContext</code> 本质上采用了<strong>单例模式</strong>来保证 Spring 容器中 <strong>Bean 的唯一性和全局访问能力</strong>。</p><p>Spring Boot 启动时会初始化一个 <code>ApplicationContext</code>（如 <code>AnnotationConfigApplicationContext</code>），作为<strong>IoC 容器的核心上下文</strong>。</p><p>这个容器对象在整个应用中<strong>只创建一次（单例）</strong>，所有组件（Controller、Service、Repository）都从这个容器中获取 Bean 实例。</p><p><strong>避免了重复初始化 Bean 的性能开销</strong>，也方便了依赖管理、统一配置、事件发布等功能的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(MyApp.class, args);</span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开发中我们只需注入一次上下文或通过 <code>@Autowired</code> 注解获取 Bean，即可全局复用。</p><p>Spring 默认的 Bean 是单例的（<code>@Scope(&quot;singleton&quot;)</code>），这与 <code>ApplicationContext</code> 单例模型相辅相成，进一步保证了资源一致性与管理效率。</p><p>策略模式允许在运行时选择算法逻辑，在排序算法中可用于根据用户选择动态切换不同排序策略。</p><p><strong>定义统一的排序接口（策略抽象）</strong>，不同的排序方式（快排、归并、冒泡等）实现这个接口。</p><p><strong>运行时根据条件动态切换策略</strong>，无需修改原有代码（遵循开闭原则）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 快速排序实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 冒泡排序实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SortStrategy strategy;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SortContext</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        strategy.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SortContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortContext</span>(<span class="keyword">new</span> <span class="title class_">QuickSort</span>());</span><br><span class="line">ctx.executeSort(myArray); <span class="comment">// 快速排序执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>电商平台商品排序（按价格、销量、上架时间）</li><li>数据可视化工具的排序规则切换</li></ul><h2 id="3-Java-线程池的核心参数有哪些？各自的作用是什么？比如corePoolSize和maximumPoolSize，如何根据业务场景设置这些参数呀？"><a href="#3-Java-线程池的核心参数有哪些？各自的作用是什么？比如corePoolSize和maximumPoolSize，如何根据业务场景设置这些参数呀？" class="headerlink" title="3.Java 线程池的核心参数有哪些？各自的作用是什么？比如corePoolSize和maximumPoolSize，如何根据业务场景设置这些参数呀？"></a>3.<strong>Java 线程池的核心参数有哪些？各自的作用是什么？比如<code>corePoolSize</code>和<code>maximumPoolSize</code>，如何根据业务场景设置这些参数呀？</strong></h2><p>核心线程</p><p>最大线程</p><p>最大线程存活事件</p><p>单位</p><p>阻塞队列</p><p>拒绝策略</p><p>工厂</p><h2 id="4-你项目里用了JWT加双-Token，具体是怎么设计的？两个-Token-各自的作用是什么？拦截器又分别处理什么逻辑？比如有没有考虑过-Token-过期、刷新机制，或者防重放攻击的问题？"><a href="#4-你项目里用了JWT加双-Token，具体是怎么设计的？两个-Token-各自的作用是什么？拦截器又分别处理什么逻辑？比如有没有考虑过-Token-过期、刷新机制，或者防重放攻击的问题？" class="headerlink" title="4.你项目里用了JWT加双 Token，具体是怎么设计的？两个 Token 各自的作用是什么？拦截器又分别处理什么逻辑？比如有没有考虑过 Token 过期、刷新机制，或者防重放攻击的问题？"></a>4.你项目里用了JWT加双 Token，具体是怎么设计的？两个 Token 各自的作用是什么？拦截器又分别处理什么逻辑？比如有没有考虑过 Token 过期、刷新机制，或者防重放攻击的问题？</h2><p>token:</p><ul><li><strong>access token</strong>（7 天有效期）：放在请求头，用于日常接口认证，用 HS256 加密（密钥服务端持有）；放在前端的localStorage/jwt</li><li><strong>refresh token</strong>（15 天有效期）：存在 Redis，值是随机字符串，且绑定用户 ID ，防止盗用。放在redis中</li></ul><div class="table-container"><table><thead><tr><th>安全措施</th><th>说明</th></tr></thead><tbody><tr><td>使用 HTTPS</td><td>防止中间人劫持 token</td></tr><tr><td>access token 只读</td><td>JWT 使用 HS256 加密，防篡改</td></tr><tr><td>refresh token 存 Redis</td><td>结合用户 ID 存储，支持设置 TTL，有效控制生命周期</td></tr><tr><td>黑名单机制（登出）</td><td>用户退出登录时可删除 Redis 中 refresh token，立即失效</td></tr><tr><td>防止多端同时登录</td><td>Redis 可使用 userId 为 key，限制 refresh token 单个登录会话</td></tr><tr><td>Token 刷新接口限流</td><td>防止 refresh token 被滥用（加防重放、限频）</td></tr><tr><td>Token 刷新重发保护</td><td>Redis 设置短期 refresh token 使用标记，防止并发重复刷新</td></tr></tbody></table></div><p>退出策略：</p><p>用户点击退出：</p><ul><li>删除 Redis 中的 refresh token（或设置为无效标记）；</li><li>access token 因为是 JWT，不可被撤销，可考虑实现<strong>黑名单机制</strong>（例如 Redis 中维护一张 token 黑名单）；</li></ul><p>黑名单适用于<strong>高安全场景</strong>（如后台管理系统），但会略增加接口访问时的 Redis 查询压力。</p><p>jwt拦截器：</p><ol><li><strong>认证拦截器</strong>：先检查请求头是否有 access token，没有就返回 401；有则解析 token，校验用户信息是否存在。</li></ol><ul><li>第一个拦截器先校验请求头是否有 access token，没有的话直接返回 401；第二个拦截器在 access token 有效时，额外检查是否快过期（比如剩余时间 &lt; 10 分钟），如果是就用 refresh token 去 Redis 换全新的 access token 和 refresh token（这里要注意刷新时的原子性，避免并发问题）。</li></ul><ol><li>刷新拦截器：如果 access token 剩余有效期 &lt; 10 分钟，就用请求头中的 refresh token 去 Redis 校验：<ul><li>校验通过的话，生成新的 access token 和 refresh token（新 refresh token 会覆盖 Redis 中的旧值，保证单设备登录）；</li><li>校验失败的话，直接让用户重新登录。</li></ul></li></ol><p>危险：</p><p>前端或攻击者<strong>拿到密钥（如部署泄露、浏览器调试泄露）</strong>，就可以伪造合法 token。</p><p>token 内容是可解密的，攻击者可<strong>猜测或修改 payload</strong>，然后重新签名。</p><p>如果服务端<strong>未验证签名</strong>（有些误用场景会只解析不校验），更容易被利用。</p><p>但还是sh256更快，计算算开销低；对称密钥管理更简单，适用于内部系统或中小型项目；</p><p>开发成本更低，不涉及证书管理、公私钥分发；</p><div class="table-container"><table><thead><tr><th>措施</th><th>说明</th></tr></thead><tbody><tr><td>✅ 使用强密钥</td><td>至少 256 bit 的复杂密钥，不可硬编码进前端或代码中</td></tr><tr><td>✅ 启用 HTTPS</td><td>防止 token 被中间人劫持</td></tr><tr><td>✅ token 签名校验</td><td>每次都校验 JWT 的签名，防止伪造</td></tr><tr><td>✅ 缩短 access token 有效期</td><td>缩小攻击窗口</td></tr><tr><td>✅ refresh token 存 Redis</td><td>结合用户 ID 防重放、防伪造</td></tr><tr><td>✅ 黑名单机制 + 登出清除</td><td>登出时使 refresh token 无效</td></tr><tr><td>✅ 检查 UA/IP 等指纹</td><td>防止 token 被别人拿去复用</td></tr></tbody></table></div><h2 id="5-看你在优惠劵的发放的时候使用限流，怎么设计的"><a href="#5-看你在优惠劵的发放的时候使用限流，怎么设计的" class="headerlink" title="5.看你在优惠劵的发放的时候使用限流，怎么设计的"></a>5.看你在优惠劵的发放的时候使用限流，怎么设计的</h2><p>我们在优惠券领取接口中用 AOP + 令牌桶实现限流</p><ul><li><strong>注解定义</strong>：<code>@RateLimit</code> 注解标注需要限流的方法，参数包括 <code>limitCount=5</code>（每分钟 5 次）、<code>time=1</code>（时间单位分钟）、<code>keyType=&quot;USER_IP&quot;</code>（按用户 IP+ID 限流）。</li><li><strong>切面实现</strong>：通过 <code>@Around</code> 切面拦截注解方法，获取参数后生成唯一限流 key（例如 <code>rate_limit:user_123:192.168.1.1</code>），然后调用 Redis 令牌桶服务校验。</li><li><strong>Redis 令牌桶</strong>：用 Lua 脚本实现原子性校验，核心是根据时间戳计算可生成的新令牌数，不足时拒绝请求。比如用户抢优惠券时，同一 IP+ID 每分钟最多 5 次请求，防止恶意刷接口。</li></ul><ol><li><strong>防重复领取</strong>：避免用户短时间内多次点击接口，导致优惠券<strong>超发</strong>；</li><li><strong>保护服务端</strong>：峰值流量时限制请求频率，防止 Redis 或数据库被击穿。线上遇到过同一 WiFi 下多个用户被误限的情况，后来把 key 改为`IP+用户ID，减少了误判率。”</li></ol><p>切面类如何获取注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.example.RateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimitPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;rateLimitPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取方法上的注解</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line">        <span class="type">RateLimit</span> <span class="variable">rateLimit</span> <span class="operator">=</span> method.getAnnotation(RateLimit.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">limitCount</span> <span class="operator">=</span> rateLimit.limitCount();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> rateLimit.time();</span><br><span class="line">        <span class="type">String</span> <span class="variable">keyType</span> <span class="operator">=</span> rateLimit.keyType();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成限流key（IP+用户ID）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> generateKey(joinPoint, keyType);</span><br><span class="line">        <span class="comment">// 调用Redis令牌桶校验</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allow</span> <span class="operator">=</span> redisBucketService.tryAcquire(key, limitCount, time, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">if</span> (!allow) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请求频繁，请稍后再试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么选令牌桶而不是漏桶？</p><p>令牌桶适合突发流量，漏桶适合平滑流量</p><p>使用redis+lua原子的存储令牌桶，使用时间戳来校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 令牌桶Lua脚本（简化版）</span><br><span class="line"><span class="type">local</span> <span class="variable">key</span> <span class="operator">=</span> KEYS[<span class="number">1</span>]  -- 限流key</span><br><span class="line"><span class="type">local</span> <span class="variable">capacity</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">1</span>])  -- 桶容量</span><br><span class="line"><span class="type">local</span> <span class="variable">rate</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">2</span>])  -- 令牌生成速率（个/秒）</span><br><span class="line"><span class="type">local</span> <span class="variable">now</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">3</span>])  -- 当前时间戳</span><br><span class="line"><span class="type">local</span> <span class="variable">requested</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">4</span>])  -- 请求令牌数</span><br><span class="line"></span><br><span class="line">-- 读取上次更新时间和剩余令牌数</span><br><span class="line"><span class="type">local</span> <span class="variable">last</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hget&#x27;</span>, key, <span class="string">&#x27;last&#x27;</span>)</span><br><span class="line"><span class="type">local</span> <span class="variable">tokens</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;hget&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>) or <span class="number">0</span>)</span><br><span class="line">last = last or now</span><br><span class="line"></span><br><span class="line">-- 计算可生成的新令牌数</span><br><span class="line"><span class="type">local</span> <span class="variable">delta</span> <span class="operator">=</span> now - last</span><br><span class="line"><span class="type">local</span> <span class="variable">newTokens</span> <span class="operator">=</span> math.min(capacity, tokens + delta * rate)</span><br><span class="line"><span class="keyword">if</span> newTokens &gt;= requested then</span><br><span class="line">    -- 够发令牌，更新状态</span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, <span class="string">&#x27;last&#x27;</span>, now)</span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, newTokens - requested)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  -- 允许访问</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  -- 拒绝访问</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="6-那么优惠劵的发放呢？一些列的问题呢"><a href="#6-那么优惠劵的发放呢？一些列的问题呢" class="headerlink" title="6.那么优惠劵的发放呢？一些列的问题呢"></a>6.那么优惠劵的发放呢？一些列的问题呢</h2><p>✅ 一、关于优惠券类型的常见问题</p><p>❓1. 如何区分和应用不同类型的优惠券逻辑？</p><p><strong>面试点</strong>：策略模式、优惠金额计算方式。</p><p><strong>答法</strong>：</p><blockquote><p>我们用策略模式来封装每种优惠券的优惠逻辑（如满减、折扣、无门槛）。每种类型对应一个策略类，实现统一的接口方法 <code>calculateDiscount(OrderInfo order)</code>，这样能在运行时动态选择策略，便于扩展和维护。</p></blockquote><hr><p>✅ 二、关于接口设计的追问</p><p>❓2. 为什么接口是这样的？有没有考虑幂等性和安全性？</p><ul><li><code>POST /use</code> 接口可能会被重复调用，是否<strong>幂等</strong>？</li><li>有没有做权限控制，防止其他用户伪造请求？</li></ul><p><strong>答法</strong>：</p><blockquote><p>在使用优惠券时，为防止重复使用，我们使用 Redis + Lua 实现原子操作，同时标记优惠券为“已使用”。此外接口采用登录态校验，验证当前操作用户是否拥有该优惠券。敏感操作都要求用户登录，并记录操作日志。</p></blockquote><hr><p>✅ 三、关于并发处理和限领逻辑</p><p>❓3. 如果多用户并发领取优惠券，如何防止超发？</p><p><strong>答法</strong>：</p><blockquote><p>发放流程中，我们使用 Redis 的 <code>DECR</code> 或 Lua 脚本实现优惠券库存的原子扣减，保证不会发放超过设定数量。同时加锁防止并发条件下库存扣减不一致。</p></blockquote><hr><p>❓4. 如何限制每个用户只能领取一次？</p><p><strong>答法</strong>：</p><blockquote><p>Redis 中设置一个标识键：<code>user:coupon:received:&#123;couponId&#125;:&#123;userId&#125;</code>，发放前先判断这个键是否存在，避免重复发放。也可以结合布隆过滤器提前过滤无效请求。</p></blockquote><hr><p>✅ 四、关于时间与状态校验</p><p>❓5. 限时券怎么判断是否有效？服务端怎么处理时间逻辑？</p><p><strong>答法</strong>：</p><blockquote><p>每张优惠券记录中保存有效时间范围。使用时，服务端比对当前时间是否在有效期内。同时定时任务每天扫描过期优惠券，标记为“已过期”。</p></blockquote><hr><p>✅ 五、关于优惠券使用过程的逻辑判断</p><p>❓6. 使用时如果有多个优惠券，怎么选最优？</p><p><strong>答法</strong>：</p><blockquote><p>前端可以请求一个“推荐最优券”的接口，我们在服务端遍历用户可用券，调用各个策略类计算预期优惠，返回最高优惠金额对应的券。</p></blockquote><hr><p>✅ 六、关于优惠券与订单系统结合问题</p><p>❓7. 如果下单失败了，优惠券是否要恢复？</p><p><strong>答法</strong>：</p><blockquote><p>下单失败（如支付失败、库存不足）时，我们会在事务回滚后将优惠券状态重置为“未使用”。为了避免并发问题，使用分布式事务（如消息队列、TCC）或 Redis 回滚标记。</p></blockquote><hr><p>✅ 七、进阶设计问题</p><p>❓8. 优惠券支持“异步发放”和“定时生效”吗？</p><p><strong>答法</strong>：</p><blockquote><p>是的，可以结合定时任务（如 Quartz 或 Spring Schedule）实现定时发放；发放时间和有效时间字段分离，发放时写入 Redis 延时队列，当生效时间到达时插入到用户优惠券表中。</p></blockquote><hr><p>✅ 八、可能让你设计代码结构的问题</p><p>❓9. 优惠券模块的结构划分是怎样的？</p><p><strong>答法</strong>（示意）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- entity（Coupon, UserCoupon）</span><br><span class="line">- controller（CouponController）</span><br><span class="line">- service（CouponService、UseStrategy接口及实现）</span><br><span class="line">- repository（MyBatis-Plus Mapper）</span><br><span class="line">- util（金额计算工具类）</span><br></pre></td></tr></table></figure><hr><p>✅ 九、安全性问题</p><p>❓10. 用户伪造优惠券 ID，试图套用别人的优惠券怎么办？</p><p><strong>答法</strong>：</p><blockquote><p>每次使用时不仅要校验优惠券 ID 是否存在，还要校验当前登录用户是否是该优惠券持有人，只有归属校验通过才能使用。</p></blockquote><h2 id="7-AOP记录日志"><a href="#7-AOP记录日志" class="headerlink" title="7.AOP记录日志"></a>7.AOP记录日志</h2><p>“我们用 AOP 实现了登录日志和业务日志的分类记录，核心设计是：</p><ul><li><strong>注解与策略</strong>：定义<code>@Log</code>注解标注需要记录的方法，通过<code>type()</code>参数区分<code>LOGIN</code>和<code>BUSINESS</code>类型。</li><li><p><strong>切面逻辑</strong>：拦截方法执行前后，<strong>获取用户信息、操作参数、接口耗时等数据，封装成日志对象</strong>。例如登录日志会记录 IP、设备信息，业务日志会<strong>记录操作类型</strong>（如下单、领券）和参数（如商品 ID、优惠券 ID）。</p></li><li><p><strong>存储优化</strong>：用 Kafka 异步写入日志，避免影响接口性能，再通过 Logstash 同步到 Elasticsearch，方便用 Kibana 按时间、用户 ID 等维度检索。</p></li></ul><p>举个实际场景：用户领取优惠券时，业务日志会记录<code>&#123;user_id:123, operation:&quot;领取满100减20&quot;, params:&#123;coupon_id:567&#125;, cost:87ms&#125;</code>。有次线上发现某个接口耗时突然增加，通过 ELK 检索该接口的日志，很快定位到是参数校验逻辑异常导致的。</p><p>我们对敏感信息做了脱敏处理，比如用户手机号会存成<code>138****5678</code>，既满足日志追溯需求，又符合数据安全规范。”</p><p>存储的信息，使用json进行存储</p><ul><li>登录日志：用户 ID、登录 IP、设备信息、登录时间、状态（成功 / 失败）、失败原因（如密码错误）；</li><li>业务日志：用户 ID、操作类型（如 “领取优惠券”“下单”）、操作内容、操作时间、接口耗时、请求参数（脱敏处理）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;operationLogPointcut()&quot;)</span><span class="comment">//切入点就是注解</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logOperation</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span>  <span class="operator">=</span> ((MethodSignature)joinPoint.getSignature()).getMethod();</span><br><span class="line">        <span class="type">OperationLog</span> <span class="variable">logAnno</span> <span class="operator">=</span> method.getAnnotation(OperationLog.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span>System.currentTimeMillis()-start;</span><br><span class="line"></span><br><span class="line">        <span class="type">LogDTO</span> <span class="variable">log</span> <span class="operator">=</span> buildLog(joinPoint,logAnno.type(),logAnno.action(),duration);</span><br><span class="line">        asyncLogUtils.record(log);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Method获取主机额上的方法，然后建立实体类，设置参数，然后利用DTO传参，然后执行service方法，然后返回，service就是调用log,info</p><p>DTO层负责service和controller直接传输数据</p><h1 id="6-14模拟面试"><a href="#6-14模拟面试" class="headerlink" title="6.14模拟面试"></a>6.14模拟面试</h1><h2 id="1-Spring-事务的实现原理是什么？-Transactional-注解在什么情况下会失效？"><a href="#1-Spring-事务的实现原理是什么？-Transactional-注解在什么情况下会失效？" class="headerlink" title="1.Spring 事务的实现原理是什么？@Transactional 注解在什么情况下会失效？"></a>1.<strong>Spring 事务的实现原理是什么？@Transactional 注解在什么情况下会失效？</strong></h2><p>spring事务的实现原理是基于AOP的动态代理和TransacationInterceptorh还有底层依赖</p><p>AOP：Spring 通过 ProxyFactoryBean 生成代理对象，默认对接口用 JDK 动态代理，对类用 CGLIB 代理；是采用cglib继承目标类的方式去创建代理类，非pulic的方法不能能继承。</p><p>拦截器：核心拦截器，在方法调用前后开启 / 提交 / 回滚事务，基于 ThreadLocal 存储事务状态；基于运行时异常来回滚的，所以把运行时异常给catch或者返回没指定的异常</p><p>底层依赖：通过 PlatformTransactionManager 接口适配不同事务管理器（如 JDBC、JPA）。</p><p>使用ThreadLocal存储事务的状态，（如连接、隔离级别）通过<code>TransactionSynchronizationManager</code>存在线程本地变量，保证线程安全。</p><p>所以基于这个情况,spring事务失效的场景有：</p><p>1.吃掉运行时异常没抛出：</p><p>2.未配置回滚规则，要配置rollbackFor=Exception.class指定类型</p><p>3.调用this</p><p>4.非public方法</p><p>5.事务的传播属性设置为never,not_support这种不支持事务的</p><p>6.调用了不支持事务的数据库</p><p>7.事务嵌套：</p><p><code>REQUIRES_NEW</code> 会挂起外部事务，<strong>提前提交</strong></p><p>嵌套事务用 <code>NESTED</code> 会创建 savepoint，支持回滚子事务（但数据库需支持）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部事务</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">    inner(); <span class="comment">// REQUIRES_NEW</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(); <span class="comment">// 外部异常不会影响 inner 提交的事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 已提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transactional 属性详解:</p><ul><li><code>propagation</code>：传播行为（如 REQUIRED：当前有事务则加入，无则新建）；</li><li><code>isolation</code>：隔离级别（如 READ_COMMITTED 避免脏读）；</li><li><code>timeout</code>：事务超时时间（如<code>timeout=30</code>秒）；</li><li><code>rollbackFor/rollbackForClassName</code>：指定回滚的异常类型；</li><li><code>noRollbackFor/noRollbackForClassName</code>：指定不回滚的异常类型。</li></ul><h2 id="2-Java-中-HashMap-在-JDK1-8-的底层实现是什么？相对于-JDK1-7-做了哪些优化？"><a href="#2-Java-中-HashMap-在-JDK1-8-的底层实现是什么？相对于-JDK1-7-做了哪些优化？" class="headerlink" title="2.Java 中 HashMap 在 JDK1.8 的底层实现是什么？相对于 JDK1.7 做了哪些优化？"></a>2.<strong>Java 中 HashMap 在 JDK1.8 的底层实现是什么？相对于 JDK1.7 做了哪些优化？</strong></h2><p>1.8：数组+链表+红黑树，1.7数组+链表</p><p>尾插                    头插</p><p>转换条件，&lt;64先扩容</p><p>为什么不用平衡二叉树，</p><p>尾插解决环的问题（线程 A 和线程 B 同时扩容 HashMap，A 处理链表时被挂起，B 完成扩容后，A 继续处理时按头插法插入元素，导致链表成环；）。</p><p>扩容机制 &lt;64先扩容</p><p>哈希算法优化：</p><ul><li>1.7：通过<code>hashCode() ^ (hashCode() &gt;&gt;&gt; 16)</code>扰动函数打散高 16 位，避免低位冲突；</li><li>1.8：直接使用<code>hashCode()</code>，但计算下标时用<code>(n-1) &amp; hash</code>（n 为数组长度，需是 2 的幂），例：</li></ul><p>实战：</p><ul><li><strong>性能提升</strong>：存储 1000 个哈希冲突的键时，1.7 查询需遍历链表（O (1000)），1.8 用红黑树只需 O (log2 (1000))≈10 次查询；</li><li><strong>内存占用</strong>：红黑树节点比链表节点多存储父节点、左右子节点指针，但若哈希冲突少，链表长度 &lt;8 时仍用链表，节省内存。”</li></ul><p>红黑树特点：</p><ol><li>节点非红即黑；</li><li>根节点和叶节点（null）是黑色；</li><li>红色节点不能相邻；</li><li>任意节点到叶节点的路径上黑节点数相同；<br>插入时最多旋转 2 次即可平衡，适合 HashMap 的高频插入场景。</li></ol><p>场景：</p><p>“线上曾遇到 HashMap 性能问题，通过 JProfiler 发现某接口频繁操作哈希冲突严重的 Map，将 JDK1.7 升级到 1.8 后，接口响应时间从 500ms 降至 50ms，主要得益于红黑树对高冲突场景的优化。”</p><h2 id="3-Spring-Bean-的生命周期是怎样的？-PostConstruct-和-PreDestroy-的作用是什么？"><a href="#3-Spring-Bean-的生命周期是怎样的？-PostConstruct-和-PreDestroy-的作用是什么？" class="headerlink" title="3.Spring Bean 的生命周期是怎样的？@PostConstruct 和 @PreDestroy 的作用是什么？"></a>3.<strong>Spring Bean 的生命周期是怎样的？@PostConstruct 和 @PreDestroy 的作用是什么？</strong></h2><p>实例化-&gt;初始化-&gt;使用-&gt;销毁</p><p><strong>实例化</strong>：通过构造器创建 Bean 实例（无参构造或工厂方法）；</p><p><strong>属性赋值</strong>：依赖注入（@Autowired、setter 方法等）；</p><p><strong>初始化前</strong>：执行 BeanPostProcessor 的<code>postProcessBeforeInitialization</code>；</p><p>初始化：</p><ol><li>执行 @PostConstruct 标注的方法；</li><li>实现 InitializingBean 接口的<code>afterPropertiesSet</code>；</li><li>自定义 init-method（XML 配置或 @Bean 的 initMethod 属性）；</li></ol><p><strong>初始化后</strong>：执行 BeanPostProcessor 的<code>postProcessAfterInitialization</code>；</p><p><strong>使用</strong>：Bean 放入容器，供应用获取使用；</p><p><strong>销毁前</strong>：执行 @PreDestroy 标注的方法；</p><p>销毁：</p><ol><li>实现 DisposableBean 接口的<code>destroy</code>；</li><li>自定义 destroy-method。</li></ol><p>三级缓存解决循环依赖：</p><p><strong>@PostConstruct 和 @PreDestroy 的执行时机</strong>：</p><p><strong>@PostConstruct</strong>：在依赖注入完成后，初始化方法（如 init-method）之前执行；</p><p><strong>@PreDestroy</strong>：在 Bean 销毁前执行，先于 destroy-method；</p><p>应用场景：</p><ul><li>初始化：数据库连接池初始化、缓存预热；</li><li>销毁：释放资源（关闭文件流、释放锁）。</li></ul><p>关键点：</p><ul><li><strong>BeanPostProcessor</strong>：初始化前后的拦截器（如 AOP 代理在此阶段创建）；</li><li><strong>InstantiationAwareBeanPostProcessor</strong>：属性赋值前的拦截器（可修改属性值）；</li><li><strong>SmartInitializingSingleton</strong>：所有单例 Bean 初始化完成后执行（适合初始化需要依赖其他 Bean 的场景）。</li></ul><p>问题解决：</p><ul><li>问题：ServiceA 依赖 ServiceB，ServiceB 的 @PostConstruct 方法未完成时，ServiceA 已使用 ServiceB；</li><li>解决：通过<code>@DependsOn(&quot;serviceB&quot;)</code>强制 ServiceA 在 ServiceB 之后初始化，或实现<code>Ordered</code>接口指定初始化顺序。”或者是使用懒加载加载一个，或者是重新构建方法</li></ul><h2 id="4-Java-中-synchronized-和-volatile-的区别是什么？各自的应用场景有哪些？"><a href="#4-Java-中-synchronized-和-volatile-的区别是什么？各自的应用场景有哪些？" class="headerlink" title="4.Java 中 synchronized 和 volatile 的区别是什么？各自的应用场景有哪些？"></a>4.<strong>Java 中 synchronized 和 volatile 的区别是什么？各自的应用场景有哪些？</strong></h2><ul><li><p>synchronized：</p><ul><li><strong>原子性</strong>：通过 <strong>Monitor 锁</strong>确保代码块同一时间只能被一个线程执行；</li><li><strong>可见性</strong>：解锁时将工作内存变量刷新到主内存；</li><li><strong>有序性</strong>：通过 happens-before 原则，禁止指令重排（锁的获取 / 释放形成 happens-before 关系）。</li></ul></li><li><p>volatile：</p><ul><li><strong>可见性</strong>：写操作时强制刷新主内存，读操作时强制从主内存读取；</li><li><strong>有序性</strong>：通过内存屏障（Memory Barrier）禁止指令重排，确保 happens-before 关系；</li><li><strong>不保证原子性</strong>：仅保证单次读 / 写操作的原子性，如<code>i++</code>（实际是读 - 改 - 写三步，非原子）。</li></ul></li></ul><p>内存屏障使用的时间：读写屏障，写写屏障，写读屏障</p><p>使用场景：</p><p>s:原子操作，线程安全比如hashtable</p><p>v:状态标记,interput</p><p>联合使用：单例的DCL模式，concurrenthashmap,</p><p>问题：</p><ul><li><strong>问题</strong>：多线程读取配置开关不生效；</li><li><strong>原因</strong>：配置开关未用 volatile 修饰，线程读取的是本地缓存值；</li><li><strong>解决</strong>：<code>volatile boolean configSwitch = false;</code>，修改后立即通知所有线程。</li></ul><h2 id="5-Java-中为什么要使用线程池？线程池如何处理异常？"><a href="#5-Java-中为什么要使用线程池？线程池如何处理异常？" class="headerlink" title="5.Java 中为什么要使用线程池？线程池如何处理异常？"></a>5.<strong>Java 中为什么要使用线程池？线程池如何处理异常？</strong></h2><p><strong>线程池的核心优势系统化梳理</strong>：</p><ul><li><strong>资源复用</strong>：避免频繁创建销毁线程（创建线程耗时约 3ms，复用可降低开销）；</li><li><strong>控制并发数</strong>：防止并发过高导致的 OOM（如秒杀场景限制线程数保护数据库）；</li><li><strong>统一管理</strong>：统一设置线程名称、优先级，方便日志追踪和故障排查；</li><li><strong>异步处理</strong>：将耗时任务放入线程池，避免主线程阻塞（如日志异步写入）。</li></ul><p>比较单线程，多线程，和线程池</p><p>异常处理：</p><p>使用<code>try-catch</code>包裹任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doTask();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;任务异常&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过<code>Future</code>获取异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    future.get(); <span class="comment">// 阻塞获取结果，抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;任务异常&quot;</span>, e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拒绝策略<code>AbortPolicy</code>会抛出<code>RejectedExecutionException</code>，需在提交任务时捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    executor.execute(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;任务被拒绝&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景：</p><ul><li><strong>电商下单场景</strong>：<br>用线程池异步处理库存扣减、积分计算等耗时任务，主线程快速返回订单创建结果，提升用户体验；</li><li><strong>日志系统</strong>：<br>用线程池异步写入日志到 Kafka，避免 IO 阻塞影响业务接口响应时间。</li></ul><h1 id="6-19模拟面试"><a href="#6-19模拟面试" class="headerlink" title="6.19模拟面试"></a>6.19模拟面试</h1><h2 id="1-在-“校园餐饮系统”-项目里，你提到用了-Redis-存储-token-缓解压力，能讲讲具体怎么设计-key-的结构，以及如何保障-token-存储和读取的高效性与安全性不？"><a href="#1-在-“校园餐饮系统”-项目里，你提到用了-Redis-存储-token-缓解压力，能讲讲具体怎么设计-key-的结构，以及如何保障-token-存储和读取的高效性与安全性不？" class="headerlink" title="1.在 “校园餐饮系统” 项目里，你提到用了 Redis 存储 token 缓解压力，能讲讲具体怎么设计 key 的结构，以及如何保障 token 存储和读取的高效性与安全性不？"></a>1.在 “校园餐饮系统” 项目里，你提到用了 Redis 存储 token 缓解压力，能讲讲具体怎么设计 key 的结构，以及如何保障 token 存储和读取的高效性与安全性不？</h2><p>我们使用 Redis 存储用户的 <code>refresh token</code>，以提升系统性能并减少数据库压力，整体设计分为三部分：<strong>Key 设计、存储结构、安全机制</strong>。</p><p>结构设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token:refresh:&#123;userId&#125;</span><br></pre></td></tr></table></figure><p>这种格式能明确标识 token 类型和所属用户，保证唯一性和可读性，避免 key 冲突。</p><p>Value 的存储结构：</p><p>我们使用 Redis 的 <strong>字符串结构（String）</strong> 或 <strong>哈希结构（Hash）</strong> 存储 refresh token，取决于业务是否需要额外附加字段（如生成时间、IP、设备信息）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET token:refresh:123 userId 123 token abc123 createdAt 2025-06-19</span><br></pre></td></tr></table></figure><p>设置合理的过期时间（如 7 天），使用 <code>EXPIRE</code> 或 <code>SETEX</code> 命令控制 token 生命周期。</p><p>Token 的生成与安全性保障：</p><p>Token 使用 JWT 生成，签名采用 <strong>HS256 算法</strong>（HMAC + SHA256），密钥保存在服务端配置中心或安全的 KMS（Key Management Service）中。</p><p>JWT 本身包含用户信息、过期时间等，生成后只将 <code>access token</code> 下发到前端，<code>refresh token</code> 则存于 Redis 中服务端管理，防止伪造。</p><p>认证流程：</p><p>登录时生成 access + refresh token：</p><ul><li>access token 返回给前端；</li><li>refresh token 存入 Redis，key 为 <code>token:refresh:&#123;userId&#125;</code>。</li></ul><p>前端 token 过期后，<strong>携带 refresh token 请求刷新接口</strong>；</p><p>后端校验 Redis 中的 refresh token，校验通过后重新生成新 token 对。</p><p>提前防止问题：</p><p><strong>防缓存穿透</strong>：使用 <strong>布隆过滤器</strong> 记录<strong>有效用户 ID 或常见请求 Key</strong>，防止恶意请求频繁查询 Redis 失败并打爆数据库。</p><p><strong>防击穿</strong>：为热点用户的 token <strong>设置合理 TTL</strong>，避免同一时间大批用户同时失效。</p><p><strong>防雪崩</strong>：TTL 设置加入随机因子，避免大批 key 同时过期。</p><p><strong>权限校验</strong>：请求时验证 token 是否属于当前 userId，防止越权操作。</p><h2 id="2-在-“MinaDB-自研轻量级数据库系统”-项目里，你实现了基于-Java-NIO-的数据页读写管理模块，提升了-3-倍访问效率，讲讲-Java-NIO-是咋在这个模块里发挥作用的，和传统-I-O-相比，具体优化点在哪呀？"><a href="#2-在-“MinaDB-自研轻量级数据库系统”-项目里，你实现了基于-Java-NIO-的数据页读写管理模块，提升了-3-倍访问效率，讲讲-Java-NIO-是咋在这个模块里发挥作用的，和传统-I-O-相比，具体优化点在哪呀？" class="headerlink" title="2.在 “MinaDB - 自研轻量级数据库系统” 项目里，你实现了基于 Java NIO 的数据页读写管理模块，提升了 3 倍访问效率，讲讲 Java NIO 是咋在这个模块里发挥作用的，和传统 I/O 相比，具体优化点在哪呀？"></a>2.在 “MinaDB - 自研轻量级数据库系统” 项目里，你实现了基于 Java NIO 的数据页读写管理模块，提升了 3 倍访问效率，讲讲 Java NIO 是咋在这个模块里发挥作用的，和传统 I/O 相比，具体优化点在哪呀？</h2><p>BIO 与 NIO 的区别：</p><p><strong>BIO（Blocking I/O）</strong>：每个请求需要一个线程处理，线程阻塞在 I/O 操作上，连接数一多就容易造成线程资源耗尽，系统响应慢。</p><p><strong>NIO（Non-blocking I/O）</strong>：通过 <strong>Selector + Channel + Buffer</strong> 实现多路复用，单线程可监听多个 Channel，避免大量线程阻塞等待，提高了资源利用率。</p><p>NIO 工作机制：</p><ul><li>客户端连接通过 <code>ServerSocketChannel</code> 接收；</li><li>每个 <code>Channel</code> 注册到 <code>Selector</code> 上，监听感兴趣的事件（如 <code>READ</code>、<code>WRITE</code>）；</li><li>Selector 使用 <code>select()</code> <strong>非阻塞轮询</strong>就绪事件；</li><li>当某个 Channel 有事件到达，就通过 <code>Buffer</code> 读写数据，由工作线程处理请求。</li></ul><p>这种模型的优势是：<strong>少量线程可处理高并发请求</strong>，适合 I/O 密集型场景。</p><p>数据库应用：</p><p>数据库系统天然是多并发场景，传统 BIO 每个连接对应一个线程，会造成线程浪费甚至上下文切换频繁；</p><p>使用 NIO 模型后，我们<strong>采用 Reactor 模式</strong>，用一个主线程监听所有连接事件，用线程池异步处理真正的读写请求；</p><p>每个客户端连接通过 Channel 注册到 Selector 上，提升了连接并发处理能力；</p><p>底层页式读写通过 Buffer 显著减少了系统调用次数和数据拷贝成本，提高了磁盘 I/O 效率。</p><p>并发控制说明：</p><p>因为是数据库系统，多用户可能同时对同一数据页进行访问；</p><p>在读写路径上，我们结合了<strong>读写锁</strong>机制和自实现的<strong>MVCC（多版本并发控制）</strong>，确保事务隔离的一致性；</p><p>NIO 负责连接层的高效事件处理，MVCC 负责数据访问层的并发安全。</p><h2 id="3-在-“校园餐饮系统”-项目里，你用-AOP-实现了操作日志自动记录，讲讲-AOP-切点是怎么定义的，怎么确保只拦截到需要记录日志的关键业务方法，又不会过度拦截影响系统性能呀？"><a href="#3-在-“校园餐饮系统”-项目里，你用-AOP-实现了操作日志自动记录，讲讲-AOP-切点是怎么定义的，怎么确保只拦截到需要记录日志的关键业务方法，又不会过度拦截影响系统性能呀？" class="headerlink" title="3.在 “校园餐饮系统” 项目里，你用 AOP 实现了操作日志自动记录，讲讲 AOP 切点是怎么定义的，怎么确保只拦截到需要记录日志的关键业务方法，又不会过度拦截影响系统性能呀？"></a>3.在 “校园餐饮系统” 项目里，你用 AOP 实现了操作日志自动记录，讲讲 AOP 切点是怎么定义的，怎么确保只拦截到需要记录日志的关键业务方法，又不会过度拦截影响系统性能呀？</h2><p>我们系统中使用了 Spring AOP 来统一记录用户的操作日志，包括登录日志和业务行为日志。整体设计思路是基于 <strong>自定义注解 + 切面编程 + 策略模式</strong> 来实现灵活、可扩展的日志记录体系。</p><p>我们定义了一个自定义注解 <code>@LogRecord</code>，用于标记需要记录的操作方法，注解中可以配置以下元信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogRecord &#123;</span><br><span class="line">    LogType <span class="title function_">type</span><span class="params">()</span>; <span class="comment">// 登录日志 or 业务日志</span></span><br><span class="line">    String <span class="title function_">action</span><span class="params">()</span>; <span class="comment">// 操作行为描述，如 &quot;删除用户&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切面实现日志拦截逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(logRecord)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordLog</span><span class="params">(ProceedingJoinPoint pjp, LogRecord logRecord)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 1. 获取方法签名与参数</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) pjp.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 根据注解元信息决定日志类型</span></span><br><span class="line">        <span class="type">LogType</span> <span class="variable">type</span> <span class="operator">=</span> logRecord.type();</span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> logRecord.action();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行方法并记录执行结果</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将日志对象封装后交由策略类处理</span></span><br><span class="line">        <span class="type">LogContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogContext</span>(...);</span><br><span class="line">        logStrategyFactory.getStrategy(type).record(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>日志记录策略设计（策略模式）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(LogContext context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginLogStrategy</span> <span class="keyword">implements</span> <span class="title class_">LogStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(LogContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录用户登录成功/失败，IP、时间等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BizLogStrategy</span> <span class="keyword">implements</span> <span class="title class_">LogStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(LogContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录用户执行的业务操作，如“删除用户”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>策略选择通过 <code>LogStrategyFactory</code> 实现，支持按日志类型动态扩展。</p><p>如何保证只拦截关键方法、避免性能问题：</p><p>只对使用 <code>@LogRecord</code> 注解的方法进行拦截，确保业务无关方法不被扫描，避免性能浪费；</p><p><strong>切面逻辑尽量精简</strong>，只做元信息解析和日志上下文构建，真正的日志落盘交给异步任务处理或消息队列；</p><p>对不需要记录的查询类接口，不加注解，完全绕过切面执行，保障系统整体响应效率。</p><p>日志可选择输出到文件（使用 SLF4J + Logback），或存入数据库 / Elasticsearch，供后期审计；</p><p>特殊场景下（如操作异常），支持记录异常栈与执行耗时。</p><p>追问：：：</p><ul><li><strong>问</strong>：@Around 和 @Before 有什么区别，为什么你选用 Around？</li><li><strong>答</strong>：Around 能拿到方法执行前后的控制权，包括返回值和异常，更适合记录执行结果和耗时。</li><li><strong>问</strong>：怎么处理日志失败、落盘慢的问题？</li><li><strong>答</strong>：日志落盘可异步执行或通过 MQ 异步解耦，避免阻塞主流程。</li></ul><h2 id="4-Mysql的两段提交的三个步骤"><a href="#4-Mysql的两段提交的三个步骤" class="headerlink" title="4.Mysql的两段提交的三个步骤"></a>4.Mysql的两段提交的三个步骤</h2><p>1.prepare</p><p>InnoDB 写入 redo log 的 prepare 状态并刷盘:</p><p>InnoDB 引擎将事务修改的数据写入内存（Buffer Pool）；</p><p>然后生成一条 redo log，标记为 <code>&quot;prepare&quot;</code> 状态；</p><p>调用 <code>fsync</code> 将 redo log 刷入磁盘，保证崩溃后能恢复；</p><p>2.binlogcommit:</p><p>Server 层将整个事务的逻辑操作记录为一条 binlog；</p><p>将 binlog 持久化刷盘，<code>fsync()</code> 确保落地。</p><p>3.redocommit:</p><p>Server 层写 binlog 成功后，通知 InnoDB；</p><p>InnoDB 将之前 prepare 状态的 redo log 更新为 <code>&quot;commit&quot;</code> 状态；</p><p>这一步是关键确认步骤，表示事务已完全提交。</p><p>如果 <strong>先写 binlog 再写 redo log</strong>：InnoDB 崩溃了但 binlog 有记录，主从同步出错；</p><p>如果 <strong>只写 redo log，不写 binlog</strong>：主库恢复没问题，但从库根本不会同步这条事务，数据不一致；</p><p>所以必须保证 <strong>redo log 与 binlog 一致性落盘</strong>，2PC 正是为了解决这一问题。</p><h2 id="5-springboot启动类注解"><a href="#5-springboot启动类注解" class="headerlink" title="5.springboot启动类注解"></a>5.springboot启动类注解</h2><p>@SpringBootApplication</p><p>这个注解是 Spring Boot 应用的入口，<strong>是一个组合注解</strong>，等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan</span><br></pre></td></tr></table></figure><p><code>@Configuration</code></p><ul><li>表示这是一个配置类，等同于传统的 <code>applicationContext.xml</code>；</li><li>可在该类中使用 <code>@Bean</code> 定义 Bean。</li></ul><p><code>@EnableAutoConfiguration</code></p><ul><li>开启 Spring Boot 的<strong>自动配置机制</strong>；</li><li>会根据项目依赖的 jar 自动配置 Spring Bean（例如依赖了 spring-boot-starter-web，就会自动配置 Tomcat、Spring MVC 等）；</li><li>可通过 <code>exclude</code> 属性排除某些自动配置类：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableAutoConfiguration(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><br></pre></td></tr></table></figure><p>它通过 <strong><code>SpringFactoriesLoader</code> + SPI机制 + 条件注解</strong>，在启动时动态加载并生效配置类。</p><blockquote><p>@Import(AutoConfigurationImportSelector.class)<br>这个 Import 会触发 Spring 的自动导入机制；</p><p>AutoConfigurationImportSelector 会加载所有自动配置类</p><p>内部使用 <code>SpringFactoriesLoader</code> 加载 <code>spring.factories</code> 文件中所有自动配置类</p><p>每个自动配置类都配合有 <code>@ConditionalOn...</code> 注解，例如：</p><p>Spring 会根据当前 <strong>classpath</strong>、<strong>已有 Bean</strong>、<strong>配置文件内容</strong>等条件判断是否真正加载配置类；</p><p>从而实现了“<strong>按需加载</strong>”的自动配置。</p></blockquote><p>在springboot中约定大于配置，</p><p>约定大于配置是Spring Boot的核心设计理念，它通过<strong>预设合理的默认行为和项目规范</strong>，大幅减少开发者需要手动配置的步骤，从而提升开发效率和项目标准化程度。</p><p>理解 Spring Boot 中的“约定大于配置”原则，可以从以下几个方面来解释：</p><ul><li><strong>自动化配置</strong>：Spring Boot 提供了<strong>大量的自动化配置</strong>，通过分析项目的依赖和环境，自动配置应用程序的行为。开发者无需显式地配置每个细节，大部分常用的配置都已经预设好了。例如，引入<code>spring-boot-starter-web</code>后，Spring Boot会自动配置内嵌Tomcat和Spring MVC，无需手动编写XML。</li><li><strong>默认配置</strong>：Spring Boot 为诸多方面提供<strong>大量默认配置</strong>，如连接数据库、设置 Web 服务器、处理日志等。开发人员无需手动配置这些常见内容，框架已做好决策。例如，默认的日志配置可让应用程序快速输出日志信息，<strong>无需开发者额外繁琐配置日志级别、输出格式与位置等。</strong></li><li><strong>约定的项目结构</strong>：Spring Boot 提倡<strong>特定项目结</strong>构，通常主应用程序类（含 main 方法）置于根包，控制器类、服务类、数据访问类等分别放在相应子包，如<code>com.example.demo.controller</code>放控制器类，<code>com.example.demo.service</code>放服务类等。<strong>此约定使团队成员更易理解项目结构与组织，新成员加入项目时能快速定位各功能代码位置，提升协作效率。</strong></li></ul><p><code>@ComponentScan</code></p><ul><li>扫描当前类所在包及其子包下的所有类，识别注解如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 并注册到 Spring 容器；</li><li>可指定自定义扫描路径：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(basePackages = &#123;&quot;com.example.service&quot;, &quot;com.example.controller&quot;&#125;)</span><br></pre></td></tr></table></figure><p>扫描这个下面的包和他的子类</p><p>常见注解：</p><p><code>@EnableScheduling</code></p><ul><li>开启定时任务支持（配合 <code>@Scheduled</code> 使用）</li></ul><p><code>@EnableAsync</code></p><ul><li>开启异步任务支持（配合 <code>@Async</code> 使用）</li></ul><p><code>@EnableTransactionManagement</code></p><ul><li>开启事务注解支持（如 <code>@Transactional</code>）</li></ul><h2 id="6-BeanFactory-和-FactoryBean-的区别"><a href="#6-BeanFactory-和-FactoryBean-的区别" class="headerlink" title="6.BeanFactory 和 FactoryBean 的区别"></a>6.<code>BeanFactory</code> 和 <code>FactoryBean</code> 的区别</h2><p><code>BeanFactory</code> 是 Spring 容器本身，负责管理所有 Bean；<br> <code>FactoryBean</code> 是你自己定义的 Bean，用来创建其他 Bean。</p><div class="table-container"><table><thead><tr><th>对比点</th><th><code>BeanFactory</code></th><th><code>FactoryBean</code></th></tr></thead><tbody><tr><td>类型</td><td>接口（Spring 顶层 IOC 容器）</td><td>接口（自定义 Bean 的工厂）</td></tr><tr><td>位置</td><td>Spring 框架提供</td><td>用户自定义实现</td></tr><tr><td>作用</td><td>提供获取 Bean 的基础功能，如 <code>getBean()</code></td><td>用于控制某个复杂 Bean 的创建逻辑</td></tr><tr><td>返回对象</td><td>返回注册的原始 Bean 实例</td><td>返回由 <code>getObject()</code> 方法创建的对象</td></tr><tr><td>示例用途</td><td>XML 加载、懒加载场景用到</td><td>MyBatis 中用于创建 Mapper 接口代理</td></tr><tr><td>典型实现类</td><td><code>DefaultListableBeanFactory</code></td><td>用户自定义，如 <code>MyCarFactoryBean</code></td></tr></tbody></table></div><p>1️⃣ <code>BeanFactory</code> 示例（Spring 提供）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory factory = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">UserService userService = factory.getBean(&quot;userService&quot;, UserService.class);</span><br></pre></td></tr></table></figure><ul><li><code>BeanFactory</code> 就是容器，负责“拿 Bean”。</li><li>常用于早期的 XML 配置方式。</li></ul><p><code>FactoryBean</code> 示例（用户自定义）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCarFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Car&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 返回一个自定义创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>, <span class="number">2025</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Car car; <span class="comment">// 实际注入的是 MyCarFactoryBean.getObject() 返回的 Car 实例</span></span><br></pre></td></tr></table></figure><ul><li>Spring 启动时会识别 <code>MyCarFactoryBean</code>，但注入时拿的是 <code>getObject()</code> 的返回值；</li><li>如果你想拿到 <code>FactoryBean</code> 本身，可以用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CarFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> (CarFactoryBean) context.getBean(<span class="string">&quot;&amp;carFactoryBean&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>beanFactory</code> 是 Spring 的底层 IOC 容器接口，提供了 Bean 的获取、懒加载等功能。<br> <code>FactoryBean</code> 是一个用于创建 Bean 的“工厂类”，由我们<strong>自定义创建逻辑</strong>，它本身是一个 Bean，但它返回的对象是 <code>getObject()</code> 产生的。<br> 例如：MyBatis 就是通过 FactoryBean 动态创建 Mapper 接口代理对象。</p><h2 id="7-MyBatis-Mapper-注册过程"><a href="#7-MyBatis-Mapper-注册过程" class="headerlink" title="7.MyBatis Mapper 注册过程"></a>7.MyBatis Mapper 注册过程</h2><p><strong>动态代理、FactoryBean、Configuration 注册流程</strong>的理解</p><p>MyBatis 使用 <code>MapperFactoryBean</code> 将<strong>接口注册为代理对象</strong>，启动时会把接口方法解析成 <code>MappedStatement</code> 存入 Configuration 中，运行时由 <code>MapperProxy</code> 通过反射动态执行 SQL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       XML or <span class="meta">@MapperScan</span></span><br><span class="line">              ↓</span><br><span class="line">  【Mapper接口注册】 → 注册到 Configuration.mapperRegistry</span><br><span class="line">              ↓</span><br><span class="line">  【创建代理类】 MapperProxyFactory → MapperProxy</span><br><span class="line">              ↓</span><br><span class="line">【执行 SQL】 通过 SqlSession 执行对应 MappedStatement</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.@MapperScan 启动时扫描 Mapper 接口</p><p><code>@MapperScan</code> 会注册 <code>MapperScannerConfigurer</code> 或 <code>MapperScannerRegistrar</code>；</p><p>它们会扫描包下所有接口，<strong>对每个接口注册一个 <code>MapperFactoryBean</code> 到 Spring 容器中</strong>。</p><p>2.<strong>每个 Mapper 接口注册成一个 MapperFactoryBean</strong></p><p><strong>MapperFactoryBean</strong> 实现了 Spring 的 <code>FactoryBean</code> 接口；</p><p>它不会直接注入自身，而是调用 <code>getObject()</code> 返回 Mapper 接口的代理类。</p><p>3.MapperProxyFactory 创建代理类</p><p>返回的是一个 <strong>MapperProxy 的动态代理对象</strong>，底层通过 <code>Proxy.newProxyInstance(...)</code> 实现；</p><p>所以你注入的 <code>UserMapper</code> 实际是 MapperProxy 代理类。</p><p>4.代理对象调用方法时执行 SQL</p><p><code>MapperMethod</code> 会查找 <code>Configuration</code> 中注册的 <code>MappedStatement</code>；</p><p>调用 <code>sqlSession.selectOne(...)</code> 或 <code>insert(...)</code> 等执行 SQL；</p><p>SQL 语句和参数映射都来源于 XML 或注解注册的 MappedStatement。</p><p>5.在 <code>SqlSessionFactoryBuilder.build()</code> 构建过程中，MyBatis 会：</p><ul><li>加载 XML 映射文件或注解 Mapper；</li><li>把每个 <code>&lt;mapper&gt;</code> 里的 SQL 语句解析为 <code>MappedStatement</code>；</li><li>调用 <code>Configuration.addMappedStatement()</code> 注册到全局配置里；</li><li>最终保存在 <code>configuration.getMappedStatements()</code> 的 Map 中。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/11/towork/working1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>瑞吉外卖逻辑分析</title>
      <link>https://blog.tokenlen.top/2025/06/10/workmenu/reggie2/</link>
      <guid>https://blog.tokenlen.top/2025/06/10/workmenu/reggie2/</guid>
      <pubDate>Mon, 09 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;业务&quot;&gt;&lt;a href=&quot;#业务&quot; class=&quot;headerlink&quot; title=&quot;业务&quot;&gt;&lt;/a&gt;业务&lt;/h1&gt;&lt;h2 id=&quot;service&quot;&gt;&lt;a href=&quot;#service&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p><strong>ShopServiceImpl：</strong></p><p>使用redis设置和查询店铺的状态。redistemplate.opsforvalue.set/get(key)</p><p><strong>AddressBookServiceImpl:</strong></p><p>新增地址，实体类设置字段的值，然后调用mapper的insert方法。</p><p>修改地址，调用updata调用主键去更新方法更新</p><p>设置默认地址，设置默认地址，然后获取当前用户的id，然后在sql中set用于默认地址,where userid。然后更新默认字段 return</p><p>使用LambdaUpdateWrapper去写一个查询条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 将该用户的所有地址设为非默认</span></span><br><span class="line">LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(AddressBook::getUserId, userId).set(AddressBook::getIsDefault, <span class="number">0</span>);</span><br><span class="line">addressBookMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将当前地址设为默认</span></span><br><span class="line">addressBook.setIsDefault(<span class="number">1</span>);</span><br><span class="line">addressBookMapper.updateById(addressBook);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>CategoryServiceImpl：</strong></p><p>新增菜品，新建菜品的实体类，使用beanuntil，拷贝DTO层数据，然后set状态，然后insert</p><p>分类查询，使用pagehelper插件，=.startpage(num,size);</p><p>然后使用Page&lt;&gt;保证菜品类，然后根据模糊匹配进行搜索，然后mapper调用，然后新建一个分页包装的reseponse返回这个数量和结果。</p><p>根据id删除菜品，先mapper查，然后看dishcount字段是不是关联了菜品，关联套餐不能删除，抛出异常。没有的话，就del删除。</p><p>ReportServiceImpl：</p><p>查询，使用一个map来装这个数据，然后返回数据，传入到mapper中的where/if标签里面一般是。</p><p>Mapper XML 中使用 <code>&lt;if test=&quot;xxx != null&quot;&gt;</code> 拼接 where 条件。</p><p>TOPk,还是使用map，但是加上了连表查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT d.name, SUM(od.number) as total_sales</span><br><span class="line">FROM order_detail od</span><br><span class="line">JOIN dish d ON od.dish_id = d.id</span><br><span class="line">GROUP BY d.id</span><br><span class="line">ORDER BY total_sales DESC</span><br><span class="line">LIMIT #&#123;topK&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>SetmealServiceImpl：</strong></p><p>新增套餐，先新建套餐实体类，拷贝dto数据，插入条数据，获取外键，然后获取关联的菜品，设置外键，然后保存。然后mapper里面使用foreach来遍历填写数据</p><p>分页插件查询。</p><p>批量删除套餐，使用foreach,lamda表达式，通过id查找数据，如果套餐的stuse为1.说明在售卖，不能删除，抛出异常。然后通过id删除套餐表中的数据。删除菜品关系表中的数据。</p><p>套餐的启用和停售，判断套餐内是否有停售菜品，有停售菜品的时候不能启用套餐，</p><p>如果是起售状态的话，直接更新为停售</p><p>修改套餐：</p><p>获取实体类对象，然后拷贝dto，然后更新数据。获取外键，删除套餐和菜品的关联关系。设置新的关系。然后重新插入</p><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>DishController:</p><p>查询的时候，先从redis中根据key来拿数据，查到缓存的话，就直接返回缓存。没有的话，就从数据库中拿，然后存入redis中。</p><p>查询缓存：注解 <code>@Cacheable</code>，用于 <strong>将方法的返回值缓存起来</strong>，提高查询效率，避免重复查数据库。你这段代码的意思是：<strong>按分类 ID 查询套餐，并将结果缓存</strong>，条件是结果不为空。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/10/workmenu/reggie2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql练习3</title>
      <link>https://blog.tokenlen.top/2025/06/09/mysql/sqltest3/</link>
      <guid>https://blog.tokenlen.top/2025/06/09/mysql/sqltest3/</guid>
      <pubDate>Sun, 08 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础语法回顾&quot;&gt;&lt;a href=&quot;#基础语法回顾&quot; class=&quot;headerlink&quot; title=&quot;基础语法回顾&quot;&gt;&lt;/a&gt;基础语法回顾&lt;/h1&gt;&lt;h2 id=&quot;1-SQL110-插入记录（一）&quot;&gt;&lt;a href=&quot;#1-SQL110-插入记录（一）&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础语法回顾"><a href="#基础语法回顾" class="headerlink" title="基础语法回顾"></a>基础语法回顾</h1><h2 id="1-SQL110-插入记录（一）"><a href="#1-SQL110-插入记录（一）" class="headerlink" title="1.SQL110 插入记录（一）"></a>1.<a href="https://www.nowcoder.com/practice/5d2a42bfaa134479afb9fffd9eee970c?tpId=240&amp;tqId=2221797&amp;ru=/exam/oj&amp;qru=/ta/sql-advanced/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page"><strong>SQL110</strong> <strong>插入记录（一）</strong></a></h2><p>牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下：</p><ul><li>用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分；</li><li>用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。</li></ul><p>试卷作答记录表exam_record中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p><div class="table-container"><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Extra</th><th>Default</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>auto_increment</td><td>(NULL)</td><td>自增ID</td></tr><tr><td>uid</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>用户ID</td></tr><tr><td>exam_id</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>试卷ID</td></tr><tr><td>start_time</td><td>datetime</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>开始时间</td></tr><tr><td>submit_time</td><td>datetime</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>提交时间</td></tr><tr><td>score</td><td>tinyint(4)</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>得分</td></tr></tbody></table></div><p>该题最后会通过执行SELECT uid, exam_id, start_time, submit_time, score FROM exam_record;来对比结果</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into exam_record(uid,exam_id,start_time,submit_time,score) </span><br><span class="line">VALUES (1001,9001,&#x27;2021-09-01 22:11:12&#x27;,&#x27;2021-09-01 23:01:12&#x27; ,90),</span><br><span class="line">(1002,9002,&#x27;2021-09-04 07:01:02&#x27;,null,NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照顺序插入即可，注意一一对应</p><p>2.</p><p>牛客的运营同学想要查看大家在SQL类别中高难度试卷的得分情况。</p><p>请你帮她从exam_record数据表中计算所有用户完成SQL类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p><p>示例数据：examination_info（exam_id试卷ID, tag试卷类别, difficulty试卷难度, duration考试时长, release_time发布时间）</p><div class="table-container"><table><thead><tr><th>id</th><th>exam_id</th><th>tag</th><th>difficulty</th><th>duration</th><th>release_time</th></tr></thead><tbody><tr><td>1</td><td>9001</td><td>SQL</td><td>hard</td><td>60</td><td>2020-01-01 10:00:00</td></tr><tr><td>2</td><td>9002</td><td>算法</td><td>medium</td><td>80</td><td>2020-08-02 10:00:00</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">示例数据：exam_record（uid用户ID, exam_id试卷ID, start_time开始作答时间, submit_time交卷时间, score得分）iduidexam_idstart_timesubmit_time</span><br><span class="line">score1100190012020-01-02 09:01:012020-01-02 09:21:01</span><br><span class="line">8021001</span><br><span class="line">9001</span><br><span class="line">2021-05-02 10:01:012021-05-02 10:30:01</span><br><span class="line">81310019001</span><br><span class="line">2021-06-02 19:01:01</span><br><span class="line">2021-06-02 19:31:01</span><br><span class="line">84</span><br><span class="line">410019002</span><br><span class="line">2021-09-05 19:01:01</span><br><span class="line">2021-09-05 19:40:0189</span><br><span class="line">51001</span><br><span class="line">90012021-09-02 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">61001</span><br><span class="line">9002</span><br><span class="line">2021-09-01 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">710029002</span><br><span class="line">2021-02-02 19:01:01</span><br><span class="line">2021-02-02 19:30:01</span><br><span class="line">87810029001</span><br><span class="line">2021-05-05 18:01:01</span><br><span class="line">2021-05-05 18:59:02909</span><br><span class="line">10039001</span><br><span class="line">2021-09-07 12:01:01</span><br><span class="line">2021-09-07 10:31:01</span><br><span class="line">501010049001</span><br><span class="line">2021-09-06 10:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br></pre></td></tr></table></figure><p>根据输入你的查询结果如下：</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT tag, difficulty,</span><br><span class="line">    ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br><span class="line">FROM exam_record</span><br><span class="line">JOIN examination_info USING(exam_id)</span><br><span class="line">WHERE tag = &#x27;SQL&#x27; AND difficulty = &#x27;hard&#x27;</span><br><span class="line">GROUP BY tag, difficulty;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据sql查询的分别出现的列，然后来根据这些列来写</p><p>主要是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br></pre></td></tr></table></figure><p>这个保留一位小数，计算平均数</p><p>然后使用联合查询</p><p>将examination_info和exam_record连接起来，其主键是exam_id</p><p>然后where条件</p><p>最后可以来个按组排序</p><h2 id="2-SQL200-查找最晚入职员工的所有信息"><a href="#2-SQL200-查找最晚入职员工的所有信息" class="headerlink" title="2.SQL200 查找最晚入职员工的所有信息"></a>2.<strong>SQL200</strong> <strong>查找最晚入职员工的所有信息</strong></h2><p>有一个员工employees表简况如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr><tr><td>10002</td><td>1964-06-02</td><td>Bezalel</td><td>Simmel</td><td>F</td><td>1985-11-21</td></tr><tr><td>10003</td><td>1959-12-03</td><td>Parto</td><td>Bamford</td><td>M</td><td>1986-08-28</td></tr><tr><td>10004</td><td>1954-05-01</td><td>Christian</td><td>Koblick</td><td>M</td><td>1986-12-01</td></tr><tr><td>10005</td><td>1955-01-21</td><td>Kyoichi</td><td>Maliniak</td><td>M</td><td>1989-09-12’</td></tr><tr><td>10006</td><td>1953-04-20</td><td>Anneke</td><td>Preusig</td><td>F</td><td>1989-06-02</td></tr><tr><td>10007</td><td>1957-05-23</td><td>Tzvetan</td><td>Zielinski</td><td>F</td><td>1989-02-10</td></tr><tr><td>10008</td><td>1958-02-19</td><td>Saniya</td><td>Kalloufi</td><td>M</td><td>1994-09-15</td></tr><tr><td>10009</td><td>1952-04-19</td><td>Sumant</td><td>Peac</td><td>F</td><td>1985-02-18</td></tr><tr><td>10010</td><td>1963-06-01</td><td>Duangkaew</td><td>Piveteau</td><td>F</td><td>1989-08-24</td></tr><tr><td>10011</td><td>1953-11-07</td><td>Mary</td><td>Sluis</td><td>F</td><td>1990-01-22</td></tr></tbody></table></div><p>请你查找employees里最晚入职员工的所有信息，以上例子输出如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10008</td><td>1958-02-19</td><td>Saniya</td><td>Kalloufi</td><td>M</td><td>1994-09-15</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 1;</span><br></pre></td></tr></table></figure><p>easy题目不必多说。</p><h2 id="3-SQL201-查找入职员工时间升序排名的情况下的倒数第三的员工所有信息"><a href="#3-SQL201-查找入职员工时间升序排名的情况下的倒数第三的员工所有信息" class="headerlink" title="3.SQL201 查找入职员工时间升序排名的情况下的倒数第三的员工所有信息"></a>3.<strong>SQL201</strong> <strong>查找入职员工时间升序排名的情况下的倒数第三的员工所有信息</strong></h2><p>有一个员工employees表简况如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr><tr><td>10002</td><td>1964-06-02</td><td>Bezalel</td><td>Simmel</td><td>F</td><td>1985-11-21</td></tr><tr><td>10003</td><td>1959-12-03</td><td>Parto</td><td>Bamford</td><td>M</td><td>1986-08-28</td></tr><tr><td>10004</td><td>1954-05-01</td><td>Christian</td><td>Koblick</td><td>M</td><td>1986-12-01</td></tr></tbody></table></div><p>请你查找employees里入职员工时间升序排名的情况下倒数第三的员工所有信息，以上例子输出如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr></tbody></table></div><p>注意：可能会存在同一个日期入职的员工，所以入职员工时间排名倒数第三的员工可能不止一个,存在多个员工的情况按照emp_no升序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">DISTINCT</span> hire_date</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span></span><br><span class="line">    limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用子查询，然后去掉倒数第一第二</p><h2 id="4-SQL202-查找当前薪水详情以及部门编号dept-no"><a href="#4-SQL202-查找当前薪水详情以及部门编号dept-no" class="headerlink" title="4.SQL202 查找当前薪水详情以及部门编号dept_no"></a>4.<strong>SQL202</strong> <strong>查找当前薪水详情以及部门编号dept_no</strong></h2><p>有一个全部员工的薪水表salaries简况如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>salary</th><th>from_date</th><th>to_date</th></tr></thead><tbody><tr><td>10001</td><td>88958</td><td>2002-06-22</td><td>9999-01-01</td></tr><tr><td>10002</td><td>72527</td><td>2001-08-02</td><td>9999-01-01</td></tr><tr><td>10003</td><td>43311</td><td>2001-12-01</td><td>9999-01-01</td></tr></tbody></table></div><p>有一个各个部门的领导表dept_manager简况如下:</p><div class="table-container"><table><thead><tr><th>dept_no</th><th>emp_no</th><th>to_date</th></tr></thead><tbody><tr><td>d001</td><td>10001</td><td>9999-01-01</td></tr><tr><td>d002</td><td>10003</td><td>9999-01-01</td></tr></tbody></table></div><p>请你查找各个部门当前领导的薪水详情以及其对应部门编号dept_no，输出结果以salaries.emp_no升序排序，并且请注意输出结果里面dept_no列是最后一列，以上例子输出如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>salary</th><th>from_date</th><th>to_date</th><th>dept_no</th></tr></thead><tbody><tr><td>10001</td><td>88958</td><td>2002-06-22</td><td>9999-01-01</td><td>d001</td></tr><tr><td>10003</td><td>43311</td><td>2001-12-01</td><td>9999-01-01</td><td>d002</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no,e.salary,e.from_date,e.to_date,d.dept_no</span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> e,dept_manager <span class="keyword">as</span> d</span><br><span class="line"><span class="keyword">where</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.emp_no;</span><br></pre></td></tr></table></figure><p>easy的多表查询</p><h2 id="5-SQL42-分析客户逾期情况-middle"><a href="#5-SQL42-分析客户逾期情况-middle" class="headerlink" title="5.SQL42 分析客户逾期情况(middle)"></a>5.<strong>SQL42</strong> <strong>分析客户逾期情况</strong>(middle)</h2><p>有贷款信息表：<strong>loan_tb</strong>（agreement_id：合同id，customer_id：客户id，loan_amount：贷款金额，pay_amount：已还金额，overdue_days：逾期天数）</p><div class="table-container"><table><thead><tr><th>agreement_id</th><th>customer_id</th><th>loan_amount</th><th>pay_amount</th><th>overdue_days</th></tr></thead><tbody><tr><td>10111</td><td>1111</td><td>20000</td><td>18000</td><td>NULL</td></tr><tr><td>10112</td><td>1112</td><td>10000</td><td>10000</td><td>NULL</td></tr><tr><td>10113</td><td>1113</td><td>15000</td><td>10000</td><td>38</td></tr><tr><td>10114</td><td>1114</td><td>50000</td><td>30000</td><td>NULL</td></tr><tr><td>10115</td><td>1115</td><td>60000</td><td>50000</td><td>NULL</td></tr><tr><td>10116</td><td>1116</td><td>10000</td><td>8000</td><td>NULL</td></tr><tr><td>10117</td><td>1117</td><td>50000</td><td>50000</td><td>NULL</td></tr><tr><td>10118</td><td>1118</td><td>25000</td><td>10000</td><td>5</td></tr><tr><td>10119</td><td>1119</td><td>20000</td><td>1000</td><td>106</td></tr></tbody></table></div><p>客户信息表：<strong>customer_tb</strong>（customer_id：客户id，customer_age：客户年龄，pay_ability：还款能力级别）</p><div class="table-container"><table><thead><tr><th>customer_id</th><th>customer_age</th><th>pay_ability</th></tr></thead><tbody><tr><td>1111</td><td>28</td><td>B</td></tr><tr><td>1112</td><td>38</td><td>A</td></tr><tr><td>1113</td><td>20</td><td>C</td></tr><tr><td>1114</td><td>30</td><td>A</td></tr><tr><td>1115</td><td>29</td><td>B</td></tr><tr><td>1116</td><td>21</td><td>C</td></tr><tr><td>1117</td><td>35</td><td>B</td></tr><tr><td>1118</td><td>36</td><td>B</td></tr><tr><td>1119</td><td>25</td><td>C</td></tr></tbody></table></div><p>请根据以上数据分析各还款能力级别的客户逾期情况，按照还款能力级别统计有逾期行为客户占比。要求输出还款能力级别、逾期客户占比。</p><p>注：逾期客户占比要求按照百分数形式输出并四舍五入保留 1 位小数，最终结果按照占比降序排序。</p><p>示例数据结果如下：</p><div class="table-container"><table><thead><tr><th>pay_ability</th><th>overdue_ratio</th></tr></thead><tbody><tr><td>C</td><td>66.7%</td></tr><tr><td>B</td><td>25.0%</td></tr><tr><td>A</td><td>0.0%</td></tr></tbody></table></div><p>结果解释：</p><p>还款能力级别为 C 的客户有1113、1116、1119，其中有逾期行为的客户为 1113、1119，故结果为 2/3=66.7%；其他结果同理。</p><p>我去了，对现在的我还是有些难的啊这个题目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select c.pay_ability,</span><br><span class="line">    concat(format(cast(sum(<span class="keyword">case</span> when l.overdue_days is not <span class="literal">null</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end)as real)*<span class="number">100.0</span>/count(DISTINCT c.customer_id),<span class="number">1</span>),<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"></span><br><span class="line">as overdue_ratio</span><br><span class="line">from customer_tb as c</span><br><span class="line">left join loan_tb as l on c.customer_id=l.customer_id</span><br><span class="line">group by c.pay_ability</span><br><span class="line">order by overdue_ratio desc;</span><br></pre></td></tr></table></figure><p>最主要的就是这个</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(format(<span class="built_in">cast</span>(<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> l.overdue_days <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)<span class="keyword">as</span> <span class="type">real</span>)<span class="operator">*</span><span class="number">100.0</span><span class="operator">/</span><span class="built_in">count</span>(<span class="keyword">DISTINCT</span> c.customer_id),<span class="number">1</span>),<span class="string">&#x27;%&#x27;</span>)</span><br></pre></td></tr></table></figure><p>计算的过程，主要是浮点数的格式话的问题，其他的还好其实。</p><h2 id="6-SQL204-查找所有员工的last-name和first-name以及对应部门编号dept-no"><a href="#6-SQL204-查找所有员工的last-name和first-name以及对应部门编号dept-no" class="headerlink" title="6.SQL204 查找所有员工的last_name和first_name以及对应部门编号dept_no"></a>6.<strong>SQL204</strong> <strong>查找所有员工的last_name和first_name以及对应部门编号dept_no</strong></h2><p>有一个员工表，employees简况如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr><tr><td>10002</td><td>1964-06-02</td><td>Bezalel</td><td>Simmel</td><td>F</td><td>1985-11-21</td></tr><tr><td>10003</td><td>1959-12-03</td><td>Parto</td><td>Bamford</td><td>M</td><td>1986-08-28</td></tr><tr><td>10004</td><td>1954-05-01</td><td>Christian</td><td>Koblick</td><td>M</td><td>1986-12-01</td></tr></tbody></table></div><p>有一个部门表，dept_emp简况如下:</p><div class="table-container"><table><thead><tr><th>emp_no</th><th>dept_no</th><th>from_date</th><th>to_date</th></tr></thead><tbody><tr><td>10001</td><td>d001</td><td>1986-06-26</td><td>9999-01-01</td></tr><tr><td>10002</td><td>d002</td><td>1989-08-03</td><td>9999-01-01</td></tr></tbody></table></div><p>请你查找所有已经分配部门的员工的last_name和first_name以及dept_no，也包括暂时没有分配具体部门的员工，以上例子如下:</p><div class="table-container"><table><thead><tr><th>last_name</th><th>first_name</th><th>dept_no</th></tr></thead><tbody><tr><td>Facello</td><td>Georgi</td><td>d001</td></tr><tr><td>Simmel</td><td>Bezalel</td><td>d002</td></tr><tr><td>Bamford</td><td>Parto</td><td>NULL</td></tr><tr><td>Koblick</td><td>Chirstian</td><td>NULL</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.last_name ,e.first_name ,d.dept_no</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_emp <span class="keyword">as</span> d <span class="keyword">on</span> e.emp_no <span class="operator">=</span> d.emp_no;</span><br></pre></td></tr></table></figure><h2 id="7-SQL46-查询培训指定课程的员工信息"><a href="#7-SQL46-查询培训指定课程的员工信息" class="headerlink" title="7.SQL46 查询培训指定课程的员工信息"></a>7.<strong>SQL46</strong> <strong>查询培训指定课程的员工信息</strong></h2><p>某公司员工信息数据及员工培训信息数据如下：</p><p>员工信息表<strong>staff_tb</strong>(staff_id-员工id，staff_name-员工姓名，staff_gender-员工性别，post-员工岗位类别，department-员工所在部门)，如下所示：</p><div class="table-container"><table><thead><tr><th>staff_id</th><th>staff_name</th><th>staff_gender</th><th>post</th><th>department</th></tr></thead><tbody><tr><td>1</td><td>Angus</td><td>male</td><td>Financial</td><td>dep1</td></tr><tr><td>2</td><td>Cathy</td><td>female</td><td>Director</td><td>dep1</td></tr><tr><td>3</td><td>Aldis</td><td>female</td><td>Director</td><td>dep2</td></tr><tr><td>4</td><td>Lawson</td><td>male</td><td>Engineer</td><td>dep1</td></tr><tr><td>5</td><td>Carl</td><td>male</td><td>Engineer</td><td>dep2</td></tr><tr><td>6</td><td>Ben</td><td>male</td><td>Engineer</td><td>dep1</td></tr><tr><td>7</td><td>Rose</td><td>female</td><td>Financial</td><td>dep2</td></tr></tbody></table></div><p>员工培训信息表<strong>cultivate_tb</strong>(info_id-信息id，staff_id-员工id，course-培训课程)，如下所示：</p><p>注：该公司共开设了三门课程，员工可自愿原则性培训0-3项；</p><div class="table-container"><table><thead><tr><th>info_id</th><th>staff_id</th><th>course</th></tr></thead><tbody><tr><td>101</td><td>1</td><td>course1, course2</td></tr><tr><td>102</td><td>2</td><td>course2</td></tr><tr><td>103</td><td>3</td><td>course1, course3</td></tr><tr><td>104</td><td>4</td><td>course1, course2, course3</td></tr><tr><td>105</td><td>5</td><td>course3</td></tr><tr><td>106</td><td>6</td><td>NULL</td></tr><tr><td>107</td><td>7</td><td>course1, course2</td></tr></tbody></table></div><p>问题：请查询培训课程course3的员工信息？</p><p>注：只要培训的课程中包含course3课程就计入结果</p><p>要求输出：员工id、姓名，按照员工id升序排序；<br>示例数据结果如下：</p><div class="table-container"><table><thead><tr><th>staff_id</th><th>staff_name</th></tr></thead><tbody><tr><td>3</td><td>Aldis</td></tr><tr><td>4</td><td>Lawson</td></tr><tr><td>5</td><td>Carl</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.staff_id,s.staff_name</span><br><span class="line"><span class="keyword">from</span> staff_tb <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> cultivate_tb <span class="keyword">as</span> c <span class="keyword">on</span> s.staff_id<span class="operator">=</span>c.staff_id</span><br><span class="line"><span class="keyword">where</span> concat(<span class="string">&#x27;,&#x27;</span>,c.course,<span class="string">&#x27;,&#x27;</span>) <span class="keyword">like</span> <span class="string">&#x27;%course3%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用分隔符来进行模糊匹配，确保只匹配到course3</p><h2 id="8-SQL43-获取指定客户每月的消费额"><a href="#8-SQL43-获取指定客户每月的消费额" class="headerlink" title="8.SQL43 获取指定客户每月的消费额"></a>8.<strong>SQL43</strong> <strong>获取指定客户每月的消费额</strong></h2><p>某金融公司某项目下有如下 2 张表：</p><p>交易表 <strong>trade</strong>（t_id：交易流水号，t_time：交易时间，t_cus：交易客户，t_type：交易类型【1表示消费，0表示转账】，t_amount：交易金额）:</p><div class="table-container"><table><thead><tr><th>t_id</th><th>t_time</th><th>t_cus</th><th>t_type</th><th>t_amount</th></tr></thead><tbody><tr><td>1</td><td>2022-01-19 03:14:08</td><td>101</td><td>1</td><td>45.0</td></tr><tr><td>2</td><td>2023-02-15 11:22:11</td><td>101</td><td>1</td><td>23.6</td></tr><tr><td>3</td><td>2023-03-19 05:33:22</td><td>102</td><td>0</td><td>350.0</td></tr><tr><td>4</td><td>2023-03-21 06:44:09</td><td>103</td><td>1</td><td>16.9</td></tr><tr><td>5</td><td>2023-02-21 08:44:09</td><td>101</td><td>1</td><td>26.9</td></tr><tr><td>6</td><td>2023-07-07 07:11:45</td><td>101</td><td>1</td><td>1200.0</td></tr><tr><td>7</td><td>2023-07-19 06:04:32</td><td>102</td><td>1</td><td>132.5</td></tr><tr><td>8</td><td>2023-09-19 11:23:11</td><td>101</td><td>1</td><td>130.6</td></tr><tr><td>9</td><td>2023-10-19 04:32:30</td><td>103</td><td>1</td><td>110.0</td></tr></tbody></table></div><p>客户表 <strong>customer</strong>（c_id：客户号，c_name：客户名称）:</p><div class="table-container"><table><thead><tr><th>c_id</th><th>c_name</th></tr></thead><tbody><tr><td>101</td><td>Tom</td></tr><tr><td>102</td><td>Ross</td></tr><tr><td>103</td><td>Julie</td></tr><tr><td>104</td><td>Niki</td></tr></tbody></table></div><p>现需要查询 Tom 这个客户在 2023 年每月的消费金额（按月份正序显示），示例如下：</p><div class="table-container"><table><thead><tr><th>time</th><th>total</th></tr></thead><tbody><tr><td>2023-02</td><td>50.5</td></tr><tr><td>2023-07</td><td>1200.0</td></tr><tr><td>2023-09</td><td>130.6</td></tr></tbody></table></div><p>请编写 SQL 语句实现上述需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">    <span class="title function_">DATE_FORMAT</span><span class="params">(t.t_time, <span class="string">&#x27;%Y-%m&#x27;</span>)</span> AS time,</span><br><span class="line">    SUM(t.t_amount) AS total</span><br><span class="line">from</span><br><span class="line">    trade as t</span><br><span class="line">    left join customer as c on t.t_cus = c.c_id</span><br><span class="line">where</span><br><span class="line">    c.c_name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    AND t.t_type = <span class="number">1</span></span><br><span class="line">    AND <span class="title function_">YEAR</span><span class="params">(t.t_time)</span> = <span class="number">2023</span></span><br><span class="line">GROUP BY</span><br><span class="line">    <span class="title function_">DATE_FORMAT</span><span class="params">(t.t_time, <span class="string">&#x27;%Y-%m&#x27;</span>)</span></span><br><span class="line">ORDER BY</span><br><span class="line">    time;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-查询连续入住多晚的客户信息？"><a href="#9-查询连续入住多晚的客户信息？" class="headerlink" title="9.查询连续入住多晚的客户信息？"></a>9.<strong>查询连续入住多晚的客户信息？</strong></h2><p>某酒店客房信息数据及某晚入住信息数据如下：</p><p>客房信息表<strong>guestroom_tb</strong>(room_id-房间号,room_type-房间类型,room_price-房间价格)，如下所示：</p><div class="table-container"><table><thead><tr><th>room_id</th><th>room_type</th><th>room_price</th></tr></thead><tbody><tr><td>1001</td><td>商务标准房</td><td>165</td></tr><tr><td>1002</td><td>家庭套房</td><td>376</td></tr><tr><td>1003</td><td>商务单人房</td><td>100</td></tr><tr><td>1004</td><td>商务单人房</td><td>100</td></tr><tr><td>1005</td><td>商务标准房</td><td>165</td></tr><tr><td>1006</td><td>商务单人房</td><td>100</td></tr><tr><td>1007</td><td>商务标准房</td><td>165</td></tr><tr><td>1008</td><td>家庭套房</td><td>365</td></tr><tr><td>1009</td><td>商务标准房</td><td>165</td></tr></tbody></table></div><p>入住信息表<strong>checkin_tb</strong>(info_id-信息id.room_id-房间号,user_id-客户id,checkin_time-入住时间,checkout_time-退房时间)，</p><p>该表存储该晚客户入住信息及后续退房信息，如下所示：</p><div class="table-container"><table><thead><tr><th>info_id</th><th>room_id</th><th>user_id</th><th>checkin_time</th><th>checkout_time</th></tr></thead><tbody><tr><td>1</td><td>1001</td><td>201</td><td>2022-06-12 15:00:00</td><td>2022-06-13 09:00:00</td></tr><tr><td>2</td><td>1001</td><td>202</td><td>2022-06-12 15:00:00</td><td>2022-06-13 09:00:00</td></tr><tr><td>3</td><td>1003</td><td>203</td><td>2022-06-12 14:00:00</td><td>2022-06-14 08:00:00</td></tr><tr><td>4</td><td>1004</td><td>204</td><td>2022-06-12 15:00:00</td><td>2022-06-13 11:00:00</td></tr><tr><td>5</td><td>1007</td><td>205</td><td>2022-06-12 16:00:00</td><td>2022-06-15 12:00:00</td></tr><tr><td>6</td><td>1008</td><td>206</td><td>2022-06-12 19:00:00</td><td>2022-06-13 12:00:00</td></tr><tr><td>7</td><td>1008</td><td>207</td><td>2022-06-12 19:00:00</td><td>2022-06-13 12:00:00</td></tr><tr><td>8</td><td>1009</td><td>208</td><td>2022-06-12 20:00:00</td><td>2022-06-16 09:00:00</td></tr></tbody></table></div><p>问题：请查询该酒店从6月12日开始连续入住多晚的客户信息？要求输出：客户id、房间号、房间类型、连续入住天数（按照连续入住天数的升序排序，再按照房间号的升序排序，再按照客户id的降序排序）示例数据结果如下：user_idroom_idroom_typedays2031003商务单人房22051007商务标准房32081009商务标准房4解释：以客户203为例，在2022-06-12入住酒店，在2022-06-14退房，连续在12日晚、13日晚入住在该酒店，故结果如上；其他结果同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select c.user_id,c.room_id,g.room_type,</span><br><span class="line">datediff(c.checkout_time, c.checkin_time) as days</span><br><span class="line">from guestroom_tb as g</span><br><span class="line">join checkin_tb as c on g.room_id = c.room_id</span><br><span class="line">where <span class="title function_">date</span><span class="params">(c.checkin_time)</span> =<span class="string">&#x27;2022-06-12&#x27;</span> </span><br><span class="line">and <span class="title function_">datediff</span><span class="params">(c.checkout_time, c.checkin_time)</span>&gt;=<span class="number">2</span></span><br><span class="line">order by days ASC,c.room_id,c.user_id desc;</span><br></pre></td></tr></table></figure><p>这个题目主要是时间函数的使用</p><h2 id="10-SQL45-统计所有课程参加培训人次"><a href="#10-SQL45-统计所有课程参加培训人次" class="headerlink" title="10.SQL45 统计所有课程参加培训人次"></a>10.<strong>SQL45</strong> <strong>统计所有课程参加培训人次</strong></h2><p>某公司员工培训信息数据如下：</p><p>员工培训信息表<strong>cultivate_tb</strong>(info_id-信息id,staff_id-员工id,course-培训课程)，如下所示：</p><p>注：该公司共开设了三门课程，员工可自愿原则性培训0-3项，每项课程每人可培训1次。</p><div class="table-container"><table><thead><tr><th>info_id</th><th>staff_id</th><th>course</th></tr></thead><tbody><tr><td>101</td><td>1</td><td>course1,course2</td></tr><tr><td>102</td><td>2</td><td>course2</td></tr><tr><td>103</td><td>3</td><td>course1,course3</td></tr><tr><td>104</td><td>4</td><td>course1,course2,course3</td></tr><tr><td>105</td><td>5</td><td>course3</td></tr><tr><td>106</td><td>6</td><td>NULL</td></tr><tr><td>107</td><td>7</td><td>course1,course2</td></tr></tbody></table></div><p>问题：请统计该公司所有课程参加培训人次？</p><p>示例数据结果如下：</p><div class="table-container"><table><thead><tr><th>staff_nums</th></tr></thead><tbody><tr><td>11</td></tr></tbody></table></div><p>解释：course1课程共有员工1、3、4、7共4名员工培训；</p><p>course2课程共有员工1、2、4、7共4名员工培训；</p><p>course3课程共有员工3、4、5共3名员工培训。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    <span class="title function_">SUM</span><span class="params">(CONCAT(<span class="string">&#x27;,&#x27;</span>, c.course, <span class="string">&#x27;,&#x27;</span>)</span> LIKE <span class="string">&#x27;%,course1,%&#x27;</span>) +</span><br><span class="line">    SUM(CONCAT(<span class="string">&#x27;,&#x27;</span>, c.course, <span class="string">&#x27;,&#x27;</span>) LIKE <span class="string">&#x27;%,course2,%&#x27;</span>) +</span><br><span class="line">    SUM(CONCAT(<span class="string">&#x27;,&#x27;</span>, c.course, <span class="string">&#x27;,&#x27;</span>) LIKE <span class="string">&#x27;%,course3,%&#x27;</span>) AS staff_nums</span><br><span class="line">FROM </span><br><span class="line">    cultivate_tb c;</span><br></pre></td></tr></table></figure><p>更具性价比的方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/09/mysql/sqltest3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>shopping项目文档面试八股</title>
      <link>https://blog.tokenlen.top/2025/06/07/doc/shopping-mengnankk/</link>
      <guid>https://blog.tokenlen.top/2025/06/07/doc/shopping-mengnankk/</guid>
      <pubDate>Fri, 06 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;JWT-双token-双拦截器登录校验&quot;&gt;&lt;a href=&quot;#JWT-双token-双拦截器登录校验&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="JWT-双token-双拦截器登录校验"><a href="#JWT-双token-双拦截器登录校验" class="headerlink" title="JWT+双token+双拦截器登录校验"></a>JWT+双token+双拦截器登录校验</h1><p>项目文件:</p><p>JwtConfig.java JWT配置类</p><p>SecurityConfig.java 安全请求放行文件</p><p>UserController.java controller请求层</p><p>JwtAuthenticationFilter.java JWT过滤器</p><p>UserServiceImpl.java 具体的方法实现</p><h1 id="swagger文档"><a href="#swagger文档" class="headerlink" title="swagger文档"></a>swagger文档</h1><h1 id="优惠劵"><a href="#优惠劵" class="headerlink" title="优惠劵"></a>优惠劵</h1><h1 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h1><h1 id="redis限流"><a href="#redis限流" class="headerlink" title="redis限流"></a>redis限流</h1>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/07/doc/shopping-mengnankk/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库原理期末考试复习</title>
      <link>https://blog.tokenlen.top/2025/06/07/lastteam/sqltest/</link>
      <guid>https://blog.tokenlen.top/2025/06/07/lastteam/sqltest/</guid>
      <pubDate>Fri, 06 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;关系代数&quot;&gt;&lt;a href=&quot;#关系代数&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>关系代数就是：一种抽象的查询语言用对关系的运算来表达查询</p><p>关系看上去像一张二维表，每个表由行和列组成</p><p>行代表一个元组，即<strong>数据记录</strong>。列代表属性，即<strong>字段</strong></p><p>关系的域为一组原子值（不可再分割的值）</p><p>关系中的元组必须各不相同（元组的唯一性）</p><h3 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h3><p>元组 t 与 t[Ai] ：</p><p>t 就是一行数据，t[Ai] 就是这一行中某一列的值。</p><p>假设表 R 结构是：</p><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>101</td><td>张三</td><td>20</td></tr></tbody></table></div><ul><li>这一行是一个元组 t。</li><li><code>t[学号] = 101</code>，<code>t[姓名] = 张三</code>，<code>t[年龄] = 20</code></li></ul><p>属性组 A、t[A]、Ā ：</p><p>表 R：</p><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th><th>班级</th></tr></thead><tbody><tr><td>101</td><td>张三</td><td>20</td><td>A1</td></tr></tbody></table></div><ul><li>如果我们说 A = {学号, 姓名}，那：<ul><li><code>t[A] = (101, 张三)</code></li><li>Ā = {年龄, 班级}</li></ul></li></ul><p>元组连接 tr ⨝ ts ：</p><p>表 R（学生）：</p><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th></tr></thead><tbody><tr><td>101</td><td>张三</td></tr></tbody></table></div><p>表 S（成绩）：</p><div class="table-container"><table><thead><tr><th>课程</th><th>成绩</th></tr></thead><tbody><tr><td>数学</td><td>95</td></tr></tbody></table></div><p>将 <code>tr ∈ R</code> 和 <code>ts ∈ S</code> 连接（拼接）起来：</p><p>→ 结果元组为：</p><div class="table-container"><table><thead><tr><th>学号</th><th>姓名</th><th>课程</th><th>成绩</th></tr></thead><tbody><tr><td>101</td><td>张三</td><td>数学</td><td>95</td></tr></tbody></table></div><p>象集 Zx：</p><p>表 R：</p><div class="table-container"><table><thead><tr><th>班级</th><th>姓名</th><th>成绩</th></tr></thead><tbody><tr><td>A1</td><td>张三</td><td>90</td></tr><tr><td>A1</td><td>李四</td><td>85</td></tr><tr><td>B1</td><td>王五</td><td>88</td></tr></tbody></table></div><ul><li>X = {班级}，Z = {姓名}</li><li>那么 A1 班的象集 Zx 是：</li></ul><p>→ <code>Zx = &#123;张三, 李四&#125;</code></p><p>意思是：在班级是 A1 时，姓名有哪些？这就是象集。</p><h3 id="五种基本运算"><a href="#五种基本运算" class="headerlink" title="五种基本运算"></a>五种基本运算</h3><p>并，差，笛卡尔积，选择，投影</p><p>关系代数是用对关系的运算来表达查询，这个时候可以使用关系代数解释器来模拟关系代数。</p><p>其中否定操作要使用差的形式</p><h4 id="并"><a href="#并" class="headerlink" title="并"></a>并</h4><p>运算符<strong>∪</strong></p><p>并运算将两个关系的所有元组合并为一个新关系，前提是两个关系必须有<strong>相同的属性</strong>（列），且每个元组在结果中只出现一次（去重）。</p><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>3</td><td><strong>4</strong></td></tr></tbody></table></div><p><code>R1 ∪ R2</code> 的结果是：s</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table></div><p>相当于<strong>增加行</strong> </p><h4 id="差"><a href="#差" class="headerlink" title="差"></a>差</h4><p><strong>运算符</strong>：<code>-</code></p><p>差运算<strong>返回一个关系中有而另一个关系中没有的元组</strong>，前提是两个关系有相同的属性。</p><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table></div><p><code>R1 - R2</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr></tbody></table></div><p>相当于<strong>删减行</strong></p><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p><strong>运算符</strong>：<code>×</code></p><p>笛卡尔积运算将两个关系中的每一对元组组合成一个新的元组，其中一个关系的所有元组与另一个关系的每个元组组合形成一个新的元组。它的结果是一个新关系，包含了<strong>两个关系中所有属性的组合</strong>。</p><p><strong>两个集合相乘的结果</strong></p><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(C, D)  </p><div class="table-container"><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p><code>R1 × R2</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td><td>6</td></tr><tr><td>1</td><td>2</td><td>7</td><td>8</td></tr><tr><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>3</td><td>4</td><td>7</td><td>8</td></tr></tbody></table></div><p>相当于<strong>增加列</strong></p><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p><strong>运算符</strong>：<code>σ</code></p><p>选择运算用于从关系中选择满足特定条件的元组。选择操作是一种<strong>过滤</strong>操作，它根据指定的条件返回满足条件的元组。</p><p>R(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p><code>σ(A &gt; 4)(R)</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p>相当于<strong>过滤</strong></p><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p><strong>运算符</strong>：<code>π</code></p><p>投影运算用于从关系中选择指定的列（属性）。它会<strong>返回包含指定列的所有元组，并且会去除重复的元组</strong>。</p><p>R(A, B, C)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p><code>π(A, B)(R)</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>4</td><td>5</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p>相当于<strong>删减列</strong></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p><strong>运算符</strong>：<code>⨝</code></p><p>连接是将两个关系中的元组按照某些共享的属性进行组合，生成新的元组。它是关系代数中非常重要的运算，因为它能够合并来自不同表的数据。连接运算通常是基于一个公共的列（或多个列）进行的。</p><p><strong>自然连接（Natural Join）</strong>：在自然连接中，连接操作自动寻找两个关系中相同名称的列，并将它们作为连接条件。<strong>自然连接将仅返回匹配的元组，并去除重复的列。</strong>相当于内连接</p><p><strong>等值连接（Equi-Join）</strong>：等值连接是指使用等号（<code>=</code>）作为连接条件，将两个关系中某个或某些列的值相等的元组合并。</p><p><strong>外连接（Outer Join）</strong>：外连接除了返回两个关系中匹配的元组外，还会保留在其中一个关系中没有匹配的元组，并用<code>NULL</code>填充缺失的值。外连接有三种类型：</p><ul><li><strong>左外连接（Left Outer Join）</strong>：返回左表中所有元组，以及右表中匹配的元组。<strong>右边的补充null</strong></li><li><strong>右外连接（Right Outer Join）</strong>：返回右表中所有元组，以及左表中匹配的元组。<strong>左边的补充null</strong></li><li><strong>全外连接（Full Outer Join）</strong>：返回两个表中的所有元组，不论它们是否匹配。都补充null</li></ul><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(B, C)  </p><div class="table-container"><table><thead><tr><th>B</th><th>C</th></tr></thead><tbody><tr><td>2</td><td>5</td></tr><tr><td>4</td><td>6</td></tr></tbody></table></div><p>如果我们进行自然连接：<code>R1 ⨝ R2</code>，连接条件是属性<code>B</code>，结果会是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td></tr><tr><td>3</td><td>4</td><td>6</td></tr></tbody></table></div><h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><p><strong>运算符</strong>：<code>÷</code></p><p>除操作用于解决“对于所有”这种类型的查询问题，通常用于查找在某个关系中与所有其他元组匹配的元组。除运算的结果是返回那些“<strong>满足某个条件的所有值</strong>”的元组。</p><p>R1(Student, Course)  </p><div class="table-container"><table><thead><tr><th>Student</th><th>Course</th></tr></thead><tbody><tr><td>Alice</td><td>Math</td></tr><tr><td>Alice</td><td>English</td></tr><tr><td>Bob</td><td>Math</td></tr><tr><td>Bob</td><td>History</td></tr><tr><td>Charlie</td><td>Math</td></tr></tbody></table></div><p>R2(Course)  </p><div class="table-container"><table><thead><tr><th>Course</th></tr></thead><tbody><tr><td>Math</td></tr><tr><td>English</td></tr></tbody></table></div><p><code>R1 ÷ R2</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>Student</th></tr></thead><tbody><tr><td>Alice</td></tr></tbody></table></div><p>相当于<strong>找到某值</strong></p><h2 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h2><p>E-R图向关系模型的转换<br>转换内容<br>E-R图由<strong>实体型、实体的属性和实体型之间的联系</strong>三个要素组成<br>关系模型的逻辑结构是一组关系模式的集合<br>将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式</p><div class="table-container"><table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody><tr><td><strong>实体（Entity）</strong></td><td>用矩形表示，转换为一个<strong>关系（表）</strong></td></tr><tr><td><strong>属性（Attribute）</strong></td><td>用椭圆表示，转换为<strong>字段（列）</strong></td></tr><tr><td><strong>联系（Relationship）</strong></td><td>用菱形表示，转换为表或外键，依赖于联系的<strong>类型</strong></td></tr></tbody></table></div><p>E-R 图信息：</p><ul><li>实体：学生(Student)：SID, Name</li><li>实体：课程(Course)：CID, Title</li><li>关系：选修(Takes)，多对多，属性：成绩(Grade)</li></ul><p>转换关系模型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student(SID <span class="keyword">PRIMARY</span> KEY, Name)</span><br><span class="line">Course(CID <span class="keyword">PRIMARY</span> KEY, Title)</span><br><span class="line">Takes(SID <span class="keyword">FOREIGN</span> KEY, CID <span class="keyword">FOREIGN</span> KEY, Grade, <span class="keyword">PRIMARY</span> KEY(SID, CID))</span><br></pre></td></tr></table></figure><p>在E-R图中，i代表弱实体</p><h2 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h1 id="重点题目"><a href="#重点题目" class="headerlink" title="重点题目"></a>重点题目</h1><h2 id="关系代数-1"><a href="#关系代数-1" class="headerlink" title="关系代数"></a>关系代数</h2><p>做关系代数的题目的时候</p><p>投影等于select 需要筛选出来的列，然后选择是去做where的条件的</p><p>一般都是先用总的连接起来的大表去除select的小表，然后再进行筛选</p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><div class="table-container"><table><thead><tr><th>概念</th><th>定义</th></tr></thead><tbody><tr><td><strong>关系（Relation）</strong></td><td>一张二维表，表名表示关系名。</td></tr><tr><td><strong>属性（Attribute）</strong></td><td>表中的一列，表示一个字段或特征，对应关系模型中的“列”。</td></tr><tr><td><strong>元组（Tuple）</strong></td><td>表中的一行，表示一个实体或记录，对应关系模型中的“行”。</td></tr><tr><td><strong>域（Domain）</strong></td><td>每个属性值的取值范围。例如：性别字段的域是 {男, 女}，年龄的域是整数 [0, 120]。</td></tr><tr><td><strong>主码（Primary Key）</strong></td><td>表中<strong>唯一标识元组的属性集合</strong>，要求唯一且非空。例如：学生表的学号、员工表的工号。</td></tr></tbody></table></div><p>1.关于系、学生、班级、学会等信息的关系数据库设计</p><div class="table-container"><table><thead><tr><th>关系名</th><th>属性</th></tr></thead><tbody><tr><td>学生 S(SNO, SN, SB, DN, CNO, SA)</td><td>学号、姓名、出生年月、系名、班号、宿舍区</td></tr><tr><td>班级 C(CNO, CS, DN, CNUM, CDATE)</td><td>班号、专业名、系名、人数、入校年份</td></tr><tr><td>系 D(DNO, DN, DA, DNUM)</td><td>系号、系名、办公室地点、人数</td></tr><tr><td>学会 P(PN, DATE1, PA, PNUM)</td><td>学会名、成立时间、地点、人数</td></tr><tr><td>学生-学会 SP(SNO, PN, DATE2)</td><td>学号、学会名、入会年份</td></tr></tbody></table></div><p>有关语义如下：一个系有若干专业，每个专业每年只招一个班，每个班有若干学生。一个系的学生住在同一宿舍区。每个学生可参加若干学会，每个学会有若干学生。学生参加某学会有一个入会年份。</p><p>极小依赖集：学生表，Sno-&gt;Sn,SN,DN</p><p>DN-&gt;SA CNO-&gt;DN</p><p>所以传递依赖为Sno-&gt;SA</p><p>班级表：</p><p>CNO-&gt;CS,CNUM,CDATE</p><p>CS-&gt;DN</p><p>(CS,CDATE)-&gt;CNO</p><p><code>(CS, CDATE) → CNO</code> 是<strong>完全函数依赖</strong></p><p>系表：</p><p>DNO-&gt;DN,DNUM DA DN-&gt;DNO</p><p>学会表:</p><p>PN-&gt;确定剩下的那三</p><p>学生-学会:</p><p>(SNO,PN)-&gt;DATE2</p><p>2.关系模式R(U,F)中：U= ABCDE, F={AD→BC,B→C }<br>求：<br>(1) F的最小函数依赖集<br>(2) R的候选码<br>（3）R达到第几范式，为什么？<br>（4）将其转换为3NF（写明分解后各关系模式的侯选码，外码）</p><p><strong>最小依赖集需要满足三点：</strong></p><ul><li>每个依赖右边只有一个属性（右部<strong>原子化</strong>）</li><li>左部不能约简（<strong>左部最小</strong>）</li><li>没有冗余依赖（<strong>去冗余</strong>）</li></ul><p>Fmin = { AD → B, B → C }</p><p>就是先拆分，然后去掉一个重复的</p><p>找出那些属性集的闭包等于全体属性 {A, B, C, D, E}<br> <strong>候选码定义：闭包等于所有属性，且不能再删属性</strong></p><p>候选码是 {A, D, E}</p><p>感觉这个就是最小依赖集加上那个不在的就是候选码</p><p>R 属于第几范式？为什么？：</p><p>先列出最小依赖集：Fmin = { AD → B, B → C }</p><p>然后看候选码，{A, D, E}</p><p>发现最小依赖集里面有个不在候选码的，所以只是符合1NF,1NF就是最小依赖集</p><p>分解为 3NF（说明每个子关系的候选码和外键）：</p><p>也是根据候选码跟最小依赖集决定的</p><div class="table-container"><table><thead><tr><th>子关系</th><th>属性</th><th>候选码</th><th>外键说明</th></tr></thead><tbody><tr><td>R1</td><td>A, D, B</td><td>AD</td><td>AD 是外键指向 R3</td></tr><tr><td>R2</td><td>B, C</td><td>B</td><td>B 是外键指向 R1/R3</td></tr><tr><td>R3</td><td>A, D, E</td><td>ADE</td><td>无</td></tr></tbody></table></div><p>就是分开的最小依赖集+候选码</p><p>关系 R(A, B, C, D, E) 的函数依赖分析:</p><p>是一种 <strong>比 3NF 更严格的数据库规范化形式</strong>，主要用于<strong>消除函数依赖引起的冗余</strong>，保证关系模式的设计更加规范。</p><p>任何一个决定因素（左部）都<strong>必须是超码</strong>(是或者包含候选码)，否则就不满足 BCNF。</p><p>若 A 是候选码，BC → DE，什么条件下 R 是 BCNF？</p><p>当 <code>BC</code> 是（或包含）候选码时，<code>BC → DE</code> 才不违反 BCNF。</p><p>如果存在依赖：A-→B，BC-→D，DE-&gt;A，列出R的所有码：</p><p>闭包：</p><p>A⁺ = {A, B}</p><p>BC⁺ = {B, C, D}</p><p>DE⁺ = {D, E, A, B} （由 DE → A → B）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCE⁺ = &#123;B, C, E&#125; → D → A → 全部</span><br><span class="line">ACE⁺ = A → B，C，E，D → 全部</span><br></pre></td></tr></table></figure><p>所以候选码有：<strong>ACE</strong>, <strong>BCE</strong>, <strong>DEC</strong></p><p>如果存在依赖：A-→B，BC-&gt;D，DE→A，R属手3NF还是BCNF：</p><p>A {A B}</p><p>BC {B C D}</p><p>DE {A B D E}</p><p>所有依赖左部（A, BC, DE）都不包含候选码<strong>但其右部都为主属性</strong></p><p>所有属性均出现在候选码中 ⇒ 都是主属性</p><h2 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h2><p>1.什么是数据库的安全性:</p><p>数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。数据库的安全性指的是防止<strong>未经授权的访问与操作</strong>，确保数据不会被非法读取、修改、删除或破坏。</p><p>2.表结构如下：</p><p>学生(学号, 姓名, 年龄, 性别, 家庭住址, 班级号)<br>班级(班级号, 班级名, 班主任, 班长)</p><p>授予用户 <code>U1</code> 对两个表拥有<strong>全部权限</strong>，并允许其<strong>再授权</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileger <span class="keyword">on</span> 学生 <span class="keyword">to</span> U1 <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> 班级 <span class="keyword">TO</span> U1 <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>grant all privileger on 学生 to U1 with grant option</p><p>授予用户2</p><ul><li>对 <strong>学生表</strong>具有<strong>查询权限</strong></li><li>对字段 <strong>家庭住址</strong> 具有<strong>更新权限</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grant select on 学生 to U2;</span><br><span class="line">grant update(家庭住址) on 学生 to U2;</span><br><span class="line">GRANT SELECT ON 学生 TO U2;</span><br><span class="line">GRANT UPDATE (家庭住址) ON 学生 TO U2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>授予<strong>所有用户</strong>对班级表的<strong>查询权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on 班级 to public;</span><br></pre></td></tr></table></figure><p>授予角色 <code>R1</code> 对学生表的<strong>查询和更新权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select,update on 学生 to R1;</span><br></pre></td></tr></table></figure><p>将角色 <code>R1</code> 授予用户 <code>U1</code>，并允许 <code>U1</code> 再授权该角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant R1 to U1 with admin option;</span><br></pre></td></tr></table></figure><h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><p>1.什么是数据库的完整性</p><p>数据库的完整性是指数据的正确性和相容性,<strong>正确性、一致性和可靠性</strong>。它保证数据库中的数据符合逻辑规则、业务约束。</p><p>2.数据库的完整性和数据库的安全性有什么区别和联系？</p><p>答：数据的完整性和安全性是两个不同的概念，但是有一定的联系。前者是为了<strong>防止数据库中存在不符合语义的数据</strong>，防止错误信息的输入和输出，即所谓垃圾进垃圾出（Garbage InGarbageOut）所造成的无效操作和错误结果：后者是保护数据库防止恶意的破坏和非法的</p><p>3.有下面的这些消息完成下面的问题：</p><ol><li><strong>职工</strong>（职工号，姓名，年龄，职务，工资，部门号）<ul><li>其中 <strong>职工号</strong> 为主码</li></ul></li><li><strong>部门</strong>（部门号，名称，经理名，电话）<ul><li>其中 <strong>部门号</strong> 为主码</li></ul></li></ol><p>请用 <strong>SQL</strong> 语言定义这两个关系模式，并在定义中完成以下<strong>完整性约束条件</strong>：</p><ol><li>定义每个关系模式的 <strong>主码</strong></li><li>定义 <strong>参照完整性约束</strong>（即外键约束）</li><li>要求职工的 <strong>年龄不得超过60岁</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">crete table dept（</span><br><span class="line">Deptno  NUMBER(2) PRIMARY KEY, </span><br><span class="line">Deptname varchar(10),</span><br><span class="line">Deptmannger varchar(10),</span><br><span class="line">DeptPhone char(12)</span><br><span class="line">）;</span><br><span class="line">crete table Emp(</span><br><span class="line">EMPno NUMBER(2) PRIMART KEY,</span><br><span class="line">EMPname varchar(10),</span><br><span class="line">EMPage NUMBER(2),</span><br><span class="line">EMPjob varchar(10),</span><br><span class="line">EMPSALE NUMBER(7,2),</span><br><span class="line">DeptNO NUMBER(2),</span><br><span class="line"></span><br><span class="line">constartint c1 check (EMPage&lt;=60),</span><br><span class="line">constartint FK_DEPTNO foreign key (deptno) references dept(Deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h2><p>1.试述事务的概念及事务的4个特性。恢复技术能保证事务的哪些特性？</p><p>ACID：</p><p>原子性，一致性，隔离性，持久性</p><p>原子性：事务的方法要么全部执行，要么全部不执行回滚</p><p>一致性：事务操作前后，数据库保持一致性</p><p>隔离性：多个事务并发的时候，相互不干扰</p><p>持久性：事务一旦<strong>提交成功</strong>，对数据库的变更就是<strong>永久性的</strong>，即使系统崩溃也不会丢失。</p><p>故障恢复保证了原子性和持久性</p><p>2.事务的回滚和重做</p><p><strong>已提交事务 → 需要重做（Redo）</strong></p><p><strong>未提交事务 → 需要回滚（Undo）</strong></p><div class="table-container"><table><thead><tr><th>日志序号</th><th>内容</th><th>事务状态变化</th></tr></thead><tbody><tr><td>1</td><td>T1 开始</td><td>T1 active</td></tr><tr><td>2</td><td>T1 写 A=10</td><td></td></tr><tr><td>3</td><td>T2 开始</td><td>T2 active</td></tr><tr><td>4</td><td>T2 写 B=9</td><td></td></tr><tr><td>5</td><td>T1 写 C=11</td><td></td></tr><tr><td>6</td><td>T1 提交</td><td>✅ T1 committed</td></tr><tr><td>7</td><td>T2 写 C=13</td><td></td></tr><tr><td>8</td><td>T3 开始</td><td>T3 active</td></tr><tr><td>9</td><td>T3 写 A=8</td><td></td></tr><tr><td>10</td><td>T2 回滚</td><td>❌ T2 aborted</td></tr><tr><td>11</td><td>T3 写 B=7</td><td></td></tr><tr><td>12</td><td>T4 开始</td><td>T4 active</td></tr><tr><td>13</td><td>T3 提交</td><td>✅ T3 committed</td></tr><tr><td>14</td><td>T4 写 C=12</td></tr></tbody></table></div><p>回滚就是不提交，提交了才算修改</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一、数据库系统的三级模式结构（3分）</p><ul><li><strong>外模式（子模式）：</strong> 用户视图，描述用户可以看到和操作的数据子集。</li><li><strong>概念模式：</strong> 整个数据库的逻辑结构，对所有用户共享。</li><li><strong>内模式：</strong> 数据在数据库内部的物理存储方式。</li></ul><p>二、关系的三类完整性约束（3分）</p><ul><li><strong>实体完整性：</strong> 主键不能为空。</li><li><strong>参照完整性：</strong> 外键取值必须为另一个关系中某主键的值，或为空。</li><li><strong>用户定义完整性：</strong> 用户根据实际需求定义的其他约束条件（如取值范围、格式等）。</li></ul><p>三、存取控制的两种常用方法（4分）</p><ul><li><strong>自主存取控制（DAC）：</strong> 用户拥有并控制自己数据的访问权限。</li><li><strong>强制存取控制（MAC）：</strong> 系统根据策略统一控制访问，用户无法更改。</li></ul><p>四、游标的作用（3分）</p><ul><li>游标用于<strong>逐行处理</strong>查询结果，适用于需要逐条处理数据的场景，如分页、逐行更新等。</li></ul><p>五、查询优化的两种分类（4分）</p><ol><li><strong>基于规则的优化（规则驱动）：</strong> 应用一系列优化规则（如选择操作下推、连接重排序）重写 SQL。</li><li><strong>基于代价的优化（代价驱动）：</strong> 枚举多种执行计划并估算代价，选择最优计划。</li></ol><p>六、冲突可串行化调度判断示例</p><p>调度：<code>r2(A) w1(B) w2(A) r3(A) wi(B) w3(A) r2(B) w2(B)</code></p><ul><li>通过构建<strong>冲突图</strong>，若该图<strong>无环</strong>，则调度是<strong>冲突可串行化的</strong>。</li></ul><p>七、关系模式分解与范式问题</p><p>问题：关系模式 R(U,F)，U={A,B,C,D,E,G}，F={BG→C,BD→E,DG→C,ADG→BC,AG→B,B→D}，进行 BCNF 分解</p><ol><li>最小函数依赖集：<ul><li>F’ = {BG→C, BD→E, DG→C, AG→B, B→D}（ADG→BC 冗余）</li></ul></li><li>候选码：AG</li><li>不满足 BCNF 的依赖：BG→C，BD→E，DG→C，B→D</li><li>分解过程：<ul><li>R1(B,G,C)</li><li>R2(A,B,D,E,G)</li><li>→ R3(B,D,E) + R4(A,B,G)</li><li>→ R5(B,D) + R6(B,E) + R4(A,B,G)</li></ul></li><li>最终结果：<ul><li>R1(B,G,C)</li><li>R5(B,D)</li><li>R6(B,E)</li><li>R4(A,B,G)</li></ul></li></ol><p>每个子关系都满足 BCNF。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      <category domain="https://blog.tokenlen.top/categories/408/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/sql/">sql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/07/lastteam/sqltest/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络面试题hot2</title>
      <link>https://blog.tokenlen.top/2025/06/05/network/net4/</link>
      <guid>https://blog.tokenlen.top/2025/06/05/network/net4/</guid>
      <pubDate>Wed, 04 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h1&gt;&lt;h2 id=&quot;1-网络OSI模型和TCP-IP模型分别介绍一下&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="1-网络OSI模型和TCP-IP模型分别介绍一下"><a href="#1-网络OSI模型和TCP-IP模型分别介绍一下" class="headerlink" title="1.网络OSI模型和TCP/IP模型分别介绍一下"></a>1.网络OSI模型和TCP/IP模型分别介绍一下</h2><blockquote><p>OSI七层模型</p></blockquote><p>为了使得多种设备能通过网络相互通信，和为了<strong>解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型</strong>（<em>Open System Interconnection Reference Model</em>），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721097268006-12c71992-11b3-4a8e-9d05-35ad3e0ab86e.png" alt="img"></p><p>每一层负责的职能都不同，如下：</p><ul><li>应用层，负责给应用程序提供统一的接口；</li><li>表示层，负责把<strong>数据转换成兼容另一个系统能识别的格式</strong>；</li><li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li><li>传输层，负责端到端的数据传输；</li><li>网络层，负责数据的路由、转发、分片；</li><li>数据链路层，负责<strong>数据的封帧和差错检测</strong>，以及 MAC 寻址；</li><li>物理层，负责在物理网络中传输数据帧；</li></ul><p>由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。</p><p>事实上，我们比较常见，也比较实用的是<strong>四层模型</strong>，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。</p><blockquote><p>TCP/IP模型</p></blockquote><p>TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721097233614-f7cd6378-32d9-4cb8-9e60-e70b95bb3759.png" alt="img"></p><ul><li>应用层 支持 HTTP、SMTP 等最终用户进程</li><li>传输层 处理主机到主机的通信（TCP、UDP）</li><li>网络层 寻址和路由数据包（IP 协议）</li><li>链路层 通过网络的物理电线、电缆或无线信道移动比特</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="1-HTTP报文有哪些部分？"><a href="#1-HTTP报文有哪些部分？" class="headerlink" title="1.HTTP报文有哪些部分？"></a>1.HTTP报文有哪些部分？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1721710466863-78bf586d-a25c-4fe4-bf27-5dd576b998c8.png" alt="img"></p><p>分请求报文和响应报文来说明。</p><p><strong>请求报文：</strong></p><ul><li>请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。</li><li>请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。</li><li>空行：请求头部和请求体之间用空行分隔。</li><li>请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。</li></ul><p>一般是20个字节吧，请求头的长度</p><p><strong>响应报文：</strong></p><ul><li>状态行：包含HTTP协议版本、状态码和状态信息。</li><li>响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。</li><li>空行：响应头部和响应体之间用空行分隔。</li><li>响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容</li></ul><h2 id="2-HTTP常用的状态码？"><a href="#2-HTTP常用的状态码？" class="headerlink" title="2.HTTP常用的状态码？"></a>2.HTTP常用的状态码？</h2><p>HTTP 状态码分为 5 大类</p><ul><li>1xx 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li><li>2xx 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</li><li>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li><li>4xx 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li><li>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li></ul><p>其中常见的具体状态码有：</p><ul><li>200：请求成功；</li><li>301：永久重定向；302：临时重定向；</li><li>404：无法找到此页面；405：请求的方法类型不支持；</li><li>500：服务器内部出错。</li></ul><h2 id="3-HTTP返回状态301-302分别是什么？"><a href="#3-HTTP返回状态301-302分别是什么？" class="headerlink" title="3.HTTP返回状态301 302分别是什么？"></a>3.HTTP返回状态301 302分别是什么？</h2><p>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明<strong>请求的资源已经不存在了</strong>，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明<strong>请求的资源还在，但暂时需要用另一个 URL 来访问</strong>。</li></ul><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><h2 id="4-http-502和-504-的区别？"><a href="#4-http-502和-504-的区别？" class="headerlink" title="4.http 502和 504 的区别？"></a>4.http 502和 504 的区别？</h2><ul><li>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从<strong>上游服务器接收到无效的响应</strong>。</li><li>504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时从上游服务器收到响应</strong>。</li></ul><p>举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（tomcat 等）。</p><ul><li>当nginx收到了无效的响应时，就返回502。</li><li><strong>当nginx超过自己配置的超时时间，还没有收到请求时</strong>，就返回504错误。</li></ul><h2 id="5-HTTP层请求的类型有哪些？"><a href="#5-HTTP层请求的类型有哪些？" class="headerlink" title="5.HTTP层请求的类型有哪些？"></a>5.HTTP层请求的类型有哪些？</h2><ul><li>GET：用于请求获取指定资源，通常用于获取数据。</li><li>POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</li><li>PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。</li><li>DELETE：用于请求服务器删除指定资源。</li><li>HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</li></ul><h2 id="6-GET和POST的使用场景，有哪些区别？"><a href="#6-GET和POST的使用场景，有哪些区别？" class="headerlink" title="6.GET和POST的使用场景，有哪些区别？"></a>6.GET和POST的使用场景，有哪些区别？</h2><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，<strong>所以 GET 请求的参数只允许 ASCII 字符</strong> ，而且<strong>浏览器会对 URL 的长度有限制（</strong>HTTP协议本身对 URL长度并没有做任何规定）。</p><p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</p><p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，<strong>body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</strong></p><p>比如，你在我文章底部，敲入了留言后点击「提交」（<strong>暗示你们留言</strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</p><p>如果从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p><ul><li>可以用 GET 方法<strong>实现新增或删除数据</strong>的请求，这样实现的 GET 方法自然就不是安全和幂等。</li><li>可以用 POST 方法<strong>实现查询数据</strong>的请求，这样实现的 POST 方法自然就是安全和幂等。</li></ul><h2 id="7-HTTP的长连接是什么？"><a href="#7-HTTP的长连接是什么？" class="headerlink" title="7.HTTP的长连接是什么？"></a>7.HTTP的长连接是什么？</h2><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231702564.png" alt="image-20240725231702564"></p><p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231648038.png" alt="image-20240725231648038"></p><p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231628356.png" alt="image-20240725231628356"></p><p>这样实在太累人了，一次连接只能请求一次资源。</p><p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p><p>当然可以，<strong>HTTP 的 Keep-Alive</strong> 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231558255.png" alt="image-20240725231558255"></p><p><strong>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</strong></p><h2 id="8-HTTP1-1怎么对请求做拆包，具体来说怎么拆的？"><a href="#8-HTTP1-1怎么对请求做拆包，具体来说怎么拆的？" class="headerlink" title="8.HTTP1.1怎么对请求做拆包，具体来说怎么拆的？"></a>8.HTTP1.1怎么对请求做拆包，具体来说怎么拆的？</h2><p>在HTTP/1.1中，请求的拆包是通过”<strong>Content-Length</strong>“头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231532943.png" alt="image-20240725231532943"></p><p>具体来说，当客户端发送一个HTTP请求时，会在请求头中添加”Content-Length”字段，该字段的值表示请求正文的字节数。</p><p>服务器在接收到请求后，<strong>会根据”Content-Length”字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。</strong></p><p>这种基于”Content-Length”字段的拆包机制可以确保服务器正确接收到完整的请求，<strong>避免了请求的丢失或截断问题。</strong></p><h2 id="9-http-断点重传是什么？"><a href="#9-http-断点重传是什么？" class="headerlink" title="9.http 断点重传是什么？"></a>9.http 断点重传是什么？</h2><p>断点续传是HTTP/1.1协议支持的特性。实现断点续传的功能，<strong>需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1737790649434-0bb21e8e-faae-44c7-9f7b-2f677c38b39d.webp" alt="img">一个最简单的断点续传流程如下：</p><ol><li>客户端开始下载一个1024K的文件，服务端发送A<strong>ccept-Ranges: bytes来告诉客户端，其支持带Range的请求</strong></li><li>假如客户端下载了其中512K时候网络突然断开了，过了一会网络可以了，客户端再下载时候，需要在HTTP头中申明本次需要续传的片段：<strong>Range:bytes=512000-这个头通知服务端从文件的512K位置开始传输文件，直到文件内容结束</strong></li><li>服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：<strong>Content-Range:bytes 512000-/1024000,Content-Length: 512000。</strong>并且此时服务端返回的HTTP状态码应该是<strong>206</strong> Partial Content。如果<strong>客户端传递过来的Range超过资源的大小,则响应416</strong> Requested Range Not Satisfiable</li></ol><p>通过上面流程可以看出：断点续传中4个HTTP头不可少的，<strong>分别是Range头、Content-Range头、Accept-Ranges头、Content-Length头</strong>。其中第一个Range头是客户端发过来的，后面3个头需要服务端发送给客户端。下面是它们的说明：</p><ul><li><strong>Accept-Ranges: bytes：</strong>这个值<strong>声明了可被接受的每一个范围请求</strong>, 大多数情况下是字节数 bytes</li><li><strong>Range: bytes=开始位置-结束位置：</strong>Range是浏览器告知服务器所需分部分内容范围的消息头。</li></ul><h2 id="10-HTTP为什么不安全？"><a href="#10-HTTP为什么不安全？" class="headerlink" title="10.HTTP为什么不安全？"></a>10.HTTP为什么不安全？</h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1719381758323-e2bd2f7b-d599-4b23-b258-b8620ac52808.jpeg" alt="img"></p><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <strong>SSL/TLS</strong> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><h2 id="11-HTTP和HTTPS-的区别？"><a href="#11-HTTP和HTTPS-的区别？" class="headerlink" title="11.HTTP和HTTPS 的区别？"></a>11.HTTP和HTTPS 的区别？</h2><p>区别主要有以下四点：</p><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP <strong>网络层之间加入了 SSL/TLS 安全协议</strong>，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS <strong>在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</strong></li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 <strong>CA（证书权威机构）申请数字证书，</strong>来保证服务器的身份是可信的。</li></ul><h2 id="12-HTTPS握手过程说一下"><a href="#12-HTTPS握手过程说一下" class="headerlink" title="12.HTTPS握手过程说一下"></a>12.HTTPS握手过程说一下</h2><p>传统的 <strong>TLS 握手基本都是使用 RSA 算法来</strong>实现密钥交换的，在将 TLS 证书部署服务端时，<strong>证书文件其实就是服务端的公钥</strong>，会在 TLS 握手阶段传递给客户端，而<strong>服务端的私钥则一直留在服务端</strong>，一定要确保私钥不能被窃取。</p><p>在 RSA 密钥协商算法中，<strong>客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端</strong>。根据非对称加密算法，<strong>公钥加密的消息仅能通过私钥解密</strong>，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p><p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1716097892426-58902c14-da4f-40fc-9199-94752fc5368b.webp" alt="img"></p><p><img src="https://cdn.xiaolincoding.com//picgo/1716097892465-985f6cfe-66c8-4384-aabd-840821de1b66.webp" alt="img"></p><blockquote><p>TLS 第一次握手</p></blockquote><p>首先，由客户端向服务器发起<strong>加密通信</strong>请求，<strong>也就是 ClientHello 请求</strong>。在这一步，客户端主要向服务器发送以下信息：</p><ul><li>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li><li>（3）客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><blockquote><p>TLS 第二次握手</p></blockquote><p>服务器收到客户端请求后，向客户端发出响应，也就是 <strong>SeverHello</strong>。服务器回应的内容有如下内容：</p><ul><li>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li>（3）确认的密码套件列表，如 RSA 加密算法。</li><li>（4）服务器的数字证书。</li></ul><blockquote><p>TLS 第三次握手</p></blockquote><p>客户端收到服务器的回应之后，<strong>首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</strong></p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后<strong>使用它加密报文，向服务器发送如下信息：</strong></p><ul><li>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>（3）客户端握手结束通知<strong>，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</strong></li></ul><p>上面第一项的随机数是整个握手阶段的<strong>第三个随机数</strong>，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><blockquote><p>TLS 第四次握手</p></blockquote><p>服务器收到客户端的<strong>第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</strong></p><p>然后，<strong>向客户端发送最后的信息</strong>：</p><ul><li>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>（2）服务器握手结束通知，表示<strong>服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</strong></li></ul><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，<strong>就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</strong></p><h2 id="13-HTTPS是如何防范中间人的攻击？"><a href="#13-HTTPS是如何防范中间人的攻击？" class="headerlink" title="13.HTTPS是如何防范中间人的攻击？"></a>13.HTTPS是如何防范中间人的攻击？</h2><p>主要通过<strong>加密和身份校验机制</strong>来防范中间人攻击的:</p><ul><li>加密：https 握手期间会通过<strong>非对称加密的方式</strong>来协商出对称加密密钥。</li><li>身份校验：<strong>服务器</strong>会向证书颁发机构申请<strong>数字证书</strong>，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，<strong>客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密。</strong></li></ul><p>中间人攻击的关键在于攻击者冒充服务器与客户端建立连接，并同时与服务器建立连接。</p><p>但由于攻击者无法获得服务器的私钥，因此无法正确解密客户端发送的加密数据。同时，客户端会在建立连接时验证服务器的证书，如果证书验证失败或存在问题，客户端会发出警告或中止连接。</p><h2 id="14-Http1-1和2-0的区别是什么？"><a href="#14-Http1-1和2-0的区别是什么？" class="headerlink" title="14.Http1.1和2.0的区别是什么？"></a>14.Http1.1和2.0的区别是什么？</h2><p>HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ul><li><strong>头部压缩</strong>：HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。这就是所谓的 <strong>HPACK</strong> 算法：在客户端和服务器同时维护一张<strong>头信息表</strong>，所有字段都会存入这个表，<strong>生成一个索引号</strong>，以后就<strong>不发送同样字段了，只发送索引号</strong>，这样就<strong>提高速度</strong>了。</li><li><strong>二进制格式</strong>：HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li><li><strong>并发传</strong>输：引出了 <strong>Stream</strong> 概念，多个 Stream 复用在一条 TCP 连接。解决了HTTP/1.1 队头阻塞的问题：</li><li><strong>服务器主动推送资源</strong>：HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</li></ul><h2 id="15-HTTP进行TCP连接之后，在什么情况下会中断"><a href="#15-HTTP进行TCP连接之后，在什么情况下会中断" class="headerlink" title="15.HTTP进行TCP连接之后，在什么情况下会中断"></a>15.HTTP进行TCP连接之后，在什么情况下会中断</h2><ul><li>当服务端或者客户端执行 close 系统调用的时候，会发送FIN报文，就会进行<strong>四次挥手</strong>的过程</li><li>当发送方发送了数据之后，接收方超过一段时间没有响应ACK报文，发送方重传数据达到最大次数的时候，就会断开TCP连接。</li><li>当HTTP长时间没有进行请求和响应的时候，超过一定的时间，这个时间就是长连接的维持时间，就会释放连接</li></ul><h2 id="16-HTTP、SOCKET和TCP的区别"><a href="#16-HTTP、SOCKET和TCP的区别" class="headerlink" title="16.HTTP、SOCKET和TCP的区别"></a>16.HTTP、SOCKET和TCP的区别</h2><p>HTTP是应用层协议，定义了<strong>客户端和服务器之间交换的数据格式和规则</strong>；Socket是通信的一端，<strong>提供了网络通信的接口</strong>；TCP是传输层协议，负责在<strong>网络中建立可靠的数据传输连接</strong>。它们在网络通信中扮演不同的角色和层次。</p><ul><li>HTTP是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示Web页面。</li><li>Socket是计算机网络中的一种抽象，用于描述<strong>通信链路的一端</strong>，提供了底层的通信接口，可实现不同计算机之间的<strong>数据交换</strong>。</li><li>TCP是一种面向连接的、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。</li></ul><h2 id="17-HTTP到底是不是无状态的？"><a href="#17-HTTP到底是不是无状态的？" class="headerlink" title="17.HTTP到底是不是无状态的？"></a>17.HTTP到底是不是无状态的？</h2><p>HTTP是<strong>无状态</strong>的，这意味着<strong>每个请求都是独立的</strong>，服务器不会在多个请求之间保留关于客户端状态的信息。在每个HTTP请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的。</p><p>虽然HTTP本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是使用<strong>Cookie和Session来跟踪用户状态</strong>。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能。或者是使用token，一般这个都是用来认证识别用户使用的</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="1-DNS的全称了解么？"><a href="#1-DNS的全称了解么？" class="headerlink" title="1.DNS的全称了解么？"></a>1.DNS的全称了解么？</h2><p>DNS的全称是<strong>Domain Name System</strong>（域名系统），它是互联网中用于将<strong>域名转换为对应IP地址的分布式数据库系统。</strong>DNS扮演着重要的角色，使得人们可以通过易记的域名访问互联网资源，而无需记住复杂的IP地址。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p><p>实际上域名最后还有一个点，比如 www.server.com.，这个<strong>最后的一个点代表根域名。</strong></p><p>也就是，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" alt="DNS 树状结构"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，<strong>客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</strong></p><h2 id="2-DNS-域名解析的工作流程？"><a href="#2-DNS-域名解析的工作流程？" class="headerlink" title="2.DNS 域名解析的工作流程？"></a>2.DNS 域名解析的工作流程？</h2><ol><li>客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果<strong>缓存</strong>里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，<strong>本地 DNS 会去问它的根域名服务器：</strong>“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715326531135-c1f081dd-89e1-4b31-94e4-95a76f9fcba4.png" alt="img"></p><p>就是一个递归的过程，从顶级到下面一步一步递归</p><h2 id="3-DNS的底层使用TCP还是UDP？"><a href="#3-DNS的底层使用TCP还是UDP？" class="headerlink" title="3.DNS的底层使用TCP还是UDP？"></a>3.DNS的底层使用TCP还是UDP？</h2><p>DNS 基于UDP协议实现，DNS使用UDP协议进行域名解析和数据传输。因为基于UDP实现DNS能够提供低延迟、简单快速、轻量级的特性，更适合DNS这种需要快速响应的域名解析服务。</p><ul><li><strong>低延迟：</strong> UDP是一种无连接的协议，不需要在数据传输前建立连接，因此可以减少传输时延，适合DNS这种需要快速响应的应用场景。</li><li><strong>简单快速：</strong> UDP相比于TCP更简单，没有TCP的连接管理和流量控制机制，传输效率更高，适合DNS这种需要快速传输数据的场景。</li><li><strong>轻量级</strong>：UDP头部较小，占用较少的网络资源，对于小型请求和响应来说更加轻量级，适合DNS这种频繁且短小的数据交换。</li></ul><p>尽管 UDP 存在丢包和数据包损坏的风险，但在 DNS 的设计中，这些风险是可以被容忍的。DNS 使用了一些机制来提高可靠性，例如查询超时重传、请求重试、缓存等，以确保数据传输的可靠性和正确性。</p><p>但是dns也是可以使用tcp进行的，默认是udp端口号是53</p><p><strong>响应数据超过 UDP 限制时</strong></p><ul><li>如果 DNS 响应内容超过 <strong>512 字节</strong>（在启用 EDNS0 时可以大于此限制，但 UDP 包最大也不能超过 4096 字节）；</li><li>比如：<ul><li>响应包含大量的 A 记录、MX 记录；</li><li>使用 DNSSEC（数据带签名，很大）；</li></ul></li><li><p>那么就会自动“回退”使用 <strong>TCP 进行重传</strong>。</p><p><strong>区域传送（Zone Transfer）时</strong></p></li><li><p>主从 DNS 服务器之间同步区域信息（<strong>AXFR、IXFR 请求</strong>）使用 <strong>TCP</strong>；</p></li><li><p>这些传输的数据量大、需要可靠性和顺序性，UDP 无法胜任。</p><p><strong>连接建立更可靠的查询环境时</strong></p></li><li><p>一些防火墙或中间设备可能对 UDP 做限制，此时客户端会主动使用 TCP。</p></li><li>一些安全策略（如 DNS-over-TCP、DoH、DoT）也默认使用 TCP。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/05/network/net4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git</title>
      <link>https://blog.tokenlen.top/2025/05/31/new-stack/git/</link>
      <guid>https://blog.tokenlen.top/2025/05/31/new-stack/git/</guid>
      <pubDate>Fri, 30 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;Git</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Git 是一个分布式版本控制系统，用于跟踪和管理代码的变化，广泛应用于软件开发中。一般用于多人开发，或者是版本管理的</p><p>组成部分：</p><p><strong>工作区（Working Directory）</strong>：你本地修改代码的目录。</p><p><strong>暂存区（Staging Area/Index）</strong>：用于暂存准备提交的更改。</p><p><strong>本地仓库（Local Repository）</strong>：存储提交的代码版本。</p><p><strong>远程仓库（Remote Repository）</strong>：托管在远程服务器（如 GitHub、GitLab）的代码仓库。</p><p>流程：修改代码 → 暂存更改（git add） → 提交到本地仓库（git commit） → 推送到远程仓库（git push）。</p><p>从远程仓库拉取更新（git pull）或克隆仓库（git clone）。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>git init 初始化仓库，建立一个.git文件夹</p><p>git clone ssh/http克隆仓库</p><p>git status 查看工作区的状态</p><p>git add <file name>添加文件。git add .添加所有</p><p>git commit -m “”提交</p><p>git log 查看提交历史</p><p>git log —oneline # 简洁显示</p><p>git log —graph   # 显示分支图形</p><p>git branch 列出本地分支</p><p>git branch -r 远程分支</p><p>git branch -a 列出所有分支</p><p>git branch &lt; name&gt;新建分支</p><p>git checkout &lt; name&gt;切换分支</p><p>git checkout -b &lt; name&gt;切换并创建分支</p><p>git merge &lt; name&gt;合并分支，可能要处理分支冲突</p><p>git branch -d &lt; name&gt;删除已经合并的分支</p><p>git branch -D &lt; name&gt; 强制删除</p><p> git remote add origin 添加远程仓库</p><p>git remote -v 查看远程仓库</p><p>git push origin main 推送本地到某某分支</p><p>git pull origin main 拉起分支，相当于 git fetch + git merge。</p><p>git restore &lt; file&gt;撤销工作区修改</p><p><strong>这些都是需要某次提交的hash值的</strong></p><p>git restore —staged  撤销暂存区修改</p><p>git reset —soft 撤销提交，但修改还在</p><p>git reset —hard 撤销提交，修改也不要</p><p>git revert 回滚到某次提交</p><p>git fetch 只获取更新的内容，不合并</p><p>git diff 工作区和暂存区的差异</p><p>git diff —staged 暂存区和上次提交的差异</p><p>将当前分支的提交应用到另一分支上</p><p>git rebase </p><p>解决冲突后继续：git rebase —continue</p><p>中止变基：git rebase —abort</p><p><strong>gitignore</strong>：</p><ul><li>创建 .gitignore 文件，忽略不需要跟踪的文件（如 node_modules/、.env）。</li></ul><p>扩展命令：</p><ul><li>git checkout — files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li><li>git reset — files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li><li>git checkout HEAD — files 回滚到复制最后一次提交。</li><li></li></ul><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p><strong>合并冲突</strong></p><p>合并或拉取时可能发生冲突，Git 会标记冲突文件。</p><p>当发生冲突时，Git 会提示您文件中的冲突部分。您可以使用以下命令查看所有冲突文件的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ol><li>打开包含冲突的文件，您会看到类似以下的标记：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 代码来自目标分支</span><br><span class="line">=======</span><br><span class="line">// 代码来自要合并的分支</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchName</span><br></pre></td></tr></table></figure><p>您需要手动编辑这些文件，决定保留哪些变更或者如何整合这些变更。</p><p>完成冲突解决后，对已解决的文件使用以下命令标记为已解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt; </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p><strong>误提交</strong></p><p>修改最后一次提交：git commit —amend</p><p>回滚到之前版本：git reset 或 git revert</p><p><strong>远程推送被拒绝</strong></p><p>通常是远程仓库有更新，先拉取：git pull —rebase，然后再推送。</p><h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><h2 id="1-git-rebase和merge的区别"><a href="#1-git-rebase和merge的区别" class="headerlink" title="1.git rebase和merge的区别"></a>1.git rebase和merge的区别</h2><ul><li><strong>Rebase</strong>（变基）是将<strong>一个分支上的提交逐个地应用到另一个分支上</strong>，使得提交历史变得更加线性。当执行rebase时，Git会将目标分支与源分支的共同祖先以来的所有提交挪到目标分支的最新位置。这个过程可以看作是<strong>将源分支上的每个提交复制到目标分支上</strong>。简而言之，<strong>rebase可以将提交按照时间顺序线性排列。</strong></li></ul><p>常用来更新的时候</p><ul><li><strong>Merge</strong>（合并）是将<strong>两个分支上的代码提交历史合并为一个新的提交</strong>。在执行merge时，Git会创建一个新的合并提交，将两个分支的提交历史连接在一起。这样，两个分支的修改都会包含在一个合并提交中。合并后的历史会保留每个分支的提交记录。</li></ul><h2 id="2-解释“git-pull”和“git-fetch”之间有什么区别？"><a href="#2-解释“git-pull”和“git-fetch”之间有什么区别？" class="headerlink" title="2.解释“git pull”和“git fetch”之间有什么区别？"></a>2.解释“git pull”和“git fetch”之间有什么区别？</h2><p>在Git中，<code>git fetch</code>和<code>git pull</code>都是用于从远程仓库获取更新的命令，但它们的工作方式有所不同。</p><p><code>git fetch</code></p><ul><li><strong>功能</strong>: 只从<strong>远程仓库获取更新，不会将这些更新合并到当前分支</strong>。</li><li><strong>用途</strong>: 它会下载所有的提交、分支和标签，更新本地的远程跟踪分支（如<code>origin/master</code>），但不会改变你的工作目录或当前分支的内容。</li><li><strong>场景</strong>: 适合在<strong>想要查看远程变化但不希望立即合并的情况下使用</strong>。你可以先审查更新，决定接下来是否要合并。</li></ul><p><code>git pull</code></p><ul><li><strong>功能</strong>: 是<code>git fetch</code>和<code>git merge</code>的组合命令。它首先会执行<code>git fetch</code>，然后会<strong>将获取的更新合并到当前分支。</strong></li><li><strong>用途</strong>: 直接将远程分支的变化合并到你当前的工作分支，适合希望快速同步远程更改并工作于最新状态的场景。</li><li><strong>场景</strong>: 适用于当你确信需要立即合并远程更新时，方便快速将最新的更改合并到本地。</li></ul><h2 id="3-简述Git和SVN有什么区别？"><a href="#3-简述Git和SVN有什么区别？" class="headerlink" title="3.简述Git和SVN有什么区别？"></a>3.简述Git和SVN有什么区别？</h2><p>Git和SVN（Subversion）都是版本控制系统，但它们在设计理念、工作流程和功能等方面有显著的区别。以下是一些主要区别：</p><ol><li><strong>版本控制模型</strong>：<ul><li><strong>SVN</strong>：基于<strong>集中式版本控制系统</strong>（CVCS），所有版本历史记录保存在中央服务器上，工作副本直接与中央库交互。</li><li><strong>Git</strong>：基于<strong>分布式版本控制系统</strong>（DVCS），每个开发者的工作副本都包含整个代码库的历史记录，操作可以在本地完成。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>SVN</strong>：对于大文件的处理和网络操作可能比较慢，因为每次提交或更新都需要与中央服务器交互。</li><li><strong>Git</strong>：大部分操作（如提交、分支、合并等）都在本地进行，速度更快，尤其是在离线时。</li></ul></li><li><strong>分支和合并</strong>：<ul><li><strong>SVN</strong>：分支和标签是从中央库创建的，相对较重，使用上不够灵活。</li><li><strong>Git</strong>：分支操作轻量且快速，鼓励频繁创建和使用分支，合并操作也相对简单。</li></ul></li><li><strong>数据完整性</strong>：<ul><li><strong>SVN</strong>：依赖中央服务器的数据完整性，尽管有一定的安全措施，但主要依靠服务器来维护数据。</li><li><strong>Git</strong>：通过<strong>SHA-1哈希值</strong>来确保每次提交的完整性，每个提交都是整个历史的一部分，易于追踪和验证。</li></ul></li><li><strong>工作流</strong>：<ul><li><strong>SVN</strong>：通常采用拉/推的工作流，开发者需要从中央库更新，提交时也要推送到中央库。</li><li><strong>Git</strong>：支持多种工作流（如Forking、Feature Branch等），开发者可以在本地进行完全隔离的开发，之后再选择何时将更改推送到中央库。</li></ul></li><li><strong>使用场景</strong>：<ul><li><strong>SVN</strong>：适合小团队和需要严格控制版本访问的项目。</li><li><strong>Git</strong>：更适合开源项目和需要频繁更新的团队，灵活性和效率较高。</li></ul></li></ol><p>总的来说，Git更适合现代软件开发的分布式协作需求，而SVN则在一些传统环境中仍然被广泛使用。</p><h2 id="4-简述Github和Gitlab的区别？"><a href="#4-简述Github和Gitlab的区别？" class="headerlink" title="4.简述Github和Gitlab的区别？"></a>4.简述Github和Gitlab的区别？</h2><p>GitHub和GitLab是两个流行的Git代码托管平台，虽然它们有许多相似之处，但在一些关键方面有所不同：</p><ol><li><strong>主机定位</strong>：<ul><li><strong>GitHub</strong>：主要是一个基于云的服务，提供代码托管和协作工具。</li><li><strong>GitLab</strong>：可以选择使用云服务，也可以自行托管在本地服务器上，<strong>适合更注重私有化和自定义的团队。</strong></li></ul></li><li><strong>访问控制</strong>：<ul><li><strong>GitHub</strong>：较为简单的权限管理，主要依赖于组织和仓库的级别设置。</li><li><strong>GitLab</strong>：提供<strong>更细粒度的权限管理，允许用户为不同的项目或分支设置不同的访问权限</strong>。</li></ul></li><li><strong>集成功能</strong>：<ul><li><strong>GitHub</strong>：虽然有GitHub Actions等CI/CD功能，但整体上集成和扩展的选择相对少。</li><li><strong>GitLab</strong>：内置了非常强大的CI/CD功能，几乎所有的<strong>DevOps流程</strong>都可以在一个平台上完成。</li></ul></li><li><strong>issue追踪与项目管理</strong>：<ul><li><strong>GitHub</strong>：提供基础的issue追踪功能，涉及的问题管理相对简单。</li><li><strong>GitLab</strong>：提供更<strong>全面的项目管理工具，包含时间线、里程碑和更复杂的看板</strong>等功能。</li></ul></li><li><strong>开源与闭源</strong>：<ul><li><strong>GitHub</strong>：主要为闭源平台，但有一些开源项目。</li><li><strong>GitLab</strong>：提供开源版本，用户可以自由修改和使用。</li></ul></li><li><strong>社区和生态</strong>：<ul><li><strong>GitHub</strong>：有着庞大的开发者社区和丰富的开源项目资源。</li><li><strong>GitLab</strong>：社区相对较小，但也在快速增长中，尤其是在DevOps领域。</li></ul></li><li><strong>费用结构</strong>：<ul><li><strong>GitHub</strong>：基本的公共仓库免费，但某些高级功能需要付费。</li><li><strong>GitLab</strong>：提供更全面的免费计划，收费方案也根据功能不同而不同。</li></ul></li></ol><p>这些差异使得GitHub和GitLab在满足不同团队和项目需求时，具有各自的优缺点。选择哪个平台主要取决于团队的具体需求和工作流程。</p><p>5.</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/git/">git</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/31/new-stack/git/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试题目</title>
      <link>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/</link>
      <guid>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/</guid>
      <pubDate>Tue, 27 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;面试一轮&quot;&gt;&lt;a href=&quot;#面试一轮&quot; class=&quot;headerlink&quot; title=&quot;面试一轮&quot;&gt;&lt;/a&gt;面试一轮&lt;/h1&gt;&lt;h2 id=&quot;3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#3-无重复字符的最长子串&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="面试一轮"><a href="#面试一轮" class="headerlink" title="面试一轮"></a>面试一轮</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><p>滑动窗口</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,res = <span class="number">0</span>,n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                left = Math.max(left,cnt.get(s.charAt(right)));</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.put(s.charAt(right),right);</span><br><span class="line">            res = Math.max(res,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典滑动窗口，更新right和left然后计算长度</p><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p>linkedHashMap</p><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>一看到是存储键值对数据，那我们可以使用map集合来做，然后返现需要插入xud</p><p>LinkedHashMap而其内部是靠 建立一个<strong>双向链表</strong> 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护 ，准确的来说，是有三个函数来做这件事，这三个函数都统称为 <strong>回调函数</strong> ，这三个函数分别是：</p><p>void afterNodeAccess(Node<K,V> p) { }<br>其作用就是在访问元素之后，<strong>将该元素放到双向链表的尾巴处</strong>(所以这个函数只有在按照读取的顺序的时候才会执行)，之所以提这个，是建议大家去看看，如何优美的实现在双向链表中将指定元素放入链尾！<br>void afterNodeRemoval(Node<K,V> p) { }<br>其作用就是在删除元素之后，将元素从双向链表中删除，还是非常建议大家去看看这个函数的，很优美的方式在双向链表中删除节点！<br>void afterNodeInsertion(boolean evict) { }<br>这个才是我们题目中会用到的，在插入新元素之后，<strong>需要回调函数判断是否需要移除一直不用的某些元素！</strong></p><p>所以我们直接继承linkedhashmap来解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer,Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer,Integer&gt; eldest)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size()&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接返回即可了</p><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>那我们就一直交换他们的指针应该就可以了，从尾部交换到头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution206A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.pre-&gt;cur</p><p>A.cur-&gt;cur.next</p><p>A.cur.next = pre</p><p>然后用<strong>头插法</strong>依次把节点 1,2,3 插到这个新链表的头部</p><p>1-&gt;2-&gt;3</p><p>2.next-&gt;1</p><p>2.pre-&gt;2</p><p>2.cur-&gt;3</p><p>3-&gt;2-&gt;1</p><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接排序，返回倒数第k个就完事</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>双指针</p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;x==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//跳过重复数组</span></span><br><span class="line">            <span class="keyword">if</span> (x+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]&gt;<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//没负数就别看了</span></span><br><span class="line">            <span class="keyword">if</span> (x+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//每个正数也不看了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span>  <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;k)&#123;</span><br><span class="line">                <span class="type">int</span> s= x+nums[j]+nums[k];</span><br><span class="line">                <span class="keyword">if</span> (s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.add(List.of(x, nums[j], nums[k]));</span><br><span class="line">                    <span class="keyword">for</span> (j++;j&lt;k&amp;&amp;nums[j]==nums[j-<span class="number">1</span>];j++);<span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">for</span> (k--;k&gt;j&amp;&amp;nums[k]==nums[k+<span class="number">1</span>];k--);<span class="comment">//去重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个进行优化和提前去观察的双指针方法，提前看最大的能不能实现，还有最小的情况能不能符合.</p><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur!=<span class="literal">null</span>;cur =cur.next)&#123;</span><br><span class="line">            n++;<span class="comment">//计数器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head),preHead = dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = head;</span><br><span class="line">        <span class="keyword">for</span> (;n&gt;=k;n-=k)&#123;<span class="comment">//重复n-k次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">                <span class="type">ListNode</span>  <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre =cur;</span><br><span class="line">                cur  = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> preHead.next;<span class="comment">//反转区间的结尾</span></span><br><span class="line">            tail.next = cur;<span class="comment">//下个区间</span></span><br><span class="line">            preHead.next = pre;<span class="comment">//区间的新head</span></span><br><span class="line">            preHead = tail;<span class="comment">//到达结尾进行下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>分组循环</p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution53A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum +=x;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum = x;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的去解决，如果和为正数的话，就继续去加数。不是的话，就从当前这个数开始重新计算</p><p>也有点分组循环的意思了哈哈</p><h2 id="手撕快速排序"><a href="#手撕快速排序" class="headerlink" title="手撕快速排序"></a>手撕快速排序</h2><p>快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution912</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right-left&lt;=INSERTION_SORT_THRESHOLD)&#123;</span><br><span class="line">            insertSort(nums,left,right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> partition(nums,left,right);</span><br><span class="line">        quickSort(nums,left,pIndex-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,pIndex+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;left&amp;&amp;nums[j-<span class="number">1</span>]&gt;tmp)&#123;</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left+RANDOM.nextInt(right-left+<span class="number">1</span>);</span><br><span class="line">        swap(nums,randomIndex,left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (gt &gt; left &amp;&amp; nums[gt] &gt; pivot) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lt &gt;= gt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 细节：相等的元素通过交换，等概率分到数组的两边</span></span><br><span class="line">            swap(nums, lt, gt);</span><br><span class="line">            lt++;</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, gt);</span><br><span class="line">        <span class="keyword">return</span> gt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点难了😓</p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span>) <span class="keyword">return</span> list2; <span class="comment">// 注：如果都为空则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="literal">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空的话就返回另一个的链表</p><p>如果l1的值小于l2的话，递归调用的链表接l1之后。反之一样</p><p>然后返回当前节点</p><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> expend(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> expend(s,i,i);</span><br><span class="line">            res = res.length()&gt;s1.length()?res:s1;</span><br><span class="line">            res = res.length()&gt;s2.length()?res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">expend</span><span class="params">(String s,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;=<span class="number">0</span>&amp;&amp;r&lt;s.length()&amp;&amp;s.charAt(l)==s.charAt(r))&#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(l+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expend返回的是上一次合法回文的范围。然后慢慢扩大范围，s1为偶数回文</p><p>s2为奇数回文</p><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution102A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue   = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>level为当前的层数，n为当前层数的所有节点数</p><p>然后使用bfs进步遍历，不为空，就加入队列遍历</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>hashmap</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用hash表解决，在map里有target-nums[i]的数，就新建数组</p><p>然后放入nums[i]，没有就扔出异常</p><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>二分查找</p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> target&gt;end&amp;&amp;x&gt;=target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target&gt;end||x&gt;=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums,target,mid))&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right]==target?right:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用二分查找</p><p>把某个数 <em>x</em> 与最后一个数 <em>nums</em>[<em>n</em>−1] 比大小</p><p>如果x&gt;nums[n-1]的话</p><p>nums一定被旋转分为左右两个递增的，就是前面的一段移动到后面来了</p><p>然后前面的大于后面的</p><p>x还在第一段</p><p>反之，x&lt;=nums[n-1]就说明x在第二段</p><p>或者他就是递增数组</p><p>根据这个写我们的check函数，来确定x的范围，好让我们进行二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> target&gt;end&amp;&amp;x&gt;=target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target&gt;end||x&gt;=target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p>bfs</p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution200</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=grid.length||j&lt;<span class="number">0</span>||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是遍历这整个矩阵，然后如果是1就count++;</p><p>然后把通过的改为2，防止重复遍历</p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p>回溯法</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, path, onPath, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; path, <span class="type">boolean</span>[] onPath, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (onPath[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            onPath[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(nums, path, onPath, ans);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            onPath[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>onPath用来放这个j有没有使用</p><p>path为路径，就是数组，长度全了的话，就给他加入到答案中</p><p>然后遍历，进入路径，设为匹配，dfs后，再恢复</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1&gt;=<span class="number">0</span>&amp;&amp;nums1[p1]&gt;nums2[p2])&#123;</span><br><span class="line">                nums1[p--] = nums1[p1--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[p--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的交换，谁大谁在后面</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>栈</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution20</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()||c!=stack.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用栈的思想，有左的话，就把右边的入栈</p><p>或者空了，或者是所不对应的时候，返回fasle</p><p>然后最后看是不是空</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution121</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE,profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p:prices)&#123;</span><br><span class="line">            cost = Math.min(cost,p);</span><br><span class="line">            profit = Math.max(profit,p-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>easy题目</p><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> List.of();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                vals.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.size()%<span class="number">2</span>&gt;<span class="number">0</span>) Collections.reverse(vals);</span><br><span class="line">            ans.add(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看到这种层序遍历，我们首先想到使用bfs，然后层序遍历，先遍历left,然后遍历right</p><p>之前的代码跟层序遍历差不多，只不过，他要形成锯齿状，奇数层就要反转。即就是下面的代码</p><p>刚刚前面判断写的有点麻烦了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>) q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                vals.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.size()%<span class="number">2</span>&gt;<span class="number">0</span>) Collections.reverse(vals);</span><br><span class="line">            ans.add(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更正一下</p><blockquote><p>联系102二叉树的层序遍历</p></blockquote><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution236</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==q||root==p) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是有啥就返回啥，没有就返回另一半，都没有就返回root</p><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution141</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个环形，也就是说是快慢指针碰到一块了就是一个环</p><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution92</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;left-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            p0= p0.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> p0.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur= next;</span><br><span class="line">        &#125;</span><br><span class="line">        p0.next.next = cur;</span><br><span class="line">        p0.next = pre;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似 leetcode25,206</p></blockquote><p>反转需要注意的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur= next;</span><br></pre></td></tr></table></figure><p>反转后在原来的链表上看，pre指向反转一段的末尾，</p><p>cur指向反转一段后续的下一个节点</p><p>然后修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p0.next.next = cur;</span><br><span class="line">        p0.next = pre;</span><br><span class="line">        return dummy.next;</span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution54A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>,r = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>,b = matrix.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r&amp;&amp;t&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;i&lt;=r;i++) res.add(matrix[t][i]);</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>t;i&lt;=b;i++) res.add(matrix[i][r]);</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;r) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=r;i&gt;=l;i--) res.add(matrix[b][i]);</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>b;i&gt;=t;i--) res.add(matrix[i][l]);</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个遍历的问题，从左到右，从上到下，然后从右到左，再从下到上</p><p>然后循环，主要是边界也要跟着移动</p><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution300</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span><span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;res[k])&#123;</span><br><span class="line">                res[++k] = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (res[j]&gt;=nums[i])&#123;</span><br><span class="line">                    res[j] =nums[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先遍历出来个递增的数组</p><p>如果不是的话，从0-k中找一个别的数，来贪心替换</p><p>最后k+1就是有效的长度</p><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span>  lists.length;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;step&lt;m;step*=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m-step;i+=step*<span class="number">2</span>)&#123;</span><br><span class="line">                lists[i] =  meryTwoLists(lists[i],lists[i+step]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">meryTwoLists</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="literal">null</span>&amp;&amp;list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val&lt;list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1!=<span class="literal">null</span>?list1:list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的函数时按大小来合并链表的</p><p>每次将间隔为 <code>step</code> 的链表合并成一个新链表</p><p>然后要满足所有，可以合并一道二，二到四，四道八这样一点一点的递归下去</p><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution143</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next!=<span class="literal">null</span>&amp;&amp;fast.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow =slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        ListNode l1_temp;</span><br><span class="line">        ListNode l2_temp;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">null</span>&amp;&amp;l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            l1_temp = l1.next;</span><br><span class="line">            l2_temp = l2.next;</span><br><span class="line"></span><br><span class="line">            l1.next = l2;</span><br><span class="line">            l1 = l1_temp;</span><br><span class="line"></span><br><span class="line">            l2.next = l1;</span><br><span class="line">            l2 = l2_temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span>head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        mergeList(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这个题目可以进行拆分，主要是分为三步</p><p>先是找到中间点，然后按照中间点分开，然后后面的链表反转，然后跟前面的链表合并</p><p>所以我们需要写三个函数，和一个主函数</p><p>找到中间点的方法就是</p><p>一个快指针，一个慢指针。然后快指针到尾部了。慢指针的位置就是中间点</p><p>反转链表不必多说：</p><p>next = cur.next</p><p>cur.next = pre;</p><p>pre = cur;</p><p>cur =next;</p><p>然后合并链表，就是先加l1的头，然后再加l2的头这样</p><p>l1tmp  = l1.next;</p><p>l2tmp = l2.next;</p><p>l1.next = l2;</p><p>l1 = l1tmp</p><p>l2.next = l1;</p><p>l2 = l2tmp</p><p>然后完成。</p><p>我自己想的思路是，我用双指针解决，找一个新的链表，然后先是左指针的节点加入，然后再加入右指针，然后左右指针都移动，一次类推，然后到左右指针相遇的时候，加入最后的节点。这个思路。但是这样的时间复杂度是o(n)不太符合哭。</p><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式</p><p>既然他不让直接进行计算器算的话，那我们去模拟计算器</p><p>从每个数的结尾去计算，如果进位的话，就加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  num1.length()-<span class="number">1</span>, j = num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            res.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后这里使用的stringBuilder用来操作字符串是非常好的，因为字符串String是final不能修改值</p><p>但是stringbuilder和stringbuffer是可以的。其中stringbuilder是单线程的</p><p>stringbuffer是多线程，是线程安全的。</p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution56A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals)&#123;</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>]-q[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是先按左端点排序，然后这样就可以清楚合并的顺序</p><p>如果ans的大小大于0，然后p的左端点要小于ans最后一个的右端点的话</p><p>那就可以合并</p><p>然后更新右端点，更新为p的右端点ans最后一个的右端点</p><p>如果不是的话，就把这个数组加进入来</p><p>然后最后将ans转为ans.size大小的数组</p><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution160</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA,B=headB;</span><br><span class="line">        <span class="keyword">while</span> (A!=B)&#123;</span><br><span class="line">            A=(A!=<span class="literal">null</span>)?A.next:headB;</span><br><span class="line">            B=(B!=<span class="literal">null</span>)?B.next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种情况</p><p>一个是B走的快吧，B走到null了，然后A处在的位置就是首个公共节点</p><p>为空了就给他赋值为headA,然后让他从A走</p><p>A为空了就赋值为headB让他从B走，然后他们相遇的地方就是公共节点</p><p>实际上就是A遍历完headA再遍历headB；B反之；这样就相当于走了同样的距离，也就是两次循环找到交点</p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>就是使用双指针，记录中间夹的地方能记录多少雨水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preMax= <span class="number">0</span>,SubMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(height[left],preMax);</span><br><span class="line">            SubMax = Math.max(height[right],SubMax);</span><br><span class="line">            ans +=preMax&lt;SubMax?preMax-height[left++]:SubMax-height[right--];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个记录左边，一个记录右边</p><p>先记录左边这个小的，就是哪个小先记录哪个</p><p>然后指针移动</p><p>更新最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preMax= <span class="number">0</span>,SubMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(height[left],preMax);</span><br><span class="line">            SubMax = Math.max(height[right],SubMax);</span><br><span class="line">            ans +=preMax&lt;SubMax?preMax-height[left++]:SubMax-height[right--];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapA</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>,peak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peak)&#123;</span><br><span class="line">                peak = height[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peakInterL</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peakInterL)&#123;</span><br><span class="line">                peakInterL = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=(peakInterL-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peakInterR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length-<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peakInterR)&#123;</span><br><span class="line">                peakInterR = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=(peakInterR-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个二次遍历</p><h2 id="72-编辑距离-x"><a href="#72-编辑距离-x" class="headerlink" title="72. 编辑距离(x)"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a>(x)</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution124</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">LVal</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">RVal</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line">        ans  = Math.max(ans,LVal+RVal+node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(LVal,RVal)+node.val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选择使用左或者右大的哪个，然后最后返回走过的路径，然后记录ans；</p><p>最后返回。</p><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        ListNode fast= head,slow  =head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果快慢指针相遇的话，说明有环，然后快指针再从头开始，快慢指针第二次相遇的地方，就是开始入环的第一个节点</p><h2 id="93-复原-IP-地址（回溯）"><a href="#93-复原-IP-地址（回溯）" class="headerlink" title="93. 复原 IP 地址（回溯）"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a>（回溯）</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution93</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; segments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;<span class="number">4</span>||s.length()&gt;<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s,<span class="number">0</span>,segments);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s,<span class="type">int</span> index,List&lt;String&gt; segments)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segments.size()==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index==s.length())&#123;</span><br><span class="line">                ans.add(String.join(<span class="string">&quot;.&quot;</span>,segments));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;len&lt;=<span class="number">3</span>;len++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index+len&gt;s.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">segment</span> <span class="operator">=</span> s.substring(index,index+len);</span><br><span class="line">            <span class="keyword">if</span> (isValid(segment)) &#123;</span><br><span class="line">                segments.add(segment);</span><br><span class="line">                dfs(s, index + len, segments);</span><br><span class="line">                segments.remove(segments.size() - <span class="number">1</span>);  <span class="comment">//恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String segment)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segment.length() &gt; <span class="number">1</span> &amp;&amp; segment.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(segment);</span><br><span class="line">        <span class="keyword">return</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回溯算法，主要是要符合ip地址的规则</p><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p>看到这个就想到了这应该是动态规划问题</p><p>嗯按照灵神的思路慢慢推演</p><p>先是<strong>记忆搜索</strong>，最初级的阶段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] s,t;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        s =text1.toCharArray();</span><br><span class="line">        t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span>s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row:memo)&#123;</span><br><span class="line">            Arrays.fill(row,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j]!=-<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (s[i]==t[j]) <span class="keyword">return</span> memo[i][j] = dfs(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j] = Math.max(dfs(i-<span class="number">1</span>,j),dfs(i,j-<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的dfs，然后遇到搜索过的直接调用，减少了时间。</p><p>遇到符合条件的，把这个位置设置为1</p><p>然后返回的时候，去找搜索的时候更好的</p><p>但是这个太慢了，要优化一下</p><p><strong>1:1 翻译成递推</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequenceA</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        s =text1.toCharArray();</span><br><span class="line">        t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span>s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j+<span class="number">1</span>] = s[i] == t[j]?f[i][j]+<span class="number">1</span>:Math.max(f[i][j+<span class="number">1</span>],f[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个主要是递推，就是遍历然后</p><p>下面的i+1,j+1就为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i] == t[j]?f[i][j]+1:Math.max(f[i][j+1],f[i+1][j])</span><br></pre></td></tr></table></figure><p>s[i]和t[j]是不是想到，然后相等的话，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j]</span><br></pre></td></tr></table></figure><p>就+1说明走过了，然后不想的话，就去找下一个路径</p><p>最后公共的就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[n][m]</span><br></pre></td></tr></table></figure><p>然后再进行一波优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequenceB</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> pre=  <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x==t[j]?pre+<span class="number">1</span>:Math.max(f[j+<span class="number">1</span>],f[j]);</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的递推，换成一个数组来操作，这样的话，因为他们的类似方法都是相同的，这样的话，我们直接使用一个数组就可以完成了。</p><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>想象有一把长度固定的尺子，左端点在链表头部，右端点在正数第 <em>n</em> 个节点。向右移动尺子，当尺子右端点到达链表末尾时，左端点就在倒数第 <em>n</em> 个节点。</p><p>我们需要找到倒数第n+1个节点</p><p>左端点在链表头部，右端点在正数第 <em>n</em>+1 个节点。向右移动尺子，当尺子右端点到达链表末尾时，左端点就在倒数第 <em>n</em>+1 个节点。</p><p>我们可以在头节点的前面插入一个哨兵节点（dummy node），把它当作链表的头节点，这样就有正数第 n+1 个节点了。换句话说，如果遇到需要删除头节点的题目，添加哨兵节点可以简化代码逻辑，请记住这个技巧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solution19A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            left = left.next;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = left.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到这个节点，然后直接跳过这个节点就行了</p><p>就相当于删除了这个节点</p><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 新头节点，指向原链表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">duplicateVal</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">// 跳过所有重复节点</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == duplicateVal) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数（困难啊）"><a href="#4-寻找两个正序数组的中位数（困难啊）" class="headerlink" title="4. 寻找两个正序数组的中位数（困难啊）"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a>（困难啊）</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>如果不限制时间复杂度的话，这个题目还是挺简单的。直接从后面开始遍历数组，合并数组。然后找中间的数即可</p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>这个题目肯定是先从跟节点开始，类似于去找他最右边的那个元素。</p><p>所以我们要先递归这个右子树。就是他的这一层第一次出现的时候，也就是深度第一次出现的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution199</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (depth==ans.size())&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>,ans);</span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p>中序遍历吗。就是根节点在中间</p><p>left root right</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution94</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,ans);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        dfs(root.right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution704</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的二分查找，记得这个是</p><p>可以取到值得</p><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span>peek();</span><br><span class="line">        B.pop();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!B.isEmpty()) <span class="keyword">return</span> B.peek();</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            B.push(A.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.isEmpty()&amp;&amp;B.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两个栈，入队得时候就是进A栈，然后出栈得时候，就是A出栈得元素，压入B栈，然后B出栈</p><p>实现先进先出FIFO</p><h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><p>给你两个 <strong>版本号字符串</strong> <code>version1</code> 和 <code>version2</code> ，请你比较它们。版本号由被点 <code>&#39;.&#39;</code> 分开的修订号组成。<strong>修订号的值</strong> 是它 <strong>转换为整数</strong> 并忽略前导零。</p><p>比较版本号时，请按 <strong>从左到右的顺序</strong> 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 <code>0</code>。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution165</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String v1, String v2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> v1.length(),m= v2.length();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n||j&lt;m)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>,num2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n&amp;&amp;v1.charAt(i)!=<span class="string">&#x27;.&#x27;</span>) num1 = num1*<span class="number">10</span>+v1.charAt(i++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;m&amp;&amp;v2.charAt(j)!=<span class="string">&#x27;.&#x27;</span>) num2 = num2*<span class="number">10</span>+v2.charAt(j++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num1&lt;num2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            i++;j++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把小数的哪个分开，然后使用双指针开始遍历</p><p>然后比较</p><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution148A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> head,f =head,ps = head;</span><br><span class="line">        <span class="keyword">while</span> (f!=<span class="literal">null</span>&amp;&amp;f.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">            ps= s;</span><br><span class="line">            s=  s.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span>  <span class="operator">=</span>sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> sortList(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode <span class="title function_">merge</span><span class="params">(ListNode l,ListNode r)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l!=<span class="literal">null</span>&amp;&amp;r!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l.val&lt;=r.val)&#123;</span><br><span class="line">                cur.next = l;</span><br><span class="line">                l = l.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = r;</span><br><span class="line">                r = r.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l==<span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next =r;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了归并排序，跟之前的反转链表类似，找到中点，然后分割，然后进行大小的比较排序</p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution22</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>*n];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span> open)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">2</span>*n)&#123;<span class="comment">//填补完成</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open&lt;n)&#123;<span class="comment">//填补左括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,open+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-open&lt;open)&#123;<span class="comment">//填补右括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,open);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法"> 原地 </a></strong>修改，只允许使用额外常数空间。</p><p>从右向左，找第一个小于右侧相邻数字的数 <em>x</em></p><p>找 <em>x</em> 右边最小的大于 <em>x</em> 的数 <em>y</em>，交换 <em>x</em> 和 <em>y</em></p><p>反转 <em>y</em> 右边的数，把右边的数变成最小的排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution31</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,i+<span class="number">1</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            swap(nums,left++,right--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为先找数，然后交交换，然后反转这三步骤。</p><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution69</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = Math.min(x, <span class="number">46340</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid*mid&lt;=x)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用二分查找来解决，注意这里是mid*mid&lt;=x,也就是小于target</p><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p>虽然看着说是滑动窗口，其实用队列做是更好的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution239AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindowA(<span class="type">int</span>[] nums, <span class="type">int</span> k )&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span>  <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>,i=<span class="number">1</span>-k;j&lt;nums.length;i++,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;deque.peekFirst()==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()&amp;&amp;deque.peekLast()&lt;nums[j])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">                deque.addLast(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)</span><br><span class="line">                res[i] =deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans= <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque= <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()&amp;&amp;nums[deque.getLast()]&lt;=nums[i])&#123;<span class="comment">//入队，维护单调性</span></span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (deque.getFirst()&lt;=i-k)&#123;<span class="comment">//出队队首已经离开窗口了</span></span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=k-<span class="number">1</span>)&#123;队满</span><br><span class="line">                ans[i-k+<span class="number">1</span>] = nums[deque.getFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span>pre;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1==<span class="literal">null</span>?<span class="number">0</span>:l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2==<span class="literal">null</span>?<span class="number">0</span>:l2.val;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span>  <span class="operator">=</span> x+y+carry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            sum = sum%<span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line"></span><br><span class="line">            cur =cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="literal">null</span>)  l1 =l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="literal">null</span>)  l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是实现两个链表数的加法，使用进位的问题</p><h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li><strong>空格：</strong>读入字符串并丢弃无用的前导空格（<code>&quot; &quot;</code>）</li><li><strong>符号：</strong>检查下一个字符（假设还未到字符末尾）为 <code>&#39;-&#39;</code> 还是 <code>&#39;+&#39;</code>。如果两者都不存在，则假定结果为正。</li><li><strong>转换：</strong>通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。</li><li><strong>舍入：</strong>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被舍入为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被舍入为 <code>231 − 1</code> 。</li></ol><p>返回整数作为最终结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Character&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> e : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    started = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    sign = -<span class="number">1</span>;</span><br><span class="line">                    started = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Character.isDigit(e)) &#123;</span><br><span class="line">                    ans.add(e);</span><br><span class="line">                    started = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.isDigit(e)) &#123;</span><br><span class="line">                    ans.add(e);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ans) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; num &gt; Integer.MAX_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (sign == -<span class="number">1</span> &amp;&amp; -num &lt; Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(sign * num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接按要求暴力破解，最后的时候进行一波转换</p><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution70AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">         <span class="keyword">return</span> dfs(n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=<span class="number">0</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="keyword">return</span> memo[i] = dfs(i-<span class="number">1</span>,memo)+dfs(i-<span class="number">2</span>,memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记忆搜推，直接进行</p><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution32A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!stack.isEmpty()&amp;&amp;s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i-leftIndex+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (leftIndex-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    length+=dp[leftIndex-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = length;</span><br><span class="line">                maxlen = Math.max(maxlen,length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一想到了这个有效的括号，我们就想到了用栈来实现</p><p><strong>遇到 <code>&#39;(&#39;</code> 左括号就入栈</strong>，记录它的下标。</p><p><strong>遇到 <code>&#39;)&#39;</code> 右括号：</strong></p><ul><li><p>如果栈不为空，说明有匹配的左括号。</p></li><li><p>从栈中弹出匹配的左括号的下标 <code>leftIndex</code>。</p></li><li><p>当前这一对括号的<strong>基本长度</strong>就是 <code>i - leftIndex + 1</code>。</p></li><li><p><strong>注意：\</strong>如果 <code>leftIndex &gt; 0</code>，而 <code>dp[leftIndex - 1] &gt; 0</code>，说明前面有一段*<em>连续的有效括号*</em>，可以加上！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">length = i - leftIndex + 1 + dp[leftIndex - 1];</span><br></pre></td></tr></table></figure></li><li><p>把这段长度记录到 <code>dp[i]</code> 中，表示以 <code>i</code> 为结尾的最长有效括号长度。</p></li><li><p>更新全局最大值 <code>res = Math.max(res, dp[i])</code>。</p></li></ul><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>这是背包问题，</p><p>问：关于完全背包，有两种写法，一种是外层循环枚举物品，内层循环枚举体积；另一种是外层循环枚举体积，内层循环枚举物品。如何评价这两种写法的优劣？</p><p>答：两种写法都可以，但更推荐前者。外层循环枚举物品的写法，只会遍历物品数组一次；而内层循环枚举物品的写法，会遍历物品数组多次。从 cache 的角度分析，多次遍历数组会导致额外的 cache miss，带来额外的开销。所以虽然这两种写法的时间空间复杂度是一样的，但外层循环枚举物品的写法常数更小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution322</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(f,Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line">        f[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:coins)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c=x;c&lt;=amount;c++)&#123;</span><br><span class="line">                f[c] = Math.min(f[c],f[c-x]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[amount];</span><br><span class="line">        <span class="keyword">return</span> ans&lt;Integer.MAX_VALUE/<span class="number">2</span>?ans:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全背包，先物品再容量.<strong>内层遍历背包容量（从小到大）：</strong>,如果当前容量 <code>c</code> 用当前硬币 <code>x</code>，可以转移为 <code>f[c - x] + 1</code>（多用了1个 <code>x</code> 面额硬币）。</p><h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘</a></h2><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution43</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>)||num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[num1.length()+num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (res[i+j+<span class="number">1</span>]+n1*n2);</span><br><span class="line">                res[i+j+<span class="number">1</span>] =sum%<span class="number">10</span>;</span><br><span class="line">                res[i+j] +=sum/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;res[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            result.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是讲乘法拆开，然后根据</p><p>乘数 <code>num1</code> 位数为 <em>M</em>，被乘数 <code>num2</code> 位数为 <em>N</em>， <code>num1 x num2</code> 结果 <code>res</code> 最大总位数为 <strong>M+N</strong></p><p>num1[i] x num2[j] 的结果为 tmp(位数为两位，”0x”, “xy” 的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。</p><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution105AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> indexOf(inorder,preorder[<span class="number">0</span>]);<span class="comment">//左子树大小</span></span><br><span class="line">        <span class="type">int</span>[] pre1 = Arrays.copyOfRange(preorder,<span class="number">1</span>,<span class="number">1</span>+leftSize);<span class="comment">//左子树序列</span></span><br><span class="line">        <span class="type">int</span>[] pre2 = Arrays.copyOfRange(preorder,<span class="number">1</span>+leftSize,n);<span class="comment">//右子树序列</span></span><br><span class="line">        <span class="type">int</span>[] in1 =Arrays.copyOfRange(inorder,<span class="number">0</span>,leftSize);<span class="comment">//左子树</span></span><br><span class="line">        <span class="type">int</span>[] in2 = Arrays.copyOfRange(inorder,<span class="number">1</span>+leftSize,n);<span class="comment">//右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> buildTree(pre1,in1);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> buildTree(pre2,in2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>],left,right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> x)</span>&#123;<span class="comment">//查找位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]==x)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是根据两个遍历，一层一层的递归，然后完成查找。速度有些慢就是了</p><h2 id="LCR-140-训练计划-II"><a href="#LCR-140-训练计划-II" class="headerlink" title="LCR 140. 训练计划 II"></a><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">LCR 140. 训练计划 II</a></h2><p>给定一个头节点为 <code>head</code> 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 <code>cnt</code> 个训练项目编号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionLCR140</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainingPlan</span><span class="params">(ListNode head, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1: 将链表的 val 存入数组</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            vals.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step2: 从 vals 的最后 cnt 位构造新链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> vals.size() - cnt; i &lt; vals.size(); i++) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(vals.get(i));</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我就是把这个链表的数据提取出来，然后放入新的链表</p><p>时间复杂度太高了</p><p>然后使用了快慢指针来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionLCR140</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainingPlanA</span><span class="params">(ListNode head, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1: 将链表的 val 存入数组</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            vals.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step2: 从 vals 的最后 cnt 位构造新链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> vals.size() - cnt; i &lt; vals.size(); i++) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(vals.get(i));</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainingPlan</span><span class="params">(ListNode head, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        node1 = head;</span><br><span class="line">        node2 = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node2.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>确实这个方法好啊</p><p>类似的可以找出从中点开始的链表</p><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution151</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        String[] str = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>str.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i].equals(<span class="string">&quot;&quot;</span>))<span class="keyword">continue</span>;</span><br><span class="line">            res.append(str[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们直接倒着遍历不得了</p><p>遇到空格就跳过继续，然后把当前拿到的全都放入结果</p><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p>看到这种题目就知识这应该是使用回溯算法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution78A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i== nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(i+<span class="number">1</span>);</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        dfs(i+<span class="number">1</span>);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回溯法，就是选不选第i个</p><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h2><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solution129</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x  =x*<span class="number">10</span>+node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.left==node.right)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(node.left,x)+dfs(node.right,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是遍历，然后到下一层的时候，*10+node.val就ok</p><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (min_stack.isEmpty()||x&lt;=min_stack.peek())&#123;</span><br><span class="line">            min_stack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.pop().equals(min_stack.peek()))&#123;</span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>     <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用两个栈，然后最小的栈存储最小的元素，然后维护这个最小栈</p><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution101A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">null</span>||recur(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L,TreeNode R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>&amp;&amp;R==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>||R==<span class="literal">null</span>||L.val!=R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(L.left,R.right)&amp;&amp;recur(R.left,L.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是遍历，左的左要等于右的右这样的</p><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution34AA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> lowBound(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length || nums[start] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lowBound(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length; <span class="comment">// 注意 right = nums.length，开区间写法</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid; <span class="comment">// nums[mid] &gt;= target</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找，，，</p><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution104AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的递归</p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution93AA</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state,<span class="type">int</span> target,<span class="type">int</span>[] choices,<span class="type">int</span> start,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start;i&lt;choices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target-choices[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state.add(choices[i]);</span><br><span class="line">            backtrack(state,target-choices[i],choices,i,res);</span><br><span class="line">            state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(state,target,candidates,start,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是回溯法+递归，一个一个去遍历找，然后最后恢复</p><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution394</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; countstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;StringBuilder&gt; stringstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">currentString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c))&#123;</span><br><span class="line">                k = k*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                countstack.push(k);</span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">                stringstack.push(currentString);</span><br><span class="line">                currentString = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> countstack.pop();</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> stringstack.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;repeat;i++)&#123;</span><br><span class="line">                    sb.append(currentString);</span><br><span class="line">                &#125;</span><br><span class="line">                currentString = sb;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                currentString.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentString.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左括号的话，就往字符栈里加字符，然后把重复的次数加进数字栈</p><p>然后右括号的时候</p><p>就把数字取出来，作为重复次数，字符栈取出来作为重复的字符</p><p>然后重复就好，单纯的字符就直接加入</p><p>最后返回字符串</p><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常easy的题目</p><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><p>给定一个二叉树，判断它是否是 平衡二叉树 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution110A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) !=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftH</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="keyword">if</span> (leftH==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightH</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="keyword">if</span> (rightH==-<span class="number">1</span>||Math.abs(leftH-rightH)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftH,rightH)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平衡二叉树的定义就是高度差不能s超过1</p><p>然后左边右边都不能超过1，左边右边比较也是</p><h2 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h2><p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数。</p><p>你只能调用 <code>rand7()</code> 且不能调用其他方法。请不要使用系统的 <code>Math.random()</code> 方法。</p><p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数。</p><p><strong>(randX() - 1)<em>Y + randY() 可以等概率的生成[1, X </em> Y]范围的随机数</strong></p><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) grid[i][j] = grid[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) grid[i][j]=grid[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是如果当前的为空的话，就转到另一个地方去尝试，然后把前面的最小的路径加到和上</p><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在<strong><a href="https://baike.baidu.com/item/原地算法"> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix[i][j]→matrix[j][n−1−i]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution48A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span>[][] tmp  = <span class="keyword">new</span> <span class="title class_">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            tmp[i] = matrix[i].clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                matrix[j][n-<span class="number">1</span>-i] = tmp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助一个辅助矩阵，进行顺时针转换</p><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">llen</span> <span class="operator">=</span> dfs(node.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rlen</span> <span class="operator">=</span> dfs(node.right)+<span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans,llen+rlen);</span><br><span class="line">        <span class="keyword">return</span> Math.max(llen,rlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就一致遍历，算左边和右边高度的和</p><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h2><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution221</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] heights = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] row :matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (row[j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    heights[j]=<span class="number">0</span>;<span class="comment">//柱子高度为0</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,largesSize(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">largesSize</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span>[] st = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        st[++top]  = -<span class="number">1</span>;<span class="comment">//在栈中只有一个数的时候，栈顶的「下面那个数」是 -1，对应 left[i] = -1 的情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> heights[right];</span><br><span class="line">            <span class="keyword">while</span> (top&gt;<span class="number">0</span>&amp;&amp;h&lt;=heights[st[top]])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> st[top--];</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> st[top];</span><br><span class="line">                ans =Math.max(ans,Math.min(heights[i],right-left-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            st[++top] =right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将每一行视为“底”，构建柱状图；每一列记录高度，形成一个直方图（heights）；<br> 在这个直方图中，用单调栈找以某个位置为底的最大 <strong>正方形（不是矩形）边长</strong>，最后平方得到面积。</p><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution122A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (tmp&gt;<span class="number">0</span>) profit+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的遍历贪心</p><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>最简单的就是直接遍历，然后比较i和i-1</p><p>但是这样效率太低，所以我们使用hashset来遍历，这样的时间复杂度低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution128A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            st.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:st)&#123;</span><br><span class="line">            <span class="keyword">if</span> (st.contains(x-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (st.contains(y))&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,y-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去找如果有前面的数字的话，就不对。</p><p>有后面数字的话，就y++</p><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution240</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span>  <span class="operator">=</span> matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;matrix.length&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]&lt;target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目类似二分查找</p><p>小于就往右去找，大于就往上去找</p><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>一看到这种的立马想到递归+dfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution98AA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">long</span> left,<span class="type">long</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="keyword">return</span> x&lt;right&amp;&amp;x&gt;left&amp;&amp;dfs(node.left,left,x)&amp;&amp;dfs(node.right,x,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的遍历</p><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>我们可以找到这个链表的中点（快慢指针），然后分为两个链表，反转后面的链表，然后判断是不是想等，两个链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution234</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondList</span> <span class="operator">=</span> reverseList(slow);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> secondList;</span><br><span class="line">        <span class="keyword">while</span> (p2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val!= p2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = node;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution14AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;j&lt;ans.length()&amp;&amp;j&lt;strs[i].length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.charAt(j)!=strs[i].charAt(j)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span> (ans.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的双重遍历</p><h2 id="面试笔试1"><a href="#面试笔试1" class="headerlink" title="面试笔试1"></a>面试笔试1</h2><p>1.</p><p>因为这个表，他需要自己呈现出多层结构，所以要使用自关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> department (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    parent_id <span class="type">INT</span>,  </span><br><span class="line">    leader <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (parent_id) <span class="keyword">REFERENCES</span> department(id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是一个树形的结构，需要使用递归来解决</p><p>递归地解析每一条记录的上级部门，先插入父再插入子</p><p>部门表的实体类的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String leader;</span><br><span class="line">    <span class="keyword">private</span> Integer parentId;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(Integer id, String name, String leader, Integer parentId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.leader = leader;</span><br><span class="line">        <span class="built_in">this</span>.parentId = parentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getParentId</span><span class="params">()</span> &#123; <span class="keyword">return</span> parentId; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Department&gt; <span class="title function_">getChildren</span><span class="params">()</span> &#123; <span class="keyword">return</span> children; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建树的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentTreeBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Department <span class="title function_">buildDepartmentTree</span><span class="params">(List&lt;Department&gt; allDepartments, Integer rootId)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Department&gt; deptMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Department dept : allDepartments) &#123;</span><br><span class="line">            deptMap.put(dept.getId(), dept);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Department</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Department dept : allDepartments) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dept.getParentId() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Department</span> <span class="variable">parent</span> <span class="operator">=</span> deptMap.get(dept.getParentId());</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                parent.getChildren().add(dept);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dept.getId().equals(rootId)) &#123;</span><br><span class="line">                root = dept;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; deptMap.containsKey(rootId)) &#123;</span><br><span class="line">            root = deptMap.get(rootId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.</p><p>需求：体检项目不固定，字段名与字段类型可自定义</p><p>表的设计：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> exam_record (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    user_id <span class="type">INT</span>,</span><br><span class="line">    exam_date <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> exam_field (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>), </span><br><span class="line">    type <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> exam_value (</span><br><span class="line">    record_id <span class="type">INT</span>,</span><br><span class="line">    field_id <span class="type">INT</span>,</span><br><span class="line">    value_text TEXT,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(record_id, field_id),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (record_id) <span class="keyword">REFERENCES</span> exam_record(id),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (field_id) <span class="keyword">REFERENCES</span> exam_field(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用 <code>value_text</code> 存储所有类型的值，在读取时再根据字段定义做类型转换；</p><p>新字段可以动态添加到 <code>exam_field</code> 表，不需要改动表结构；</p><p>数据插入/查询时，通过 field_id 关联字段定义表。</p><p>java代码：</p><p>实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamField</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, ExamField&gt; fieldMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertExamRecord</span><span class="params">(<span class="type">int</span> recordId, Map&lt;String, Object&gt; values)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : values.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="type">ExamField</span> <span class="variable">field</span> <span class="operator">=</span> fieldMap.get(fieldName);</span><br><span class="line">            <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;字段未定义：&quot;</span> + fieldName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">valueText</span> <span class="operator">=</span> String.valueOf(value);</span><br><span class="line"></span><br><span class="line">            insertExamValue(recordId, field.getId(), valueText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertExamValue</span><span class="params">(<span class="type">int</span> recordId, <span class="type">int</span> fieldId, String valueText)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插入：recordId=&quot;</span> + recordId + <span class="string">&quot;, fieldId=&quot;</span> + fieldId + <span class="string">&quot;, value=&quot;</span> + valueText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, ExamField&gt; fieldMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ExamField&gt; fieldIdMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getExamRecord</span><span class="params">(<span class="type">int</span> recordId)</span> &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; rawValues = queryValuesFromDB(recordId);</span><br><span class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : rawValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">fieldId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rawText</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="type">ExamField</span> <span class="variable">field</span> <span class="operator">=</span> fieldIdMap.get(fieldId);</span><br><span class="line">            <span class="keyword">if</span> (field == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Object</span> <span class="variable">realValue</span> <span class="operator">=</span> parseValue(field.getType(), rawText);</span><br><span class="line">            result.put(field.getName(), realValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">parseValue</span><span class="params">(String type, String raw)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;int&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(raw);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;decimal&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> Double.parseDouble(raw);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;date&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> LocalDate.parse(raw);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> raw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; <span class="title function_">queryValuesFromDB</span><span class="params">(<span class="type">int</span> recordId)</span> &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; dummy = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dummy.put(<span class="number">1</span>, <span class="string">&quot;4.8&quot;</span>);</span><br><span class="line">        dummy.put(<span class="number">2</span>, <span class="string">&quot;90&quot;</span>); </span><br><span class="line">        dummy.put(<span class="number">3</span>, <span class="string">&quot;2025-06-26&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>差不多就是这样。</p><h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h2><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p>我们可以直接暴力破解，遍历然后直接看是不是中间的最大的元素，但是这样的时间复杂度为O(logn)</p><p>不行，所以我们考虑是不是可以使用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution162</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p><p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p><p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p><p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p><p>一看除了递归dfs也没啥好的方法了，直接递归吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution695</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=grid.length||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        sum +=dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        sum +=dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        sum +=dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        sum +=dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    max = Math.max(max,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution113AA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,targetSum,path,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> left, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        left -=node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.left==node.right&amp;&amp;left==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(node.left,left,path,ans);</span><br><span class="line">            dfs(node.right,left,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是到了叶子节点我们就把他加入，没到叶子节点的话，就去递归左右节点</p><p>然后操作完之后如果超过了的话，那我我们回溯，把这次的删除。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode动态规划</title>
      <link>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;爬楼梯&quot;&gt;&lt;a href=&quot;#爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;爬楼梯&quot;&gt;&lt;/a&gt;爬楼梯&lt;/h1&gt;&lt;h2 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>按着数学来看的话，就是如果是1阶梯的话，就是1</p><p>大于等于2的有两种，是i-1+(i-2)</p><p>然后我们使用记忆数组来记忆之前算过的</p><p>然后使用递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution70A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo  = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>  (memo[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = dfs(i-<span class="number">1</span>,memo)+dfs(i-<span class="number">2</span>,memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到记忆数组不是1的，调用记忆数组，为0的就直接计算</p><p>这样就不会超时</p><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution746</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span> [] memo = <span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(n,memo,cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span>[] memo,<span class="type">int</span>[] cost)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> dfs(i-<span class="number">1</span>,memo,cost)+cost[i-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> dfs(i-<span class="number">2</span>,memo,cost)+cost[i-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> memo[i] = Math.min(res2,res1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面那个题一样，只不过最后取的时候，是看花费哪个少了</p><h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>本质还是爬楼梯问题啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution377</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(target,nums,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] nums,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;=i)&#123;</span><br><span class="line">                res +=dfs(i-x,nums,memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i]  = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是类似的</p><h2 id="2466-统计构造好字符串的方案数"><a href="#2466-统计构造好字符串的方案数" class="headerlink" title="2466. 统计构造好字符串的方案数"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 统计构造好字符串的方案数</a></h2><p>给你整数 <code>zero</code> ，<code>one</code> ，<code>low</code> 和 <code>high</code> ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p><ul><li>将 <code>&#39;0&#39;</code> 在字符串末尾添加 <code>zero</code> 次。</li><li>将 <code>&#39;1&#39;</code> 在字符串末尾添加 <code>one</code> 次。</li></ul><p>以上操作可以执行任意次。</p><p>如果通过以上过程得到一个 <strong>长度</strong> 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <strong>好</strong> 字符串。</p><p>请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2466</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span>[high+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=zero) f[i] = f[i-zero];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=one) f[i] = (f[i]+f[i-one])%MOD;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=low) ans = (ans+f[i])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递推</p><p>相当于把递推式 <em>f</em>[<em>i</em>]=<em>f</em>[<em>i</em>−<em>zero</em>]+<em>f</em>[<em>i</em>−<em>one</em>] 拆分成了两步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[high + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>); <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) &#123;</span><br><span class="line">            ans = (ans + dfs(i, zero, one, memo)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> zero, <span class="type">int</span> one, <span class="type">int</span>[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = (dfs(i - zero, zero, one, memo) + dfs(i - one, zero, one, memo)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记忆递推方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
