<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Thu, 11 Sep 2025 12:35:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>SpringAI源码分析</title>
      <link>https://blog.tokenlen.top/2025/09/11/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/springai/</link>
      <guid>https://blog.tokenlen.top/2025/09/11/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/springai/</guid>
      <pubDate>Wed, 10 Sep 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;Spring AI Alibaba Graph&lt;/h1&gt;
&lt;p&gt;旨在利用 Spring AI 作为桥梁，连接阿里巴巴的大语言模型（如通义千wen）和图数据库（如阿里云 GDB），以实现通过自然语言与复杂关联数据进行交互的目的。&lt;/p&gt;
&lt;p&gt;底层核心原理是</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>Spring AI Alibaba Graph</h1><p>旨在利用 Spring AI 作为桥梁，连接阿里巴巴的大语言模型（如通义千wen）和图数据库（如阿里云 GDB），以实现通过自然语言与复杂关联数据进行交互的目的。</p><p>底层核心原理是 <strong>Text-to-Cypher/Gremlin</strong>，即<strong>将用户的自然语言问题，通过大语言模型（LLM）动态翻译成图数据库的专业查询语言</strong>。</p><h2 id="设计思想">设计思想</h2><p>图数据库（Graph Database）非常擅长处理实体之间的复杂关系，例如社交网络中的“朋友的朋友”、金融风控中的“资金链路”、电商中的“共同购买”等。但要查询这些数据，需要使用专门的图查询语言，如 <strong>Gremlin</strong> (阿里云 GDB 支持) 或 <strong>Cypher</strong>。这些语言学习门槛高，普通业务人员无法直接使用。</p><p>“Spring AI Alibaba Graph”架构的核心思想就是解决这个问题：让 LLM 充当一个智能的“翻译官”。</p><p>流程：</p><p><strong>赋予 LLM 上下文知识 (Context Awareness)</strong>：一个通用的 LLM 不知道你的图数据库里有什么。因此，必须在查询时，动态地告诉 LLM 图的**“Schema”**（模式），包括：</p><ul><li><strong>节点标签 (Node Labels)</strong>：例如 <code>Person</code>（人）、<code>Company</code>（公司）、<code>Product</code>（产品）。</li><li><strong>边标签 (Edge Labels)</strong>：例如 <code>WORKS_FOR</code>（为…工作）、<code>INVESTED_IN</code>（投资了）、<code>BOUGHT</code>（购买了）。</li><li><strong>属性 (Properties)</strong>：每个节点和边上可能有的属性，例如 <code>Person</code> 节点有 <code>name</code>, <code>age</code> 属性。</li></ul><p><strong>利用 LLM 的代码生成能力 (Code Generation)</strong>：大语言模型本质上是一个强大的序列生成器，它不仅能生成文章，也能生成代码。通过<strong>精巧的提示工程 (Prompt Engineering)</strong>，我们可以引导 LLM 将用户的自然语言问题，结合我们提供的图 Schema，生成一段完全正确的 Gremlin 或 Cypher 查询代码。</p><p><strong>自动化执行与反馈</strong>：生成查询代码后，程序自动执行它，并将结果返回。为了提升用户体验，甚至可以将图数据库返回的结构化数据再次交给 LLM，让它用自然语言进行总结和概括。</p><h2 id="架构">架构</h2><p>实际流程：</p><p><strong>用户提问</strong>： 用户通过前端界面或 API，输入自然语言问题：“查询投资了‘阿里巴巴’的所有人的姓名”。</p><p><strong>Spring 应用接收</strong>： 一个基于 Spring Boot 和 Spring AI 构建的后端服务接收到这个请求。</p><p><strong>构建精确的 Prompt</strong>： 这是最关键的一步。程序会动态构建一个发给 LLM 的 Prompt，它通常包含以下部分：</p><ul><li><strong>入口</strong> : 开发者代码调用 <code>graphClient.query(&quot;查詢投資了阿里巴巴的所有人&quot;)</code> 。<br><strong>委派</strong> : <code>DefaultGraphClient</code> 将请求委派给 <code>graphChatService.chat(&quot;...&quot;)</code> 。<br><strong>检索(Retrieval)</strong> : <code>graphChatService</code> 首先调用其持有的 <code>graphStore.getSchema()</code> 方法。 <code>Neo4jGraphStore</code> （假设）会连接 Neo4j 数据库，执行 <code>CALL db.schema.visualization()</code> 或类似命令，获取 Schema 并格式化为文本。<br><strong>构建(Prompt Construction)</strong> : <code>graphChatService</code> 使用 <code>GraphChatPromptFactory</code> ，将上一步获取的 Schema 文本和用户问题填充到一个预设的模板中，生成最终的 <code>Prompt</code> 对象。<br><strong>生成(Generation)</strong> : <code>graphChatService</code> 调用 <code>chatClient.call(prompt)</code> 。 <code>spring-ai-alibaba-tongyi-starter</code> 捕获此调用，向通义千问 API 发送请求。<br><strong>解析(Parsing)</strong> : 通义千问返回一个包含 Cypher 查询的 <code>ChatResponse</code> 。 <code>graphChatService</code> 使用 <code>GraphCypherResponseParser</code> 从中提取出纯净的 Cypher 查询字符串。<br><strong>执行(Execution)</strong> : <code>graphChatService</code> 拿到查询字符串后，调用 <code>graphStore.execute(cypherQuery)</code> 。<strong>返回</strong> : <code>Neo4jGraphStore</code> 使用 Neo4j Java Driver 执行查询，并将结果返回。这个结果最终沿着调用链返回给开发者。</li></ul><h2 id="三大核心">三大核心</h2><p>GraphStore，图存储的统一抽象</p><p><strong>设计目的</strong> : 将上层的“Text-to-Query”逻辑与底层具体的图数据库（Neo4j, NebulaGraph, 阿里云 GDB 等）完全解耦。无论底层是什么图数据库，对上层来说，它们都只是一个 <code>GraphStore</code></p><p>核心方法：</p><p><code>getSchema()</code> : 这是实现 RAG 的<strong>信息来源</strong> 。此方法负责连接到底层数据库，并提取其 Schema 信息（节点标签、边标签、属性等），将其格式化为一个可以喂给 LLM 的字符串。</p><p><code>execute(String query)</code> : 这是<strong>执行查询</strong>的统一入口。它接收 LLM 生成的查询字符串（如 Cypher 或 Gremlin），并通过具体的数据库驱动来执行它，然后返回结果。</p><p><strong>设计模式</strong> : <strong>策略模式(Strategy Pattern)</strong> 。用户可以根据自己的数据库类型，注入不同的 <code>GraphStore</code> 实现（例如 <code>Neo4jGraphStore</code> , <code>TinkerPopGremlinGraphStore</code> ），而上层 <code>GraphClient</code> 的代码无需任何改动。一个抽象类的实现</p><p>问题and挑战：</p><ol><li><code>GraphStore.getSchema()</code> 的“信息密度”挑战</li></ol><p><strong>“提示词爆炸” (Prompt Explosion) 与成本问题</strong>：当图的 Schema 变得非常庞大时（成百上千种节点和边），<code>getSchema()</code> 返回的字符串会非常长。这不仅会急剧增加调用 LLM 的 Token 成本，更严重的是，过长的、充斥着大量无关信息的上下文，反而可能<strong>降低 LLM 的理解和推理能力</strong>，导致生成错误的查询。</p><p><strong>Schema 的“知识”密度不足</strong>：Schema 只定义了“结构”，但没有定义“语义”。例如，一个 <code>TRANSACTION</code> 的边，其 <code>amount</code> 属性是正是负代表什么业务含义？LLM 仅从 Schema 中无法得知。</p><p>解决：</p><p>一个更先进的 <code>GraphStore</code> 实现，不应该仅仅是“暴力”地返回整个 Schema。它应该进化为一个**“Schema 智能检索器”**：</p><ol><li><strong>Schema 知识图谱化/向量化</strong>：将图的 Schema 本身（节点标签、边标签、属性及其注释）也构建成一个小型知识图谱或将其向量化存储。</li><li><strong>两阶段 RAG</strong>：当用户提问时，<strong>第一阶段</strong>，先对用户的问题进行向量相似度搜索，从海量的 Schema 中<strong>检索出与问题最相关的子图 Schema</strong>（例如，问题关于“交易”，就只提取 <code>Account</code>, <code>Transaction</code> 等相关的节点和边）。<strong>第二阶段</strong>，再将这个高度相关的、精简的子图 Schema 喂给 LLM 去生成查询。</li><li><strong>动态数据样本</strong>：<code>getSchema()</code> 还可以被增强为 <code>getContext()</code>，除了返回 Schema，还能动态地从图中抓取几条与问题相关的<strong>实际数据样本</strong>（例如，几条交易记录），一并作为上下文提供给 LLM。这能极大地帮助 LLM 理解数据格式和语义，提升查询准确率。</li></ol><p>GraphClient ：面向用户的核心入口</p><p><strong>设计目的</strong> : 隐藏所有内部复杂的交互流程（获取 Schema -&gt; 构建 Prompt -&gt; 调用 LLM -&gt; 解析响应-&gt; 执行查询），为最终用户提供一个极其简单的接口。</p><p><strong>核心方法剖析</strong>:</p><ul><li><code>query(String question, ...)</code> : 这是最核心的方法。开发者只需要传入自然语言问题，就可以得到图数据库的查询结果。它的默认实现 <code>DefaultGraphClient</code> 会<strong>编排</strong>下面要讲的 <code>GraphChatService</code> 和 <code>GraphStore</code> 来完成整个流程。</li></ul><p>GraphChatService ：LLM 交互与智能的核心</p><p><strong>设计目的</strong> : 专门负责处理与大语言模型（LLM）之间的所有交互，实现核心的“Text-to-Query”转换逻辑。</p><p>核心：</p><p><strong>依赖注入</strong> : 它会被注入一个 <code>GraphStore</code> 实例和一个 Spring AI 的 <code>ChatClient</code> 实例。<br><strong>Prompt 工厂</strong> : 内部会使用一个 <code>GraphChatPromptFactory</code> 来创建 Prompt。这个工厂是<strong>提示工程(Prompt Engineering)</strong> 的具体体现，它会接收 <code>GraphStore.getSchema()</code> 获取到的 Schema 和用户问题，然后把它们组装成一个结构化、高质量的 Prompt 模板。<br><strong>调用 LLM</strong> : 它使用注入的 <code>ChatClient</code> 将生成的 Prompt 发送给 LLM（例如通义千问）。<strong>响应解析</strong> : 它还包含一个 <code>ResponseParser</code> 。因为 LLM 的返回内容可能不只是纯粹的查询语句（例如，可能包含在 Markdown 的 <code>cypher ...</code> 代码块中，或者有一些解释性的文字）， <code>ResponseParser</code> 负责从 LLM 的原始响应中<strong>精确地提取出可执行的查询代码</strong> 。这一步是保证系统稳定性的关键。</p><h1>Google GraphRAG</h1><p>Google GraphRAG 的核心目标是<strong>从非结构化文本中构建图，以优化 RAG 的检索效果</strong>。</p><p>传统的向量检索（Vector Search）只能找到与问题“表面相似”的文本片段，却忽略了文档内部和文档之间隐藏的<strong>深层语义关联</strong>。GraphRAG 的核心思想就是<strong>通过从文本中提取实体和关系来构建知识图谱，并利用图的社区结构来发现这些深层关联，从而为 LLM 提供更全面、更具上下文的背景信息</strong>。</p><p><strong>图的角色</strong>：在这里，图<strong>不是最终的知识库</strong>，而是一个为了提升检索质量而生成的**“中间索引结构”**。最终答案的来源（Source of Truth）依然是原始的文本。</p><hr><p>GraphRAG 的流程分为“离线索引”和“在线查询”两个阶段。</p><p><strong>阶段一：离线索引（数据预处理）</strong></p><ol><li><strong>实体与关系提取 (Information Extraction)</strong>：系统读取所有源文档（如 PDF, Word, TXT），利用 LLM 遍历这些文本，提取出关键的实体（人、事、物、概念）以及它们之间的关系。</li><li><strong>图谱构建 (Graph Construction)</strong>：将提取出的实体作为“节点”，关系作为“边”，构建一个全局的知识图谱。</li><li><strong>社区检测 (Community Detection)</strong>：在构建好的图上运行图算法（如 Leiden 算法），将整个图划分成若干个高内聚、低耦合的“语义社区”。每个社区代表了一组在语义上紧密相关的主题或事件。</li><li><strong>社区摘要 (Community Summarization)</strong>：利用 LLM 为每一个检测出的社区生成一个高度概括的摘要描述。</li></ol><p><strong>阶段二：在线查询（应答用户提问）</strong></p><ol><li><strong>用户提问</strong>：用户提出一个问题。</li><li><strong>多路检索 (Multi-path Retrieval)</strong>：系统并行地在两个层面上进行检索：<ul><li><strong>全局检索</strong>：在所有“社区摘要”上进行向量检索，快速定位到与问题最相关的几个社区。</li><li><strong>局部检索</strong>：同时，也在所有原始文本块上进行传统的向量检索。</li></ul></li><li><strong>上下文构建 (Context Building)</strong>：这是 GraphRAG 的<strong>核心创新</strong>。一旦通过全局检索定位到了一个或多个相关社区，系统<strong>不再是只返回几个零散的文本块，而是将整个社区内的所有实体、关系、以及关联的原始文本块，作为一个完整的、结构化的上下文</strong>提供出来。</li><li><strong>生成答案 (Answer Generation)</strong>：将这个极其丰富且上下文完整的“社区信息包”喂给 LLM，让它基于这些信息生成最终的、高质量的答案。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/springAI/">springAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/09/11/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/springai/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dubbo源码分析</title>
      <link>https://blog.tokenlen.top/2025/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/dubbo-alay/</link>
      <guid>https://blog.tokenlen.top/2025/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/dubbo-alay/</guid>
      <pubDate>Tue, 09 Sep 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;设计&lt;/h1&gt;
&lt;h2 id=&quot;分层架构&quot;&gt;分层架构&lt;/h2&gt;
&lt;p&gt;Dubbo 最显著的特点就是其&lt;strong&gt;分层架构&lt;/strong&gt;。官方文档中将其划分为 10 层，但为了便于理解，我们可以将其归纳为三大块：&lt;strong&gt;业务层、RPC</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>设计</h1><h2 id="分层架构">分层架构</h2><p>Dubbo 最显著的特点就是其<strong>分层架构</strong>。官方文档中将其划分为 10 层，但为了便于理解，我们可以将其归纳为三大块：<strong>业务层、RPC 核心层、Remoting 通信层</strong>。</p><p><strong>业务层 (Business Layer)</strong>:</p><ul><li><strong>Service 层</strong>: 开发者定义的业务接口和实现。</li><li><strong>Config 层</strong>: 对外配置层，用于配置服务的暴露和引用，如 <code>ServiceConfig</code> 和 <code>ReferenceConfig</code>。这是开发者直接接触的部分。</li></ul><p><strong>RPC 核心层 (RPC Core Layer)</strong>: 这是 Dubbo 功能的核心所在。</p><ul><li><strong>Proxy 层</strong>: 服务代理层。为消费者端生成接口的代理对象，使其能像调用本地方法一样调用远程服务。</li><li><strong>Registry 层</strong>: 注册中心层。负责服务的注册与发现，封装了与 Zookeeper、Nacos 等注册中心的交互。</li><li><strong>Cluster 层</strong>: 集群容错层。当从注册中心获取到多个服务提供者时，由该层决定如何选择（负载均衡）以及在调用失败时如何应对（容错机制）。</li><li><strong>Monitor 层</strong>: 监控层。负责统计服务的调用次数、耗时等信息。</li><li><strong>Protocol 层</strong>: 远程调用层。<strong>这是 RPC 的核心</strong>，封装了调用协议的细节，如 <code>DubboProtocol</code>, <code>HttpProtocol</code>, <code>TripleProtocol</code> 等。它负责管理 <code>Invoker</code> 的生命周期。</li></ul><p><strong>Remoting 通信层 (Remoting Layer)</strong>:</p><ul><li><strong>Exchange 层</strong>: 信息交换层。在 <code>Transport</code> 层之上封装了请求-响应模型。</li><li><strong>Transport 层</strong>: 网络传输层。抽象了 <code>Client</code> 和 <code>Server</code>，封装了底层网络库（如 Netty, Mina）的细节。</li><li><strong>Serialize 层</strong>: 序列化层。负责对象与字节流之间的转换。</li></ul><h2 id="核心机制">核心机制</h2><p>微内核 + SPI 扩展机制</p><p><strong>微内核架构 (Microkernel Architecture) 与 开闭原则 (Open/Closed Principle)</strong> Dubbo 的核心（Kernel）非常小，它本身只负责整合和流程串联。所有具体的功能，如协议、序列化、负载均衡、注册中心等，都被抽象为接口，并通过 SPI 机制作为可插拔的<strong>扩展点 (Extension Point)</strong> 来加载。</p><p>SPI实现：</p><p><strong>核心类</strong>: <code>org.apache.dubbo.common.extension.ExtensionLoader</code> 这个类是 Dubbo SPI 机制的心脏。每个扩展点接口（如 <code>Protocol</code>, <code>LoadBalance</code>）都有一个与之对应的 <code>ExtensionLoader</code> 实例，负责该扩展点的所有实现类的加载、缓存和管理。</p><p><strong>约定大于配置</strong>:</p><ol><li><p><strong><code>@SPI</code> 注解</strong>: 在一个接口上标注 <code>@SPI</code>，即表示该接口是一个扩展点。注解的 <code>value</code> 是该扩展点的默认实现名称。</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;dubbo&quot;) // 默认使用 DubboProtocol</span><br><span class="line">public interface Protocol &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置文件</strong>: 所有的扩展实现都定义在 <code>META-INF/dubbo/</code> 目录下的以接口全限定名命名的文件中。 文件内容是 <code>key=value</code> 的形式，<code>key</code> 是扩展名，<code>value</code> 是实现类的全限定名。 例如，<code>META-INF/dubbo/org.apache.dubbo.rpc.Protocol</code> 文件内容可能为：</p><p>Properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line">http=org.apache.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line">triple=org.apache.dubbo.rpc.protocol.tri.TripleProtocol</span><br></pre></td></tr></table></figure></li></ol><p><strong>强大的特性</strong>:</p><ul><li><strong>自动注入 (IOC)</strong>: <code>ExtensionLoader</code> 会自动为加载的扩展实例注入其依赖的其他扩展点。</li><li><strong>自适应扩展 (Adaptive Extension)</strong>: Dubbo 中最精妙的设计之一。它能为扩展点接口动态生成一个代理类，这个代理类在运行时能根据**调用上下文（通常是 <code>URL</code> 对象）**来动态决定具体使用哪个扩展实现。这使得 Dubbo 可以在运行时灵活切换行为。</li><li><strong>自动包装 (AOP)</strong>: 如果一个扩展实现类有拷贝构造函数，Dubbo 会认为它是一个 Wrapper 类，用它来包装其他扩展实现，从而轻松实现 AOP 功能。</li></ul><h2 id="RPC的生命周期">RPC的生命周期</h2><p>服务提供者 (Provider) 暴露过程</p><p><strong>触发</strong>: 当 Spring 容器启动时，解析到 <code>&lt;dubbo:service&gt;</code> 或 <code>@DubboService</code>。</p><p><strong>配置解析</strong>: <code>ServiceConfig</code> 类承载了所有配置信息。其 <code>export()</code> 方法是服务暴露的入口。</p><p><strong>协议选择与暴露</strong>: <code>export()</code> 方法会调用 <code>doExportUrls()</code>，它会根据配置的协议（如 <code>dubbo</code>），通过 <strong>SPI</strong> 机制获取 <code>Protocol</code> 接口的对应实现，即 <code>ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(&quot;dubbo&quot;)</code>，得到 <code>DubboProtocol</code> 实例。</p><p><strong>打开服务器</strong>: <code>DubboProtocol.export()</code> 方法会启动一个网络服务器（如 <code>NettyServer</code>，这又是通过 SPI 获取的 <code>Transporter</code> 扩展）。同时，它会将业务实现类包装成一个 <code>Invoker</code> 对象，并维护一个 <code>ip:port -&gt; Invoker</code> 的映射。</p><p><strong>服务注册</strong>: <code>Protocol</code> 的实现类（通常是 <code>RegistryProtocol</code>，它包装了真正的协议实现）会构建服务提供者的 <code>URL</code>，然后通过 <strong>SPI</strong> 获取 <code>Registry</code> 扩展（如 <code>ZookeeperRegistry</code>），调用其 <code>register()</code> 方法，将服务信息注册到注册中心。</p><p>服务消费者 (Consumer) 引用与调用过程</p><p><strong>触发</strong>: Spring 容器启动，解析到 <code>&lt;dubbo:reference&gt;</code> 或 <code>@DubboReference</code>。</p><p><strong>配置解析</strong>: <code>ReferenceConfig</code> 类承载配置，其 <code>get()</code> 方法是获取远程服务代理的入口。</p><p><strong>创建代理</strong>: <code>get()</code> 方法的核心是创建代理。它同样通过 <code>RegistryProtocol</code> 从注册中心订阅服务提供者列表。</p><p><strong>集群与容错</strong>: <code>RegistryProtocol</code> 将获取到的多个提供者 <code>URL</code> 列表，通过 <strong>SPI</strong> 获取 <code>Cluster</code> 扩展（如 <code>FailoverCluster</code>），调用其 <code>join()</code> 方法。<code>Cluster</code> 会将多个 <code>Invoker</code> 聚合成一个单一的、具备容错能力的 <code>Invoker</code>。</p><p><strong>生成代理</strong>: <code>ProxyFactory</code> 扩展（如 <code>JavassistProxyFactory</code>）会为业务接口生成一个代理对象。这个代理对象内部持有了上一步生成的 <code>Cluster Invoker</code>。</p><p><strong>发起调用</strong>: 当开发者调用代理对象的方法时：</p><p>a. 请求会进入代理对象的 <code>InvocationHandler</code>，最终会调用 <code>Cluster Invoker</code> 的 <code>invoke()</code> 方法。</p><p>b. <code>Cluster Invoker</code> 内部会通过 <strong>SPI</strong> 获取 <code>LoadBalance</code> 扩展（如 <code>RandomLoadBalance</code>）从多个提供者 <code>Invoker</code> 中选择一个。</p><p>c. 选中的 <code>Invoker</code>（代表一个远程连接）会通过 <code>ExchangeClient</code> -&gt; <code>NettyClient</code> 发送请求。</p><p>d. 请求数据会经过 <code>Serialization</code> 扩展（如 <code>Hessian2Serialization</code>）进行序列化。</p><p>e. 字节流通过 Netty 发送到服务提供者端。</p><p><strong>接收与执行</strong>: 提供者端的 <code>NettyServer</code> 接收到数据，经过反序列化后，找到对应的 <code>Invoker</code>，最终调用到业务实现类的原始方法。执行结果再原路返回。</p><p>精髓：</p><p><strong>统一模型 <code>URL</code></strong>: Dubbo 设计中另一个极其 brilliant 的地方，就是使用 <code>URL</code> 对象作为其核心配置的总线。无论是服务提供者、消费者、注册中心信息，还是调用过程中的各种参数，都被统一封装在 <code>URL</code> 对象中，在各层之间传递。这使得整个框架几乎是无状态的，极大地简化了扩展的实现难度，因为所有扩展都可以从 <code>URL</code> 中获取自己需要的所有上下文信息。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/dubbo/">dubbo</category>
      
      
      <comments>https://blog.tokenlen.top/2025/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/dubbo-alay/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>分布式架构</title>
      <link>https://blog.tokenlen.top/2025/09/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cap1/</link>
      <guid>https://blog.tokenlen.top/2025/09/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cap1/</guid>
      <pubDate>Mon, 08 Sep 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;分布式&lt;/h1&gt;
&lt;h2 id=&quot;1-介绍一下CAP理论&quot;&gt;1.介绍一下CAP理论&lt;/h2&gt;
&lt;p&gt;CAP 原则又称 CAP 定理, 指的是在一个分布式系统中, Consistency（一致性）、 Availability（可用性）、Partition</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>分布式</h1><h2 id="1-介绍一下CAP理论">1.介绍一下CAP理论</h2><p>CAP 原则又称 CAP 定理, 指的是在一个分布式系统中, Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）, <strong>三者不可得兼</strong></p><ul><li><strong>一致性© :</strong> 在分布式系统中的所有数据备份, 在同一时刻是否同样的值(等同于所有节点访问同一份最新的数据副本)</li><li><strong>可用性(A):</strong> 在集群中一部分节点故障后, 集群整体是否还能响应客户端的读写请求(对数据更新具备高可用性)</li><li><strong>分区容忍性(P):</strong> 以实际效果而言, 分区相当于对通信的时限要求. 系统如果不能在时限内达成数据一致性, 就意味着发生了分区的情况, 必须就当前操作在 C 和 A 之间做出选择</li></ul><h2 id="2-如何使用redis分布式锁">2.如何使用redis分布式锁</h2><p><strong>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用</strong>。</p><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p><ul><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure><p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p><p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><h2 id="3-如何使用zookeeper实现分布式锁">3.如何使用zookeeper实现分布式锁</h2><p>zookeeper是一个为分布式应用提供一致性服务的软件，它内部是一个分层的文件系统目录树结构，规定统一个目录下只能有一个唯一文件名。</p><p>数据模型：</p><ul><li>永久节点：节点创建后，不会因为会话失效而消失</li><li>临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点</li><li>顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</li></ul><p>监视器（watcher）：</p><ul><li>当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。</li></ul><p>利用Zookeeper的临时顺序节点和监听机制两大特性，可以帮助我们实现分布式锁。</p><p>流程：</p><ul><li>首先得有一个持久节点<code>/locks</code>, 路径服务于某个使用场景，如果有多个使用场景建议路径不同。</li><li>请求进来时首先在<code>/locks</code>创建临时有序节点，所有会看到在<code>/locks</code>下面有seq-000000000, seq-00000001 等等节点。</li><li>然后判断当前创建得节点是不是<code>/locks</code>路径下面最小的节点，如果是，获取锁，不是，阻塞线程，同时设置监听器，监听前一个节点。</li><li>获取到锁以后，开始处理业务逻辑，最后delete当前节点，表示释放锁。</li><li>后一个节点就会收到通知，唤起线程，重复上面的判断。</li></ul><p>zookerper 实现的分布式锁是强一致性的，**因为它底层的 ZAB协议(原子广播协议), 天然满足 CP，**但是这也意味着性能的下降, 所以不站在具体数据下看 Redis 和 Zookeeper, 代表着性能和一致性的取舍。</p><p>如果项目没有强依赖 ZK, 使用 Redis 就好了, 因为现在 Redis 用途很广, 大部分项目中都引用了 Redis，没必要对此再引入一个新的组件, 如果业务场景对于 Redis 异步方式的同步数据造成锁丢失无法忍受, 在业务层处理就好了。</p><h2 id="4-分布式限流">4.分布式限流</h2><ul><li><strong>滑动窗口限流算法</strong>是对固定窗口限流算法的改进，有效解决了窗口切换时可能会产生两倍于阈值流量请求的问题。</li><li>漏桶限流算法能够对流量起到整流的作用，让随机不稳定的流量以固定的速率流出，但是不能解决<strong>流量突发</strong>的问题。</li><li><strong>令牌桶算法</strong>作为漏斗算法的一种改进，除了能够起到平滑流量的作用，还允许一定程度的流量突发。</li></ul><hr><p>固定窗口限流算法就是对一段固定时间窗口内的请求进行计数，如果请求数超过了阈值，则舍弃该请求；如果没有达到设定的阈值，则接受该请求，且计数加1。当时间窗口结束时，重置计数器为0。</p><p>固定窗口限流优点是实现简单，但是会有“流量吐刺”的问题，假设窗口大小为1s，限流大小为100，然后恰好在某个窗口的第999ms来了100个请求，窗口前期没有请求，所以这100个请求都会通过。再恰好，下一个窗口的第1ms有来了100个请求，也全部通过了，那也就是在2ms之内通过了200个请求，而我们设定的阈值是100，通过的请求达到了阈值的两倍，这样可能会给系统造成巨大的负载压力。</p><hr><p>滑动窗口限流</p><p>滑动窗口限流算法，滑动窗口就是将限流窗口内部切分成一些更小的时间片，然后在时间轴上滑动，每次滑动，滑过一个小时间片，就形成一个新的限流窗口，即滑动窗口。然后在这个滑动窗口内执行固定窗口算法即可。</p><p>滑动窗口可以避免固定窗口出现的放过两倍请求的问题，因为一个短时间内出现的所有请求必然在一个滑动窗口内，所以一定会被滑动窗口限流。</p><hr><p>漏桶限流算法</p><p>漏桶限流算法是模拟水流过一个有漏洞的桶进而限流的思路</p><p>水龙头的水先流入漏桶，再通过漏桶底部的孔流出。如果流入的水量太大，底部的孔来不及流出，就会导致水桶太满溢出去。</p><p>从系统的角度来看，我们不知道什么时候会有请求来，也不知道请求会以多大的速率来，这就给系统的安全性埋下了隐患。但是如果加了一层漏斗算法限流之后，就能够保证请求以恒定的速率流出。在系统看来，请求永远是以平滑的传输速率过来，从而起到了保护系统的作用。</p><p>使用漏桶限流算法，缺点有两个：</p><ul><li>即使系统资源很空闲，多个请求同时到达时，漏桶也是慢慢地一个接一个地去处理请求，这其实并不符合人们的期望，因为这样就是在浪费计算资源。</li><li>不能解决流量突发的问题，假设漏斗速率是2个/秒，然后突然来了10个请求，受限于漏斗的容量，只有5个请求被接受，另外5个被拒绝。你可能会说，漏斗速率是2个/秒，然后瞬间接受了5个请求，这不就解决了流量突发的问题吗？不，这5个请求只是被接受了，但是没有马上被处理，处理的速度仍然是我们设定的2个/秒，所以没有解决流量突发的问题</li></ul><hr><p>令牌桶限流算法</p><p>令牌桶是另一种桶限流算法，模拟一个特定大小的桶，然后向桶中以特定的速度放入令牌（token），请求到达后，必须从桶中取出一个令牌才能继续处理。如果桶中已经没有令牌了，那么当前请求就被限流。如果桶中的令牌放满了，令牌桶也会溢出。</p><p>放令牌的动作是持续不断进行的，如果桶中令牌数达到上限，则丢弃令牌，因此桶中可能一直持有大量的可用令牌。此时请求进来可以直接拿到令牌执行。比如设置 qps 为 100，那么限流器初始化完成 1 秒后，桶中就已经有 100 个令牌了，如果此前还没有请求过来，这时突然来了 100 个请求，该限流器可以抵挡瞬时的 100 个请求。由此可见，只有桶中没有令牌时，请求才会进行等待，最终表现的效果即为以一定的速率执行。</p><p>令牌桶限流算法综合效果比较好，能在最大程度利用系统资源处理请求的基础上，实现限流的目标，建议通常场景中优先使用该算法。</p><h2 id="5-分布式一致算法">5.分布式一致算法</h2><p>Raft 和 Paxos 是两种经典的分布式一致性算法，旨在实现<strong>多节点状态机的高可靠一致性</strong>。两者核心目标相同（保证分布式系统数据一致性），但设计理念和实现方式有区别。</p><blockquote><p>raft 协议的原理</p></blockquote><p>Raft算法由leader节点来处理一致性问题。leader节点接收来自客户端的请求日志数据，然后同步到集群中其它节点进行复制，当日志已经同步到超过半数以上节点的时候，leader节点再通知集群中其它节点哪些日志已经被复制成功，可以提交到raft状态机中执行。</p><p>通过以上方式，Raft算法将要解决的一致性问题分为了以下几个子问题。</p><ul><li>leader选举：集群中必须存在一个leader节点。</li><li>日志复制：leader节点接收来自客户端的请求然后将这些请求序列化成日志数据再同步到集群中其它节点。</li><li>安全性：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引 的另一条日志数据输入到raft状态机中执行。</li></ul><p>Raft算法需要有两个比较重要的机制</p><ul><li><strong>角色转换与选举机制</strong>：Raft 将系统中的节点分为三种角色：领导者（Leader）、跟随者（Follower）和候选人（Candidate）。系统启动时，所有节点都是跟随者。跟随者会定期从领导者处接收心跳信息以确认领导者的存活。如果跟随者在一段时间内（选举超时时间）没有收到领导者的心跳，它会转变为候选人，发起新一轮的选举。候选人向其他节点发送请求投票消息。其他节点根据收到的请求投票消息，决定是否为该候选人投票。当候选人获得超过半数节点的投票时，它就成为新的领导者。领导者会周期性地向所有跟随者发送心跳消息，以维持自己的领导地位。每个领导者的领导周期称为一个任期（Term），任期号是单调递增的。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1741335422453-5a93e24e-d9a4-49c9-9ae8-170e7db0e387.png" alt="img"></p><ul><li><strong>日志复制机制</strong>：客户端的请求会被领导者作为日志条目添加到自己的日志中。领导者将新的日志条目复制到其他跟随者节点。它会通过附加日志消息将日志条目发送给跟随者，跟随者收到消息后会将日志条目追加到自己的日志中，并向领导者发送确认消息。当领导者得知某个日志条目已经被大多数节点复制时，它会将该日志条目标记为已提交，并将其应用到状态机中。然后，领导者会通知其他节点该日志条目已提交，跟随者也会将已提交的日志条目应用到自己的状态机中。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1741335463759-7880ff38-4280-47c9-ac37-a0acbaedc6c3.png" alt="img"></p><blockquote><p>paxos协议的原理</p></blockquote><p>Paxos算法的核心思想是将一致性问题分解为多个阶段，每个阶段都有一个专门的协议来处理。Paxos算法的主要组成部分包括提议者（Proposer）、接受者（Acceptor）和投票者（Voter）。</p><ul><li>提议者：提议者是负责提出一致性问题的节点，它会向接受者发送提议，并等待接受者的回复。</li><li>接受者：接受者是负责处理提议的节点，它会接收提议者发送的提议，并对提议进行判断。如果接受者认为提议是有效的，它会向投票者发送请求，并等待投票者的回复。</li><li>投票者：投票者是负责决定提议是否有效的节点，它会接收接受者发送的请求，并对请求进行判断。如果投票者认为请求是有效的，它会向接受者发送投票，表示支持或反对提议。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1741336124270-c0328978-0eed-4409-bc42-dfaddf10a373.png" alt="img"></p><p>Paxos算法的流程如下（以Basic Paxos 算法为例子）：</p><ul><li>准备阶段：提议者选择一个提案编号，并向所有接受者发送准备请求。提案编号是一个全局唯一的、单调递增的数字。接受者收到准备请求后，如果提案编号大于它之前接受过的任何提案编号，它会承诺不再接受编号小于该提案编号的提案，并返回它之前接受过的最大编号的提案信息（如果有）。</li><li>接受阶段：如果提议者收到了超过半数接受者的响应，它会根据这些响应确定要提议的值。如果接受者返回了之前接受过的提案信息，提议者会选择编号最大的提案中的值作为要提议的值；如果没有，提议者可以选择自己的值。提议者向所有接受者发送接受请求，包含提案编号和要提议的值。</li><li>学习阶段：当提议者收到超过半数接受者对某个提案的接受响应时，该提案被认为达成共识。学习者通过接受者的通知得知达成共识的值。</li></ul><p>对比总结</p><ul><li><strong>Raft</strong> 更易于理解和实现，它将共识过程分解为选举和日志复制两个相对独立的子问题，并且对选举超时时间等参数进行了明确的定义和限制，降低了算法的复杂度。</li><li><strong>Paxos</strong> 是一种更通用、更基础的共识算法，它的理论性更强，在学术界有广泛的研究和应用。但 Paxos 的实现相对复杂，理解和调试难度较大。</li></ul><h1>分布式事务</h1><h2 id="1-分布式事务的解决方案你知道哪些？">1.分布式事务的解决方案你知道哪些？</h2><table><thead><tr><th><strong>方案</strong></th><th><strong>一致性</strong></th><th><strong>性能</strong></th><th><strong>复杂度</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>2PC</td><td>强一致性</td><td>低</td><td>中</td><td>传统数据库、XA协议</td></tr><tr><td>3PC</td><td>强一致性</td><td>中低</td><td>高</td><td>需减少阻塞的强一致场景</td></tr><tr><td>TCC</td><td>最终一致性</td><td>高</td><td>高</td><td>高并发业务（支付、库存）</td></tr><tr><td>Saga</td><td>最终一致性</td><td>中</td><td>高</td><td>长事务、跨服务流程</td></tr><tr><td>消息队列</td><td>最终一致性</td><td>高</td><td>中</td><td>事件驱动架构</td></tr><tr><td>本地消息表</td><td>最终一致性</td><td>中</td><td>低</td><td>异步通知（订单-积分）</td></tr></tbody></table><ul><li>两阶段提交协议（2PC）：为准备阶段和提交阶段。准备阶段，协调者向参与者发送准备请求，参与者执行事务操作并反馈结果。若所有参与者准备就绪，协调者在提交阶段发送提交请求，参与者执行提交；否则发送回滚请求。实现简单，能保证事务强一致性。存在单点故障，协调者故障会影响事务流程；性能低，多次消息交互增加延迟；资源锁导致资源长时间占用，降低并发性能。适用于对数据一致性要求高、并发度低的场景，如金融系统转账业务。</li><li>三阶段提交协议（3PC）：在 2PC 基础上，将准备阶段拆分为询问阶段和准备阶段，形成询问、准备和提交三个阶段。询问阶段协调者询问参与者能否执行事务，后续阶段与 2PC 类似。降低参与者阻塞时间，提高并发性能，引入超时机制一定程度解决单点故障问题。无法完全避免数据不一致，极端网络情况下可能出现部分提交部分回滚。用于对并发性能有要求、对数据一致性要求相对较低的场景。</li><li>TCC：将业务操作拆分为 Try、Confirm、Cancel 三个阶段。Try 阶段预留业务资源，Confirm 阶段确认资源完成业务操作，Cancel 阶段在失败时释放资源回滚操作。可根据业务场景定制开发，性能较高，减少资源占用时间。开发成本高，需实现三个方法，要处理异常和补偿逻辑，实现复杂度大。适用于对性能要求高、业务逻辑复杂的场景，如电商系统订单处理、库存管理。</li><li>Saga：将长事务拆分为多个短事务，每个短事务有对应的补偿事务。某个短事务失败，按相反顺序执行补偿事务回滚系统状态。性能较高，短事务可并行执行减少时间，对业务侵入性小，只需实现补偿事务。只能保证最终一致性，部分补偿事务失败可能导致系统状态不一致。适用于业务流程长、对数据一致性要求为最终一致性的场景，如旅游系统订单、航班、酒店预订。</li><li>可靠消息最终一致性方案：基于消息队列，业务系统执行本地事务时将业务操作封装成消息发至消息队列，下游系统消费消息并执行操作，失败则消息队列重试。实现简单，对业务代码修改小，系统耦合度低，能保证数据最终一致性。消息队列可靠性和性能影响大，可能出现消息丢失或延迟，需处理消息幂等性。适用于对数据一致性要求为最终一致性、系统耦合度低的场景，如电商订单支付、库存扣减。</li><li>本地消息表：业务与消息存储在同一个数据库，利用本地事务保证一致性，后台任务轮询消息表，通过MQ通知下游服务，下游服务消费成功后确认消息，失败则重试。简单可靠，无外部依赖。消息可能重复消费，需幂等设计。适用场景是异步最终一致性（如订单创建后通知积分服务）</li></ul><h2 id="2-seata">2.seata</h2><p>Seata 是开源分布式事务解决方案，支持多种模式：</p><ul><li><strong>AT模式</strong>：是 Seata 默认的模式，基于支持本地 ACID 事务的关系型数据库。在 AT 模式下，Seata 会自动生成回滚日志，在业务 SQL 执行前后分别记录数据的快照。当全局事务需要回滚时，根据回滚日志将数据恢复到事务开始前的状态。</li><li><strong>TCC模式</strong>：需要开发者手动编写 Try、Confirm 和 Cancel 三个方法。Try 方法用于对业务资源进行预留，Confirm 方法用于确认资源并完成业务操作，Cancel 方法用于在业务执行失败时释放预留的资源。</li><li><strong>SAGA 模式</strong>：将一个长事务拆分为多个短事务，每个短事务都有一个对应的补偿事务。当某个短事务执行失败时，会按照相反的顺序执行之前所有短事务的补偿事务，将系统状态回滚到初始状态。</li></ul><h1>组件</h1><h2 id="1-RPC">1.RPC</h2><p>RPC 即远程过程调用，允许程序调用运行在另一台计算机上的程序中的过程或函数，就像调用本地程序中的过程或函数一样，而无需了解底层网络细节。</p><p>一个典型的 RPC 调用过程通常包含以下几个步骤：</p><ol><li><strong>客户端调用</strong>：客户端程序调用本地的一个 “伪函数”（也称为存根，Stub），并传入所需的参数。这个 “伪函数” 看起来和普通的本地函数一样，但实际上它会负责处理远程调用的相关事宜。</li><li><strong>请求发送</strong>：客户端存根将调用信息（包括函数名、参数等）进行序列化，然后通过网络将请求发送到服务器端。</li><li><strong>服务器接收与处理</strong>：服务器端接收到请求后，将请求信息进行反序列化，然后找到对应的函数并执行。</li><li><strong>结果返回</strong>：服务器端将函数的执行结果进行序列化，通过网络发送回客户端。</li><li><strong>客户端接收结果</strong>：客户端接收到服务器返回的结果后，将其反序列化，并将结果返回给调用者。</li></ol><p>常见的 RPC 框架：</p><ul><li><strong>gRPC</strong>：由 Google 开发的高性能、开源的 RPC 框架，支持多种编程语言，使用 Protocol Buffers 作为序列化协议，具有高效、灵活等特点。</li><li><strong>Thrift</strong>：由 Facebook 开发的跨语言的 RPC 框架，支持多种数据传输协议和序列化格式，具有良好的可扩展性和性能。</li><li><strong>Dubbo</strong>：阿里巴巴开源的高性能 Java RPC 框架，提供了服务治理、集群容错、负载均衡等功能，广泛应用于国内的互联网企业。</li></ul><h2 id="2-gRPC-Dubbo">2.gRPC&amp;Dubbo</h2><p><strong>gRPC</strong> 是 Google 推出的、<strong>面向跨语言、高性能、云原生场景</strong>的 RPC 协议和框架。它更像一套严格的“通信法规”。</p><p><strong>Dubbo</strong> 是阿里巴巴开源、后贡献给 Apache 的、<strong>面向大规模微服务治理</strong>的 RPC 框架。它的核心优势在于“服务治理”的“全家桶”能力。</p><p>网络协议</p><p><strong>gRPC</strong>:</p><ul><li><strong>严格基于 HTTP/2</strong>。这是 gRPC 高性能的关键之一。HTTP/2 带来了<strong>多路复用 (Multiplexing)</strong>，允许在单个 TCP 连接上同时处理多个请求和响应，彻底解决了 HTTP/1.x 的队头阻塞问题。</li><li>还利用了 HTTP/2 的<strong>头部压缩 (Header Compression)</strong> 和 <strong>服务端推送 (Server Push)</strong> 等特性，进一步减少了网络开销和延迟。</li><li>其二进制分帧 (Binary Framing) 层使得数据传输非常高效。</li></ul><p><strong>Dubbo</strong>:</p><ul><li><strong>Dubbo 2.x</strong>: 默认使用<strong>私有的 Dubbo TCP 协议</strong>。这是一个基于 TCP 的长连接协议，其协议设计非常精简，性能也很高。但缺点是它是一个私有协议，通用性差，跨语言支持困难，且在协议探测、网关穿透等方面存在一些挑战。</li><li><strong>Dubbo 3.x</strong>: 引入了全新的 <strong>Triple 协议</strong>。这个协议<strong>完全兼容 gRPC</strong>，底层同样基于 HTTP/2。这是 Dubbo 迈向云原生、实现跨语言互通的关键一步。现在，一个 Dubbo3 服务既可以被 Dubbo 客户端调用，也可以被标准的 gRPC 客户端调用。</li></ul><hr><p>序列化协议</p><p><strong>gRPC</strong>:</p><ul><li><strong>强制使用 Protocol Buffers (Protobuf)</strong> 作为其 IDL。开发者必须先在 <code>.proto</code> 文件中定义服务接口和消息体（数据结构）。</li><li>这种“<strong>契约先行 (Contract First)</strong>”的方式，使得服务定义与具体实现语言完全解耦，是其跨语言能力的基础。</li><li>Protobuf 是一种<strong>二进制序列化协议</strong>，其序列化后的体积非常小，解析速度快，这为 gRPC 的高性能提供了另一重保障。</li></ul><p><strong>Dubbo</strong>:</p><ul><li><strong>Dubbo 2.x</strong>: 传统上是“<strong>代码先行 (Code First)</strong>”。开发者直接定义 Java 接口，这个接口就是服务的契约。</li><li>序列化协议<strong>灵活可选</strong>，默认是 <strong>Hessian2</strong>，也支持 Protobuf、JSON、Kryo 等。Hessian2 在 Java 体系中性能和兼容性表现均衡，但跨语言支持不如 Protobuf。</li><li><strong>Dubbo 3.x</strong>: 在保持对 Java 接口兼容的同时，也<strong>全面支持基于 Protobuf 的服务定义</strong>，向 gRPC 的“契约先行”模式看齐，以此来强化其跨语言能力。</li></ul><hr><p>功能</p><p><strong>gRPC</strong>:</p><ul><li>gRPC 自身只关注“通信”，对服务治理（如服务发现、负载均衡、熔断、路由）<strong>提供的是基础的拦截器 (Interceptor) 机制</strong>，但没有内置完整的解决方案。</li><li>它的设计哲学是<strong>将服务治理能力下沉到基础设施层</strong>，与 <strong>服务网格 (Service Mesh)</strong>，如 Istio、Linkerd 配合使用，通过 Sidecar 模式实现强大的治理能力。</li></ul><p><strong>Dubbo</strong>:</p><ul><li><strong>强大的服务治理是 Dubbo 的“王牌”</strong>。它在框架层面内置了几乎所有微服务治理需要的功能，并且是高度可扩展的。</li><li><strong>服务发现</strong>：通过注册中心 (Registry)，支持 Zookeeper, Nacos, Consul, etcd 等。</li><li><strong>负载均衡</strong>：内置多种策略 (Random, RoundRobin, ConsistentHash 等)。</li><li><strong>容错机制</strong>：内置多种集群容错策略 (Failover, Failfast, Failsafe 等)。</li><li><strong>动态路由</strong>：可以实现精细化的流量调度。</li><li>这些功能通过 SDK 的方式集成在应用中，对于开发者来说“开箱即用”。</li></ul><p>应用场景：</p><p>何时选择 gRPC？</p><ul><li>多语言异构环境 (Polyglot Systems)</li><li>对性能和延迟极度敏感的场景</li><li>需要流式通信的场景</li><li>云原生与服务网格环境</li></ul><p>何时选择 Dubbo？</p><ul><li>以 Java 技术栈为主的大规模微服务集群</li><li>需要精细化服务治理与控制的场景</li><li>从传统架构向微服务平滑演进</li><li>追求“一站式解决方案”的团队</li></ul><h2 id="3-zookeeper拿来做什么？核心的原理是什么？">3.zookeeper拿来做什么？核心的原理是什么？</h2><p>zookeeper是 <strong>分布式协调服务</strong>，它能很好地支持集群部署，并且具有很好的分布式协调能力，可以让我们在分布式部署的应用之间传递数据， 保证 <strong>顺序一致性（全序广播）</strong> 而不是 **强一致性，**以下是其常见的应用场景：</p><ul><li><strong>配置管理</strong>：在分布式系统中，不同节点往往需要相同的配置信息，如数据库连接参数、服务端口等。ZooKeeper 可以将这些配置信息集中存储，当配置发生变更时，能及时通知到各个节点。例如，一个由多个微服务组成的系统，各个服务实例可以从 ZooKeeper 中获取统一的配置，当配置更新时，ZooKeeper 会通知所有相关服务重新加载配置。</li><li><strong>服务注册与发现</strong>：服务注册与发现是微服务架构中的关键环节。服务提供者在启动时将自己的服务信息（如服务名称、地址、端口等）注册到 ZooKeeper 中，服务消费者通过 ZooKeeper 查找并获取服务提供者的信息。当服务提供者发生变化（如上线、下线、故障等）时，ZooKeeper 会实时更新服务列表并通知服务消费者。像 Dubbo 框架就可以利用 ZooKeeper 实现服务的注册与发现。</li><li><strong>分布式锁</strong>：在分布式环境下，多个进程或线程可能会竞争同一资源，为了避免数据不一致等问题，需要实现分布式锁。ZooKeeper 可以通过创建临时顺序节点来实现分布式锁。当一个客户端需要获取锁时，它会在 ZooKeeper 中创建一个临时顺序节点，然后检查自己创建的节点是否是序号最小的节点，如果是，则表示获取到了锁；如果不是，则等待前一个节点释放锁。</li></ul><p>ZooKeeper 的数据模型类似于文件系统的树形结构，每个节点称为 Znode。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1741337056083-d9acc5ca-a24f-4d38-9a54-7b3d52052f12.png" alt="img"></p><p>每个 Znode 可以存储数据，也可以有子节点。Znode 有不同的类型，包括持久节点（PERSISTENT）、临时节点（EPHEMERAL）和顺序节点（SEQUENTIAL）。</p><ul><li><strong>持久节点</strong>：一旦创建，除非主动删除，否则会一直存在。</li><li><strong>临时节点</strong>：与客户端会话绑定，当客户端会话结束时，临时节点会自动被删除。</li><li><strong>顺序节点</strong>：在创建时，ZooKeeper 会为其名称添加一个单调递增的序号，保证节点创建的顺序性。</li></ul><p>ZooKeeper 使用 ZAB协议来保证集群中数据的一致性。ZAB 协议基于主从架构，有一个领导者（Leader）和多个跟随者（Follower）。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1741337086749-5975f92a-275e-40ab-99d0-b6727d6a7a3f.png" alt="img"></p><ul><li><strong>消息广播</strong>：当客户端发起写请求时，请求会先到达领导者。领导者将写操作封装成一个事务提案，并广播给所有跟随者。跟随者收到提案后，将其写入本地日志，并向领导者发送确认消息。当领导者收到超过半数跟随者的确认消息后，会发送提交消息给所有跟随者，跟随者收到提交消息后，将事务应用到本地状态机。</li><li><strong>崩溃恢复</strong>：当领导者出现故障时，ZooKeeper 会进入崩溃恢复阶段。在这个阶段，集群会选举出新的领导者，并确保在新领导者产生之前，不会处理新的写请求。选举过程基于节点的事务 ID 和节点 ID 等信息，保证新选举出的领导者包含了所有已提交的事务。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</category>
      
      
      <comments>https://blog.tokenlen.top/2025/09/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cap1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring源码分析</title>
      <link>https://blog.tokenlen.top/2025/09/08/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/spring-alay/</link>
      <guid>https://blog.tokenlen.top/2025/09/08/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/spring-alay/</guid>
      <pubDate>Sun, 07 Sep 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;IOC&lt;/h1&gt;
&lt;h2 id=&quot;BeanDefinition&quot;&gt;BeanDefinition&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BeanDefinition&lt;/code&gt; 是 Spring IoC 容器的基石，它是 Bean</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>IOC</h1><h2 id="BeanDefinition">BeanDefinition</h2><p><code>BeanDefinition</code> 是 Spring IoC 容器的基石，它是 Bean 的一切元数据（类名、作用域、构造函数参数、属性等）的载体，是面向接口编程思想的体现。容器操作的是 <code>BeanDefinition</code>，而非直接操作 <code>Class</code>。</p><p>我们最常用的就是<code>DefaultListableBeanFactory</code> 中 <code>beanDefinitionMap</code> 这个 <code>ConcurrentHashMap</code>，所有加载的 <code>BeanDefinition</code> 都存储于此。</p><p>然后我们的IOC容器<code>ApplicationContext</code> 根据其实现（XML, Annotation）选择不同的策略（Reader, Scanner）来加载 <code>BeanDefinition</code>。<strong>模板方法模式</strong>在 <code>AbstractBeanDefinitionReader</code> 等类中被广泛使用。</p><p><strong>XML 路径</strong>: 从 <code>AbstractXmlApplicationContext</code> 的构造函数出发 -&gt; <code>loadBeanDefinitions(new XmlBeanDefinitionReader(this))</code> -&gt; <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> -&gt; <code>doLoadDocument()</code> (将XML转为DOM) -&gt; <code>registerBeanDefinitions()</code> (解析DOM并注册 <code>BeanDefinition</code>)。</p><p><strong>注解路径</strong>: 从 <code>AnnotationConfigApplicationContext</code> 构造函数出发 -&gt; <code>this.scanner.scan(...)</code> -&gt; <code>ClassPathBeanDefinitionScanner.doScan()</code> -&gt; <code>findCandidateComponents()</code> (扫描路径，找到符合条件的类) -&gt; <code>isCandidateComponent()</code> (检查是否包含 <code>@Component</code> 等注解) -&gt; <code>registerBeanDefinition()</code>。</p><p>IOC容器就是<code>BeanFactory</code> 是 IoC 容器的“核心引擎”，负责 Bean 的生命周期管理。而 <code>ApplicationContext</code> 是一个更高级的“企业级容器”，它继承了 <code>BeanFactory</code> 的所有功能，并在此基础上集成了AOP、事件发布、国际化等众多高级服务。</p><p><code>BeanFactory</code>: 顶层接口，定义了 <code>getBean()</code> 等核心方法。</p><p><code>ListableBeanFactory</code>: 扩展接口，提供枚举所有 Bean 的能力。</p><p><code>ConfigurableListableBeanFactory</code>: <code>BeanFactory</code> 体系的终极接口，几乎包含了所有功能。</p><p><code>ApplicationContext</code>: 继承了 <code>ListableBeanFactory</code> 和其他多个高级接口。</p><p><code>AbstractApplicationContext</code>: 核心中的核心，其 <code>refresh()</code> 方法定义了容器启动的完整流程。</p><p>追踪**<code>AbstractApplicationContext.refresh()</code> 方法**：</p><blockquote><p><code>refresh()</code>方法可以说是Spring IoC容器的“启动引擎”。它的核心使命就是根据我们的配置，<strong>创建并初始化一个功能完备的ApplicationContext，最终让所有Bean都准备就绪</strong>，随时可以被应用程序使用。</p><h3 id="准备与定义加载">准备与定义加载</h3><ol><li><strong><code>prepareRefresh()</code></strong>: 做一些启动前的准备工作，比如设置启动时间、激活状态等。</li><li><strong><code>obtainFreshBeanFactory()</code></strong>: 这是<strong>奠定基础</strong>的一步。它会创建一个<code>DefaultListableBeanFactory</code>（IoC容器的底层核心），然后去解析我们的配置文件（无论是XML还是注解），把Bean的定义信息，也就是<code>BeanDefinition</code>，加载到容器中。<strong>需要强调的是，这个阶段只是加载了“蓝图”，还没有创建任何Bean的实例。</strong></li><li><strong><code>prepareBeanFactory()</code></strong>: 对创建好的<code>BeanFactory</code>进行一些基础配置，比如设置类加载器、添加一些内置的后置处理器等。</li><li><strong><code>postProcessBeanFactory()</code></strong>: 这是一个模板方法，留给子类去扩展，体现了Spring设计的灵活性。</li></ol><h3 id="第二阶段：核心处理与扩展">第二阶段：核心处理与扩展</h3><p>这个阶段是<code>refresh()</code>的精髓所在，体现了Spring强大的扩展能力。这里有两个最重要的扩展点：</p><ol><li><strong><code>invokeBeanFactoryPostProcessors()</code></strong>: 调用所有<code>BeanFactoryPostProcessor</code>。这个扩展点允许我们在所有Bean实例化<strong>之前</strong>，去<strong>修改Bean的定义信息（BeanDefinition）</strong>。比如，我们常用的<code>$&#123;...&#125;</code>属性占位符替换，就是在这里完成的。<code>@Configuration</code>和<code>@ComponentScan</code>等注解的解析也是由这个阶段的后置处理器完成的。</li><li><strong><code>registerBeanPostProcessors()</code></strong>: 注册所有<code>BeanPostProcessor</code>。这个扩展点则是在Bean<strong>实例化之后、初始化前后</strong>对Bean实例本身进行“加工”。<strong>Spring的AOP和声明式事务就是通过这个机制实现的</strong>。它会在这里为符合条件的Bean创建动态代理对象，对Bean实例进行增强。</li></ol><h3 id="第三阶段：实例化与完成">第三阶段：实例化与完成</h3><ol><li><strong><code>initMessageSource()</code> 和 <code>initApplicationEventMult-icaster()</code></strong>: 分别初始化国际化支持和事件广播器，为事件驱动模型做准备。</li><li><strong><code>onRefresh()</code></strong>: 又一个模板方法，像Spring Boot内嵌的Tomcat就是在这里启动的。</li><li><strong><code>registerListeners()</code></strong>: 把我们定义的事件监听器注册到事件广播器上。</li><li><strong><code>finishBeanFactoryInitialization()</code></strong>: <strong>这是整个流程中最重量级的一步</strong>。Spring会在这里实例化所有非懒加载的单例Bean。这个过程包括了<strong>实例化、属性填充（依赖注入）、以及执行各种初始化回调</strong>，比如<code>@PostConstruct</code>和<code>BeanPostProcessor</code>的前后置处理方法。</li><li><strong><code>finishRefresh()</code></strong>: 所有工作完成后，它会发布一个<code>ContextRefreshedEvent</code>事件，通知应用程序容器已经准备就绪。</li></ol></blockquote><h2 id="bean的生命周期">bean的生命周期</h2><p><code>AbstractAutowireCapableBeanFactory</code>: Bean 生命周期的主要执行者。</p><p><code>DefaultListableBeanFactory.preInstantiateSingletons()</code> -&gt; <code>getBean()</code> -&gt; <code>doGetBean()</code>开始</p><p>AbstractAutowireCapableBeanFactory.createBean()包含以下扩展点：</p><p><code>resolveBeforeInstantiation()</code>: 第一次扩展点，允许 <code>InstantiationAwareBeanPostProcessor</code> 返回一个代理对象，直接短路后续流程（AOP 早期代理化的机会）。</p><p><code>doCreateBean()</code>:</p><ul><li><code>createBeanInstance()</code>: <strong>【实例化】</strong> 通过构造函数反射创建 Bean 的空对象。</li><li><code>populateBean()</code>: <strong>【属性填充】</strong> 依赖注入发生于此。会调用 <code>InstantiationAwareBeanPostProcessor</code> 的 <code>postProcessProperties()</code> 方法。</li><li><code>initializeBean()</code>: <strong>【初始化】</strong> 这是最复杂的阶段，顺序如下：<ol><li><code>invokeAwareMethods()</code>: 调用 <code>BeanNameAware</code>, <code>BeanFactoryAware</code> 等接口。</li><li><code>applyBeanPostProcessorsBeforeInitialization()</code>: 调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法。</li><li><code>invokeInitMethods()</code>: 调用 <code>afterPropertiesSet()</code> (<code>InitializingBean</code>) 或自定义的 <code>init-method</code>。</li><li><code>applyBeanPostProcessorsAfterInitialization()</code>: <strong>【AOP 关键点】</strong> 调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法。AOP 就是在这里通过 <code>AnnotationAwareAspectJAutoProxyCreator</code> 将原始对象包装成代理对象的。</li></ol></li></ul><h2 id="循环依赖的解决">循环依赖的解决</h2><p>Spring 用来解决单例 Bean Setter 注入循环依赖的“三级缓存”机制</p><p>DefaultSingletonBeanRegistry这个来解决</p><p>从<code>doGetBean()</code> -&gt; <code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code>开始</p><p><code>singletonObjects</code> (一级缓存): <code>Map&lt;String, Object&gt;</code>，存放完全初始化好的 Bean，是最终的成品。</p><p><code>earlySingletonObjects</code> (二级缓存): <code>Map&lt;String, Object&gt;</code>，存放<strong>提前暴露</strong>的、未完成初始化的 Bean。这个 Bean <strong>可能</strong>是原始对象，也<strong>可能</strong>是已经过 AOP 代理的对象。</p><p><code>singletonFactories</code> (三级缓存): <code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code>，存放一个能产生 Bean 的工厂 <code>ObjectFactory</code>（通常是一个 Lambda 表达式）。工厂的目的是<strong>推迟</strong>代理对象的创建。</p><p>例子：</p><p>A 正在创建，实例化后，将一个 <code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code> 的 <code>ObjectFactory</code> 放入<strong>三级缓存</strong> <code>singletonFactories</code>。</p><p>A 在属性填充时发现需要 B，于是去创建 B。</p><p>B 在创建过程中发现需要 A，于是去 <code>getBean(A)</code>。</p><p><code>getBean(A)</code> 时，先查一级缓存（无），再查二级缓存（无），最后查到三级缓存中有 A 的工厂。</p><p>执行 A 的 <code>ObjectFactory</code>，调用 <code>getEarlyBeanReference()</code>，如果 A 需要被代理，就在此时创建代理对象，否则返回原始对象。然后将结果放入<strong>二级缓存</strong> <code>earlySingletonObjects</code>，并移除三级缓存中的工厂。B 获得了 A 的（代理）对象，完成创建。</p><p>B 创建完毕，A 获得了 B 的对象，也完成创建，最终放入<strong>一级缓存</strong>。</p><ul><li><strong>空间换时间</strong>和<strong>延迟计算</strong>。通过增加缓存来解决对象创建过程中的时序问题。三级缓存的核心思想是，只有在真正发生循环依赖时，才通过 <code>ObjectFactory</code> 去提前创建（可能存在的）代理对象。</li></ul><h1>AOP</h1><h2 id="动态代理">动态代理</h2><p>AOP 是如何通过“运行时织入”的方式，在不侵入业务代码的前提下，为其附加新功能的。掌握两种动态代理技术的底层原理及其在 Spring 中的应用。</p><p>动态代理模式：</p><p>JDK: <code>java.lang.reflect.Proxy</code>, <code>java.lang.reflect.InvocationHandler</code>。</p><p>CGLIB: <code>net.sf.cglib.proxy.Enhancer</code>, <code>net.sf.cglib.proxy.MethodInterceptor</code>。</p><p>Spring 封装: <code>AopProxyFactory</code>, <code>JdkDynamicAopProxy</code>, <code>ObjenesisCglibAopProxy</code>。</p><p>跟踪 <code>DefaultAopProxyFactory.createAopProxy()</code> 方法：</p><blockquote><p><code>DefaultAopProxyFactory.createAopProxy()</code>这个方法是Spring AOP创建代理对象的<strong>决策中心</strong>。它的核心职责就是<strong>根据目标对象的特征，决定到底使用哪种动态代理技术来创建代理</strong>。</p><p><strong>如果目标对象实现了一个或多个接口</strong>，Spring默认会选择使用 <strong>JDK动态代理</strong>。它会在运行时动态创建一个新的代理类，这个代理类实现了目标对象所实现的所有接口，并将方法调用转发给一个<code>InvocationHandler</code>进行处理。</p><p><strong>如果目标对象没有实现任何接口</strong>，那么JDK动态代理就无法工作了。此时，Spring会选择使用 <strong>CGLIB代理</strong>，CGLIB通过在运行时动态创建一个<strong>目标类的子类</strong>来作为代理。因为它使用的是继承，所以不要求目标类实现接口。</p><p>还有一个关键配置会影响这个决策，那就是<code>proxyTargetClass</code>属性。</p><ul><li><strong>如果<code>proxy-target-class</code>被设置为<code>true</code></strong>（在Spring Boot中这是默认设置），那么<code>createAopProxy()</code>方法会<strong>跳过接口检查，直接选择使用CGLIB代理</strong>。这样做的好处是统一了代理行为，避免了因目标对象是否有接口而导致代理方式不同的问题，并且可以直接代理类本身的方法，而不仅仅是接口方法。</li></ul></blockquote><h2 id="代理链路">代理链路</h2><p>Spring AOP 从解析切面 (<code>@Aspect</code>) 到创建代理，再到执行通知 (<code>Advice</code>)</p><p>重要的类：</p><p><code>AnnotationAwareAspectJAutoProxyCreator</code>: 最核心的 <code>BeanPostProcessor</code>，驱动整个 AOP 流程。</p><p><code>Advisor</code>: Spring AOP 的内部最小单元，包含一个 <code>Pointcut</code> 和一个 <code>Advice</code>。</p><p><code>Advised</code>: 代理对象的配置信息持有者。</p><p><code>ReflectiveMethodInvocation</code>: 方法调用链的实现，负责依次执行拦截器。</p><p>步骤：</p><p><strong>代理创建</strong>: 如前所述，发生在 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的 <code>postProcessAfterInitialization</code> 方法中。它会调用 <code>wrapIfNecessary()</code>。</p><p><strong>寻找匹配的 Advisor</strong>: 在 <code>wrapIfNecessary()</code> 内部，会调用 <code>findCandidateAdvisors()</code> 找到所有切面，然后通过 <code>findAdvisorsThatCanApply()</code> 根据切入点表达式（Pointcut）筛选出适用于当前 Bean 的所有 <code>Advisor</code>。</p><p><strong>创建代理</strong>: 如果找到 <code>Advisor</code>，则调用 <code>createProxy()</code> 创建代理对象。</p><p><strong>代理执行</strong>: 当调用代理对象的方法时，会进入 <code>JdkDynamicAopProxy.invoke()</code> 或 <code>CglibAopProxy.DynamicAdvisedInterceptor.intercept()</code>。</p><p><strong>构建拦截器链</strong>: 代理逻辑会从 <code>Advised</code> 配置中获取所有适用的 <code>Advisor</code>，并将它们转换成一个拦截器链（<code>List&lt;Object&gt; chain</code>）。</p><p><strong>链式调用</strong>: 创建一个 <code>ReflectiveMethodInvocation</code> 实例，并调用其 <code>proceed()</code> 方法。<code>proceed()</code> 方法会依次调用链中的每一个拦截器（即 <code>Advice</code>），最后调用目标方法。</p><h1>事务</h1><p>Spring 如何巧妙地利用 AOP 将命令式的、与业务逻辑高度耦合的事务代码（<code>try-catch-finally</code>, <code>commit</code>, <code>rollback</code>）“剥离”出去，转化为声明式的、以注解驱动的优雅实现。核心在于理解“<strong>围绕方法调用的事务边界控制</strong>”</p><h2 id="原理">原理</h2><p>Spring 事务管理的核心是 AOP 代理，并且其实现依赖于一个<strong>与具体数据访问技术解耦</strong>的抽象层。</p><p>核心类：</p><p><code>PlatformTransactionManager</code>: <strong>事务管理器的核心策略接口</strong>。不同的数据访问技术有不同的实现</p><p><code>TransactionDefinition</code>: 定义事务的属性，如<strong>隔离级别 (Isolation)</strong>、<strong>传播行为 (Propagation)</strong>、超时、是否只读。</p><p><code>TransactionInterceptor</code>: <strong>AOP 通知 (Advice) 的具体实现</strong>，是驱动事务管理的核心逻辑所在。</p><p><code>TransactionSynchronizationManager</code>: <strong>事务同步管理器</strong>。它使用 <code>ThreadLocal</code> 来保存和管理当前线程的事务状态（如连接、<code>TransactionStatus</code>），是确保事务在单线程内正确运行和线程安全的关键。</p><p>步骤：</p><p><strong>入口</strong>：当一个被 <code>@Transactional</code> 注解的方法被调用时，AOP 代理会拦截这个调用。</p><p><strong>拦截器介入</strong>：调用被转发到 <code>TransactionInterceptor</code> 的 <code>invoke()</code> 方法。</p><p><strong>核心处理</strong>：<code>invoke()</code> 方法直接委托给父类 <code>TransactionAspectSupport</code> 的 <code>invokeWithinTransaction()</code> 方法。<strong>这是整个事务模块的心脏</strong>。</p><p><strong><code>invokeWithinTransaction()</code> 内部流程</strong>：</p><p>a. <strong>获取事务属性</strong>：通过 <code>TransactionAttributeSource</code> 解析方法上的 <code>@Transactional</code> 注解，获取 <code>TransactionDefinition</code>。</p><p>b. <strong>获取事务管理器</strong>：确定要使用的 <code>PlatformTransactionManager</code>。</p><p>c. <strong>开启事务</strong>：调用 <code>transactionManager.getTransaction(txAttr)</code>。这是<strong>传播行为</strong>生效的地方。管理器会查询 <code>TransactionSynchronizationManager</code>，检查当前线程是否已存在事务： * 若无事务且传播行为为 <code>REQUIRED</code> / <code>REQUIRES_NEW</code> / <code>NESTED</code>，则开启一个新事务，并将数据库连接和事务状态绑定到当前线程。 * 若有事务且传播行为为 <code>REQUIRED</code> / <code>SUPPORTS</code>，则加入当前事务。 * 若有事务且传播行为为 <code>REQUIRES_NEW</code>，则挂起当前事务，开启一个全新的事务。</p><p>d. <strong>执行业务逻辑</strong>：将事务状态 <code>TransactionStatus</code> 准备好后，在一个 <code>try-catch</code> 块中，调用 <code>invocation.proceed()</code>，执行原始的业务方法。</p><p>e. <strong>提交事务</strong>：如果业务方法正常执行完毕，则调用 <code>commitTransactionAfterReturning()</code>，内部最终会调用 <code>transactionManager.commit(status)</code>。</p><p>f. <strong>回滚事务</strong>：如果业务方法抛出异常，<code>catch</code> 块会捕获它。<code>completeTransactionAfterThrowing()</code> 会被调用，它会检查抛出的异常是否满足回滚规则（默认是 <code>RuntimeException</code> 和 <code>Error</code>），如果满足，则调用 <code>transactionManager.rollback(status)</code>。</p><p>根据我们的spring事务的底层原理我们可以知道，我们事务失效的场景有哪些？</p><ol><li><p>跳过了AOP代理</p><ol><li>this直接调用，跳过了AOP代理</li><li>权限错误，Spring AOP默认使用CGLIB创建代理，它通过继承目标类并重写<code>public</code>方法来实现。</li><li><strong>方法被 <code>final</code> 修饰，一个被<code>final</code>修饰的方法无法被子类重写，因此AOP无法对其进行代理。</strong></li><li><strong>方法被 <code>static</code> 修饰</strong>，<code>static</code>方法属于类，而不属于任何实例。Spring的AOP是基于实例的代理，无法代理静态方法。</li></ol></li><li><p>异常</p><ol><li><strong>异常被<code>try-catch</code>块捕获且未抛出</strong>，AOP的回滚是依赖<strong>捕获到了从事务方法中抛出的异常</strong></li><li><strong>抛出的异常类型不被默认回滚规则覆盖</strong>，异常的类型错误，在遇到 <strong><code>RuntimeException</code>（非受检异常）或 <code>Error</code></strong> 时才会触发回滚</li></ol></li><li><p>事务传播</p><ol><li><strong>事务传播行为（Propagation）配置不当</strong>，比如NOT_SUPPORTED，NEVER</li></ol></li><li><p>外部环境</p><ol><li><strong>数据库引擎不支持事务</strong>，比如<strong>MyISAM</strong>引擎的Mysql</li><li><strong>Spring相关配置问题</strong>，<code>@SpringBootApplication</code>所在的启动类无法扫描到你的Service包。 2. 忘记在启动类上添加<code>@EnableTransactionManagement</code>注解</li></ol></li></ol><h1>MVC</h1><p>流程：</p><p><strong>入口</strong>：所有 HTTP 请求进入 <code>DispatcherServlet</code> 的 <code>service()</code> 方法，最终由 <code>doDispatch()</code> 方法处理。<strong><code>doDispatch()</code> 是 Spring MVC 的“主循环”</strong>。</p><p><code>doDispatch()</code></p><p><strong>内部流程</strong>:</p><p>a. <strong><code>getHandler()</code></strong>: 遍历所有注册的 <code>HandlerMapping</code>，调用它们的 <code>getHandler()</code> 方法，直到找到一个匹配当前请求的 <code>HandlerExecutionChain</code>。这个 Chain 对象中包含了真正的处理器（<code>HandlerMethod</code>）和应用于它的所有拦截器。</p><p>b. <strong><code>getHandlerAdapter()</code></strong>: 遍历所有注册的 <code>HandlerAdapter</code>，找到一个支持上一步得到的 Handler 的适配器。</p><p>c. <strong><code>applyPreHandle()</code></strong>: 按顺序执行 <code>HandlerExecutionChain</code> 中所有拦截器的 <code>preHandle()</code> 方法。如果任何一个返回 <code>false</code>，则请求处理中断。</p><p>d. <strong><code>handlerAdapter.handle()</code></strong>: <strong>核心调用</strong>。<code>RequestMappingHandlerAdapter</code> 的 <code>handle()</code> 方法会委托给 <code>invokeHandlerMethod()</code>。此方法内部：</p><p>​ i.  通过 <code>HandlerMethodArgumentResolver</code> 链，解析并准备 Controller 方法所需的所有参数。</p><p>​ ii. 通过反射调用真正的 Controller 方法。</p><pre><code>iii. 通过 `HandlerMethodReturnValueHandler` 链，处理 Controller 方法的返回值，并将其封装到 `ModelAndView` 对象中。 </code></pre><p>e. <strong><code>applyPostHandle()</code></strong>: 倒序执行所有拦截器的 <code>postHandle()</code> 方法。</p><p>f. <strong><code>processDispatchResult()</code></strong>: 处理 <code>ModelAndView</code>。调用 <code>render()</code> 方法，<code>render()</code> 方法会使用 <code>ViewResolver</code> 找到对应的 <code>View</code> 对象，然后调用 <code>view.render()</code> 将模型数据渲染到响应中。</p><p>g. <strong><code>triggerAfterCompletion()</code></strong>: 在 <code>finally</code> 块中，无论成功与否，都会倒序执行拦截器的 <code>afterCompletion()</code> 方法，用于资源清理。</p><p>当然根据这个我们也可以将MVC的设计应用到一些重复性的工作之中，prehandel进行前置处理，finally进行后置处理</p><h1>Boot</h1><p>Spring Boot “约定大于配置” 的神秘面纱。理解其本质并非“魔法”，而是一套基于 <strong>Classpath 内容</strong>和<strong>环境配置</strong>的、<strong>条件化的</strong>、<strong>可插拔的</strong> Bean 注册机制。</p><p>掌握 Spring Boot 是如何通过 <code>@EnableAutoConfiguration</code> 扫描、加载、并根据条件（<code>@Conditional</code>）过滤配置类，最终完成 Bean 自动注册的全过程。</p><p>流程：</p><p><strong>起点</strong>：<code>SpringApplication.run()</code> 启动应用，创建 <code>ApplicationContext</code>。</p><p><strong>触发</strong>：在容器 <code>refresh</code> 过程中，Spring 会解析主配置类上的 <code>@SpringBootApplication</code> 注解，进而处理其元注解 <code>@EnableAutoConfiguration</code>。</p><p><strong>导入选择器</strong>：<code>@EnableAutoConfiguration</code> 通过 <code>@Import(AutoConfigurationImportSelector.class)</code> 引入了 <code>AutoConfigurationImportSelector</code>。</p><p><strong>收集候选配置</strong>：Spring 会调用 <code>AutoConfigurationImportSelector</code> 的 <code>selectImports()</code> 方法。该方法会：</p><p>a. 调用 <code>getCandidateConfigurations()</code>，它使用 <code>SpringFactoriesLoader</code> (或新的 <code>AutoConfiguration</code> 机制) 去扫描所有 classpath 下的 JAR 包，读取 <code>spring.factories</code> 或 <code>.imports</code> 文件中 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> key 下的自动配置类全名列表。</p><p><strong>过滤与评估</strong>：得到这个庞大的候选列表后，<strong>并不会全部加载</strong>，而是进行严格的过滤：</p><p>a. 首先，移除用户通过 <code>exclude</code> 属性明确排除的配置类。</p><p>b. 然后，<strong>最重要的步骤</strong>：遍历每一个候选配置类，使用 <code>ConditionEvaluator</code> 检查该类上的所有 <code>@Conditional...</code> 注解。</p><p>c. 例如，<code>DataSourceAutoConfiguration</code> 上有 <code>@ConditionalOnClass(DataSource.class)</code>，评估器会检查 <code>DataSource.class</code> 是否存在于当前 Classpath。<code>RabbitAutoConfiguration</code> 上的 <code>@ConditionalOnClass(RabbitTemplate.class)</code> 会检查 RabbitMQ 的客户端库是否存在。</p><p>d. 只有<strong>所有条件都满足</strong>的配置类，才会被认为是“激活”的。</p><p><strong>最终加载</strong>：<code>selectImports()</code> 方法最终返回一个“激活”的配置类名称数组。Spring 会像处理普通的 <code>@Configuration</code> 类一样，将它们加载到 IoC 容器中，执行其中的 <code>@Bean</code> 方法，从而完成 Bean 的自动配置。</p><p>理解</p><p><strong>SPI (Service Provider Interface)</strong>：<code>spring.factories</code> / <code>.imports</code> 文件机制是一种 SPI 的实现，它允许第三方库（starters）向 Spring Boot “注册”自己的自动配置能力，实现了完美的解耦和可插拔性。</p><p><strong>约定大于配置 (Convention over Configuration)</strong>：Spring Boot 替你做了最佳实践的预设。例如，只要 <code>spring-boot-starter-web</code> 在 classpath 中，它就“约定”你可能需要一个内嵌的 Tomcat 和一个配置好的 <code>DispatcherServlet</code>。</p><p><strong>条件化配置 (Conditional Configuration)</strong>：<code>@Conditional</code> 注解是整个自动配置体系的基石，它让配置变得智能和按需加载，避免了不必要的资源消耗和配置冲突。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring/">spring</category>
      
      
      <comments>https://blog.tokenlen.top/2025/09/08/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/konw/spring-alay/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-大厂收集</title>
      <link>https://blog.tokenlen.top/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/</link>
      <guid>https://blog.tokenlen.top/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/</guid>
      <pubDate>Tue, 26 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;美团&lt;/h1&gt;
&lt;h2 id=&quot;一面&quot;&gt;一面&lt;/h2&gt;
&lt;h3</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>美团</h1><h2 id="一面">一面</h2><h3 id="题目1">题目1</h3><p>请说明进程和线程的区别与联系。操作系统中的虚拟内存是如何实现的？谈谈乐观锁和悲观锁，以及它们在Java中的具体实现（如CAS、Synchronized）。AQS（AbstractQueuedSynchronizer）的原理是什么？请举例说明（如ReentrantLock）。当向一个线程池提交任务时，它的执行流程是怎样的？（考虑核心线程、队列、最大线程、拒绝策略）</p><p>介绍一下Redis的持久化机制有哪几种，它们各自有什么优缺点？如何保证缓存与数据库双写一致性？谈谈MySQL的事务隔离级别，以及MVCC是如何在可重复读（RR）级别下工作的。什么是覆盖索引和回表？在使用联合索引时，需要注意哪些最左前缀匹配原则？</p><p>请描述一下JVM的类加载过程，以及双亲委派模型。G1垃圾收集器相比于CMS有哪些优势？什么情况下会发生OOM（堆内存溢出），请举例说明几种场景。Java中的强引用、软引用、弱引用、虚引用之间有什么区别？</p><h3 id="题目2">题目2</h3><p>1：自我介绍</p><p>2：HashMap1.8底层数据结构和put流程</p><p>3：jvm底层和OOM发生区域</p><p>4：roc调用流程</p><p>5：慢SQL调查流程</p><p>6：mysql隔离级别和如何实现的，以及MVCC</p><p>7：唯一ID，一致性哈希</p><h3 id="题目3">题目3</h3><p>Bean的生命周期</p><p>Spring怎么解决循环依赖问题</p><p>Spring的IOC、AOP</p><p>Spring的事务传播机制</p><p>事务传播机制的底层实现</p><p>TheadLocal的key为什么要设置成弱引用</p><p>TheadLocal的value为什么要设置成强引用</p><p>TheadLocal怎么防止内存泄漏</p><p>TCP的三次握手和四次挥手</p><p>TIME_WAIT发生在哪里，以及为什么需要TIME_WAIT</p><p>UDP怎么设置成可靠的</p><p>votaile 关键字的作用，以及votaile 禁止指令重排的底层实现</p><p>解释一下SYN的泛洪攻击</p><p>怎么防御泛洪攻击</p><h3 id="题目4">题目4</h3><p>1. ThreadLocal在什么情况下会导致out of memory？</p><p>2. 阿里规范中为什么要求用static来修饰ThreadLocal变量？</p><p>3. 存储100万数据时，选HashMap还是ConcurrentHashMap？</p><p>4. 多线程情况下使用HashMap会导致什么问题？</p><p>5. HashMap扩容时需要注意什么？</p><p>6. 仿大众点评项目中缓存空值具体是怎么实现的？</p><p>7. 布隆过滤器的误判率大概是多少？</p><p>8. 仿大众点评项目中，类似微博大V发博客的场景，使用推模式还是拉模式？大粉丝量时推模式会有什么问题？</p><p>9. Redis分布式锁为什么要使用Lua脚本？纯Java代码为什么不可以？</p><p>10. 为什么选用Websocket？除了Websocket，是否考虑过其他协议（如谷歌的相关协议）？</p><p>11. 分布式环境下用schedule的关单会有什么问题？</p><p>12. 若系统扩大为分布式且单量增大，解决定时任务问题的思路有哪些？</p><p>13. 日志框架用的是log4j还是log4j2？日志应在哪些地方重点打印？</p><p>14. 碰到老应用、老系统日志不全时，如何最快地加上基础日志打点？</p><p>15. 为什么选用Mybatis plus而不选用JPA？</p><p>16. 线程池在系统里用在哪些位置？</p><p>17. 线程池的核心参数有哪些？从核心线程数达到最大线程数需要什么条件？</p><p>18. 在优惠券秒杀场景下，阻塞队列应设置多大？</p><p>19. RabbitMQ与Redis stream的推流最大区别是什么？</p><p>20. 仿大众点评项目中，最重要的几张表是哪几张？订单表应加什么索引？</p><p>21. MySQL的日志指的是哪些？集群模式最主要依赖的日志是什么？</p><p>22. 生产环境中如何避免主从同步延迟带来的故障？</p><p>23. JDK 11、17有哪些新特性？</p><h3 id="题目5">题目5</h3><p>说一下 JVM 的内存结构（运行时数据区）有哪些？每一块的作用是什么？</p><p>Java 中对象的内存分配过程是怎样的？对象分配在堆还是栈？</p><p>什么是栈上分配、逃逸分析？是否可以让对象不分配在堆上？</p><p>什么情况下对象会进入老年代？如何判断对象“是否存活”？</p><p>直接内存（Direct Memory）是什么？你在什么场景下用过它？</p><p>JVM 中常见的垃圾回收器有哪些？它们的适用场景？</p><p>Serial、ParNew、CMS、G1、ZGC 有什么区别？你项目中用的哪一个？为什么？</p><p>Minor GC 和 Full GC 有什么区别？分别在什么情况下发生？</p><p>如何避免或减少 Full GC？有哪些排查方法？</p><p>GC Roots 有哪些？JVM 是怎么判断一个对象是否需要回收的？</p><h3 id="题目6">题目6</h3><p>ArrayList和hashmap扩容机制</p><p>Java并发容器和锁</p><p>jvm参数设置 — 堆内存和垃圾回收器</p><p>如果新生代的垃圾回收一直清不到0，怎么解决？</p><p>full GC</p><p>垃圾回收机制</p><p>类加载机制和双亲委派机制</p><p>IOC —  还有IOC相关的，忘记是什么了</p><p>Bean生命周期</p><p>MySQL索引的注意事项、事务</p><p>MVCC</p><p>当前读和快照读</p><p>Redis数据结构</p><p>RocketMQ与kafka</p><p>rocketmq有哪些主要部分</p><p>消息重试</p><p>消费者的消费模式</p><p>消费者如何保证幂等</p><p>RocketMQ消息有序吗？</p><p>http状态码，对应着是哪个环节出现问题</p><p>TCP三次握手和四次挥手 为什么挥手是四次？</p><p>lInux查最近的日志 — tail -f | grep XXX</p><p>linux其他命令 查看进程 ps</p><h3 id="题目7">题目7</h3><p>1.自我介绍</p><p>2.实习拷打</p><p>3.讲讲javac过程，结合编译原理的东西详细分析</p><p>4.讲讲你写的一个java代码跑起来的过程，例如编译运行和解释运行</p><p>5.面向对象的几个特性和举例子说明</p><p>6.springboot容器启动过程</p><p>7.讲讲list，map，set几种基本数据结构和使用场景</p><p>8.假如你用一个arraylist，你已经知道里面会存1w条数据了，那该怎么办</p><p>9.collections下的加锁和数据结构本身例如chw的加锁操作有什么区别</p><p>10.手撕SQL:</p><p>员工编号-id，部门-dep，薪酬-salary</p><p>求找到所有薪酬大于部门平均工资的员工</p><p>要求多种解法</p><p>不知道想要哪种，除了常规的，还写了一种 avg（salary）over（partation by dep）as avgSalary这种</p><p>11.手撕链表中删除重复元素</p><p>12.讲讲大模型中的知识蒸馏是怎么做的</p><p>13.整体介绍介绍你对于agent，work flow，rag，mcp，a2a的理解</p><h3 id="题目8">题目8</h3><ol><li><p>看你简历上写了几个项目，可以挑一个你觉得最有代表性的介绍一下吗？</p></li><li><p>我看你提到了mcp，能解释下它是什么吗？主要起什么作用，在什么地方起作用？</p></li><li><p>我们来聊聊基础吧，HashMap是线程安全的吗？为什么？</p></li><li><p>StringBuffer和StringBuilder，它俩有什么区别？</p></li><li><p>TCP和UDP，能分别说说它们的特点和常见的应用场景吗？</p></li><li><p>来一道概率题吧：现在你只有一个能生成1到5随机数的<code>rand5()</code>函数，怎么用它来实现一个能生成1到7随机数的<code>rand7()</code>函数？（讲了大体思路没讲具体思路 估计死了)</p></li><li><p>你之前有做过全栈开发吗？</p></li><li><p>我们来深入聊聊MySQL索引。能介绍一下吗？为什么它通常用B+树来实现？B+树的每个节点里都存了些什么？另外，一张表里可以有几个聚簇索引？（把我问死了）</p></li><li><p>来个系统设计题。假设我们要搞一个秒杀活动：晚上八点开抢1000台手机。你会怎么设计这个秒杀系统？</p></li><li><p>你觉得，一个好的Prompt通常需要包含哪些要素？</p></li><li><p>在我们平台里，Agent模式和Ask模式，它俩有什么区别？</p></li></ol><h3 id="题目9">题目9</h3><p>hashcode equal什么时候需要重写</p><p>hashmap原理</p><p>hashmap是线程安全的吗</p><p>不安全的话用什么？他的原理是什么样的</p><p>线程池使用过吗？怎么用的？什么场景？</p><p>spring事务怎么做到的</p><p>spring事务传播机制</p><p>mysql使用</p><p>mysql怎么建索引？怎么判断是否要建索引</p><p>mysql索引失效？</p><p>mysql慢查询排查</p><h3 id="题目10">题目10</h3><p>1.自我介绍</p><p>2.项目难点有什么</p><p>3.Redis常用数据结构有哪些</p><p>4.Redis缓存击穿、缓存雪崩是什么，解决方案</p><p>5.equals和hashcode</p><p>6.TCP三次握手</p><p>7.MySQL索引类型有什么，索引失效场景</p><p>8.一个主线程正在进行，现在有个子线程，怎样才能让主线程停止，等到子线程执行结束之后再恢复运行</p><p>9.创建线程的方式有哪些</p><p>10.平时怎么用AI学习的</p><h3 id="题目10-2">题目10</h3><p>1.hashmap如何解决哈希冲突，红黑树化为何阈值为8</p><p>2.cglib和jdk代理区别，哪个性能好</p><p>3.联合索引失效 如何改进</p><p>4.synchonized reentrantlock区别</p><p><a href="http://5.mq/">5.mq</a>如何保证可靠性，顺序性</p><p>6.ArrayList LinkedList区别</p><p>7.OOM怎么排查</p><p>8.线程池核心参数 原理 四种拒绝策略 举个例子</p><p>9.缓存穿透 雪崩</p><p>10.分库分表 附属表 基因法  优缺点</p><p>11.mysql隔离级别 可重复读怎么避免幻读</p><p>12.G1怎么避免内存碎片</p><p>13.Mysql oracle区别</p><p>13.用过哪些AI，用途，工作中遇到别人代码bug怎么办</p><p>14.手撕 二叉树层序 最长重复子数组</p><h3 id="题目11">题目11</h3><p>1、项目、实习拷打<br>2、violate关键字作用<br>3、如何保证线程安全<br>4、支持原子性操作的方法<br>5、简述Spring的ioc和aop的核心思想<br>6、mysql的acid特性<br>7、慢sql如何优化<br>8、explain关键字解释<br>9、Redis常用数据结构以及应用场景<br>10、WebSocket的工作原理<br>11、如何优化你项目中使用的WebSocket的业务<br>12、FTP中的keep-alive<br>13、TCP特性<br>14、UDP和TCP应用场景，如何使得UDP可靠<br>15、对前端的了解，对vue的认识<br>16、java中Sort的原理</p><h3 id="题目12">题目12</h3><p>1.问实习内容<br>2.并发工具类<br>3.介绍项目背景<br>4.项目框架设计<br>5.项目如何面对高并发场景<br>6.线程池八股<br>7.项目接口和高并发<br>8.手撕：合并两个有序数组<br>9.Mysql日志<br>10.MVCC</p><h3 id="题目13">题目13</h3><ol><li>自我介绍，过往项目经历、实习经历</li><li>日常怎么运用 ai 大模型</li><li>讲一下 java 8 lambda 表达式</li><li>osi 7 层结构模型，每层的作用是什么</li><li>tcp 和 udp 的区别，tcp 超时重传、流量控制机制</li><li>怎么运用大模型，为探店博主或者商家提供服务，包括根据用户上传的图片或关键字，生成一个基础的探店笔记（追问 prompt 工程、怎么解决幻觉）</li><li>讲实习遇到的困难</li></ol><h3 id="题目14">题目14</h3><ol><li>自我介绍，特别问了AI大模型在你学习过程中给你的帮助</li><li>栈和队列的区别；生活中站和队列分别有什么应用场景？</li><li>Lambda表达式的作用和使用场景？Lambda表达式和匿名内部类相比有什么优势？</li><li>解释消息队列的消息投递机制，比如“至少一次”、“至多一次”、“恰好一次”？“至少一次”投递机制会出现什么问题，怎么解决？</li><li>设计一个考勤管理系统，如何保证考勤记录的真实性？如何防止考勤过程中用户信息被人篡改？</li><li>利用AI大模型，为新入驻的商家提供一个“7×24小时的AI导师”，可以回答商家提供的各类问题？<br>追问：如果线上发现模型返回的JSON经常缺字段或格式错乱，导致下游服务解析失败，如何从Prompt设计、模型参数或后处理等方面系统性解决这个问题？<br>追问：后处理阶段发现模型生成的内容与预期字段不匹配，你会如何设计检测机制来发现和解决这些问题？</li><li>描述一次你成功识别并解决了一次潜在的、尚未显形的问题，你是如何预见并采取行动的？</li></ol><h3 id="题目15">题目15</h3><p>1、自我介绍+项目拷打<br>2、对于分库分表，是按照什么分的<br>3、为什么要把数据分开存储，不能都存到分布式数据库里吗？分布式数据库和普通数据库区别是什么<br>4、当数据库表超过2千万之后，处理方案是什么？<br>5、有学过计算机相关的课程吗，对哪一门比较熟悉（这里我说网络）<br>6、说一下滑动窗口的原理<br>7、讲一下三次握手和四次挥手<br>8、提到close_wait 和 time_wait，说一下这两个状态过多的影响，以及哪个危害更大。<br>9、阐述一下类加载的过程，包括具体加载到什么地方<br>10、元空间和方法区会存放哪些信息<br>11、有使用过AI吗？现在大模型的幻觉问题比较大，平时处理方法是什么？<br>12、知道RAG吗？阐述一下Rag原理，以及它是如何处理大模型幻觉问题的<br>13、说一下未来的职业规划？如果工作内容不符合你的规划呢？<br>14、知道大模型的生成数据流推送的方案吗？就是如何逐字输出的？<br>15、WebSocket 和 SSE 的区别是什么？<br>16、单工一定比全双工性能要好吗？<br>17、对于分表后的主键ID是怎么处理的</p><h3 id="题目16">题目16</h3><p>15min<br>实习业务介绍及问答<br>聊聊 RAG 和 Embedding？它们是啥，有啥用？<br>你是怎么学大模型的？<br>你觉得大模型能在哪些地方实际用起来？</p><p>10min<br>讲讲悲观锁和乐观锁？<br>消息队列有啥用？<br>RocketMQ 和 Kafka 有啥区别？底层实现上有什么不一样？<br>Kafka 消费消息比 RocketMQ 快吗？为啥？<br>顺序消费有啥要注意的？</p><p>15min<br>布隆过滤器一般用在哪？原理是啥？<br>MySQL 的索引是啥原理？有啥用？<br>B+ 树和 B 树有啥区别？<br>MySQL 的隔离级别有哪几种？分别怎么实现的？<br>设计一个外卖流程：用户下单、商家接单、骑手派单，大概是个啥过程？会用到哪些数据结构和算法？</p><h3 id="题目17">题目17</h3><ol><li>redis为什么快，性能为什么高？</li><li>redis里面基本的数据类型有哪些？</li><li>一些数据类型也是redis优化之后导致redis快的原因，能够就其中一个redis数据结构的优化来举出一个实际的例子吗？</li><li>你能先描述一下跳表的数据结构长什么样子？</li><li>跳表空间复杂度是多少？</li><li>说说对redis事务的理解？</li><li>说说对mysql事务的理解？</li><li>说一下redis的持久化方案把？</li><li>redis主从同步主要采取哪种形式？</li><li>redis有几种部署模式？</li><li>你觉得集群模式和哨兵模式的主要区别是？</li><li>集群模式中如何出现一个redis热点key的情况，怎么做防止节点单点压力过大？（我回答是业务层面解决，每个节点都缓存热点key，用一个哈希集合存储热点key，直接快速判断是否走本地查询，而不是哈希索引节点）</li><li>说一下mysql的隔离级别以及每种隔离级别下可能出现的问题？</li><li>说一下可重复读是怎么解决不可重复读的问题？</li><li>说一下什么是聚簇索引？</li><li>聚簇索引和聚簇索引有什么区别？</li><li>数据结构的区别在哪里？都用的是B+数吗？</li><li>B+数的结构原理是什么？</li><li>什么是覆盖索引？</li><li>覆盖索引有什么好处？</li><li>最近的话，AI大模型比较火，你有没有学习AI大模型相关的原理，大模型微调了解过吗？</li></ol><h3 id="题目18">题目18</h3><p>1.介绍多态，重载、重写底层如何实现<br>2.野指针和悬挂指针出现场景，产生什么后果，如何解决<br>3.介绍智能指针，什么操作会导致共享指针引用计数加1、减1<br>4.如果想把一个智能指针的释放控制在某一个线程内应该怎么做？这个我不会，面试官说要让指定线程一直持有着它，然后再释放，我还是没太懂<br>5.对堆和栈的理解<br>6.申请堆空间的方式，两种方式的区别<br>7.STL库有了解吗？vector有了解吗？<br>8.除了添加元素时容量不够会扩容，还有什么时候会扩容？这个我不知道，面试官说还有一个用来动态扩容的容器阈值，当前申请的内存超过阈值时会提前申请。<br>9.vector底层数组在内存分配上是什么特性<br>10.还有其他内存分配方式吗<br>11.为什么有epoll，epoll的水平触发和边缘触发<br>12.tcp三次握手<br>13.对于客户端和服务器而言，是怎么认出这个tcp连接的？我当时一直没get到面试官的意思，现在想想应该是想让我回答四元组标识一条连接吧？<br>14.客户端和服务器的fd都是什么时候生成的<br>15.连接队列满了会给客户端返回什么？不清楚，面试官说reset<br>16.进程和线程。我当时有点昏头了，说进程不能很好的利用多核cpu，面试官说多进程也可以用多核<br>17.进程间通信<br>18.linux排查问题的相关命令：查网络连接、查网络连接个数、grep反向查找</p><h3 id="题目19">题目19</h3><p>说一下java并发编程<br>多个线程访问同一个资源 怎么设计<br>多个线程访问同一个资源 用sycoenized锁性能如何 如果优化的话怎么优化<br>分布式事务<br>缓存击穿<br>缓存击穿和缓存穿透的区别<br>设计一个新闻推送<br>如果用ai进行新闻推送分类的话 提示词怎么写<br>如果让你用ai生成营销策略的话怎么设计提示词<br>如果大模型出现产地硬信息描述不符怎么办<br>如果大模型回答缺一个点 怎么办<br>你项目中最有难度的一个问题 如何排查的</p><h3 id="题目20">题目20</h3><p>2min</p><p>自我介绍</p><p>15min</p><p>实习业务介绍及问答</p><p>Q: RAG和embedding了解吗，是什么有什么作用</p><p>RAG检索增强生成，可以拓展模型上下文，缓解模型幻觉和时效问题。</p><p>embedding可以将非结构化数据（文本图片视频）转化为结构化数值向量，向量每个数值代表某个维度上的特征，以此让机器也能理解分类和检索数据。</p><p>Q: 你是怎么学习大模型的</p><p>论文、博客</p><p>Q: 大模型你觉得有哪些可以落地应用的地方</p><p>AI coding、豆包形式AI应用、行业定制agent和传统互联网业务赋能。</p><p>​</p><p>10min</p><p>Q: 悲观锁和乐观锁概念</p><p>是否强制加锁，区别于在进入共享资源区之前是否允许其他请求修改共享资源。</p><p>Q:  消息队列的作用</p><p>削峰填谷、异步化、服务解耦。</p><p>Q:  RocketMq跟Kafka区别，底层实现有什么不同</p><p>架构相似，功能RocketMq更丰富，吞吐量KafKa更大，底层零拷贝策略不同。</p><p>Q:  kafka消息消费比RocketMq快吗，为什么</p><p>Kafka sendfile零拷贝(没有用户态和内核态之间的拷贝)，RocketMq mmap零拷贝(比sendfile多一次拷贝)。</p><p>Kafka 分区消息顺序写磁盘且可以通过分区偏移量直接从日志文件中读到数据，RocketMq队列消息都存在全局CommitLog中，只是同一队列消息有序，但在磁盘上位置可能分散，且定位消息位置需要两次寻址。</p><p>Q:  顺序消费要注意什么</p><p>生产者生产的消息要发送到同一个队列，指定单个消费者单线程或多线程加锁消费该队列。</p><p>​</p><p>15min</p><p>Q:  布隆过滤器使用场景及原理</p><p>缓存穿透+ 哈希函数 + bitMap。</p><p>Q:  mysql的索引原理，作用</p><p>多叉自平衡树B+树，将数据按索引字段顺序编排，查询效率更高。</p><p>Q:  B+树跟B树的区别</p><p>B+树仅叶子节点存储数据，树高度更低减少磁盘IO且查询效率稳定，叶子节点双向连接方便范围查询。</p><p>Q:  mysql的隔离性有哪些，怎么实现的</p><p>读未提交、读已提交、可重复读和串行化，其中读已提交和可重复读通过MVCC和undo log配合实现。</p><p>Q:   用户下单，商家接单，骑手派单中间大致是个什么样的过程，涉及什么数据结构和算法上的考量</p><p>​</p><p>7min</p><p>括号匹配</p><p>​</p><p>8min</p><p>反问</p><p>消息队列没回答好，因为我不了解kafka，但最近被问到好几次，最后一道场景题更是懵逼。</p><h3 id="题目21">题目21</h3><p>1.redis的事务和mysql的事务区别</p><p>2.redis事务在命令入队期间出错了会不会回滚</p><p>3.redis事务底层是如何实现的？（没看过，随便说的应该是放到一个事务队列依次执行的</p><p>4.redis线程模型</p><p>5.redis持久化方式，只用aof行不行</p><p>6.redis哨兵模式，如何判断挂没挂（心跳+Gossip</p><p>7.redis集群模式，如何判断节点挂了和后续的选举动作</p><p>8.redis缓存淘汰策略</p><p>9.mysql的delete、truncate、drop的区别（当时脑子懵了，以为问的都是删除行的操作，后两个删除行没听说过啊。。。）</p><p>10.mysql持久化怎么实现的？</p><p>11.什么是MVCC以及MVCC怎么实现的？可重复读和读已提交怎么实现的</p><p>12.innodb引擎层的查询优化（解释了索引下推和select多的时候不走索引</p><p>13.慢sql排查优化</p><p>14.项目分库分表，数据多大需要考虑分表</p><p>15.手撕：接雨水好久没复习了不会，换了道层序遍历+单例模式（我哭死</p><p>16.volatile解释</p><p>17.synchronized底层实现原理，具体说Monitor的结构和c++的objectMonitor</p><p>18.synchronized和reentrantlock，怎么实现非公平锁。说下juc包下你说过的类有什么</p><p>19.线程池参数（7个，一段时间没复习了说了5个），核心线程数怎么设置，队列设多大（给了个响应速度要求高的场景，当时没敢说队列设为0，只说了尽量小，后面看了个美团的博客一模一样的场景。。。）</p><p>20.阻塞队列有哪些（原来有这么多BlockingQueue。。。）</p><h3 id="题目22">题目22</h3><p>1.一上来自我介绍都没有，自己问</p><p>2.java线程池，从参数到流程</p><p>3.线程池是怎么把任务给线程执行的？<br>（我前面已经讲过线程池的流程，阻塞队列啥的，我说不就是还没到核心线程数就新建线程执行吗，面试官说不不不，就是线程池怎么把任务给线程执行的，我又说了线程池提交任务的execute和submit，面试官又重复不不不，到这里我没招了，然后问我没看源码吗）<br>刚下来查了会ai，源码是有一个worker对象对应线程，然后有run方法和runwork方法。怪我没看源码。</p><p>4.看过spring源码吗（看八股的时候或多或少看过，愣了几秒回没看过）</p><p>5.jdk和cglib动态代理，为什么jdk要目标类实现接口的（我说jdk是反射，通过代理类实现相同接口，覆盖，起到代理效果。面试官还问为什么要接口，又一次不知道怎么开口。ai说：JDK动态代理依赖于接口的多态性。如果没有接口，代理类无法确定需要生成哪些方法）</p><p>6.mysql慢查询，深分页怎么优化</p><p>7.mysql索引失效情况</p><p>8.mysql优化</p><p>9.redis你一般用来干什么，讲讲项目怎么用的</p><p>10.redis5种数据结构</p><p>11.跳表结构，跳表查询时间复杂度</p><p>12.跳表的索引高度是怎么确认的（又一个不知道的，我结结巴巴说他自动生成的。ai说：在跳表中，每个节点的索引高度（即该节点有多少个指针）是通过随机化方法确定的。具体来说，通常使用一个随机数生成器来决定每个节点的索引高度。这种方法的优点是简单且高效，同时能够保证跳表的平均性能。）</p><h3 id="题目23">题目23</h3><p>\1. 自我介绍。</p><p>\2. 拷打项目。</p><p>\3. HashMap 是怎么解决哈希冲突的？</p><p>\4. 红黑树和 AVL 树有啥区别？</p><p>\5. 排序算法有哪些？哪些是稳定的？</p><p>\6. TCP 是怎么保证可靠传输的？</p><p>\7. 讲讲拥塞控制？</p><p>\8. MySQL 是怎么做到事务隔离的？隔离级别有哪几种？</p><p>\9. Spring Boot 里用到了哪些设计模式？</p><p>\10. 你还知道哪些设计模式？</p><p>\11. 面向对象有哪些特性？</p><p>\12. 聊聊设计模式的六大原则，挑两个讲讲？</p><h3 id="题目24">题目24</h3><p>你的学习路线是啥？</p><p>为啥用 Spring Cloud？</p><p>啥是自动装配？</p><p>聊聊 AOP 和 IOC？</p><p>IOC 有啥用？和单例模式有啥区别？它具体是怎么解耦的？</p><p>为啥用 B+ 树？</p><p>MySQL 的事务隔离级别有哪几种？</p><p>MVCC 为啥解决不了幻读？</p><p>讲讲 RabbitMQ？</p><p>如果让你来设计 RabbitMQ，你会怎么做？</p><p>Redis 有哪些数据类型？</p><p>Sorted Set 是怎么实现的？</p><p>为啥用跳表？</p><p>JMM 模型是啥？</p><p>进程和线程有啥区别？</p><p><code>volatile</code> 关键字底层是怎么保证可见性的？</p><p>TCP 和 UDP 有啥区别？</p><h3 id="题目25">题目25</h3><p>\1. 在日常学习工作中如何使用大模型？举一个具体场景案例</p><p>\2. HTTP 和 HTTPS 的区别？HTTPS 对称加密和非对称加密如何应用？</p><p>\3. 消息队列消息发送方式？</p><p>\4. 缓存穿透成因及解决方案？布隆过滤器局限性？</p><p>\5. 帮助商家回复用户评价的大模型方案设计？面对用户评价中恶意评价、prompt 攻击之类的如何解决？</p><p>\6. 项目遇到的难题？如何找出难题的具体原因？详细说明白</p><h3 id="题目26">题目26</h3><p>HTTP 和 RPC 有啥区别？</p><p>数组和链表有啥区别？</p><p>哈希表的实现和底层是啥？具体怎么查找？Redis 的哈希底层结构是啥？</p><p><code>VARCHAR</code> 和 <code>CHAR</code> 有啥区别？</p><p>事务四大特性是啥？怎么实现的？</p><p>从输入网址到页面显示，发生了啥？</p><p>Redis 有啥优点？</p><p>聚簇索引和非聚簇索引是啥？</p><p>联合索引，面试官举了个例子问会不会失效。</p><p>啥是回表？啥是覆盖索引？</p><p>大 Key 问题怎么解决？</p><p>熟悉哪些设计模式？</p><h3 id="题目27">题目27</h3><p>1.redis的提前缓存的同步链路怎么实现？</p><p>2.rabbitMQ的幂等性怎么实现？</p><p>3.你在开发时怎么提高接口性能？</p><p>4.java的常用集合介绍一下？</p><p>5.哪些集合是线程安全的哪些是线程不安全的？</p><p>6.HashMap和concurrentHashMap的对比？</p><p>7.ConcurrentHashMap线程安全怎么实现？</p><p>8.java的锁机制介绍一下？</p><p>9.ReentrantLock的实现原理介绍一下</p><p>10.volatile关键字介绍下</p><p>11.java创建线程池怎么实现？</p><p>12.线程池的工作原理？</p><p>13.拒绝策略都有什么？</p><p>14.你项目中使用到了两个线程池，他们的拒绝策略不一致是怎么考虑的？</p><p>15.jvm调参怎么实现？</p><p>16.什么是GC？</p><p>17.知道哪些垃圾回收器？</p><p>18.jvm怎么分析线上进程线程对象的信息？</p><p>19.性能分析工具有了解过吗？</p><p>20.你的工具是怎么使用的？</p><p>21.springboot的启动流程讲一下？</p><p>22.在 Spring 启动过程中，若要在其生命周期的特定阶段执行自定义操作，怎么实现？</p><p>23.mysql的底层索引的数据结构是什么？</p><p>24.你都知道哪些索引？</p><p>25.怎么分析建立的索引有没有生效？</p><p>26.什么是索引失效？</p><p>27.联合索引建立之后，使用了两个字段做过滤，那么有没有可能不走索引？</p><p>28.mysql基于成本的优化考量通过什么算法来实现的？</p><p>29.mysql怎么分库分表？什么情况下分库，什么情况下分表？</p><p>30.redis的数据结构有什么？</p><p>31.解释一下缓存穿透、缓存击穿和缓存雪崩？怎么解决？</p><p>32.高并发系统中怎么保证数据一致性？</p><p>33.加锁如何保证数据一致性？</p><p>34.rabbitmq介绍下底层原理？</p><p>35.当一条消息被发送到 RabbitMQ 集群后，这条消息去哪了？</p><h3 id="题目28">题目28</h3><p>GC Roots怎么选择？</p><p>常见的垃圾回收算法？</p><p>CMS用什么算法？垃圾回收过程介绍一下？</p><p>CMS怎么解决标记清除的内存碎片问题？</p><p>G1垃圾回收过程介绍一下？</p><p>G1怎么判断哪个region是最有价值的region？</p><p>什么方法可以不遍历老年代，对新生代没被引用的对象进行回收？</p><p>Mixed GC听过没有？</p><p>InnoDB的ACID怎么实现的？(把三大日志MVCC隔离级别都吟唱了一遍)</p><p>没有binlog行不行？(答的主从同步和二阶段提交)</p><p>Redis支持事务吗？(忘了)</p><p>Redis主从怎么保证高可用的？(吟唱主从同步过程+哨兵集群)</p><p>哨兵集群选主怎么选的？(忘了，说了个投票，追问不会)</p><h3 id="题目29">题目29</h3><p>为什么技术选型上为什么要选用Redis做token 的缓存？<br>不用Redis的话，怎么实现过期？<br>用jwt携带信息，有没有可能客户端把过期时间篡改？<br>token完整的生命周期以及前后端的整个交互流程？<br>怎么防止AI识别出验证码导致恶意登陆？<br>建联合索引的SQL语句？EXPLAIN语句输出的有哪些字段？大概是什么含义？<br>最左前缀匹配<br>IOC和DI是什么？之间是什么关系？<br>Spring、 Spring MVC、 Spring Boot，三个有什么区别与联系？<br>Java创建线程池的方式？ThreadPoolExecutor有哪些参数？拒绝策略有哪些？<br>异步创建订单以后，效率、成本以及用户体验，哪一方面有提升，哪一方面有降低？<br>订单量特别大，怎么提升kafka的整个的吞吐率？<br>Kafka的订单消息有哪几种丢失的情况，丢了怎么办？</p><h3 id="题目30">题目30</h3><p>\2. AI 应用题，用自然语言与AI对话，生成一个美团外卖的通用订单详情页面。<br>\3. 平时会关注ai相关的知识吗？有哪些渠道去学习ai<br>\4. HashMap的底层存储结构？<br>\5. 为什么JDK1.8之后会有一个链表红黑树的转换，为啥不都用红黑树？<br>\6. ConcurrentHashMap怎么保证的线程安全<br>\7. equals() 和 == 有啥区别<br>\8. int a 可以和 Integer B 用 == 进行比较吗<br>\9. int 和 Integer不给赋值的话初始值是一样的吗<br>\10. 什么时候要用线程池 线程池的核心参数<br>\11. 三次握手的过程<br>\12. 为什么要有三次，两次不行吗<br>\13. Mysql有哪几种存储引擎<br>\14. 为什么现在大多数都用InnoDB而不是其他的，好处体现在哪里<br>\15. 为什么要用事物？<br>\16. 聚簇索引和非聚簇索引的区别是什么<br>\17. 给定一个表（a主键, b普通索引, c无索引），查询 SELECT a,b,c WHERE b = ? 会走索引吗？具体流程是怎样的？<br>\18. 这个例子在什么情况下可能会索引失效？<br>\19. 你提到优化器，它怎么判断扫全表比走索引更快？<br>\20. 如果索引变成 a主键 和 (c, b)联合索引，还是查 WHERE b = ?，能走到索引吗？<br>\21. 是否了解索引下推？</p><h3 id="题目31">题目31</h3><p>1.为什么会出现缓存穿透的问题？</p><p>2.缓存和数据库的一致性</p><p>3.修改数据库后，为什么不直接update缓存，而是删除缓存</p><p>4.拷打强一致性和最终一致性</p><p>5.缓存击穿</p><p>6.你的意思是重建业务不复杂的key是没有缓存击穿的风险是吗？</p><p>7.热点key的含义</p><p>8.雪花算法</p><p>9.雪花算法生成ID的逻辑</p><p>10.倒排索引</p><p>11.全文索引</p><p>12.和聚簇索引有什么区别</p><p>13.算法：爬楼梯</p><p>14.算法：编辑距离</p><p>15.算法：两个有序链表合并</p><p>16.简单SQL</p><p>17.MVCC</p><p>18.JVM内存模型</p><p>19.Integer a = new Integer(100); a在哪</p><p>20.Integer b = new Integer(100); a==b？</p><p>21.integer c = 100; a==c?</p><p>22.线程池核心线程数和最大线程数的区别#java</p><h3 id="题目32">题目32</h3><p>\1. AI Agent项目的主要目的是什么？</p><p>\2. 这个项目最大的挑战是什么？</p><p>\3. DDD是什么？</p><p>\4. DDD的使用场景和解决的问题是什么？</p><p>\5. AI Agent项目中DDD实现的大致步骤？</p><p>\6. 领域识别和划分部分的思路是什么？</p><p>\7. 外卖项目中支付和营销拼团服务是如何拆分的，和DDD的异同？</p><p>\8. 索引优化具体是怎么做的？</p><p>\9. 实现商品名称模糊搜索的方案思路有哪些？</p><p>\10. MySQL慢查询的优化方法有哪些？</p><p>\11. 如何用锁和幂等解决超卖问题？</p><p>\12. 外卖项目中责任链、工厂、状态模式的选择思路是什么？</p><p>\13. 如何设计一个用户邀请系统（库表和API）？</p><p>\14. 对比Redis和Caffeine的优劣势及使用场景？</p><p>\15. JVM的内存模型和划分是怎样的？</p><p>\16. 对比MyBatis和MyBatis-Plus的优缺点？</p><h3 id="题目33">题目33</h3><p>1.base 业务<br>2.websocet选型 和sse区别 和短轮询区别<br>3.假如引入新组件出现问题 怎么解决<br>4.了解哪些限流策略<br>5.滑动窗口会有什么问题<br>6.分布式锁的命令 分布式锁过期时间怎么考量的 上线后有没有出现过什么问题<br>7.假如redis断流了 如何处理<br>8.多表数据怎么同步到同一张es宽表上<br>9.es和db的对账策略<br>10.假如对账没对出问题 兜底策略怎么设计<br>11.对降级策略以及组件了解多少<br>12.缓存用的什么组件 有哪些需要配置的信息<br>13.访问rpc接口 哪些因素影响接口耗时<br>14.mysql索引 慢查询优化经验<br>15.mysql事务等级 每个可能出现的问题<br>16.可重复读怎么实现的<br>17.mvcc具体讲一下<br>18.redis的string zset原理</p><h3 id="题目34">题目34</h3><p>java的基本类型及其包装类，为什么已经有基本类型，还需要包装类型</p><p>包装类的自动装箱和拆箱（Integer两道题目）</p><p>java的两种异常类型（Exception和error）</p><p>抽象类和接口的区别，使用时期的选择</p><p>为什么一般使用线程池，而不是每次都直接使用thread</p><p>线程池初始化位置</p><p>线程池有那些核心参数</p><p>核心5，最大10，等待队列上限50，来了20个任务，此时线程池里面有多少个线程</p><p>一个项目有很多个线程池，发现线程特别多，线程又不怎么活跃，此时怎么处理，合并线程池抢占激烈怎么办</p><p>java如何保证线程安全的方式</p><p>CAS具体的流程，另一个线程怎么感知变量是否修改</p><p>concurrentHashMap put的流程</p><p>mysql innodb引擎b+树，为什么使用b+树</p><p>联合索引，排序的顺序</p><p>msyql主从架构</p><p>一条sql语句的执行流程</p><p>消息队列MQ在系统中起到的作用</p><p>kafka有哪些部分组成</p><p>MQ消息积压的问题</p><p>partition的数量小于消费者的数量</p><p>partition扩容可能会出现的情况或者代价</p><h3 id="题目35">题目35</h3><p>\1. TCP VS UDP<br>\2. TCP的流量窗口，慢启动<br>\3. TCP拥塞算法<br>\4. TCP的连接<br>\5. TCP失序到达处理<br>\6. OSI七层模型，从上到下与从下到上，两种情况的应用场景<br>\7. 用户态与内核态<br>\8. 用户态内核态频繁切换具体会损耗什么<br>\9. 我要进行一个读取excel并发送的操作，期间会涉及到几次内核/用户的切换，以及发送的介质<br>\10. Redis单线程与多线程<br>\11. Redis的多路复用与具体实现原理，相比于别的方法有什么优势<br>\12. Redis数据一致性</p><h3 id="题目36">题目36</h3><p>\1. 自我介绍</p><p>\2. 拷问实习</p><p>\3. 接口耗时有了解过吗，数据库的执行耗时。</p><p>\4. 举一个实际做的数据库优化的例子？</p><p>\5. 项目中商品名称、品牌、价格范围，商品数量，如果你去搜的话有这么多选项，你是去如何优化一下索引的？</p><p>\6. ES查询流程</p><p>\7. ES去做分布式查询的流程</p><p>\8. ES分片有了解过吗？</p><p>\9. 商城里面缓存预热怎么做的？</p><p>\10. 缓存之间同步怎么去做的？</p><p>\11. 在更新缓存的时候，先更新一级缓存还是二级缓存</p><p>\12. 二级缓存什么时候会更新到一级缓存？</p><p>\13. 一级缓存和二级缓存的容量是一样大的吗？</p><p>\14. redis脚本和lua脚本之间的配合有使用过吗？</p><p>\15. 秒杀防超卖</p><p>\16. Redis lua脚本中有5条命令，第三条失败会会滚吗，后面两条会执行吗？</p><p>\17. 秒杀这里这么保证缓存的数据和数据库的数据是数据一致的？</p><p>\18. 如果用MQ保证的，消息发送失败怎么办？</p><p>\19. 如果MQserver端挂了，消息发不过去，还能成功吗？如果缓存已经扣减，然后MQ宕机，那么DB和缓存数据不一致，怎么解决？</p><p>\20. 用的哪个分布式锁？怎么实现的？</p><p>\21. 网关登录验证鉴权怎么做的？</p><p>\22. Nginx和网关的功能相同点和区别</p><p>\23. 介绍一下网络协议一共几层</p><p>\24. TCP和UDP主要的区别和场景</p><p>\25. HTTP和HTTPS主要区别</p><p>\26. 那HTTP为什么还会存在？</p><p>\27. 了解过LinkedHashMap?</p><p>\28. 为什么使用红黑树？</p><p>\29. 在HashMap里为什么不用其他的树？介绍一下红黑树</p><p>\30. 介绍一下平衡二叉树？</p><p>\31. ThreadLocal有用过吗？介绍一下。</p><p>\32. ThreadLocal的存储结构？源码有了解过吗？</p><p>\33. 假设现在有四个核心线程，八个最大核心线程数，任务队列容量为4，先提交四个任务，再去提交新的四个，核心线程处理四个，非核心线程处理4个需要十个小时，核心线程处理的快，在非核心线程处理时，核心线程空闲，这样不会浪费资源吗？</p><p>\34. 核心线程和非核心线程有一个标识？</p><p>\35. 介绍一下任务队列？各自有什么区别？</p><p>\36. 无界队列设置容量和有界区别，了解过底层的源码吗？</p><p>\37. 数据库的索引数据类型有了解过吗？B+树的了解。</p><p>\38. B树和B+树对于非叶子节点来说，一个存数据，一个不存数据，有什么区别？</p><p>\39. Mysql的锁？</p><p>\40. Spring的循环依赖的问题？怎么解决？</p><p>\41. 垃圾回收器用的什么？配置大概是多少？</p><p>\42. G1的回收过程？</p><p>\43. Shell命令查看占用80端口的线程ID怎么看？</p><p>\44. Shell命令查看某一个进程的进程ID怎么看？</p><p>\45. 说一下快排</p><h3 id="题目37">题目37</h3><p>你的项目中有哪些亮点或难点？</p><p>MySQL中，如果监控发现 CPU 和内存较高、连接较慢，可能是什么原因？排查方向有哪些？</p><p>MySQL中哪些查询可能导致慢查询？如何避免？</p><p>MySQL中建立了联合索引 (a, b, c)，查询条件是 b &gt; b1 and a = a1 时，索引是否会失效？为什么？</p><p>MySQL 为什么使用 B+ 树作为索引，而不是其他数据结构（如 AVL 树、红黑树）？</p><p>数据库事务的四种隔离级别是什么？分别解决了哪些问题</p><p>Redis 的常见数据结构有哪些？分别适用哪些场景？</p><p>为什么 Redis 适合作为缓存？</p><p>Redis 集群的分片原理是什么？（key 如何找到对应节点）</p><p>Spring 的核心思想是什么？请解释 Spring IOC 和 AOP 的原理。</p><h3 id="题目38">题目38</h3><p>1、自我介绍<br>2、实习+实验室项目。广告平台对算法调用比较多，细问了我数据集的制作。然后就是挑一个实习项目的难点介绍。中间主要穿插一些选型的询问，kafka or rocketmq，以及消息队列的高可用，保证消息的不丢失等问题。<br>3、八股：<br>a、讲讲java里面线程同步有哪几种方式<br>b、java的synchronized是如何实现的，是不是可重入的，如何实现可重入<br>c、你对栈和队列的理解<br>d、如何用栈实现队列，实现一个容量为n的队列，至少需要的栈大小为多少。</p><h3 id="题目39">题目39</h3><p>问了项目的redis相关的数据用什么类型存的(问的很细，但是我没复习项目，忘了)<br>怎么保证mysql跟redis的一致性(答了先更新后删除)，问redis删除失败怎么办(答了设置ttl)<br>java是怎么保证线程安全的？有哪些工具？<br>介绍下CocurrentHashMap。jdk1.8之后有什么不一样？插入元素的具体过程？为什么要使用红黑树？红黑树的增加元素的时间复杂度？<br>ConcurrentHashMap如何返回size的？如果不了解说一下设计思路(答了维护一个原子变量)<br>sql的慢查询如何优化，可能优化的方案尽可能说出来(explain先看看执行策略，之后分为sql语句方面，索引优化方面，innodb方面，架构方面优化)<br>如果一个接口响应时间不符合预期，怎么排查跟解决？(增加cpu，增加实例并使用合理的负载均衡算法，优化代码逻辑，使用多线程处理并设置合理的拒绝策略，降级，限流，改造成异步接口，使用消息队列balabala能想到的都说了，属于是梦到啥就说啥了)</p><h3 id="题目40">题目40</h3><p>\1. 先做个自我介绍吧。</p><p>\2. 聊聊你的实习经历，我可能会问得比较细。</p><p>\3. Redis 底层有哪些数据结构？原理是啥？</p><p>\4. 怎么保证 MySQL 和 Redis 的数据一致性？</p><p>\5. 如果不用事务，怎么维护数据一致性？</p><p>\6. Redis 有哪些缓存淘汰策略？</p><p>\7. 数据库索引为什么用 B+ 树，而不是红黑树？</p><p>\8. 聊聊乐观锁和悲观锁的应用场景。</p><p>\9. 做秒杀系统的性能测试，主要关注哪些指标？</p><p>\10. RabbitMQ 的核心概念和工作机制是怎样的？</p><p>\11. 用 RabbitMQ 保证 Redis 和 MySQL 的数据一致性，要注意什么？</p><p>\12. 怎么给共享单车系统设计测试用例？</p><p>\13. 支付流程的测试用例，你觉得还能怎么补充？</p><p>\14. 怎么监控和优化慢 SQL？</p><p>\15. 介绍下常见的大语言模型（LLM）？</p><p>\16. 讲讲 Agent 技术的原理？</p><p>\17. 分享下你是怎么学习 AI 的？</p><h3 id="题目41">题目41</h3><p>\1. 订单表分库分表后，怎么同时支持按商家和美团订单号查询，避免读扩散？</p><p>\2. 了解分布式事务吗？聊聊 2PC、3PC、Seata、TCC？</p><p>\3. 这些分布式事务方案有什么缺点？怎么解决？</p><p>\4. 还有别的分布式事务解决方案吗？</p><p>\5. 了解分布式链路追踪吗？Trace ID 是怎么传的？</p><p>\6. ThreadLocal 的原理是啥？</p><p>\7. 还知道哪些 ThreadLocal 的变种实现？</p><p>\8. 这些变变体分别解决了什么问题？为什么会出现？</p><p>\9. 看过 Redisson 分- 布式锁的源码吗？底层怎么实现的？</p><p>\10. Redisson 的分布式限流和延迟队列是怎么做的？</p><p>\11. 了解 JVM 的 G1 垃圾回收器吗？</p><p>\12. 聊聊实习经历吧。</p><p>\13. 算法：反转链表。</p><p>\14. 平时怎么学新技术？实习遇到困难怎么解决的？</p><h3 id="题目42">题目42</h3><p>1、公式化自我介绍<br>2、公式化拷打实习，问难点在哪，你做了什么工作，为什么要这么设计<br>3、RateLimiter原理是什么？（实习相关）<br>4、介绍一下ConcurrentHashMap的原理，如何做到高并发的？<br>5、ConcurrentHashMap如何扩容的？<br>6、公式化问项目（黑马点评），如何解决session不共享问题的，token生成策略是什么？如何刷新token<br>7、介绍一下ZSet，答了ziplist、listpack和跳表<br>8、为什么mysql不使用跳表作为数据结构？<br>9、3行的B+树最多有多少个结点？（没答出来）<br>10、mysql的存储引擎有哪些， 答了innodb和myisam<br>11、innodb和myisam的区别<br>12、MVCC介绍一下（上一个问题提了一嘴就问了）<br>13、平时用ai吗？（发现最近美团很喜欢问这个。。。）我答了平时用ai帮我做一些DTO、VO转换、list转为map这种，但是面试官好像希望能用ai做一个需求而非这种辅助功能</p><h3 id="题目43">题目43</h3><p>. 先做个自我介绍吧。</p><p>\2. 聊聊你对 MCP 的理解？</p><p>\3. MCP 客户端怎么调用服务器上的工具？整个交互流程是怎样的？</p><p>\4. Spring AI Alibaba Graph 的底层原理是啥？</p><p>\5. AI 编程对你的工作或生活有影响吗？具体聊聊？</p><p>\6. 为啥要用线程池？</p><p>\7. Java 线程池有哪几种创建方式？</p><p>\8. Java 线程池都有哪些拒绝策略？</p><p>\9. 多线程编程怎么保证线程安全？</p><p>\10. synchronized 和 ReentrantLock 有啥区别？</p><p>\11. ReentrantLock 的底层原理是啥？</p><p>\12. AQS 是怎么实现的？如何保证 state 变量的原子性？</p><p>\13. 垃圾回收算法有哪些？</p><p>\14. 聊聊一个对象在 JVM 里的生命周期？</p><p>\15. JVM 新生代里的 S0/S1 区有啥用？对象什么时候会进入老年代？</p><p>\16. Kafka 有什么特点？和 RabbitMQ 有啥区别？</p><p>\17. Kafka 为什么吞吐量这么高？</p><p>\18. 大模型为什么会产生幻觉？有什么解决办法？</p><p>\19. RAG 具体是怎么实现的？</p><p>\20. 预训练和微调有什么区别？</p><p>\21. 我们来回顾一下你之前做的 AI 编程题。</p><h2 id="二面">二面</h2><h3 id="题目1-2">题目1</h3><p>1.问了两句学校的项目，不是后端的，面试官肉眼可见没有兴趣</p><p>2.问了问实习做的rag项目的情况，不拷打纯聊天15分钟</p><p>3.RAG技术发展历史</p><p>4.java项目相关细节问题，比较常规：雪花算法，基因法分表，redis和db的一致性，缓存击穿</p><p>5.手撕</p><p>6.聊天室系统设计20min，业务实现orm设计、数据库设计、分库分表、restful接口设计</p><p>7.平时怎么学习，职业定位规划</p><h3 id="题目2-2">题目2</h3><p>主要聊了实习，还有 JDK 8 升 21 碰到的问题。</p><p>问了 UDP 广播。</p><p>场景题：微博大 V 发帖，用户量巨大，怎么优化？</p><p>问项目是不是自己写的，还问了分布式事务。</p><p>计网方面问了拥塞控制。</p><p>问了 JVM，怎么把元空间塞满？</p><p>问了些 Docker 的细节。</p><p>问了 Redis 的 Bitmap。</p><p>问了垃圾回收器。</p><p>问了怎么用大模型。</p><h3 id="题目3-2">题目3</h3><p>\1. 面试官介绍自己业务，没太听懂，说了有tob的也有toc的，主要是分布式场景、三高、数据一致性<br>\2. 自我介绍<br>\3. 项目经典点评超卖 + 一人一单一直说<br>\4. redission的setnx和redis的setnx有什么区别（不知道）<br>\5. 看门狗说说怎么回事<br>\6. rabbitmq消息积压怎么办<br>\7. 分析sql执行流程，innodb 字段(id,a,b,c,d) 索引有(d)、(a,b,c,d) select * from table_A where a = 1 and b = 2 and d = 4</p><p>SQL查询所有课程成绩都小于60分的学生学号、姓名，这里也宕机了一下<br>算法完成所有任务的最少初始时间</p><h3 id="题目4-2">题目4</h3><p>1.base偏好 业务偏好?北上杭各种业务都持开放态度</p><p>2.实习最大收获?项目中难点?怎么学习解决的? 提到了看技术博客和暑期面试美团的时候看的美团的文章，又问我一次为什么暑期没来美团</p><p>3.转正怎么样?是偏向于转正还是偏向于去外面找机会?(这时肯定得说老东家不好了</p><p>3.项目里MQ怎么用的?RocketMQ底层? 和 Kafka区别?</p><p>4.什么场景下选 Kafka?</p><p>5.实习用 redis是怎么用的?有没有看过它对数据库压力缓解了多少?(这是真没有)</p><p>6.为什么前端转后端?</p><p>7.想做全栈吗?</p><p>8.有什么 AI应用的实践?</p><p><a href="http://9.AI">9.AI</a> Coding的时候有什么自己的rule?</p><p>10.数据库表数据量大了怎么办?主从不一致怎么办? 如何补偿?</p><h3 id="题目5-2">题目5</h3><p>\2. 中断运行中的线程有哪些方式<br>\3. 如何中断线程池中一个特定的任务<br>\4. 主线程如何感知子线程有异常<br>\5. ThreadLocal 的实现原理是什么？它为什么会导致内存泄露？<br>\6. LinkedHashMap 或 TreeMap 的数据结构是什么？（选一）<br>\7. TreeMap 的查找复杂度是多少？<br>\8. 一条 SQL 语句在数据库中是怎么执行的？（从 Client, Server, Engine 协作关系角度）<br>\9. ORDER BY 语句在执行过程中是如何实现的？<br>\10. SQL 题：三张表（学生、课程、成绩），如何查到数学成绩排名第二的学生？<br>\11. 用过哪些大模型相关的能力或技术？<br>\12. Function Call, MCP, Agent2Agent 之间的关系是什么？<br>\13. 你理解大模型出现幻觉的原因是什么？</p><h3 id="题目6-2">题目6</h3><p>介绍 rpc?rpc 和 http 最本质的区别（提示我是代理）</p><p>介绍 java 代理？java 的这两种代理（jdk和 cglib）能代理私有方法吗？</p><p>实现分布式锁除了 redis 还有哪些？答了 mysql 和 zookeeper</p><p>zookeeper和 redis 实现分布式锁最主要的区别（又和我解释你介绍这两个组件的区别也行）？</p><p>Redis 为什么快？</p><p>讲讲io多路复用？</p><p>Redis 数据类型？讲讲跳表？</p><h1>米哈游</h1><h2 id="一面-2">一面</h2><h3 id="题目1-3">题目1</h3><ol><li>自我介绍</li><li>实习经历</li><li>MongoDB和MySQL选型上有过考量吗</li><li>Redis分布式锁</li><li>Redis怎么做消息队列，可以使用什么数据结构</li><li>怎么用Redis的数据结构实现一个延迟消息队列</li><li>项目经历，页面查询优化怎么做</li><li>游标和offset limit</li><li>订单数据同步的数据一致性怎么体现</li><li>Redis在这里的作用</li><li>MySQL的事务隔离级别</li><li>MySQL三种日志</li><li>二阶段提交</li></ol><h1>饿了么</h1><h2 id="一面-3">一面</h2><h3 id="题目1-4">题目1</h3><p>你用了优先队列（Priority Queue），这种做法本质上属于哪类排序？</p><p>该算法的时间复杂度和空间复杂度各是多少？</p><p>除了优先队列＋虚拟节点方案，你有没有想到其他更优解？</p><p>对“基本有序”数组，哪种排序最优？为什么？</p><p>请讲解快速排序的核心思想与流程。</p><p>如何快速从无序数组中找出第K大的元素？（如第3大、第10000大等）</p><p>最优解可否用堆？可否用快速选择（Quickselect）？</p><p>用3–5分钟重点介绍一个你参与度高、技术含量突出的项目。</p><p>你了解哪些开源RPC框架？</p><p>请详细讲一下阿里Dubbo的注册／发现机制、核心功能及优缺点。</p><p>令牌桶限流原理是什么？关键点在哪里？</p><p>你还知道哪些限流策略（固定窗口、滑动窗口、漏桶等），它们各自优缺点是什么？</p><p>你对Spring源码做过哪些研读？关注了哪些模块？</p><p>在Spring MVC中，IOC容器的两个最核心职责是什么？</p><p>能否详细讲解Spring容器的启动、类加载、Bean定义解析、依赖注入全过程？</p><p>JVM类加载双亲委派流程是怎样的？如何打破它？</p><p>请描述Java内存区域：堆、栈、方法区（永久代/元空间）、本地方法栈等。</p><p>哪些区域可能抛出OutOfMemoryError？</p><p>为什么Java 8将永久代改为元空间？它们在内存上的区别与优劣？</p><p>为什么要把String设计为不可变？</p><p>StringBuilder与StringBuffer有何区别？</p><p>反射的优点和缺点有哪些？</p><h1>携程</h1><h2 id="一面-4">一面</h2><h3 id="题目1-5">题目1</h3><p>2.项目拷打</p><p>a.把项目部署在服务器上你会怎么做？</p><p>b.把项目进行打包要打包成哪几个部分？怎么进行打包？前端后端分哪几个部分？</p><p>c.跨域问题怎么解决？</p><p>d.实时私聊功能怎么做的？</p><p>e.假如一下子有大量消息的话，服务端要怎么保证消息转发的实时性和完整性？</p><p>3. MySQL索引的原理？</p><p>4. B+树和B树的区别？</p><p>5. Redis怎么实现分布式锁？</p><p>6. Redis在应对高并发请求场景下有什么应对策略？（一开始说了搭建集群来做分流，后面面试官提示说要从令牌桶技术限流角度出发）</p><h1>小米</h1><h2 id="一面-5">一面</h2><h3 id="题目1-6">题目1</h3><ol><li>开场做了自我介绍，并详细介绍了项目经历</li><li>聊聊你对Java集合框架的理解吧。ConcurrentHashMap在1.7和1.8里有啥不一样的地方？</li><li>Java内存模型（JMM）能介绍一下吗？GC这块呢，讲讲内存回收？对了，逃逸分析了解不？</li><li>Java并发编程里的锁，你是怎么理解的？CAS底层是怎么实现的，能说说吗？</li><li>拦截器（Interceptor）和过滤器（Filter），它俩有啥主要区别？</li><li>SQL里 COUNT(*)、COUNT(1) 和 COUNT(具体列名)，它们之间有什么区别？</li><li>用Redis做延时消息，有什么实现方案吗？</li><li>HTTPS的加密和认证流程，还能想起来吗？能详细讲讲这个过程不？</li><li>假如有个特别大的日志文件，在Linux环境下，你会用什么命令去看它的内容？</li></ol><h3 id="题目2-3">题目2</h3><p>1、介绍一下项目，延迟任务怎么做的</p><p>2、zset底层原理 为什么用跳表 最差情况下查询复杂度 和其他二叉树、红黑树区别</p><p>3、异步任务是怎么做的</p><p>4、IOC</p><p>5、介绍CAS</p><p>6、怎么用的多线程？ 什么场景考虑用线程池</p><p>7、熟悉的垃圾回收器</p><p>8、说一下Redission 面试官说底层都是setnx</p><p>9、Redis是单线程的？ 多线程体现在哪里</p><p>10、synchronized可用在哪里？ 场景：在一个类中的读写锁方法加上synchronized</p><p>11、Mysql 索引，你项目中哪些表用了什么索引？ 索引失效的场景？ 大于小于为什么能造成索引失效</p><p>12、Mysql ACID Mysql的几个隔离级别 可重复读和读已提交相比？</p><p>可重复读主要解决了隔离性</p><p>13、MVCC了解吗</p><p>14、聊一下网络 TCP和UCP区别</p><p>15、UDP优点 （快）</p><p>16、TCP建立连接</p><p>17、TCP断开连接 为什么需要等待2MSL</p><p>18、进行服务发现和负载均衡， 负载均衡算法是什么 是定制的？还是用的轮询</p><h1>阿里</h1><h2 id="一面-6">一面</h2><h3 id="题目1-7">题目1</h3><p>1.优惠卷秒杀模块的技术亮点</p><p>2.处理线程安全问题的锁分为哪几类，一般是怎么使用的</p><p>3.介绍一下偏向锁和自旋锁</p><p>4.说一说你了解的加密算法</p><p>5.聊一聊你所了解的缓存</p><p>6.缓存一致性问题</p><p>7.在读取缓存时可能出现的相关问题</p><p>8.讲一下布隆过滤器的特点</p><p>9.布隆过滤器存在的假阳性的问题怎么进行优化</p><p>10.分布式系统的设计考量</p><p>11.分布式锁的大概原理</p><p>12.微服务的工作流程</p><p>13.微服务的服务数量很多的情况下如果某一个服务突然挂掉了可能引发微服务的雪崩，该怎么解决</p><p>14.限流算法的了解</p><p>15.CAS和AQS的原理</p><h3 id="题目2-4">题目2</h3><p>\1. 聊聊 Java 线程池的参数？线程池是怎么执行任务的？</p><p>\2. 建 MySQL 索引时要考虑啥？用 MySQL 的时候，要关注哪些指标？</p><p>\3. Redis 是怎么做持久化的？</p><p>\4. 对 AI 了解多少？了解 Milvus 吗？(这块我讲了一堆理论，但面试官没怎么追问)</p><p>\5. JVM 垃圾回收有哪些算法？CMS 和 G1 有啥区别？</p><p>\6. 为啥要用分布式锁？什么场景下会用？</p><p>\7. 讲一个项目里解决问题的经历？</p><p>\8. 你平时是怎么学新东西的？</p><h3 id="题目3-3">题目3</h3><p>1.自我介绍<br>先问的八股<br>2.简单描述一下常用集合类的适用场景及线程安全性<br>3.ArrayList 和 HashMap的增删改查复杂度<br>4.ReentrantLock 和 synchronized的区别<br>reentrantLock 的尝试机制忘了说了<br>5.mysql 事务<br>6.举个幻读的例子<br>7.mysql中建索引要注意什么<br>8.举个例子说明下什么是回表<br>9.如何避免回表<br>10.分库分表问题<br>面试官提示 : 尽量打散 结合业务需求分表<br>11.缓存雪崩击穿穿透问题</p><h3 id="题目4-3">题目4</h3><p>自我介绍</p><p>讲实习 35min<br>toc场景如何确保DB和REDIS尽量实时？<br>怎么避免缓存雪崩和击穿？<br>假如列表查询时数据量极大需要分页怎么办？</p><p>八股 10分钟<br>hashset讲一下<br>threadlocal讲一下</p><p>场景15分钟<br>设计一个智能会议总结系统<br>大致流程是前端把语音发到后端，调用工具转文字，调用大模型进行总结，再发回前端</p><h3 id="题目5-3">题目5</h3><p>\1. 为什么要使用CompletableFuture<br>\2. 线程池是怎么管理的<br>\3. 实习经历<br>\4. 本地缓存相关<br>\5. ThreadLocal内存泄漏<br>\6. HashSet为什么能去重<br>\7. Redis怎么保证原子性<br>\8. 缓存击穿和缓存雪崩<br>\9. 慢SQL优化<br>\10. 场景题：1. 前端录音 → 后端接收录音 → 后端调用阿里云API转文字 → 利用文字调用大模型API总结 → 文字落库</p><ol start="2"><li>前端调用后端接口输出文字</li></ol><h3 id="题目6-3">题目6</h3><p>1、自我介绍</p><p>2、实习询问（5min）</p><p>3、项目拷打（20min）</p><p>4、谈谈 Java 的 HashMap</p><p>5、线程池的核心参数</p><p>6、线程池从没有任务到繁忙起来，再到空闲这个过程中，参数是如何变化的？</p><p>7、谈谈浅拷贝和深拷贝的区别</p><p>8、谈谈 Java 的 String 是怎样的结构？内部怎么设计的？</p><p>9、String 类在加载后会存在什么区域？</p><p>10、谈谈 JVM 的内存模型</p><p>11、GC 算法有哪些？每种算法应用在什么场景？</p><p>12、谈谈 CMS 垃圾回收器的回收过程</p><p>13、CMS 在哪些阶段会 Stop The World？</p><p>14、谈谈 G1 和 CMS 的区别</p><p>15、如何排查 OOM 问题？</p><p>16、如何排查 CPU 100% 问题？</p><p>17、日常开发过程中对于类冲突或者 jar 包冲突，如何去解决？（加载第三方包，和自己的环境不适配）</p><p>18、MySQL 怎么去排查慢 SQL？</p><p>19、谈谈 MySQL 的 InnoDB 存储引擎的索引结构</p><p>20、为什么 InnoDB 不选择 B 树或者红黑树？</p><p>21、MySQL 的排序 order by，对于大数据的排序，是怎么实现的？</p><p>22、目前对于 AI相关的一些前沿的技术自己有去了解过吗？</p><p>23、你认为对于数据标注类工作，比如判断一张图片有无水印，能否用 AI 去代替人工？</p><h3 id="题目7-2">题目7</h3><p>1.自我介绍</p><p>2.实习经历中有哪些亮点。</p><p>3.个人项目有哪些技术难点。</p><p>4.秒杀系统的流量承接怎么做的。</p><p>5.如何解决超卖问题（多种实现）。</p><p>6.系统如何防刷的。</p><p>7.GC如何设计的。（内存结构到回收算法）</p><p>8.mysql 行锁的加锁过程。</p><p>9.TCP可靠性，滑动窗口解决了哪些问题。</p><p>10.AI方面关注过哪些技术点。</p><p>11.简单聊聊LangChain和LangGraph。</p><h3 id="题目8-2">题目8</h3><p>1,现在在哪实习<br>2，有没有转正<br>3，那你现在更倾向去哪<br>4，挑一个项目讲讲<br>5，怎么解决大key以及数据倾斜问题<br>6，redis分片后本身有什么联系<br>7，数据倾斜解决用什么算法<br>8.整体业务是什么，为什么设计这四个缓存<br>9，实习遇到难的问题<br>10，复现哪些是比较难的，怎么复现<br>11，为啥忽然换实习<br>12，另一个项目介绍<br>13，第一个功能怎么实现的<br>14，怎么做的健康检查<br>15，什么时间间隔发请求，还是怎么做的<br>16，这个功能支持什么协议，一般用什么协议，不同协议的使用场景（后面再看看有点忘了）<br>17，健康请求，需要触发吗，还是有定时任务<br>18，你这里面怎么样递归<br>19，什么时候订阅，哪些节点订阅<br>20，什么时候初始化启动<br>21，怎么初始化，什么时候订阅消息初始化<br>22，建立长链接还是短连接<br>23，什么时候用长连接，什么时候用短连接<br>24，你那个开关经常变化吗，<br>25，你这个ectd为什么用长连接，而不是短连接<br>26，介绍你的研究方向<br>27，你这个方向具体解决什么问题<br>28，解决思路什么<br>29，最后的效果如何，为什么能达成这样的效果<br>30，平时怎么样学习<br>31，展开讲讲你的学过的一次技术分享<br>32，为什么不找你研究方向相关的工作<br>33，你觉得开发具体往哪个方向发展会更好，提到大模型智能体什么的<br>34，你为什么不找智能体相关的工作<br>35，讲一下反射原理，应用场景，实际工作中的应用<br>36，并发编程主要用来干嘛</p><h3 id="题目9-2">题目9</h3><p>1.concurrenthashmap怎么保证线程安全</p><p>2.hashtable线程安全(不会</p><p>3.hashmap线程不安全例子(说的不咋地</p><p>4.Future用过吗(没有</p><p>5.Spring ioc底层 好处</p><p>6.mysql索引 联合索引的B+树具体咋实现的</p><p>7.mysgl隔离级别 RR用在哪些场景</p><p>8.5层网络模型tcp udp区别http https区别</p><p>9.阿里云有哪些产品用的udp?(这我哪了解过</p><p>10.死锁条件(忘了一个</p><p>11.A给B转账 B给A转账会死锁吗?12.微软实习13.阿里云实习</p><p>14.手写支付系统A给B转账(没写完讲了思路，具体问了怎么加锁</p><p>15.RocketMQ事务消息底层实现，回查时间16.如果事务回查的时候事务那个线程在执行逻辑 超过回查时间事务回查到成功会有什么问题?怎么解决?(没太理解他的意思</p><h1>腾讯</h1><h2 id="一面-7">一面</h2><h3 id="题目1-8">题目1</h3><p>1. 实习干的东西</p><p>2. 权限管控怎么做的</p><p>3. 权限管控是怎么标识的用户</p><p>4. 怎么保证用户信息不会被传输过程篡改</p><p>5. https怎么保证的加密传输</p><p>6. 线程和进程的区别 进程能访问其他应用的内存吗 为什么</p><p>7. 线程和协程的区别</p><p>8. 项目里为什么要使用登录 qq登录怎么做的 过程是怎样的 qq是怎么加密的中间数据</p><h3 id="题目2-5">题目2</h3><p>Canal 和 Kafka 之间是怎么交互的？用的什么协议？<br>Kafka 的实现原理是啥？<br>ES 为什么这么快？讲讲倒排索引，还有文档列表是啥意思？<br>资源隔离是怎么实现的？<br>K8s 的部署和滚动更新流程是怎样的？怎么在更新的时候保证服务不中断？<br>有个下载文件的问题（具体忘了）<br>操作系统启动时都干了些啥？<br>聊聊操作系统的内存管理和进程管理？<br>给你一大堆 IP 地址，怎么找出哪个网段下的 IP 最多？<br>我答了个 O(n) 的方案，面试官追问怎么避免哈希冲突，有没有更好的方法，还问了哈希冲突最极端的情况怎么办。<br>又追问，如果想找 Top 3 怎么办？要是内存不够，又该怎么找 Top 10？</p><h3 id="题目3-4">题目3</h3><ol><li>自我介绍</li><li>开篇面试官介绍了一下这次面试的流程</li><li>HashMap和HashTable的区别？</li><li>接T3，针对HashTable的问题，有没有解决方案？（ConcurrentHashMap）</li><li>线程和进程的区别？</li><li>接T5，通信方式上有什么区别？</li><li>MySQL索引结构？</li><li>接T7，B树和B+树的区别是什么？</li><li>接T8，为什么说B+树更好做范围查询？</li><li>MySQL事务隔离级别？</li><li>MVCC</li><li>索引失效的情况都有哪些？</li><li>Redis持久化方案？</li><li>缓存雪崩、缓存穿透、缓存击穿</li><li>讲讲TCP的三次握手和四次挥手</li><li>说说Linux的常用命令？</li><li>有没有用过Docker？说说Docker的常用命令？有自己构建过Docker镜像吗？</li></ol><h3 id="题目4-4">题目4</h3><p>你对腾讯云智的产品有哪些了解？有没有使用过相关的服务？<br>Java 中的集合框架有哪些？HashMap 和 ConcurrentHashMap 的区别是什么？<br>谈谈 Java 中的多线程，线程池的核心参数有哪些？如何设置合理的线程池参数？<br>Spring IoC 和 AOP 的原理是什么？在项目中是如何使用 AOP 的？<br>Spring 事务的传播机制有哪些？你在实际开发中遇到过哪些事务相关的问题<br>Java 中 synchronized 和 Lock 的底层实现原理有何区别？谈谈你对偏向锁、轻量级锁、重量级锁的理解<br>深入分析 ThreadLocal 的内存泄漏问题，如何避免？在分布式场景下如何实现类似 ThreadLocal 的功能？<br>Redis 的持久化机制有哪些？RDB 和 AOF 的优缺点及适用场景是什么？如何解决 AOF 重写时的性能问题？<br>Redis 的集群方案有哪些？哨兵模式和 Cluster 模式的区别是什么？Cluster 模式下槽位迁移的过程是怎样的？<br>RabbitMQ 的交换机类型有哪些？详细说明 Topic 交换机的路由规则，如何保证消息的可靠性投递（从生产者到交换机、交换机到队列、消费者消费三个环节分析）<br>单例模式的实现方式有哪些？哪种方式是线程安全的？<br>在项目开发中，你是如何进行代码调试和排错的？有什么技巧吗？<br>工厂模式和抽象工厂模式的区别是什么？在什么场景下会使用抽象工厂模式？<br>工厂模式在实际项目中有哪些应用？你觉得使用工厂模式有什么好处？<br>Java 中的异常处理机制是怎样的？try-catch-finally 块的执行顺序是什么？<br>谈谈你对 Java 内存模型的理解，volatile 关键字的作用是什么？<br>数据库的分库分表有哪些方案？各自的优缺点是什么？<br>在进行 Java 开发时，你是如何保证代码质量的？会使用哪些工具？</p><h3 id="题目5-4">题目5</h3><p>1.自我介绍<br>2.5层网络分别是什么，讲讲每层什么协议，有什么东西<br>3.MTU包含哪些层的数据，大小一般多大怎么计算<br>4.MTU和MSS区别<br>5.TCP怎么保证可靠的<br>6.建连和断连是怎么样<br>7.为什么挥手四次要比握手多一次<br>8.挥手并不是一定得四次，能在更少次数内实现，请分析可能怎么做的<br>9.既然能挥手次数更少，但是为什么现在主流还是四次<br>10.我假设是一个客户端，我在和服务端通信，我怎么知道发送窗口数据量是多大呢<br>11.现在已经有了一个滑动窗口了，这个滑动窗口大小变化的时候是怎么变化的<br>12.我丢包了，那这个窗口大小是不是就有问题了，有什么处理方案<br>13.你作为一个一端的程序，是怎么知道是网络拥塞还是是链路丢包的<br>14.TCP的拥塞控制是怎么做的<br>15.假设要让你设计一个完整的判断网络拥塞还是链路丢包的协议，你会怎么设计<br>16.现在假设你打开腾讯视频，突然某些（不是所有）视频你看不了了，你会怎么分析+排查+定位+解决这个问题，从app端上的问题-》网络的问题-》服务端的问题各个角度尽量全面的分析<br>17.wireshark你了解吗，怎么在手机上抓包呢<br>18.算了你假设你能在手机上抓包，你怎么从二进制数据排查定位分析这个场景的问题原因呢<br>19.抓包的底层原理是怎么样的，这个包是怎么从操作系统的内核态数据取到的<br>20.HTTP1-3对比，讲讲多路复用在内核是怎么实现的<br>21.QUIC保证udp可靠传输和tcp自身可靠传输的对比<br>22.HTTP和HTTPS区别<br>23.你讲讲HTTPS的完整的方案<br>24.你这种方案的RTT是多少<br>25.有1RTT的HTTPS方案，你了解吗<br>26.你对网络安全了解多少，像DDOS攻击，中间人攻击这些了解吗，有没有一些解决</p><h3 id="题目6-4">题目6</h3><p>~ tcp客户端开发有哪些步骤</p><p>~ tco协议具体是什么</p><p>~ 描述三次握手和四次挥手</p><p>~ udp一个包有多少数据</p><p>~ 结构体和模板类的区别是什么</p><p>~ linux根目录proc目录作用是什么</p><p>~ 介绍一些调试工具</p><p>~ mysql引擎是什么</p><p>~ ddos是什么</p><p>~ redis有哪些数据结构</p><p>~ redis缓存慢了怎么办，如何进行持久化</p><p>~ 消息队列</p><p>~ 举一些agent框架</p><p>~ mcp是什么</p><p>~ mcp用的通信协议</p><h3 id="题目7-3">题目7</h3><p>\1. 自我介绍后问意向base（刚开始还抱有期待hhh）</p><p>\2. 介绍实习内容？有什么难点？</p><p>\3. 你说的这些偏业务，有没有技术上的难点？</p><p>\4. 你提到redis，zset底层原理？dict和skiplist是怎么对应的？如果让你设计，如何设计一个并发安全的跳表？</p><p>\5. 内存里有一个map，你如何设计持久化策略，使得忽然宕机时，能够保证数据最少丢失？</p><p>\6. 假设redis有一个list，客户端执行append操作，你如何设计，实现能够判断插入失败的原因（client还是server导致的）</p><p>\7. 100g数据1g内存找中位数？</p><h2 id="二面-2">二面</h2><h3 id="题目1-9">题目1</h3><ol><li><p>自我介绍</p></li><li><p>有用过MQ对吧，那你说说怎么解决消息重传的？</p></li><li><p>你是怎么做消息幂等性处理的？</p></li><li><p>接T3，如果说Redis的key已经存入了，但是刚好消费者宕机了，怎么办？</p></li><li><p>建立索引的SQL语句是？</p></li><li><p>TLS握手过程</p></li><li><p>手撕1：单链表有一个指针指向任意一个节点，怎么删除这个指针指向的节点，如1→2→3→4，传入2，删除2，没有头指针（回答了更改节点值，next设置为next.next，追问怎么删除最后一个节点，不会，换了道题）</p></li></ol><h2 id="三面">三面</h2><h3 id="题目1-10">题目1</h3><ol><li>自我介绍</li><li>拷打项目</li><li>拷打实习</li><li>我现在有一个student表，我要对name简历索引，sql语句怎么写？</li><li>主键索引和普通索引有什么区别？</li><li>为什么非聚簇索引要回表？</li><li>MySQL隔离级别？</li><li>MySQL主从同步原理？</li><li>binlog日志存的是什么？</li><li>Redis缓存雪崩是个什么概念？怎么解决？</li><li>Redis持久化方式？</li><li>HTTP报文格式？</li><li>HTTP和HTTPS有什么不同？</li><li>TLS握手过程？</li><li>为什么是非对称加密和对称加密结合使用？能不能只使用一种？</li><li>面向对象三大特性</li><li>我现在有一个Java源代码，比如说叫xxx.java，他是如何变成一个二进制文件的能够让机器运行他的？这个中间的过程是怎么样的？</li><li>JVM的作用是什么？</li><li>进程和线程的区别？</li><li>有没有了解过协程？跟线程的区别是什么？</li><li>为什么说协程为什么更轻量？</li><li>二进制文件加载进内存，他的分布是怎么样的？</li><li>Linux上怎么看机器的负载？</li><li>top命令哪些参数表示负载？</li><li>Linux怎么看cpu的核数？</li><li>Linux怎么查看当前目录占用了多少空间？</li><li>查看当前服务器建立的tcp连接，用什么命令？</li><li>tcp滑动窗口机制是怎么样的？</li><li>time_wait状态是什么意思？</li><li>为什么是四次挥手？</li><li>三次握手是怎么实现的？中间的ACK和SYN是怎么合并的？</li><li>用过docker吗？怎么做到容器间隔离的？</li><li>怎么构建docker镜像？</li><li>有了解AI吗？大模型训练过程是怎么样的？</li><li>有没有了解过MCP？</li><li>使用过什么AI工具？</li></ol><h1>中兴通讯</h1><h2 id="题目1-11">题目1</h2><p>1、两段实习拷打，没手撕；</p><p>2、如果你想做出海业务你会想怎么去因地制宜设计架构；</p><p>3、redis大key对于cpu和网络流量的影响；</p><p>4、redis跳表结构；</p><p>5、mysql的b+树结构，mysql的FULLTEXT索引是否能帮助进行模糊查询，这个索引和es直接查询区别在哪；</p><p>6、sql语句执行顺序；</p><p>7、线程池原理；</p><p>8、Hashmap结构和扩容机制；</p><p>9、Java开发中用到的同步机制；</p><p>10、rpc调用链路中怎么保证分布式事务的最终一致性；</p><p>11、谈谈kafka怎么保证消费的一致性和顺序性还有可靠性；</p><p>12、说说gc收集器，说说怎么排查gc日志；</p><p>13、说说Java开发过程你用到的设计模式；</p><p>14、说说你简历写的慢sql排查思路；</p><p>15、死锁检查，银行家算法；</p><p>16、jvm结构；</p><p>17、JNA怎么保证不内存泄漏；</p><p>18、OOM常见情况；</p><p>19、linux大页；</p><p>20、拦截器和过滤器；</p><p>21、一致性协议还有相关的选举机制；</p><p>22、redis缓存雪崩穿透击穿场景和解决方法；</p><p>23、常见的哈希冲突，ThreadLocal怎么解决哈希冲突；</p><p>24、怎么优化提示词生成效果；</p><p>25、怎么写规则引擎；</p><p>26、你常用的设计模式；</p><p>27、类加载机制和双亲委派；</p><p>28、数据库三大范式；</p><p>29、2pc，3pc，tcc，seata；</p><p>30、最大堆最小堆是啥样子的，红黑树原理，堆排序过程。</p><h1>科大讯飞</h1><h2 id="题目1-12">题目1</h2><p>.自我介绍</p><p>2.问了一下实习的东西</p><p>3.问了一下Java中那些组件和技术学的好(我回答了Nacos,Sentinel,RocketMQ,Zookpper,Dubbo,Redis,Caffein这类的)</p><p>4.Java中的封装和反射的区别(这里建议回答为什么有封装了还需要使用反射,要更了解底层,比如要回答反射的一些作用,依赖注入这类的,要回答反射使用的一些例子(比如反射是用于动态代理,为什么是动态的?举例子),后面还问到了设计模式,我说到了代理模式(AOP),但是面试官说没有这种设计模式,最后说了一下工厂模式,但是没了解过工厂模式底层怎么使用到反射)</p><p>5.反射运行时灵活,怎么体现的?(最好说依据,举例子)</p><p>6.工厂模式底层怎么使用到反射,为什么这么使用</p><p>7.说一下Mysql的事务怎么实现的(我回答了锁)</p><p>8.Java里面有哪些锁</p><p>9.事务的特效(ACID)</p><p>10.说一下ACID是什么</p><p>11.你知道Redis也有事务,redis的事务跟Mysql的事务有什么区别(我不会)</p><p>12.问了一下毕业时间,有没有考研打算,说一下自己的职业规划,往什么方向发展,感兴趣什么,想从事什么职业</p><h3 id="题目2-6">题目2</h3><p>Java 有哪些基本的数据类型？</p><p>32 位操作系统跟 64 位系统 int 类型有区别吗？</p><p>讲一下 Java 的集合结构？</p><p>如何对集合的元素排序？JDK 里排序用的是什么算法？归并排序和快速排序有什么区别？</p><p>讲一下 JVM 的结构</p><p>引用计数法如何解决循环依赖？</p><p>JVM 有哪些垃圾回收算法？</p><p>MySQL 执行一条 select 语句经历了哪些？MySQL 有些存储引擎？</p><p>SpringMVC 中的过滤器跟拦截器有什么区别？</p><p>SpringBoot 从接收到一个请求到返回前端经历了哪些？</p><h1>影石</h1><h2 id="题目1-13">题目1</h2><p>1.自我介绍<br>2.介绍一下学校情况和学的语言和框架</p><ol start="3"><li>线程池的四种类型 ， 核心参数<br>4.单线程池的应用场景<br>5.同步的一些方式<br>6.reentranLock和synchronized的区别<br>7.各自怎么来进行同步过程，contional的sign()和await()；<br>8.correntHashMap , copyonWrite<br>9.ArrayList的扩容过程，复制过程是底层的system.copy();<br>10.容器快速失败过程和原理（就是遍历的时候被修改）<br>11.TCP和UDP的区别和各自应用场景</li></ol><h1>SOUL</h1><h2 id="一面-8">一面</h2><h3 id="题目1-14">题目1</h3><p>自我介绍<br>实习拷打：为什么用线程池，用了什么线程池？有什么指标吗？提升了多少？为什么用策略模式和工厂模式？还有哪些难点？<br>spring 的模块有哪些？<br>IOC， AOP，DI分别指什么？<br>spring bean生命周期<br>线程池有哪些优点，池化<br>mysql事务有哪些隔离级别<br>一条sql语句如何执行的<br>redis有哪些数据结构，使用场景<br>redis哨兵如何选举，<br>redis持久化机制</p><h3 id="题目2-7">题目2</h3><p>Java 的重写和重载有啥区别？</p><p>Spring Bean 的生命周期是怎样的？</p><p>Java 什么情况下会 Full GC？</p><p>手撕 SQL：查出学生数超过 3 个的学院。</p><p>慢查询怎么处理？</p><p>MVCC 是干嘛的？</p><p>不同隔离级别下，MVCC 的表现有啥不一样？</p><p>Redis 的持久化机制是啥？</p><p>AOF 重写是怎么回事？</p><p>git 提交错了怎么办？</p><p>操作系统里进程间通信有哪几种方式？</p><p>Linux 里怎么干掉一个进程？</p><p>Linux 怎么查进程 ID？</p><p>Redis 有哪些数据类型？</p><p>ZSet 底层是怎么实现的？</p><p>项目里有啥难点？(我聊了秒杀流程)</p><p>分布式锁是怎么实现的？</p><p>怎么知道分布式锁被哪个线程占着？</p><h1>得物</h1><h2 id="一面-9">一面</h2><h3 id="题目1-15">题目1</h3><p>1.简历上后端经历偏多，为什么来投递我们IOS端？<br>2.实习经历简单介绍一下<br>3.面向对象的设计原理？<br>4.设计模式了解哪些？<br>5.进程和线程的区别？<br>6.为什么会产生死锁？<br>7.讲一下优先级反转？<br>8.多线程操作非原子的数据的安全性怎么保障？<br>9.自旋锁是什么？<br>10.想要复用别人开发的方法但其只能满足自己一部分需求，可以怎么做？<br>11.怎么设计一个易复用的代码结构？<br>12.如果定义成纯虚函数，原有的功能逻辑怎么办？</p><h3 id="题目2-8">题目2</h3><p>自我介绍</p><p>1.dubbo的spi和java的spi有什么区别</p><p>2.分布式系统中的trace链路跟踪</p><p>3.线上的java服务cpu负载高怎么排查<br>怎么定位是哪块的代码出了问题</p><p>4.分布式系统调用下游服务怎么保证成功<br>怎么去设计重试机制 异步线程池不会爆满吗</p><p>5.java里的类加载机制<br>双亲委派怎么打破<br>spi 是怎么打破的</p><p>6.jvm内存溢出怎么排查(堆内与堆外怎么排查)</p><h3 id="题目3-5">题目3</h3><p>1、跳表原理</p><p>2、跳表相对于平衡树在并发场景下有优势</p><p>3、CAS 三大问题，以及怎么解决</p><p>4、版本号AtomicStampedReference的怎么解决</p><p>5、线程池使用无界队列的问题</p><p>6、线程线程怎么结束的</p><p>7、事务的@Transtional 注解，A事务调用B事务抛出异常之后，在默认事务传播机制下，会提交异常，因为 rollback 异常标志位已经被设置有值</p><p>8、如果一个Trace 调用耗时比较长，怎么去进行排查</p><p>9、Redisson 的看门狗机制</p><p>10、Spring 是如何解决循环依赖的11、Kafka 落盘如何建立索引</p><h3 id="题目4-5">题目4</h3><p>\1. 讲一下redis zset底层数据结构，讲讲跳表、压缩列表、listpack？</p><p>\2. 从浏览器地址栏输入网址按下回车，发生了什么？</p><p>\3. 浏览器怎么知道你按下了回车？</p><p>\4. 应用程序怎么知道客户端向其发送了请求？</p><p>\5. 影响MySQL B+树高度的因素</p><p>\6. 讲一下MySQL执行查询语句的流程</p><p>\7. [项目] 如果别人拿到了sessionId，就可以冒名登录，如何解决这个问题？</p><p>\8. [项目]每次进行判题都创建容器，是否会有性能问题？</p><p>\9. [项目]用户规模大后怎么解决QPS高的问题？</p><h3 id="题目5-5">题目5</h3><p>\1. 简单说下最熟悉的中间件，或者说看过源码的中间件<br>\2. JVM内存模型<br>\3. 栈内存的生命周期是什么？<br>\4. 栈内存，也就是说虚拟机栈是什么时候创建的？<br>\5. 为什么栈是线程私有的？<br>\6. synchronized关键字知道吗？<br>\7. 锁标识存在哪里？<br>\8. 公平锁还是非公平锁？怎么实现的？<br>\9. mysql聚簇索引和非聚簇索引有什么区别？<br>\10. 空值会不会存入索引？查询会走索引码？selsect一个 null值不会全表扫描吗？<br>\11. Redis淘汰策略了解吗？<br>\12. Redis的LRU的数据结构是什么？怎么实现的？<br>\13. 二叉树层次遍历口述<br>\14. Redis什么情况下会造成阻塞？有什么使用不规范的情况会导致？（单线程角度）<br>\15. 设计一个火车票库存表，有哪些字段？<br>\16. 有一辆列车从北京到上海，中间站郑州，怎么存储这些车票？<br>\17. 如果中间站A，B，C…怎么存储？考虑中间站之间的上下车，比如B到C的票，一共该怎么存储？<br>\18. SQL：<br>查找下了最多订单的客户的 customer_number<br>表: Orders order_number customer_number<br>在 SQL 中，Order_number是该表的主键。<br>此表包含关于订单ID和客户ID的信息。<br>查找下了 最多订单 的客户的 customer_number<br>测试用例生成后，恰好有一个客户 比任何其他客户下了更多的订单。</p><h3 id="题目6-5">题目6</h3><p>1.自我介绍<br>2.实习/项目经历中有什么遇到过什么困难？<br>3.利用大模型进行代码的缺陷检测，你了解大模型底层是怎么做到输入代码返回缺陷的吗？<br>4.大模型应用方面有哪些调优的地方？<br>5.上面你提到需要提取一些上下文，比如全局变量，你知道java中哪些对象可以作为GCroot？<br>6.gc有哪些机制，能说说吗？（说了gc算法，gc垃圾回收器）<br>7.现在使用哪一种垃圾回收器? (jdk1.8默认的)<br>\8. 那和其他垃圾回收器相比，你使用的垃圾回收器有哪些优点与缺点？（其余的STW的时长会短一点，高并发、低延迟）<br>9.项目中有一个优惠券防超发的功能，说说怎么做的？<br>10.锁的维度是什么？<br>11.优惠券创建的时候就和用户做了绑定了吗？<br>12.那你按照用户id去锁（好像应该是锁优惠券），那多个用户去抢，怎么做到防止超发？（数据库乐观锁）<br>13.那为什么还需要锁用户id（防止单个用户去抢多张券）<br>14.锁的超时时间是怎么设置的？<br>15.使用消息队列进行异步领券，那如果消息还没有消费，用户又一次发了请求，怎么处理？（先校验再发送到MQ）<br>16.那如果消费队列消费失败了怎么办？（兜底，死信队列对失败消息处理，重试？回滚？）<br>17.你的分布式锁怎么控制死锁的情况？<br>18.数据库与redis的一致性如何去保证？<br>19.单例模式双重锁的那一套写一下？解释一下为什么要两次判断？<br>20.我看你加了volatile，有什么用？<br>21.java中有error和Exception两种，分别是什么？讲讲？</p><h3 id="题目7-4">题目7</h3><p>1.讲一下有挑战的项目</p><p>2.讲一下熟悉的中间件</p><p>3.讲一下jvm内存模型</p><p>4.栈的生命周期</p><p>5.栈什么时候创建（回答的不是很好）</p><p>6.栈和线程的关系（回答的不是很好）</p><p>7.java的sy锁</p><p>8.LRU的底层</p><p>9.讲一下二叉树层序遍历</p><p>10.手撕sql</p><p>11.场景题：火车票库存系统设计数据库字段</p><h1>滴滴</h1><h2 id="一面-10">一面</h2><h3 id="题目1-16">题目1</h3><ol><li>自我介绍。</li><li>(项目) 聊聊你们是怎么防止单点故障的？</li><li>(项目) 具体讲讲那 10 万条数据是怎么处理的？</li><li>线程池有哪些核心参数？它具体是怎么跑的？</li><li>线程池的核心参数，你一般都怎么设？特别是核心线程数和最大线程数。</li><li><code>synchronized</code> 和 <code>Lock</code> 有啥区别？要是碰到异常，它俩分别会怎么样？</li><li>JVM 的运行时数据区都包含啥？分别介绍一下？</li><li>MQ 一般都用来干嘛？除了削峰填谷还能干啥？为啥要用 MQ？</li><li>MySQL 优化，除了加索引还有别的招吗？</li><li>介绍下数据库的隔离级别？</li><li>讲讲缓存穿透？怎么解决？布隆过滤器具体怎么实现的？有啥特点？</li><li>手撕算法：10 万个数里找出最小的 10 个（用小顶堆）。</li><li>以后有什么规划？</li></ol><h3 id="题目2-9">题目2</h3><p>1、自我介绍，大概 2 分钟。</p><p>2、详细聊了聊项目，深挖了一些技术细节。</p><p>3、啥是序列化和反序列化？</p><p>后面还聊了：</p><p>- <code>equals</code> 和 <code>==</code> 的区别？</p><p>- <code>ConcurrentHashMap</code> 的原理？</p><p>- 线程池参数怎么配？</p><p>- CPU 密集型任务为啥线程数要设成 CPU 核数+1？</p><p>- 怎么平衡软硬件资源的使用？</p><p>- <code>synchronized</code> 的锁升级过程是啥？</p><p>4、JVM 垃圾回收：</p><p>- 详细讲讲垃圾回收算法？</p><p>- 主流的垃圾回收器有啥区别？</p><p>- 新生代和老年代用的回收算法有啥不一样？</p><p>- 新生代为啥用标记-复制算法？</p><p>5、深挖了项目里的调度系统。</p><p>6、详细聊了并发解析 Excel 的方案：</p><p>- 接口延迟怎么处理？</p><p>- 数据库表结构怎么设计的？</p><p>- 并发写入和限流策略？</p><p>- 权限验证机制？</p><p>- 怎么防重复提交？</p><p>- 数据合规性怎么校验？</p><h3 id="题目3-6">题目3</h3><p>\1. 看过源码吗，什么时候才会去看源码</p><p>\2. redission了解过吗，有什么用，怎么实现分布式锁的，原理是什么，为什么是可重入的，是怎么实现给锁续期的，他怎么检查任务是否执行完成了呢，轮训吗</p><p>\3. redis是怎么实现执行操作的原子性的</p><p>\4. mysql三个日志的作用和区别</p><p>\5. mysql事务隔离级别，默认的是哪一个，每个隔离级别会产生什么问题，分别是怎么解决的</p><p>\6. 有哪些线程安全的队列（回答阻塞队列和复制队列），阻塞队列有什么用，有用过吗</p><p>\7. sync锁和lock锁的区别</p><p>\8. lock的底层实现</p><h1>猿辅导</h1><h2 id="一面-11">一面</h2><h3 id="题目1-17">题目1</h3><p>八股</p><ul><li>进程之间的通信的方式？</li><li>线程同步的方式？</li><li>阻塞&amp;非阻塞 和 同步&amp;异步 都是什么？</li><li>数据库事务的 ACID 都是怎么实现的？</li><li>使用事务的时候都要注意什么？如何做死锁避免？</li><li>分布式保证一致性的 CAP 和 BASE 理论</li></ul><p>项目</p><ul><li>为什么要用 RAG？</li><li>有做过 prompt 攻击的防范吗？</li></ul><h3 id="题目2-10">题目2</h3><p>自我介绍<br>项目询问<br>百度实习的qps、流量大小<br>怎么保证服务可用<br>怎么处理慢查询<br>介绍一下百度实习的技术难点<br>腾讯实习的一个core单子是怎么排查的<br>MIT6.824Lab里，如果切片迁移期间程序崩溃会怎么样<br>Lab怎么做的切片分配<br>怎么理解redis所谓的“单线程”<br>Redis作为缓存怎么保证一致性<br>Redis怎么持久化<br>场景题<br>一个超出内存限制的大文件怎么排序<br>了解过mapreduce吗<br>八股<br>介绍下golang的goroutine调度<br>goroutine遇到网络IO等阻塞事件会怎么样<br>介绍下golang的gc机制<br>你说gc需要stw，什么时候会暂停程序</p><h1>百度</h1><h2 id="一面-12">一面</h2><h3 id="题目1-18">题目1</h3><p>1. Redis如何实现高可用</p><p>2. 跳表查找，删除时间复杂度</p><p>3. wal log断电如何解决</p><p>4. wg.Add() 和 wg.Add(1)区别是什么</p><p>5. wg里面，一个协程挂了，如何操作： 捕获panic，recover，发送错误，结束</p><p>6. 线程新建，切换的开销体现在哪里</p><h3 id="题目2-11">题目2</h3><p>反射是啥，那些地方使用了</p><p>equals和==的区别</p><p>重写equals要注意什么</p><p>ThreadLocal、数据结构、内存泄露</p><p>B树和B+有什么区别</p><p>联合索引是什么？什么情况下会失效</p><p>手撕SQL：我记得不难，一个group+order</p><p>线程池参数有哪些？平时怎么使用的？</p><p>线程池的submit和excute有什么区别</p><p>spring声明式事务如何用？什么时候失效？</p><p>死锁是什么？怎么避免</p><p>我们要缓存一个接口的结果，key要有方法名和参数，太大了怎么办</p><p>布隆过滤器是什么，数据结构、原理</p><p>缓存穿透和缓存雪崩</p><p>垃圾回收有哪些方法</p><p>JVM的分代收集介绍一下</p><p>快排的原理？是稳定排序吗？</p><p>git怎么使用？</p><p>Stream会用吗？</p><h3 id="题目3-7">题目3</h3><p>JMM Java内存模型</p><p>mysql 索引 有哪些</p><p>排序算法有哪些</p><p>linux命令 查看进程信息命令，查看端口命令</p><p>你知道哪些设计模式，分别举例说明</p><p>三次握手</p><p>生产者消费者</p><p>垃圾回收算法</p><p>抽象类，接口，普通类的区别</p><p>重载和重写</p><p>生产者消费者的原理和过程</p><h3 id="题目4-6">题目4</h3><p>进程和线程的区别</p><p>进程间的通讯方式</p><p>线程间的通讯方式，多个服务，单服务</p><p>Linux常见命令 ，搜索等</p><p>Linux通讯命令，通讯原理是什么</p><p>tcp三次握手，为什么必须要三次</p><p>hashmap底层原理，有哪些线程安全的map</p><p>答concurrenthashmap，问底层原理，怎么加锁的</p><p>springboot启动注解是什么，内部的四个实际注解讲一下</p><p>MySQL事务，事务特性。</p><p>深挖索引，联合索引，ABC  BC  AC 怎么走索引，索引下推是什么，索引优化查询命令各个字段讲一下</p><p>拷打实习，怎么加的索引，什么情况下索引失效，举例子，做什么业务，代码库是什么，怎么上线打包部署的，全程拷打真实性和个人收获，实习做的东西也都用上了，能和面试官聊起来，感觉加分挺多的。</p><p>做题 一道sql多表联合查询，一道算法</p><h3 id="题目5-6">题目5</h3><p>自我介绍<br>介绍一下实习项目<br>如何使用乐观锁解决超卖问题的<br>乐观锁和悲观锁的区别，介绍一下<br>redis缓存穿透、缓存击穿、缓存雪崩问题及解决方案<br>在高并发场景下设计一个点赞系统<br>使用redis存储点赞数据，数据库怎么存？何时落库，落库的时候是不是也要考虑分批<br>redis数据持久化方式及区别<br>介绍单例模式的两种实现及区别<br>简单工厂模式和工厂方法模式</p><h3 id="题目6-6">题目6</h3><ol><li>自我介绍</li><li>实习拷打</li><li>怎么对mysql进行优化</li><li>怎么对十亿级别的线程和进程数据进行管理</li><li>现在都是分布式系统，怎么保证我们获取的数据是最新的</li></ol><h3 id="题目7-5">题目7</h3><ol><li>自我介绍</li><li>知道这是测开不就投？-知道，不管了</li><li>说一下你实习中的Redis缓存优化怎么做的</li><li>你怎么去测试这个</li><li>订单数据同步说一下</li><li>数据一致性怎么说</li><li>怎么测试，测试有哪些思路</li><li>策略模式取消订单，对于这个功能你会怎么测试</li><li>Redis的数据结构你知道多少，分别对应哪些场景可以使用</li><li>MySQL的事务特性</li><li>MySQL并发事务问题，隔离级别</li><li>做一道算法题–股票的最佳购买时间</li><li>写一个SQL–给定订单表（用户id、订单id、产品id，产品对应金额，购买时间），查询在今天每个用户购买每个产品的金额</li></ol><h3 id="题目8-3">题目8</h3><p>自我介绍</p><p>1.用过哪些有关并发编程以及JUC的组件</p><p>2.用过线程池吗</p><p>3.ThreadLocal的作用 项目中咋用的 不回收的后果</p><p>4.mysql索引数据结构</p><p>5.b+树叶子节点存的什么</p><p>6.回表查询</p><p>7.用过的redis数据结构</p><p>8.zset底层数据结构 除了排行榜其他的使用场景</p><p>9.项目中乐观锁的应用与实现</p><p>10.rabbitmq的消息分发</p><p>11.项目中如何用的rabbitmq</p><p>12.微服务拆分的优点</p><p>13.模板模式的用法与好处 项目中如何用的</p><p>14.用docker部署的步骤</p><h2 id="二面-3">二面</h2><p>你们用dubbo是吧？你知道netty吧？</p><p>接口幂等</p><p>kafka和RocketMQ的区别？</p><p>分布式链路追踪的原理：</p><p>Mybatis的原理、如何和mysq交互的？</p><p>count(*)和count(字段)的区别、效率</p><p>linux信号是什么：我举例kill命令</p><p>kill命令具体是干什么的</p><p>讲解一下这个题目：</p><p>用户在搜索框的时候搜索，会有提示词条，如何实现：我说前缀树等</p><p>反正就一直讨论这个搜索问题</p><h3 id="题目2-12">题目2</h3><p>mq如何防止丢失</p><p>mq如何防止重复消费</p><p>消费端如何保证消息不重复消费</p><p>redis实现分布式锁需要注意哪些？</p><p>redis 会删除错锁吗？</p><p>注解是如何实现的，原理</p><p>反射原理？在什么阶段？</p><p>lombok注解的实现原理？什么机制？在什么时候运行的？</p><p>java 数值上下界的越界，你怎么理解？long类型的上界赋值给int类型，会怎么样？</p><p>你怎么理解幂等？</p><p>你开发了一个接口，如何保证幂等</p><p>数据库的一条数据，多个线程并发修改，用canal如何保证写到es是对的呢？</p><p>加密，签名，摘要分别是什么？使用场景？摘要用的私钥还是公钥验签？</p><h3 id="题目3-8">题目3</h3><p>自我介绍<br>介绍一下最近的项目，做了什么？解决的问题，如何解决的，<br>大模型的上下文长度是有限的，如何解决的<br>大型项目还是会有很多的上下文，这种情况怎么解决<br>可不可以分步骤做？一步一步压缩上下文，<br>MCP了解多少<br>MCP server，client有没有开发过<br>AI还了解多少？还参与过什么ai项目<br>文本相似度怎么计算的？<br>POI搜索是如何实现的，可不可以使用大模型来优化一下<br>可不可以通过意图识别，找相关数据，在数据层面做好<br>计算机网络了解吗？websocket底层是怎么做的<br>广播和单播分别指什么<br>设计一个生产者消费者模型，生产者生产不同类型的消息，消费者消费自己订阅的类型的消息</p><h1>快手</h1><h2 id="一面-13">一面</h2><h3 id="题目1-19">题目1</h3><p>消息队列如何实现功能解耦和压力分散？</p><p>延迟队列是如何处理未完成任务的？</p><p>整个流程的QPS或容量预估是多少？是否有进行性能测试？</p><p>缓存与数据库的一致性如何保证（同步策略、定时任务间隔等）</p><p>JVM垃圾回收 简述JVM的垃圾回收机制（分代回收、可达性分析）？</p><p>有哪些垃圾回收算法（标记清除、标记整理等）？</p><p>不同垃圾回收器（如CMS、G1）的特点和区别？</p><p>多线程与锁 synchronized和volatile的区别？</p><p>ReentrantLock的公平锁与非公平锁实现原理？</p><p>CAS机制在锁中的应用？</p><p>集合框架 HashMap和ConcurrentHashMap的区别？</p><p>ConcurrentHashMap的分段锁机制（JDK 1.8前后变化）？</p><p>MySQL MySQL索引的底层数据结构（B+树 vs B树）？为什么选择B+树？</p><p>默认的事务隔离级别是什么？如何解决幻读问题（间隙锁）？</p><p>Redis Redis为什么比数据库快（内存操作、IO多路复用）？</p><p>Redis高可用方案（集群、哨兵模式）？</p><p>数据分片（Sharding）如何实现？节点间如何通信？</p><p>操作系统/网络</p><p>HTTP请求处理流程 从客户端发起HTTP请求到服务端响应的完整过程（DNS解析、TCP连接、报文拆解等）？</p><p>服务端架构中如何接收和处理请求（Web容器、业务逻辑分层）？</p><p>消息队列</p><p>RabbitMQ vs Kafka 为什么选择RabbitMQ而不是Kafka？两者在高并发场景下的差异？</p><h3 id="题目2-13">题目2</h3><p>1、Kafka，raft一致性协议，选举过程；</p><p>2、慢sql优化方式；</p><p>3、mysql的bufferpoll；</p><p>4、优化器按照什么指标决定走不走索引；</p><p>5、你怎么去解决深分页，其实这个感觉无法避免回表的，只是回表数据大小的问题(回id肯定比回整行数据拷贝开销低)，业务性避免吧；</p><h3 id="题目3-9">题目3</h3><p>1. 介绍仿大众点评项目的主要模块。</p><p>2. 项目难点。</p><p>3. 用户登录模块中，Redis 缓存是同步过程还是异步过程，同步过程会有什么问题，用户量大时发得慢该怎么办。</p><p>4. 若用消息队列存储验证码相关信息，消息队列的架构是什么，出现消息堆积该怎么办。</p><p>5. 增加消费者数量能否随意增加，有什么其他考虑。</p><p>6. 双重拦截器的作用，是否能在一个拦截器中实现相关逻辑，双重拦截器有什么好处。</p><p>7. 优惠券秒杀中，扣减的是数据库还是 Redis 中的数据，扣减后使用分布式锁和写入消息队列的顺序是怎样的。</p><p>8. 若写入数据库时发生异常，Redis 中已扣减的数据是否需要恢复，如何恢复，恢复操作是否会对线上产生影响。</p><p>9. 为什么在优惠券秒杀中使用 Lua 脚本，不能用 Redis 的其他数据类型（如 increment 或 decrement 计数器）的原因。</p><p>10. 预检信息包含哪些操作，能否在外部完成。</p><p>11. 若不在 Lua 脚本中实现预检资格、查询是否一人一单和扣减库存等操作，而在代码中实现，会有什么问题。</p><p>12. 一人一单的限制能否保证，若快速点击或用脚本点击两次，是否会突破限制。</p><p>13. 一人一单的限制应该在哪个环节实现。</p><p>14. 写入消息队列之前应该完成哪些操作。</p><p>15. 讲解 JVM 的相关知识，包括类加载器、运行时数据区、执行引擎等。</p><p>16. 垃圾回收算法在年轻代或老年代是如何应用的，年轻代的结构是怎样的。</p><p>17. 对 AI 有哪些了解，如何使用大模型。</p><h3 id="题目4-7">题目4</h3><p>Java的锁介绍一下</p><p>aqs原理</p><p>有哪些锁用到了aqs</p><p>cms和g1垃圾回收器有什么区别</p><p>有进行过jvm调参嘛？为什么要进行这样的调参</p><p>介绍一下spring boot的启动过程（完全不知道啊）</p><p>tcp粘包说一下，如何解决？</p><p>tcp4次挥手</p><p>数据处理</p><p>有100亿个url，怎么找到相同的url</p><h3 id="题目5-7">题目5</h3><p>1、kafka和rabbitmq 相比有哪些优缺点<br>2、kafka的延迟情况和数据丢失情况 应该怎么查看<br>3、redis的hash数据结构是什么样的？那么使用String和使用Hash的区别是什么呢？他们各自的优缺点是什么呢？<br>4、redis的缓存穿透、击穿、雪崩是什么问题，如何解决？<br>5、redis 缓存一致性，如何在大量数据的情况下做一致性处理？<br>6、CompletableFuture的底层原理（还是有点不太熟悉）<br>7、CompletableFuture内存泄漏的问题（这一块 又吃了没看源码的亏）<br>8、ThreadLocal的内存泄漏的问题<br>9、mysql的持久性是如何实现的<br>10、mysql中undolog redolog中的区别有哪些<br>11、常见的OOM情况，如何解决（这里说的是读取大量Excel数据的情况）</p><h3 id="题目6-7">题目6</h3><p>JAVA</p><p>1、反射的原理，应用场景，哪些场景不能使用反射？自定义一个注解需要定义哪些方面的信息</p><p>2、线程的生命周期，各个状态之间的转变通过哪些语句？保证线程安全的方式及优缺点？ThreadLocal会导致什么问题？</p><p>3、JAVA中的锁有几种方式？同步锁原理及申请流程、可重入锁原理及申请流程</p><p>4、MYSQL事务的隔离级别，分别会导致什么问题？如何在MYSQL中查询隔离级别</p><p>5、MYSQL主从同步机制</p><p>6、Redis持久化机制、AOF文件重写、Redis宕机重启后，什么机制保证其快速恢复？</p><p>SPRING</p><p>1、IOC、AOP、bean的实例化流程。IOC中如何解决循环依赖</p><p>1、使用过什么消息队列？怎么确保一个消息发送成功？</p><p>2、介绍实习项目的背景、技术架构、负责的内容。使用了哪些中间件？</p><p>3、怎么使用分布式锁？怎么设置锁的key，拿锁成功和拿锁失败对于下游业务的影响，怎么保证幂等性</p><p>4、怎么设置限流参数，阈值等？</p><p>5、在项目中做了什么优化手段，最终拿到了什么结果？</p><h3 id="题目7-6">题目7</h3><p>mysql索引结构，b+树查询的时间复杂度，建立索引的原则？<br>什么是AOP？什么是动态代理？<br>什么是注解？注解是怎么起作用的？<br>什么是反射？什么时候会用到反射？<br>java的内存模型是什么样的？栈是用来干什么的？<br>什么是设计模式？你了解哪些？<br>实现单例模式的时候有什么需要注意的？为什么要做双重校验？什么时候会用到单例模式？</p><h3 id="题目8-4">题目8</h3><p>1、自我介绍</p><p>2、项目一拷打（10min）</p><p>3、Java中线程池任务提交的流程是怎样的？</p><p>4、线程池的拒绝策略有哪些？</p><p>5、提交到任务队列的任务，它的消费策略是怎样的？</p><p>6、如果是无界队列，还需要非核心线程吗？</p><p>7、无界队列存在什么问题？一般在什么场景下使用无界队列？</p><p>8、谈谈 Java 里面锁消除和锁升级</p><p>9、synchronized 可重入吗？能保证可见性吗？</p><p>10、某个服务 CPU 利用率到 100% 了，如何排查？</p><p>11、如果是 OOM 了怎么排查？</p><p>12、自己有用过 jmap 和一些工具去排查过错误吗？</p><p>13、MySQL 有几种事务隔离级别？从低到高说</p><p>14、什么是幻读？</p><p>15、MySQL 是怎么去解决幻读问题的？</p><p>16、谈谈 Kafka</p><p>17、为什么项目中技术选型用的是 RabbitMQ？</p><p>18、RabbitMQ 的数据持久化是怎么做的？</p><p>19、线程和进程的区别？</p><p>20、线程的安全怎么保证？</p><p>21、进程通信的方式有哪些？</p><p>22、进程间通信，它的数据传输大概是怎样的流程？怎么能让数据从一个进程传递到另一个进程去？</p><p>23、Redis 常用的数据结构有哪些？</p><p>24、谈谈 ZSet 的具体实现？为什么数据规模大的时候采用跳表而不是压缩列表？</p><p>25、查一个有序集合里面元素的个数，复杂度是多少？命令是什么？</p><p>26、取有序集合某个元素的分数，命令是什么？复杂度是多少？</p><h3 id="题目9-3">题目9</h3><p>\1. ThreadLocal的原理和存在的问题<br>\2. ThreadLocal在Spring当中的应用<br>\3. ThreadLocalMap和HashMap的区别（hash方法不同，设计原因角度出发）<br>\4. 线程池的使用，核心参数设计<br>\5. 如何根据业务需求动态修改线程池参数<br>\6. 动态线程池实现原理<br>\7. 对比Zookeeper和Redis实现分布式锁的优劣（CP vs AP、是否引入新组件）。<br>\8. 阐述设计一个Redis分布式锁需要考虑的关键问题（死锁、锁超时、释放锁的原子性、owner验证）。<br>\9. 追问如何评估Redis锁的超时时间（看门狗机制、压测）。<br>\10. 阐述一次慢SQL优化的完整过程：从发现问题（Oncall告警）到定位（Explain分析），再到解决（调整where条件利用联合索引的最左前缀原则）。</p><h3 id="题目10-3">题目10</h3><p>线程池？线程池的生命周期？什么时候转换？</p><p>jdk8版本及以后哪些新特性你用过？什么帮助？</p><p>对反射的理解？反射的缺点？什么时候用什么时候不用？</p><p>注解，结合经历说？</p><p>说说一些框架中的注解？</p><p>Spring如何扫描到注解的？详细说说流程？</p><p>bean的实例化流程？</p><p>Spring如何解决循环依赖？详细说说</p><p>介绍一下线程的状态和流转？</p><p>线程池核心参数和执行流程？</p><p>实现一个简单的线程池需要注意什么？</p><p>mysql的数据库隔离级别？解决的问题？</p><p>用什么语句可以尽快测出隔离级别？</p><p>mysql的主从同步？</p><p>主从同步有哪些模式，如何确认是否完毕？</p><p>常用的数据库版本mysql用的什么方式？</p><p>设置了索引但没生效，原因？</p><h3 id="题目11-2">题目11</h3><p>1、自我介绍</p><p>2、项目一拷打（10min）</p><p>3、Java中线程池任务提交的流程是怎样的？</p><p>4、线程池的拒绝策略有哪些？</p><p>5、提交到任务队列的任务，它的消费策略是怎样的？</p><p>6、如果是无界队列，还需要非核心线程吗？</p><p>7、无界队列存在什么问题？一般在什么场景下使用无界队列？</p><p>8、谈谈 Java 里面锁消除和锁升级</p><p>9、synchronized 可重入吗？能保证可见性吗？</p><p>10、某个服务 CPU 利用率到 100% 了，如何排查？</p><p>11、如果是 OOM 了怎么排查？</p><p>12、自己有用过 jmap 和一些工具去排查过错误吗？</p><p>13、MySQL 有几种事务隔离级别？从低到高说</p><p>14、什么是幻读？</p><p>15、MySQL 是怎么去解决幻读问题的？</p><p>16、谈谈 Kafka</p><p>17、为什么项目中技术选型用的是 RabbitMQ？</p><p>18、RabbitMQ 的数据持久化是怎么做的？</p><p>19、线程和进程的区别？</p><p>20、线程的安全怎么保证？</p><p>21、进程通信的方式有哪些？</p><p>22、进程间通信，它的数据传输大概是怎样的流程？怎么能让数据从一个进程传递到另一个进程去？</p><p>23、Redis 常用的数据结构有哪些？</p><p>24、谈谈 ZSet 的具体实现？为什么数据规模大的时候采用跳表而不是压缩列表？</p><p>25、查一个有序集合里面元素的个数，复杂度是多少？命令是什么？</p><p>26、取有序集合某个元素的分数，命令是什么？复杂度是多少？</p><h3 id="题目12-2">题目12</h3><p>1.自我介绍</p><p>2.挑最熟悉的项目讲，讲一些技术选型，对比redis实现的消息队列和kafka有什么区别</p><p>3.redis list底层数据结构</p><p>4.redisson怎么实现</p><p>5.redis实现分布式锁用什么命令</p><p>6.Java有哪些锁</p><p>7.reentrrantlock实现原理，为什么用CAS</p><p>8.reentrrantlock用了什么设计模式?</p><p>9.项目中的AI聊天为什么用websocket，不用HTTP？</p><p>10.进程和线程什么区别？</p><p>11.进程调度算法有什么？</p><p>12.虚拟内存的好处？</p><p>13.页表置换算法有哪些？</p><p>14.页表置换算法具体举例</p><h3 id="题目13-2">题目13</h3><p>. 你在实习的时候主要做了什么，介绍一下<br>\2. 实习经历拷打，问题延伸，非常深入，难绷…实习生几个月怎么可能把几年的代码库全部掌握…<br>\3. 拷打起手：<br>\1. 唉，我问一下哈…<br>\2. 比如说：…<br>\3. 然后开始拷打延伸<br>\4. 提出一些假设的case，如何解决？<br>\5. 你实习的时候主要做了什么，介绍一下<br>\6. C端请求的整体链路、QPS、RT、量级<br>\7. 锁到底是主线程抢占的，还是子线程进行抢占的？<br>\8. CompletableFuture在执行过程中，如果线程池的等待队列满了，你该怎么处理？<br>\9. 各个拒绝策略的适用场景是什么？<br>\10. 有些拒绝策略会丢请求，如果说不需要丢请求，并且对要丢的任务进行记录，怎么处理？<br>\11. AOP你用来写什么的？<br>\12. 讲一下@Transaction的底层实现，参数一般怎么用呢？事务传递属性了解吗？</p><h2 id="二面-4">二面</h2><h3 id="题目1-20">题目1</h3><p>1. 介绍仿大众点评项目的详细内容，包括学到的东西、难点、重点。</p><p>2. 详细描述一次C端用户登录行为在系统背后的完整数据链路，每一步系统要做什么、存储在什么地方。</p><p>3. 验证码存储在Redis中的key是什么。</p><p>4. 用户再次登录时，前端是否做防刷或重复登录验证，还是依赖短信验证码。</p><p>5. 验证码发送在系统后台的操作流程。</p><p>6. 用户登录态如何维持。</p><p>7. 为什么要返回TOKEN，能否返回手机号。</p><p>8. TOKEN在浏览器端存储在什么地方。</p><p>9. 将TOKEN存到authorization字段的原因。</p><p>10. authorization是header还是body字段。</p><p>11. 双重拦截器拦截的内容，以及从什么地方取TOKEN。</p><p>12. 从Redis中取TOKEN的key是什么。</p><p>13. ThreadLocal中存储的是什么。</p><p>14. ThreadLocal的定义是什么。</p><p>15. ThreadLocal的生命周期是什么。</p><p>16. 用户发起HTTP请求时线程是创建还是复用。</p><p>17. 在post handler中remove ThreadLocal的原因。</p><p>18. 已登录用户后续操作是否需要更新ThreadLocal。</p><p>19. 拦截器拦截的请求类型及作用。</p><p>20. 分布式系统中，用户请求路由到不同机器时是否需要重新登录。</p><p>21. ThreadLocal存在的必要性，能否用其他东西替代。</p><p>22. ThreadLocal的优点是什么。</p><p>23. ThreadLocal设置的生命周期或服务的生命周期是什么。</p><p>24. postHandler的调用时机。</p><p>25. 声明线程的方法有哪些。</p><p>26. 线程池的核心参数及各自作用。</p><p>27. 等待队列是否越长越好。</p><p>28. MySQL事务的隔离级别及各自举例。</p><p>29. Redis的数据结构及各自特性和适用场景。</p><p>30. 最近在学习的内容及大模型相关学习情况。</p><h2 id="三面-2">三面</h2><h3 id="题目1-21">题目1</h3><p>索引构建有什么用，底层是怎么做的</p><p>httpclient 如何设置连接池，设置参数后 httpclient 底层是怎么做的，用了什么数据结构</p><p>为什么操作系统需要虚拟内存，一个 32 位系统里有物理内存 2G，对应的虚拟内存应该有多大？为什么一共就 2G 物理内存，通过虚拟内存技术之后，可以给应用程序提供 4G 内存，多出来的 2G 哪里来的，</p><p>假设要写一个网络爬虫，这个爬虫里面有一个功能，想快速的判断一个 URL 地址它之前有没有被爬过。用什么样的数据结构会比较合适？</p><h1>拼多多</h1><h2 id="一面-14">一面</h2><h3 id="题目1-22">题目1</h3><p>一、Java基础与JVM（6题）</p><p>HashMap扩容时链表转红黑树的阈值为什么是8？退化为6的原因？</p><p>synchronized锁升级过程？</p><p>G1垃圾回收器如何预测停顿时间？Region大小如何设置？</p><p>volatile能否保证数组元素的可见性？如何解决？</p><p>ThreadLocal内存泄漏的根本原因？JDK改进方案？</p><p>Java 8中Stream的并行处理原理？ForkJoinPool工作窃取机制？</p><p>二、并发编程（5题）</p><p>AQS中为什么用CLH队列而不用普通链表？</p><p>线程池核心参数设置规则？美团动态调整方案？</p><p>ConcurrentHashMap的size()方法为何不精确？替代方案？</p><p>如何用CAS实现一个无锁栈？ABA问题如何规避？</p><p>CompletableFuture如何实现多个异步任务依赖执行？</p><p>三、数据库与Redis</p><p>MySQL索引失效的10种场景？最左前缀原则的底层原理？</p><p>十亿级订单表如何优化分页查询？</p><p>Redis大Key删除导致集群崩溃，如何避免？</p><p>Redis事务与MySQL事务的ACID区别？</p><p>缓存与数据库一致性方案对比？拼多多秒杀采用哪种？</p><p>Redis Cluster的slot迁移过程会阻塞请求吗？</p><p>MySQL死锁排查步骤？如何用gap锁解决幻读？</p><p>四、分布式与微服务（6题）</p><p>TCC事务的Confirm阶段失败怎么办？</p><p>如何设计一个支撑百万QPS的分布式ID生成器？</p><p>Nacos如何实现配置动态推送？长轮询原理？</p><p>RocketMQ如何保证消息不丢失？</p><p>Dubbo的泛化调用使用场景？如何实现服务降级？</p><p>CAP理论在拼多多购物车中的取舍？</p><p>五、系统设计（4题）</p><p>设计拼多多砍价系统，如何防止刷单？</p><p>订单超时未支付自动关闭，如何实现？</p><p>如何设计一个实时热卖排行榜？</p><p>分布式锁在库存扣减中的应用，Redisson实现原理？</p><h3 id="题目2-14">题目2</h3><p>\1. 自我介绍<br>\2. 实习亮点<br>\3. Java线程池类型，应用场景<br>\4. 线程池怎么进行线程回收的<br>\5. 为什么要用线程池<br>\6. 说说RPC是什么<br>\7. 设计RPC框架有哪些要点<br>\8. 常用的序列化方式<br>\9. 为什么要进行序列化<br>\10. 写题：二叉树后序遍历（非递归）<br>\11. List<Integer> list = new ArrayList&lt;&gt;()发生了哪些内存分配<br>\12. 操作系统是怎么进行递归的<br>\13. 为什么要有多态<br>\14. 多态父类表现出子类的行为，运行时是如何实现的呢<br>\15. Java泛型是怎么实现的<br>\16. Java为什么要用泛型擦除，为什么不像c++一样<br>\17. <code>sout( &quot;Hello World!”)</code> 运行过程。字符串是怎么打印到屏幕上的<br>\18. 为什么要有内核态<br>\19. 从操作系统层面分析<code>java -jar xxx.jar</code> 是怎么运行的，在操作系统层面的可执行文件是什么<br>\20. Java和JVM的关系<br>\21. Java和Python有什么区别（答了JIT）<br>\22. 算法：找到一个具有最大和的连续子数组<br>\23. 介绍一下AOP<br>\24. 怎么指定AOP生效的地方<br>\25. Java中注解是怎么生效的<br>\26. 谁去扫描注解的<br>\27. 介绍一下IOC<br>\28. 介绍一下MQ<br>\29. MQ有什么特性</p><h2 id="三面-3">三面</h2><h3 id="题目1-23">题目1</h3><p>\1. 自我介绍<br>\2. 你们的RPC框架用的是什么，了解底层实现吗<br>\3. 线程池的参数、底层的运行原理<br>\4. 设计一个无锁的工作队列<br>\5. 有了解服务的GC<br>\6. G1和ZGC<br>\7. 如何防止一个服务过载（答了监控、限流、熔断）<br>\8. 知道堆外内存吗，什么时候会用到堆外内存<br>\9. c++了解吗<br>\10. 二叉树的后序遍历-非递归</p><h1>京东</h1><h2 id="一面-15">一面</h2><h3 id="题目1-24">题目1</h3><p>1.项目介绍</p><p>2.spingboot做了什么事情</p><p>3.sql怎么优化，mysql怎么优化</p><p>4.bean注入有哪些方式</p><p>5.auto wire注解的原理，spring怎么做到加载有这个注解的对象</p><p>6.mybatis能不能直接new一个dao 接口的对象，怎么做？拦截器功能原理，使用场景</p><p>7.接口性能问题怎么看，怎么分析哪个阶段有问题</p><p>8.mysql的三种日志介绍一下</p><p>9.发生宕机redolog和binlog怎么协调作用的</p><p>10.宕机后怎么恢复数据，一条数据怎么确定回滚还是恢复</p><p>11.生产问题定位，平时怎么做的</p><p>12.线程池执行过程</p><p>13.g1回收器跟cms 相比，各自适合什么场景</p><p>14.使用的什么检验的框架，原理是什么</p><p>15.mysql索引为什么快</p><h3 id="题目2-15">题目2</h3><p>做项目遇到的问题和解决方法</p><p>有没有用到多线程的东西，ThreadLocal</p><p>线程池参数怎么设置的</p><p>如何保证线程安全</p><p>synchronized 和 ReentrantLock 区别</p><p>Java 并发类有哪些</p><p>ConcurrentHashMap原理</p><p>redis 常用数据结构及底层实现</p><p>zset 跳表</p><p>缓存击穿、穿透、雪崩</p><p>击穿、穿透区别在哪</p><h3 id="题目3-10">题目3</h3><p>1、自我介绍+实习项目</p><p>2、Spring AOP原理是什么，Java的反射和代理有哪几种</p><p>3、BeanFactory和FactoryBean的区别是什么</p><p>4、ES的倒排索引是如何实现的</p><p>5、除了简历上的项目，还有其他项目可以介绍一下吗？</p><p>6、Mysql的间隙锁是什么</p><p>7、了解哈希索引吗？为什么innoDB不采用哈希索引</p><p>8、了解哈希冲突吗？ 处理哈希冲突的方法有哪些？</p><p>9、 为什么HashMap 不采用ThreadLocalMap解决哈希冲突的方法（开放寻址法）</p><p>10、如果要想实现可以按put的顺序遍历HashMap，要怎么实现呢？那如果要想改变其中的顺序呢？</p><p>11、 java的可重入锁是如何实现的？</p><p>12、 如果想实现可重入的分布式锁要如何实现呢？</p><p>13、对于树的三种遍历方式，分别有什么用途？</p><p>14、了解JVM的内存模型，大概介绍一下？</p><p>15、实例对象都是在堆上分配吗？（我提到了可以在栈上分配）</p><p>16、那有哪些对象是可以直接在栈上分配呢？—</p><h3 id="题目4-8">题目4</h3><p>1、自我介绍</p><p>2、电脑上有没有生产环境</p><p>3、项目的难点和解决思路以及你的收获</p><p>4、ES的原理（这个没有很理解问的意思</p><p>5、分布式锁、redisson的实现</p><p>6、Redis数据结构</p><p>7、JUC的syn和可重入锁</p><p>8、JVM+GC</p><p>9、MySQL的使用场景，MySQL的使用经验，</p><p>10、聚集索引和非聚集索引</p><p>11、B+树</p><p>12、事务ACID和隔离级别</p><p>13、乐观锁、悲观锁</p><p>14、为什么有spring，springboot的优势，用了spring全家桶的哪些</p><p>15、spring的AOP、spring其他的设计模式</p><h3 id="题目5-8">题目5</h3><p>查一张学生表，表里有学生名字，如何查出学生名字中哪些是重复的？<br>缓存的过期策略有哪些？<br>后端一直更新数据，前端一直查缓存，在更新的间隙，缓存是空的，导致缓存穿透，怎么解决？<br>有没有别的思路可以解？比如通过全局的乐观锁？<br>创建多线程会用哪些方法创建？<br>了解completable future 吗？</p><h3 id="题目6-8">题目6</h3><ol><li>面试官介绍了下岗位</li><li>自我介绍</li><li>现在实习的地方，有留用机会吗？</li><li>拷打项目一（10分钟）</li><li>本科不是计算机，怎么跨考上的？当时怎么准备的？</li><li>考研学专业课时，碰到过什么困难吗？怎么解决的？</li><li>用户登录为啥用 Spring Session 来管状态？它内部是怎么跑的？</li><li>密码用 MD5+盐值 来校验，有啥风险吗？</li><li>现在让你重新设计密码加密存储，你会怎么做？</li><li>数据万象服务是干嘛的？项目里怎么用的？</li><li>如果要实现图片搜索，比如搜“小狗”，就能找出所有带小狗的图片，你会怎么设计？</li><li>什么场景下需要用多级缓存？</li><li>怎么保证多级缓存和数据库的一致性？项目里是怎么做的？</li><li>用 WebSocket 做多人协作编辑，假如有 100 个人同时改一张图，怎么设计才能避免操作互相覆盖？</li><li>你提到加锁，具体怎么加？用 Redis 还是别的？锁什么？锁的粒度多大？</li><li>加锁会让其他用户干等着，没法操作，这块怎么优化？</li><li>平时除了项目，还学了啥新技术吗？</li><li>你觉得用什么锁来控制虚拟线程比较好？</li><li>最近一年用过哪些 AI 编程工具？</li><li>看你一直在一个地方生活学习，以后想去哪工作？</li></ol><h3 id="题目7-7">题目7</h3><p>. 实习期间学到了什么，结合项目介绍一下<br>\2. mysql和redis的一致性如何做<br>\3. 如果不订阅binlog，还能保证一致性吗？<br>\4. 什么场景会出现数据库和缓存不一致<br>\5. zset的底层是怎样的<br>\6. 跳表为什么快<br>\7. redis原生的锁是用什么命令，流程是怎样的，如何释放锁，里面参数都是什么<br>\8. 什么时候会出现当前线程的锁被其他线程解锁？ （不会）<br>\9. redis持久化<br>\10. 需要实现百万qps的系统，功能是实时排行榜，查询量很大，实时更新，可以理解为微博排行榜，怎么实现？<br>\11. DDD架构讲解一下<br>\12. kafka的topic和partition的关系<br>\13. partition越多越好吗<br>\14. 想实现顺序的消费，生产者发出来的消息是顺序的，一个partition，多个消费者，怎么实现？<br>\15. kafka怎么保证消息不丢失？<br>\16. 如何解决java浮点数丢失的问题<br>\17. 多线程的场景题：主线程执行到一半的是要开始10个子线程，子线程执行完之后主线程在执行，怎么实现<br>\18. completableFuture的实现原理<br>\19. countdownlatch的原理<br>\20. 自己实现一个线程安全的计数器，怎么实现？<br>\21. 场景题：电商大促，负责秒杀，通过线程池实现，怎么设置核心参数<br>\22. 实现功能：写个sql，给一张订单表，至少有订单id，userId，createTime，筛选出昨天下单的用户是近一年第一次下单的用户，怎么实现<br>\23. 索引相关，联合索引A，B，C，where a &gt; ? and b = ? c != ?，怎么走</p><h3 id="题目8-5">题目8</h3><p>1.Future和CompletableFuture区别，Future有回调吗，除了forkjoin线程池，还知道什么线程池？项目里用的什么线程池，线程池流程<br>2.零拷贝底层原理，select/poll/epoll各自优化点，各阶段是否阻塞<br>3.kafka底层咋样，和rocketMQ区别，为啥rocketMQ不用零拷贝（沉默了十秒），消息队列日志，broker啥的<br>4.redis单线程体现在哪，有什么优势<br>5.介绍了一下cola4架构，防腐层<br>6.在实习公司用过dubbo吧？服务发现、负载均衡怎么实现的，函数式调用咋连接的？（我只知道架构长啥样，不懂原理啊<br>7.实习参与了一个月的业务迭代，能独立完成需求评审-开发-上线了吧？我不知道啊)<br>8.应用发布时，监控哪些指标<br>9.挑一个业务迭代讲讲<br>10.联合索引失效的场景</p><h3 id="题目9-4">题目9</h3><p>\1. 部门是干什么的？<br>\2. 介绍实习的一个项目<br>\3. 介绍一下自己的项目<br>\4. 说说lua脚本是怎么保证原子性的？<br>\5. 为什么Redis这么快<br>\6. redis主从节点如何同步<br>\7. 客户端与服务端有connect函数，如果IP写错和端口号写错，二者在程序反应上有什么区别？为什么？<br>\8. 了解僵尸进程吗？<br>\9. 了解管道的机制吗？<br>\10. 执行管道命令之后操作系统内部会做哪些处理？<br>\11. 为什么TCP连接要三次，但是断开要四次？</p><h3 id="题目10-4">题目10</h3><p>\1. AIO、BIO、NIO 分别是啥？有啥区别？</p><p>\2. 抽象类和普通类有啥区别？</p><p>\3. 讲讲 HashMap 的扩容机制，还有 ConcurrentHashMap 的原理和线程安全是怎么保证的？</p><p>\4. 线程池的核心参数有哪些？设置时要考虑什么？</p><p>\5. 注解的实现原理是啥？</p><p>\6. 一个类调用自己内部类上的注解，这个注解会生效吗？</p><p>\7. 介绍几种常见的设计模式？</p><p>\8. 常见的垃圾回收器有哪些？各自有什么特点？</p><p>\9. 遇到高并发页面访问，有哪些解决方案？</p><h1>虾皮</h1><h2 id="一面-16">一面</h2><h3 id="题目1-25">题目1</h3><p>2. 讲一下xxl-job的架构与实现原理(实习有xxljob)</p><p>3. xxl-job怎么保证每一个实例的任务只调用一次</p><p>4. 算法题:用栈实现队列，说思路</p><p>思路:用两个栈，判断第一个栈是否为空，为空将第一个栈的所有元素转移到第二个栈，否则弹出最上层的元素</p><p>5. 算法题:一篇文章找出使用频率最高的k个单词</p><p>思路:使用一个HashMap存储每个单词出现的频率，转换成结构体，然后再建堆，再堆排序</p><p>6. topk拓展:建堆的时间复杂度是多少？</p><p>7. topk拓展:堆排序的时间复杂度是多少?</p><p>8. topk拓展:你这样不会有点慢嘛，还有更优解嘛？</p><p>9. 数组和链表在数据结构上的区别是什么？</p><p>10. 数组和链表的使用场景有什么区别？</p><p>11. 了解哪些MySQL存储引擎</p><p>12. InnoDB引擎有什么特性</p><p>13. 索引是数据结构是什么，有什么特点？</p><p>14. MySQL有哪些锁</p><p>15. MySQL的事务四大特性是什么</p><p>16. MySQL的隔离级别是有哪些</p><p>17. MySQL默认隔离级别是？</p><p>18. RR和RC的区别是什么？</p><p>19. 可重复读什么时候能解决幻读，什么时候不能？</p><p>20. TCP协议怎么保证可靠性？ 三次握手四次挥手、流量控制、拥塞控制</p><p>21. 讲讲流量控制怎么做的</p><p>22. 拥塞控制算法有哪些？</p><p>23. TCP粘包是什么</p><p>24. 怎么解决TCP粘包？</p><p>25. 如果我的TCP里面就有换行符该怎么解决</p><p>26. 进程之间的通信机制有哪些</p><p>27. 进程、线程、协程之间的区别</p><p>28. 线程有独立的内存空间嘛？</p><p>29. Redis有哪些数据结构</p><p>30. ZSet的底层实现是什么数据结构</p><p>31. 跳表的实现原理是什么？</p><p>32. 跳表插入一条数据的具体实现是什么</p><h3 id="题目2-16">题目2</h3><p>1. java的内存模型</p><p>2. 数据库优化，sql优化</p><p>3. 消息队列有什么作用，kafka在项目中有什么作用</p><p>4. 2个topic， 一个group消费者组，一个topic 异常rebalance， 另一个会受影响吗？</p><p>5. 讲一下mysql的redo log、binlog、undo log，</p><p>6. mysql崩溃以后恢复流程？mysql崩溃之后未提交的事务怎么办？</p><p>7. B+数主键索引和非主键区别</p><p>8. inplace DDL(不会)</p><p>9. RPC框架中，怎么做链路追踪</p><p>10. 网页中输入网址的流程变化</p><p>11. tcp与udp区别</p><p>12. go 的协程和java的线程区别</p><p>13. go多协程和java多线程 同时读写，共享资源 处理 方式一样吗</p><p>14. java 的线程与内核线程， go的协程与线程的 映射方式一样吗？（1:1，n:m）</p><h3 id="题目3-11">题目3</h3><p>1.可以讲讲用户从发送请求url之后会发生什么吗 ✘</p><p>介绍了一下SpringMVC的流程，从url到DispatcherServlet再到各个处理器部件等</p><p>实际上面试官是想问从网络通信层面上它们发生了什么</p><p>回复不太清楚，只介绍了一下域名通过DNS解析成IP然后请求到后端服务器</p><p>2.了解cookie和session吗 ✘</p><p>答的很不好，因为自己只学了JWT和token完全没想到会问这块，只答出前者存储在客户端后者存储在服务端</p><p>3.了解MySQL中的事务隔离级别吗，它们分别解决哪些问题，具体讲 ✔</p><p>4.学过哪些排序算法？✔</p><p>冒泡，二分，快排</p><p>5.MySQL中索引的数据结构？讲讲优势和为什么✔</p><p>6.Redis常见架构✔</p><p>7.了解正排索引和倒排索引吗✘</p><p>答不太清楚只知道es库中通过倒排索引建表实现较高的搜索效率</p><p>8.手撕，反转链表✔</p><p>9.延迟队列是什么，了解底层实现吗✘</p><p>回答了xdelayed延迟队列的基本应用场景和概念，底层实现不知道</p><p>10.AMQP中消息可靠性原理✔</p><p>11.你项目中的推荐功能是怎么实现的</p><p>简单讲了一下调用了分词器和向量模型的API将库中视频基于标题分到我给出的聚类中</p><h3 id="题目4-9">题目4</h3><p>1. 自我介绍<br>2. 你常用哪个 JDK 版本？<br>3. 选一个你熟悉的项目，说说它配了什么垃圾回收器？<br>4. 描述一下 CMS 的回收流程及每个阶段的作用。<br>5. CMS 有哪些阶段会 Stop-The-World？<br>6. 新生代和老年代的划分机制是什么？<br>7. 对象从新生代晋升到老年代的条件有哪些？<br>8. 说说 AOP 的最基本实现方式。<br>9. Spring AOP 生成代理的两种场景/方式分别是什么？<br>10. 你在项目里用过微服务吗？用的什么技术栈？<br>11. 有做过哪些 MySQL 调优？举一个具体例子。<br>12. 当时如何定位到这条慢 SQL？用了哪些工具或命令？<br>13. 解释 Explain 结果中哪些字段说明索引未生效。<br>14. Redis 持久化有哪些可选策略？<br>15. RDB 与 AOF 各自有哪些刷盘/触发方式？<br>16. 如果要求“不丢数据”或“高性能”分别怎样配置？<br>17. TCP 四次挥手中 TIME_WAIT 状态的含义是什么？<br>18. 为什么需要等待 2MSL 才能进入 CLOSED？<br>19. 你在项目里用过 CompletableFuture 吗？<br>20. 它与 Future / Task 组合相比有什么优势？<br>21. 如果异步链路里包含数据库事务，事务回滚会不会有问题？为什么？<br>22. 线上 Linux 服务器常用命令熟悉吗？<br>23. 如何在文件里查找关键字？<br>24. 如何查找某个文件？</p><h3 id="题目5-9">题目5</h3><p>上来先写两句SQL</p><p>给了一个学生表</p><p>1.两个字段不重复，重复的话就无法插入，建立合适的索引</p><p>2.获取表中录取学生人数第二多的公司，要求公司录取学生的人数至少大于3</p><p>表设计的一些考量、索引建立的一些考量</p><p>sql优化在工作中遇到的一些实例。</p><p>一道题：</p><p>尽快实现亿级别数据的求和。</p><p>八股：</p><p>redis为什么快？</p><p>Java的一些设计原则</p><h3 id="题目6-9">题目6</h3><p>消息队列如何实现功能解耦和压力分散？</p><p>延迟队列是如何处理未完成任务的？</p><p>整个流程的QPS或容量预估是多少？是否有进行性能测试？</p><p>缓存与数据库的一致性如何保证（同步策略、定时任务间隔等）</p><p>​</p><p>JVM垃圾回收 简述JVM的垃圾回收机制（分代回收、可达性分析）？</p><p>有哪些垃圾回收算法（标记清除、标记整理等）？</p><p>不同垃圾回收器（如CMS、G1）的特点和区别？</p><p>多线程与锁 synchronized和volatile的区别？</p><p>ReentrantLock的公平锁与非公平锁实现原理？</p><p>CAS机制在锁中的应用？</p><p>集合框架 HashMap和ConcurrentHashMap的区别？</p><p>ConcurrentHashMap的分段锁机制（JDK 1.8前后变化）？</p><p>​</p><p>MySQL MySQL索引的底层数据结构（B+树 vs B树）？为什么选择B+树？</p><p>默认的事务隔离级别是什么？如何解决幻读问题（间隙锁）？</p><p>Redis Redis为什么比数据库快（内存操作、IO多路复用）？</p><p>Redis高可用方案（集群、哨兵模式）？</p><p>数据分片（Sharding）如何实现？节点间如何通信？</p><p>操作系统/网络</p><p>HTTP请求处理流程 从客户端发起HTTP请求到服务端响应的完整过程（DNS解析、TCP连接、报文拆解等）？</p><p>服务端架构中如何接收和处理请求（Web容器、业务逻辑分层）？</p><p>消息队列</p><p>RabbitMQ vs Kafka 为什么选择RabbitMQ而不是Kafka？两者在高并发场景下的差异？</p><h3 id="题目7-8">题目7</h3><p>​\1. 从浏览器输入URL到返回内容的完整过程<br>\2. 用大模型服务器的网络通信关键点是什么（猜想想问的是输出的流式stream是怎么体现的，怎么实现的服务端主动推送，长链接。）<br>\3. ThreadLocal是什么？如何避免并发安全问题？<br>\4. ThreadLocal如何避免内存泄漏？（jdk设置的自救机制，finally块中主动释放）<br>\5. 接口响应慢如何排查？ 系统层面考虑 cpu和内存层面考虑<br>\6. 联合索引的存储结构是怎样的？<br>\7. 索引的优缺点？<br>\8. 数据量大时如何分库分表？ （如何考虑什么时候分表，什么时候分库）<br>\9. 如何安全地删除Redis中的大Key（一个几千万数据的List）？<br>\10. 10亿无重复数据，如何快速、随机、等分成10份？<br>\11. 一个文件从磁盘读出，通过网络发出，内存经过几次拷贝？（考察零拷贝之类的）<br>\12. CPU执行代码的整个过程是怎么样？</p><h3 id="题目8-6">题目8</h3><p>1.innodb 和 myisam<br>2.tcp四次挥手，time_wait之后要等多久，为什么<br>3.https 加密过程<br>4.zset底层实现，redis用过哪些数据结构<br>5.bitmap用过吗<br>6.hyperlog用过吗<br>7.linux查看连接的命令<br>8.redis持久化，rdb和aof区别？<br>9.mysql主从同步怎么做<br>10.binlog重放是并行的还是串行的？会出现什么问题<br>11.主从同步什么情况下会丢数据<br>12.redis的事务？和mysql事务的区别</p><h3 id="题目9-5">题目9</h3><p>1.自我介绍</p><p>2.介绍实习项目，引申一些八股和场景题</p><p>3.jvm内存结构，栈里面放什么东西？</p><p>4.new一个对象具体做了哪些事？</p><p>5.垃圾回收器cms过程是怎么样的？</p><p>6.垃圾回收算法有哪些？</p><p>7.g1回收器怎么建立可预测的停顿时间模型？</p><p>8.Mysql 锁有哪些？MVCC如何实现？日志有哪些？</p><p>9.B+树的结构？和b树的区别？索引的原理？</p><p>10.联合索引a,b,c，判断sql有无走索引</p><p>11.redolog具体怎么保证持久化的？</p><p>12.了解哪些设计模式？</p><p>13.简单工厂和工厂模式的区别</p><p>14.单例模式分为哪些？</p><h3 id="题目10-5">题目10</h3><p>1.自我介绍<br>2.问了下哪段实习对你提升最大，技术等等的提升、实习的业务和简历上写的限流<br>3.springboot比较好的一个方面是它有注解的一个方式去管理一些实例，这种思路解决了什么问题（面试官提示说循环依赖，没听说过!)<br>4.Java里面是怎么解决的？就垃圾回收那块（可能面试官想问Java垃圾回收是怎么解决循环依赖的，我理解成问垃圾回收器了<br>5.java的注册发现用什么？可以定制一些算法吗？<br>6.怎么发现服务的？比如服务有两台，那请求是第一台还是第二台<br>7.中间应该还问了些问题，忘记了</p><h3 id="题目11-3">题目11</h3><p>\1. 实习经历<br>1.1 队列选型的依据是什么<br>1.2 下游异常除了告警还能怎么做<br>\2. 快速排序的时间复杂度和空间复杂度<br>\3. 网络IO模型有哪些<br>\4. select和epoll的区别<br>\5. epoll水平触发和边缘触发的区别<br>\6. 分布式锁的实现方式<br>\7. mysql实现分布式锁怎么解决锁占用不释放<br>\8. 缓存三剑客<br>\9. 公司年会入场券抽票，有些人有多张票或者票的权重不一样，要怎么设计<br>\10. 安全问题有了解哪些</p><h3 id="题目12-3">题目12</h3><p>1.点评秒杀流程，秒杀过程中用户退单怎么加回去(没考虑过，瞎说，另外中途一直打断让他说又不说，有点红）<br>2.实习<br>3.mysql隔离级别，实现原理，mvcc<br>4.索引，聚集索引，非聚集索引，索引覆盖，回表<br>5.创建索引上来直接用b＋树吗<br>6.联合索引我直接多加几个字段是不是一步到位，和少量字段有啥区别<br>7.redis主从同步<br>8.最新的垃圾回收算法是什么，怎么解决碎片化</p><h3 id="题目13-3">题目13</h3><p>\1. AOP 底层原理是啥？</p><p>\2. SQL 性能问题一般怎么解决？</p><p>\3. 简单讲讲数据库的底层原理？</p><p>\4. redo log、undo log 和 binlog 有啥区别？</p><p>\5. 详细说说支付渠道对接和数据表结构优化的工作？</p><p>\6. 怎么用策略模式让支付渠道更容易扩展？还有，怎么用线程池做 RPC 调用？</p><p>\7. 实现异步线程池时，碰到过啥技术难点或亮点吗？</p><p>\8. 测试效率提升 70%，这数怎么来的？</p><p>\9. Excel 是怎么自动收集搜索结果来提升测试效率的？</p><p>\10. 用了哪些自动化测试工具？</p><p>\11. 详细讲讲 Java 的垃圾回收？</p><p>\12. HashMap 的原理和扩容机制熟吗？</p><p>\13. 聊聊 Redis 的缓存淘汰策略？</p><p>\14. 除了 Linux、MySQL、Python、Java，还用过 Kafka、Redis 这些吗？</p><p>\15. 核心代码模式算法题：求一个字符串的最长回文子串。</p><h3 id="题目14-2">题目14</h3><p>1.自我介绍<br>2.实习<br>技术架构<br>业务；安全方向考量 （消费失败<br>RocketMQ？<br>Kafka顺序性要求<br>延时队列；那你有了解过市面上的延迟队列吗（没<a href="">#牛客AI配图神器#</a><br>Redis你用过什么数据结构</p><p>技术架构<br>聊天消息怎么存储的<br>有了解过市面上的同类产品吗（没<br>同时登陆<br>每次都判断token吗<br>日志组件怎么做的</p><p>9亿个IP地址去重 （想成9G个字符串了，，<br>做成白名单服务如何做 （分表<br>MySQL太暴力了，你能自己实现吗；内存中实现</p><h3 id="题目15-2">题目15</h3><p>1.自我介绍</p><p>2.zset底层数据结构，跳表怎么设置的层高，了解压缩列表吗</p><p>3.布隆过滤器原理，你具体怎么配置的，它如果发生删除会怎么样？</p><p>4.bitmap了解么，怎么实现的签到功能，还有个压缩位图了解吗</p><p>5.mvcc原理解释（必须非常细！！！甚至模拟事务让我判断应该是哪个版本）</p><p>6.可重复读的readview和读已提交，读未提交的区别</p><p>面试官追问我这快10min</p><p>7.间隙锁介绍及作用，有唯一索引的时候间隙锁会锁哪几条记录？</p><p>8.redis的数据库连接出现问题，你在客户端，怎么排查解决</p><p>9.linux查网络情况，查找文件</p><p>10.为什么用jwt，jwt好在哪，你还知道哪些鉴权方式</p><p>11.全局唯一id怎么生成的，你了解雪花算法吗，哪些组成，为什么保证唯一</p><p>12.https加密握手流程</p><p>13.tcp拥塞控制算法</p><h3 id="题目16-2">题目16</h3><p>\1. 项目成果是什么？怎么做的质量保障？<br>\2. 什么场景用到ES？Redis都扛不住ES能抗住吗？方案合理吗？<br>\3. 有用过本地缓存吗？<br>\4. 算法：<br>Result<orderlD> confirmOrder(Order order) (}伪代码实现下单接口(扣减库存、创建订单)，要求:<br>吞吐高<br>商品不超卖<br>每人限购一件<br>\5. 针对写的伪代码的问题：下单怎么保证同步？<br>\6. 并发场景下同一个用户两个请求过来，会不会超卖？前一个请求的异步订单还没有保存，这时第二个请求也没有检测到已经下单，可能出现并发问题，怎么解决？（创建一个轻量的任务去DB，再去做其他的更新）<br>\7. 算法：<br>给定数字数组，返回第三大的不重复的数，不存在返回null<br>要求:遍历和比较次数尽可能少(时间复杂度限制)，空间复杂度尽量低(空间复杂度限制)<br>7767856-&gt;6<br>7767766-&gt;nul<br>6 7 -&gt; null<br>\8. 间隙锁是干啥的？<br>\9. 意向锁的作用呢？是表锁还是行锁？解决什么问题的？<br>\10. select a, b, c from t where a = xx and b = xx orderby c desc  a,b有联合索引，c也有索引 这个场景走的什么索引？c怎么扫描？怎么优化？<br>\11. select a, b, c from t where a = xx and b = xxa.b有联合索引 怎么优化？为什么？<br>\12. 秒杀场景中怎么保护系统的稳定性？系统外部的？<br>\13. 有什么限流算法？漏铜令牌桶？<br>\14. 怎么设置限流的值？怎么去确定这个值？需要关注哪些指标？<br>\15. 应对Redis热点问题有什么解决办法？<br>\16. Redis和数据库一致性怎么做保障？非秒杀环境<br>\17. binlog丢失用什么方法去兜底？<br>\18. 怎么解决Redis数据没有及时更新，检查出现的数据不一致情况？（从DB入手，加一个保证线程去查看）</p><h3 id="题目17-2">题目17</h3><p>1.redis缓存穿透，击穿，雪崩问题<br>2.怎么解决Redisson实现秒杀场景的“一人一单”，避免超卖<br>3.如果让你不用redission实现，你会怎么做，讲讲代码<br>4.判断什么是热点数据（指标，数据结构）<br>5.为什么会有定时任务重复执行的问题，这是一个什么场景<br>6.zet底层逻辑，讲的详细一点（就是说一下跳表的数据结构，为什么选择跳表+哈希）<br>7.跳表底层存储的单元逻辑（没太听懂，问了ai说是​从内存结构​​、​​编码方式​​到​​元素存储的二进制布局讲）<br>8.自己实现一个锁，你会怎么样去实现<br>9.持久化机制，你会选择什么样子的<br>10.redis的过期机制<br>11.redis集群的部署，整体讲一下（数据分片、高可用和自动故障转移等机制）<br>12.主从节点，主从节点崩溃怎么处理，删除节点，增加节点，主节点故障<br>13.java进程中一个线程om了，这个程序会怎么样<br>14.如果是栈溢出呢，怎么解决<br>15.jvm空间分配介绍（着重讲堆内存）<br>16.垃圾回收机制，堆内存空间分布，为什么要这么分，一个程序怎么切换到其他内存<br>17.GC策略<br>18.数据库底层数据结构（对比讲解）（为什么选择）<br>19.红黑树怎么实现的，特点<br>20.查询数据库整个过程（楼主既讲sql执行过程，也讲了整个网络的过程）<br>21.数据库查询中的重复度问题及解决方案​<br>22.数据库隔离机制，acid都是什么，数据库事务的理解，并发问题，隔离级别的实现<br>23.数据库mvcc讲解一下<br>24.分布式事务策略（不会）<br>25.讲一下计算机网络模型<br>26.http和socket的区别<br>27.四次挥手过程，产生两个wait都在哪里，怎么解决<br>编程题目:<br>电商系统，实现一个商品库存的接口，提供<br>increaseStock(int amount)<br>decreaseStock(int amount)</p><p>解决并发的问题，可以使用乐观锁(txt手打，从零开始，使用cas去解决，然后还要写测试并发的代码)</p><h2 id="二面-5">二面</h2><h3 id="题目1-26">题目1</h3><p>1. 自我介绍</p><p>2. 优惠券平台项目是怎么做的</p><p>3. 牛券项目拷打:秒杀是怎么做的？</p><p>4. 秒杀接口如果Redis都扛不住了怎么办  限流</p><p>5. 怎么限流？ Sentinel或者使用Redis</p><p>6. 讲讲这两种限流是怎么实现的</p><p>7. Sentinel限流是全局维度还是单机的</p><p>8. Sentinel限流的原理是什么</p><p>9. 优惠券平台优惠券分发过程是怎么样的</p><p>10. 实习中主要做了哪些工作</p><p>11. 实习中遇到哪些技术难点</p><p>12. 实习还有什么收获</p><p>13. 讲讲对MySQL分库分表的理解  讲了为啥要分表、为啥要分库、垂直分和水平分等等</p><p>14. 垂直分表主要是解决什么问题？为什么要进行垂直分表</p><p>15. 为什么一张表有好几个字段要垂直分表呢，除了业务上的解耦？</p><p>16. 水平分表主要是解决什么问题？为啥要进行水平分表</p><p>17. 水平分表有哪些方式</p><p>18. 哈希法和范围法的优劣</p><p>19. 如果对优惠券表进行分库分表，用户要查询自己的订单，怎么办</p><h3 id="题目2-17">题目2</h3><p>定量的分析我的项目系统的极限处理能力（没弄过，根本不会）。我说没弄过不知道，又问现在就是要分析它的承受能力，你应该怎么做（还是不会…）</p><p>3.项目组件选型考量，用了哪些东西为什么要用这些（最后焦点放在消息队列的选型上，问rocketmq和kafka相较RocketMQ有什么优点，这些优点底层怎么实现的）</p><p>4.Redis缓存穿透（缓存空对象+布隆过滤器，还有没有优化手段（不知道…））</p><p>5.Redis持久化（设计一套兼顾AOF完整和RDB快的持久化方案）</p><p>6.Java垃圾回收机制</p><h3 id="题目3-12">题目3</h3><p>. 做个自我介绍吧。</p><p>\2. 实习时碰到的最大挑战是啥？</p><p>\3. 问题解决后，有深挖过根本原因吗？</p><p>\4. 后来有做什么来防止问题再发生吗？</p><p>\5. 方案设计上，还有哪些能改进的地方？</p><p>\6. 要是重来一次，你会怎么做？</p><p>\7. 除了 Shopee，还在面别的公司吗？</p><p>\8. 你想做测试、工具开发还是业务测试？偏技术还是偏业务？</p><h1>字节</h1><h2 id="一面-17">一面</h2><h3 id="题目1-27">题目1</h3><p>3. redis相关</p><p>3.1 redis有什么数据结构</p><p>3.2 GEO的原理</p><p>3.3 排行榜用什么数据结构</p><p>3.4 朋友圈共同好友用什么数据结构</p><p>3.5 实现数字的原子+1用什么方式</p><p>4. mysql相关</p><p>4.1 mysql有哪些锁</p><p>4.2 分布式锁还有哪些实现方案</p><p>4.3 很多多余的索引有什么缺点</p><p>4.4 怎么利用索引做查询优化</p><p>4.5 大表统计多少条数据行满足筛选条件怎么优化</p><p>4.6 亿级数据大表怎么做查询优化</p><p>4.7 分表要怎么做</p><p>4.8 分区表有听说过吗</p><p>5. ThreadLocal是什么，内存泄漏是怎么回事</p><p>6. 并发访问资源怎么防止冲突</p><p>7. 场景题：一个守护进程负责对工作进程重启，但是现在工作进程一直没拉起来，怎么去定位问题</p><h3 id="题目2-18">题目2</h3><p>进程间的通信方式</p><p>http属于哪一层分层模型：应用层</p><p>访问网页的全过程</p><p>丢包、粘包问题</p><p>创建子进程的方法：fork</p><p>PgSQL和MySQL的区别，选型时的考虑</p><p>建立索引选择字段的原则，最左匹配原则的底层原理是什么</p><p>数据库范式</p><p>Zset的底层原理，查询和增删改的时间复杂度</p><h3 id="题目3-13">题目3</h3><ul><li>预计能实习多久？</li><li>能简单介绍一下实习期间做了什么吗？</li><li>能介绍一下什么是 Websocket 吗？</li><li>Websocket 和 SOCKET 有什么区别？</li><li>Websocket 怎么保证连接是保活的？</li><li>你了解大模型的一些相关的技术概念吗？</li><li>实习项目中除了聊过的内容，还有什么比较有技术深度或挑战性的事吗？</li><li>刚才提到的选择算法（雪花算法）有哪些潜在的问题？</li><li>雪花算法的时钟回拨问题怎么解决？</li><li>能介绍一下项目解决什么问题，或者主要有哪些产品功能吗？</li><li>秒杀模块遇到的核心问题是什么？</li><li>用 Redis 扣减库存时，怎么保证 Redis 和 MySQL 数据一致性？</li><li>Redis 库存数量是什么时候初始化的？</li><li>一道字节的算法题：小于n的最大数（网上能搜到原题）</li><li>先讲思路再写代码，面试官对思路里面有问题的地方会做一些提示</li><li>Redis 是单线程的，单线程会引入什么问题吗？</li><li>MySQL 的 Innodb 存储引擎默认的事务隔离级别是什么？</li><li>Innodb 的默认事务隔离级别能解决幻读问题吗？</li><li>你还在面试其他的实习吗？</li><li>有拿到 offer 吗？</li><li>如果通过面试，你最早什么时候能来实习？</li></ul><h3 id="题目4-10">题目4</h3><p>1. 麻烦你先简单自我介绍一下。</p><p>2. 这个搜索优化里边你做了什么工作？有什么结果？</p><p>3. 机票场景我理解可能有很多这种目的地、价格这种不同的因素，尤其是价格非常敏感，那这个缓存会缓存价格吗？</p><p>4. 那如果你的9天拉到30天，会不会缓存命中率的确提高了，会不会造成后续到下单环节实际库存不匹配？</p><p>5. 影响多大？</p><p>6. 我们扩展一下，假如说你的最终下单环节没有这个下单环节在，实际查询服务商的价格给你兜底了，你的缓存需要精准，怎么做？</p><p>7. 你刚提到这个主动缓存，这个“主动”怎么理解？</p><p>8. 你能描述一下一个简单的搜索系统主要包含哪些环节吗？</p><p>9. 就比如说召回、快速分析、召回、精排这些。</p><p>10. 你刚提到多个供应商的同一个航班线的这种合并会比较耗时，为什么它耗时？</p><p>11. merge为什么耗时？</p><p>12. 那就必须得等最慢的规则才能返回吗？</p><p>13. 那进一步的能不能回来一个就处理一个？</p><p>14. 耗时和CPU哪个更重要？</p><p>15. 你们线上CPU利用率是多少？</p><p>16. 这个 MCP 项目的难点在哪？</p><p>17. 动态工具加载和自动注册在 MyBatis-Plus 里底层是怎么实现 MCP 服务动态注册和热更新的？</p><p>18. 你这边主要熟悉的开发语言是什么？</p><p>19. synchronized 的底层原理是什么？</p><p>20. synchronized 是可重入的吗？</p><p>21. 什么叫可重入？</p><p>22. 它是怎么实现可重入的？</p><p>23. 关于线程池：核心线程数10，最大线程数20，任务队列容量100，不断提交任务时，线程和队列状态会怎样变化？</p><p>24. Redis 里 zset 是怎么实现的？</p><p>25. 压缩列表和跳表什么时候用压缩列表，什么时候用跳表？</p><p>26. 跳表的结构是怎么样的？</p><p>27. MySQL 查询：成绩表中分数在80到90之间，排名前五的学生姓名及分数，SQL 怎么写？</p><p>28. 操作系统中线程和进程的区别？</p><p>29. 在 Linux 系统上，怎么查当前系统负载较高的进程及其实时负载？</p><p>30. 定位某个 Java 业务进程 CPU 很高，该怎么进一步定位问题？</p><p>31. 大模型里“温度”参数的作用是什么？</p><p>32. MCP 和 Function Call 有什么区别？</p><p>33. SSE 和流式 HTTP 有什么区别？</p><p>34. SSE 断开了怎么办？</p><h3 id="题目5-10">题目5</h3><p>1. Http请求中有哪些请求方式？</p><p>2. 说一下Https是如何保证链接安全的？</p><p>3. Https的加密方式是怎样的？对称还是非对称？</p><p>4. Http的状态码都有哪些，代表什么意思？</p><p>5. TCP是如何实现可靠传输的呢？</p><p>6. 在浏览器中输入url后会发生哪些事情？</p><p>7. C++指针和引用的差别是什么？</p><p>8. 说一下动态链接和静态链接是什么，以及各自的优缺点</p><p>9. 说一下深拷贝和浅拷贝的区别</p><p>10. 进程通信的解耦机制？</p><p>11. linux进程通信的几种方式以及各自的应用场景</p><p>12. 说一下数据库的范式</p><p>13. 说一下多线程死锁的原因吧</p><p>14. 如何避免死锁呢？</p><p>15. java是如何保证线程安全的呢？</p><p>16. 说一下java里面的容器是如何保证线程安全的？</p><p>17. AOP在Spring中是怎么实现的呢？</p><p>18. 说一下缓存穿透、击穿、雪崩</p><p>19. 写的项目有没有上线过，有没有用户大规模使用，缓存穿透这些问题是怎么遇到的？(答：模拟这些问题)</p><p>20. 你是怎么模拟这些过程的呢？</p><p>21. 你的linux主要是用来干嘛的呢？</p><h3 id="题目6-10">题目6</h3><p>1.实习 拷打 主要db</p><p>2.分表的设计</p><p><a href="http://3.mq/">3.MQ</a>的使用</p><p>4.索引 联合索引</p><p>5.缓存三剑客</p><p>6.缓存一致性</p><p>7.分布式锁</p><p>8.浏览器输入域名到响应返回</p><h3 id="题目7-9">题目7</h3><p>缓存里存什么数据？<br>Redis 的什么特性使它可以胜任缓存工作？<br>Redis单线程是什么意思，为什么单线程就会快？<br>IO多路复用是什么？单线程和多线程在IO多路复用里的区别？<br>在实习过程中，用的HTTP版本是多少？<br>HTTP2.0和3.0相比1.1的优化方式？</p><h3 id="题目8-7">题目8</h3><p>1.实习项目，问了20分钟左右<br>2.你多线程是怎么用的<br>3.线程进程区别，怎么创建线程<br>4.线程池原理，拒绝策略<br>5.数据库索引数据结构、优点，你们部门项目是怎么加索引的<br>6.springboot用到了什么设计模式<br>7.spring的循环依赖<br>8.项目里用过什么注解<br>9.数据库事务的隔离级别和原理<br>树的z型遍历，但是是英文题</p><h3 id="题目9-6">题目9</h3><p>实习中有什么挑战性的东西<br>有用到什么中间件吗<br>八股/场景<br>一条sql语句的执行顺序（内部流程，解析器执行器）<br>一条sql语句的执行计划（计划，先联表还是先分组）<br>innodb事务隔离级别<br>MySQL索引结构<br>为什么选择B＋树<br>什么时候会索引失效？<br>说一下联合索引<br>对(a,b,c)这样的索引，where b &gt; 10 and a = 1可以利用索引吗<br>业务中发现数据库机器CPU和内存都很高怎么办<br>怎么处理慢查询<br>redis常见数据类型<br>redis为什么适合缓存<br>redis cluster的读写 分片等</p><h3 id="题目10-6">题目10</h3><p>1.自我介绍<br>2.项目拷打(20min)<br>a. 介绍一下视频上传功能<br>b.介绍一下私聊功能<br>3.手撕K个一组反转链表(最后不够K个也要反转没注意)[15min]<br>4.介绍一下MVCC？<br>5.介绍一下间隙锁？</p><h3 id="题目11-4">题目11</h3><ol><li><p>详细介绍一下你那个海洋物联网平台都干了些啥？</p></li><li><p>那么多不同设备的数据，是怎么接到系统里的？它们的数据结构有啥不一样？</p></li><li><p>刚提到了反射，Java 里有几种方式能实现反射？</p></li><li><p>CGLIB 和 JDK 动态代理，主要区别是啥？</p></li><li><p>数据是怎么存的？如果按半年存，要查 6 月到 8 月的数据该怎么做？</p></li><li><p>怎么监控和优化慢 SQL？</p></li><li><p>索引在什么情况下会失效？MySQL 有哪些索引类型？聚簇索引和非聚簇索引有啥区别？</p></li><li><p>Spring 的事务传播行为有哪几种？它们有啥用？</p></li><li><p>消息队列在项目里一般都用在哪些地方？</p></li><li><p>聊聊你对 Kafka 的理解？它的核心组件和 broker 都是干嘛的？怎么保证消息不丢？</p></li></ol><p>后45分钟进入编程环节:</p><p>核心代码模式算法题&quot;求前缀和&quot;</p><p>附加问题:</p><ol><li>用 Shell 写个脚本，统计日志里出现次数 Top 10 的 IP。</li><li>用 Java 实现同样的功能（要求自己手写堆）。</li><li>给你一些日志（每条包含 ip、start、end），算一下一天中同时在线人数的峰值是多少。</li></ol><h3 id="题目12-4">题目12</h3><p>\1. 自我介绍<br>\2. 讲一个实习或项目的亮点<br>\2. go协程和c协程区别？栈溢出会崩溃吗？<br>\3. read系统调用会发生几次用户态到内核态的切换？零拷贝会发生几次？<br>\4. 浏览器输入url，客户端发包过程？，在数据链路层用到什么协议，是怎么路由到目标服务器的？<br>\5. mysql的mvcc版本链存在什么位置？<br>\6. mysql日志没落盘突然断电了怎么办？<br>\7. 两阶段提交涉及哪些日志？</p><h3 id="题目13-4">题目13</h3><p>自我介绍<br>详细介绍第一个项目 （我的项目放的比较多）<br>面试官了解项目的基本情况（使用场景和一些简单的细节）<br>数据量级比较大的时候如何解决（详细答了解决的算法设计思路，这块项目里详细做过）<br>关于项目中网络传输和数据存储的一些问题<br>数据传输中用到的协议<br>介绍另一个项目（做了个web服务框架）<br>安全认证的方式<br>链表和数组的区别<br>一个场景题，数组取数据相关的<br>线程和进程的区别<br>详细说明适用场景<br>多线程的CPU底层处理方式<br>介绍一下设计模式的一些情况</p><h3 id="题目14-3">题目14</h3><p>1.自我介绍<br>2.实习<br>微服务，怎么交互<br>http是一种序列化协议吗 （答错了，更高级一些）<br>RPC<br>socket<br>Kafka写内存可以吗<br>3.项目 （项目做的太简单了<br>表的设计<br>聊天有历史记录吗<br>为什么压测</p><p>redis<br>缓存一致性</p><h3 id="题目15-3">题目15</h3><p># 你觉得go和Java有什么区别，这俩本质上语言这方面有没有什么区别</p><p>​</p><p># 讲一下 Java的反射原理和机制是什么，怎么获取具体实现，反射的话说是不是它里面所有的属性都可以获取到，私有属性可以吗</p><p>​</p><p># 对象创建的哪个阶段去调用的，编译值还是运行值，你说一下反射的优点和缺点都是什么，它的性能怎么样？它运行的时候是怎么获取的</p><p>​</p><p># Java里边常用的数据结构有哪些?也就是集合数据结构,集合 list和数组的区别,常见的list有哪些类型，我new一个ArrayList的时候是预分配内存还是插入的时候再分配内存</p><p>​</p><p># 现在我们假设有一个数组也好，map也好，我们想保证一个数据操作它的读写是现场安全的，请问有几种办法,ReetrantLock实现原理是什么，锁的话说会有性能问题除此之外还有什么保证现场安全的办法</p><p>​</p><p># 跑程序的容器里边，它有两个比较核心的指标对吧？这两个核心指标分别是什么，那么我们加锁的方式是用什么换什么</p><p>​</p><p># 解释一下https的原理行吧，说一下https的原理实现方式以及加密方式，还有它是如何保证安全的，那个证书有没有可能被劫持</p><p>​</p><p># Redis在哪些场景下用的多，或者说什么场景需要用到Redis，你用之前知道它大约能抗多少QPS，它为什么快</p><h3 id="题目16-3">题目16</h3><p>\1. 自我介绍<br>\2. 简单问了实习<br>\3. 事务的ACID特性是如何保证的，没有redolog的引擎怎么实现持久化<br>\4. mysql主从同步的过程<br>5.主从同步延迟长的原因<br>\6. 数据库和缓存如何保证一致性<br>7.项目拷打</p><h3 id="题目17-3">题目17</h3><p>pringBoot的IOC的基本原理和底层实现？<br>出现循环依赖怎么解决？有没有遇到过三级缓存也解决不了的循环依赖<br>OOM是什么，什么情况会出现OOM？<br>如果出现了栈溢出的情况，程序会直接终止吗？<br>进程和线程的区别？<br>Java线程有哪些状态？Java的线程和操作系统的线程是一一对应的吗？<br>数据库在什么情况下会出现索引失效？为什么左模糊查询会导致索引失效？<br>数据库的第一第二第三范式都是什么？<br>RPC是个什么样的概念？有哪些常见的RPC框架？RPC是怎么实现的？</p><h3 id="题目18-2">题目18</h3><p>1.问实习二十五分钟 后开始基础知识拷打</p><p>2.讲讲Java的锁 synchroniz</p><p>3.说说锁升级的过程</p><p>4.为什么会有这个过程  主要是避免什么</p><p>5.reentranlock 和synchronize 的区别 生产上一般用哪个</p><p>6.AQS的实现原理</p><p>7.有哪些实现类 以及怎么实现的</p><p>8.类加载机制</p><p>9.双亲委派是什么</p><p>10.索引失效是由什么导致的</p><p>11.慢sql排查优化</p><p>12.联合索引 最左前缀匹配原则</p><p>13.redolog binlog如何写入磁盘 两阶段提交</p><p>14.如果没有两阶段提交会怎么样</p><p>15.MySQL 的原子性是怎么保证的</p><p>16.数据更新日志的写入顺序</p><p>17.redis的网络模型是怎么样的 （为什么这么快）</p><p>18.什么是分布式 以及会带来什么问题</p><p>19.分布式数据一致性怎么保证</p><p>20.消息队列的推拉模式了解么</p><p>21.如何保证消息幂等</p><p>22.如何保证消息不丢失</p><p>23.kafka为什么那么快</p><p>24.零拷贝是什么 讲一下流程 减少哪些地方的拷贝 是完全没有拷贝么</p><p>25.一个消息队列的好坏有哪些评价指标  有什么作用</p><p>26.rocketmq和kafak的区别</p><p>27.设计模式 应用场景</p><h3 id="题目19-2">题目19</h3><p>SpringBoot 是怎么加载 Bean 的？</p><p>反射为啥会影响性能？</p><p>线程安全的工作原理是啥？</p><p>线程安全里，主内存和工作内存分别指啥？</p><p>进程和线程有啥联系和区别？</p><p>HashMap 和 TreeMap 有啥区别？</p><p>红黑树查询效率为啥高？</p><p>红黑树是怎么实现自平衡的？</p><p>网络编程里，你知道哪些 IO 模型？</p><p>BIO、NIO、AIO 里的 N 指的是啥？</p><p>TCP 是怎么保证可靠传输的？</p><h3 id="题目20-2">题目20</h3><p>\1. redis数据结构<br>\2. zset底层实现，底层为什么用跳表，跳表底层实现，跟其他数据结构比有什么好处<br>\3. redis持久化方案，实现方案，优缺点<br>\4. io多路复用<br>\5. 又问了select，epoll，poll实现区别优缺点，这些实在不会了，操作系统没仔细看<br>\6. 哈希冲突处理方法 ，缺点？其他处理哈希冲突方法？<br>\7. tcp与udp分别介绍一下，区别？<br>\8. redolog undolog binlog<br>\9. mysql隔离级别<br>\10. 覆盖索引，索引下推<br>\11. mysql数据从入库到提交到修改有哪些流程<br>\12. 怎么用redis实现分布式锁<br>\13. 怎么增加标识<br>\14. 实现分布式锁其他方案？<br>\15. 用过哪些mq介绍一下<br>\16. 数据库表设计，结合他们的一些业务写一些建表语句（应该是用来水时间的）</p><h3 id="题目21-2">题目21</h3><p>\1. 讲一讲美团做的项目<br>\2. 项目最终拿到什么收益？<br>\3. 有用过mysql、redis、kafufa等吗？<br>\4. mysql四个事务隔离级别和每个级别锁对应的问题<br>\5. 死锁怎么产生的？怎么解决？<br>\6. mysql常见的分库分表一般怎么做？<br>\7. 举一个分表的场景，垂直？水平？<br>\8. 如果是有一个账单表怎么分表？按userId？有没有可能某个用户数据量巨大？怎么解决？（按照时间戳）<br>\9. 涉及分布式锁的时候需要注意哪些问题？<br>\10. redis分布式锁如果单节点挂了，应该怎么解决？<br>\11. redis说是二进制安全，为什么？SDS相比普通的String优势在哪？redis的String底层类型是什么？<br>\12. redis有序集合底层是什么实现的？<br>\13. 跳表的数据存储和读取是什么步骤？<br>\14. ES为什么适合做模糊查询？<br>\15. ES最适合做什么场景？如果分表过多要联合查询怎么做？<br>\16. 设计一个秒杀系统要做什么考虑？<br>\17. 库存扣减怎么保证不超卖？<br>\18. redis中作库存扣减怎么做？会出现并发问题吗？</p><h3 id="题目22-2">题目22</h3><p>1.实习内容拷打（甚至涉及到问我业务后续迭代可以从什么方面考虑）</p><p>2.分布式系统的了解</p><p>3.给一个几百万的数组，没办法一个机器放进去，怎么用分布式系统排序。</p><p>4.怎么避免按值分配后大部分值不会落在同一个区间内？</p><p>5.虚拟内存和物理内存</p><p>6.如何映射的</p><p>7.如果找不到映射会怎么样？</p><p>8.有哪些页面置换算法</p><p>9.Lru的数据结构</p><p>10.操作系统怎么提高流畅度</p><h3 id="题目23-2">题目23</h3><p>\1.  一些项目问题这里就不阐述了<br>\2.  java重载重写有啥区别<br>\3.  java中哈希表的工作原理是什么<br>\4.  java中jvm的内存结构和java中对象创建过程是啥样的<br>\5.  垃圾回收与待计假说的原理<br>\6.  MySQL中索引原理是啥<br>\7.  MySQL中遇到慢查询如何去排查<br>\8.  简述快排时间空间复杂度<br>\9.  TCP三握手、四握手的过程<br>\10. https协议中ssl的交换过程</p><h3 id="题目24-2">题目24</h3><p>\1. java里控制线程同步的方式</p><p>\2. java里有哪些实现锁的机制</p><p>\3. synchronized标记两个方法，我现在创建这个类的实例对象，我再创建两个线程，其中一个线程调用第一个方法的时候，第二个线程能否调用第二个方法。</p><p>\4. 线程池的常用参数，以及线程池提交任务的运行机制</p><p>\5. MySQL的InnoDB引擎有哪几种事务隔离级别？</p><p>\6. 可重复读相比读已提交解决了哪些问题？</p><p>\7. 举一下可重复读的一个具体场景。</p><p>\8. 最左前缀匹配。</p><h3 id="题目25-2">题目25</h3><p>1，问问专业背景，学过什么课，发现没系统学过计网和操作系统<br>2，情景题，如何设计一个旅游景点的门票，涉及到几张表，每个表之间的关系是什么样的，如何设置库存，控制人流量<br>1，计网，只知道一点，问了TCP和UDP<br>2，Java开发的单例模式？不知道<br>3，MySQL索引结构？B＋树，索引失效？不知道。事务，四大特性，如何实现这四大特性？<br>4，Redis有哪些数据结构，Zset的底层实现？不知道<br>5，手撕，数组中最小k个数。力扣面试题17.14。要求：不允许用java自带函数和方法，要给出时间复杂度和空间复杂度，且要尽可能小。</p><h3 id="题目26-2">题目26</h3><p>\1. 自我介绍一下。</p><p>\2. 能实习多久？</p><p>\3. Spring 和 Spring Boot 有啥区别？</p><p>\4. 聊聊内存，虚拟内存和物理内存是啥关系？</p><p>\5. 为什么需要虚拟内存？</p><p>\6. 堆和栈里都存些啥？</p><p>\7. HTTP、HTTPS、HTTP/2、HTTP/3 有什么区别？</p><p>\8. 网络协议的七层和四层模型是啥？为啥要有四层？</p><p>\9. IOC 和 AOP 的原理是啥？</p><p>\10. 进程和线程有啥区别？浏览器发请求这个过程是怎么样的？怎么避免线程冲突？</p><p>\11. 创建线程有几种方式？</p><p>\12. 锁有哪些类型？悲观锁和乐观锁有啥区别？</p><p>\13. 什么是装箱和拆箱？</p><p>\14. 短链系统怎么设计和优化？</p><p>\15. 100 个人和 100 盏灯，一开始灯都关着。第 i 个人会去按所有 i 的倍数编号的灯的开关。最后有多少灯是亮着的？</p><h3 id="题目27-2">题目27</h3><p>项目难点啊，轻耦合表现在哪啊，java的哪些特性实现了轻耦合啊，模块与模块之间怎么实现的轻耦合啊……<br>spring依赖注入方案有哪些？<br>Setter和基于接口的方案有啥区别？你用哪个？为什么？<br>柔性事务相对刚性事务有什么区别？中间状态不一致为什么保持了强一致？<br>tcp半包粘包？<br>tcp报文段有规定体积吗？头部有规定体积吗？<br>设计编码器是怎么解决半包粘包的？怎么判断这个包是不是属于这个包的开头部分……<br>tcp重复和丢包是怎么处理的？怎么保证收到的是完整的？（长度和内容）<br>udp实现IM的话应用层怎么保证安全和一致性呢？（重传部分问的很细（（</p><p>java集合的ArrayList和LinkedList有什么区别？内存部分有什么特点？应用场景有？<br>Hashmap底层怎么实现的？什么时候扩展到红黑树？有什么优势？红黑树怎么保证平衡？<br>场景题：<br>用户同时保存下载100本小说，有进度提示，希望下载的越快越好，也希望保障手机的性能，可以从哪些点入手来实现？<br>这样的item结构是啥样的？怎么更新下载状态？存到本地数据库要注意什么？为什么造成死锁？怎么解决？怎么设计锁？<br>网络层层面怎么进行优化？</p><h3 id="题目28-2">题目28</h3><p>. 实习经历、难点、亮点<br>\2. 数据库隔离级别+解决的问题<br>\3. 缓存穿透、击穿、雪崩+怎么解决<br>\4. HTTP、HTTPS的区别，加密的方式<br>\5. 介绍对称加密和非对称加密 + 两者的区别<br>\6. 具体讲解一下两种加密方式和一些加密算法<br>\7. 手机扫描电脑登录二维码实现登录功能，你怎么进行设计<br>\8. 服务端如何向PC客户端返回数据【WebSocket】<br>\9. 登录时向服务端发送请求使用什么协议？HTTP or HTTPS？<br>\10. 介绍一下WebSocket，HTTP 和 WebSocket的区别？</p><h2 id="二面-6">二面</h2><h3 id="题目1-28">题目1</h3><ul><li>跟电影售票有什么区别？剧院跟电影的区别是啥？为什么不能放在现有平台上呢？</li><li>项目有什么关键的设计？</li><li>如果我们要做一个登录态的保持，比如说七天免登录，那这个应该怎么做？</li><li>access TOKEN 的过期时间是怎么保证的？</li><li>这个（TOKEN 过期时间）会被篡改吗？怎么做的非法校验？</li><li>为什么要两个 TOKEN 呢？</li><li>存在 cookie 里了，为什么没有暴露呢？（回答设置HTTP-only）设置这个是能做什么？（被拷打了，没有答明白两个token应该存放在哪）</li><li>token控制 7 天有效期这个怎么控制？</li><li>那假设我们再把这个问题升级一下，就是如果 7 天内有登录，那这个 key 就不过期。那你怎么实现？</li><li>就是如果我连续登录，那理论上不是固定的过期时间，是超过多长时间不登录才过期？</li><li>只要你 7 天内有登录，那我们这个就不过期；如果超过 7 天没登录，那就过期重新登，那你应该怎么做？</li><li>那比如说我中间有登录，只要我中间打开 APP，这个就不过期，这个怎么做的？</li><li>会生成新的 TOKEN 刷新了，怎么刷？</li></ul><h3 id="题目2-19">题目2</h3><p>1.自我介绍<br>2.为什么选用websocket<br>3.谁来敲定使用websocket的<br>4.websocket和sse区别<br>5.为什么sse原生只支持文本格式<br>6.sse是怎么做限制的<br>7.什么是双全工协议<br>8.使用websocket有什么要注意的地方<br>9.讲一下组件的原理 如何实现交互的<br>10.websocket能复用长连接吗<br>11.这个组件肯定是多机部署的 怎么知道你要选用的是哪个连接<br>12.你觉得这个组件设计的收益在哪里<br>13.假如让你实现一个websocket 如何实现<br>14.rocketmq和kafka区别<br>15.为什么kafka吞吐量大<br>16分布式锁的key和过期时间怎么设置的<br>17.为什么要用分布式锁 有别的方法吗<br>18.讲一下故障降级的机制</p><h3 id="题目3-14">题目3</h3><p>自我介绍<br>堆区栈区相关内容<br>静态变量<br>这些都问的比较深入<br>代码编译的过程<br>死锁相关<br>做的项目代码量<br>Nginx反向代理介绍一下<br>项目算法介绍<br>TCP流量控制的方法<br>具体介绍滑动窗口<br>http协议相关<br>设计模式</p><h3 id="题目4-11">题目4</h3><p>怎么设计保存用户登录状态、<br>HTTPS的握手原理<br>Binlog有几种格式<br>undolog的格式<br>事务失败回滚的具体执行过程<br>慢查询 怎么分析<br>redis的sds<br>redis的数据持久化方式<br>如何用redis去实现分布式锁<br>setNX命令详解</p><h3 id="题目5-11">题目5</h3><p>1、自我介绍（3min）</p><p>2、实习拷打（30min，其中有一个问题没回答好）</p><p>3、1000w的ur，10MB内存，如何排序</p><p>4、1个商品，1000w库存，20wQPS的购买，如何设计</p><p>5、括号匹配（easy，3min秒了）</p><h3 id="题目6-11">题目6</h3><p>\1. Java 中的接口和抽象类有什么区别？说几个使用场景。<br>\2. 手写一个 LRU 缓存，要求线程安全。<br>\3. 线程池的核心参数分别代表什么？最大线程数满了之后会发生什么？<br>\4. Spring 里的循环依赖是怎么解决的？单例、原型都适用吗？<br>\5. 如果多个线程同时竞争锁，JVM 是怎么决定谁先拿到锁的？<br>\6. 你了解过 volatile 吗？说说它和 synchronized 的区别。<br>\7. 数据库索引什么时候会失效？有哪些使用误区？<br>\8. HTTP 和 HTTPS 的底层加密原理能简单讲一下吗？<br>\9. 算法题：给一个数组和目标值，找出两个数，使它们的和等于目标值，要求时间复杂度尽可能低。<br>\10. Redis 是单线程的，那为什么它还这么快？<br>\11. 假设你有一张订单表，每秒几千条数据写入，怎么设计才能高并发插入同时还能支持实时查询？</p><h2 id="三面-4">三面</h2><h3 id="题目1-29">题目1</h3><p>1.简单寒暄了几句</p><p>2.自我介绍</p><p>3.项目拷打</p><p>a.项目里Nginx负载均衡怎么做的？</p><p>b.Nginx配置集群怎么做？[以为问的是后端集群在Nginx怎么配置，结果是Nginx服务器集群怎么配置，没做过Nginx服务器集群根本不知道]</p><p>c.你的多后端服务配置在哪？[追问：为什么在Linux不在Docker上？]</p><p>d.从键入请求到你的服务返回响应中间发生了什么?</p><p>e.那你得到IP地址和MAC地址去请求集群中哪台Nginx服务器？</p><p>f.域名挂靠怎么挂靠的[没听懂这里想问什么，可能是请求的后端服务器的域名或者其他的，有牛友可以解答一下吗]</p><p>g.Linux命令了解吗？</p><p>h.我如果把Nginx的配置文件的所属目录更改了，那我要做哪些操作</p><p>这里面试官看出来我没什么实战经验了，直接问我你刚才说的是不是都是背的？（好想钻地缝里去）</p><p>开始拷打操作系统：</p><p>1.删除一个文件在操作系统里面是什么流程？</p><p>2.进程线程区别？</p><p>3.你刚才提到说进程独立分配资源，具体有哪些资源？</p><p>4.硬链接软链接了解吗？区别在哪？</p><p>接着拷打数据库：</p><p>1.做过数据库备份吗？对应SQL语句是什么？[忘光光]</p><p>2.来个SQL查询，分别找出学生表中姓李的男生女生个数（我的答案是group by 性别 having name like “李%”，面试官说为什么不where name like “李%” group by 性别，汗流浃背了）</p><p>3.来写一个反射的实例以及方法的调用（几百年没写过反射了，直接蒙了）</p><p>手撕在数组中出现次数超过一半的数字</p><p>面试官可能看我好多答不上来有点尴尬，接着问我消息队列：</p><p>1.kafka的原理？</p><p>2.kafka部署在几台机器上，一个分区几个副本？</p><h3 id="题目2-20">题目2</h3><p>自我介绍（面试官恭喜进入第三面 ┭┮﹏┭┮）<br>项目上介绍最能代表个人技术特点的项目<br>补充：项目这块因为是从0到1做的实现，本身项目做的很多，属于是项目业务型选手，所以面试官老师问的项目相关的内容<br>没有卡壳的基本，各种衍生优化场景当时做的时候也都基本有考虑到过，所以答得很顺畅，还跟面试官老师交流了一<br>些优化设计思路</p><p>然后就是基本的八股<br>面试官老师对网络通信和安全协议这块问的很多也比较细，绝大部分答得还可以</p><h1>小红书</h1><h2 id="一面-18">一面</h2><h3 id="题目1-30">题目1</h3><p>1.介绍自己。讲一下项目</p><p>2.讲一下你用的这个reactor网络模型</p><p>3.你说把耗时操作push到线程池，那返回的结果是如何回到reactor的回调里的呢。我不会，胡扯了一通，还是对项目不够了解</p><p>4.讲一下epoll处理的过程</p><p>5.send返回以后数据是已经从机器发出去了吗</p><p>6.缓冲区满了以后阻塞模式的send会是什么表现？非阻塞模式呢</p><p>7.什么时候触发send缓冲区的清理。面试官提到tcp之后我说是ack以后</p><p>8.在reactor回调里不小心写了一个sleep会怎么样？影响的是一个连接还是一个线程？其实是想问线程切换相关</p><p>9.你提到nginx，有没有看过nginx的实现，我说没有，面试官说因为你之前提到用epoll实现reactor网络模型，其实应该先看一下nginx和redis的实现，因为他们就是标准的。而且redis还是跨平台的，不仅是epoll，会根据操作系统的不同选择不同的方案</p><p>10.你提到io_uring，是使用过吗？内核版本多少？是要解决什么问题？只是处理网络io还是包括文件？</p><p>11.你提到的这个用户态轻量级线程协程是什么？具体的切栈的逻辑你有看过吗？操作寄存器如果不用内联汇编的话你觉得c和c++可以实现吗？面试官意思是c/c++没有提供直接操作寄存器的接口</p><p>12.你这边还提到了使用过dpdk，dpdk和标准的内核网络栈有什么区别？是如何绕过内核的？驱动是用户态的还是内核态的？工作原理可以描述一下吗？它是主动去pull还是一个中断触发</p><p>13.read系统调用读本地文件一直到磁盘设备大概经历那些流程。我说我不太了解</p><h3 id="题目2-21">题目2</h3><p>实习里面这个监听binlog怎么保证一致性</p><p>mq有了解过吗</p><p>es有了解过吗</p><p>es和mysql的区别</p><p>mysql的索引结构</p><p>垃圾回收算法</p><p>jvm各区域</p><p>一次younggc的过程</p><p>synchronized锁底层</p><p>synchronized锁升级</p><p>mq有了解过吗（只说会kafka 讲了一下kafka的架构 以及一些机制</p><p>分布式一致性（说了raft，说了分布式事务</p><p>分布式事务实现的技术有了解过吗？这个不会</p><p>怎么看待ai</p><h3 id="题目3-15">题目3</h3><p>1. 自我介绍<br>2. 项目里面提到的一些内容<br>3. Redis使用场景、Redis数据结构、部署方式（单机/集群/哨兵）、Redis哨兵模式原理<br>4. MySQL与ES的核心差异、搜索索引优化内容、压测工具、项目核心难点<br>5. MQ使用场景、MQ原理（核心组成）<br>6. JVM运行时数据区域有哪些？<br>7. 常见垃圾回收算法及各自区别与优点<br>8. Java线程池核心参数<br>9. 线程池拒绝策略有哪些？<br>10. Java内置锁（synchronized）原理<br>11. 如何避免死锁？<br>12. 分布式一致性了解吗？分布式锁或分布式事务？</p><h3 id="题目4-12">题目4</h3><p>\1. 自我介绍<br>\2. 介绍一下第一个需求的背景<br>\3. 为什么使用CompletableFuture<br>\4. 线程池的参数以及你的设置<br>\5. 那如何设计一个阻塞队列呢<br>\6. 第二个需求的背景<br>\7. 插件是怎么实现的<br>\8. 什么是AOP<br>\9. Caffeine的内存淘汰策略，及其优势<br>\10. 第三个需求的背景<br>\11. 为什么选择使用工厂+策略进行优化<br>\12. 第四个需求的背景<br>\13. 有没有遇到什么问题</p><h3 id="题目5-12">题目5</h3><p>1、自我介绍</p><p>2、挑一个项目来介绍一下</p><p>3、Java 的 GC 过程会有 Stop the World，谈谈为什么要有 STW 的机制？</p><p>4、谈谈 Java 的SGC、G1、ZGC 垃圾回收器</p><p>5、G1 已经很不错了，为什么还要有 ZGC 这样的垃圾回收器，为了解决什么问题？</p><p>6、比如一个订机票的场景，涉及多个外部系统，首先要去看有没有票，然后第二个是支付要调支付宝或者微信去做付款，定完票可能过了半个小时才告诉我订票有没有成功。对于这种场景下的分布式事务，你认为怎么去处理和设计来保证一致性比较好？</p><p>7、基于消息传递的方案，消息可能传递失败，如何解决？</p><p>8、如果用消息队列，这种场景，怎么做技术选型？</p><p>9、做题：新兵报到，指导员命令所有人按身高大小，从低到高，依次站好，每次从头这边开始调整，但是要求，每次一次只能进行一次交换。输入 N(N &lt;=  20)，输出 N 个士兵最终的排列结果。示例：N = 5，heights = [170, 167, 180, 175, 168]，输出：[167, 168, 170, 175, 180]</p><p>10、谈谈基于数据库的方式如何实现分布式锁？</p><p>11、谈谈基于 Redis 如何实现分布式锁？</p><p>12、为什么基于 Redis 实现分布式锁时，Set 命令要加 PX 参数？</p><p>13、基于数据库方式实现和基于 Redis 实现的区别？应用场景？</p><h3 id="题目6-12">题目6</h3><p>创建线程有几种方式？</p><p>聊聊线程池的设计和参数配置？拒绝策略和阻塞队列怎么选？</p><p>Spring AOP 的原理是啥？都用在哪些地方？</p><p>聊聊 Spring 的事务管理和隔离级别？</p><p>Redis 数据结构，随便挑一个讲讲底层原理？</p><p>项目里 Redis 具体用在哪了？</p><p>Redis 还有别的用法吗？它的分布式锁支持可重入吗？</p><p>怎么保证 Redis 和 MySQL 的数据一致性？</p><p>聊聊项目里防超卖的方案？为啥用库存扣减，而不是直接改库存数？数据库锁为啥没法完全解决超卖？</p><p>为啥要把行业映射配置放 Diamond 里？</p><p>阿里云 OpenSearch 全量和增量同步冲突了咋办？</p><p>实习时碰到过啥技术难题？</p><p>核心代码模式算法题：连续子数组的最大和。</p><p>电商的基础设施（比如库存、订单系统），你觉得有啥技术挑战？</p><h3 id="题目7-10">题目7</h3><p>1、自我介绍几分钟</p><p>2、实习的提效工具怎么工程化落地，混合了对Agent、MCP、RAG的工具性理解</p><p>3、Redis为什么高效</p><p>4、Redis的缓存雪崩、缓存击穿、缓存穿透及解决方案</p><p>5、TCP为什么是可靠传输</p><p>6、连不上服务（time_wait）怎么排查</p><p>7、多线程的锁机制</p><p>8、并发、并行及其应用场景</p><p>9、乐观锁和悲观锁</p><p>10、浅拷贝和深拷贝及其应用场景</p><p>11、假设有一个超大文件，以最省内存（并非空间复杂度）的方法输出前十个最大的数</p><p>12、有null值的两表联查</p><h3 id="题目8-8">题目8</h3><p>介绍实习业务<br>实习里面这个监听binlog怎么保证一致性<br>mq有了解过吗<br>es有了解过吗<br>es和mysql的区别<br>mysql的索引结构<br>垃圾回收算法<br>jvm各区域<br>一次younggc的过程<br>synchronized锁底层<br>synchronized锁升级<br>mq有了解过吗（只说会kafka 讲了一下kafka的架构 以及一些机制<br>分布式一致性（说了raft，说了分布式事务<br>分布式事务实现的技术有了解过吗？这个不会<br>怎么看待ai</p><h3 id="题目9-7">题目9</h3><p>八股文：<br>mysql执行一条update语句，全流程是怎么样的，假设存储引擎是innodb。（问了很久，包括加锁啥的面试官也引导着要求说一下，忘完了，这块说的不够详细）<a href="">#牛客AI配图神器#</a></p><p>加一个联合索引后，在存储引擎内存储结构是怎么样的。就假如说加了（a,b）联合索引。</p><p>假如加了（a,b）联合索引，查询的时候还有个非索引字段c，最终查询流程是什么样的。</p><p>mysql redolog和undolog干啥的。</p><p>假如说mysql宕机了，redolog写入成功了，binlog还没写进去。mysql重启后会怎样。</p><p>redis String底层结构，为啥要这么设计</p><p>redis expire的工作原理</p><p>redis 除了基于内存以外，还有哪些点导致他性能这么高的。</p><p>你说io多路复用，为啥io多路复用性能高，说一下select poll，epoll原理。</p><p>redis分片集群，集群某个节点容量不够了怎么扩容。扩容后数据迁移怎么做。扩容后hash变化是怎样的。</p><p>go语言slice append流程</p><p>go语言垃圾回收机制，写屏障是为了解决什么问题的。</p><p>你对go转Java是什么看法，部门内主要还是Java</p><h3 id="题目10-7">题目10</h3><p>全程八股</p><p>TCP三次握手 四次挥手</p><p>TCP如何保证数据传输可靠性(滑动窗口</p><p>TCP UDP区别</p><p>http和websocket</p><p>http和https区别，是对称加密吗，为什么</p><p>类加载流程</p><p>双亲委派流程，如何打破</p><p>启动类加载器和扩展类加载器加载什么样的类</p><p>为什么要打破，有什么好处</p><p>垃圾回收算法，哪些算ROOT</p><p>如何触发full gc，cms和g1流程以及区别，三色标记</p><p>类什么时候回收，怎么回收</p><p>mysql三大范式，你设计一张表会从哪些角度考虑</p><p>mysql索引，聚簇，二级，哈希，联合，覆盖，前缀</p><p>mysql事务如何保证，acid如何实现</p><p>redolog和undolog在哪层，分别怎么实现</p><p>幻读是什么，如何解决</p><p>readview版本链读取规则</p><p>解释一下BIO，AIO，NIO，以及多路复用</p><p>详细说一下select，poll，epoll，如何做</p><p>线程池相关，如何预热，工作流程，如何手写拒绝策略</p><p>字节码如何增强</p><p>ThreadLocal为什么会导致内存泄露，反射原理，注解原理，用过吗，举个例子</p><p>细说Spring解决循环依赖的三级缓存</p><h2 id="二面-7">二面</h2><ul><li>redis 常用数据结构, 实现, big key,</li><li>业务处理时间超过了分布式锁的过期时间, 如何处理</li><li>mq 如何实现订单超时处理</li></ul><h3 id="题目1-31">题目1</h3><p>几乎都答出来了<br>简单问了一下实习<br>Java 的hash函数是怎样的<br>hash函数有什么降低hash冲突的方法吗<br>垃圾回收算法<br>标记复制的缺点是什么？<br>标记复制为什么是8:1:1<br>jvm的软引用和弱引用的区别<br>为什么jvm会有这几种引用的区分<br>讲一下协程<br>线程和协程区别，哪个上下文切换开销大<br>协程的上下文切换开销主要在哪里？<br>协程栈大小是多大，线程呢？<br>springboot的优势<br>除了约定俗成的配置，你知道springboot在初期是怎样发展起来的吗，有什么优势<br>spring是如何解决循环依赖的？<br>三级缓存为什么能解决循环依赖</p><h1>网易</h1><h2 id="一面-19">一面</h2><h3 id="题目1-32">题目1</h3><p>开局一个sql题：<br>登录记录表record，有字段记录id（id），用户id（user_id），登录时间（login_time），怎么查询用户A（user_id=10000）的最近3次登录记录？<br>写了个select * from record where user_id = 10000 order by login_time desc，忘记最近3次怎么写了（加个limit 3就行）<br>接下来全是场景题，感受一下：<br>1、服务器被入侵了如何处理？（随便答了个拉黑ip，但是换一个ip怎么办，不会）<br>2、发现某个接口速度很慢，如何排查？（一脸懵）<br>3、mysql某条语句查询速度很慢，如何排查？（说了explain查看执行计划）<br>4、1000w条数据找目标值，几分查找比较合适？（没懂这题想考什么，是想考B+树索引吗）</p><h3 id="题目2-22">题目2</h3><p>\1. 自我介绍<br>\2. 实习经历中的接口优化怎么做的<br>\3. 你是怎么检测接口速度和页面响应快慢的<br>\4. 合同流程优化细节<br>\5. 合同生成是同步还是异步调度的<br>\6. 防重提交怎么做的<br>\7. Redis分布式锁相关问题<br>\8. 为什么要做这样的功能<br>\9. 简历上面有个策略模式，你还知道哪些设计模式<br>\10. 讲一下单例和工厂模式<br>\11. 看了你的github源码，这里面为什么会有这么多文件夹–微服务，工具类打成jar包，直接用接口<br>\12. 是不是可以试试多模块？<br>\13. 各个模块之间是不是有很多关联操作<br>\14. 怎么创建线程<br>\15. 线程的拒绝策略有哪些，分别在什么场景下面能用到<br>\16. 你之前怎么进行项目部署的<br>\17. 你知道dockerfile是什么作用不<br>\18. 来做道题–单词拆分（leetcode 139）–大概7min<br>\19. 说思路–动态规划<br>\20. 什么时候到岗，能实习多久</p><h1>新浪</h1><h2 id="一面-20">一面</h2><h3 id="题目1-33">题目1</h3><p>1.自我介绍</p><p>2.秒杀场景下redis的分布式锁和lua脚本分别起什么作用</p><p>3.缓存空对象可以解决缓存穿透，但是高并发场景下压力大怎么办</p><p>4.了解大模型吗，用大模型协助开发吗，平时用什么大模型协助开发，大模型的token是什么，怎么定义一个token</p><p>5.项目中怎么解决mq消息的重复消费和消息丢失</p><p>6.rocketmq底层怎么保证消息的可靠性（记不清问的啥了）</p><p>7.mysql的隔离级别有哪些</p><p>8.rr下一个事务能读到其他事务的提交吗</p><p>9.优化慢查询有哪些思路</p><p>10.索引分类有哪些，怎么建索引，哪些场景索引会失效</p><h1>大疆</h1><h2 id="一面-21">一面</h2><h3 id="题目1-34">题目1</h3><p>1.自我介绍+项目介绍</p><p>2.ThreadLocal咱们平时用的时候，都说要注意内存泄漏，具体是怎么避免的呢?</p><p>3.聊聊Nacos吧，它的选举机制是怎么样的?跟 Raft算法有什么关系，能讲讲Raft的原理吗?</p><p>4.分库分表这个话题，你了解哪些实现方案?分了之后，分布式ID一般是怎么生成的?</p><p>5.如果我想在线程池的父子线程之间传递 ThreadLocal里的值，有什么办法吗?</p><p>6.MySQL性能调优，你一般会从哪些方面入手?有什么方法和思路?</p><p>7.布隆过滤器，能讲讲它的原理吗?在什么场景会用到它?</p><p>8.Dubbo在做RPC调用的时候，如果调用失败了，它都有哪些处理机制?比如重试、降级这些。</p><p>9.你是怎么理解线程安全这个概念的?平时在代码里是怎么处理线程安全问题的?</p><p>10.我们常说Redis单线程快，而且是线程安全的。它的线程安全具体是怎么保证的?</p><p>\11. MySQL主从同步如果出现延迟了，一般是什么原因造成的?有什么解决方案?</p><p>12.MySQL的binlog有哪几种格式?它们之间有什么区别?</p><p>13.实现分布式锁，都有哪些方案?能讲讲它们的3/4原理吗?</p><p>14.如果要你来设计一个全链路压测平台，你的设计思路是怎样的?</p><p>15.系统升级的时候，经常涉及到数据迁移，怎么才能做到平滑迁移，不影响线上业务?</p><p>16.线上服务JVM频繁Full GC，你会怎么去排查和解决?</p><p>17.数据库如果发生死锁了，一般的排查步骤是怎样的?</p><p>18.做了分库分表之后，如果某个库或表出现数据倾斜，有什么解决办法?</p><p>19.用分布式锁的时候，如果第一次加锁失败了，4/4</p><p>后续的重试机制一般怎么设计比较合理?</p><p>20.有没有遇到过MySQL执行计划选错了索引的情况?碰到了怎么处理?</p><p>21.Spring的核心是IOC，你觉得要实现一个IOC容器，关键点有哪些?</p><p>22.Spring的声明式事务很方便，它的底层原理是什么?</p><p>23.设计一个订单超时自动取消的功能，你会怎么实现?</p><p>24.在并发编程里，线程的同步</p><p>(Synchronization)和协作(Coordination)，它俩有什么区别?</p><h1>顺丰</h1><h2 id="一面-22">一面</h2><h3 id="题目1-35">题目1</h3><p>1、自我介绍<br>2、介绍一下你的项目的背景和自己负责的项目模块<br>3、结合业务对SQL优化进行讲解<br>4、项目中分库分表是怎么做的,常见的分库分表组件有哪些,原理<br>5、常见出现OOM的场景,怎么解决分析的<br>6、JVM垃圾回收机制,为什么大对象会导致系统OOM和CPU飙升<br>7、JVM使用什么方式标记这个对象回收的<br>8、标记对象回收使用引用计数了,为什么还需要有可达性分析技术来代替<br>9、项目中的订单量是多少,项目中订单相关的功能怎么实现的,详细说明一下<br>10、项目中如果出现消息挤压、重复消费的情况怎么解决<br>11、RocketMQ的原理,怎么发送消息,收到消息怎么处理<br>12、RocketMQ支持那几种类型的消息<br>13、Redis项目中具体场景是什么<br>14、Redis常见的数据结构<br>15、Redis部署方式<br>16、Redis为什么单线程还那么快</p><p>17、当接口速度慢,SQL比较慢,具体是怎么排除的,给出思路</p><h1>招银网络</h1><h2 id="一面-23">一面</h2><h3 id="题目1-36">题目1</h3><p>ava中线程安全的集合？（只答了ConcurrentHashMap）</p><p>ConcurrentHashMap如何保证线程安全？（没答好，答了节点锁）</p><p>Object类有哪些常用的方法？（答了hashcode、equals，面试官补充还有多线程、锁相关的方法）</p><p>抽象类和接口的区别？（答设计动机不同）</p><p>模版方法模式用抽象类还是接口更好？（抽象类，因为可以直接复用方法，这题答错了确实不应该）</p><p>ArrayList和LinkedList的区别？（前者基于动态数组，后者基于链表）</p><p>什么场景用ArrayList？什么场景用LinkedList？（从性能角度分析，读多写少用前者，写多读少用后者）</p><p>JVM有哪些常用参数？（答了初始堆内存、最大堆内存）</p><p>JVM的轻GC和重GC有什么区别？（轻GC只清Eden区，重GC会清整个新生代）</p><p>如何避免重GC？（没答好，答了从程序设计的角度，少new一些对象；从JVM参数的角度，扩大堆内存）</p><p>如何避免OOM？（不知道，只说了加大堆内存）</p><p>线程池的参数？（七大核心参数）</p><p>线程池的任务队列，用有界队列和无界队列的区别？（有界队列如果满了，新任务会被拒绝，无界队列则不会）</p><p>什么场景用有界队列？什么场景用无界队列？（任何场景都不推荐用无界队列，容易OOM）</p><p>MySQL三大设计范式？（学过，忘了）</p><p>InnoDB引擎的优势？（支持事务、外键、行级锁）</p><p>乐观锁和悲观锁的区别？（乐观锁假设不发生冲突，不加锁，但修改数据时需要判断数据是否被修改过，悲观锁假设发生冲突，直接加锁）</p><p>Spring如何解决循环依赖？（三级缓存，没答上来）</p><p>Spring Bean的生命周期？（没答上来）</p><p>如何设计一个切面？（不会）</p><h1>B站</h1><h2 id="一面-24">一面</h2><h2 id="二面-8">二面</h2><h3 id="题目1-37">题目1</h3><p>\1. 自我介绍<br>\2. 介绍腾讯实习做的工作，并绘制流程图，同时解答以下疑问点：<br>1）这样的设计的意图是解决什么问题？<br>2）瓶颈不是单分区吗？没有解决关键瓶颈？<br>4）exporter具体是怎么导出？<br>5）prometheus的核心指标类型？<br>6）采集-&gt;聚合-&gt;上报的相关问题？<br>\3. 设计一个基于微服务的医患问诊系统，并解答以下问题：<br>1）怎么去划分系统模块？<br>2）结算服务会向问诊服务发请求吗？<br>3）结算服务和问诊服务都是用同一个库吗？结算服务该建几个表？<br>4）如果要异步发起结算调用怎么设计？为什么不用Kafka？<br>\4. 手撕责任链模式，并解答以下问题：<br>1）责任链模式的作用是什么？<br>2）责任链模式和工厂类的区别是什么？</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>压测实际经验</title>
      <link>https://blog.tokenlen.top/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/</link>
      <guid>https://blog.tokenlen.top/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/</guid>
      <pubDate>Wed, 20 Aug 2025 16:00:00 GMT</pubDate>
      
      
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E5%8E%8B%E6%B5%8B/">压测</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC-源码分析</title>
      <link>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/</link>
      <guid>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/</guid>
      <pubDate>Thu, 14 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;线程&lt;/h1&gt;
&lt;h2 id=&quot;1-从-JVM-的角度来说一下线程和进程之间的关系&quot;&gt;1.从 JVM 的角度来说一下线程和进程之间的关系&lt;/h2&gt;
&lt;p&gt;一个进程中可以有多个线程，多个线程共享进程的&lt;strong&gt;堆&lt;/strong&gt;和**方法区 (JDK1.8</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>线程</h1><h2 id="1-从-JVM-的角度来说一下线程和进程之间的关系">1.从 JVM 的角度来说一下线程和进程之间的关系</h2><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和**方法区 (JDK1.8 之后的元空间)*<em>资源，但是每个线程有自己的*<em>程序计数器</em></em>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p>那么？为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><ol><li>程序计数器：</li></ol><p>主要作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>so,程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><ol start="2"><li>虚拟机栈和本地方法栈</li></ol><p><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><p>那么我们怎么创建线程呢？</p><p>一般来说，创建线程有很多种方式，例如继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口、使用线程池、使用<code>CompletableFuture</code>类等等。</p><p>严格来说，Java 就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><p>然后我们的run方法是直接启动线程，start方法是新建一个线程然后使用run方法来启动线程</p><h2 id="2-说一下线程的生命周期">2.说一下线程的生命周期</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕</li></ul><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p><p>当线程进入 <code>synchronized</code> 方法/块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="3-多线程">3.多线程</h2><p>为什么我们要使用多线程？</p><p>总体上呢：</p><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p><p><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><p>底层来看：</p><p><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p><p><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p><p>单核CPU实现多线程：</p><p>单核 CPU 是支持 Java 多线程的。操作系统通过时间片轮转的方式，将 CPU 的时间分配给不同的线程。尽管单核 CPU 一次只能执行一个任务，但通过快速在多个线程之间切换，可以让用户感觉多个任务是同时进行的</p><p>操作系统主要通过两种线程调度方式来管理多线程的执行：</p><ul><li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I/O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li><li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li></ul><h2 id="4-死锁">4.死锁</h2><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>四个条件：</p><p><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</p><p><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</p><p>如何判断死锁呢？</p><p>使用<code>jmap</code>、<code>jstack</code>等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，<code>jstack</code> 的输出中通常会有 <code>Found one Java-level deadlock:</code>的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用<code>top</code>、<code>df</code>、<code>free</code>等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取Java进程PID</span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"># 生成线程堆栈信息</span><br><span class="line">jstack &lt;pid&gt; &gt; thread_dump.txt</span><br><span class="line"></span><br><span class="line"># 实时监控（每3秒输出一次）</span><br><span class="line">while true; do jstack &lt;pid&gt;; sleep 3; done</span><br></pre></td></tr></table></figure><p>然后我们可以在程序中去检查死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDetector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">detectDeadlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="type">long</span>[] deadlockedThreads = threadBean.findDeadlockedThreads();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadInfo[] threadInfos = threadBean.getThreadInfo(deadlockedThreads);</span><br><span class="line">            <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;检测到死锁线程: &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mysql的话，我们可以去查看日志，找deadlock字段记录的，然后看他选择的哪一个事务进行了回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看最近的死锁信息</span><br><span class="line">SHOW ENGINE INNODB STATUS;</span><br><span class="line"></span><br><span class="line">-- 开启死锁日志记录</span><br><span class="line">SET GLOBAL innodb_print_all_deadlocks = ON;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何避免死锁呢？</p><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><ol><li>按照顺序获取锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderedLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock1) &#123; <span class="comment">// 同样先获取lock1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>超时锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeoutLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">acquired1</span> <span class="operator">=</span> <span class="literal">false</span>, acquired2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acquired1 = lock1.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!acquired1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            acquired2 = lock2.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!acquired2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行转账逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acquired2) lock2.unlock();</span><br><span class="line">            <span class="keyword">if</span> (acquired1) lock1.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去给这个锁设置一个超时的时间</p><ol start="3"><li>使用并发工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Semaphore避免死锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">// 业务逻辑，同时最多2个线程执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>锁&amp;关键字</h1><h2 id="1-Synchonized">1.Synchonized</h2><ol><li><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。在 JDK18 中，偏向锁已经被彻底废弃</li></ol><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><ol start="2"><li>monitor和对象头</li></ol><p>在HotSpot JVM中，每个Java对象都有对象头，主要包含：Markword这里记录的是锁信息的状态，GC标记，hashcode等，然后是一个Class Pointer指向Class对象的指针</p><p>Markword是根据锁的状态是变化的，根据锁的升级是进行变化的</p><p>锁的升级：</p><ul><li>无锁状态：Mark Word存储hashCode、GC年龄等，头是unused</li><li>首次进入：尝试偏向锁，Mark Word存储: 线程ID + epoch + age + 01，头是threadID:54</li><li>重入：recursions++，仍是偏向锁</li><li>如果有其他线程竞争，升级为轻量级锁，Mark Word存储: Lock Record指针 + 00，JVM在当前线程栈中创建Lock Record，markOop就是原始的markword,oop被指向的锁对象。头是ptr_to_lock_record</li><li>竞争激烈时，升级为重量级锁 ，Mark Word存储: Monitor对象指针 + 10，当升级到重量级锁时，创建Monitor对象，Mark Word指向它。头是ptr_to_monitor</li></ul><p>然后我们的线程是要去竞争锁的，首先我们会使用快速路径：尝试CAS获取锁，如果失败了就自旋等待，然后超过重试的次数的话，加入EntryList，阻塞等待。</p><p>然后我们如果阻塞了的话，这个时候需要去notify，需要从WaitSet移到EntryList，然后等待的话，需要先释放锁，然后加入等待Set，然后阻塞等待notify</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking          // 开启偏向锁（默认开启）</span><br><span class="line">-XX:BiasedLockingStartupDelay=0 // 立即启用偏向锁</span><br><span class="line">-XX:+UseHeavyMonitors          // 强制使用重量级锁（调试用）</span><br></pre></td></tr></table></figure><p>实际应用问题：</p><p>​hashCode调用**会导致偏向锁失效</p><p>​**System.identityHashCode()**会强制升级锁</p><p>​<strong>大量短期锁竞争</strong>时，禁用偏向锁可能更好</p><p>​Monitor对象**在锁释放后不会立即回收，可能影响GC</p><ol start="3"><li>偏向锁的撤销（好难哭）,JDK18已经废弃</li></ol><p>条件：</p><p>比如说线程1获取了偏向锁，然后线程2去尝试获取偏向锁，然后这个时候就会触发偏向撤销，升级为轻量级锁</p><p>调用Object.hashCode()或System.identityHashCode()，此时obj处于偏向锁状态，Mark Word存储线程ID等信息</p><p>调用hashcode就会立刻撤销偏向锁，因为偏向锁的Mark Word无法存储hashCode</p><p>然后调用wait方法，让obj等待了，立即撤销偏向锁，升级为重量级锁，因为wait需要Monitor对象支持</p><p>流程：</p><p>​检测撤销条件：检查是否为偏向锁模式，在markword获取偏向的线程ID,判断撤销类型,如果是匿名偏向直接撤销，有具体偏向线程，需要更复杂的处理</p><p>​安全点操作：在安全点执行撤销操作，</p><h2 id="2-volatile">2.volatile</h2><p>Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>他能保证可见性，禁止重排，但是不能保证原子性，比如i++</p><p>指令重排是编译器和 CPU 的优化手段，通过改变代码执行顺序来提升性能。然而，重排序可能会破坏多线程中的正确性。<br>通过插入 <strong>内存屏障</strong>（Memory Barrier），<code>volatile</code> 保证了对该变量的操作的顺序不会被重排，确保了对共享变量的写操作在前，读操作在后。这种内存屏障的插入通常是 <code>StoreLoad</code> 指令，它确保写操作的数据先写入主内存，后续的读操作必须从主内存中获取最新值</p><p>插入的是StoreLoad指令，先将cpu缓存刷新到主内存之前，不会将主内存的缓存，加载到cpu中</p><p>使用场景：</p><p><strong>停止标志位</strong>：多线程间通过共享的 <code>volatile</code> 变量来通知其他线程是否停止工作。</p><p>DCL的单例模式</p><p>AQS中的state变量，用来计数</p><h2 id="3-乐悲观锁">3.乐悲观锁</h2><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</p><p>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变</p><p>量类）。</p><h2 id="4-ReentranLock">4.ReentranLock</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。<code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁</p><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说当前线程在等待获取锁的过程中，如果其他线程中断当前线程「 <code>interrupt()</code> 」，当前线程就会抛出 <code>InterruptedException</code> 异常，可以捕捉该异常进行相应处理。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li><li><strong>支持超时</strong> ：<code>ReentrantLock</code> 提供了 <code>tryLock(timeout)</code> 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li></ul><p>总结：</p><p>ReentrantLock是Java中的显式可重入互斥锁，提供灵活的线程同步功能。它支持公平和非公平模式，允许同一线程多次获取锁而不会发生死锁。其核心特性包括：可中断的锁获取（lockInterruptibly()）、超时尝试锁（tryLock()）、以及支持多个Condition条件变量。与synchronized相比，ReentrantLock需要手动管理锁的获取和释放，适用于复杂的多线程场景。</p><p>voliate修饰变量的实现</p><ul><li>当同一个线程再次请求锁时，如果它已经持有该锁，计数器会增加，以允许多次获取而不会阻塞。</li><li>ReentrantLock维护一个等待队列，当线程无法获取锁时，会被放入该队列。每当持有锁的线程释放锁时，计数器会减少，直到归零，其他线程才能获取锁。</li></ul><h2 id="5-Semaphore">5.Semaphore</h2><p><code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始共享资源数量</span><br><span class="line">final Semaphore semaphore = new Semaphore(5);</span><br><span class="line">// 获取1个许可</span><br><span class="line">semaphore.acquire();</span><br><span class="line">// 释放1个许可</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p><p><code>Semaphore</code> 有两种模式：。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的，默认是非公平的</li></ul><p>可以使用Redis+Lua来做限流的处理</p><p>它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><h2 id="6-CountDownLatch">6.CountDownLatch</h2><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行</p><p>比如多次处理六个没有顺序关系的文件，全都处理完之后，返回给用户</p><h2 id="7-CyclicBarrier-有什么用？">7.CyclicBarrier 有什么用？</h2><p>它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CyclicBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><p>比如我们去好几个任务完成之后，给他们综合起来</p><h2 id="8-Java中的CAS">8.Java中的CAS</h2><p>CAS（Compare-And-Swap）是一种无锁的原子操作机制，广泛应用于Java的并发编程中。它通过比较内存中的实际值与预期值，决定是否将该值更新为新值。CAS的操作依赖于三个参数：当前值、预期值和新值。如果当前值等于预期值，则更新为新值；否则不做任何操作。CAS的优势是能够避免传统锁带来的性能开销，但也存在ABA问题，可以通过引入版本号或时间戳来解决。典型应用包括AtomicInteger等原子类的实现。</p><p>底层是Unsafe的CAS操作，是调用的操作系统的</p><p>在unsafe类里面静态方法尝试去先获取表示 <code>value</code> 字段在 <code>AtomicInteger</code> 对象中的内存偏移地址。</p><p>然后调用<code>compareAndSwapInt</code>方法去执行调用底层的 <code>cmpxchg</code> 指令</p><h2 id="9-ReentrantReadWriteLock">9.ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 适用于读多写少的高并发场景，特别是在需要频繁读取但较少修改的数据同步需求。它的读锁允许多个线程并行访问，而写锁则保证写操作的独占性和数据一致性。常见的应用场景包括缓存系统、配置管理和统计数据管理等。</p><h1>线程池</h1><h2 id="1-线程池的处理任务的流程">1.线程池的处理任务的流程</h2><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p><p>答案是可以的！<code>ThreadPoolExecutor</code> 提供了两个方法帮助我们在提交任务之前，完成核心线程的创建，从而实现线程池预热的效果：</p><ul><li><code>prestartCoreThread()</code>:启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；</li><li><code>prestartAllCoreThreads()</code>:启动所有的核心线程，并返回启动成功的核心线程数。</li></ul><h2 id="2-设计一个能根据任务优先级执行的线程池">2.设计一个能根据任务优先级执行的线程池</h2><p>不同的线程池会选用不同的阻塞队列作为任务队列，比如<code>FixedThreadPool</code> 使用的是<code>LinkedBlockingQueue</code>（有界队列），默认构造器初始的队列长度为 <code>Integer.MAX_VALUE</code> ，由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</p><p><code>PriorityBlockingQueue</code> （优先级阻塞队列）作为任务队列（<code>ThreadPoolExecutor</code> 的构造函数有一个 <code>workQueue</code> 参数可以传入任务队列）。</p><p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：</p><ol><li>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li><li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li></ol><p>不过会遇见以下的问题</p><p><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。</p><p>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。</p><p>由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 <code>ReentrantLock</code>），因此会降低性能。</p><p>对于 OOM 这个问题的解决比较简单粗暴，就是继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。</p><p>饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</p><h1>Future</h1><h2 id="1-一个任务需要依赖另外两个任务执行完之后再执行，怎么设计">1.一个任务需要依赖另外两个任务执行完之后再执行，怎么设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1</span></span><br><span class="line">CompletableFuture&lt;Void&gt; futureT1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T1 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// T2</span></span><br><span class="line">CompletableFuture&lt;Void&gt; futureT2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T2 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class="line">    ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用allOf()方法合并T1和T2的CompletableFuture，等待它们都完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; bothCompleted = CompletableFuture.allOf(futureT1, futureT2);</span><br><span class="line"><span class="comment">// 当T1和T2都完成后，执行T3</span></span><br><span class="line">bothCompleted.thenRunAsync(() -&gt; System.out.println(<span class="string">&quot;T3 is executing after T1 and T2 have completed.Current time：&quot;</span> + DateUtil.now()));</span><br><span class="line"><span class="comment">// 等待所有任务完成，验证效果</span></span><br><span class="line">ThreadUtil.sleep(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过 <code>CompletableFuture</code> 的 <code>allOf()</code> 这个静态方法来并行运行 T1 和 T2，当 T1 和 T2 都完成后，再执行 T3。</p><h2 id="2-使用-CompletableFuture，有一个任务失败，如何处理异常？">2.使用 CompletableFuture，有一个任务失败，如何处理异常？</h2><p>使用 <code>CompletableFuture</code>的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。</p><p>下面是一些建议：</p><ul><li>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li><li>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li><li>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li><li>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复</li></ul><h2 id="3-在使用-CompletableFuture-的时候为什么要自定义线程池？">3.在使用 CompletableFuture 的时候为什么要自定义线程池？</h2><p><code>CompletableFuture</code> 默认使用全局共享的 <code>ForkJoinPool.commonPool()</code> 作为执行器，所有未指定执行器的异步任务都会使用该线程池。这意味着应用程序、多个库或框架（如 Spring、第三方库）若都依赖 <code>CompletableFuture</code>，默认情况下它们都会共享同一个线程池。</p><p>虽然 <code>ForkJoinPool</code> 效率很高，但当同时提交大量任务时，可能会导致资源竞争和线程饥饿，进而影响系统性能。</p><p>为避免这些问题，建议为 <code>CompletableFuture</code> 提供自定义线程池，带来以下优势：</p><ul><li>隔离性：为不同任务分配独立的线程池，避免全局线程池资源争夺。</li><li>资源控制：根据任务特性调整线程池大小和队列类型，优化性能表现。</li><li>异常处理：通过自定义 <code>ThreadFactory</code> 更好地处理线程中的异常情况。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql底层分析</title>
      <link>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/</link>
      <guid>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/</guid>
      <pubDate>Thu, 14 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;索引&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>索引</h1><h2 id="1-索引的分类">1.索引的分类</h2><p>从数据结构上分类，B+树索引，hash索引，倒排索引，R树索引</p><p>从InoDB的B+树的索引分类，分为聚簇索引和非聚簇索引</p><p>从索引的性质进行分类，普通索引，主键索引，唯一索引，联合索引，全文索引，空间索引</p><h1>锁&amp;隔离级别</h1><h2 id="1-表级锁与行级锁的区别？">1.表级锁与行级锁的区别？</h2><p>MySQL 常见的两种锁是表级锁和行级锁。</p><p>表级锁锁定整个表，所有对该表的读写操作都会被阻塞，适用于低并发场景；而行级锁锁定特定行，允许其他行的操作并发进行，适用于高并发场景。</p><p>表级锁粒度大，加锁快、开销小，但并发性能差，典型代表是 MyISAM。<br>行级锁粒度小，允许多个事务并发操作不同的行，并发性高，但锁的开销大，容易出现死锁，典型代表是 InnoDB。<br>因此实际使用时，MyISAM 适合读多写少的分析场景，而 InnoDB 的行级锁更适合高并发的 OLTP 系统。</p><h2 id="2-MySQL-默认隔离级别？为何选择它？">2.MySQL 默认隔离级别？为何选择它？</h2><p>MySQL 的默认隔离级别是可重复读（REPEATABLE READ）。选择这一隔离级别是因为它能够提供较高的数据一致性，防止不可重复读，并通过 MVCC（多版本并发控制）技术支持高效的并发性能。同时，通过间隙锁（Gap Lock）解决了幻读问题，使得在一个事务中多次读取结果一致，尽管它并不能完全消除幻读的可能性。</p><p>如果选择 <strong>Serializable</strong>，虽然隔离性最强，但会强制事务串行化执行，性能开销过大。</p><p>如果选择 <strong>Read Committed</strong>，虽然性能更高，但会出现不可重复读，影响数据一致性。但是某些大厂的事务隔离级别就是RC，数据的一致性可以由MQ等组件来完成，为了提高并发量</p><h1>日志</h1><h2 id="1-MySQL-的-buffer-pool-与缓存命中率如何监控？">1.MySQL 的 buffer pool 与缓存命中率如何监控？</h2><p>MySQL 的 buffer pool 是 InnoDB 存储引擎中用于缓存数据和索引的内存区域。监控 buffer pool 和缓存命中率可以通过 <code>SHOW ENGINE INNODB STATUS</code> 查看状态变量，关键指标包括 buffer pool 的总大小、当前缓存的数据页数量等。或者是直接SHOW GLOBAL STATUS，SHOW GLOBAL STATUS LIKE ‘Innodb_buffer_pool_read%’;</p><p>视图更加友好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看 Buffer Pool 状态的摘要信息</span><br><span class="line">SELECT * FROM sys.innodb_buffer_stats_by_schema;</span><br><span class="line"></span><br><span class="line">-- 按表查看 Buffer Pool 的使用情况，用于定位热点数据</span><br><span class="line">SELECT * FROM sys.innodb_buffer_stats_by_table ORDER BY pages DESC LIMIT 10;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缓存命中率的计算方法是：命中率 = (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) × 100%。使用性能监控工具如 MySQL Enterprise Monitor 或 Percona Monitoring and Management （<strong>PMM</strong>）可以实时监控这些指标，从而优化数据库性能。</p><h1>SQL语句</h1><h2 id="1-Order-by是怎么实现的">1.Order by是怎么实现的</h2><p>在 MySQL 中，<code>ORDER BY</code> 的实现主要有三种方式：</p><ul><li><p><strong>索引有序扫描</strong>：如果 <code>ORDER BY</code> 字段能和索引顺序匹配，直接按索引返回，最优。</p></li><li><p><strong>Filesort 文件排序</strong>：无法利用索引时，MySQL 会将结果放入 sort buffer 排序，小数据在内存，大数据写磁盘；它有单路和双路两种实现方式。</p><ul><li>双路：扫描符合条件的行 → 将排序字段和主键 ID 放到 sort buffer → 排序 → 再根据主键 ID 回表取数据。需要两次数据访问，性能差。</li><li>单路：直接将排序字段和要返回的所有列一起放入 sort buffer → 排序 → 直接返回。回表减少了，需要更大内存，sort buffer 容量不够时会写磁盘临时文件。</li></ul></li><li><p><strong>优先队列排序</strong>：当 <code>ORDER BY</code> 搭配 <code>LIMIT N</code> 时，可能只维护一个 N 大小的堆，提高效率。结果集很大，但只取前 N 条。</p></li></ul><p>调优：</p><p>尽量让 <code>ORDER BY</code> 和索引顺序匹配，避免 filesort。</p><p>如果必须 filesort，调大 <code>sort_buffer_size</code>、<code>tmp_table_size</code>，减少磁盘落盘。</p><p>避免 <code>SELECT *</code>，减少 sort buffer 内存占用。</p><p>大数据排序时考虑加索引或改写 SQL。</p><h2 id="2-MySQL-如何存储-IP-地址？">2.MySQL 如何存储 IP 地址？</h2><p>因为我们的IP地址是有两种的IPV4 IPV6</p><ul><li><p><strong>VARCHAR</strong>：直接存 <code>'192.168.0.1'</code>，简单直观，但存储和查询效率差。</p></li><li><p><strong>UNSIGNED INT</strong>：用 <code>INET_ATON/INET_NTOA</code> 把 IPv4 转整数（4B），空间小、查询快，但只支持 IPv4。使用Mysql提供的两个函数，</p></li><li><pre><code>INET_ATON('192.168.0.1')` → `3232235521INET_NTOA(3232235521)` → `'192.168.0.1'</code></pre></li><li><p><strong>VARBINARY(16)</strong>：用 <code>INET6_ATON/INET6_NTOA</code> 存二进制，既支持 IPv4 又支持 IPv6（推荐做法）。使用函数</p></li><li><p><code>INET6_ATON('2001:db8::1')</code> → 二进制（16B）</p><p><code>INET6_NTOA(binary_value)</code> → 字符串 IP</p></li></ul><p>如果只考虑 IPv4，<code>INT</code> 最优；如果要兼容 IPv6，推荐 <code>VARBINARY(16)</code>。</p><h2 id="3-MySQL-一行记录是怎么存储的？">3.MySQL 一行记录是怎么存储的？</h2><p><strong>InnoDB</strong> 是最常用的存储引擎，数据以 <strong>页（Page，16KB）</strong> 为最小单位。</p><p>一个页中包含多个行记录。页内部有 <strong>页头、页目录、行数据</strong> 等。</p><p>一行记录的结构主要包括：行头信息（删除标记、指针）、事务信息（事务 ID、回滚指针）、NULL 标记位、变长字段长度列表以及实际字段值。<br>如果某行太大（例如包含 TEXT/BLOB），就会发生行溢出，行内只存前 768 字节和指针，其余内容存放在溢出页。<br>InnoDB 还支持 Compact、Dynamic、Compressed 等多种行格式，Compact 是默认的。</p><h2 id="事务">事务</h2><h2 id="1-Mysql长事务可能带来哪些问题？">1.Mysql长事务可能带来哪些问题？</h2><p>首先，它会长时间持有锁，阻塞其他事务，影响并发性能；<br>其次，InnoDB 的 MVCC 机制需要依赖 undo log 保存历史版本，长事务不提交会导致 undo log 膨胀，版本链变长，阻止 purge 线程清理，造成表膨胀和性能下降；<br>同时也会增加死锁概率和主从延迟。<br>因此在开发中我们要控制事务范围，及时提交，并通过监控和超时机制避免长事务。</p><p>比如：</p><ul><li><strong>及时提交事务</strong>：避免在事务中执行不必要的逻辑，比如用户交互、网络请求。</li><li><strong>控制事务大小</strong>：大批量操作要拆分成多个小事务。</li><li>SELECT * FROM information_schema.INNODB_TRX \G;监控长事务</li><li><strong>设置超时</strong>：<ul><li><code>innodb_lock_wait_timeout</code>：控制锁等待时间。</li><li><code>wait_timeout</code> / <code>interactive_timeout</code>：控制会话空闲超时。</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试-深入源码</title>
      <link>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/</link>
      <guid>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/</guid>
      <pubDate>Mon, 11 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;javase源码详解&lt;/h1&gt;
&lt;h2 id=&quot;1-和equal-和hashcode&quot;&gt;1.==和equal()和hashcode&lt;/h2&gt;
&lt;p&gt;==和equals函数对于基本类型来说， = =</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>javase源码详解</h1><h2 id="1-和equal-和hashcode">1.==和equal()和hashcode</h2><p>==和equals函数对于基本类型来说， = = 比较是值，equals不能比较基本类型</p><p>对于包装类型来说，== 比较的是对象的引用，就是对象的内存地址。而<code>equals()</code>通常被重写以比较对象的值。</p><p>需要注意的是，像Interger这种包装类具有缓存机制，如果在缓存的范围，==的结果可能就是true，因为他们都是指向常量池的同一个对象</p><p>对于引用类型来说，==比较的是其对象的内存地址，equals要分为两个情况，看这个类型到底重写了equals函数了没，重写了就按重写的比较，比如String类型，他的equals就是比较的对象的值。然后没有重写的话，equals内部还是使用 ==来比较。没有什么区别。还是比较的对象的内存地址</p><p>hashcode函数的作用是获取哈希码，然后确定该对象再hash表中的位置，比如hashmap,hashset,布隆过滤器等都用到了hashcode</p><p>hasecode分为好几种哈希函数，有取模的，有进行位运算的。我们在布隆过滤器中使用最好是使用两种hash函数来确定位的位置。</p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的</p><p>然后hashcode相同，equals不一定相同。hashcode不相同，这个对象一定不相同。这样的话，我们可以将hashcode和equals函数相结合。我们先用hash函数来判断，然后再用equals判断</p><p>如果这个对象真的不相同的话，那我们就可以用运行速度快的hash函数早判断。然后出现hash碰撞的时候我们再用equals函数来确定是不是真的相同。这样大大提高了效率，因为hash函数的运算是比equals快的。这也是hashmap,hashset，布隆过滤器的设计原理。</p><p>因此，我们在重写equals的时候，hashcode也必须重写，否则就会出现equals相等，但是hash不相同。就会出现重复值的问题</p><h2 id="2-BigDecimial处理精度丢失的问题">2.BigDecimial处理精度丢失的问题</h2><p><code>BigDecimal</code>是Java中用于处理高精度数值计算的类，尤其适用于金融、科学计算等对精度要求极高的场景。</p><p>最关键的就是两个字段：</p><ul><li><code>intVal</code>: 一个<code>BigInteger</code>对象，用于存储数值的<strong>非标度值 (unscaled value)</strong>。简单来说，就是去掉小数点后的整数值。</li><li><code>scale</code>: 一个<code>int</code>类型的整数，表示<strong>标度 (scale)</strong>。标度指的是小数点后的位数。例如，对于数值 123.45，<code>intVal</code>是12345，<code>scale</code>是2。</li></ul><p><code>BigDecimal</code> <strong>使用整数来表示数值，避免了浮点数的二进制表示法引入的精度问题。</strong> 它通过<code>scale</code>来记录小数点的位置，从而实现对小数的精确表示。</p><p>BigDecimal的运算都是基于BigInterger来实现的</p><ul><li><p>加减法的时候，调整两个数的sacle，对齐标度，然后将intval相加减，最好创建一个新的BigDecial对象，intval为相加减的结果，scale为调整后的标度</p></li><li><p>乘法，将两个数的intval想乘，然后scale为两个BigDecimal的scale的和</p></li><li><p>除法是最复杂的操作，因为可能产生无限循环小数，<code>BigDecimal</code>需要提供多种舍入模式 (RoundingMode) 来控制精度，比如</p><ul><li><p><code>ROUND_UP</code>: 向上舍入</p></li><li><p><code>ROUND_DOWN</code>: 向下舍入</p></li><li><p><code>ROUND_CEILING</code>: 向正无穷方向舍入</p></li><li><p><code>ROUND_FLOOR</code>: 向负无穷方向舍入</p></li><li><p><code>ROUND_HALF_UP</code>: 四舍五入 (大于等于0.5向上舍入)</p></li><li><p><code>ROUND_HALF_DOWN</code>: 五舍六入 (大于0.5向上舍入)</p></li><li><p><code>ROUND_HALF_EVEN</code>: 银行家舍入 (四舍六入，五看奇偶，偶舍奇入)<code>BigDecimal</code>会根据指定的舍入模式，计算出精确的结果，并截断到指定的精度。</p></li></ul></li></ul><p>但是会出现很多个BigDecimal对象：Bigdecimal 是一个immutable类，每次计算都会new一个新的对象。如果在一个循环内多次使用bigdecimal，会生成很多对象，影响性能，建议如果在循化内不要使用string 构造出bigdecimal, 否则生成大量的string对象和bigdecimal对象</p><h2 id="3-变量">3.变量</h2><p>成员变量&amp;&amp;局部变量对比–变量存储的内存地址对应的任意随机值</p><ul><li>定义：成员变量是属于类的，局部变量是在代码块或者方法之中的</li><li>存储：成员变量如果是使用static的话，那这个成员变量属于类，没有的话，在堆。局部变量在栈，栈之中维护了一个局部变量表</li><li>生存时间：成员变量是对象的一部分，跟对象的生命周期一样，局部变量跟他的方法的生命周期一样</li><li>默认值：成员变量没有被赋值的话，一般都会是类型的默认值，除非是final修饰的，必须显示的赋值，局部变量不赋值会报错。</li></ul><table><thead><tr><th>特性</th><th>成员变量 (Instance Variable)</th><th>成员变量 (Static Variable)</th><th>局部变量 (Local Variable)</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>属于类的属性，在类中方法外定义。</td><td>属于类的静态属性，在类中方法外定义，用<code>static</code>修饰。</td><td>在方法、代码块（如<code>if</code>、<code>for</code>语句内部）中定义的变量。</td></tr><tr><td><strong>存储</strong></td><td>存储在堆内存（Heap）中，作为对象的一部分。</td><td>存储在方法区（Method Area）或元空间(Metaspace)中。（JDK8+之后静态变量从方法区移动到了堆中，但逻辑概念上仍与类相关联）</td><td>存储在Java虚拟机栈（Java Virtual Machine Stack）的栈帧（Stack Frame）的局部变量表中。</td></tr><tr><td><strong>生命周期</strong></td><td>随着对象的创建而创建，随着对象的销毁而销毁。</td><td>随着类的加载而创建，随着类的卸载而销毁。（实际上与类的 Class 对象关联）</td><td>随着方法的调用而创建，随着方法的执行结束而销毁。</td></tr><tr><td><strong>默认值</strong></td><td>存在默认值。如果没有显式赋值，会赋予类型的默认值（如<code>int</code>为0，<code>boolean</code>为<code>false</code>，<code>Object</code>为<code>null</code>）。</td><td>static 变量在类加载的准备阶段就会赋默认值. 如果没有显式赋值，会赋予类型的默认值（如<code>int</code>为0，<code>boolean</code>为<code>false</code>，<code>Object</code>为<code>null</code>）。</td><td>不存在默认值。<strong>必须显式赋值</strong>后才能使用，否则编译报错。</td></tr><tr><td><strong>final修饰</strong></td><td><code>final</code>修饰的成员变量必须在对象创建前（构造器或声明时）显式赋值，之后不能修改。</td><td><code>final static</code>修饰的成员变量必须在类加载完成前（静态代码块或声明时）显式赋值，之后不能修改。</td><td><code>final</code>修饰的局部变量必须在使用前显式赋值，之后不能修改。</td></tr><tr><td><strong>线程安全</strong></td><td>线程不安全，每个对象都有一份独立的成员变量副本，如果多个线程修改同一个对象的成员变量，可能导致数据不一致。</td><td>线程安全，所有该类的对象共享同一个静态变量，需要进行同步处理才能保证线程安全。</td><td>线程安全，局部变量只在当前线程的栈帧中有效，不同线程之间互不影响。</td></tr></tbody></table><h2 id="4-String家族三位">4.String家族三位</h2><p>String家族的三位分别是String StringBuffer StringBulider，除去String,剩下的两个都是继承自AbstractStringBuilder</p><p>其中String是不可变的，StringBuffer和StringBulider是可变的，他们都有append等方法来操作字符串</p><p>不同的是StringBuffer是线程安全的，通过同步锁加到方法上，可以多线程操作，而StringBulider是线程不安全的，一般单线程操作。因此StringBulider的性能是最高的</p><p>那么为什么String是不可变的呢？</p><p>String类中使用final来修饰字符串数组来，导致他的引用类型不能再指向其他的对象，并且数组的私有的。并且没有提供暴露这个字符串的方法</p><p>final导致String不能被继承，进而避免了子类破坏String</p><p>字符串拼接使用什么？变量少的时候使用+，然后变量多的时候使用StringBulider，防止在循环中使用，建立多个StringBulider对象</p><p>在我们JVM的堆中，存在一个字符串常量池，主要就是为了避免字符串的重复的问题</p><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>我们去new一个新的字符串的时候，会看字符串常量池有没有这个字符串，有的话，直接返回该字符串的引用。没有的话，JVM会在常量池中创建该字符，然后返回他的引用，也就是说我们新建了两个对象</p><h2 id="5-常见的IO-拷贝">5.常见的IO&amp;&amp;拷贝</h2><p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p><p>我们的用户进程想要进行IO操作的话，必须通过系统调用来访问内核空间，也就是拷贝，从用户态转变为内核态进行拷贝</p><p>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</p><p>常见的IO模型：</p><p><strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><p>在我们的java中，有三种常见的IO</p><p>BIO：属于同步堵塞的IO，同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。在客户端连接数量不高的情况下，是没问题的。但是高了就没办法了</p><p>NIO：Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>同步非阻塞 IO，发起一个 read 调用，如果数据没有准备好，这个时候应用程序可以不阻塞等待，而是切换去做一些小的计算任务，然后很快回来继续发起 read 调用，也就是轮询。这个<br>轮询不是持续不断发起的，会有间隙, 这个间隙的利用就是同步非阻塞 IO 比同步阻塞 IO 高效的地方。</p><p>但是这样有问题的，程序需要不断进行IO系统轮询来判断是不是准备好了,然后就出现了我的IO多路复用</p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><p>线程通过<code>select</code>、<code>poll</code>或<code>epoll</code>等系统调用，<strong>监听多个文件描述符（File Descriptor, FD）</strong>，一旦某个FD就绪（可读、可写），就通知应用程序。</p></li><li><p><strong>select 调用</strong>：最大连接数有限制（通常是1024），由<code>FD_SETSIZE</code>决定。每次调用都需要将FD集合从用户空间拷贝到内核空间，开销大。内核采用轮询方式检查FD是否就绪，效率低。</p></li><li><p>poll调用：取消了最大连接数的限制。同样需要将FD集合拷贝到内核空间。</p></li><li><p><strong>epoll 调用</strong>：基于事件驱动，只关注就绪的FD，避免了无意义的轮询。采用红黑树存储FD，查找效率高。使用<code>mmap</code>技术，减少了用户空间和内核空间之间的数据拷贝。</p></li></ul><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>而我们java中的NIO,最重要的三个组件，<strong>Selector</strong> ，Buffer，Channel</p><p>通过<strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。然后数据通过Channel让客户端将数据写入到Buffer中去</p><ul><li><code>Channel</code>: <strong>代表一个连接通道，负责数据的读写。</strong> <code>Channel</code> 类似于传统 I/O 中的流 (Stream)，但更加灵活，可以进行双向数据传输。</li><li><code>Buffer</code>: <strong>缓冲区，用于存储数据。</strong> NIO 使用缓冲区来读写数据，而不是直接操作流。 Java NIO 支持多种类型的缓冲区，例如 <code>ByteBuffer</code>、<code>CharBuffer</code>、<code>IntBuffer</code> 等。</li><li><code>Selector</code>: <strong>多路复用器，用于监听多个<code>Channel</code>的事件。</strong> 一个 <code>Selector</code> 可以同时监听多个 <code>Channel</code> 的连接、读、写等事件。 通过 Selector， 只需要一个线程即可管理多个 Channel，实现高效的 I/O 多路复用。</li><li><strong>Reactor模式和Proactor模式：</strong> 是两种常用的并发编程模式，分别对应I/O多路复用和异步I/O。 Netty 采用了 Reactor模式。</li></ul><p>AIO：</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>然后我们需要数据进行传输的时候，就需要对数据进行拷贝。比如用户进程在从硬盘里传输数据的时候，需要从用户态转为内核态然后才能进行拷贝。这样的话，效率比较慢，然后我们就出现了零拷贝技术</p><p>传统的数据传输流程中，用户数据通常会经过如下多次拷贝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘 → 内核缓冲区 → 用户态 → Socket 缓冲区 → 网卡</span><br></pre></td></tr></table></figure><p>一般来说文件拷贝是要拷贝四次的，</p><p>当用户进程调用<code>read()</code>，用户态无法调用内核态的设备，只能触发系统调用（IO）。这时计算机需要从用户态切换为内核态。</p><p>到达内核态之后，计算机通过<code>DMA</code>控制器将数据从磁盘读取出来，放到内核的缓冲区。完成第一次拷贝。</p><p>CPU需要将缓冲区的数据拷贝到用户态的缓冲区，完成第二次拷贝，也是read()函数的返回。这时计算器需要从内核态切换为用户态。</p><p>因为最终的数据需要通过网卡输出，所以用户进程就需要调用<code>write()</code>函数，CPU将用户缓冲区的数据拷贝到<code>Socket</code>缓冲区，完成第三次拷贝。同时需要再次触发系统调用。这时计算机又需要从用户态切换为内核态。</p><p><code>DMA</code>控制器把数据从<code>Socket</code>缓冲区，拷贝到网卡设备输出，至此完成第四次拷贝。同时需要将内核态切换为用户态，<code>write()</code>函数返回。</p><p>而“零拷贝”技术通过内核优化和 API 支持，能<strong>避免数据在用户态与内核态间的多次拷贝</strong>，从而提升性能。常用技术：</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td><code>mmap</code></td><td>将文件映射到内存地址空间，避免文件拷贝</td></tr><tr><td><code>sendfile</code></td><td>直接将文件从磁盘发送到 Socket，避免数据进入用户态</td></tr><tr><td><code>writev</code></td><td>批量写入多个内存区域，减少系统调用</td></tr><tr><td><code>DirectByteBuffer</code>（Java NIO）</td><td>Java 堆外内存，提高 I/O 性能</td></tr></tbody></table><p>mmap</p><ul><li><code>mmap</code>将一个文件或者其他对象映射到进程的地址空间，实现<strong>文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一映射关系</strong>。应用程序可以直接读写映射的内存区域，而<strong>不需要进行显式的<code>read</code>和<code>write</code>系统调用</strong>。</li><li><strong>原理：</strong> <code>mmap</code> 减少了数据在内核空间和用户空间之间的拷贝。 只需要从磁盘拷贝到内核缓冲区，然后用户进程直接从内核缓冲区读取数据，而无需再拷贝到用户空间。</li><li><strong>适用场景：</strong> 适用于需要频繁读写同一文件的场景，例如大型数据库、共享内存等。</li><li>存在的问题：<ul><li><code>mmap</code> 对文件读写仍然需要两次上下文切换。</li><li>如果多个进程同时对同一文件进行<code>mmap</code>映射，可能会导致数据不一致的问题。</li></ul></li><li><strong>使用场景:</strong> 常用于读取静态资源。</li></ul><p><strong>sendfile()</strong></p><p>sendfile() 系统调用允许将数据从一个文件描述符 (例如， 文件)  直接传输到另一个文件描述符 (例如， Socket)。  避免了数据在用户空间和内核空间之间的拷贝。</p><ol><li>用户进程调用 <code>sendfile()</code> 系统调用， 指定输入和输出文件描述符。</li><li>数据通过 DMA 从磁盘读取到内核缓冲区。</li><li>数据直接从内核缓冲区拷贝到 Socket 缓冲区，或者更优的方式是：只有描述符信息从内核缓冲区拷贝到socket缓冲区。</li><li>数据通过 DMA 从 Socket 缓冲区传输到网卡。</li></ol><p>静态文件服务器（例如 Nginx）通常使用 sendfile() 来将静态文件发送给客户端。只能适用于数据从文件传输到Socket的场景，范围有限</p><p><strong>splice() (管道):</strong></p><p>splice() 系统调用允许在两个文件描述符之间移动数据，而不需要在用户空间和内核空间之间进行复制。</p><ol><li>创建两个管道(pipe)对象</li><li>调用 splice() 系统调用,将数据从输入文件描述符读取到第一个管道.</li><li>调用 splice() 系统调用,将数据从管道数据写到socket 。</li></ol><p>适用于需要数据传输与转换(类似于Linux的管道操作)的场景</p><p><strong>Direct I/O</strong>：</p><p>Direct I/O 允许用户进程绕过内核缓冲区 (Page Cache)， 直接访问磁盘。</p><ol><li>用户进程发起 Direct I/O 请求。</li><li>数据通过 DMA 直接从磁盘传输到用户进程的缓冲区。</li></ol><ul><li>需要用户进程自己管理缓存，增加了开发的复杂性。</li><li>可能影响系统的整体性能， 因为绕过了 Page Cache。 （Page Cache 可以缓存热点数据，提高访问速度）。</li></ul><p>大型数据库（例如 Oracle）通常使用 Direct I/O 来进行数据读写， 因为数据库有自己的缓存管理机制。</p><p><strong><code>DirectByteBuffer</code> (Java NIO)：</strong></p><ul><li>是Java NIO 提供的一种堆外内存分配方式，它<strong>允许JVM直接在操作系统本地内存（堆外内存）中分配缓冲区，而不是在JVM堆中分配。</strong></li><li><strong>避免了数据从JVM堆内存拷贝到直接内存 (Native memory) 的过程。</strong></li><li><strong>适用场景：</strong> 适用于需要高效I/O的场景，例如网络服务器、大数据处理等。</li><li><strong>原理：</strong> <code>DirectByteBuffer</code>并不是真正意义上的零拷贝，因为它仍然需要在用户空间和内核空间之间进行数据拷贝。 但是，它可以减少一次数据拷贝，从而提高I/O性能。 通过调用操作系统的<code>read</code>方法，将数据从IO端口读取到这个直接内存。</li></ul><p>好处：</p><ul><li><strong>减少数据拷贝次数：</strong> 降低CPU的开销， 提高I/O效率。</li><li><strong>减少上下文切换次数：</strong> 降低系统开销， 提高并发能力。</li><li><strong>提高数据传输速度：</strong> 缩短响应时间， 提供更好的用户体验。</li></ul><h2 id="6-Java中的值传递">6.Java中的值传递</h2><ul><li><strong>值传递</strong>：方法接收的是实参值的拷贝，会创建副本。</li><li><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li></ul><p>但是在java中只有值传递</p><p>比如我们设定一个简单的swap方法，交换值得方法，num1=a num2=b</p><p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p>再比如</p><p>我们设定一个swap方法，交换两个Person参数</p><p>然后我们发现<code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p><p>java值传参：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h2 id="7-序列化-反序列化">7.序列化&amp;&amp;反序列化</h2><ul><li><strong>序列化</strong>：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程</li></ul><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化</li></ul><p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。</p><p>然后我们有好几种序列化的方式,jdk自带的效率低且有安全问题，比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><ul><li><p>jdk自带的序列化方式，只需要实现Serializable接口即可，我们一般会加上一个私有静态final的变量，serialVersionUID。是类似于版本控制的效果，如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。<code>serialVersionUID</code> 是一个特例，<code>serialVersionUID</code> 的序列化做了特殊处理。关键在于，<code>serialVersionUID</code> 不是作为对象状态的一部分被序列化的，而是被序列化机制本身用作一个特殊的“指纹”或“版本号”</p></li><li><p>对于我们不想进行序列化的变量，可以使用<code>transient</code> 关键字修饰。阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。<code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。除了serialVersionUID以外。</p></li><li><p>Kryo ，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。使用的时候也是需要实现Serializer接口，然后分别去重写serialize方法和deserialize方法</p></li><li><p>Protobuf，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p></li><li><p>Protostuff，protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p></li></ul><p>这些反序列化的话，会有漏洞</p><p>许多序列化协议都存在反序列化漏洞，攻击者可以通过构造恶意的序列化数据，在反序列化过程中执行任意代码，从而控制目标系统。比如kryo</p><ul><li>防止反序列化漏洞的措施：<ul><li>避免使用存在已知漏洞的序列化协议。</li><li>对序列化数据进行签名或加密，防止篡改。</li><li>使用白名单机制，只允许反序列化特定类型的对象。</li><li>限制反序列化的深度和复杂度，防止资源耗尽。</li></ul></li></ul><h2 id="8-Unsafe解析">8.Unsafe解析</h2><p><code>Unsafe</code> 是位于 <code>sun.misc</code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等</p><p><code>Unsafe</code> 提供的这些功能的实现需要依赖本地方法（Native Method），本地方法使用 <strong><code>native</code></strong> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 <strong>本地代码</strong>。</p><p><code>Unsafe</code> 类为一单例实现，提供静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code>实例。这个看上去貌似可以用来获取 <code>Unsafe</code> 实例。但是，当我们直接调用这个静态方法的时候，会抛出 <code>SecurityException</code> 异常</p><p>这是因为在<code>getUnsafe</code>方法中，会对调用者的<code>classLoader</code>进行检查，判断当前类是否由<code>Bootstrap classLoader</code>加载，如果不是的话那么就会抛出一个<code>SecurityException</code>异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。</p><p>为什么这个类这么严格？<code>Unsafe</code> 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。</p><p>那我们该怎么去获取unsafe的实例呢？</p><ol><li>利用反射获得 Unsafe 类中已经实例化完成的单例对象 <code>theUnsafe</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>从<code>getUnsafe</code>方法的使用限制条件出发，通过 Java 命令行命令<code>-Xbootclasspath/a</code>把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取 Unsafe 实例。</li></ol><p>Unsafe的功能多种多样，比如内存操作，内存屏障，对象操作，数据操作，CAS 操作，线程调度，Class 操作，系统信息</p><ol><li>内存操作：</li></ol><p>在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure><p>通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p><p>那我们为什么要使用堆外内存？</p><p>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</p><p>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</p><p>比如：<code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。类似实现了零拷贝的功能，但是其实他并没有实现零拷贝。创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放</p><ol start="2"><li>内存屏障：</li></ol><p>编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p><p>比如我们的voliate关键词就是通过内存屏障，来保证了禁止重排。主要是就是保证读写的屏障</p><p>内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能</p><p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p><p>应用：</p><p><code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p><p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p><ol start="3"><li>对象操作：</li></ol><p>对象成员属性的内存偏移量获取，以及字段属性值的修改</p><p>Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。</p><p>基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）</p><p><code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。</p><p><code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p><p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。</p><p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型。</p><p>其中：</p><ul><li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li><li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li></ul><p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p><ol start="4"><li>对象实例化：</li></ol><p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p><p><code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但<code>allocateInstance</code>方法仍然有效。</p><p>比如：</p><p>new 机制有个特点就是当类只提供有参的构造函数且无显式声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</p><p>Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用</p><p>5.数组操作：</p><p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回数组中第一个元素的偏移地址</span><br><span class="line">public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);</span><br><span class="line">//返回数组中一个元素占用的大小</span><br><span class="line">public native int arrayIndexScale(Class&lt;?&gt; arrayClass);</span><br></pre></td></tr></table></figure><p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code>、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作</p><ol start="6"><li>CAS</li></ol><p>CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p><p>在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p><p>如果 CAS 操作成功（返回 true），则打印 <code>targetValue</code> 并退出循环。</p><p>如果 CAS 操作失败，或者 <code>currentValue</code> 不满足条件，则当前线程会继续循环（自旋），并通过 <code>Thread.yield()</code> 尝试让出 CPU，直到成功更新并打印或者条件满足。</p><p>这样我们就可以通过CAS来实现多个线程1-9的顺序输出,a=0</p><p>线程1是 i&lt;5的情况，线程2是i&lt;10的情况</p><p>我们的CAS加的是(a,i-1,i);所以的话，线程一就是0-4的输出，线程2就是5-9.然后使用之前，我们要把获取unsafe实例和获取a字段的内存偏移量给静态加载进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 获取 a 字段的内存偏移量</span></span><br><span class="line">        fieldOffset = unsafe.objectFieldOffset(CasTest.class.getDeclaredField(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>线程调度</li></ol><p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure><p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常</p><p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code>、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code>、<code>unpark</code> 方式实现的</p><p>就是通过这个实现了CLH队列,减少了在等待队列里面消耗等待的时间</p><ol start="8"><li>Class操作</li></ol><p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取静态属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取静态属性的对象指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断类是否需要初始化（用于获取类的静态属性前进行检测）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure><p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code></p><h2 id="9-SPI机制">9.SPI机制</h2><h2 id="10-语法糖">10.语法糖</h2><h2 id="11-新特性（Java17-Java21）">11.新特性（Java17&amp;&amp;Java21）</h2><h3 id="1-虚拟线程-JDK21">1.虚拟线程 JDK21</h3><p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p><p>优点：</p><p><strong>非常轻量级</strong>：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</p><p><strong>简化异步编程</strong>： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。</p><p><strong>减少资源开销</strong>： 由于虚拟线程是由 JVM 实现的，它能够更高效地利用底层资源，例如 CPU 和内存。虚拟线程的上下文切换比平台线程更轻量，因此能够更好地支持高并发场景。</p><p>缺点：</p><p><strong>不适用于计算密集型任务</strong>： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。</p><p><strong>与某些第三方库不兼容</strong>： 虽然虚拟线程设计时考虑了与现有代码的兼容性，但某些依赖平台线程特性的第三方库可能不完全兼容虚拟线程。</p><p>创建方法：</p><ol><li><strong>使用 <code>Thread.startVirtualThread()</code> 创建</strong></li><li><strong>使用 <code>Thread.ofVirtual()</code> 创建</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CustomThread</span> <span class="variable">customThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomThread</span>();</span><br><span class="line">    <span class="comment">// 创建不启动</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">unStarted</span> <span class="operator">=</span> Thread.ofVirtual().unstarted(customThread);</span><br><span class="line">    unStarted.start();</span><br><span class="line">    <span class="comment">// 创建直接启动</span></span><br><span class="line">    Thread.ofVirtual().start(customThread);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用 <code>ThreadFactory</code> 创建</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustomThread customThread = new CustomThread();</span><br><span class="line">    ThreadFactory factory = Thread.ofVirtual().factory();</span><br><span class="line">    Thread thread = factory.newThread(customThread);</span><br><span class="line">    thread.start();</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>使用<code>Executors.newVirtualThreadPerTaskExecutor()</code>创建</strong></li></ol><h2 id="12-源码详解ArrayList">12.源码详解ArrayList</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。一开始先分配一个空间，然后后面快满了再进行扩容。list 列表的结尾会预留一定的容量空间</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><p><code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。</p><p>扩容机制的分析：</p><ul><li><p>默认的初始容量大小就是10，一般采用默认构造函数，创造一个空列表，<strong>实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p></li><li><p>带初始容量的构造参数，就使用用户指定的初始容量。&gt;0就用指定的，=0就创建空数组，&lt;0抛出异常</p></li><li><p>构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</p></li></ul><p>扩容的参数是**<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>**所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><h2 id="13-TreeMap">13.TreeMap</h2><p><code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</p><ul><li><p><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于等于、小于等于、严格大于、严格小于给定键的最接近的键值对。</p></li><li><p><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</p></li><li><p><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</p></li><li><p><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素</p></li></ul><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p>指定排序的比较器，重写compare方法</p><h2 id="14-HashMap底层分析-问题解析">14.HashMap底层分析&amp;问题解析</h2><ol><li>源码分析</li></ol><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p>通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置，使用位运算的计算速度快，而且HashMap的的容量都是2的次幂，然后这样我们就可以使用位运算，最高位的一个标志。根据这个来确定是否在原位置，0不动，1+当前的长度</p><p>负载因子：一般都是0.75，这是一个经验值，**loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。**长度的默认为16</p><ol start="2"><li>HashMap 的长度为什么是 2 的幂次方？</li></ol><p>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</p><p>可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</p><p>扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</p><ol start="3"><li>HashMap 多线程操作导致死循环问题</li></ol><p>JDK1.7 之前的版本，在多线程下，使用头插法容易形成环形链表。JDK1.8 版本的 HashMap 采用了尾插法，避免了环形问题，但多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题</p><ol start="4"><li>ConcurrentHashMap1.7 <strong>Segment 数组 + HashEntry 数组 + 链表</strong></li></ol><p>初始化逻辑：</p><ul><li><p>必要参数校验。</p></li><li><p>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></p></li><li><p>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</p></li><li><p>记录 <code>segmentShift</code> 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</p></li><li><p>记录 <code>segmentMask</code>，默认是 ssize - 1 = 16 -1 = 15.</p></li><li><p><strong>初始化 <code>segments[0]</code></strong>，<strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩</p></li></ul><p>根据put计算到key的位置，获取指定的Segment,如果为空那么初始化Segment</p><ol><li><p>检查计算得到的位置的 <code>Segment</code> 是否为 null.</p><p>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</p><p>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null.</p><p>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</p><p>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code></p></li><li><p><code>Segment.put</code> 插入 key,value 值。</p></li></ol><p>ConcurrentHashMap1.8 <strong>Node 数组 + 链表 / 红黑树</strong></p><p>的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化，其他线程需要自旋等待</li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化</li></ol><p>put方法：</p><p>根据 key 计算出 hashcode 。</p><p>判断是否需要进行初始化。</p><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p><p>如果都不满足，则利用 synchronized 锁写入数据。</p><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务论坛设计方案</title>
      <link>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/</link>
      <guid>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/</guid>
      <pubDate>Sat, 09 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;技术栈应用&lt;/h1&gt;
&lt;p&gt;Nacos—服务注册&lt;/p&gt;
&lt;p&gt;OpenFeign—RPC&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seata&lt;/strong&gt; —分布式事务&lt;/p&gt;
&lt;h1&gt;真正内容设计亮点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于 Sa-Token</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>技术栈应用</h1><p>Nacos—服务注册</p><p>OpenFeign—RPC</p><p><strong>Seata</strong> —分布式事务</p><h1>真正内容设计亮点</h1><ul><li><strong>基于 Sa-Token 构建统一 OAuth2 认证中心</strong>，实现账号密码、短信验证码、第三方平台（微信/支付宝/GitHub 等）等多种登录方式；通过自定义 Token 生成与权限控制，实现细粒度角色/权限管理；集成 Redis 实现分布式会话共享，支持多微服务统一认证与单点登录（SSO）；结合注解与全局拦截器完成接口级鉴权，有效提升系统安全性与扩展性。</li><li>基于 <strong>Seata 分布式事务框架</strong> 实现跨微服务数据一致性保障，支持 AT/Saga/TCC 多事务模式；通过 Feign 拦截器实现全局事务上下文透传，结合异常分类回滚策略提升稳定性；引入事务监控与告警系统，支持事务状态实时追踪与自动补偿，显著降低人工介入成本。</li><li>设计并实现 <strong>基于 Spring Cloud Gateway 的全局认证过滤器</strong>，支持 JWT 多端统一认证、白名单动态管理、用户上下文透传；集成 Redis 实现 Token 黑名单与防重放攻击机制，提升系统安全性；引入链路追踪 ID 与异常告警体系，支持全链路请求跟踪与安全事件快速响应。</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务论坛问题收集</title>
      <link>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/</link>
      <guid>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/</guid>
      <pubDate>Sat, 09 Aug 2025 16:00:00 GMT</pubDate>
      
      
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringCloud-组件介绍</title>
      <link>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/</link>
      <guid>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/</guid>
      <pubDate>Fri, 08 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;p&gt;Spring Cloud 是一系列框架的有序集合。&lt;/p&gt;
&lt;p&gt;Spring Cloud 利用 Spring Boot</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本概念</h1><p>Spring Cloud 是一系列框架的有序集合。</p><p>Spring Cloud 利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>它将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><ul><li><p><strong>Spring Cloud Netflix</strong>：重要组件之一，与各种Netflix OSS组件集成，组成微服务的核心。</p></li><li><p><strong>Netflix Eureka</strong>：服务注册中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</p></li><li><p><strong>Netflix Hystrix</strong>：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p></li><li><p><strong>Spring Cloud Config</strong>：配置中心，配置管理工具包，可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Svn。</p></li><li><p><strong>Spring Cloud Bus</strong>：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</p></li><li><p><strong>Spring Cloud for Cloud Foundry</strong>：Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</p></li><li><p><strong>Spring Cloud Cluster</strong>:Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。</p></li><li><p><strong>Spring Cloud Zookeeper</strong>:操作Zookeeper的工具包，用于使用zookeeper方式进行服务发现和配置管理。</p></li><li><p><strong>Spring Cloud Starters</strong>:为Spring Cloud提供开箱即用的依赖管理。</p></li><li><p>Dubbo:基于RPC调⽤，对于⽬前使⽤率较⾼的Spring Cloud Netflix来说，它是基于HTTP的，所以效率上没有Dubbo⾼，但问题在于Dubbo体系的组件不全，不能够提供⼀站式解决⽅案。</p></li><li><p>Nocas:注册中⼼ + 配置中⼼的组合，帮助我们解决微服务开发必会涉及到的服务注册与发现，服务配置，服务管理等问题。<a href="https://zhida.zhihu.com/search?content_id=169091361&amp;content_type=Article&amp;match_order=1&amp;q=Nacos&amp;zhida_source=entity">Nacos</a> 是Spring Cloud Alibaba 核⼼组件之⼀，负责服务注册与发现，还有配置。</p></li><li><p>Zookeeper:Zookeeper ⽤来做服务注册中⼼，主要是因为它具有节点变更通知功能，只要客户端监听相关服务节点，服务节点的所有变更，都能及时的通知到监听客户端，这样作为调⽤⽅只要使⽤ Zookeeper 的客户端就能实现服务节点的订阅和 变更通知功能了，zookeeper遵循半数集群可用原则。</p></li><li><p>Ribbon负载均衡</p></li></ul><h1>开发组件选择</h1><h2 id="Eureka注册服务中心">Eureka注册服务中心</h2><p>在微服务项目中，我们一般会对一个项目，以业务的维度拆分至多个服务，比如用户服务、账务服务、订单服务、仓储服务等，这些服务在生产环境部署，<br>至少是2个服务实例，如果业务量大几十个都是有可能的。</p><p>订单服务实例部署了4个，仓库服务部署了5个，仓库服务要调用订单服务，如果没有注册中心，他会怎么做，那只有把对应的ip和端口写死在代码中，如果新增了一个订单服务怎么办？或者下线了订单服务怎么办？</p><p>另外，在云环境中，服务实例随时都有可能启动和关闭，随之IP也会发生变化，没法把IP写死在代码中。</p><p>基于以上问题就有了服务注册中心<code>Eureka</code></p><p><code>Eureka</code>能实现服务自动的注册和发现，在每次服务调用的时候根据服务名称会获取到目标服务的IP和端口，在进行调用。</p><p>如果服务下线或者上线，对应的服务的地址信息也会进行更新，这样就保证了，随时可以调用到有效的服务。</p><p>同时为了提高性能，这个服务地址信息会在每个服务本地缓存一份地址信息表，定时更新，这样每次请求服务时，不用每次去<code>Eureka</code>查询来降低服务调用耗时。</p><p>我们部署一个<code>Eureka Server</code>，并将我们的微服务（部门服务和用户服务）作为 Eureka 客户端，注册到<code>Eureka Server</code>，同时使用用户服务调用根据部门服务的<code>Service ID</code> 来调用部门服务相关接口。</p><p>在项目中添加组件Eureka Server，pom文件中进行导入</p><p>主方法上我们需要添加<code>@EnableEurekaServer</code>注解，使我们应用程序成为服务注册中心。</p><p>默认情况下，每个<code>Eureka Server</code> 也是一个<code>Eureka</code>客户端。由于我们只想让他做好服务注册中心，不想让他做客户端，因此我们将通过在<code>application.properties</code>文件中配置以下属性来禁用此客户端行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=Eureka Server</span><br><span class="line">server.port=8761</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8761</code>，会显示以下界面</p><p>然后将一个服务注册到Eureka Server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;spring-cloud.version&gt;2021.0.4&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>在application.properties中配置<code>eureka.client.service-url.defaultZone</code> 属性 即可自动注册到 Eureka Server。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.application.name=DEPARTMENT-SERVICE</span></span><br><span class="line"><span class="string">eureka.instance.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>当服务注册到 Eureka Server 时，它会在一定的时间间隔内不断发送心跳。如果 Eureka 服务器没有收到来自任何服务实例的心跳，它将假定该服务实例已关闭并将其从池中取出</p><p>然后目标服务添加注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;DEPARTMENT-SERVICE&quot;)</span><br></pre></td></tr></table></figure><h2 id="Open-Feign服务调用">Open Feign服务调用</h2><p>声明式 HTTP RPC 调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;forum-auth&quot;, path = &quot;/api/auth&quot;)</span><br></pre></td></tr></table></figure><p>表示这是一个 <strong>Feign 客户端接口</strong>，要去调用 <strong>名为 <code>forum-auth</code></strong> 的微服务。</p><ul><li><strong><code>name</code></strong>：对应 Spring Cloud 服务注册中心（如 Nacos、Eureka）里的服务名</li><li><strong><code>path</code></strong>：接口调用时统一加上的路径前缀</li></ul><p>你在别的模块里注入这个接口（<code>@Autowired AuthFeignClient client;</code>），就能直接<strong>像调用本地方法一样发起远程 HTTP 请求</strong>。</p><p>那么什么是RPC呢？</p><p>你写一个 Java 接口并打上 Feign 注解（不需要写实现类）。</p><p>Spring Cloud OpenFeign 会在运行时为这个接口创建 <strong>动态代理对象</strong>。</p><p>当你调用方法时，代理会根据注解信息拼接成 HTTP 请求（<code>GET /api/auth/...</code>），<br>并通过负载均衡（Ribbon/Spring Cloud LoadBalancer）调用到 <code>forum-auth</code> 服务的对应接口。</p><p>返回 JSON 会被自动反序列化成 <code>Result&lt;T&gt;</code> 类型。</p><h2 id="Nacos服务注册">Nacos服务注册</h2><p>config配置类：</p><p>@postconstruct的init方法，设置本地地址和元数据，重写run方法</p><p>然后写NacosShutdownHook类，关闭nacos，防止解决DefaultHttpClientFactory无法加载的问题。</p><p>然后再application文件中加入配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cloud:</span><br><span class="line">  nacos:</span><br><span class="line">    discovery:</span><br><span class="line">      server-addr: $&#123;NACOS_SERVER_ADDR:localhost:8848&#125;</span><br><span class="line">      namespace: $&#123;NACOS_NAMESPACE:&#125;</span><br><span class="line">      group: $&#123;NACOS_GROUP:DEFAULT_GROUP&#125;</span><br><span class="line">      enabled: true</span><br><span class="line">    config:</span><br><span class="line">      server-addr: $&#123;NACOS_SERVER_ADDR:localhost:8848&#125;</span><br><span class="line">      file-extension: yaml</span><br><span class="line">      namespace: $&#123;NACOS_NAMESPACE:&#125;</span><br><span class="line">      group: $&#123;NACOS_GROUP:DEFAULT_GROUP&#125;</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure><p>填写组别，发现端口，name名字，然后记录服务端的端口，组别等</p><h2 id="Seata-分布式事务">Seata 分布式事务</h2><p>​Config配置文件：</p><p>根据 <strong>环境</strong>（dev/test/prod）和 <strong>服务名</strong> 动态生成事务组名，避免不同环境污染。</p><p>使用配置中心（Nacos / Apollo）动态管理事务组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GlobalTransactionScanner <span class="title function_">globalTransactionScanner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">txServiceGroup</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s-%s-tx-group&quot;</span>,</span><br><span class="line">        System.getenv(<span class="string">&quot;SPRING_APPLICATION_NAME&quot;</span>),</span><br><span class="line">        System.getenv(<span class="string">&quot;ENV&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GlobalTransactionScanner</span>(<span class="string">&quot;forum-seata-group&quot;</span>, txServiceGroup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​不同的模式：</p><p>当前是 <strong>AT 模式</strong>（自动 SQL 拦截 + 全局锁），性能不错但会加大数据库锁粒度。</p><p>可以升级为：</p><p>对<strong>长事务/跨多服务耗时操作</strong>改用 <strong>Saga 模式</strong>（状态机驱动 + 补偿动作）。</p><p>对<strong>高并发热点写</strong>改用 <strong>TCC 模式</strong>（Try-Confirm-Cancel）避免全局锁。</p><p>​回滚策略：</p><p>然后对不同类型的异常，设定不同的回滚的策略</p><p>区分 <strong>业务异常</strong>（不回滚，如参数错误）和 <strong>系统异常</strong>（回滚，如数据库/网络错误）。</p><p>可自定义 <code>BusinessException</code> 并在 <code>@GlobalTransactional</code> 里排除。</p><p>​告警：</p><p>接入 <strong>Seata 控制台</strong>，实时查看全局事务状态。</p><p>通过 Prometheus + Grafana 做事务失败率/超时监控。</p><p>超时自动告警（钉钉/企业微信）。</p><p>集成 SkyWalking/Zipkin，将 XID 作为 TraceId 的一部分，方便跨服务链路分析。</p><p>在全局事务开始、提交、回滚时打业务日志。</p><h2 id="Gateway网关认证">Gateway网关认证</h2><p>安全性升级</p><ul><li><p>现在 JWT 一旦签发，在过期时间内无法撤销（除非改密钥）。升级建议：引入 Redis 存储<strong>黑名单 Token</strong>，用户登出或被封禁时将 Token 加入黑名单，网关在过滤器里校验。</p></li><li><p>目前 <code>JwtUtil</code> 应该是固定签名密钥，建议使用 <strong>定期轮换</strong>（Key Rotation），减少泄漏风险。可以用 <code>kid</code>（key id）标记密钥版本，JWT 验证时先取 <code>kid</code>，再用对应密钥解密。</p></li><li><p>给 Token 增加 <code>jti</code>（唯一 ID），在 Redis 里做一次性校验，防止别人抓包重放。</p></li></ul><p>扩展性升级</p><ul><li>白名单配置化，现在白名单是写死在代码里的，可以改成 Nacos / Apollo 配置动态加载：</li><li>现在你用 <code>X-User-Id</code>、<code>X-Username</code>，但可以考虑：全量透传 <code>claims</code>（JSON 压缩后放 header 或 Gateway Request Attribute）。或者只传一个 <code>User-Context</code> Base64，后端统一解码。</li></ul><p>性能优化</p><ul><li>Gateway 是 Reactor 模型，要确保 <code>JwtUtil</code> 验证不会有阻塞 IO（如 Redis、文件操作）。如果 JWT 公钥存 Redis，可提前加载到内存，用 <code>Cache</code> 缓存，减少每次请求访问 Redis。</li><li>白名单频繁变动时，用单个 <code>volatile</code> 变量指向 <code>Set&lt;String&gt;</code>，避免并发锁开销。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.forum.gateway.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.forum.common.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.ExpiredJwtException;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureException;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;AuthGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析缓存（避免每次都重复解析 JWT）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Claims&gt; tokenCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;gateway.auth.tokenHeader:Authorization&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthGatewayFilterFactory</span><span class="params">(JwtUtil jwtUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">        <span class="built_in">this</span>.jwtUtil = jwtUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 白名单放行</span></span><br><span class="line">            <span class="keyword">if</span> (isWhiteListed(path, config.getWhiteList())) &#123;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 Token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(request);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;缺少认证信息&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> tokenCache.computeIfAbsent(token, t -&gt; jwtUtil.getClaimsFromToken(t));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 校验 Token 是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (jwtUtil.isTokenExpired(token)) &#123;</span><br><span class="line">                    tokenCache.remove(token);</span><br><span class="line">                    <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;Token 已过期&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 提取用户信息并添加到请求头</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> StringUtils.defaultString(claims.getSubject(), <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">mutatedRequest</span> <span class="operator">=</span> request.mutate()</span><br><span class="line">                        .header(<span class="string">&quot;X-User-Id&quot;</span>, String.valueOf(userId))</span><br><span class="line">                        .header(<span class="string">&quot;X-Username&quot;</span>, username)</span><br><span class="line">                        .header(<span class="string">&quot;X-Trace-Id&quot;</span>, UUID.randomUUID().toString())</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange.mutate().request(mutatedRequest).build());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Token 已过期: &#123;&#125;&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;Token 已过期&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SignatureException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Token 签名无效: &#123;&#125;&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;无效的认证信息&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Token 验证失败&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isWhiteListed</span><span class="params">(String path, List&lt;String&gt; whiteList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> whiteList.stream().anyMatch(pattern -&gt;</span><br><span class="line">                path.equals(pattern) || path.startsWith(pattern) || pathMatcher.match(pattern, path)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getToken</span><span class="params">(ServerHttpRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeaders().getFirst(tokenHeader);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(authorization) &amp;&amp; authorization.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorization.substring(<span class="number">7</span>).trim();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">unauthorizedResponse</span><span class="params">(ServerWebExchange exchange, String message)</span> &#123;</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        response.getHeaders().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> String.format(<span class="string">&quot;&#123;\&quot;code\&quot;:401,\&quot;message\&quot;:\&quot;%s\&quot;,\&quot;timestamp\&quot;:%d&#125;&quot;</span>,</span><br><span class="line">                message, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; whiteList = Arrays.asList(</span><br><span class="line">                <span class="string">&quot;/auth/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/auth/register&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/auth/captcha&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/doc.html&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/swagger-ui/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/v3/api-docs/**&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-2</title>
      <link>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/</link>
      <guid>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/</guid>
      <pubDate>Mon, 28 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;面试回答优化&lt;/p&gt;
&lt;h1&gt;Gemini模拟面试2025.7.29&lt;/h1&gt;
&lt;p&gt;1.Java面向对象的基本特性：&lt;/p&gt;
&lt;p&gt;总：的介绍一下java面向对象&lt;/p&gt;
&lt;p&gt;分：封装，继承，多态&lt;/p&gt;
&lt;p&gt;总：好处&lt;/p&gt;
&lt;p&gt;2.Hashmap的原理&lt;/p&gt;
</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>面试回答优化</p><h1>Gemini模拟面试2025.7.29</h1><p>1.Java面向对象的基本特性：</p><p>总：的介绍一下java面向对象</p><p>分：封装，继承，多态</p><p>总：好处</p><p>2.Hashmap的原理</p><p>总：hashmap是个啥</p><p>分：</p><ol><li><p>基本数据结构类型，1.7 or 1.8</p></li><li><p>hash冲突解决</p></li><li><p>核心put过程</p></li><li><p>扩容机制，为什么是2倍</p></li><li><p>线程安全实现</p></li><li><p>concurrenthashmap</p></li><li><p>平时使用场景</p></li></ol><p>3.<strong>ArrayList 和 LinkedList 的区别</strong></p><ol><li>底层数据结构</li><li>插入删除遍历节点</li><li>扩容</li><li>使用场景：</li></ol><p>4.常用的设计模式</p><ol><li>单例：饿汉式，懒汉式，DCL 枚举 实际应用，RedisClient AppConfig Spring bean</li><li>策略：</li><li>模板</li><li>观察</li><li>工厂</li></ol><p>5.ThreadLocal的实现</p><ol><li>底层数据结构</li></ol><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，key为实例，value是为具体的对象</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><ol start="2"><li><p>内存泄漏问题</p></li><li><p>使用场景</p></li></ol><p>6.你如何理解“悲观锁与乐观锁”？分别适用哪些场景？CAS 原理是什么？</p><ol><li>悲观锁，乐观锁代表什么，实例，场景</li><li>CAS原理，OS的cmpxchg</li><li>CAS问题</li><li>使用场景</li></ol><p>7.说一下 Java 中的 <code>synchronized</code> 关键字的实现原理、优化机制，以及它和 <code>ReentrantLock</code> 的区别</p><ol><li>底层原理，对象头中的 monitor 锁，每个对象在 JVM 中都有一个对象头，包含了锁标志位和指向 monitor 的指针。当线程进入 <code>synchronized</code> 块或方法时，会尝试获得这个对象的 monitor。多线程竞争时，会进行 <strong>锁的升级</strong>，这就是 HotSpot 中的锁优化。</li><li>锁的升级过程，无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>和<code>ReentrantLock</code> 对比</li></ol><p>8.说一下 Java 中的 <code>volatile</code> 关键字的作用，它能实现线程安全吗？它和 <code>synchronized</code> 有什么区别？</p><ol><li><p>可见性，禁止重排性</p></li><li><p>不能保证原子下，i++</p></li><li><p>和JMM的关系：JMM规定了主内存和工作内存的交互规则，volatile 会强制线程刷新工作内存和主内存之间的数据。</p><p>写 volatile → 插入一个 Store + StoreBarrier 。读 volatile → 插入一个 LoadBarrier + Load</p></li><li><p>应用场景，标识位，布尔控制变量，DCL</p></li><li><p>和<code>synchronized</code> 对比</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-1</title>
      <link>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/</link>
      <guid>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/</guid>
      <pubDate>Thu, 24 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;他人面经&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>他人面经</h1><h2 id="1-spring的底层实现-三级缓存原理">1.spring的底层实现&amp;三级缓存原理</h2><p>我们先来说三级缓存的实现吧</p><p>首先三级缓存是那三个缓存呢？是在DefaultSingletonBeanRegistry类里面定义的三个Map。然后第一第二层都是key是bean的名字，value是bean的实例。第三次key是bean的名字，value是objectfactory.</p><p>第一层缓存是用来存储我们已经完全实例化好的bean,在这里可以直接使用的</p><p>第二层缓存时用来存储我们早期的bean，创建好，但是并没有进行依赖注入的</p><p>第三次缓存是用来存储我们的objectfactory的，用来创建代理对象的</p><p>然后我们缓存的核心方法是我们的getSingleton方法，他定义了我们如何去获取缓存的顺序</p><p>我们首先先去看第一层缓存，如果第一次没有且bean正在创建中的话。我们再去找第二层缓存，第二层也没有的话，允许早期引用。然后从三级缓存中获取objectfactory</p><p>然后使用objectfactory来创建对象，这里可能是代理对象。因为比如AOP，或者使用了其他的代理模式</p><p>然后将其升级到二级缓存，将三级缓存里面的删除。（暂不使用，然后再可以进行依赖注入。然后如果我们的作用域是单例的话，就直接放入一级缓存，不是的话，就根据场景来）</p><p>然后在我们进行依赖注入的时候可能会出现循环依赖的问题，就是A依赖于B，B也依赖于A的问题</p><p>这个时候就需要解决依赖的问题，我们的三层缓存使用的是提前暴露的方法来解决循环依赖的问题</p><p>在AbstractAutowireCapableBeanFactory.doCreateBean的方法里面定义了解决的实现</p><p>首先我们先实例化bean，只是采用*构造器，*创建，并没有进行属性的注入</p><p>然后我们去判断需不要早期暴露，是不是单例的，因为单例的才会允许循环依赖注入。然后允不允许我们循环依赖。这个是在SpringApplication中设置的，然后这个bean是不是正在被创建中。，</p><p>满足了这个条件，我们才会将objectfactory放入三级缓存的时候，保证二级缓存没有，然后这个会获取一个早期引用，如果我们需要AOP 的话，会获取他的代理对象</p><p>然后对我们需要的依赖进行属性的填充，进行依赖注入</p><p>注入完进行初始化bean</p><p>然后为什么是三级缓存呢？因为<strong>AOP代理对象的延迟创建问题</strong></p><p>在AOP的后置处理器中，获取早期的引用对象的时候，会返回的是我们的代理对象。</p><p>如果我们使用二级缓存的，不知道什么时候创建代理对象，可能会创建多个代理对象，AOP的时机控制会失效。</p><p>so:</p><p>三级缓存通过ObjectFactory实现了：</p><ul><li><strong>按需创建</strong>：只有真正发生循环依赖时才创建代理对象</li><li><strong>唯一性保证</strong>：确保一个Bean只有一个早期引用实例</li><li><strong>时机控制</strong>：代理对象的创建时机由Spring容器精确控制</li></ul><h2 id="2-hashmap为什么扩容要是2的倍数">2.hashmap为什么扩容要是2的倍数</h2><p>HashMap扩容为2的倍数的根本原因是为了实现<strong>高效的哈希计算</strong>和<strong>均匀的元素分布</strong>。</p><p>我们hashmap的tableSizeFor进行容量初始化的时候，通过位运算确保了任何输入都会背转换成<strong>大于等于该数的最小2的幂次方</strong>。确保了容量为2的次方幂。</p><p>然后在put一个元素的时候，我们是通过hash来确定这个值得索引的，使用的是**(n-1) &amp; hash 的按位与运算**来确定位置的。然后hash函数也进行了优化，<em>高16位与低16位异或，增加散列的随机性</em>。</p><p>然后我们的扩容方法里面是这样规定的，是单个元素的话，我们使用位运算重新规划位置，如果是红黑树的话，我们对他的头节点进行位运算，</p><p>如果是链表的话，我们要对链表进行拆分，通过一个位来判断元素的去向，如果与老容量的位运算是0的话，就留在原位置，是1的话就转移到原位置+oldcap的位置，这个算法是非常巧妙的，比如假设hash为21，oldcap=16-1,那么原位置就是5，然后现在我们再进行运算，21&amp;16=0，那么他就是留在原位置。</p><p>然后讲我们拆分的链表加入到我们新的数组之中。这个时候要注意链表的长度，如果超过了8的话，且数组位数大于64，需要转为红黑树。</p><p>然后为什么是2的倍数呢？当我们的数字长度为2的次方幂的时候，我们使用位运算比我们的取模运算高效的多，然后我们不需要重新计算hash值，只需要检查一个位就可以确定新的位置，然后如果是2的幂次方保证了hash值的每一位都能参与到索引计算中，而且对cpu的缓存更加友好</p><h2 id="3-sychronized的底层原理">3.sychronized的底层原理</h2><p>sychronized的底层原理，如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>sychronized的字节码层面的实现是基于监视器实现的，进入监视器，然后执行sychronized修饰的代码块，然后退出监视器</p><p>然后在Hotspot JVM中，synchronized基于Monitor对象实现，ObjectMonitor规定了持有锁的线程，重入的次数，等待获取锁的线程的队列，竞争队列，wait方法等待的线程</p><p>然后如果我们成功获得锁，直接返回。如果是线程的id等于锁的id的话，重入锁的计数器+1,然后如果不相等的话，就产生了锁的竞争，将其放入慢路径。然后慢路径里面的线程自旋，继续取尝试获取活，如果超过了重试次数的话，将其加入等待队列。</p><p>然后出现的三个线程的关系是，竞争队列-&gt;唤醒队列-&gt;获取锁</p><p>然后如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>我们可以使用countDownLatch</p><p>分为A，B两个线程，分别重写他们的run方法，然后A线程执行完之后计数器完成，就通知B线程可以进行。</p><p>然后B线程，重修run方法，调用wait等待，计数器为0的时候开始线程的执行</p><p>然后countdownlatch的底层实现是，state等于0的时候允许通过，然后释放锁的通过cas来实现的</p><p>或者是使用Semaphore，将其初始化为0，然后分为线程A和线程B，线程A执行完之后释放许可，然后B线程执行的时候，尝试获取许可执行</p><p>或者是直接使用LockSupport，在A线程完之后，直接唤醒线程B，然后重写B线程的run方法，先是park的等待A线程执行完之后的唤醒</p><p>然后我们最常用的实现方案是synchronized + wait/notify</p><p>我们先初始化lock然后用sychronized去获取lock,和一个静态的标识位设定为A线程是不是完成。</p><p>然后重写A线程run方法，讲标志位设定为true，然后唤醒等待的线程。线程Bwait等待去执行</p><h2 id="4-tcp状态机，java底层怎么实现tcp的">4.tcp状态机，java底层怎么实现tcp的</h2><p>那我先说TCP状态机的流程吧，分为客户端状态机和服务端状态机</p><p>客户端：</p><p>CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</p><p>服务端：</p><p>CLOSED -&gt; LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED(0),      // 初始状态，无连接</span><br><span class="line">LISTEN(1),      // 服务端监听状态</span><br><span class="line">SYN_SENT(2),    // 客户端发送SYN后的状态</span><br><span class="line">SYN_RCVD(3),    // 服务端收到SYN后的状态</span><br><span class="line">ESTABLISHED(4), // 连接建立状态</span><br><span class="line">FIN_WAIT_1(5),  // 主动关闭方发送FIN后的状态</span><br><span class="line">FIN_WAIT_2(6),  // 主动关闭方收到ACK后的状态</span><br><span class="line">CLOSE_WAIT(7),  // 被动关闭方收到FIN后的状态</span><br><span class="line">CLOSING(8),     // 双方同时关闭的中间状态</span><br><span class="line">LAST_ACK(9),    // 被动关闭方发送FIN后的状态</span><br><span class="line">IME_WAIT(10);  // 主动关闭方的最终等待状态</span><br></pre></td></tr></table></figure><p>那我先说一下TCP三次握手的状态机变化：</p><p>客户端主动连接服务端，首先客户端的状态机位close，然后发送完SYN包之后变为SYN_SENT</p><p>然后收到服务端发来的SYN+ACK包，发送ACK包，然后状态转为 ESTABLISHED</p><p>服务端是监听状态的情况下，接收到客户端的SYN包之后，发送SYN-ACK包，状态变为SYN_RCVD</p><p>然后收到客户端的ACK包，状态转变为ESTABLISHED</p><p>TCP四次挥手状态机变化</p><p>先是主动关闭方，一般是客户端，发送FIN包，然后变为FIN_WAIT_1 状态</p><p>然后收到服务端发来的ACK，状态转变为FIN_WAIT_2</p><p>然后再收到发来的FIN包，向服务端发送ACK，转为 TIME_WAIT 等待2MSL后关闭，变为Close状态</p><p>服务端，收到FIN请求后，发送ACK，请求，变为CLOSE_WAIT，然后应用程序调用close方法，发送FIN包，状态变为LAST_ACK</p><p>然后收到ACK请求后，状态变为CLose,彻底关闭</p><hr><p>后面这个有些难度了，哭</p><h2 id="5-协程和线程的区别是什么？">5.协程和线程的区别是什么？</h2><p>线程是由操作系统内核进行抢占式调度，任何时候都可能被强制切换，协程是由用户态程序进行协作式调度，只在主动让出时才会切换</p><p>然后线程：</p><ul><li>每个线程需要独立的栈空间（通常1MB）</li><li>创建和切换需要用户态和内核态转换，开销较大</li><li>1000个线程大约占用1GB内存</li><li>共享内存模型，需要使用锁、synchronized等机制保证线程安全</li></ul><p>适合：</p><ul><li>CPU密集型任务</li><li>需要真正并行执行的场景</li><li>传统的多线程编程</li></ul><p>协程：</p><ul><li>栈空间很小（通常几KB）</li><li>在用户态完成创建和切换，开销很小</li><li>10万个协程可能只占用几百MB内存</li><li>通常采用消息传递模型（如Channel），天然避免数据竞争</li></ul><p>适合：</p><ul><li>IO密集型任务</li><li>高并发场景（如服务器处理大量连接）</li><li>异步编程，避免回调地狱</li></ul><p>协程是轻量级的用户态线程，更适合高并发的IO密集型场景，而线程更适合CPU密集型的并行计算场景。协程的核心优势是用更少的资源实现更高的并发度。</p><h2 id="6-介绍一下ArrayList扩容机制">6.介绍一下ArrayList扩容机制</h2><p>首先先介绍一下ArrayList他的底层是动态的数组，默认的容量为10。但是有一个最大数组的容量，这个主要是考虑JVM的，因为ArrayList给他在JVM里面分配的是一个连续的内存。最大是Integer.MAX_VALUE - 8，为什么呢？JVM在数组对象头中需要存储一些元数据，预留防止出现OOM</p><p>然后ArrayList的扩容是add元素之后，剩余的内存容量还足够，通过数组复制的方法，为新元素腾出空间</p><p>我们首先会进行容量的检查，这里检查的是Size+1，先去查查内部的容量，然后去检查我们所需要的容量，如果是空数组的话，那么至少需要10的容量</p><p>然后去显示的检查容量，计数器+1，如果最小需求容量&gt;当前数组的长度的话，就进行扩容</p><p>然后触发核心的扩容方法，新的容量是<em>新容量 = 旧容量 + 旧容量的一半</em>，是根据oldCapacity + (oldCapacity &gt;&gt; 1)计算来的。这样计算更快</p><p>然后处理边界的情况，先是最小边界，1.5倍如果还不够的话，就用最小需求量，然后是超大的边界处理，将容量设为容量的最大值</p><p>然后检查完之后，进行数组的复制，将元素复制到更大的数组。这里使用<em>Arrays.copyOf然后最终调用System.arraycopy的</em>native方法</p><p>优化的策略：</p><p>我们可以先进行预估一下，然后再确定一开始初始化需要的初始容量，避免频繁扩容。最好的办法是，开了负载因子，然后容量比我们预计的多一点</p><h2 id="7-口述实现非公平与公平的redis分布式锁">7.口述实现非公平与公平的redis分布式锁</h2><p>非公平锁：</p><p>获取锁</p><ol><li>使用<code>SET key value NX EX timeout</code>命令尝试获取锁</li><li>如果设置成功，说明获取锁成功，返回true</li><li>如果设置失败，说明锁被占用，可以选择重试或返回失败</li><li>value通常设置为当前线程的唯一标识（如UUID+线程ID）</li></ol><p>释放锁</p><ol><li>使用Lua脚本确保原子性操作</li><li>先检查锁的value是否是当前线程设置的</li><li>如果是，则执行DEL命令删除锁</li><li>如果不是，说明锁已超时被其他线程获取，不能删除</li></ol><p>重试机制</p><ul><li>获取失败后，线程sleep一小段时间再重试</li><li>重试间隔可以是固定时间或采用指数退避策略</li><li>设置最大重试次数或超时时间避免无限等待</li></ul><p>公平锁：</p><p>获取锁</p><ol><li><strong>检查当前锁状态</strong><ul><li>如果锁未被占用，直接尝试获取</li><li>如果被占用，进入排队流程</li></ul></li><li><strong>加入等待队列</strong><ul><li>将当前线程标识和时间戳加入<code>queue:resource_name</code>有序列表</li><li>使用ZADD命令，以时间戳为分数确保顺序</li></ul></li><li><strong>检查队列位置</strong><ul><li>获取队列中的第一个元素（最早等待的线程）</li><li>如果是当前线程，说明轮到自己，尝试获取锁</li><li>如果不是，继续等待</li></ul></li><li><strong>等待通知机制</strong><ul><li>使用Redis的BLPOP或发布订阅机制等待通知</li><li>或者采用轮询方式，定期检查是否轮到自己</li></ul></li><li><strong>获取锁的尝试</strong><ul><li>当轮到自己时，使用SET NX命令尝试获取锁</li><li>获取成功后，从等待队列中移除自己</li><li>获取失败说明锁被其他线程抢占，重新进入等待</li></ul></li></ol><p>释放锁</p><ol><li><strong>释放锁资源</strong><ul><li>使用Lua脚本原子性地检查并删除锁</li></ul></li><li><strong>通知下一个等待者</strong><ul><li>从等待队列中获取下一个等待的线程</li><li>向该线程发送通知信号</li><li>可以使用Redis的发布订阅或设置特定key来通知</li></ul></li><li><strong>清理过期等待者</strong><ul><li>定期清理队列中的过期等待线程</li><li>避免队列无限增长</li></ul></li></ol><h2 id="9-OS的虚拟内存和页面置换算法">9.OS的虚拟内存和页面置换算法</h2><p>虚拟内存是操作系统的核心抽象，通过MMU和页表机制将进程的虚拟地址空间映射到有限的物理内存，实现内存保护、共享和扩展。</p><p>当物理内存不足时，页面置换算法决定哪些页面被换出到磁盘。<strong>FIFO算法</strong>实现简单但可能出现Belady异常；<strong>LRU算法</strong>基于局部性原理效果最好但实现成本高；<strong>Clock算法</strong>是LRU的高效近似实现，使用访问位模拟时钟指针给页面第二次机会；<strong>Enhanced Clock算法</strong>进一步考虑修改位，优先置换干净页面减少磁盘I/O。</p><p>现代操作系统如Linux采用多层LRU设计，将页面分为active和inactive链表动态管理热度，并结合预取、内存压缩等技术优化性能。<strong>关键是要平衡算法复杂度与性能提升，充分利用程序的时间空间局部性，同时考虑NUMA、SSD等现代硬件特性</strong>。在生产环境中需要根据应用特征选择合适策略，避免内存抖动，并通过监控缺页率等指标持续优化。虚拟内存的设计体现了操作系统在资源管理上的核心思想：通过抽象和调度算法，在有限资源上为应用提供无限且高效的服务体验。</p><h2 id="10-AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写">10.AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写</h2><p>AQS是一个设计思想，本质上就是一个同步器框架。主要控制状态管理和线程排队，状态管理交给子类，然后线程排队AQS统一处理</p><p>核心组件就是state变量和CLH队列变种</p><p>state:</p><ul><li>使用volatile int保证可见性</li><li>通过CAS操作保证原子性修改</li><li>语义由子类定义：可以表示锁的持有状态、信号量的许可数量、CountDownLatch的计数等</li></ul><p>CLH队列：</p><ul><li><strong>双向链表</strong>：支持超时和中断处理</li><li><strong>虚拟头节点</strong>：简化边界条件处理</li><li><strong>节点状态</strong>：SIGNAL、CANCELLED、CONDITION等，精确控制唤醒时机</li></ul><p>流程：</p><p>他是先尝试快速获取锁，避免排队。失败后加入队列，但是不会立刻阻塞。在队列中尝试去获得锁，获取前驱释放的锁。实在无法获取的适合才堵塞。</p><p>然后获取锁的时候state+1，线程Id=锁的Id，然后解锁的时候-1。知道为0的时候释放锁。</p><p>然后在CLH中设计了<strong>懒初始化</strong>：只有竞争时才创建队列，减少内存开销。设计了唤醒机制，释放资源的线程负责唤醒后记的节点，被唤醒的线程获取资源后，唤醒下一个。避免了雷鸣群羊&quot;问题，精确控制唤醒数量</p><p>被唤醒的线程，实现CAS自旋尝试去获得锁，失败后会被park，直到再次unpark。</p><p>同步工具，我写了一个基于AQS和令牌桶实现的限流操作</p><p>先是引入桶容量，每秒补充的速率。然后对他们进行初始化，初始化令牌桶，将时间戳和令牌数压缩到一个long变量中。</p><p>然后重要的是实现*tryAcquire *和tryRelease，但是令牌桶不需要主动的释放资源</p><p>先去解析我们当前的状态，获取时间和需要的令牌数量，然后计算我们需要补充的令牌的数量，然后判断我们是否可以获取。然后使用CAS更新状态，返回剩余令牌数。CAS失败就自旋重试，避免了线程堵塞。</p><h2 id="11-介绍一下动态代理">11.介绍一下动态代理</h2><p>动态代理主要有<strong>JDK动态代理</strong>和<strong>CGLIB字节码增强</strong>两种实现方式。<strong>JDK动态代理</strong>基于接口，在运行时通过Proxy.newProxyInstance()创建代理对象，底层使用反射调用InvocationHandler的invoke方法来拦截目标方法；<strong>CGLIB字节码增强</strong>无需接口，通过ASM字节码操作库在运行时生成目标类的子类，重写目标方法并插入拦截逻辑，在方法中通过super调用原始方法或MethodInterceptor进行增强。<strong>核心区别</strong>：JDK代理生成的是接口实现类，性能更好但必须有接口；CGLIB生成的是继承子类，更灵活但不能代理final方法。Spring AOP默认策略是有接口用JDK代理，无接口用CGLIB，都是在运行时动态生成字节码实现方法拦截和功能增强，广泛应用于AOP、事务管理、权限控制等场景。</p><h2 id="12-tomcat底层（TODO）">12.tomcat底层（TODO）</h2><h2 id="13-布隆过滤器的底层实现">13.布隆过滤器的底层实现</h2><p>布隆过滤器本质上就是一个大的Bitset+多个独立的hash函数，<em>根据期望元素数和误判率计算最优参数</em>，假设有m个位，k个哈希函数，插入n个元素，最优数组位大小是 -n * ln(p) / (ln(2))²*，最优hash函数个数是*k = (m/n) * ln(2)</p><p>然后我们添加元素的时候，对元素进行hash，然后放在对应的hash%bitsetsize的位置上，然后设置为1</p><p>查询元素的时候，遍历hash，获取其index，然后必须所以的hash位都要是1才可能存在</p><p>我们单个使用hash太慢了，我们需要高效生成k个独立的哈希值，就可以使用双hash方法，使用两个不同的哈希函数，比如一个直接调用，一个取16位，让组合生成一个新的hash比如hash1+i+hash2,常用MurmurHash + FNV Hash两个hash组合</p><p>然后其布隆过滤器不是完全准确的，可能布隆过滤器中没有，但是数据库中有的，我们就需要计算准确率，较少的计算出某个位为0的概率，然后计算出k个位都为1但是元素不存在的概率</p><p>然后1-概率1 pow上概率2</p><p>当这个布隆过滤器很大的时候，一般我们都用16位就可以了，k=16时已经能提供足够好的误判率。理论值误判率：(1 - e^(-kn/m))^k</p><p>单个优化策略：</p><ol><li><strong>动态扩容</strong>，<em>创建新的过滤器，容量翻倍，误判率减半</em>，然后只要有一个过滤器返回true就可以</li><li>增加位数组大小，相同的元素数量下，位数组越多，误判率越小。</li><li><strong>Counting Bloom Filter</strong>，使用计数器代替位数组，成功添加之后，计数器+1，避免单一位冲突，可以支持删除操作</li><li>分层布隆过滤器，元素依次通过多层过滤器，在第一个返回的层添加其元素。然后只有所有的层都返回true才表明存在</li></ol><p>关键特性：</p><p>如何判断没有一定没有？</p><ul><li>如果元素真的被添加过，它的所有哈希位置都<strong>必须</strong>为1，发现任何一个位置为0，说明元素<strong>绝对没有</strong>被添加过，所有位置都为1时，可能是其他元素设置的（假阳性）</li></ul><p>然后实际的参数的设计，100万商品的话，误判率设为0.01</p><p>然后位数组大小 ≈ 9,585,058*，然后单击场景我们就放在JVM内存中，分布式的话就存在redis里面</p><h2 id="14-ThreadLocal的底层实现">14.ThreadLocal的底层实现</h2><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，其键是 <code>ThreadLocal</code> 实例对象（弱引用），值是线程本地变量的值（强引用）。</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><p>Threadlocal可以用于线程不安全类的线程安全封装，<strong>典型场景</strong>：<code>SimpleDateFormat</code>。<code>SimpleDateFormat</code> 是一个线程不安全的类，可以为每个线程提供一个独立的实例，避免竞争。</p><p>在数据库连接的时候应用，通常为每个线程（每个请求）独立创建一个数据库连接，使用 <code>ThreadLocal</code> 来管理这些连接。</p><p>管理用户的上下文信息，这个最常用</p><p>在分布式事务或者嵌套事务中，通过 <code>ThreadLocal</code> 存储事务信息，使得同一线程的不同方法调用间能共享事务上下文。</p><p><strong>InheritableThreadLocal</strong> 用于子线程继承父线程变量；</p><h2 id="15-详细解析下CAS和原子类">15.详细解析下CAS和原子类</h2><p>CAS的英文是compare and swap ，就是比较然后交换的意思，他是一个原子操作，用于在多线程环境下实现同步</p><p>包括三个操作数</p><ul><li><strong>V</strong>：要更新的变量（内存地址）。</li><li><strong>E</strong>：期望值。</li><li><strong>N</strong>：新值。</li></ul><p>CAS 指令会先比较 V 的当前值是否等于 E，如果相等，则将 V 的值原子性地更新为 N；如果不相等，则什么也不做。 整个比较和替换操作是一个原子操作。通常会返回一个布尔值，表示是不是操作成功</p><p>CAS 的实现依赖于 CPU 提供的原子指令。不同的 CPU 架构实现方式有所不同，但基本原理类似</p><p>在java中是使用的是JUC包下的原子类来实现CAS操作的。这些类通过 <code>Unsafe</code> 类来调用底层的 <code>cmpxchg</code> 指令。该指令的操作数与 CAS 的 V、E、N 对应。该指令会 lock 总线，从而实现原子性。</p><p><code>Unsafe</code> 类是 Java 提供的一个后门，可以直接访问底层系统资源，包括内存操作。<code>AtomicInteger</code> 等原子类使用 <code>Unsafe</code> 类的 <code>compareAndSwapInt</code> 等方法来实现 CAS。</p><p>在unsafe类里面静态方法尝试去先获取表示 <code>value</code> 字段在 <code>AtomicInteger</code> 对象中的内存偏移地址。</p><p>然后调用<code>compareAndSwapInt</code>方法去执行调用底层的 <code>cmpxchg</code> 指令</p><p>但是CAS有一个典型的ABA问题</p><p>如果一个变量 V 的值被修改为 A，然后又被修改回 A，CAS 操作会认为 V 的值没有发生变化，从而成功更新。但实际上，V 的值可能已经经过了其他的改变，只是最终又变回了 A。</p><p>我们可以加入版本号或者是时间戳的一个遍历来实现，CAS的时候不仅是要去比较变量的值，还要去比较版本号或者时间戳</p><p>或者是使用**<code>AtomicStampedReference</code>**，<code>AtomicStampedReference</code> 类维护了一个变量值和一个 Stamp（类似于版本号）。CAS 操作需要同时比较变量值和 Stamp，确保变量没有被修改过。</p><p>CAS应用在ConcurrenthashMap这种类里面，JUC包下的原子类里面，AQS的实现，还有自旋。不适合高冲突的场景</p><h2 id="16-详细说明一下concurrenthashmap的变化">16.详细说明一下concurrenthashmap的变化</h2><p>介绍一下，然后其他的线程安全的实现。</p><p>数据结构：由分段锁变为了数组链表+红黑树然后使用node数组来存储数据</p><p>线程安全的实现：</p><p>初始化的时候使用volatile+CAS来确保node数组的初始化</p><p>然后如果桶为空使用CAS，不为空使用synchronized锁住链表/红黑树的头节点。扩容的时候使用ForwardingNode标记正在迁移的桶</p><p>读操作的时候大部分情况无锁，使用volatile来保证可见性，node节点的next和val都是volatile来修饰的</p><p>效果：</p><p>锁粒度更细：只锁住具体的桶，而不是整个segment</p><p>读操作基本无锁</p><p>使用CAS减少锁竞争</p><p>然后扩容和红黑树变换</p><p>结合实际</p><h2 id="17-熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性">17.熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性</h2><p><strong>RocketMQ如何保证消息的幂等性？在您的项目中是如何实现的？</strong></p><p><strong>延迟消息的实现原理是什么？它有什么限制？</strong></p><p><strong>如果消费者处理消息失败，RocketMQ是如何处理的？死信队列的作用是什么？</strong></p><p>1.消息幂等：因为RocketMQ只保证了消息至少发送一次，所以我们要在业务逻辑上实现</p><p>通过业务唯一ID进行检查，然后尽量使用msg的key的操作来保持幂等，在数据库方面，使用唯一索引和去重表</p><p>2.延迟消息：延迟队列定时执行任务，只支持固定的18个延迟级别，可以在broker.conf文件中修改</p><p>3.异常处理：消息是先放入redis设计一个短的过期时间，然后执行业务逻辑，执行成功延长过期时间，失败就过期。然后ACK消息</p><p>然后设置消息为RECONSUME_LATER，执行重试逻辑。到达重试次数，记录日志，发送到死心队列进行人工处理，死信消息默认保留3天</p><h2 id="18-详细解释ZSet在Redis中的底层实现，以及跳表的使用场景">18.<strong>详细解释ZSet在Redis中的底层实现，以及跳表的使用场景</strong></h2><p>ZSet是Redis中一种常用的数据结构，用于存储有序的元素集合，它可以根据元素的分数（score）进行排序，通常用于排行榜等场景。</p><p>他的底层实现是两种数据结构</p><ol><li><p><strong>压缩列表（ziplist）：</strong> 在元素数量较少且元素成员（member）较短时使用。 压缩列表的特点是内存占用小，但插入、删除操作的效率较低，因为它需要进行连续的内存移动。</p><ul><li><strong>结构：</strong> 压缩列表是一种特殊的&quot;连续内存块&quot;构成的数据结构，类似于数组，但可以存储不同长度的数据。 它由多个entry组成，每个entry保存ZSet中的一个元素（member-score）。</li><li>**缺点：**当压缩列表中某个entry的长度发生变化时，可能会导致后续entry的offset也需要更新，如果更新的entry数量较多，就会导致连锁更新，影响性能。</li></ul></li><li><p><strong>跳表（skiplist） + 字典（dict）：</strong> 在元素数量较多或元素成员较长时使用。 跳表可以提供较高的插入、删除、查找效率，但会占用更多的内存空间。 字典则用于存储member到score的映射，使得可以通过member快速查找score。</p><ul><li><strong>跳表的定义：</strong> 跳跃表（skiplist）是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳表是一种概率型数据结构，它通过随机算法来决定每个节点拥有多少个指针。 跳表是一种可以实现平均O(log N) 查找，插入，删除的有序数据结构。</li><li><strong>跳表的结构：</strong> 跳表由多层链表组成，每一层链表都包含所有的元素，但元素之间的连接方式不同。 最底层是包含所有元素的有序链表，而上层链表则以一定的概率包含下层链表的元素，从而构成一种类似于索引的结构。 节点会包含一个后退指针（backward pointer），指向位于前一个节点。 在跳表中，节点按照它们的分值大小进行排序。</li><li><strong>字典的定义：</strong> 字典，也称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。</li></ul></li></ol><p>满足这两个条件就会使用跳表</p><ol><li><strong>元素数量超过<code>zset_max_ziplist_entries</code>配置的值（默认128）：</strong> 这个配置限制了使用压缩列表存储的元素数量。</li><li><strong>集合中任一member的长度大于<code>zset_max_ziplist_value</code>配置的值（默认64）：</strong> 这个配置限制了使用压缩列表存储的元素的长度。</li></ol><h2 id="19-ziplist的底层以及改进">19.ziplist的底层以及改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry1&gt;&lt;entry2&gt;...&lt;entryN&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure><p><code>zlbytes</code>：整个压缩列表占用字节数</p><p><code>zltail</code>：表尾节点距离起始地址的偏移量</p><p><code>zllen</code>：节点数量</p><p><code>entry</code>：各个节点</p><p><code>zlend</code>：标记压缩列表末端</p><p>每个entry</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen&gt;&lt;encoding&gt;&lt;entry-data&gt;</span><br></pre></td></tr></table></figure><p>当前一个节点长度从小于254字节变为大于等于254字节时,prevlen字段会从1字节扩展到5字节,可能引发后续节点的连锁扩展</p><p>然后就属于节点数量比较少的时候使用</p><p>在list中会被listpack代替，zset中被skiplist代替在listpack中，取消了prevlen字段，增加了len字段记录当前节点长度，可以从后往前遍历，避免连锁更新</p><h2 id="20-索引下推">20.索引下推</h2><p>SELECT * FROM users WHERE age &gt; 20 AND name LIKE ‘张%’ AND city = ‘北京’;</p><p>存在复合索引：<code>(age, name, city)</code></p><p>没有索引下推的话，使用索引定位范围测试之后，每一个查询都需要进行回表。然后在MySQL Server层过滤name和city条件</p><p>有索引下推的话，使用索引定位完之后，在索引层直接判断，只有同时满足三个条件的记录才回表。大幅度减少回表查询的次数</p><p>因为他范围查询，会破坏后续字段的有序性。正常无法走索引，但是索引下推可以。</p><p>使用 <code>EXPLAIN</code> 命令查看执行计划，确认是否使用了索引下推优化。ICP，然后进行调试让其走索引下推</p><h2 id="21-JVM垃圾回收器">21.JVM垃圾回收器</h2><p>分类：</p><p><strong>Serial / Parallel（吞吐优先）</strong></p><p><strong>CMS（低停顿）</strong></p><p><strong>G1（低停顿 + 区域化收集）</strong></p><p>**ZGC / Shenandoah（可预测、低延迟、支持大内存）**搜集场景题</p><table><thead><tr><th>收集器</th><th>特点</th><th>回收策略</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>CMS</strong></td><td>并发回收，停顿低，已淘汰</td><td>标记-清除/存在内存碎片问题</td><td>老项目，注重响应延迟（已不推荐）</td></tr><tr><td><strong>G1</strong></td><td>分区回收，预测停顿</td><td>Region + 标记-整理</td><td>推荐，适合大内存、对吞吐和延迟平衡</td></tr><tr><td><strong>ZGC</strong></td><td>并发、低延迟、支持 TB 级堆</td><td>可并发标记/重定位</td><td>极低停顿、现代系统（JDK ≥ 17）</td></tr></tbody></table><h2 id="22-Redis-数据库分布式锁">22.Redis&amp;数据库分布式锁</h2><p>我们一般就是使用的redisson，Redisson 基于 RedLock；提到了锁的可重入机制；与 AQS 有类比意识；简略提到数据库锁的粒度更大，Redis 粒度更细并发性更好；</p><p>Redisson 提供的是一种 <strong>基于 Redis 的可重入分布式锁实现</strong>，其原理包括：</p><ul><li>使用 Redis 的 <code>SET key value NX PX timeout</code> 命令原子性加锁；</li><li><code>value</code> 为唯一线程标识（如 UUID + ThreadId）；</li><li>可重入：同一个线程再次加锁会对 <code>value</code> 维护一个计数器；</li><li>释放锁时会先比对线程标识，确保只有锁的拥有者可以释放；</li><li>使用 Lua 脚本释放锁，保证原子性；</li><li>提供“看门狗机制（watchdog）”，定时自动续期避免超时释放锁；</li></ul><p>数据库：</p><p>常见方式有两种：</p><ul><li>利用数据库的行级锁（如基于 <code>select ... for update</code>）；</li><li>使用数据库表记录作为“锁资源”，进行 <code>insert/update</code> 加锁；</li></ul><p>特点：</p><ul><li>实现简单，易于理解；</li><li>可靠性高（依赖事务和 ACID）；</li><li><strong>性能差</strong>，阻塞严重，不适合高并发；</li><li>不具备重入机制，不支持超时释放；</li><li>会增加数据库压力，影响主业务。</li></ul><h1>场景题目</h1><h2 id="1-MySQL自增ID用完了怎么办？">1.MySQL自增ID用完了怎么办？</h2><p>那么我们先来分析一下，我们的自增ID最多可以多少呢？</p><p>如果是<em>INT类型</em>类型的话，普头的int，差不读能容纳约21的数据，UNSIGNED INT的话，能容纳43亿的数据</p><p>如果我们使用的BIGINT的话，-2^63^ ----2^63的数据，UNSIGNED BIGINT更多了，大约1844万亿的数据</p><p>一般的话，我们有一下几个方案：</p><p>1.INT升级到BIGINT，可以<em>使用pt-online-schema-change安全升级</em>，或者直接使用Mysql的ALTER TABLE your_table MODIFY COLUMN id BIGINT AUTO_INCREMENT;</p><p>这样的话，我们的数据量变大了，但是升级过程中会锁表，建议在维护窗口进行，而且需要同步修改相关的外键应用，而且java里面我们得用long字段而不是int字段了</p><p>2.分库分表，一般的我们可以根据ID的范围来分表，多少到多少为一个。这样分表比较简单。</p><p>3.使用UUID，是由32个十六进制数字组成的，因此一个UUID总共由128（32*4）个bit组成，也是说理论上有2的128次方个值可以使用。作为我们的自增主键，但是普通的UUID性能较差，可以使用OrderedUUID，这个有序的UUID，而且还可以将时间戳嵌入UUID的前缀，确保了有序性</p><p>4.使用雪花算法，利用机器ID和时间戳来生成64位长整型ID。最终生成的ID是会按时间递增的，但是也要考虑时钟回拨的问题，建议使用。</p><p>5.使用ID回收策略，回收被我们删除的ID，然后优先使用回收的ID，没有回收的话，才使用新的ID。一般用于实现假删除的表，但是我们需要去查，哪一些才是假删除的。</p><h2 id="2-如何把一个文件快速下发到100w个服务器">2.如何把一个文件快速下发到100w个服务器</h2><p>对于100万台服务器的文件快速下发问题，我感觉可以使用P2P网络来解决</p><p>我们传统的方案是中心化下发，一个传输端发送给很多的接收端，很显然，在这个场景下不合适</p><p>我们可以设计一下</p><p><strong>构建多个独立的生成树同时传输</strong>，将100万节点构建成<strong>3-5个不相交的生成树</strong>，每个节点在不同树中担任不同角色（有时是父节点，有时是子节点），文件分片后通过不同树路径并行传输</p><p><strong>分片策略</strong>，将大文件切分为N个数据块，不同的数据块交给不同的生成树，每个节点收集所有分片之后重组文件</p><p>我们构建三层架构，<strong>种子层</strong>：5-10台高带宽服务器作为初始种子，<strong>中继层</strong>：按地理位置/网络拓扑划分的1000-5000台中继节点，<strong>叶子层</strong>：普通服务器节点</p><p>减少网络的跳数，降低延迟。然后理由网络拓扑特性，避免跨地域传输。</p><p>然后建立容错机制，每个节点连接2-3个父节点并行下载，任一节点故障时子节点自动重新寻找父节点，通过健康检查和动态调整保证传输连续性。<strong>优化策略</strong>包括最稀缺分片优先传输、自适应带宽分配、就近父节点选择等。</p><p>这样的话，我们理论上O(log N)轮传输完成，实际10-15轮即可完成。</p><p>实际上是树状结构升级为容错的多树并行网络，既保持P2P高效性又解决了单点故障和路径瓶颈问题。</p><h2 id="3-服务器上如果有很多time-wait如何解决，以及出现这个问题的场景有哪些">3.服务器上如果有很多time wait如何解决，以及出现这个问题的场景有哪些</h2><p>首先time_wait是tcp连接中，主动关闭一方的状态，等待2MSL后关闭。然后服务器出现说明是服务器主动断开的连接</p><p>比如：</p><ol><li><strong>并发Web服务</strong>：比如电商大促期间，Nginx反向代理服务器向后端应用服务器发起大量短连接请求，每次请求完成后主动关闭连接，导致Nginx服务器积累大量TIME_WAIT状态。</li><li><strong>微服务架构</strong>：服务A调用服务B的REST API，使用HTTP短连接方式，每次调用后都关闭连接。在高QPS场景下，比如订单服务调用库存服务，会产生大量TIME_WAIT。</li><li><strong>数据库连接池配置不当</strong>：应用服务器连接MySQL时，如果没有使用连接池或连接池配置过小，频繁创建和关闭数据库连接，会在应用服务器上产生大量TIME_WAIT。</li><li><strong>监控和健康检查</strong>：负载均衡器（如F5、ELB）对后端服务器进行健康检查，每次检查都是短连接，高频率的健康检查会导致后端服务器TIME_WAIT堆积。</li></ol><p>timewait过多会导致：</p><p><strong>端口耗尽</strong>：Linux默认可用端口范围是32768-65535，大约3万个端口。当TIME_WAIT状态的连接达到这个数量时，无法创建新的出站连接，出现&quot;Cannot assign requested address&quot;错误。</p><p><strong>内存占用</strong>：每个TIME_WAIT连接都会占用一定的内核内存，大量堆积会消耗系统资源。</p><p>我们可以使用分层解决的办法</p><p>应用层：因为可能是http短连接导致的，我们启用<strong>启用HTTP Keep-Alive</strong>，在nginx里面配置keeplive</p><p>然后可能是数据库的频繁连接导致的，我们使用连接池，HikariCP、Druid。http的连接池，HttpClient的PoolingHttpClientConnectionManager，redis的连接池，Jedis Pool</p><p>系统层：</p><ol><li><strong>开启TIME_WAIT重用</strong>，使用echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse 参数设置为1开启</li><li><strong>TIME_WAIT超时时间</strong>设计减少，尽快让其超时</li><li>扩大端口的可用范围，ip_local_port_range增大</li><li><strong>增加socket buffer</strong>，/etc/sysctl.conf里面设置’net.core.rmem_max = 16777216’</li></ol><h2 id="4-服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置">4.服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置</h2><p>我们一般都是部署在linux服务器上，如果安装了监控软件的话，直接从监控软件上看</p><p>没有的话，我们使用top -c找出CPU占用最多的进程，然后top -H -PID 找出占用最多的线程</p><p>然后将线程ID转为16进制之后，jstack PID|grep -A 20 ID 查看其栈堆，对比找出我们具体是什么问题？</p><p>典型场景：</p><ol><li>死循环和无限递归</li><li>频繁的GC，我们可以jstat -gc PID 1000查看GC统计</li><li>正则表达式回溯，复杂的正则表达式出现了回溯</li><li>死锁，我们可以jstack PID|grep -A 5 -B &quot;deadlock&quot;直接显示死锁，或者是用<em>jconsole</em>等图形化工具来检测</li></ol><p>死锁的场景，<strong>数据库事务死锁</strong>，查询Mysql日志，<em>DEADLOCK</em>信息。然后在应用层的表现是，大量的线程阻塞在JDBC操作上</p><p>分布式死锁，主要是redis分布式锁，查找redis-cli keys “<em>lock</em>”，应用层表现是线程一直在等待锁</p><h2 id="5-有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现">5.有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现</h2><p>我们可以不主动查询，等用户登录到时候，执行会员过期时间的检测，给用户发送邮件提醒。但是这样用户不登录，我们没有办法提醒了就。而且我们要进行全表扫描，效率较低，数据库压力大。但我们可以将他作为补充的手段。</p><p>我们可以使用ES等搜索引擎，把会员表里的会员id和会员到期时间存储到搜索引擎里面。然后根据范围查询，查询到即将过期的用户，对他们发送消息。但是这样系统复杂度高了，而且我们还是需要进行定时轮询</p><p>可以使用redis，key为用户的id，value为该id的过期时间。然后使用redis的过期提醒功能，监视key的过期事件，检查成功发送邮件提醒。但是这样只能精确到秒，不能提前提醒，而且内存压力较大。</p><p>使用MQ延迟队列，计算该用户的过期事件，然后存储到延迟消息队列里面，轮询执行，一道过期事件发送消息。这是我们最佳的方案。</p><p>流程：</p><p>→ 计算提醒时间点（到期前7天、3天、1天）</p><p>→ 投递延迟消息到RocketMQ</p><p>→ 消息到期自动消费</p><p>→ 验证用户状态后发送邮件</p><p>然后加上补偿机制，定时执行任务，只扫描近期（如15天内）即将到期用户，然后查看是否发送，补偿未发送的。重新发送</p><p>然后这个过程中需要保持消息幂等，不应该多次发送，查询用户当前会员状态，然后检查到期时间，检查是否发送过，发送之后记录日志。消费失败后自动重试三次，发送失败进入死信队列处理。然后多个途径进行提醒。</p><p>RocketMQ作为消息队列，mysql作为主库，redis缓存用户的状态。</p><h2 id="6-假设你们系统有一个下单接口，突然并发量暴增，比如从-1k-QPS-涨到-10w-QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。">6.假设你们系统有一个下单接口，突然并发量暴增，比如从 1k QPS 涨到 10w QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。</h2><p>第一，限流。我们在网关层加了 Sentinel 做接口限流和熔断，防止系统被打垮。或者是我们使用AOP+bucket令牌桶进行限流</p><p>第二，缓存优化。我们使用了本地 + Redis 两级缓存，热点商品信息预加载，避免高并发直接打到数据库。然后防止缓存击穿，使用互斥锁</p><p>第三，异步削峰。下单写操作进入 MQ，由后台线程异步落库，极大缓解数据库压力。</p><p>第四，数据库层我们做了读写分离，写入走主库，查询走从库，提升吞吐。<br>最后就只能服务熔断了不行的话。</p><h2 id="7-你们系统中-Redis-如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？">7.你们系统中 Redis 如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？</h2><p>失效的影响：</p><p><strong>请求直打数据库</strong>：热点接口并发高时，数据库容易被压垮。</p><p><strong>响应时间变长</strong>：Redis 是内存级别，数据库响应慢，用户体验下降。</p><p><strong>缓存穿透</strong>：用户请求不存在的数据，Redis 拿不到，数据库压力大。</p><p><strong>缓存不一致</strong>：应用读了 Redis 旧值，可能会造成业务逻辑问题。</p><p>应对策略：</p><p>1）<strong>缓存高可用部署</strong></p><ul><li>Redis 使用主从 + Sentinel 实现自动故障转移；</li><li>或使用 Redis Cluster，提供分布式高可用能力。</li></ul><p>2）<strong>加缓冲 + 限流</strong></p><ul><li>引入线程池 / 信号量等方式限流；</li><li>使用本地缓存（如 Caffeine）做短时间的过渡保护。</li></ul><p>3）<strong>缓存预热 / 冷数据淘汰</strong></p><ul><li>关键数据在启动时预热到 Redis；</li><li>利用定时任务刷热点数据；</li><li>对非热点数据设置较短 TTL。</li></ul><p>4）<strong>避免缓存穿透 / 击穿 / 雪崩</strong></p><ul><li><strong>穿透</strong>：对 null 值做缓存 / 用布隆过滤器拦截；</li><li><strong>击穿</strong>：加互斥锁 / 单飞请求重建缓存；</li><li><strong>雪崩</strong>：设置随机 TTL + 限流 + 降级处理。</li></ul><p>5）<strong>降级与熔断</strong></p><ul><li>如果 Redis 和数据库都失败，降级为静态页 / 弹窗提示；</li><li>监控超时率，自动熔断部分接口，防止服务雪崩。</li></ul><p>热点数据丢失后？AOP的日志自己来恢复</p><p>用户体验如何保证？</p><p>redis的高可用，主从，哨兵，集群</p><p>缓存一致性保证，延迟双删策略</p><h2 id="8-假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？">8.假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？</h2><p>技术选型：</p><ol><li>concurrenthashmap+AtomicLong 精确统计，但是占内存较大，不适合大量用户</li><li>Redis HyperLogLog，内存占用小，适合大基数去重，有0.81%的误差，无法获取具体的元素</li></ol><h2 id="9-您在-生活商店优选-项目中提到了-多级缓存（Caffeine-Redis-MySQL）“和-基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：">9.您在&quot;生活商店优选&quot;项目中提到了&quot;多级缓存（Caffeine-Redis-MySQL）“和&quot;基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：</h2><p>多级缓存的数据一致性如何保证？</p><p>延迟双删+异步补偿</p><p>BCP中间件：</p><p>CDC方案，使用Canal订阅binglog然后通过MQ发送，缓存更新，允许短暂不一致，保证最终一致</p><p><strong>无侵入性</strong>：不需要修改业务代码</p><p><strong>准确性</strong>：只有事务提交后才会写入binlog</p><p><strong>完整性</strong>：捕获所有数据变更</p><p><strong>实时性</strong>：近实时同步</p><h2 id="10-mysql的分页查询优化">10.mysql的分页查询优化</h2><p>SELECT * FROM products ORDER BY id LIMIT 1000000, 20;</p><p>意识到了大偏移量会导致性能问题,</p><p>需要----</p><p>扫描并排序前1000020条记录</p><p>丢弃前1000000条记录</p><p>返回后20条记录,然后即使走了索引，也要&quot;数&quot;1000000条记录才能定位到起始位置</p><p>我们可以使用子查询来优化，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products p1 </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span></span><br><span class="line">) p2 <span class="keyword">ON</span> p1.id <span class="operator">=</span> p2.id;</span><br></pre></td></tr></table></figure><p>或者是使用游标，假设上页最后一个id是1000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-分库分表的查询如何进行">11.分库分表的查询如何进行</h2><p>如何定位需要查询的分表？</p><p>如何聚合多个分表的结果？</p><p>如何处理分页查询？</p><p>按用户ID分表（user_id % 16）</p><p>可以使用异构索引表来查询，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product_order_index (</span><br><span class="line">    product_id BIGINT,</span><br><span class="line">    user_id BIGINT,</span><br><span class="line">    order_id BIGINT,</span><br><span class="line">    table_suffix INT,  -- 记录在哪个分表</span><br><span class="line">    INDEX(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者是引入ES搜索</p><p>然后我们如何聚合查询呢？使用归并排序</p><p>从每个分表获取足够的数据，每个分表需要取 page * size + size 条数据，然后返回冰柜排序</p><h2 id="12-大数据量找最值">12.大数据量找最值</h2><p>就是一个非常大的数据量，然后在里面找出最大的数字</p><p>就是分三步，分桶，计数，比大小</p><p>先把大文件按照hash分成小文件，使用hash取模来分桶，同一个数字要进同一个桶</p><p>使用HashMap来找到出现次数最多的数字，然后遍历每个桶里面出现次数最多的，和当前全局最大值进行比较</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring面试题hot2-源码分析</title>
      <link>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础&lt;/h1&gt;
&lt;h2 id=&quot;1-什么是-IOC？&quot;&gt;1.什么是</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础</h1><h2 id="1-什么是-IOC？">1.什么是 IOC？</h2><p>IOC就是控制反转，反转之前是啥，，，反转之后是啥。。。。实现核心就是反射，设计模式是工厂模式</p><p>然后IOC和核心就是DI，几种实现方式，循环依赖的解决方式。</p><p>@bean的生命周期，@PostConstruct @PreDestroy，bean的作用域，单例，原型，websocket,session,request,application</p><p>bean的单例不一定是线程安全的，这个跟我们的业务逻辑有关，如果bean没有一个可变的成员变量，那么他就是无状态的，也就是线程安全的</p><p>我们为了保证线程安全可以改变作作用域为prototype，或者使用ThreadLocal，或者是用锁</p><p>IOC容器：</p><p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 都是Spring的IoC容器，但后者是前者的超集，提供了更强大的功能。</p><p><code>ApplicationContext</code>继承了<code>BeanFactory</code>，所以它具备<code>BeanFactory</code>的所有能力，同时还提供了更多面向企业应用的功能。它的预加载机制能帮助你在应用启动时就发现配置错误，而不是等到运行时才报错。</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>BeanFactory</strong></th><th style="text-align:left"><strong>ApplicationContext (推荐使用)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心定位</strong></td><td style="text-align:left">Spring IoC容器的<strong>基础接口</strong>，是“底层基础设施”。</td><td style="text-align:left">IoC容器的<strong>高级接口</strong>，是<code>BeanFactory</code>的子接口。</td></tr><tr><td style="text-align:left"><strong>Bean加载</strong></td><td style="text-align:left"><strong>懒加载 (Lazy-loading)</strong>：只有当<code>getBean()</code>被调用时，才会去实例化Bean。</td><td style="text-align:left"><strong>预加载 (Eager-loading)</strong>：容器启动时，会一次性实例化所有<code>singleton</code>作用域的Bean。</td></tr><tr><td style="text-align:left"><strong>功能丰富度</strong></td><td style="text-align:left">功能较少，主要提供Bean的注册和获取。</td><td style="text-align:left"><strong>功能非常丰富</strong>，除了<code>BeanFactory</code>的所有功能外，还提供了：</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>国际化支持 (i18n)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>事件发布与传播机制 (ApplicationEvent)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>AOP集成</strong>（自动识别并配置<code>BeanPostProcessor</code>等）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>Web环境支持</strong>（如<code>WebApplicationContext</code>）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>资源访问</strong>（如<code>classpath:</code>、<code>file:</code>前缀的资源加载）</td></tr><tr><td style="text-align:left"><strong>使用场景</strong></td><td style="text-align:left">对内存消耗要求极高的场景（如移动设备）。在现代企业应用开发中<strong>几乎不直接使用</strong>。</td><td style="text-align:left"><strong>绝大多数Spring应用和所有Spring Boot应用</strong>的默认选择。</td></tr></tbody></table><h2 id="2-什么是spring-Aop">2.什么是spring Aop</h2><p>AOP是啥，作用</p><p>实现的原理，动态代理，jdk,cgilb</p><p>几个概念，切面，连接点，通知，切点，织入</p><p>AOP通过<strong>织入(Weaving)</strong>，将<strong>切面(Aspect)<strong>中的</strong>通知(Advice)</strong>，应用到由**切点(Pointcut)<strong>匹配到的</strong>连接点(Join Point)<strong>所对应的</strong>目标对象(Target)**上。</p><p>通知类型，用了代理这个设计模式</p><p>代理对象（Proxy）接管了对目标对象（Target）的访问。所有外部调用都必须先经过代理对象。</p><p>代理对象在将调用请求转发给真正的目标对象<strong>之前</strong>或<strong>之后</strong>，有机会执行额外的操作。这些额外的操作，就是我们之前说的<strong>通知（Advice）</strong>，也就是切面逻辑。</p><p><strong>pring AOP的核心是基于动态代理实现的。它利用代理模式，在运行时为我们的目标Bean动态地创建一个代理对象。这个代理对象拦截了对原始Bean方法的所有调用，并在调用前后织入了我们定义的切面逻辑（比如日志、事务等），从而在不修改源代码的情况下，实现了功能的增强。</strong></p><p>这个只能作用在public方法上，所以非public的方法会失效</p><p>通知注解，@Around<strong>包裹</strong>在目标方法的整个执行过程周围。它是功能最强大、最灵活的通知。</p><p>环绕通知的第一个参数必须是<code>ProceedingJoinPoint</code>，它有一个<code>proceed()</code>方法。</p><ul><li>你可以在<strong>调用<code>proceed()</code>方法之前</strong>执行逻辑（等同于<code>@Before</code>）。</li><li>你可以<strong>决定是否调用<code>proceed()</code>方法</strong>，从而决定是否执行目标方法。</li><li>你可以在<strong>调用<code>proceed()</code>方法之后</strong>执行逻辑（等同于<code>@AfterReturning</code>）。</li><li>你可以<strong>修改目标方法的参数或返回值</strong>。</li><li>你可以<strong>捕获并处理目标方法抛出的异常</strong>（等同于<code>@AfterThrowing</code>）。</li></ul><h2 id="3-spring的常用注解">3.spring的常用注解</h2><p>组件：</p><p><strong><code>@Component</code></strong>，标记为一个组件，生成一个bean</p><p><strong><code>@Service</code></strong>，业务层的组件注解</p><p><strong><code>@Repository</code></strong>，DTO层的组件注解，但是能让Spring<strong>自动转换特定于平台的数据库异常</strong>为统一的<code>DataAccessException</code>。</p><p><strong><code>@Controller</code></strong>，controller层的组件注解</p><p><strong><code>@Scope</code></strong>，定义Bean的作用域。最常用的两个是：</p><ul><li><code>singleton</code>：（默认值）在整个应用中只有一个实例。</li><li><code>prototype</code>：每次请求（获取）时都会创建一个新的实例。request，websocket,context,session</li></ul><p><strong><code>@PostConstruct</code></strong> 和 <strong><code>@PreDestroy</code></strong>,初始化合销毁</p><p>DI</p><p><strong><code>@Autowired</code></strong>，按**类型（byType）<strong>自动注入依赖。如果找到多个相同类型的Bean，会尝试按</strong>名称（byName）**匹配。如果还找不到就会报错。</p><p><strong><code>@Qualifier(&quot;beanName&quot;)</code></strong>，指定bean的名称注入，多个bean相同的</p><p><strong><code>@Resource(name = &quot;beanName&quot;)</code></strong>，默认按名称注入，找不到就按类型注入</p><p>web</p><p><strong><code>@RestController</code></strong>，专门写API的</p><p><strong><code>@RequestMapping(&quot;/path&quot;)</code></strong>，指定URL</p><p><strong><code>@RequestParam</code></strong>，从请求的URL的？中获取参数</p><p><strong><code>@PathVariable</code></strong>，从URL路径里面获取参数</p><p><strong><code>@RequestBody</code></strong>，把发过来的JSON请求体变成一个Java对象</p><p>配置</p><p><strong><code>@SpringBootApplication</code></strong>=</p><ul><li><code>@SpringBootConfiguration</code>: (就是<code>@Configuration</code>)</li><li><code>@EnableAutoConfiguration</code>: 启用Spring Boot的自动配置机制。内部使用@Import注解是自动装配的核心，每发现一个自动配置类，就Selector使用条件判断来确实是不是满足导入条件，自动创建所选bean</li><li>@AutoConfigurationPackage，将项目src中main包下的所有组件注册到容器中</li><li><code>@ComponentScan</code>: 自动扫描启动类所在包及其子包下的所有组件。</li></ul><p><strong><code>@Value</code></strong>，配置文件读取值</p><p><strong><code>@Bean</code></strong>，作用方法上</p><p><strong><code>@Configuration</code></strong>，表明配置类</p><h2 id="4-Bean">4.@Bean</h2><p>创建-&gt;实例化-&gt;填充属性-&gt;初始化-&gt;可用和销毁</p><p>实例化：当客户端请求一个Bean，或者在容器启动时，Spring容器会查找Bean的定义。利用java的反射机制或者工厂方法创建一个原始的bean</p><p>填充属性，IOC容器识别bean的依赖关系，比如@Autowired@Resource。从容器中查找对应的bean，通过反射将依赖注入到bean的属性中</p><p>初始化，最重要的点，扩展点最多的。</p><p><strong>执行Aware接口的方法</strong>，实现了特定的<code>Aware</code>接口，比如BeanNameAware<code>, </code>BeanFactoryAware<code>, </code>ApplicationContextAware</p><p><strong>执行<code>BeanPostProcessor</code>的前置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法。</p><p><strong>执行<code>@PostConstruct</code>注解的方法</strong>，调用使用了@postConstruct的方法</p><p><strong>执行<code>InitializingBean</code>接口的方法</strong>，实现了<code>InitializingBean</code>接口，Spring会调用它的<code>afterPropertiesSet()</code>方法。</p><p><strong>执行自定义的<code>init-method</code></strong>，如果在XML配置或<code>@Bean</code>注解中指定了<code>init-method</code>，Spring会调用这个自定义的初始化方法。</p><p><strong>执行<code>BeanPostProcessor</code>的后置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法。</p><p>Spring的**AOP（动态代理）**就是在这个阶段通过包装原始Bean实例，并返回一个代理对象来实现的。我们平时拿到的Bean，很多时候其实是这一步处理后的代理对象。</p><p>可用和销毁，当Spring容器关闭时（或者对于非<code>singleton</code>作用域的Bean，当其作用域结束时）。按照顺序执行</p><ul><li><strong>执行<code>@PreDestroy</code>注解的方法</strong>：如果Bean的方法上使用了<code>@PreDestroy</code>注解，Spring会调用这个方法。这也是<strong>推荐</strong>的销毁回调方式。</li><li><strong>执行<code>DisposableBean</code>接口的方法</strong>：如果Bean实现了<code>DisposableBean</code>接口，Spring会调用它的<code>destroy()</code>方法。</li><li><strong>执行自定义的<code>destroy-method</code></strong>：如果在XML配置或<code>@Bean</code>注解中指定了<code>destroy-method</code>，Spring会调用这个方法。</li></ul><p>扩展点</p><p><strong><code>BeanFactoryPostProcessor</code></strong></p><ul><li><strong>作用时机</strong>：在Spring容器<strong>加载了所有Bean的定义信息（BeanDefinition），但尚未创建任何Bean实例之前</strong>。</li><li><strong>能力</strong>：允许你<strong>读取并修改Bean的定义元数据</strong>。例如，你可以动态地修改某个Bean的属性值，甚至更改它的作用域。</li><li><strong>通俗理解</strong>：给你一个机会在“蓝图”阶段修改设计图纸，而不是等房子建好了再去敲墙。</li></ul><p>比如是在<code>application.properties</code>中使用占位符 <code>$&#123;...&#125;</code> 的功能(<code>PropertySourcesPlaceholderConfigurer</code>)。MyBatis的<code>MapperScannerConfigurer</code>，它会扫描接口并将其注册为Bean定义。</p><p><strong><code>BeanPostProcessor</code></strong></p><ul><li><p><strong>作用时机</strong>：在Bean<strong>实例化和属性填充之后，初始化方法（<code>init-method</code>, <code>@PostConstruct</code>）的前后</strong>。</p></li><li><p>能力</p><p>：包含两个方法：</p><ul><li><code>postProcessBeforeInitialization</code>: 在初始化之前干预。</li><li><code>postProcessAfterInitialization</code>: 在初始化之后干预。<strong>Spring的AOP就是通过它实现的</strong>，在此处返回Bean的代理对象。</li></ul></li><li><p><strong>通俗理解</strong>：在房子建好（实例化）并装修完（填充属性）之后，在主人入住（可用）前后，给你机会对房子进行“精装修”或“改造”（如加装监控系统-AOP）。</p></li></ul><p><strong><code>Aware</code>系列接口</strong>:</p><ul><li><strong>作用时机</strong>：在Bean的初始化阶段，<code>BeanPostProcessor</code>之前。</li><li><strong>能力</strong>：让Bean能“感知”并获取到Spring容器自身的资源，如<code>ApplicationContext</code>、<code>BeanFactory</code>、<code>BeanName</code>等。</li><li><strong>通俗理解</strong>：让Bean知道自己“身在何处”以及“叫什么名字”。</li></ul><p><strong><code>InitializingBean</code>和<code>DisposableBean</code></strong>:</p><ul><li><strong>作用时机</strong>：初始化和销毁阶段的特定回调。</li><li><strong>能力</strong>：提供<code>afterPropertiesSet()</code>和<code>destroy()</code>方法，用于自定义初始化和销毁逻辑。</li><li><strong>通俗理解</strong>：Bean的“出生仪式”和“临终遗言”的固定写法。（现在更推荐使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，因为无代码侵入）</li></ul><h2 id="5-spring事务">5.spring事务</h2><p>事务分为声明型事务和编程型事务</p><p>声明型事务，通过注解**<code>@Transactional</code>**来声明，他的底层是基于AOP实现的</p><ul><li><ol><li>Spring容器在启动时，会为标记了<code>@Transactional</code>的Bean创建一个<strong>代理对象 (Proxy)</strong>。</li><li>当外部调用这个代理对象的方法时，代理逻辑会先被触发。</li><li><strong>事务开始</strong>：代理逻辑会负责开启事务（例如，禁用数据库连接的自动提交 <code>connection.setAutoCommit(false)</code>）。</li><li><strong>执行业务</strong>：然后，代理对象再调用你编写的原始业务方法。</li><li>事务提交/回滚：<ul><li>如果业务方法正常执行完毕，代理逻辑会<strong>提交</strong>事务。</li><li>如果业务方法抛出<strong>运行时异常 (RuntimeException)</strong> 或 <strong>Error</strong>，代理逻辑会<strong>回滚</strong>事务。</li></ul></li></ol></li><li><strong>优点</strong>：对业务代码<strong>无侵入</strong>，将事务管理代码与业务逻辑彻底解耦，使得代码非常清晰。</li></ul><p>编程型事务，在业务代码中，通过手动调用<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>的API来精确地控制事务的边界。</p><p>然后调用方法，自己进行手动的提交和手动的回滚</p><p>提供了极高的灵活性，可以实现非常精细的事务控制，比如在一个方法内实现多次提交或回滚。但是高耦合</p><p>事务的隔离级别跟mysql的事务的隔离级别相同。多了一个**<code>DEFAULT</code><strong>：这是<code>@Transactional</code>注解的</strong>默认值**。它表示使用数据库本身设置的默认隔离级别。一般数据库的事务的隔离级别就是rr</p><p>或者rc?</p><p>但是事务会失效的，事务失效的场景如下：</p><p>AOP代理有关的</p><ol><li><strong>方法不是<code>public</code>的</strong><ul><li><strong>原因</strong>：Spring AOP的代理机制在为类创建代理时，只会代理其<code>public</code>方法。如果你将<code>@Transactional</code>注解用在<code>protected</code>、<code>private</code>或<code>package-private</code>方法上，事务不会生效，也不会有任何报错。</li><li><strong>一句话总结</strong>：<strong>代理对象无法覆盖非公有方法</strong>。</li></ul></li><li><strong>方法被<code>final</code>修饰</strong><ul><li><strong>原因</strong>：被<code>final</code>修饰的方法无法被子类重写（Override）。Spring的CGLIB动态代理是通过创建目标类的子类来实现的，因此无法代理<code>final</code>方法。</li><li><strong>一句话总结</strong>：<strong>final方法无法被代理</strong>。</li></ul></li><li><strong>同一个类中的方法调用（<code>this</code>调用）</strong><ul><li><strong>原因</strong>：这是最常见也最隐蔽的失效场景。当你在一个Bean的<code>methodA</code>中调用同一个类中的<code>methodB</code>（<code>methodB</code>有<code>@Transactional</code>注解）时，这个调用是通过<code>this</code>指针直接发生的，<strong>绕过了代理对象</strong>。事务增强逻辑是存在于代理对象中的，所以事务会失效。</li></ul></li></ol><p>跟运行时异常有关的</p><ol><li><strong>异常被<code>try-catch</code>捕获了</strong><ul><li><strong>原因</strong>：Spring声明式事务默认只在遇到<strong>RuntimeException或Error</strong>时才会回滚。如果你在事务方法内部用<code>try-catch</code>捕获了异常，并且没有在<code>catch</code>块中重新抛出，那么Spring的事务代理就无法感知到异常的发生，从而会正常提交事务。</li><li><strong>一句话总结</strong>：<strong>异常没有传播到代理层，代理以为一切正常</strong>。</li></ul></li><li><strong>指定了不回滚的异常类型</strong><ul><li><strong>原因</strong>：在<code>@Transactional(noRollbackFor = ...)</code>中指定了某个异常类，那么当这个异常发生时，事务将不会回滚。</li><li><strong>示例</strong>：<code>@Transactional(noRollbackFor = NullPointerException.class)</code></li></ul></li></ol><p>事务有关的</p><ol><li><strong>数据库引擎不支持事务</strong><ul><li><strong>原因</strong>：例如，MySQL的MyISAM引擎就不支持事务。如果表使用了不支持事务的引擎，所有事务相关的操作都会被静默忽略。</li><li><strong>一句话总结</strong>：<strong>底层基础不支持，上层框架无能为力</strong>。</li></ul></li><li>事务的传播类型设置的不对，比如不支持事务never</li></ol><p>事务的传播机制：</p><ol><li><strong><code>REQUIRED</code> (需要)</strong><ul><li><strong>描述</strong>：这是<strong>默认</strong>的传播特性。如果当前存在一个事务，那么新方法就<strong>加入</strong>到这个事务中。如果当前没有事务，就<strong>新建</strong>一个事务。</li><li><strong>场景</strong>：绝大多数情况下的选择。</li></ul></li><li><strong><code>SUPPORTS</code> (支持)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就加入。如果当前没有事务，就以<strong>非事务</strong>的方式执行。</li><li><strong>场景</strong>：用于那些“可有可无”的事务方法，比如一些只读查询操作。</li></ul></li><li><strong><code>MANDATORY</code> (强制)</strong><ul><li><strong>描述</strong>：<strong>强制</strong>要求当前必须存在一个事务。如果当前没有事务，就会抛出异常。它不会自己创建事务。</li><li><strong>场景</strong>：用于那些必须在事务环境下执行的核心操作，起到一种校验作用。</li></ul></li><li><strong><code>REQUIRES_NEW</code> (需要新的)</strong><ul><li><strong>描述</strong>：<strong>总是创建一个全新的、独立的事务</strong>。如果当前已经存在一个事务，会把当前事务<strong>挂起</strong>，然后执行新事务。新事务执行完毕后，再恢复被挂起的事务。</li><li><strong>场景</strong>：希望某些操作的事务结果独立于外部事务，不受其影响。比如，在一个大的下单流程中，记录操作日志，无论下单成功与否，日志都必须成功入库。</li></ul></li><li><strong><code>NOT_SUPPORTED</code> (不支持)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，会把当前事务<strong>挂起</strong>。</li><li><strong>场景</strong>：用于那些明确不希望在事务中运行的方法。</li></ul></li><li><strong><code>NEVER</code> (从不)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，就会抛出异常。</li><li><strong>场景</strong>：用于和<code>MANDATORY</code>相对的校验场景。</li></ul></li><li><strong><code>NESTED</code> (嵌套)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就在这个事务中创建一个<strong>嵌套事务（保存点 Savepoint）</strong>。嵌套事务独立于外部事务进行提交或回滚。如果外部事务回滚，嵌套事务也会回滚。但嵌套事务的回滚不影响外部事务。如果当前没有事务，行为等同于<code>REQUIRED</code>。</li><li><strong>注意</strong>：这是一个部分数据库才支持的特性（如Oracle），需要底层JDBC驱动和数据库的支持。</li></ul></li></ol><h2 id="6-spring-MVC">6.spring MVC</h2><p>MVC 设计模式：</p><p>model-&gt;view-&gt;controller</p><p>作用：</p><ol><li><strong>实现MVC模式的解耦</strong>：它提供了一套清晰的架构，将处理请求的控制器、业务逻辑的模型和展示用的视图分离开来，极大地提高了代码的可维护性、可扩展性和可测试性。</li><li><strong>简化Web开发</strong>：它基于Servlet API构建，但极大地简化了底层的Servlet、Request、Response等对象的直接操作。开发者可以用简单的注解（如<code>@GetMapping</code>, <code>@PostMapping</code>）来处理复杂的HTTP请求。</li><li><strong>与Spring生态无缝集成</strong>：它可以非常方便地使用Spring核心的IoC和AOP功能，轻松整合Service层、DAO层以及事务管理等。</li><li><strong>提供强大的功能</strong>：内置了强大的参数绑定、数据校验、RESTful风格支持、拦截器、国际化、文件上传等一系列Web开发所需的核心功能。</li></ol><p>springmvc核心组件&amp;&amp;执行过程c</p><p>常用注解，那几个mappring 参数绑定的那几个</p><p>深入知识：</p><p>1.<strong>统一异常处理 (<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>)</strong></p><ul><li><strong>作用</strong>：通过创建一个带有<code>@ControllerAdvice</code>注解的类，可以在其中定义多个<code>@ExceptionHandler</code>方法，来集中处理整个应用中由Controller抛出的特定异常。这避免了在每个Controller中都写<code>try-catch</code>，实现了优雅的全局异常处理。</li><li><strong>示例</strong>：捕获所有<code>NullPointerException</code>，并返回一个自定义的错误JSON。</li></ul><p>2.<strong>拦截器 (<code>HandlerInterceptor</code>)</strong></p><ul><li><p><strong>作用</strong>：提供了在请求处理的生命周期中（<strong>Controller方法执行前后</strong>）织入自定义逻辑的能力。它比Servlet Filter更精细，因为它能访问到即将执行的<code>Handler</code>信息。</p></li><li><p>三大方法</p><p>：</p><ul><li><code>preHandle</code>: 在Controller方法执行<strong>之前</strong>调用。可以进行权限验证、日志记录等。返回<code>false</code>则中断后续流程。</li><li><code>postHandle</code>: 在Controller方法执行<strong>之后</strong>，视图渲染<strong>之前</strong>调用。可以修改<code>ModelAndView</code>中的数据。</li><li><code>afterCompletion</code>: 在整个请求处理完成（包括视图渲染）<strong>之后</strong>调用。主要用于资源清理。</li></ul></li><li><p><strong>与Filter的区别</strong>：Filter是Servlet规范的一部分，作用范围更广，能处理所有HTTP请求；Interceptor是Spring MVC的一部分，只能处理经过<code>DispatcherServlet</code>的请求，但能获取到Spring MVC的上下文信息。</p></li></ul><p>3.<strong>数据绑定与类型转换 (<code>DataBinder</code>, <code>Converter</code>)</strong></p><p>Spring MVC能自动将请求参数（都是字符串）转换为Controller方法参数所需的类型（如<code>Integer</code>, <code>Date</code>）。这个过程就是数据绑定。我们可以通过实现<code>Converter</code>接口，并将其注册到Spring中，来定义自定义的类型转换逻辑（例如，将&quot;2023-01-01&quot;字符串转换为<code>LocalDate</code>对象）。</p><p>4.<strong>跨域请求处理 (<code>@CrossOrigin</code>)</strong></p><ul><li><strong>作用</strong>：简单方便地解决Web开发中常见的跨域资源共享（CORS）问题。可以直接在<code>Controller</code>类或方法上使用<code>@CrossOrigin</code>注解，来允许来自特定域的跨域请求。</li></ul><h2 id="7-springboot">7.springboot</h2><p>springboot是啥，四大特性（自动配置，starter，内嵌web服务器，无需xml配置）</p><p>常用的starter，Starter本质上是一个<strong>Maven依赖描述符 (pom)</strong>。它的作用是将实现某一特定功能所需的所有依赖项打包在一起，并触发与该功能相关的自动配置。</p><p>启动springboot，</p><p>spring-boot-devtools热部署工作原理：</p><p>当<code>devtools</code>检测到classpath下的文件发生变化时，它会触发应用<strong>快速重启</strong>（不是完全重启，速度很快）。它通过维护两个类加载器（一个加载不变的第三方库，一个加载你自己的代码）来实现这一点，只重新加载你自己写的代码，从而大大加快了速度。</p><p><strong>Spring Boot JAR 与 普通JAR的区别</strong></p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>普通JAR (Thin JAR)</strong></th><th style="text-align:left"><strong>Spring Boot JAR (Fat JAR / Executable JAR)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>内容</strong></td><td style="text-align:left">只包含你项目自己编译的<code>.class</code>文件和资源文件。</td><td style="text-align:left"><strong>包含所有内容</strong>：你的代码、资源文件，以及项目所需的所有第三方依赖库的JAR包。</td></tr><tr><td style="text-align:left"><strong>大小</strong></td><td style="text-align:left">非常小。</td><td style="text-align:left">非常大，因此也叫“胖JAR”。</td></tr><tr><td style="text-align:left"><strong>运行方式</strong></td><td style="text-align:left">不能直接<code>java -jar</code>运行（除非配置了<code>Main-Class</code>且无外部依赖）。通常是作为其他项目的库被引用。</td><td style="text-align:left">可以通过<code>java -jar</code>命令<strong>直接运行</strong>，因为它内置了所有依赖和启动逻辑。</td></tr><tr><td style="text-align:left"><strong>结构</strong></td><td style="text-align:left">标准JAR结构。</td><td style="text-align:left">特殊的结构。解压后会看到一个<code>BOOT-INF</code>目录，里面包含了<code>classes</code>（你的代码）和<code>lib</code>（所有依赖的JAR包）。还有一个<code>org/springframework/boot/loader</code>目录，这是Spring Boot的启动加载器。</td></tr></tbody></table><p>自动装配原理，Spring Boot的自动装配核心在于<code>@SpringBootApplication</code>注解，而这个注解又是一个组合注解，其中最关键的是<code>@EnableAutoConfiguration</code>。</p><ol><li><strong><code>@EnableAutoConfiguration</code></strong>：这个注解是自动配置的开关。</li><li><strong><code>@Import(AutoConfigurationImportSelector.class)</code></strong>：<code>@EnableAutoConfiguration</code>内部通过<code>@Import</code>注解导入了<code>AutoConfigurationImportSelector</code>这个类。</li><li><strong><code>AutoConfigurationImportSelector</code></strong>：这个类的核心作用是去<strong>加载和筛选</strong>需要被激活的自动配置类。</li><li><strong>扫描<code>META-INF/spring.factories</code></strong>：它会扫描项目中所有JAR包的<code>META-INF/spring.factories</code>文件。这个文件中定义了所有可能的自动配置类（key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>）。</li><li><strong>按需加载</strong>：<code>Selector</code>会根据<strong>条件注解 (<code>@ConditionalOnClass</code>, <code>@ConditionalOnBean</code>等)</strong> 来判断这些自动配置类是否满足生效条件（比如<code>DataSourceAutoConfiguration</code>只有在classpath下存在<code>DataSource.class</code>时才会生效）。</li><li><strong>注入Bean</strong>：最终，满足条件的自动配置类被加载到Spring容器中，它们内部定义的各种Bean（如<code>DataSource</code>, <code>RestTemplate</code>）就被创建并注入了。</li></ol><p>@Import注解：</p><p><code>@Import</code>是Spring框架提供的基础注解，它比<code>@Bean</code>更强大，通常用于<strong>批量导入Bean</strong>或者<strong>导入配置类</strong>。它有三种主要使用方式，而Spring Boot的自动配置正是利用了第三种：</p><ol><li><strong>导入普通的类</strong>：<code>@Import(MyService.class)</code>，Spring会将<code>MyService</code>注册为一个Bean。</li><li><strong>导入配置类</strong>：<code>@Import(MyConfig.class)</code>，Spring会加载<code>MyConfig</code>这个配置类以及它内部定义的所有<code>@Bean</code>。</li><li><strong>导入<code>ImportSelector</code>实现类</strong>：<strong>这是最关键的用法</strong>。<code>@Import(MyImportSelector.class)</code>，Spring会实例化<code>MyImportSelector</code>，并调用它的<code>selectImports()</code>方法，该方法返回一个字符串数组，数组里的每一个类名都会被Spring注册为Bean。<strong>Spring Boot的自动配置就是通过这种方式，动态地、可选择地加载了大量的配置类。</strong></li></ol><h1>spring源码分析</h1><h2 id="bean">bean</h2><p>凡是可以存放数据的具体数据结构实现，都可以称之为容器，在 Spring Bean 容器的场景下，我们需要一种可以用于存放和名称索引式的数据结构，所以选择 HashMap 是最合适不过的。</p><p>HashMap 是一种基于扰动函数、负载因子、红黑树转换等技术内容，形成的拉链寻址的数据结构，它能让数据更加散列的分布在哈希桶以及碰撞时形成的链表和红黑树上。它的数据结构会尽可能最大限度的让整个数据读取的复杂度在 O(1) ~ O(Logn) ~O(n)之间，当然在极端情况下也会有 O(n) 链表查找数据较多的情况。不过我们经过10万数据的扰动函数再寻址验证测试，数据会均匀的散列在各个哈希桶索引上，所以 HashMap 非常适合用在 Spring Bean 的容器实现上。但是我们实际上应用的是concurrenthashmap，因为他是线程安全的。我们的bean不可能只是单线程进行操作的。他是一个弱一致性迭代器，避免了并发的修改异常。</p><p>一个简单的 Spring Bean 容器实现，还需 Bean 的定义、注册、获取三个基本步骤</p><ul><li>定义：BeanDefinition，可能这是你在查阅 Spring 源码时经常看到的一个类，例如它会包括 singleton、prototype、BeanClassName 等。</li><li>注册：这个过程就相当于我们把数据存放到 HashMap 中，只不过现在 HashMap 。在我们注册阶段Map里面存储的是beanDefintion</li><li>获取：最后就是获取对象，Bean 的名字就是key，Spring 容器初始化好 Bean 以后，就可以直接获取了。</li><li>实例化完成之后里面存储的才是bean实例</li></ul><p>我们解决循环依赖的三级缓存就是这么设计的，key是bean的名字，value是bean的实例。</p><hr><p>Spring Bean 容器的整个实现内容非常简单，也仅仅是包括了一个简单的 BeanFactory 和 BeanDefinition</p><ol><li>BeanDefinition，用于定义 Bean 实例化信息，现在的实现是以一个 Object 存放对象，可以继续添加属性，比如:SCOPE_SINGLETON、SCOPE_PROTOTYPE、ROLE_APPLICATION、ROLE_SUPPORT、ROLE_INFRASTRUCTURE 以及 Bean Class 信息。</li><li>BeanFactory，代表了 Bean 对象的工厂，可以存放 Bean 定义到 Map 中以及获取。</li></ol><p><code>BeanDefinition</code> 是 Spring IoC 容器的基石，它是 Bean 的一切元数据（类名、作用域、构造函数参数、属性等）的载体，是面向接口编程思想的体现。容器操作的是 <code>BeanDefinition</code>，而非直接操作 <code>Class</code>。</p><p><code>DefaultListableBeanFactory</code> 中 <code>beanDefinitionMap</code> 这个 <code>ConcurrentHashMap</code>，所有加载的 <code>BeanDefinition</code> 都存储于此。</p><p>将 Bean 的定义信息封装成一个标准化的数据结构，使得容器上层逻辑可以统一处理，与 Bean 的来源（XML, 注解）解耦。</p><p>在 Bean 工厂的实现中，包括了 Bean 的注册，这里注册的是 Bean 的定义信息。同时在这个类中还包括了获取 Bean 的操作。</p><p>然后我们使用的时候，是先初始化beanfactory容器，然后通过beanDefinition来创建一个bean。</p><p>然后去通过beanfactory去获取我们注册的bean，然后去使用bean里面封装的方法。这个时候才会实例化</p><p>然后实际我们使用的spring容器比如说是<strong>DefaultListableBeanFactory</strong>，他是继承了AbstractAutowireCapableBeanFactory，然后实现了ConfigurableListableBeanFactory, BeanDefinitionRegistry</p><p>里面包括存储BeanDefinition的容器，存储bean定义名词的列表，一级缓存，已经完成初始化的单例bean,二级缓存，早期bean的引用。三级缓存，单例工厂</p><p>我们注册bean的时候bean并没有实例化，直到获取bean的时候才会实例化，这就是懒加载</p><p>获取的时候先从一级缓存获取，缓存没有才创建bean</p><p><code>BeanFactory</code>: 顶层接口，定义了 <code>getBean()</code> 等核心方法。</p><p><code>ListableBeanFactory</code>: 扩展接口，提供枚举所有 Bean 的能力。</p><p><code>ConfigurableListableBeanFactory</code>: <code>BeanFactory</code> 体系的终极接口，几乎包含了所有功能。</p><p><code>ApplicationContext</code>: 继承了 <code>ListableBeanFactory</code> 和其他多个高级接口。</p><p><code>AbstractApplicationContext</code>: 核心中的核心，其 <code>refresh()</code> 方法定义了容器启动的完整流程。</p><p>rerfesh方法：</p><hr><p>加载的一个链路：</p><p>注解：从 <code>AnnotationConfigApplicationContext</code> 构造函数出发 -&gt; <code>this.scanner.scan(...)</code> -&gt; <code>ClassPathBeanDefinitionScanner.doScan()</code> -&gt; <code>findCandidateComponents()</code> (扫描路径，找到符合条件的类) -&gt; <code>isCandidateComponent()</code> (检查是否包含 <code>@Component</code> 等注解) -&gt; <code>registerBeanDefinition()</code>。</p><p><strong>XML 路径</strong>: 从 <code>AbstractXmlApplicationContext</code> 的构造函数出发 -&gt; <code>loadBeanDefinitions(new XmlBeanDefinitionReader(this))</code> -&gt; <code>XmlBeanDefinitionReader.loadBeanDefinitions()</code> -&gt; <code>doLoadDocument()</code> (将XML转为DOM) -&gt; <code>registerBeanDefinitions()</code> (解析DOM并注册 <code>BeanDefinition</code>)。</p><h2 id="设计模式">设计模式</h2><p>职责分清，一个接口只关注一个核心的职责，通过组合来实现多种能力。这样的话，方便我们的后续扩展和维护</p><p>比如我们的BeanFactory只负责获取bean,SingletonBeanRegistry只负责单例bean的管理，BeanDefinitionRegistry 只负责定义注册</p><p>模板方法模式，所有子类都遵循相同的Bean获取流程，子类只需实现特定的抽象方法，通用逻辑在父类中实现</p><p>比如一个抽象的基类AbstractBeanFactory定义了获取bean的标准流程，先去看一级缓存中有没有，没有的话，获取一个beandefinition，然后创建实例化这个bean</p><p>然后剩下的方法只是定义完，具体的逻辑留给子类实现</p><p>分层架构，每一层都该干属于自己的事情，比如接口层定义契约和规范，然后抽象类层，实现通用的逻辑和模板方法，实现类层，实现具体的业务逻辑实现</p><p>然后在我们的项目中，比如说实现一个支付的实现的话，我们可以先创建一个支付接口，定义一个执行方法。</p><p>然后创建一个所有的支付类共同的抽象类，实现支付的基本逻辑，先检验参数，然后执行，获取执行结果，返回执行结果</p><p>然后子类具体的去实现这个执行的逻辑，比如支付宝的具体的实现逻辑</p><p>比如说我们在项目中可以根据我们的类型来选择我们要实例化bean的模式，一般就是普通的jdk代理或者是cglib代理，可以在bean属性中class里面设定，然后我们根据属性的设定来选择我们具体是选择哪一种策略。</p><h2 id="实例化">实例化</h2><p>jdk实例化，首先通过 beanDefinition 获取 Class 信息，这个 Class 信息是在 Bean 定义的时候传递进去的。然后看我们获取的class信息是不是空的，空的就是无构造函数实例化，不是空的就是有构造函数实例化。这里我们重点关注有构造函数的实例化，实例化方式为 <code>clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</code>，把入参信息传递给 newInstance 进行实例化。比较简单，适用于简单的pojo对象。</p><p>cglib实例化,先是构建enhancer，设置目标为父类。设置回溯，使用noop就是说明不需要额外的处理。可以设置<code>MethodInterceptor</code>等其他回调来实现AOP功能</p><p>如果class信息为空，就enhacers默认的创建，不为空的话，就创建我们指定的构造器的类型。</p><p>支持动态代理，适用于需要进行增强的对象。运行的时候动态的生成新的class文件，比如需要事务代理，需要缓存代理的</p><table><thead><tr><th>特性</th><th>JDK反射</th><th>Cglib动态代理</th></tr></thead><tbody><tr><td><strong>实现原理</strong></td><td>Java原生反射API</td><td>字节码动态生成</td></tr><tr><td><strong>性能表现</strong></td><td>反射调用开销较小</td><td>首次创建开销大，后续调用快</td></tr><tr><td><strong>功能扩展</strong></td><td>仅支持实例化</td><td>支持方法拦截、AOP增强</td></tr><tr><td><strong>依赖要求</strong></td><td>无额外依赖</td><td>需要cglib和asm库</td></tr><tr><td><strong>代理限制</strong></td><td>无法代理final类/方法</td><td>无法代理final类/方法</td></tr></tbody></table><h2 id="注入">注入</h2><p>属性填充的时机，实在对象创建后立刻进行。<strong>. PropertyValue - 属性值载体****，PropertyValues - 属性集合管理</strong> <strong>BeanReference - 对象依赖标识</strong></p><ul><li><strong>延迟解析</strong>：不是直接存储Bean对象，而是存储Bean名称</li><li><strong>递归创建</strong>：在属性填充时才真正创建依赖的Bean</li><li><strong>循环依赖预留</strong>：为后续处理循环依赖留下接口</li></ul><p>属性填充方法，内部使用递归，检测到<code>BeanReference</code>类型，调用<code>getBean(beanReference.getBeanName())</code>获取他的依赖的名字</p><p>使用递归获取，被依赖的Bean创建完成后返回，用创建好的Bean对象填充当前Bean的属性</p><p>框架自动处理依赖关系，开发者无需关心创建顺序，只有真正需要这个bean的时候才会创建，提高了性能。然后我们创建后的Bean会被缓存，避免重复创建。这是缓存的思想</p><p>处理循环依赖：使用三级缓存架构来解决，一级缓存，完整的bean。二级缓存，实例化，没有进行属性的填充。三级缓存，bean的工厂对象，用于解决aop代理的问题</p><table><thead><tr><th>缓存级别</th><th>存储内容</th><th>作用</th><th>时机</th></tr></thead><tbody><tr><td><strong>一级缓存</strong></td><td>完整的Bean对象</td><td>存放完全初始化好的Bean</td><td>Bean创建完成后</td></tr><tr><td><strong>二级缓存</strong></td><td>早期Bean对象</td><td>存放实例化但未填充属性的Bean</td><td>解决循环依赖时</td></tr><tr><td><strong>三级缓存</strong></td><td>ObjectFactory</td><td>用于创建代理对象</td><td>Bean实例化后立即放入</td></tr></tbody></table><p>扩展支持private boolean allowCircularReference = true;</p><p><strong>DefaultSingletonBeanRegistry</strong>：</p><p>一级一级的调用，先去找一次缓存没有，标记为正在创建，然后再找二级缓存，允许早期引用。没有就从三级缓存中获取，还没有的话，<em>通过ObjectFactory创建Bean</em></p><p>然后放入二级缓存，从三级缓存中删除。</p><p>实体类方法：</p><p>实例化后立刻放入三级缓存，然后进行填充属性。然后初始化bean，成功之后放入一级缓存，标记为完成</p><p>流程：</p><p><strong>创建UserService</strong></p><ol><li>doGetBean(“userService”)</li><li>getSingleton(“userService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“userService”) → 标记正在创建</li><li>createBeanInstance() → 实例化UserService对象</li><li>addSingletonFactory(“userService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充orderService属性</li><li>getBean(“orderService”) → 触发OrderService创建</li></ol><p>创建orderService</p><ol start="8"><li>doGetBean(“orderService”)</li><li>getSingleton(“orderService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“orderService”) → 标记正在创建</li><li>createBeanInstance() → 实例化OrderService对象</li><li>addSingletonFactory(“orderService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充userService属性</li><li>getBean(“userService”) → 再次请求UserService</li></ol><p>循环依赖解析</p><ol start="15"><li>doGetBean(“userService”)</li><li>getSingleton(“userService”, true) → 执行三级缓存查找<ul><li>一级缓存：null</li><li>isSingletonCurrentlyInCreation(“userService”) → true</li><li>二级缓存：null</li><li>三级缓存：找到ObjectFactory</li><li>factory.getObject() → 返回早期UserService对象</li><li>放入二级缓存，移除三级缓存</li></ul></li><li>返回早期UserService对象给OrderService</li><li>OrderService属性填充完成</li><li>OrderService初始化完成，添加到一级缓存</li><li>返回OrderService给UserService</li><li>UserService属性填充完成</li><li>UserService初始化完成，添加到一级缓存</li></ol><p>这就是我们所说的提前暴露的问题</p><h2 id="bean管理">bean管理</h2><p>使用配置文件来管理我们的bean,添加一个资源解释器，也就是能读取classpath、本地文件和云文件的配置内容</p><p>里面会包括 Bean 对象的描述和属性信息。在读取配置文件信息后，接下来就是对配置文件中的 Bean 描述信息解析后进行注册操作，把 Bean 对象注册到 Spring 容器中。</p><p>从配置文件层-&gt;资源加载层-&gt;解析注册层-&gt;bean容器层</p><hr><p>资源加载：定义 Resource 接口，提供获取 InputStream 流的方法</p><p>然后策略实现类，多种的实现策略。</p><p><strong>ClassPath资源加载</strong>：</p><p>通过 <code>ClassLoader</code> 读取<code>ClassPath</code> 下的文件信息，具体的读取过程主要是：<code>classLoader.getResourceAsStream(path)</code></p><ul><li><strong>打包后的配置文件</strong>：JAR包内的spring.xml</li><li><strong>测试资源</strong>：src/test/resources下的配置文件</li><li><strong>类路径资源</strong>：与class文件同目录的配置文件</li></ul><p><strong>文件系统资源加载</strong>：</p><p>通过指定文件路径的方式读取文件信息</p><ul><li><strong>外部配置文件</strong>：/etc/app/config.xml</li><li><strong>用户自定义配置</strong>：~/app/custom.properties</li><li><strong>绝对路径资源</strong>：D:/config/spring.xml</li></ul><p><strong>URL资源加载</strong>：</p><p>通过 HTTP 的方式读取云服务的文件，我们也可以把配置文件放到 GitHub 或者 Gitee 上，使用URLConnection</p><ul><li><strong>远程配置中心</strong>：<a href="http://config-server/app.xml">http://config-server/app.xml</a></li><li><strong>云端配置文件</strong>：<a href="https://github.com/user/repo/config.xml">https://github.com/user/repo/config.xml</a></li><li><strong>动态配置</strong>：从配置中心实时拉取</li></ul><hr><p>智能资源定位器，<strong>DefaultResourceLoader</strong></p><p>按照资源加载的不同方式，资源加载器可以把这些方式集中到统一的类服务下进行处理，外部用户只需要传递资源地址即可</p><p>使用的顺序是先去从classpath进行获取，然后再去获取url资源。都没有的话采取获取默认的文件系统资源</p><p>Bean定义读取器，BeanDefinitionReader</p><p>通过这个抽象类的具体实现就可以把解析后的 XML 文件中的 Bean 信息，注册到 Spring 容器去了。<em>以前我们是通过单元测试使用，调用 BeanDefinitionRegistry 完成Bean的注册，现在可以放到 XMl 中操作了</em></p><p>解析xml处理bean注册，<strong>XmlBeanDefinitionReader</strong> 基础自抽象类</p><p>将xml文件映射为我们需要的代码，然后进行在spring容器中的注册</p><h2 id="bean组件的扩展">bean组件的扩展</h2><p>在实际工作中，当我们开发基于Spring的技术组件（如中间件、SpringBoot Starter等）时，经常需要：</p><ul><li>修改Bean的信息</li><li>添加日志打印、监控</li><li>处理数据库路由和数据源切换</li><li>给RPC服务连接注册中心</li><li>实现AOP切面功能</li></ul><p>这些都需要在Bean的生命周期中插入自定义逻辑，这就是Spring扩展机制的核心价值。</p><p><strong>BeanFactoryPostProcessor - Bean定义后置处理器</strong></p><p>在beandefinition加载完之后，bean实例化之前，可以去修改beandefinition的属性信息。相当于我们去建筑的蓝图。用于配置属性修改、Bean定义动态调整</p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 场景1：动态修改Bean的属性值</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">userServiceDef</span> <span class="operator">=</span> beanFactory.getBeanDefinition(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">PropertyValues</span> <span class="variable">pv</span> <span class="operator">=</span> userServiceDef.getPropertyValues();</span><br><span class="line">        pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;environment&quot;</span>, <span class="string">&quot;production&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景2：根据环境调整Bean配置</span></span><br><span class="line">        <span class="keyword">if</span> (isProductionEnvironment()) &#123;</span><br><span class="line">            pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;timeout&quot;</span>, <span class="string">&quot;30000&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景3：添加额外的Bean定义</span></span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;dynamicBean&quot;</span>, createDynamicBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanPostProcessor - Bean实例后置处理器</strong></p><p><em>Bean实例化和属性注入后，初始化方法调用前执行</em>,他有前置和后置的类型，我们一般在后置进行增加的更多，比如AOP代理，Bean增强，属性修改。依赖检查，权限校验和监控</p><p>ApplicationContext应用上下文架构</p><p>为了避免繁琐的操作，他是我们最常用的一个IOC容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简洁的上下文操作</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">UserService userService = context.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接口体系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 接口层次结构</span><br><span class="line">BeanFactory                           // 基础Bean工厂</span><br><span class="line">└── ListableBeanFactory              // 可列举Bean的工厂</span><br><span class="line">    └── ApplicationContext           // 应用上下文接口</span><br><span class="line">        └── ConfigurableApplicationContext  // 可配置的应用上下文</span><br><span class="line"></span><br><span class="line">// 实现层次结构  </span><br><span class="line">DefaultResourceLoader                 // 资源加载能力</span><br><span class="line">└── AbstractApplicationContext       // 上下文抽象实现</span><br><span class="line">    └── AbstractRefreshableApplicationContext     // 可刷新的上下文</span><br><span class="line">        └── AbstractXmlApplicationContext         // XML配置支持</span><br><span class="line">            └── ClassPathXmlApplicationContext    // 类路径XML上下文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在applicationcontext里面最重要的方法就是refresh方法</p><p>创建beanfactory然后加载beandefinnition</p><p>然后我们去获取beanfactory，执行<em>BeanFactoryPost</em>processor修改beandefinition</p><p>然后注册beanpostprocessor,为后续的处理进行准备</p><p>然后提前实例化单例的bean。</p><p>完整的生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. BeanDefinition注册</span><br><span class="line">        ↓</span><br><span class="line">2. BeanFactoryPostProcessor执行 ← 修改BeanDefinition</span><br><span class="line">        ↓</span><br><span class="line">3. Bean实例化（Constructor）</span><br><span class="line">        ↓</span><br><span class="line">4. 属性注入（Setter）</span><br><span class="line">        ↓</span><br><span class="line">5. BeanPostProcessor.postProcessBeforeInitialization ← Bean增强</span><br><span class="line">        ↓</span><br><span class="line">6. 初始化方法执行（@PostConstruct, InitializingBean, init-method）</span><br><span class="line">        ↓</span><br><span class="line">7. BeanPostProcessor.postProcessAfterInitialization ← AOP代理创建</span><br><span class="line">        ↓</span><br><span class="line">8. Bean就绪，放入容器</span><br><span class="line">        ↓</span><br><span class="line">9. 应用运行</span><br><span class="line">        ↓</span><br><span class="line">10. 容器关闭时执行销毁方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanFactoryPostProcessor应用场景</strong>：</p><ol><li><strong>配置中心集成</strong>：动态读取远程配置修改Bean属性</li><li><strong>环境相关配置</strong>：根据环境（dev/test/prod）调整Bean配置</li><li><strong>属性占位符解析</strong>：解析${property}占位符</li><li><strong>条件化Bean注册</strong>：根据条件动态注册Bean</li></ol><p><strong>BeanPostProcessor应用场景</strong>：</p><ol><li><strong>AOP实现</strong>：Spring AOP就是通过此接口创建代理对象</li><li><strong>中间件集成</strong>：如MyBatis的MapperScannerConfigurer</li><li><strong>监控和日志</strong>：自动添加监控、日志功能</li><li><strong>依赖注入增强</strong>：如@Autowired注解的实现</li><li><strong>数据源路由</strong>：动态数据源切换</li></ol><p><strong>Spring中哪些功能使用了这些扩展机制</strong></p><p><strong>BeanFactoryPostProcessor的应用</strong>：</p><ul><li><code>PropertyPlaceholderConfigurer</code>：属性占位符解析</li><li><code>PropertySourcesPlaceholderConfigurer</code>：Spring 3.1+的属性解析</li><li><code>ConfigurationClassPostProcessor</code>：@Configuration类处理</li></ul><p><strong>BeanPostProcessor的应用</strong>：</p><ul><li><code>AutowiredAnnotationBeanPostProcessor</code>：@Autowired注解处理</li><li><code>CommonAnnotationBeanPostProcessor</code>：@Resource等注解处理</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>：AOP代理创建</li></ul><h2 id="bean的初始化和销毁">bean的初始化和销毁</h2><p>完整的生命周期：</p><p>Bean定义注册<br>↓<br>BeanFactoryPostProcessor执行<br>↓<br>Bean实例化（Constructor）<br>↓<br>属性注入（Setter/Field）<br>↓<br>BeanPostProcessor.postProcessBeforeInitialization<br>↓<br>InitializingBean.afterPropertiesSet() ← 接口方式初始化<br>↓<br>init-method执行 ← XML配置方式初始化<br>↓<br>BeanPostProcessor.postProcessAfterInitialization<br>↓<br>Bean就绪状态<br>↓<br>容器关闭触发<br>↓<br>DisposableBean.destroy() ← 接口方式销毁<br>↓<br>destroy-method执行 ← XML配置方式销毁</p><p>在这个里面,init-method和destory-method他们也是要xml配置来进行的。所以也要通过 XmlBeanDefinitionReader 加载 spring.xml 配置信息到 BeanDefinition 中。</p><ul><li>InitializingBean、DisposableBean，两个接口方法还是比较常用的，在一些需要结合 Spring 实现的组件中，经常会使用这两个方法来做一些参数的初始化和销毁操作。比如接口暴漏、数据库数据读取、配置文件加载等等。</li><li>在方法 invokeInitMethods 中，主要分为两块来执行实现了 InitializingBean 接口的操作，处理 afterPropertiesSet 方法。另外一个是判断配置信息 init-method 是否存在，执行反射调用 initMethod.invoke(bean)。这两种方式都可以在 Bean 对象初始化过程中进行处理加载 Bean 对象中的初始化操作，让使用者可以额外新增加自己想要的动作。先执行接口方式，再执行配置方式，通过反射避免重复执行同名方法</li><li>方法destory跟上面的invokeinitMethods差不多，都是先实现接口，然后<em>配置信息 destroy-method {判断是为了避免二次执行销毁}</em></li></ul><p>虚拟机关闭钩子：</p><ul><li>首先我们需要在 ConfigurableApplicationContext 接口中定义注册虚拟机钩子的方法 <code>registerShutdownHook</code> 和手动执行关闭的方法 <code>close</code>。</li><li>在抽象实现类里面进行实现，注册JVM关闭构造的时候，是Runtime.getRuntime().addShutdownHook</li></ul><p>1.<strong>初始化方法和构造函数的区别？</strong></p><p>主要的区别在于执行的实际和功能定位，构造函数执行的时候，依赖注入还没完成，无法进行初始化</p><p>初始化方法执行的时候，所有属性已经完成。可以使用依赖对象进行初始化。比如建立数据库连接池，缓存预热，注册到注册中心</p><p>然后构造函数主要用于对象创建、基本属性设置，初始化方法主要使用依赖就绪后的业务初始化</p><p>2.<strong>为什么需要销毁方法？不能依赖GC吗</strong></p><p>GC只能回收内存，不能处理资源的释放</p><p>比如，socket,http连接，文件流，数据库连接等。比如线程池，定时器。还有注册中心，Mbean</p><p>3.<strong>Spring中哪些组件使用了初始化/销毁机制？</strong></p><p><strong>几乎所有核心组件都有应用</strong>，比如数据源组件，初始化连接池，销毁连接池</p><p>缓存组件，初始化缓存预热，关闭redis连接</p><p><strong>消息队列</strong>，启动监听消息队列，停止监听关闭消息队列</p><p>4.<strong>如何保证初始化方法的执行顺序？</strong></p><p>使用*@DependsOn*注解，就是一个前置条件，<em>确保configService和cacheService先初始化</em></p><p><strong>@Order注解配合ApplicationListener</strong>，数字越小，约先执行。</p><p><em>实现Ordered接口</em>，然后确定高优先级的初始化</p><p>5.<strong>如何处理初始化方法的异常？</strong></p><ol><li><strong>快速失败</strong>：关键资源初始化失败时立即抛异常</li><li><strong>优雅降级</strong>：非关键失败时使用备用方案</li><li><strong>延迟重试</strong>：网络等临时性失败可以重试</li></ol><h2 id="Aware">Aware</h2><p>Aware是Spring提供的一种<strong>容器感知机制</strong>，让Bean能够获取Spring容器中的各种资源和服务。它是一个<strong>标记接口</strong>，通过实现不同的Aware子接口，Bean可以感知到：</p><ul><li>BeanFactory</li><li>ApplicationContext</li><li>ClassLoader</li><li>Bean名称</li><li>以及其他容器资源</li></ul><p>继承 Aware 的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware</p><p>在具体的接口实现过程中你可以看到，一部分(<em>BeanFactoryAware、BeanClassLoaderAware、BeanNameAware</em>)在 factory 的 support 文件夹下，另外 ApplicationContextAware 是在 context 的 support 中，这是因为不同的内容获取需要在不同的包下提供。所以，在 AbstractApplicationContext 的具体实现中会用到向 beanFactory 添加 BeanPostProcessor 内容的 <code>ApplicationContextAwareProcessor</code> 操作，最后由 AbstractAutowireCapableBeanFactory 创建 createBean 时处理相应的调用操作。</p><p>Aware接口</p><ul><li><p>在 Spring 中有特别多类似这样的标记接口的设计方式，它们的存在就像是一种标签一样，可以方便统一摘取出属于此类接口的实现类，通常会有 instanceof 一起判断使用。</p></li><li><p><strong>标记模式</strong>：类似于<code>Serializable</code>接口，用于标识具有某种特性的类</p></li><li><p><strong>instanceof判断</strong>：通过<code>bean instanceof Aware</code>统一识别和处理</p></li><li><p><strong>统一管理</strong>：将所有感知接口归类到一个体系下</p></li></ul><p>四大核心感知接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 感知BeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 感知ClassLoader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanClassLoaderAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 感知Bean名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 感知ApplicationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用感知：</p><ul><li><p>首先在 initializeBean 中，通过判断 <code>bean instanceof Aware</code>，调用了三个接口方法，<code>BeanFactoryAware.setBeanFactory(this)</code>、<code>BeanClassLoaderAware.setBeanClassLoader(getBeanClassLoader())</code>、<code>BeanNameAware.setBeanName(beanName)</code>，这样就能通知到已经实现了此接口的类。</p></li><li><p>另外我们还向 BeanPostProcessor 中添加了 <code>ApplicationContextAwareProcessor</code>，此时在这个方法中也会被调用到具体的类实现，得到一个 ApplicationContex 属性。</p></li><li><p>确保Bean获得感知能力后再进行业务初始化</p></li></ul><p><strong>ApplicationContext</strong>比较特殊他要单独去执行在refresh方法中进行，ApplicationContext在<code>AbstractAutowireCapableBeanFactory</code>中不可直接获取，需要在容器启动时注册专门的处理器，体现了<strong>分层架构</strong>的设计思想。ApplicationContextAwareProcessor在ApplicationContext，其他的他们在<em>BeanFactory层</em> 。</p><p>实现：</p><ol><li>在ApplicationContext层创建<code>ApplicationContextAwareProcessor</code></li><li>将processor注册到BeanFactory中</li><li>利用BeanPostProcessor机制在Bean初始化时注入ApplicationContext</li></ol><p>题目：</p><p>1.<strong>Aware接口的作用是什么？</strong></p><p><strong>Aware接口提供了Bean获取Spring容器资源的标准机制：</strong></p><ol><li><strong>容器感知</strong>：让Bean能够感知到Spring容器的存在</li><li><strong>资源获取</strong>：提供获取容器内部资源的标准方式</li><li><strong>扩展能力</strong>：为开发中间件和框架提供扩展点</li><li><strong>解耦设计</strong>：通过接口回调而非静态方法获取资源</li></ol><p>比如setApplicationContext方法，可以获取容器中的其他的bean，发布应用事件，可以获取环境配置</p><p>setBeanFactory方法，可以动态获取bean，检查bean是不是存在</p><p>2.<strong>不同Aware接口的执行顺序是什么？</strong></p><p>\1. BeanNameAware.setBeanName()</p><p>\2. BeanClassLoaderAware.setBeanClassLoader()</p><p>\3. BeanFactoryAware.setBeanFactory()</p><p>\4. EnvironmentAware.setEnvironment() (如果实现)</p><p>\5. EmbeddedValueResolverAware.setEmbeddedValueResolver() (如果实现)</p><p>\6. ResourceLoaderAware.setResourceLoader() (如果在ApplicationContext中)</p><p>\7. ApplicationEventPublisherAware.setApplicationEventPublisher() (如果在ApplicationContext中)</p><p>\8. MessageSourceAware.setMessageSource() (如果在ApplicationContext中)</p><p>\9. ApplicationContextAware.setApplicationContext() (如果在ApplicationContext中)</p><ul><li><strong>Bean自身信息</strong>先设置（Name、ClassLoader、Factory）</li><li><strong>容器环境信息</strong>后设置（Context、Environment等）</li><li><strong>应用层面信息</strong>最后设置（Event、Message等）</li><li>最后是我们的context</li></ul><p>3.<strong>Aware机制与@Autowired的区别？</strong></p><table><thead><tr><th>对比维度</th><th>Aware接口</th><th>@Autowired</th></tr></thead><tbody><tr><td><strong>注入对象</strong></td><td>Spring容器内部资源</td><td>业务Bean对象</td></tr><tr><td><strong>执行时机</strong></td><td>Bean初始化阶段</td><td>属性注入阶段</td></tr><tr><td><strong>耦合度</strong></td><td>与Spring框架耦合</td><td>相对解耦</td></tr><tr><td><strong>使用场景</strong></td><td>框架扩展、中间件开发</td><td>业务依赖注入</td></tr><tr><td><strong>灵活性</strong></td><td>可以获取容器的动态能力</td><td>静态依赖关系</td></tr></tbody></table><h2 id="FactoryBean-Bean的作用域">FactoryBean&amp;Bean的作用域</h2><p>FactoryBean是Spring提供的一种<strong>创建复杂Bean对象的工厂接口</strong>，它允许我们自定义Bean的创建逻辑，特别适用于：</p><ul><li><strong>代理对象创建</strong>（如MyBatis的Mapper代理）</li><li><strong>复杂对象初始化</strong>（需要多步骤构建的对象）</li><li><strong>第三方框架集成</strong>（将外部框架的对象纳入Spring管理）</li></ul><p><strong>Bean作用域（Scope）机制</strong></p><p>Spring支持多种Bean作用域：</p><ul><li><strong>singleton</strong>：单例模式（默认），容器中只有一个实例</li><li><strong>prototype</strong>：原型模式，每次获取都创建新实例</li><li><strong>request/session/application</strong>：Web环境中的作用域</li></ul><p>单例模式和原型模式的区别就在于是否存放到内存中，如果是原型模式那么就不会存放到内存中，每次获取都重新创建对象</p><p>这就是我们常说的五大作用域</p><p>FactoryBean设计：获取对象、对象类型，以及是否是单例对象</p><p>比如我们的<strong>MyBatis Mapper代理创建</strong>就是我们自定义的一个FactoryBean， 使用 <code>MapperFactoryBean</code> 将<strong>接口注册为代理对象</strong>，启动时会把接口方法解析成 <code>MappedStatement</code> 存入 Configuration 中，运行时由 <code>MapperProxy</code> 通过反射动态执行 SQL。</p><p>还有数据源代理等等。</p><p>作用域就是我们定义在BeanDefinition中的一个常量，然后我们通过指定scpore字段来定义</p><p>然后xml解析回去xml里获取作用域，然后设置beandefinition的信息</p><p>1.<strong>FactoryBean和BeanFactory的区别？</strong></p><table><thead><tr><th>对比维度</th><th>BeanFactory</th><th>FactoryBean</th></tr></thead><tbody><tr><td><strong>性质</strong></td><td>Spring容器的根接口</td><td>用户可实现的工厂接口</td></tr><tr><td><strong>作用</strong></td><td>管理Bean的生命周期</td><td>创建复杂的Bean对象</td></tr><tr><td><strong>使用者</strong></td><td>Spring框架内部使用</td><td>开发者实现和使用</td></tr><tr><td><strong>获取方式</strong></td><td>通过ApplicationContext</td><td>通过getBean()获取其产品</td></tr></tbody></table><p>2.<strong>如何获取FactoryBean本身而不是它创建的对象</strong></p><p>使用&amp;的前缀符表示我们需要的是FactoryBean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyFactoryBean factoryBean = (MyFactoryBean) applicationContext.getBean(&quot;&amp;myFactoryBean&quot;);</span><br></pre></td></tr></table></figure><p>然后内部处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;&amp;&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 去掉&amp;前缀，获取FactoryBean本身</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryBeanName</span> <span class="operator">=</span> name.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getFactoryBean(factoryBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常获取FactoryBean创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> getObjectForBeanInstance(getSingleton(name), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.<strong>FactoryBean在什么场景下使用？</strong></p><p>代理对象的创建，<strong>复杂对象初始化</strong>， <strong>第三方框架集成</strong>（比如redis中设置redis的运行的参数和序列化方式）</p><p>4.<strong>FactoryBean的生命周期是怎样的？</strong></p><p><strong>FactoryBean有双重生命周期</strong>，一个是他本身的生命周期，一个是他产品对象的生命周期</p><h2 id="事件">事件</h2><p>Event机制</p><p>在复杂的业务系统中，直接调用会导致<strong>紧耦合</strong>问题：</p><ul><li><strong>用户注册</strong> → 直接调用发送邮件、赠送积分、风控检查等服务</li><li><strong>订单支付</strong> → 直接调用库存扣减、物流发货、积分计算等服务</li><li><strong>文章发布</strong> → 直接调用消息推送、索引更新、缓存刷新等服务</li></ul><p>这种方式会导致：</p><ol><li><strong>代码耦合度高</strong>：核心业务逻辑与辅助功能混杂</li><li><strong>扩展性差</strong>：新增功能需要修改核心代码</li><li><strong>维护困难</strong>：一个环节出错影响整个流程</li><li><strong>性能问题</strong>：同步执行所有操作，响应慢</li></ol><p>我们可以通过观察者模式进行解耦</p><p>用户注册成功 → 发布UserRegisteredEvent → 多个监听器异步处理</p><p>├── EmailListener: 发送欢迎邮件</p><p>├── CouponListener: 赠送新人礼包</p><p>├── RiskListener: 风控分析</p><p>└── StatisticsListener: 数据统计</p><p>spring event</p><p>定义出事件类、事件监听、事件发布 事件广播器</p><p>applicationevent-&gt;applicationlistener-&gt;applicationeventpublisher-&gt;applicaitoneventmulticaster</p><p>我们事件类是构建一个基本的抽象类，然后其他的具体事件继承这个抽象类</p><p>事件广播器定义了添加监听和删除监听的方法，和添加广播的方法。<code>multicastEvent</code> 最终推送时间消息也会经过这个接口方法来处理谁该接收事件。</p><p>那我们怎么处理事件广播的并发处理呢？</p><ul><li><strong>监听器隔离</strong>：一个监听器异常不影响其他监听器</li><li><strong>异步执行</strong>：可配置同步或异步处理</li><li><strong>顺序控制</strong>：支持监听器执行顺序</li></ul><p>然后我们怎么去确定某个事件如何被监听器处理？我们使用泛型参数匹配来实现</p><p>我们先去获取监听的class，然后如果存在GCLIB代理的话，我们处理CGLIB代理。spring中Bean可能被代理，需要获取真实类型，就是他的父类。</p><p>然后获取泛型接口，提取泛型参数，获取事件的类型。</p><p>然后判断事件是否匹配，就是判断ParameterizedType 和eventClassName是不是子类和父类的关系</p><p>事件发布器，初始化事件发布者(initApplicationEventMulticaster)，</p><ul><li><p>主要用于实例化一个 SimpleApplicationEventMulticaster，这是一个事件广播器。</p></li><li><p>注册事件监听器(registerListeners)，通过 getBeansOfType 方法获取到所有从 spring.xml 中加载到的事件配置 Bean 对象。</p></li><li><p>发布容器刷新完成事件(finishRefresh)，发布了第一个服务器启动完成后的事件，这个事件通过 publishEvent 发布出去，其实也就是调用了 applicationEventMulticaster.multicastEvent(event); 方法。</p></li></ul><p>问题</p><p>1.spring event事件执行的流程：</p><ol><li><strong>事件定义</strong>：继承<code>ApplicationEvent</code>创建事件类</li><li><strong>监听器注册</strong>：实现<code>ApplicationListener</code>并注册到容器</li><li><strong>事件发布</strong>：通过<code>ApplicationEventPublisher.publishEvent()</code>发布</li><li><strong>事件广播</strong>：<code>ApplicationEventMulticaster</code>接收事件</li><li><strong>监听器匹配</strong>：根据泛型参数匹配感兴趣的监听器</li><li><strong>事件处理</strong>：调用匹配监听器的<code>onApplicationEvent()</code>方法</li></ol><p>2.<strong>如何保证Event处理的事务一致性？</strong></p><p>使用事件同步机制，事务提交后执行事务监听器，发送邮件通知等，然后事务回滚的时候发送清理操作</p><p>通过@TransactionalEventListener的状态来确定</p><p>然后失败之后通过补偿机制。</p><h2 id="动态代理">动态代理</h2><p>动态代理是我们spring的AOP的</p><p>AOP主要就是解耦，他将跟核心业务没关系的业务比如权限，日志等业务的抽离出来，一般都是以注释的形式。然后方法只执行业务核心方法</p><p>动态代理分为JDK动态代理和CGLIB动态代理</p><p>JDK动态代理基于接口，代理实现了接口的类，在运行时动态生成代理类的字节码。速度较快，不需要生成新的字节码</p><p>JdkDynamicAopProxy实现了AopProxy, InvocationHandler</p><p>获取代理方式，获取当前线程的context类加载器，然后通知通知添加目标接口。然后执行<em>InvocationHandler实现</em></p><p>然后使用Invoke方法，执行代理。检查方法是不是匹配切点表达式，匹配成功后执行方法拦截器，拦截，然后换取我们自己实现的bean。如果不匹配的话，我们就执行原来的方法</p><p>CGLIB动态是基于继承目标类生成子类代理，使用了使用ASM字节码技术。除了final都可以代理，速度较慢，需要生成字节码。但是性能较好</p><p>get方法是通过设置我们的需要代理的类，然后设置接口，设置回调处理器</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring/">spring</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试总结</title>
      <link>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;面试题目类型&lt;/h1&gt;
&lt;h2 id=&quot;双指针&quot;&gt;双指针&lt;/h2&gt;
&lt;h2 id=&quot;二叉树&quot;&gt;二叉树&lt;/h2&gt;
&lt;h2 id=&quot;链表&quot;&gt;链表&lt;/h2&gt;
&lt;h2 id=&quot;滑动窗口&quot;&gt;滑动窗口&lt;/h2&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>面试题目类型</h1><h2 id="双指针">双指针</h2><h2 id="二叉树">二叉树</h2><h2 id="链表">链表</h2><h2 id="滑动窗口">滑动窗口</h2><h2 id="堆-栈">堆&amp;栈</h2><h1>回溯</h1><p>所有回溯问题，都可以抽象成在一个“决策树”上进行深度优先搜索（DFS）的过程。这个过程包含三个关键部分：</p><ol><li><strong>路径（Path）</strong>：已经做出的选择。在全排列问题中，就是当前已经选了哪几个数字，构成了一个不完整的排列。我们通常用一个 <code>List</code> 或 <code>Stack</code> 来记录。</li><li><strong>选择列表（Choices）</strong>：当前可以做的选择。在全排列问题中，就是那些<strong>还没有被选过</strong>的数字。</li><li><strong>结束条件（End Condition）</strong>：当“选择列表”为空，或者说“路径”的长度达到了要求（比如等于原数组长度），就意味着我们走到了决策树的叶子节点，找到了一个完整的解。此时需要把“路径”存入最终结果集。</li></ol><p>比如说一个全排列的问题，抽象出来就是</p><p>我们需要先从选择列表中将其加入到路径之中，然后标记为已选</p><p>继续递归</p><p>下一层递归返回后，为了能去尝试其他的，就将这次的撤销，就是我们说的回溯，然后移除，标记为没有启用</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 面试题目</title>
      <link>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;model类型面试题目&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>model类型面试题目</h1><h2 id="1-如何实现大模型的连续对话？">1.如何实现大模型的连续对话？</h2><p>所有的大模型本身是不进行信息存储的，也不提供连续对话功能，<strong>所以想要实现连续对话功能需要开发者自己写代码才能实现</strong></p><p>所以呢我们需要将当前用户的提问与<strong>经过管理的对话历史</strong>一同作为输入，提交给模型。</p><p>我们需要维护一个session，</p><p>通常是<code>List&lt;Message&gt;</code>结构。<code>Message</code>对象至少包含两个关键字段：</p><ul><li><code>role</code>: 角色（<code>system</code>、<code>user</code>、<code>assistant</code>）</li><li><code>content</code>: 消息内容</li></ul><p>然后进入交互循环</p><ul><li><strong>用户输入</strong>：接收用户的新消息（<code>user</code> role）。</li><li><strong>上下文构建</strong>：从存储中获取该会话的历史消息列表，并将新消息追加到列表末尾。</li><li><strong>API调用</strong>：将完整的消息列表提交给大模型。</li><li><strong>获取响应</strong>：接收模型的回复（<code>assistant</code> role）。</li><li><strong>上下文持久化</strong>：将模型的回复也追加到历史消息列表中，并更新存储（如Redis、数据库等），为下一次交互做准备。</li></ul><p>在这里面最重要的就是上下文是有窗口限制的，超出模型的Token限制（如4K, 8K, 32K, 128K）。这不仅会导致API调用失败，还会增加成本和响应延迟。</p><p>1.截断策略：</p><ul><li><strong>简单滑动窗口</strong>：只保留最近的 N 轮对话。实现最简单，但会丢失早期的重要信息。</li><li><strong>保留首轮+滑动窗口</strong>：保留系统提示（<code>system</code> prompt）和第一轮对话，然后截取最近的 N-2 轮对话。适用于需要固定初始设定的场景。</li></ul><p>2.摘要策略：</p><ul><li><strong>滚动摘要</strong>：当对话长度达到一定阈值时，使用另一个LLM调用将较早的对话内容进行总结，用这个摘要替换掉原始的多轮对话。</li><li><strong>优点</strong>：保留了长期记忆的精华。</li><li><strong>缺点</strong>：摘要过程会丢失细节，并产生额外的API开销和延迟。</li></ul><p>3.RAG策略：</p><ol><li><strong>存储</strong>：将每一轮完整的对话历史（或其要点）向量化后存入向量数据库 (VectorDB)。</li><li><strong>检索</strong>：当用户提出新问题时，先将问题向量化，然后去向量数据库中检索最相关的 N 条历史对话记录。</li><li><strong>注入</strong>：将这些检索出的、最相关的历史记录，连同当前问题，一起注入到提示词中，提交给大模型。</li></ol><ul><li><ul><li><strong>突破长度限制</strong>：理论上可以维护无限的对话历史。</li><li><strong>高相关性</strong>：只提供与当前问题最相关的上下文，效率高。</li></ul></li><li><strong>挑战</strong>：需要引入向量数据库（如Milvus, Pinecone）和embedding模型，系统复杂度更高。</li></ul><p>这是我们自己需要配置的，但是Spring AI Alibaba 因为内置了连续对话的多种实现,比如mysql,redis</p><p>只需要简单配置就ok，我们注入注入 RedisChatMemoryRepository 对象。</p><p>然后配置 ChatClient 实现连续对话。</p><p>直接调用先prompt，然后advisors,最好call.context发送给模型</p><h2 id="2-AI项目的执行流程">2.AI项目的执行流程</h2><p>我习惯上分为<strong>离线数据处理（Data Preparation）</strong> 和 <strong>在线请求处理（Real-time Inference）</strong></p><p>1.离线数据处理：</p><p>这个阶段的目标是将原始、异构的数据处理成AI模型可以高效检索的结构化知识库。它是一次性的或周期性执行的。</p><ol><li><strong>多源数据抽取 (Extraction)</strong>：<ul><li>首先，需要从多个来源抽取数据，这些数据就是我们常说的“知识”。来源可能包括：<ul><li><strong>结构化数据</strong>：如MySQL, PostgreSQL里的业务数据。</li><li><strong>半结构化数据</strong>：如网页HTML, Markdown文档。</li><li><strong>非结构化数据</strong>：如PDF, Word文档, 纯文本。</li><li><strong>API数据</strong>：通过调用内部或外部API获取的动态信息。</li></ul></li></ul></li><li><strong>数据清洗与分块 (Cleaning &amp; Chunking)</strong>：<ul><li>原始数据是“脏”的，必须清洗。这包括去除无关信息（如HTML标签、广告、页眉页脚）、处理格式错误、统一编码等。</li><li>清洗后，将长文本（如一篇长文档）切分成有意义的、大小适中的“文本块 (Chunks)”。这一步至关重要，因为文本块是后续向量检索的基本单位。分块的好坏直接影响检索质量。</li></ul></li><li><strong>向量化与索引 (Embedding &amp; Indexing)</strong>：<ul><li>这是将文本语言转换为数学语言的核心步骤。</li><li>我们使用一个特定的<strong>Embedding模型</strong>，将每一个“文本块”计算成一个高维向量（Embedding）。这个向量可以被认为是该文本块在语义空间中的“坐标”。</li><li>然后，将这些文本块原文连同它们的向量索引，存入一个或多个<strong>向量数据库</strong>（如Milvus, Pinecone）中。同时，也可能将关键词、元数据等存入传统检索引擎（如Elasticsearch）。</li></ul></li></ol><p>2.在线请求处理：</p><p>这个阶段是用户与系统实时交互的过程，追求低延迟和高精度。</p><ol><li><strong>意图分析 (Intention Analysis)</strong>：<ul><li>请求的入口。当用户输入一句话，系统首先要理解“他想干什么”。</li><li>这不仅仅是关键词识别，更深层次会判断用户意图，例如：是闲聊（Chitchat）？是问答（FAQ）？还是需要执行一个任务（Task-oriented）？</li><li>意图分析的结果会决定后续调用哪些检索路径。比如，闲聊意图可能直接交给大语言模型，而问答意图则会触发后续的召回和排序流程。</li></ul></li><li><strong>多路召回 (Multi-path Recall)</strong>：<ul><li>这是为了“宁可错杀，不可放过”，尽可能多地从不同渠道找回所有相关的候选答案。各路召回并行执行，以保证效率。</li><li><strong>向量召回（语义召回）</strong>：将用户的查询也进行向量化，然后去向量数据库里进行相似度检索，找出语义上最接近的N个文本块。这是您提到的“向量检索”的应用环节。</li><li><strong>关键词召回（词法召回）</strong>：使用传统搜索引擎（如Elasticsearch）根据关键词匹配，找出包含查询词的文本块。这能弥补向量召回在精确匹配上的不足。</li><li><strong>其他召回</strong>：还可能包括基于知识图谱的召回、基于数据库精确查询的召回等。</li></ul></li><li><strong>混合排序 (Hybrid Ranking/Re-ranking)</strong>：<ul><li>多路召回会返回大量候选结果，质量良莠不齐，甚至有重复。排序阶段就是优中选优的过程。</li><li><strong>粗排 (Coarse Ranking)</strong>：首先，通过一些简单的规则和模型，对召回的上百个结果进行快速排序和去重，筛选出Top K（比如Top 50）个候选结果。</li><li><strong>精排 (Fine-grained Ranking / Re-ranking)</strong>：然后，使用一个更复杂、更强大的排序模型（通常是Cross-Encoder或专门的排序大模型），对这Top K个结果进行精准打分。这个模型会综合考虑查询与候选答案的语义相关性、业务重要性、时效性等多种特征，给出最终的、最合理的排序。</li></ul></li><li><strong>答案生成与整合 (Answer Generation &amp; Synthesis)</strong>：<ul><li>最后，系统会将排序最高的一个或几个结果，作为核心上下文，连同用户的原始问题，一起组织成一个精炼的提示词（Prompt）。</li><li>将这个Prompt提交给一个强大的生成式大语言模型（如GPT-4），由它基于给定的上下文，生成最终的、通顺自然的回答，并呈现给用户。</li></ul></li></ol><h2 id="3-Dify是什么？怎么使用？">3.Dify是什么？怎么使用？</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>1.为什么选择Dify?</p><ul><li><strong>从效率和速度角度看：</strong> 对于需要快速验证原型（MVP）或业务逻辑不那么极端的项目，我会首选Dify。因为它将RAG、多模型支持、API封装等通用能力产品化了，可以让我们在几天甚至几小时内就搭建起一个可用的AI应用，极大地缩短了Time-to-Market（产品上市时间）。</li><li><strong>从维护成本角度看：</strong> Dify提供了一个完整的后台管理界面，包括日志、监控和用户反馈。这意味着运营人员或产品经理也可以参与到应用的优化中来，例如更新知识库、标注数据等。如果自研，这部分工作都需要开发人员投入精力去构建和维护，长期成本更高。</li><li><strong>对于自定义和灵活性：</strong> 当然，如果项目需求非常特殊，比如需要一个高度定制化的RAG策略（例如复杂的混合检索和重排逻辑），或者对系统性能有极致要求，那么基于LangChain或LlamaIndex自研会提供更高的灵活性和控制力。</li></ul><p>2.Dify的Agent和Tool（工具）能力是如何工作的？它与传统的API调用有什么不同？</p><p>Dify的Agent和Tool能力，是实现<strong>Language Model as a Reasoning Engine（将语言模型作为推理引擎）<strong>的关键。它和传统API调用的核心区别在于</strong>‘决策者’不同</strong>。</p><ul><li><strong>传统API调用</strong>：是我们开发者在代码里<strong>提前写好逻辑</strong>。比如，<code>if</code>用户想查天气，<code>then</code>调用天气API。这个决策逻辑是<strong>由人预先编码</strong>的。</li><li><strong>Dify中的Agent/Tool工作流</strong>:</li></ul><ol><li><strong>工具注册</strong>：我们首先向Dify注册一个或多个工具，比如“天气查询API”、“计算器API”。关键在于，我们需要用自然语言<strong>向模型清晰地描述这个工具是做什么的、需要哪些参数</strong>（比如，天气查询API需要一个<code>city</code>参数）。</li><li><strong>模型决策 (Reasoning)</strong>：当用户提出一个模糊的需求，比如“帮我查查明天北京会不会下雨，适合穿什么？”，Agent接收到请求后，大模型会进行“思考”。</li><li><strong>工具选择与调用</strong>：模型会分析用户的意图，并根据我们提供的工具描述，<strong>自主决定</strong>需要使用“天气查询API”。然后，它会从用户问题中<strong>提取出参数</strong><code>city: &quot;北京&quot;</code>，并生成一个调用该API的请求。</li><li><strong>结果整合与响应</strong>：模型获取到API返回的天气数据后（比如“晴天”），会将其作为新的信息，结合它自己的知识（晴天适合穿什么），最终生成一段通顺的、完整的回答给用户。</li></ol><p>Dify的Agent模式，把**‘决定调用哪个API’以及‘如何组织参数’的权力，从开发者交给了大模型**，实现了更高层次的自动化和智能化。”</p><p>3.如果让你来设计一个类似Dify的平台，你会如何规划它的技术架构？</p><p>设计一个类似Dify的平台，我会将其拆分为几个核心模块，并采用微服务的思想来构建，确保可扩展性和可维护性</p><ol><li><strong>前端 (Frontend)</strong>：<ul><li>使用React或Vue等现代前端框架，负责提供所有可视化的操作界面，包括应用管理、Prompt Studio、知识库上传和运营后台等。</li></ul></li><li><strong>API网关 (API Gateway)</strong>：<ul><li>作为所有服务的统一入口，处理用户认证、请求路由、速率限制等。这是外部应用（比如用户的前端）与我们平台交互的门户。</li></ul></li><li><strong>应用编排服务 (Orchestration Service)</strong>：<ul><li>这是平台的大脑。它负责解释在Studio中保存的应用配置。当一个API请求进来时，这个服务会根据应用定义，决定是走简单的LLM对话流程，还是需要执行RAG或Agent流程。它会编排并调用下游的各个服务。</li></ul></li><li><strong>模型管理服务 (Model Management Service)</strong>：<ul><li>用于统一管理和对接不同的大模型提供商（OpenAI, Anthropic, Google Gemini, 以及开源模型）。它会封装好各家API的差异，对上层提供一个统一的调用接口。</li></ul></li><li><strong>RAG服务 (RAG Service)</strong>：<ul><li>这是一个独立的模块，负责知识库的全生命周期管理。</li><li><strong>写入路径</strong>：接收文档 -&gt; 文本解析 -&gt; 分块 (Chunking) -&gt; 调用Embedding模型 -&gt; 存入向量数据库。</li><li><strong>读取路径</strong>：接收查询 -&gt; 向量化 -&gt; 在向量数据库中进行相似性搜索 -&gt; 返回相关文本块。</li><li><strong>技术选型</strong>：会用到向量数据库（如Milvus/Weaviate）和Embedding模型。</li></ul></li><li><strong>日志与监控服务 (Logging &amp; Monitoring Service)</strong>：<ul><li>专门收集所有API调用的日志、Token消耗、用户反馈等数据。</li><li>将数据存入专门的数据库（如ClickHouse或Elasticsearch），并提供数据可视化界面，用于运营分析和应用优化。</li></ul></li></ol><h2 id="4-那么怎么区分使用简单模型还是使用agent呢？">4.那么怎么区分使用简单模型还是使用agent呢？</h2><p>可以使用前置规则与关键词匹配 ，比如系统会维护一个“触发词”列表。当用户的输入包含这些特定的动词或名词时，系统会<strong>绕过复杂的判断</strong>，直接将其路由到Agent流程。</p><p>或者是利用大语言模型进行意图分类 ，我们设计一个专门用于“路由”的<strong>元提示 (Meta-Prompt)</strong>。这个Prompt会包含以下内容：</p><ol><li><strong>用户的原始问题</strong>。</li><li><strong>一个“选项列表”</strong>，这个列表描述了所有可用的“路径”。每个路径就是一个Agent或工具，外加一个“默认闲聊”的选项。</li><li><strong>一个明确的指令</strong>，要求LLM根据用户问题，从列表中选择一个最合适的路径。</li></ol><p>非常智能和灵活，能理解深层语义。这是目前最主流和最有效的方法。现代LLM的“Function Calling”或“Tool Use”功能，本质上就是这种机制的高度优化和内置实现。</p><p>或者是结合上下文进行动态判断，系统在做意图判断时，不仅考虑当前这一句，还会<strong>附加上下文（最近的几轮对话历史）</strong>。</p><p>我在这个项目中主要用的是，<strong>分层漏斗模型</strong></p><ol><li><strong>首先，通过一个‘快速通道’进行前置判断</strong>。我们会用关键词和规则匹配，快速识别出那些意图非常明确的请求，比如包含‘查询’、‘计算’、‘预订’等词语的指令，直接将它们路由给相应的Agent。这能覆盖掉一部分简单明确的任务，且成本最低。</li><li><strong>其次，对于无法被快速通道处理的请求，我们会启用一个‘智能路由’层</strong>。这一层的核心是利用大语言模型自身的理解能力。我们会设计一个专门的‘路由Prompt’，把用户的请求和所有可用的‘工具’（Agents）以及一个‘闲聊’选项一起发给LLM，让模型来判断用户最可能的意图是什么。比如，模型需要从‘查询天气’、‘检查订单’和‘普通聊天’这几个选项里做出选择。这是目前最主流也最可靠的方式。</li><li><strong>最后，在多轮对话中，我们会引入上下文进行动态判断</strong>。用户的意图可能不会在第一句话就完全暴露。因此，在做意图识别时，系统会结合最近的对话历史。比如用户先说了‘我想去北京’，接着问‘那边天气如何？’，系统就能结合上下文，准确地将这个模糊的问题路由到‘天气查询Agent’。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 基础知识</title>
      <link>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;普通概念&lt;/h1&gt;
&lt;h2 id=&quot;Model&quot;&gt;Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ChatModel&lt;/strong&gt;: 基于&lt;strong&gt;自回归语言模型&lt;/strong&gt;，其核心是 &lt;strong&gt;Transformer</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>普通概念</h1><h2 id="Model">Model</h2><ul><li><strong>ChatModel</strong>: 基于<strong>自回归语言模型</strong>，其核心是 <strong>Transformer Decoder</strong> 架构。它通过“逐字生成”的方式工作：接收一段文本（Prompt），预测下一个最可能的词（Token），然后将新生成的词加入输入，再次预测下一个，如此循环，直到生成完整的回答。这种机制保证了生成文本的上下文连贯性和逻辑性。</li><li><strong>EmbeddingModel</strong>: <code>EmbeddingModel</code>（如text-embedding-ada-002、text2vec-chinese）基于<strong>双向编码器</strong>，其核心是 <strong>Transformer Encoder</strong> 架构。与ChatModel不同，它会同时分析整个输入文本的上下文，然后将文本的深层语义信息<strong>映射</strong>到一个高维、密集的数字向量（Vector）中。在这个向量空间里，语义上相似的文本在空间距离上会更接近。</li></ul><p>EmbeddingModel负责检索阶段：就是我们常说的嵌入模型</p><p>- 将查询和文档转换为向量表示</p><p>- 通过余弦相似度计算相关性</p><p>- 检索最相关的K个文档片段</p><p>ChatModel负责生成阶段：就是我们常用的聊天的那种模型</p><p>- 接收检索到的上下文+用户查询</p><p>- 基于上下文生成回答</p><p>- 保证回答的连贯性和准确性</p><p>那么我们如何选择模型呢？</p><ol><li><p>维度大小：向量的维度。维度越高，通常能编码更丰富的语义信息，但也会增加存储和计算开销。</p><ul><li><strong>示例</strong>：<code>BERT-base</code> 通常是768维，而OpenAI的 <code>text-embedding-ada-002</code> 是1536维。</li></ul></li><li><p>语言支持：模型是否针对特定语言（如中文）进行过优化。对于中文场景，使用专门的中文Embedding模型（如 <code>text2vec-chinese</code>）效果远超通用模型。</p></li><li><p>领域适配：通用模型在开放域表现良好，但在专业领域（如法律、医疗），使用经过该领域数据微调过的模型能显著提升准确性。</p></li><li><p>性能指标：</p><p>检索准确率 (Recall/Precision)：衡量Embedding模型检索到的相关文档的准确度。</p><p>推理延迟 (Latency)：模型处理一次请求所需的时间，直接影响用户体验。</p></li></ol><p>比如我自定义知识库使用的就是Embedding v2 ada</p><p>重排模型:</p><h2 id="VectorStore">VectorStore</h2><p><code>VectorStore</code> 负责存储<code>EmbeddingModel</code>生成的向量，并提供高效的相似度检索能力。</p><table><thead><tr><th>特性</th><th>Redis Vector</th><th>Pinecone</th><th>Weaviate</th></tr></thead><tbody><tr><td><strong>架构</strong></td><td>内存+持久化</td><td>云原生分布式</td><td>图数据库+向量</td></tr><tr><td><strong>索引算法</strong></td><td>HNSW/IVF</td><td>专有优化算法</td><td>HNSW</td></tr><tr><td><strong>存储成本</strong></td><td>中等(内存占用高)</td><td>高(按量计费)</td><td>低(开源版免费)</td></tr><tr><td><strong>检索延迟</strong></td><td>&lt;10ms</td><td>10-50ms</td><td>20-100ms</td></tr><tr><td><strong>扩展性</strong></td><td>水平扩展复杂</td><td>自动扩缩容</td><td>手动扩展</td></tr></tbody></table><ul><li><strong>小规模验证 (&lt;10万文档)</strong>：<strong>Redis Vector</strong> 是绝佳选择。部署简单，延迟极低，与现有Java生态无缝集成。</li><li><strong>中等规模生产 (10万-1000万)</strong>：<strong>Pinecone</strong> 提供完全托管的服务，免去运维烦恼，让你专注于业务逻辑。</li><li><strong>大规模或定制化场景 (&gt;1000万)</strong>：<strong>Weaviate</strong> 的开源和分布式特性提供了极高的灵活性和成本优势，但需要投入运维资源。</li><li><strong>成本敏感场景</strong>：<strong>Weaviate 开源版</strong> 自建部署是理想选择。</li></ul><h2 id="RAG">RAG</h2><p>RAG就是检索增强，是一种让LLM访问外部知识库以回答问题的框架，极大地减少了模型幻觉，提高了回答的准确性。</p><p>我们使用嵌入模型的时候是需要对我们传入的文档进行切分的</p><p>切分策略：</p><p>一般的切分策略就是按照大小进行切分的，一般就是多少个字就切分。这样的话比较简答，但是可能破坏语句的完整性。适用于API，代码等</p><p>还有就是按照语义进行切分，这样就是按照句子边界，标点符号进行切分。这样保证了语句的完整性，但是我们切分的效率比较慢。适用于文章报告等</p><p>我们切分的时候要去按照场景进行选择</p><ul><li><p><strong>检索准确率</strong>：语义切分通常能确保每个Chunk包含完整的答案片段，从而提升准确率。</p></li><li><p><strong>上下文利用率</strong>：合适的Chunk大小可以最大化利用模型的上下文窗口，不多也不少。</p></li><li><p><strong>重叠比例 (Overlap)</strong>：设置一部分重叠内容（如10%）可以防止重要信息在切分边界处丢失。</p><p>在Spring AI中，通常通过实现<code>DocumentTransformer</code>接口来定义切分逻辑。</p></li></ul><hr><p>检索策略：</p><p>密集检索，就是使用模型调用embed方法，然后调用向量库进行密集搜索。这样的话语义理解强，但是对罕见词汇搜索较差</p><p>bm25检索，传统的关键词匹配算法，对罕见词、专业术语友好，但缺乏语义理解。</p><p>混合检索，就待用密集检索和bm25检索，然后分析文档。结合了两种检索，但是复杂度增加了</p><h2 id="上下文构建">上下文构建</h2><p>检索到的文档片段不能直接丢给LLM，需要精心组织成“上下文”（Context），以避免噪声干扰。</p><p>1.如何避免<strong>上下文噪声干扰</strong>？</p><ul><li><strong>重排序 (Reranking)</strong>：使用更轻量、但更精确的模型（如Cross-Encoder）对初步检索到的Top-K结果进行二次排序，将最相关的文档排在最前面。</li><li><strong>上下文压缩 (Context Compression)</strong>：从检索到的文档中提取与用户问题最相关的句子或摘要，丢弃无关信息，减少噪声。</li><li><strong>分层检索 (Hierarchical Retrieval)</strong>：对于结构化的长文档，可以先检索到相关的章节标题，再在章节内部进行精确检索。</li><li><strong>动态上下文长度 (Dynamic Context Length)</strong>：根据问题的复杂度和模型上下文窗口的限制，动态调整送入模型的文档数量。</li></ul><p>在Spring AI中，这些策略通常在调用<code>ChatModel</code>之前，通过自定义逻辑实现。</p><h2 id="Function-Calling">Function Calling</h2><p>函数调用允许LLM将自然语言指令转化为对外部工具（API、数据库查询等）的结构化调用。</p><ul><li><p><strong>参数校验</strong>：这是安全的第一道防线。可以使用<strong>JSON Schema</strong>来定义函数期望的参数格式、类型和范围，在执行前进行严格校验。</p></li><li><p>安全机制</p><ul><li><strong>参数沙箱</strong>：绝不直接将用户输入用于代码执行或数据库查询，进行严格的无害化处理。</li><li><strong>权限控制</strong>：根据用户身份，限制其能调用的函数集合。</li><li><strong>执行隔离/超时</strong>：在独立、受限的环境中执行函数，并设置超时，防止恶意调用消耗系统资源。</li><li><strong>审计日志</strong>：记录所有函数调用，便于追踪和分析。</li></ul></li><li><p><strong>错误处理</strong>：健壮的错误处理至关重要。需要明确处理参数验证失败（<code>ParameterValidationException</code>）、执行超时（<code>ExecutionTimeoutException</code>）、资源超限（<code>ResourceLimitException</code>）等情况，并设计合理的<strong>重试策略</strong>（如使用<code>@Retryable</code>）</p><p>先捕捉ParameterValidationException，参数验证</p><p>再捕捉ExecutionTimeoutException，执行超时</p><p>再捕捉ResourceLimitException，资源限制</p><p>然后再执行重试策略，加上重试注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))</span><br></pre></td></tr></table></figure></li></ul><p>在Spring AI中，你可以定义一个<code>@Bean</code>，通过<code>@Description</code>注解描述其功能，Spring AI会自动将其注册为可供LLM调用的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionParameterValidator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ValidationResult <span class="title function_">validate</span><span class="params">(FunctionCall call)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ValidationResult.builder()</span><br><span class="line">            .typeValidation(validateTypes(call.getParameters()))</span><br><span class="line">            .rangeValidation(validateRanges(call.getParameters()))</span><br><span class="line">            .formatValidation(validateFormats(call.getParameters()))</span><br><span class="line">            .businessValidation(validateBusinessRules(call.getParameters()))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validateTypes</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="comment">// JSON Schema验证</span></span><br><span class="line">        <span class="comment">// 类型强制转换</span></span><br><span class="line">        <span class="comment">// null值处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Agent">Agent</h2><p>Agent是什么，是一个自主决策的智能体</p><p><strong>如何设计多Agent协作的通信机制？</strong></p><p>消息总线模式：</p><p>- 使用Redis/RabbitMQ作为消息中介</p><p>- Agent间异步通信</p><p>- 支持广播和点对点通信</p><p>协调者模式：</p><p>- 中央协调器管理任务分配</p><p>- Agent向协调器汇报状态</p><p>- 协调器负责冲突解决</p><p>契约式协作：</p><p>- 定义Agent间的服务契约</p><p>- 使用OpenAPI规范描述接口</p><p>- 支持版本管理和向后兼容</p><p>状态同步机制：</p><p>- 共享状态存储(Redis Cluster)</p><p>- 乐观锁处理并发冲突</p><p>- 事件溯源记录状态变更</p><p>决策树/状态机实现：</p><ul><li>可以使用<strong>状态机</strong>来定义Agent的行为逻辑。例如，一个Agent的状态可以流转于：<code>IDLE</code> -&gt; <code>PLANNING</code> -&gt; <code>EXECUTING_TOOL</code> -&gt; <code>WAITING_FOR_RESULT</code> -&gt; <code>COMPLETED/ERROR</code>。每个状态转移都由特定的事件触发。这种方式使得Agent的行为清晰、可控、易于调试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentStateMachine</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgentState</span> &#123;</span><br><span class="line">        IDLE, PLANNING, EXECUTING, WAITING_INPUT, COMPLETED, ERROR</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AgentState <span class="title function_">transition</span><span class="params">(AgentState current, AgentEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">            <span class="keyword">case</span> IDLE -&gt; event == START ? PLANNING : IDLE;</span><br><span class="line">            <span class="keyword">case</span> PLANNING -&gt; event == PLAN_READY ? EXECUTING : </span><br><span class="line">                           event == NEED_INPUT ? WAITING_INPUT : PLANNING;</span><br><span class="line">            <span class="keyword">case</span> EXECUTING -&gt; event == SUCCESS ? COMPLETED :</span><br><span class="line">                            event == FAILURE ? ERROR : EXECUTING;</span><br><span class="line">            <span class="keyword">default</span> -&gt; current;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MCP">MCP</h2><p>MCP是一个由Anthropic、OpenAI、Google等行业巨头共同支持的<strong>开放标准</strong>。你可以把它理解为<strong>AI世界的JDBC或JMS</strong>——它旨在标准化AI模型与外部工具、数据源进行交互的方式。</p><ul><li><strong>MCP服务器 (MCP Server)</strong>：任何外部工具、API或数据源（比如你的Spring Boot应用提供的服务）都可以通过实现MCP协议，将自己暴露为一个MCP服务器。它会“宣告”自己能提供哪些能力（如<code>查询订单</code>、<code>读取文件</code>）。</li><li><strong>MCP客户端 (MCP Client)</strong>：AI模型或代理（Agent）作为客户端，可以<strong>发现</strong>并<strong>连接</strong>到这些MCP服务器，使用标准化的请求/响应格式与之交互，而无需关心服务器底层的具体实现。</li></ul><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">传统函数调用 (Function Calling)</th><th style="text-align:left">模型上下文协议 (MCP)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>本质</strong></td><td style="text-align:left"><strong>模型特定的API</strong></td><td style="text-align:left"><strong>开放的、通用的通信协议</strong></td></tr><tr><td style="text-align:left"><strong>耦合度</strong></td><td style="text-align:left">高度耦合（与特定LLM提供商绑定）</td><td style="text-align:left"><strong>松耦合</strong>（与任何支持MCP的LLM兼容）</td></tr><tr><td style="text-align:left"><strong>互操作性</strong></td><td style="text-align:left">弱（切换模型成本高）</td><td style="text-align:left"><strong>强</strong>（工具可被不同模型复用）</td></tr><tr><td style="text-align:left"><strong>生态</strong></td><td style="text-align:left">封闭（各厂商各自为政）</td><td style="text-align:left"><strong>开放</strong>（促进工具和服务的生态系统）</td></tr></tbody></table><p><strong>作为MCP客户端（消费工具）</strong></p><ol><li>在<code>application.yml</code>中配置需要连接的外部MCP服务器的地址。</li><li>Spring AI将提供一个统一的<code>McpTemplate</code>或类似的客户端Bean。</li><li>我们的Agent通过这个<code>McpTemplate</code>来发现并调用外部工具。</li><li><code>McpTemplate</code>会将调用转化为标准的MCP请求，并发送给目标服务器。</li></ol><p>我们如何去导入一个mcp呢在我的项目中？</p><p>如果是内部的，我直接写一个mcp工具即可，实现mcptool接口，继承抽象mcp基类</p><p>外部的我先导入依赖，中添加<code>spring-ai-mistralai-spring-boot-starter</code>依赖</p><p>然后配置mcp服务器，在里面指定mcp的json配置</p><p>然后再spring ai中配置我们chatmodel的apikey</p><p>然后我们就可以使用注册好mcp的chatmodel，来完成使用mcp完成</p><h2 id="Dify">Dify</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>核心能力：</p><ol><li><strong>可视化的提示词编排 (Prompt Studio)</strong>：提供一个图形界面，让开发者可以像填表格一样设计和调试Prompt，管理变量、上下文和模型输出。</li><li><strong>内置的RAG引擎</strong>：允许用户直接上传文档（PDF, TXT, Markdown等），Dify会自动处理数据清洗、分块、向量化和索引，快速构建起一个可供检索的知识库。</li><li><strong>Agent能力</strong>：支持应用集成“工具 (Tools)”，让大模型可以调用外部API（如查询天气、搜索、计算等），完成更复杂的任务，而不仅仅是文本生成。</li><li><strong>统一的API服务</strong>：一旦你在Dify上构建好应用，它会自动生成一套标准的API。你的前端或业务后端可以直接调用这个API，无需关心背后的大模型是哪个、RAG流程如何运作。</li><li><strong>监控与分析</strong>：内置日志和数据分析功能，可以让你监控应用的调用情况、用户反馈、Token消耗等，方便持续运营和优化。</li></ol><p>那么我们怎么构建一个dify，比如n8n工作流</p><p>1.创建新的应用</p><p>2.编排提示词，加入变量</p><p>3.构建RAG知识库，选择嵌入模型</p><p>4.调试程序问题</p><p>5.发布</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis面试hot-高并发/高级玩法部分</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;redis的高并发和高可用&lt;/h1&gt;
&lt;p&gt;如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。&lt;/p&gt;
&lt;p&gt;redis</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>redis的高并发和高可用</h1><p>如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。</p><p>redis 实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><h2 id="主从架构">主从架构</h2><p>redis的主从架构就是读写分离，一主多从。</p><p>主节点负责写，其他的从节点负责读</p><p>其中重要的就是数据的一致性的问题，就是数据的replication。我们采用了主从架构的时候，必须开启持久化</p><ul><li>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li><li>slave并不会过期key，master的key过期了，会模拟一条del命令发送给slave</li><li>无磁盘复制，master 在内存中直接创建 <code>RDB</code> ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</li></ul><hr><p>主从复制的核心：就是增量复制和全量复制</p><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。这个就是增量复制。</p><p>那么我们怎么确定是增量复制还是全量复制呢，如果复制的过程中中断了怎么办？</p><p>Redis2.8 开始就支持断点传输了。</p><p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> 。</p><p>那么我们增量复制的时候，主节点的backlog_buffer里面存储我们最近的数据，然后跟从节点的slave_reolica_buffer进行对比，根据差值来进行全量复制还是增量复制。</p><p>但是这个缓冲区默认的是1M，我们可以增大这个缓冲区</p><p>打开 <code>redis.conf</code> 文件，找到repl-backlog-size，然后修改值即可。</p><hr><p>复制的流程：</p><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><p>全量复制：</p><ul><li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li><li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li><li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li><li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure><ul><li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中。注意，在清空旧数据之前，slave node 依然会<strong>基于旧的数据版本</strong>对外提供服务。</li><li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li></ul><p>增量复制：</p><ul><li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li><li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li><li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li></ul><h2 id="持久化机制">持久化机制</h2><p>一般的我们的持久化机制就是</p><p>RDB，AOF ，RDB-AOF</p><p>持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 Redis 整个挂了，然后 Redis 就不可用了，你要做的事情就是让 Redis 变得可用，尽快变得可用。</p><ul><li>RDB：RDB 持久化机制，是对 Redis 中的数据执行<strong>周期性</strong>的持久化。</li><li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li></ul><p>RDB:</p><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 Redis 中的数据。</li><li>RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis <strong>保持高性能</strong>，因为 Redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 Redis 进程，更加快速。</li><li>如果想要在 Redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟（甚至更长时间）的数据。</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><p>AOF:</p><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 <code>fsync</code> 操作，最多丢失 1 秒钟的数据。</li><li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li><li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li><li>AOF 日志文件的命令通过可读较强的方式进行记录，这个特性非常<strong>适合做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code> ，性能也还是很高的。（如果实时写入，那么 QPS 会大降，Redis 性能会大大降低）</li><li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 <code>merge</code> 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是<strong>基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好很多。</li></ul><p>他们都是有优缺点的，我们可以使用RDB-AOF混合的模式</p><p>当然appendonly yes也是要启动AOF的，然后一般我们选择**<code>appendfsync everysec</code>** 配置 AOF 的同步策略为每秒一次</p><p>在 <code>redis.conf</code> 文件中，找到aof-use-rdb-preamble yes</p><p>这意味着当 AOF 进行 <code>rewrite</code> （重写）时，会使用 RDB 格式的数据作为 AOF 文件的前置内容，然后才是增量的 AOF 命令。  这能大大缩短 Redis 重启时加载 AOF 文件的速度。</p><p>然后重启redis，使配置生效</p><h2 id="哨兵模式">哨兵模式</h2><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li><p>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</p></li><li><p>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p></li><li><p>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</p></li><li><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p></li><li><p>哨兵至少需要 3 个实例，来保证自己的健壮性。按照需求设置配置 <code>quorum=</code></p></li></ul><hr><p>哨兵在让redis node进行主备切换的时候可能会出现数据丢失的问题</p><p>异步复制导致的数据丢失：</p><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p><p>脑裂问题导致的数据丢失:</p><p>脑裂，也就是说，某个 master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会<strong>认为</strong> master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong>。</p><p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p><p>解决：：</p><p>进行如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p><p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。</p><ul><li>减少异步复制数据的丢失</li></ul><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p><ul><li>减少脑裂的数据丢失</li></ul><p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p><hr><p>自动发现机制：</p><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步。</p><p>选举算法：</p><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><p>configuration epoch：</p><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p><h2 id="集群">集群</h2><p>一般我们使用的使redis原生的集群，Redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><p>介绍：</p><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><p>节点之间的通信：</p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p><p>Redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p><ul><li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code> 。</li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li></ul><hr><p>gossip协议：</p><p>gossip 协议包含多种消息，包含 <code>ping</code> , <code>pong</code> , <code>meet</code> , <code>fail</code> 等等。</p><ul><li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-trib.rb add-node</span><br></pre></td></tr></table></figure><p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</li><li>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。</li><li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</li></ul><p>ping:</p><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p><p>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息。</p><hr><p>分布式寻址算法：</p><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul><p>hash：</p><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><p>一致性hash：</p><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><p>Redis cluster 的 hash slot 算法:</p><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/redis/">redis</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BUG收集</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;配置bug&lt;/h1&gt;
&lt;h2 id=&quot;MyBatis-bug&quot;&gt;&lt;strong&gt;MyBatis bug&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[x] factoryBeanObjectType的兼容性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring Boot 在</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>配置bug</h1><h2 id="MyBatis-bug"><strong>MyBatis bug</strong></h2><ul><li>[x] factoryBeanObjectType的兼容性问题</li></ul><p>Spring Boot 在 3.2 版本中更新了 <code>FactoryBeanRegistrySupport#getTypeForFactoryBeanFromAttributes</code> 方法，它要求 <code>factoryBeanObjectType</code> 必须是 <code>Class&lt;?&gt;</code> 或 <code>ResolvableType</code>，绝不接受 <code>String</code></p><p>旧版本的 MyBatis-Spring 在 <code>ClassPathMapperScanner.processBeanDefinitions()</code> 中将 <code>beanClassName</code>（一个 <code>String</code>）赋给了 <code>factoryBeanObjectType</code></p><p>slove:</p><p>我们使用MyBatis-Plus starter3.5.5。然后现在基本都要升级成springboot3，因为springaialibaba等框架也是需要3的</p><p>然后我们分模块的时候，为了避免@MapperScan重复扫描，我们只在业务模块进行mybatisplus的导入，然后common模块就只导入一个annotion。不到人core</p><p>防止出现重复扫描的问题。</p><h1>nacos配置bug</h1><ul><li>[x] 缺少NacosShutdownHook，然后导致nacos-clint无法运行，添加nacos钩子然后让其更美观的关闭</li></ul><p>关闭通知中心，然后强制关闭所有的后台线程</p><p>reason:</p><p>Spring 会先销毁 Bean，然后执行注册的 <code>ShutdownHook</code>，如果 Nacos 没有注册自己的钩子，那它的后台线程就会存活到 JVM 强制退出。</p><p>Nacos 客户端（<code>nacos-client</code>）在正常退出时会通过 <code>ShutdownHook</code> 释放 HttpClient、长连接、定时任务等资源。<br>如果没有这个钩子，<code>DefaultHttpClientFactory</code> 之类的类无法加载或初始化不完整，就会出现 <code>NoClassDefFoundError</code>，或者后台线程挂起不退出。</p><p>slove:</p><p>所以我们需要在应用的时候手动注册一个nacos的关闭的钩子，通知中心 → 释放 HttpClient → 停止定时任务</p><p>然后为了防止还有存活，再强制关闭所有的后台线程</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/BUG/">BUG</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
