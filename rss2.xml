<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Fri, 06 Jun 2025 08:40:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>计算机网络面试题hot2</title>
      <link>https://blog.tokenlen.top/2025/06/05/network/net4/</link>
      <guid>https://blog.tokenlen.top/2025/06/05/network/net4/</guid>
      <pubDate>Wed, 04 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h1&gt;&lt;h2 id=&quot;1-网络OSI模型和TCP-IP模型分别介绍一下&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="1-网络OSI模型和TCP-IP模型分别介绍一下"><a href="#1-网络OSI模型和TCP-IP模型分别介绍一下" class="headerlink" title="1.网络OSI模型和TCP/IP模型分别介绍一下"></a>1.网络OSI模型和TCP/IP模型分别介绍一下</h2><blockquote><p>OSI七层模型</p></blockquote><p>为了使得多种设备能通过网络相互通信，和为了<strong>解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型</strong>（<em>Open System Interconnection Reference Model</em>），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721097268006-12c71992-11b3-4a8e-9d05-35ad3e0ab86e.png" alt="img"></p><p>每一层负责的职能都不同，如下：</p><ul><li>应用层，负责给应用程序提供统一的接口；</li><li>表示层，负责把<strong>数据转换成兼容另一个系统能识别的格式</strong>；</li><li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li><li>传输层，负责端到端的数据传输；</li><li>网络层，负责数据的路由、转发、分片；</li><li>数据链路层，负责<strong>数据的封帧和差错检测</strong>，以及 MAC 寻址；</li><li>物理层，负责在物理网络中传输数据帧；</li></ul><p>由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。</p><p>事实上，我们比较常见，也比较实用的是<strong>四层模型</strong>，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。</p><blockquote><p>TCP/IP模型</p></blockquote><p>TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721097233614-f7cd6378-32d9-4cb8-9e60-e70b95bb3759.png" alt="img"></p><ul><li>应用层 支持 HTTP、SMTP 等最终用户进程</li><li>传输层 处理主机到主机的通信（TCP、UDP）</li><li>网络层 寻址和路由数据包（IP 协议）</li><li>链路层 通过网络的物理电线、电缆或无线信道移动比特</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="1-HTTP报文有哪些部分？"><a href="#1-HTTP报文有哪些部分？" class="headerlink" title="1.HTTP报文有哪些部分？"></a>1.HTTP报文有哪些部分？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1721710466863-78bf586d-a25c-4fe4-bf27-5dd576b998c8.png" alt="img"></p><p>分请求报文和响应报文来说明。</p><p><strong>请求报文：</strong></p><ul><li>请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。</li><li>请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。</li><li>空行：请求头部和请求体之间用空行分隔。</li><li>请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。</li></ul><p>一般是20个字节吧，请求头的长度</p><p><strong>响应报文：</strong></p><ul><li>状态行：包含HTTP协议版本、状态码和状态信息。</li><li>响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。</li><li>空行：响应头部和响应体之间用空行分隔。</li><li>响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容</li></ul><h2 id="2-HTTP常用的状态码？"><a href="#2-HTTP常用的状态码？" class="headerlink" title="2.HTTP常用的状态码？"></a>2.HTTP常用的状态码？</h2><p>HTTP 状态码分为 5 大类</p><ul><li>1xx 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li><li>2xx 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</li><li>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li><li>4xx 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li><li>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li></ul><p>其中常见的具体状态码有：</p><ul><li>200：请求成功；</li><li>301：永久重定向；302：临时重定向；</li><li>404：无法找到此页面；405：请求的方法类型不支持；</li><li>500：服务器内部出错。</li></ul><h2 id="3-HTTP返回状态301-302分别是什么？"><a href="#3-HTTP返回状态301-302分别是什么？" class="headerlink" title="3.HTTP返回状态301 302分别是什么？"></a>3.HTTP返回状态301 302分别是什么？</h2><p>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明<strong>请求的资源已经不存在了</strong>，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明<strong>请求的资源还在，但暂时需要用另一个 URL 来访问</strong>。</li></ul><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><h2 id="4-http-502和-504-的区别？"><a href="#4-http-502和-504-的区别？" class="headerlink" title="4.http 502和 504 的区别？"></a>4.http 502和 504 的区别？</h2><ul><li>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从<strong>上游服务器接收到无效的响应</strong>。</li><li>504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时从上游服务器收到响应</strong>。</li></ul><p>举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（tomcat 等）。</p><ul><li>当nginx收到了无效的响应时，就返回502。</li><li><strong>当nginx超过自己配置的超时时间，还没有收到请求时</strong>，就返回504错误。</li></ul><h2 id="5-HTTP层请求的类型有哪些？"><a href="#5-HTTP层请求的类型有哪些？" class="headerlink" title="5.HTTP层请求的类型有哪些？"></a>5.HTTP层请求的类型有哪些？</h2><ul><li>GET：用于请求获取指定资源，通常用于获取数据。</li><li>POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</li><li>PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。</li><li>DELETE：用于请求服务器删除指定资源。</li><li>HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</li></ul><h2 id="6-GET和POST的使用场景，有哪些区别？"><a href="#6-GET和POST的使用场景，有哪些区别？" class="headerlink" title="6.GET和POST的使用场景，有哪些区别？"></a>6.GET和POST的使用场景，有哪些区别？</h2><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，<strong>所以 GET 请求的参数只允许 ASCII 字符</strong> ，而且<strong>浏览器会对 URL 的长度有限制（</strong>HTTP协议本身对 URL长度并没有做任何规定）。</p><p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</p><p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，<strong>body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</strong></p><p>比如，你在我文章底部，敲入了留言后点击「提交」（<strong>暗示你们留言</strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</p><p>如果从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p><ul><li>可以用 GET 方法<strong>实现新增或删除数据</strong>的请求，这样实现的 GET 方法自然就不是安全和幂等。</li><li>可以用 POST 方法<strong>实现查询数据</strong>的请求，这样实现的 POST 方法自然就是安全和幂等。</li></ul><h2 id="7-HTTP的长连接是什么？"><a href="#7-HTTP的长连接是什么？" class="headerlink" title="7.HTTP的长连接是什么？"></a>7.HTTP的长连接是什么？</h2><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231702564.png" alt="image-20240725231702564"></p><p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231648038.png" alt="image-20240725231648038"></p><p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231628356.png" alt="image-20240725231628356"></p><p>这样实在太累人了，一次连接只能请求一次资源。</p><p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p><p>当然可以，<strong>HTTP 的 Keep-Alive</strong> 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231558255.png" alt="image-20240725231558255"></p><p><strong>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</strong></p><h2 id="8-HTTP1-1怎么对请求做拆包，具体来说怎么拆的？"><a href="#8-HTTP1-1怎么对请求做拆包，具体来说怎么拆的？" class="headerlink" title="8.HTTP1.1怎么对请求做拆包，具体来说怎么拆的？"></a>8.HTTP1.1怎么对请求做拆包，具体来说怎么拆的？</h2><p>在HTTP/1.1中，请求的拆包是通过”<strong>Content-Length</strong>“头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231532943.png" alt="image-20240725231532943"></p><p>具体来说，当客户端发送一个HTTP请求时，会在请求头中添加”Content-Length”字段，该字段的值表示请求正文的字节数。</p><p>服务器在接收到请求后，<strong>会根据”Content-Length”字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。</strong></p><p>这种基于”Content-Length”字段的拆包机制可以确保服务器正确接收到完整的请求，<strong>避免了请求的丢失或截断问题。</strong></p><h2 id="9-http-断点重传是什么？"><a href="#9-http-断点重传是什么？" class="headerlink" title="9.http 断点重传是什么？"></a>9.http 断点重传是什么？</h2><p>断点续传是HTTP/1.1协议支持的特性。实现断点续传的功能，<strong>需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1737790649434-0bb21e8e-faae-44c7-9f7b-2f677c38b39d.webp" alt="img">一个最简单的断点续传流程如下：</p><ol><li>客户端开始下载一个1024K的文件，服务端发送A<strong>ccept-Ranges: bytes来告诉客户端，其支持带Range的请求</strong></li><li>假如客户端下载了其中512K时候网络突然断开了，过了一会网络可以了，客户端再下载时候，需要在HTTP头中申明本次需要续传的片段：<strong>Range:bytes=512000-这个头通知服务端从文件的512K位置开始传输文件，直到文件内容结束</strong></li><li>服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：<strong>Content-Range:bytes 512000-/1024000,Content-Length: 512000。</strong>并且此时服务端返回的HTTP状态码应该是<strong>206</strong> Partial Content。如果<strong>客户端传递过来的Range超过资源的大小,则响应416</strong> Requested Range Not Satisfiable</li></ol><p>通过上面流程可以看出：断点续传中4个HTTP头不可少的，<strong>分别是Range头、Content-Range头、Accept-Ranges头、Content-Length头</strong>。其中第一个Range头是客户端发过来的，后面3个头需要服务端发送给客户端。下面是它们的说明：</p><ul><li><strong>Accept-Ranges: bytes：</strong>这个值<strong>声明了可被接受的每一个范围请求</strong>, 大多数情况下是字节数 bytes</li><li><strong>Range: bytes=开始位置-结束位置：</strong>Range是浏览器告知服务器所需分部分内容范围的消息头。</li></ul><h2 id="10-HTTP为什么不安全？"><a href="#10-HTTP为什么不安全？" class="headerlink" title="10.HTTP为什么不安全？"></a>10.HTTP为什么不安全？</h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1719381758323-e2bd2f7b-d599-4b23-b258-b8620ac52808.jpeg" alt="img"></p><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <strong>SSL/TLS</strong> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><h2 id="11-HTTP和HTTPS-的区别？"><a href="#11-HTTP和HTTPS-的区别？" class="headerlink" title="11.HTTP和HTTPS 的区别？"></a>11.HTTP和HTTPS 的区别？</h2><p>区别主要有以下四点：</p><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP <strong>网络层之间加入了 SSL/TLS 安全协议</strong>，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS <strong>在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</strong></li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 <strong>CA（证书权威机构）申请数字证书，</strong>来保证服务器的身份是可信的。</li></ul><h2 id="12-HTTPS握手过程说一下"><a href="#12-HTTPS握手过程说一下" class="headerlink" title="12.HTTPS握手过程说一下"></a>12.HTTPS握手过程说一下</h2><p>传统的 <strong>TLS 握手基本都是使用 RSA 算法来</strong>实现密钥交换的，在将 TLS 证书部署服务端时，<strong>证书文件其实就是服务端的公钥</strong>，会在 TLS 握手阶段传递给客户端，而<strong>服务端的私钥则一直留在服务端</strong>，一定要确保私钥不能被窃取。</p><p>在 RSA 密钥协商算法中，<strong>客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端</strong>。根据非对称加密算法，<strong>公钥加密的消息仅能通过私钥解密</strong>，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p><p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1716097892426-58902c14-da4f-40fc-9199-94752fc5368b.webp" alt="img"></p><p><img src="https://cdn.xiaolincoding.com//picgo/1716097892465-985f6cfe-66c8-4384-aabd-840821de1b66.webp" alt="img"></p><blockquote><p>TLS 第一次握手</p></blockquote><p>首先，由客户端向服务器发起<strong>加密通信</strong>请求，<strong>也就是 ClientHello 请求</strong>。在这一步，客户端主要向服务器发送以下信息：</p><ul><li>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li><li>（3）客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><blockquote><p>TLS 第二次握手</p></blockquote><p>服务器收到客户端请求后，向客户端发出响应，也就是 <strong>SeverHello</strong>。服务器回应的内容有如下内容：</p><ul><li>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li>（3）确认的密码套件列表，如 RSA 加密算法。</li><li>（4）服务器的数字证书。</li></ul><blockquote><p>TLS 第三次握手</p></blockquote><p>客户端收到服务器的回应之后，<strong>首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</strong></p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后<strong>使用它加密报文，向服务器发送如下信息：</strong></p><ul><li>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>（3）客户端握手结束通知<strong>，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</strong></li></ul><p>上面第一项的随机数是整个握手阶段的<strong>第三个随机数</strong>，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><blockquote><p>TLS 第四次握手</p></blockquote><p>服务器收到客户端的<strong>第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</strong></p><p>然后，<strong>向客户端发送最后的信息</strong>：</p><ul><li>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>（2）服务器握手结束通知，表示<strong>服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</strong></li></ul><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，<strong>就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</strong></p><h2 id="13-HTTPS是如何防范中间人的攻击？"><a href="#13-HTTPS是如何防范中间人的攻击？" class="headerlink" title="13.HTTPS是如何防范中间人的攻击？"></a>13.HTTPS是如何防范中间人的攻击？</h2><p>主要通过<strong>加密和身份校验机制</strong>来防范中间人攻击的:</p><ul><li>加密：https 握手期间会通过<strong>非对称加密的方式</strong>来协商出对称加密密钥。</li><li>身份校验：<strong>服务器</strong>会向证书颁发机构申请<strong>数字证书</strong>，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，<strong>客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密。</strong></li></ul><p>中间人攻击的关键在于攻击者冒充服务器与客户端建立连接，并同时与服务器建立连接。</p><p>但由于攻击者无法获得服务器的私钥，因此无法正确解密客户端发送的加密数据。同时，客户端会在建立连接时验证服务器的证书，如果证书验证失败或存在问题，客户端会发出警告或中止连接。</p><h2 id="14-Http1-1和2-0的区别是什么？"><a href="#14-Http1-1和2-0的区别是什么？" class="headerlink" title="14.Http1.1和2.0的区别是什么？"></a>14.Http1.1和2.0的区别是什么？</h2><p>HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ul><li><strong>头部压缩</strong>：HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。这就是所谓的 <strong>HPACK</strong> 算法：在客户端和服务器同时维护一张<strong>头信息表</strong>，所有字段都会存入这个表，<strong>生成一个索引号</strong>，以后就<strong>不发送同样字段了，只发送索引号</strong>，这样就<strong>提高速度</strong>了。</li><li><strong>二进制格式</strong>：HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li><li><strong>并发传</strong>输：引出了 <strong>Stream</strong> 概念，多个 Stream 复用在一条 TCP 连接。解决了HTTP/1.1 队头阻塞的问题：</li><li><strong>服务器主动推送资源</strong>：HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</li></ul><h2 id="15-HTTP进行TCP连接之后，在什么情况下会中断"><a href="#15-HTTP进行TCP连接之后，在什么情况下会中断" class="headerlink" title="15.HTTP进行TCP连接之后，在什么情况下会中断"></a>15.HTTP进行TCP连接之后，在什么情况下会中断</h2><ul><li>当服务端或者客户端执行 close 系统调用的时候，会发送FIN报文，就会进行<strong>四次挥手</strong>的过程</li><li>当发送方发送了数据之后，接收方超过一段时间没有响应ACK报文，发送方重传数据达到最大次数的时候，就会断开TCP连接。</li><li>当HTTP长时间没有进行请求和响应的时候，超过一定的时间，这个时间就是长连接的维持时间，就会释放连接</li></ul><h2 id="16-HTTP、SOCKET和TCP的区别"><a href="#16-HTTP、SOCKET和TCP的区别" class="headerlink" title="16.HTTP、SOCKET和TCP的区别"></a>16.HTTP、SOCKET和TCP的区别</h2><p>HTTP是应用层协议，定义了<strong>客户端和服务器之间交换的数据格式和规则</strong>；Socket是通信的一端，<strong>提供了网络通信的接口</strong>；TCP是传输层协议，负责在<strong>网络中建立可靠的数据传输连接</strong>。它们在网络通信中扮演不同的角色和层次。</p><ul><li>HTTP是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示Web页面。</li><li>Socket是计算机网络中的一种抽象，用于描述<strong>通信链路的一端</strong>，提供了底层的通信接口，可实现不同计算机之间的<strong>数据交换</strong>。</li><li>TCP是一种面向连接的、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。</li></ul><h2 id="17-HTTP到底是不是无状态的？"><a href="#17-HTTP到底是不是无状态的？" class="headerlink" title="17.HTTP到底是不是无状态的？"></a>17.HTTP到底是不是无状态的？</h2><p>HTTP是<strong>无状态</strong>的，这意味着<strong>每个请求都是独立的</strong>，服务器不会在多个请求之间保留关于客户端状态的信息。在每个HTTP请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的。</p><p>虽然HTTP本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是使用<strong>Cookie和Session来跟踪用户状态</strong>。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能。或者是使用token，一般这个都是用来认证识别用户使用的</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="1-DNS的全称了解么？"><a href="#1-DNS的全称了解么？" class="headerlink" title="1.DNS的全称了解么？"></a>1.DNS的全称了解么？</h2><p>DNS的全称是<strong>Domain Name System</strong>（域名系统），它是互联网中用于将<strong>域名转换为对应IP地址的分布式数据库系统。</strong>DNS扮演着重要的角色，使得人们可以通过易记的域名访问互联网资源，而无需记住复杂的IP地址。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p><p>实际上域名最后还有一个点，比如 www.server.com.，这个<strong>最后的一个点代表根域名。</strong></p><p>也就是，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" alt="DNS 树状结构"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，<strong>客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</strong></p><h2 id="2-DNS-域名解析的工作流程？"><a href="#2-DNS-域名解析的工作流程？" class="headerlink" title="2.DNS 域名解析的工作流程？"></a>2.DNS 域名解析的工作流程？</h2><ol><li>客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果<strong>缓存</strong>里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，<strong>本地 DNS 会去问它的根域名服务器：</strong>“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715326531135-c1f081dd-89e1-4b31-94e4-95a76f9fcba4.png" alt="img"></p><p>就是一个递归的过程，从顶级到下面一步一步递归</p><h2 id="3-DNS的底层使用TCP还是UDP？"><a href="#3-DNS的底层使用TCP还是UDP？" class="headerlink" title="3.DNS的底层使用TCP还是UDP？"></a>3.DNS的底层使用TCP还是UDP？</h2><p>DNS 基于UDP协议实现，DNS使用UDP协议进行域名解析和数据传输。因为基于UDP实现DNS能够提供低延迟、简单快速、轻量级的特性，更适合DNS这种需要快速响应的域名解析服务。</p><ul><li><strong>低延迟：</strong> UDP是一种无连接的协议，不需要在数据传输前建立连接，因此可以减少传输时延，适合DNS这种需要快速响应的应用场景。</li><li><strong>简单快速：</strong> UDP相比于TCP更简单，没有TCP的连接管理和流量控制机制，传输效率更高，适合DNS这种需要快速传输数据的场景。</li><li><strong>轻量级</strong>：UDP头部较小，占用较少的网络资源，对于小型请求和响应来说更加轻量级，适合DNS这种频繁且短小的数据交换。</li></ul><p>尽管 UDP 存在丢包和数据包损坏的风险，但在 DNS 的设计中，这些风险是可以被容忍的。DNS 使用了一些机制来提高可靠性，例如查询超时重传、请求重试、缓存等，以确保数据传输的可靠性和正确性。</p><p>但是dns也是可以使用tcp进行的，默认是udp端口号是53</p><p><strong>响应数据超过 UDP 限制时</strong></p><ul><li>如果 DNS 响应内容超过 <strong>512 字节</strong>（在启用 EDNS0 时可以大于此限制，但 UDP 包最大也不能超过 4096 字节）；</li><li>比如：<ul><li>响应包含大量的 A 记录、MX 记录；</li><li>使用 DNSSEC（数据带签名，很大）；</li></ul></li><li><p>那么就会自动“回退”使用 <strong>TCP 进行重传</strong>。</p><p><strong>区域传送（Zone Transfer）时</strong></p></li><li><p>主从 DNS 服务器之间同步区域信息（<strong>AXFR、IXFR 请求</strong>）使用 <strong>TCP</strong>；</p></li><li><p>这些传输的数据量大、需要可靠性和顺序性，UDP 无法胜任。</p><p><strong>连接建立更可靠的查询环境时</strong></p></li><li><p>一些防火墙或中间设备可能对 UDP 做限制，此时客户端会主动使用 TCP。</p></li><li>一些安全策略（如 DNS-over-TCP、DoH、DoT）也默认使用 TCP。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/05/network/net4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git</title>
      <link>https://blog.tokenlen.top/2025/05/31/new-stack/git/</link>
      <guid>https://blog.tokenlen.top/2025/05/31/new-stack/git/</guid>
      <pubDate>Fri, 30 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;Git</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Git 是一个分布式版本控制系统，用于跟踪和管理代码的变化，广泛应用于软件开发中。一般用于多人开发，或者是版本管理的</p><p>组成部分：</p><p><strong>工作区（Working Directory）</strong>：你本地修改代码的目录。</p><p><strong>暂存区（Staging Area/Index）</strong>：用于暂存准备提交的更改。</p><p><strong>本地仓库（Local Repository）</strong>：存储提交的代码版本。</p><p><strong>远程仓库（Remote Repository）</strong>：托管在远程服务器（如 GitHub、GitLab）的代码仓库。</p><p>流程：修改代码 → 暂存更改（git add） → 提交到本地仓库（git commit） → 推送到远程仓库（git push）。</p><p>从远程仓库拉取更新（git pull）或克隆仓库（git clone）。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>git init 初始化仓库，建立一个.git文件夹</p><p>git clone ssh/http克隆仓库</p><p>git status 查看工作区的状态</p><p>git add <file name>添加文件。git add .添加所有</p><p>git commit -m “”提交</p><p>git log 查看提交历史</p><p>git log —oneline # 简洁显示</p><p>git log —graph   # 显示分支图形</p><p>git branch 列出本地分支</p><p>git branch -r 远程分支</p><p>git branch -a 列出所有分支</p><p>git branch &lt; name&gt;新建分支</p><p>git checkout &lt; name&gt;切换分支</p><p>git checkout -b &lt; name&gt;切换并创建分支</p><p>git merge &lt; name&gt;合并分支，可能要处理分支冲突</p><p>git branch -d &lt; name&gt;删除已经合并的分支</p><p>git branch -D &lt; name&gt; 强制删除</p><p> git remote add origin 添加远程仓库</p><p>git remote -v 查看远程仓库</p><p>git push origin main 推送本地到某某分支</p><p>git pull origin main 拉起分支，相当于 git fetch + git merge。</p><p>git restore &lt; file&gt;撤销工作区修改</p><p><strong>这些都是需要某次提交的hash值的</strong></p><p>git restore —staged  撤销暂存区修改</p><p>git reset —soft 撤销提交，但修改还在</p><p>git reset —hard 撤销提交，修改也不要</p><p>git revert 回滚到某次提交</p><p>git fetch 只获取更新的内容，不合并</p><p>git diff 工作区和暂存区的差异</p><p>git diff —staged 暂存区和上次提交的差异</p><p>将当前分支的提交应用到另一分支上</p><p>git rebase </p><p>解决冲突后继续：git rebase —continue</p><p>中止变基：git rebase —abort</p><p><strong>gitignore</strong>：</p><ul><li>创建 .gitignore 文件，忽略不需要跟踪的文件（如 node_modules/、.env）。</li></ul><p>扩展命令：</p><ul><li>git checkout — files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li><li>git reset — files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li><li>git checkout HEAD — files 回滚到复制最后一次提交。</li><li></li></ul><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p><strong>合并冲突</strong></p><p>合并或拉取时可能发生冲突，Git 会标记冲突文件。</p><p>当发生冲突时，Git 会提示您文件中的冲突部分。您可以使用以下命令查看所有冲突文件的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ol><li>打开包含冲突的文件，您会看到类似以下的标记：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 代码来自目标分支</span><br><span class="line">=======</span><br><span class="line">// 代码来自要合并的分支</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchName</span><br></pre></td></tr></table></figure><p>您需要手动编辑这些文件，决定保留哪些变更或者如何整合这些变更。</p><p>完成冲突解决后，对已解决的文件使用以下命令标记为已解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt; </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p><strong>误提交</strong></p><p>修改最后一次提交：git commit —amend</p><p>回滚到之前版本：git reset 或 git revert</p><p><strong>远程推送被拒绝</strong></p><p>通常是远程仓库有更新，先拉取：git pull —rebase，然后再推送。</p><h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><h2 id="1-git-rebase和merge的区别"><a href="#1-git-rebase和merge的区别" class="headerlink" title="1.git rebase和merge的区别"></a>1.git rebase和merge的区别</h2><ul><li><strong>Rebase</strong>（变基）是将<strong>一个分支上的提交逐个地应用到另一个分支上</strong>，使得提交历史变得更加线性。当执行rebase时，Git会将目标分支与源分支的共同祖先以来的所有提交挪到目标分支的最新位置。这个过程可以看作是<strong>将源分支上的每个提交复制到目标分支上</strong>。简而言之，<strong>rebase可以将提交按照时间顺序线性排列。</strong></li></ul><p>常用来更新的时候</p><ul><li><strong>Merge</strong>（合并）是将<strong>两个分支上的代码提交历史合并为一个新的提交</strong>。在执行merge时，Git会创建一个新的合并提交，将两个分支的提交历史连接在一起。这样，两个分支的修改都会包含在一个合并提交中。合并后的历史会保留每个分支的提交记录。</li></ul><h2 id="2-解释“git-pull”和“git-fetch”之间有什么区别？"><a href="#2-解释“git-pull”和“git-fetch”之间有什么区别？" class="headerlink" title="2.解释“git pull”和“git fetch”之间有什么区别？"></a>2.解释“git pull”和“git fetch”之间有什么区别？</h2><p>在Git中，<code>git fetch</code>和<code>git pull</code>都是用于从远程仓库获取更新的命令，但它们的工作方式有所不同。</p><p><code>git fetch</code></p><ul><li><strong>功能</strong>: 只从<strong>远程仓库获取更新，不会将这些更新合并到当前分支</strong>。</li><li><strong>用途</strong>: 它会下载所有的提交、分支和标签，更新本地的远程跟踪分支（如<code>origin/master</code>），但不会改变你的工作目录或当前分支的内容。</li><li><strong>场景</strong>: 适合在<strong>想要查看远程变化但不希望立即合并的情况下使用</strong>。你可以先审查更新，决定接下来是否要合并。</li></ul><p><code>git pull</code></p><ul><li><strong>功能</strong>: 是<code>git fetch</code>和<code>git merge</code>的组合命令。它首先会执行<code>git fetch</code>，然后会<strong>将获取的更新合并到当前分支。</strong></li><li><strong>用途</strong>: 直接将远程分支的变化合并到你当前的工作分支，适合希望快速同步远程更改并工作于最新状态的场景。</li><li><strong>场景</strong>: 适用于当你确信需要立即合并远程更新时，方便快速将最新的更改合并到本地。</li></ul><h2 id="3-简述Git和SVN有什么区别？"><a href="#3-简述Git和SVN有什么区别？" class="headerlink" title="3.简述Git和SVN有什么区别？"></a>3.简述Git和SVN有什么区别？</h2><p>Git和SVN（Subversion）都是版本控制系统，但它们在设计理念、工作流程和功能等方面有显著的区别。以下是一些主要区别：</p><ol><li><strong>版本控制模型</strong>：<ul><li><strong>SVN</strong>：基于<strong>集中式版本控制系统</strong>（CVCS），所有版本历史记录保存在中央服务器上，工作副本直接与中央库交互。</li><li><strong>Git</strong>：基于<strong>分布式版本控制系统</strong>（DVCS），每个开发者的工作副本都包含整个代码库的历史记录，操作可以在本地完成。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>SVN</strong>：对于大文件的处理和网络操作可能比较慢，因为每次提交或更新都需要与中央服务器交互。</li><li><strong>Git</strong>：大部分操作（如提交、分支、合并等）都在本地进行，速度更快，尤其是在离线时。</li></ul></li><li><strong>分支和合并</strong>：<ul><li><strong>SVN</strong>：分支和标签是从中央库创建的，相对较重，使用上不够灵活。</li><li><strong>Git</strong>：分支操作轻量且快速，鼓励频繁创建和使用分支，合并操作也相对简单。</li></ul></li><li><strong>数据完整性</strong>：<ul><li><strong>SVN</strong>：依赖中央服务器的数据完整性，尽管有一定的安全措施，但主要依靠服务器来维护数据。</li><li><strong>Git</strong>：通过<strong>SHA-1哈希值</strong>来确保每次提交的完整性，每个提交都是整个历史的一部分，易于追踪和验证。</li></ul></li><li><strong>工作流</strong>：<ul><li><strong>SVN</strong>：通常采用拉/推的工作流，开发者需要从中央库更新，提交时也要推送到中央库。</li><li><strong>Git</strong>：支持多种工作流（如Forking、Feature Branch等），开发者可以在本地进行完全隔离的开发，之后再选择何时将更改推送到中央库。</li></ul></li><li><strong>使用场景</strong>：<ul><li><strong>SVN</strong>：适合小团队和需要严格控制版本访问的项目。</li><li><strong>Git</strong>：更适合开源项目和需要频繁更新的团队，灵活性和效率较高。</li></ul></li></ol><p>总的来说，Git更适合现代软件开发的分布式协作需求，而SVN则在一些传统环境中仍然被广泛使用。</p><h2 id="4-简述Github和Gitlab的区别？"><a href="#4-简述Github和Gitlab的区别？" class="headerlink" title="4.简述Github和Gitlab的区别？"></a>4.简述Github和Gitlab的区别？</h2><p>GitHub和GitLab是两个流行的Git代码托管平台，虽然它们有许多相似之处，但在一些关键方面有所不同：</p><ol><li><strong>主机定位</strong>：<ul><li><strong>GitHub</strong>：主要是一个基于云的服务，提供代码托管和协作工具。</li><li><strong>GitLab</strong>：可以选择使用云服务，也可以自行托管在本地服务器上，<strong>适合更注重私有化和自定义的团队。</strong></li></ul></li><li><strong>访问控制</strong>：<ul><li><strong>GitHub</strong>：较为简单的权限管理，主要依赖于组织和仓库的级别设置。</li><li><strong>GitLab</strong>：提供<strong>更细粒度的权限管理，允许用户为不同的项目或分支设置不同的访问权限</strong>。</li></ul></li><li><strong>集成功能</strong>：<ul><li><strong>GitHub</strong>：虽然有GitHub Actions等CI/CD功能，但整体上集成和扩展的选择相对少。</li><li><strong>GitLab</strong>：内置了非常强大的CI/CD功能，几乎所有的<strong>DevOps流程</strong>都可以在一个平台上完成。</li></ul></li><li><strong>issue追踪与项目管理</strong>：<ul><li><strong>GitHub</strong>：提供基础的issue追踪功能，涉及的问题管理相对简单。</li><li><strong>GitLab</strong>：提供更<strong>全面的项目管理工具，包含时间线、里程碑和更复杂的看板</strong>等功能。</li></ul></li><li><strong>开源与闭源</strong>：<ul><li><strong>GitHub</strong>：主要为闭源平台，但有一些开源项目。</li><li><strong>GitLab</strong>：提供开源版本，用户可以自由修改和使用。</li></ul></li><li><strong>社区和生态</strong>：<ul><li><strong>GitHub</strong>：有着庞大的开发者社区和丰富的开源项目资源。</li><li><strong>GitLab</strong>：社区相对较小，但也在快速增长中，尤其是在DevOps领域。</li></ul></li><li><strong>费用结构</strong>：<ul><li><strong>GitHub</strong>：基本的公共仓库免费，但某些高级功能需要付费。</li><li><strong>GitLab</strong>：提供更全面的免费计划，收费方案也根据功能不同而不同。</li></ul></li></ol><p>这些差异使得GitHub和GitLab在满足不同团队和项目需求时，具有各自的优缺点。选择哪个平台主要取决于团队的具体需求和工作流程。</p><p>5.</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/git/">git</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/31/new-stack/git/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试题目</title>
      <link>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/</link>
      <guid>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/</guid>
      <pubDate>Tue, 27 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;面试一轮&quot;&gt;&lt;a href=&quot;#面试一轮&quot; class=&quot;headerlink&quot; title=&quot;面试一轮&quot;&gt;&lt;/a&gt;面试一轮&lt;/h1&gt;&lt;h2 id=&quot;3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#3-无重复字符的最长子串&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="面试一轮"><a href="#面试一轮" class="headerlink" title="面试一轮"></a>面试一轮</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><p>滑动窗口</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,res = <span class="number">0</span>,n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                left = Math.max(left,cnt.get(s.charAt(right)));</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.put(s.charAt(right),right);</span><br><span class="line">            res = Math.max(res,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典滑动窗口，更新right和left然后计算长度</p><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p>linkedHashMap</p><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>一看到是存储键值对数据，那我们可以使用map集合来做，然后返现需要插入xud</p><p>LinkedHashMap而其内部是靠 建立一个<strong>双向链表</strong> 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护 ，准确的来说，是有三个函数来做这件事，这三个函数都统称为 <strong>回调函数</strong> ，这三个函数分别是：</p><p>void afterNodeAccess(Node<K,V> p) { }<br>其作用就是在访问元素之后，<strong>将该元素放到双向链表的尾巴处</strong>(所以这个函数只有在按照读取的顺序的时候才会执行)，之所以提这个，是建议大家去看看，如何优美的实现在双向链表中将指定元素放入链尾！<br>void afterNodeRemoval(Node<K,V> p) { }<br>其作用就是在删除元素之后，将元素从双向链表中删除，还是非常建议大家去看看这个函数的，很优美的方式在双向链表中删除节点！<br>void afterNodeInsertion(boolean evict) { }<br>这个才是我们题目中会用到的，在插入新元素之后，<strong>需要回调函数判断是否需要移除一直不用的某些元素！</strong></p><p>所以我们直接继承linkedhashmap来解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer,Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer,Integer&gt; eldest)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size()&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接返回即可了</p><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>那我们就一直交换他们的指针应该就可以了，从尾部交换到头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution206A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.pre-&gt;cur</p><p>A.cur-&gt;cur.next</p><p>A.cur.next = pre</p><p>然后用<strong>头插法</strong>依次把节点 1,2,3 插到这个新链表的头部</p><p>1-&gt;2-&gt;3</p><p>2.next-&gt;1</p><p>2.pre-&gt;2</p><p>2.cur-&gt;3</p><p>3-&gt;2-&gt;1</p><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接排序，返回倒数第k个就完事</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>双指针</p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;x==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//跳过重复数组</span></span><br><span class="line">            <span class="keyword">if</span> (x+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]&gt;<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//没负数就别看了</span></span><br><span class="line">            <span class="keyword">if</span> (x+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//每个正数也不看了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span>  <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;k)&#123;</span><br><span class="line">                <span class="type">int</span> s= x+nums[j]+nums[k];</span><br><span class="line">                <span class="keyword">if</span> (s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.add(List.of(x, nums[j], nums[k]));</span><br><span class="line">                    <span class="keyword">for</span> (j++;j&lt;k&amp;&amp;nums[j]==nums[j-<span class="number">1</span>];j++);<span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">for</span> (k--;k&gt;j&amp;&amp;nums[k]==nums[k+<span class="number">1</span>];k--);<span class="comment">//去重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个进行优化和提前去观察的双指针方法，提前看最大的能不能实现，还有最小的情况能不能符合.</p><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur!=<span class="literal">null</span>;cur =cur.next)&#123;</span><br><span class="line">            n++;<span class="comment">//计数器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head),preHead = dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = head;</span><br><span class="line">        <span class="keyword">for</span> (;n&gt;=k;n-=k)&#123;<span class="comment">//重复n-k次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">                <span class="type">ListNode</span>  <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre =cur;</span><br><span class="line">                cur  = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> preHead.next;<span class="comment">//反转区间的结尾</span></span><br><span class="line">            tail.next = cur;<span class="comment">//下个区间</span></span><br><span class="line">            preHead.next = pre;<span class="comment">//区间的新head</span></span><br><span class="line">            preHead = tail;<span class="comment">//到达结尾进行下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>分组循环</p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution53A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum +=x;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum = x;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的去解决，如果和为正数的话，就继续去加数。不是的话，就从当前这个数开始重新计算</p><p>也有点分组循环的意思了哈哈</p><h2 id="手撕快速排序"><a href="#手撕快速排序" class="headerlink" title="手撕快速排序"></a>手撕快速排序</h2><p>快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution912</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right-left&lt;=INSERTION_SORT_THRESHOLD)&#123;</span><br><span class="line">            insertSort(nums,left,right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> partition(nums,left,right);</span><br><span class="line">        quickSort(nums,left,pIndex-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,pIndex+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;left&amp;&amp;nums[j-<span class="number">1</span>]&gt;tmp)&#123;</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left+RANDOM.nextInt(right-left+<span class="number">1</span>);</span><br><span class="line">        swap(nums,randomIndex,left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (gt &gt; left &amp;&amp; nums[gt] &gt; pivot) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lt &gt;= gt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 细节：相等的元素通过交换，等概率分到数组的两边</span></span><br><span class="line">            swap(nums, lt, gt);</span><br><span class="line">            lt++;</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, gt);</span><br><span class="line">        <span class="keyword">return</span> gt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点难了😓</p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span>) <span class="keyword">return</span> list2; <span class="comment">// 注：如果都为空则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="literal">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空的话就返回另一个的链表</p><p>如果l1的值小于l2的话，递归调用的链表接l1之后。反之一样</p><p>然后返回当前节点</p><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> expend(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> expend(s,i,i);</span><br><span class="line">            res = res.length()&gt;s1.length()?res:s1;</span><br><span class="line">            res = res.length()&gt;s2.length()?res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">expend</span><span class="params">(String s,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;=<span class="number">0</span>&amp;&amp;r&lt;s.length()&amp;&amp;s.charAt(l)==s.charAt(r))&#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(l+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expend返回的是上一次合法回文的范围。然后慢慢扩大范围，s1为偶数回文</p><p>s2为奇数回文</p><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution102A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue   = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>level为当前的层数，n为当前层数的所有节点数</p><p>然后使用bfs进步遍历，不为空，就加入队列遍历</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>hashmap</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用hash表解决，在map里有target-nums[i]的数，就新建数组</p><p>然后放入nums[i]，没有就扔出异常</p><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>二分查找</p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> target&gt;end&amp;&amp;x&gt;=target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target&gt;end||x&gt;=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums,target,mid))&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right]==target?right:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用二分查找</p><p>把某个数 <em>x</em> 与最后一个数 <em>nums</em>[<em>n</em>−1] 比大小</p><p>如果x&gt;nums[n-1]的话</p><p>nums一定被旋转分为左右两个递增的，就是前面的一段移动到后面来了</p><p>然后前面的大于后面的</p><p>x还在第一段</p><p>反之，x&lt;=nums[n-1]就说明x在第二段</p><p>或者他就是递增数组</p><p>根据这个写我们的check函数，来确定x的范围，好让我们进行二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> target&gt;end&amp;&amp;x&gt;=target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target&gt;end||x&gt;=target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p>bfs</p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution200</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=grid.length||j&lt;<span class="number">0</span>||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是遍历这整个矩阵，然后如果是1就count++;</p><p>然后把通过的改为2，防止重复遍历</p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p>回溯法</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, path, onPath, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; path, <span class="type">boolean</span>[] onPath, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (onPath[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            onPath[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(nums, path, onPath, ans);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            onPath[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>onPath用来放这个j有没有使用</p><p>path为路径，就是数组，长度全了的话，就给他加入到答案中</p><p>然后遍历，进入路径，设为匹配，dfs后，再恢复</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1&gt;=<span class="number">0</span>&amp;&amp;nums1[p1]&gt;nums2[p2])&#123;</span><br><span class="line">                nums1[p--] = nums1[p1--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[p--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的交换，谁大谁在后面</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>栈</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution20</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()||c!=stack.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用栈的思想，有左的话，就把右边的入栈</p><p>或者空了，或者是所不对应的时候，返回fasle</p><p>然后最后看是不是空</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution121</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE,profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p:prices)&#123;</span><br><span class="line">            cost = Math.min(cost,p);</span><br><span class="line">            profit = Math.max(profit,p-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>easy题目</p><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> List.of();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                vals.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.size()%<span class="number">2</span>&gt;<span class="number">0</span>) Collections.reverse(vals);</span><br><span class="line">            ans.add(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看到这种层序遍历，我们首先想到使用bfs，然后层序遍历，先遍历left,然后遍历right</p><p>之前的代码跟层序遍历差不多，只不过，他要形成锯齿状，奇数层就要反转。即就是下面的代码</p><p>刚刚前面判断写的有点麻烦了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>) q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                vals.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.size()%<span class="number">2</span>&gt;<span class="number">0</span>) Collections.reverse(vals);</span><br><span class="line">            ans.add(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更正一下</p><blockquote><p>联系102二叉树的层序遍历</p></blockquote><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution236</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==q||root==p) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是有啥就返回啥，没有就返回另一半，都没有就返回root</p><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution141</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个环形，也就是说是快慢指针碰到一块了就是一个环</p><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution92</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;left-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            p0= p0.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> p0.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur= next;</span><br><span class="line">        &#125;</span><br><span class="line">        p0.next.next = cur;</span><br><span class="line">        p0.next = pre;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似 leetcode25,206</p></blockquote><p>反转需要注意的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur= next;</span><br></pre></td></tr></table></figure><p>反转后在原来的链表上看，pre指向反转一段的末尾，</p><p>cur指向反转一段后续的下一个节点</p><p>然后修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p0.next.next = cur;</span><br><span class="line">        p0.next = pre;</span><br><span class="line">        return dummy.next;</span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution54A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>,r = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>,b = matrix.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r&amp;&amp;t&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;i&lt;=r;i++) res.add(matrix[t][i]);</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>t;i&lt;=b;i++) res.add(matrix[i][r]);</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;r) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=r;i&gt;=l;i--) res.add(matrix[b][i]);</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>b;i&gt;=t;i--) res.add(matrix[i][l]);</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个遍历的问题，从左到右，从上到下，然后从右到左，再从下到上</p><p>然后循环，主要是边界也要跟着移动</p><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution300</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span><span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;res[k])&#123;</span><br><span class="line">                res[++k] = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (res[j]&gt;=nums[i])&#123;</span><br><span class="line">                    res[j] =nums[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先遍历出来个递增的数组</p><p>如果不是的话，从0-k中找一个别的数，来贪心替换</p><p>最后k+1就是有效的长度</p><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span>  lists.length;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;step&lt;m;step*=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m-step;i+=step*<span class="number">2</span>)&#123;</span><br><span class="line">                lists[i] =  meryTwoLists(lists[i],lists[i+step]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">meryTwoLists</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="literal">null</span>&amp;&amp;list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val&lt;list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1!=<span class="literal">null</span>?list1:list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的函数时按大小来合并链表的</p><p>每次将间隔为 <code>step</code> 的链表合并成一个新链表</p><p>然后要满足所有，可以合并一道二，二到四，四道八这样一点一点的递归下去</p><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution143</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next!=<span class="literal">null</span>&amp;&amp;fast.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow =slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        ListNode l1_temp;</span><br><span class="line">        ListNode l2_temp;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">null</span>&amp;&amp;l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            l1_temp = l1.next;</span><br><span class="line">            l2_temp = l2.next;</span><br><span class="line"></span><br><span class="line">            l1.next = l2;</span><br><span class="line">            l1 = l1_temp;</span><br><span class="line"></span><br><span class="line">            l2.next = l1;</span><br><span class="line">            l2 = l2_temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span>head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        mergeList(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这个题目可以进行拆分，主要是分为三步</p><p>先是找到中间点，然后按照中间点分开，然后后面的链表反转，然后跟前面的链表合并</p><p>所以我们需要写三个函数，和一个主函数</p><p>找到中间点的方法就是</p><p>一个快指针，一个慢指针。然后快指针到尾部了。慢指针的位置就是中间点</p><p>反转链表不必多说：</p><p>next = cur.next</p><p>cur.next = pre;</p><p>pre = cur;</p><p>cur =next;</p><p>然后合并链表，就是先加l1的头，然后再加l2的头这样</p><p>l1tmp  = l1.next;</p><p>l2tmp = l2.next;</p><p>l1.next = l2;</p><p>l1 = l1tmp</p><p>l2.next = l1;</p><p>l2 = l2tmp</p><p>然后完成。</p><p>我自己想的思路是，我用双指针解决，找一个新的链表，然后先是左指针的节点加入，然后再加入右指针，然后左右指针都移动，一次类推，然后到左右指针相遇的时候，加入最后的节点。这个思路。但是这样的时间复杂度是o(n)不太符合哭。</p><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式</p><p>既然他不让直接进行计算器算的话，那我们去模拟计算器</p><p>从每个数的结尾去计算，如果进位的话，就加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  num1.length()-<span class="number">1</span>, j = num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            res.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后这里使用的stringBuilder用来操作字符串是非常好的，因为字符串String是final不能修改值</p><p>但是stringbuilder和stringbuffer是可以的。其中stringbuilder是单线程的</p><p>stringbuffer是多线程，是线程安全的。</p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution56A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals)&#123;</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>]-q[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是先按左端点排序，然后这样就可以清楚合并的顺序</p><p>如果ans的大小大于0，然后p的左端点要小于ans最后一个的右端点的话</p><p>那就可以合并</p><p>然后更新右端点，更新为p的右端点ans最后一个的右端点</p><p>如果不是的话，就把这个数组加进入来</p><p>然后最后将ans转为ans.size大小的数组</p><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution160</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA,B=headB;</span><br><span class="line">        <span class="keyword">while</span> (A!=B)&#123;</span><br><span class="line">            A=(A!=<span class="literal">null</span>)?A.next:headB;</span><br><span class="line">            B=(B!=<span class="literal">null</span>)?B.next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种情况</p><p>一个是B走的快吧，B走到null了，然后A处在的位置就是首个公共节点</p><p>为空了就给他赋值为headA,然后让他从A走</p><p>A为空了就赋值为headB让他从B走，然后他们相遇的地方就是公共节点</p><p>实际上就是A遍历完headA再遍历headB；B反之；这样就相当于走了同样的距离，也就是两次循环找到交点</p><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>就是使用双指针，记录中间夹的地方能记录多少雨水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preMax= <span class="number">0</span>,SubMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(height[left],preMax);</span><br><span class="line">            SubMax = Math.max(height[right],SubMax);</span><br><span class="line">            ans +=preMax&lt;SubMax?preMax-height[left++]:SubMax-height[right--];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个记录左边，一个记录右边</p><p>先记录左边这个小的，就是哪个小先记录哪个</p><p>然后指针移动</p><p>更新最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preMax= <span class="number">0</span>,SubMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(height[left],preMax);</span><br><span class="line">            SubMax = Math.max(height[right],SubMax);</span><br><span class="line">            ans +=preMax&lt;SubMax?preMax-height[left++]:SubMax-height[right--];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapA</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>,peak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peak)&#123;</span><br><span class="line">                peak = height[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peakInterL</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peakInterL)&#123;</span><br><span class="line">                peakInterL = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=(peakInterL-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peakInterR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length-<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peakInterR)&#123;</span><br><span class="line">                peakInterR = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=(peakInterR-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个二次遍历</p><h2 id="72-编辑距离-x"><a href="#72-编辑距离-x" class="headerlink" title="72. 编辑距离(x)"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a>(x)</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution124</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">LVal</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">RVal</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line">        ans  = Math.max(ans,LVal+RVal+node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(LVal,RVal)+node.val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选择使用左或者右大的哪个，然后最后返回走过的路径，然后记录ans；</p><p>最后返回。</p><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        ListNode fast= head,slow  =head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果快慢指针相遇的话，说明有环，然后快指针再从头开始，快慢指针第二次相遇的地方，就是开始入环的第一个节点</p><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution93</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; segments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;<span class="number">4</span>||s.length()&gt;<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s,<span class="number">0</span>,segments);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s,<span class="type">int</span> index,List&lt;String&gt; segments)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segments.size()==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index==s.length())&#123;</span><br><span class="line">                ans.add(String.join(<span class="string">&quot;.&quot;</span>,segments));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;len&lt;=<span class="number">3</span>;len++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index+len&gt;s.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">segment</span> <span class="operator">=</span> s.substring(index,index+len);</span><br><span class="line">            <span class="keyword">if</span> (isValid(segment)) &#123;</span><br><span class="line">                segments.add(segment);</span><br><span class="line">                dfs(s, index + len, segments);</span><br><span class="line">                segments.remove(segments.size() - <span class="number">1</span>);  <span class="comment">//恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String segment)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segment.length() &gt; <span class="number">1</span> &amp;&amp; segment.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(segment);</span><br><span class="line">        <span class="keyword">return</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回溯算法，主要是要符合ip地址的规则</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JAVA设计面试题目hot</title>
      <link>https://blog.tokenlen.top/2025/05/27/java-stack/javasample1/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/java-stack/javasample1/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;Controller&quot;&gt;&lt;a href=&quot;#Controller&quot; class=&quot;headerlink&quot; title=&quot;Controller&quot;&gt;&lt;/a&gt;Controller&lt;/h1&gt;&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><h2 id="1-写一个简单的登录接口的Controller，包含用户ID和密码字段。"><a href="#1-写一个简单的登录接口的Controller，包含用户ID和密码字段。" class="headerlink" title="1.写一个简单的登录接口的Controller，包含用户ID和密码字段。"></a>1.写一个简单的登录接口的Controller，包含用户ID和密码字段。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUserId(request.getUserId());</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!user.getPassword().equals(request.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟生成 JWT（可替换为真实生成）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createToken(user.getId().toString(), <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 10分钟有效</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; response = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        response.put(<span class="string">&quot;accessToken&quot;</span>, token);</span><br><span class="line">        response.put(<span class="string">&quot;userId&quot;</span>, user.getId());</span><br><span class="line">        response.put(<span class="string">&quot;username&quot;</span>, user.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findByUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟查库</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(userId)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setId(<span class="number">1L</span>);</span><br><span class="line">            user.setUserId(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            user.setUsername(<span class="string">&quot;管理员&quot;</span>);</span><br><span class="line">            user.setPassword(<span class="string">&quot;123456&quot;</span>); <span class="comment">// 明文密码仅用于演示</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-对于POST请求，你是直接用参数接收，还是封装成对象接收？"><a href="#2-对于POST请求，你是直接用参数接收，还是封装成对象接收？" class="headerlink" title="2.对于POST请求，你是直接用参数接收，还是封装成对象接收？"></a>2.对于POST请求，你是直接用参数接收，还是封装成对象接收？</h2><p>封装成对象来接受。</p><p>在开发中，对于 POST 请求，我更倾向于使用 <code>@RequestBody</code> 将参数封装成对象。这种方式更清晰、可维护，也方便进行参数校验和自动生成 Swagger 文档。如果参数较少、是简单的表单提交，偶尔也可以用 <code>@RequestParam</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> request.getUserId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getPassword();</span><br><span class="line">    <span class="comment">// 登录逻辑...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装成类，参数多的时候，不宜混乱，方便扩展，新增字段的时候，不用改方法签名，支持验证注解，如 <code>@NotBlank</code>、<code>@Size</code> 直接加在类字段上。更加适合Swagger自动文档，自动识别请求结构。</p><p>不封装的话，参数签名越来越长，而且无法处理 <code>application/json</code> 请求。不能队单个字段加验证规则。</p><h2 id="3-你在工作中是如何进行参数非空校验的？"><a href="#3-你在工作中是如何进行参数非空校验的？" class="headerlink" title="3.你在工作中是如何进行参数非空校验的？"></a>3.你在工作中是如何进行参数非空校验的？</h2><p>在工作中，我会根据具体场景，在 <strong>三个层次</strong> 对参数进行非空校验：</p><ol><li><strong>前端校验</strong>：前端通过 JS 或组件校验框架（如 Element Plus 表单校验、AntD Rule）来做第一层参数合法性校验，提升用户体验。</li><li><strong>后端控制层校验（推荐）</strong>：使用 Spring 的 <code>javax.validation</code> 注解（如 <code>@NotBlank</code>、<code>@NotNull</code>、<code>@Size</code>）结合 <code>@Valid</code> 实现自动参数校验，<strong>统一异常处理</strong>返回提示。</li><li><strong>业务逻辑校验（服务层）</strong>：对关键参数进行业务校验（如账号是否存在、密码是否为空、两个字段不能同时为空等），保证逻辑正确性。</li></ol><p>controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">    <span class="comment">// 如果参数校验失败，会自动抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> authService.login(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DTO+注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleValidationException(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ex.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(Map.of(<span class="string">&quot;error&quot;</span>, msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还封装了统一的 <code>BaseRequest</code> 类 + 参数校验通用注解，配合全局异常返回标准化的错误结构，做到接口友好、开发高效。</p><p>BaseRequest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseRequest</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;请求时间戳不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;请求来源不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String source; <span class="comment">// web / app / admin 等</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;签名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sign;   <span class="comment">// 用于简单签名校验</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> <span class="keyword">extends</span> <span class="title class_">BaseRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Controller 中使用 <code>@Valid</code> 接收参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">    <span class="comment">// 校验通过，执行业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> authService.login(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局异常处理返回统一格式（如 <code>Result&lt;T&gt;</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">200</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; error(String message) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">400</span>, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数校验统一异常处理（<code>@ControllerAdvice</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&lt;?&gt;&gt; handleValidation(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ex.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(Result.error(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他通用异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们项目里统一封装了请求基类 <code>BaseRequest</code>，每个接口请求都包含 timestamp、source、sign 等字段，同时结合 Spring 的 <code>@Valid</code> 和自定义的通用注解进行字段校验，配合统一异常处理类，返回格式统一成 <code>Result&lt;T&gt;</code>。这样接口文档清晰、调试方便、前后端联调效率高，开发体验提升很多。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><div class="table-container"><table><thead><tr><th>分类</th><th>模式</th><th>作用</th><th>示例关键点</th></tr></thead><tbody><tr><td>创建型</td><td>单例模式</td><td>保证全局只有一个实例</td><td>Spring 中的 Bean 默认就是单例</td></tr><tr><td>创建型</td><td>工厂模式</td><td>统一创建对象</td><td>数据库连接、策略类</td></tr><tr><td>结构型</td><td>代理模式</td><td>给目标对象增加额外功能</td><td>Spring AOP、事务、日志</td></tr><tr><td>结构型</td><td>装饰器模式</td><td>动态扩展对象功能</td><td>IO 流、过滤器链</td></tr><tr><td>行为型</td><td>策略模式</td><td>可切换的行为算法</td><td>支付、消息推送</td></tr><tr><td>行为型</td><td>观察者模式</td><td>发布/订阅事件通知</td><td>MQ、事件监听</td></tr><tr><td>行为型</td><td>模板方法</td><td>固定流程 + 可变步骤</td><td>抽象 Controller、登录流程</td></tr><tr><td>行为型</td><td>责任链模式</td><td>多个处理器依次处理</td><td>过滤器链、权限认证</td></tr><tr><td>行为型</td><td>状态模式</td><td>对象状态驱动行为</td><td>订单、任务状态</td></tr><tr><td>行为型</td><td>命令模式</td><td>把操作封装成对象</td><td>任务撤销、限流操作命令</td></tr></tbody></table></div><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>确保一个类在整个应用中 <strong>只有一个实例</strong>，并提供一个全局访问点。</p><ul><li>Redis 工具类、线程池、连接池、配置类等</li><li>Spring 默认是单例 Bean（IOC 控制）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 防止指令重排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于volatile和synchronized</p><p><code>volatile</code>：防止 JVM 指令重排序，确保实例初始化完成后再赋值。</p><p>双重校验：第一次 if 避免每次加锁，第二次 if 避免并发重复创建。</p><p>比如Calendar:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>比如 Logger：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = Logger.getLogger(MyClass.class.getName());</span><br></pre></td></tr></table></figure><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>根据不同类型 <strong>生成不同实现类实例</strong>，解耦对象创建过程。</p><ul><li><p>根据类型创建支付处理器、登录方式、导出类型等</p></li><li><p>创建支付方式（支付宝、微信）</p><p>创建导出服务（Excel、PDF）</p><p>登录策略、文件解析等类型多变组件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExportService <span class="title function_">getExport</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;excel&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExcelExportService</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不支持的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ExportService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">export</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExcelExportService</span> <span class="keyword">implements</span> <span class="title class_">ExportService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出Excel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合接口隔离 + 枚举注册</p><p>通过工厂类封装创建逻辑</p><p>返回的是接口类型，利于扩展和解耦</p><p>结合枚举或配置可实现<strong>注册式工厂</strong></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义一系列算法（策略），并使它们可以相互替换。<strong>将行为与选择解耦</strong>。</p><p>多种支付方式、登录方式、审核策略等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayContext</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,PayStrategy&gt; paymap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dopay</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="type">PayStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> paymap.get(type);</span><br><span class="line">        <span class="keyword">if</span> (strategy!=<span class="literal">null</span>) strategy.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">PayStrategy</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component(&quot;aliPay&quot;)</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">implements</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component(&quot;wechatPay&quot;)</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">WeChatPay</span> <span class="keyword">implements</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;微信支付&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用 Spring 容器自动注入所有策略 Bean</p><p>根据 key 获取策略执行对应逻辑，避免写死 if-else 或 switch</p><p>和工厂模式的最大区别是：<strong>策略封装行为，工厂封装创建</strong></p><p>面试题目：设计模式场景题：比如现在有支付宝、微信、各大银行卡等支付方式，最坏的情况是写了20多个if-else判断是用户选择哪种支付方式，耦合度很高，如果叫你优化，你怎么想？</p><p>我们可以使用策略模式，先封装一个支付的接口，然后把每个支付的方式分装成类，然后用一个map集合或者是工厂类来让用户选择具体的是哪个支付方式，这样就避免了大量使用if-else。</p><p>需要一个接口，然后具体的实现类，然后一个工厂类，使用map简化策略选择。还有一个策略的上下文类</p><p>然后客户端调用上下文类（里面是工厂实例），然后选择支付金额。这里的支付金额要使用BigDecimal</p><p>因为 <code>double</code> 是<strong>二进制浮点数</strong>，在进行运算时会出现<strong>精度误差</strong></p><p>使用BigDecimal <strong>基于字符串表示的小数类</strong>，可以实现精确计算，避免金额误差，防止“丢钱”或“多扣”的风险。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在不修改目标类的情况下，<strong>增强其功能（如日志、权限、事务等）</strong></p><p>日志、权限、事务控制、接口限流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.mengnankk.designpattern.Log)&quot;)</span> <span class="comment">// 指定注解全路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint point)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法：&quot;</span> + point.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AOP 本质是动态代理（JDK 或 CGLIB）</p><p>利用切点表达式 <code>@annotation</code> 定位目标方法</p><p>增强功能通过切面类编织</p><h2 id="修饰器模式"><a href="#修饰器模式" class="headerlink" title="修饰器模式"></a>修饰器模式</h2><p>在不修改原始对象的情况下，<strong>动态增强其功能</strong>（与代理很像，区别是包装对象）</p><p>请求/响应增强处理、日志追加处理、加密/解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestLogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化逻辑（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录请求日志&quot;</span>);</span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 资源释放逻辑（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类似代理，但更偏向“嵌套增强”</p><p>典型用法是 <strong>Filter、Interceptor</strong>，形成处理链</p><p>可以组合多个修饰器链式增强</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>配器模式</strong>像是“插头转换器”，让两个原本不兼容的接口连接上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String type, String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playAudio</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;播放音频：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioAdapter</span> <span class="keyword">implements</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">OldPlayer</span> <span class="variable">oldPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OldPlayer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String type, String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;mp3&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            oldPlayer.playAudio(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>维度</th><th>代理模式</th><th>适配器模式</th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>控制访问目标对象，添加附加逻辑</td><td>接口不兼容时进行适配</td></tr><tr><td><strong>原始类</strong></td><td>与代理类实现同一接口</td><td>与目标接口<strong>无关</strong>，通过包装“适配”</td></tr><tr><td><strong>使用时机</strong></td><td>不想或不能直接访问目标对象，增加功能（如远程调用、权限）</td><td>复用已有类但其接口不符合当前系统要求</td></tr><tr><td><strong>是否增强</strong></td><td>是，可以添加前置/后置逻辑</td><td>否，仅做接口适配</td></tr></tbody></table></div><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法，比如说有三个模板方法A、B、C，第一个子类我想让他实现ABC这么执行，第二个子类我想让他实现ACB，这个怎么实现？（使用“钩子方法”，抽离一个方法返回true、false，true就ABC，false就ACB）</p><p><strong>模板方法模式</strong> + <strong>钩子方法（Hook）自定义流程控制</strong>。</p><p>在抽象类中定义整体流程 A → B → C，然后用<strong>钩子方法来控制流程顺序</strong>：</p><ul><li>抽象类中定义 <code>template()</code> 模板方法</li><li><code>A()</code> 和 <code>C()</code> 是固定流程</li><li><code>B()</code> 是可选的</li><li>使用 <code>shouldDoB()</code> 钩子方法（返回 true/false）来决定执行顺序，是 ABC 还是 ACB</li></ul><p>定义抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        A();</span><br><span class="line">        <span class="keyword">if</span> (shouldDoBFirst()) &#123;</span><br><span class="line">            B();</span><br><span class="line">            C();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            C();</span><br><span class="line">            B();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法，默认返回 true，即执行 ABC</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldDoBFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类去继承这个抽象类，然后重写父类的方法shouldDoBFirst,按照需求重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstChild</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;C&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldDoBFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 默认就是 ABC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="java扩展"><a href="#java扩展" class="headerlink" title="java扩展"></a>java扩展</h1><h2 id="1-同步和异步的区别是什么？"><a href="#1-同步和异步的区别是什么？" class="headerlink" title="1.同步和异步的区别是什么？"></a>1.同步和异步的区别是什么？</h2><p><strong>同步（Synchronous）和异步（Asynchronous）</strong> 是两种不同的任务执行方式，主要区别在于任务的执行是否需要等待其他任务完成。</p><p>同步的话是需要等待任务完成之后，收到返回的确认请求的时候再进行其他的</p><p>异步的话，就是不需要等待，直接进行下一步任务</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/java-stack/javasample1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode动态规划</title>
      <link>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;爬楼梯&quot;&gt;&lt;a href=&quot;#爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;爬楼梯&quot;&gt;&lt;/a&gt;爬楼梯&lt;/h1&gt;&lt;h2 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70.</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>按着数学来看的话，就是如果是1阶梯的话，就是1</p><p>大于等于2的有两种，是i-1+(i-2)</p><p>然后我们使用记忆数组来记忆之前算过的</p><p>然后使用递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution70A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo  = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>  (memo[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = dfs(i-<span class="number">1</span>,memo)+dfs(i-<span class="number">2</span>,memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到记忆数组不是1的，调用记忆数组，为0的就直接计算</p><p>这样就不会超时</p><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution746</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span> [] memo = <span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(n,memo,cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span>[] memo,<span class="type">int</span>[] cost)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> dfs(i-<span class="number">1</span>,memo,cost)+cost[i-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> dfs(i-<span class="number">2</span>,memo,cost)+cost[i-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> memo[i] = Math.min(res2,res1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面那个题一样，只不过最后取的时候，是看花费哪个少了</p><h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>本质还是爬楼梯问题啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution377</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(target,nums,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] nums,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;=i)&#123;</span><br><span class="line">                res +=dfs(i-x,nums,memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i]  = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是类似的</p><h2 id="2466-统计构造好字符串的方案数"><a href="#2466-统计构造好字符串的方案数" class="headerlink" title="2466. 统计构造好字符串的方案数"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 统计构造好字符串的方案数</a></h2><p>给你整数 <code>zero</code> ，<code>one</code> ，<code>low</code> 和 <code>high</code> ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p><ul><li>将 <code>&#39;0&#39;</code> 在字符串末尾添加 <code>zero</code> 次。</li><li>将 <code>&#39;1&#39;</code> 在字符串末尾添加 <code>one</code> 次。</li></ul><p>以上操作可以执行任意次。</p><p>如果通过以上过程得到一个 <strong>长度</strong> 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <strong>好</strong> 字符串。</p><p>请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2466</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span>[high+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=zero) f[i] = f[i-zero];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=one) f[i] = (f[i]+f[i-one])%MOD;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=low) ans = (ans+f[i])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递推</p><p>相当于把递推式 <em>f</em>[<em>i</em>]=<em>f</em>[<em>i</em>−<em>zero</em>]+<em>f</em>[<em>i</em>−<em>one</em>] 拆分成了两步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[high + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>); <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) &#123;</span><br><span class="line">            ans = (ans + dfs(i, zero, one, memo)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> zero, <span class="type">int</span> one, <span class="type">int</span>[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = (dfs(i - zero, zero, one, memo) + dfs(i - one, zero, one, memo)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记忆递推方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>crmeb商城分析</title>
      <link>https://blog.tokenlen.top/2025/05/27/workmenu/crmeb/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/workmenu/crmeb/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;从整体分析这个项目&lt;/p&gt;
&lt;p&gt;然后加入一些别的项目的通用的知识&lt;/p&gt;
&lt;p&gt;其他项目加入的：：：&lt;/p&gt;
&lt;h1 id=&quot;亮点&quot;&gt;&lt;a href=&quot;#亮点&quot; class=&quot;headerlink&quot; title=&quot;亮点&quot;&gt;&lt;/a&gt;亮点&lt;/h1&gt;&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>从整体分析这个项目</p><p>然后加入一些别的项目的通用的知识</p><p>其他项目加入的：：：</p><h1 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h1><h2 id="身份认证与权限校验"><a href="#身份认证与权限校验" class="headerlink" title="身份认证与权限校验"></a>身份认证与权限校验</h2><p>使用令牌技术实现身份验证，用自定栏截器完成用户认证，并结合 ThreadLocal进行截器校验，保障系统安全访间。</p><p><strong>基于Spring Boot + JWT的完整身份认证示例</strong>，包含：</p><ul><li>JWT生成和解析工具类</li><li>认证拦截器（拦截请求验证JWT）</li><li>ThreadLocal存储当前用户信息</li><li>配置拦截器注册</li><li>简单的用户控制器示例</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>注册：提交用户名/密码，后台保存（通常密码要哈希存储），返回注册成功信息。</p><p>登录：提交用户名/密码，校验通过后生成 JWT Token，返回给客户端。、</p><p>访问：客户端在请求头 <code>Authorization: Bearer &lt;token&gt;</code> 中携带 JWT</p><p>自定义拦截器拦截请求，验证 JWT，有效则将解析后的用户信息存入 <code>ThreadLocal</code></p><p>Controller 业务方法中可直接从 <code>ThreadLocal</code> 取出当前用户信息</p><p>登出/过期：JWT 自带过期时间，无需服务器状态维护；或配合黑名单实现主动失效。</p><h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><h4 id="1-JWT的组成"><a href="#1-JWT的组成" class="headerlink" title="1.JWT的组成"></a>1.JWT的组成</h4><p>Header（头部）:描述签名的元数据，包含alg(签名算法) HS256，RS256,typ(令牌的类型)通常为JWT，base64URL编码作为一个片段</p><p>Payload：存放业务数据和标准声明（Claims），</p><p><strong>RFC定义</strong>：<code>iss</code>（签发者）、<code>sub</code>（主题）、<code>aud</code>（受众）、<code>exp</code>（过期时间）、<code>iat</code>（签发时间）</p><p><strong>Public Claims</strong>：用户自定义，但要避免冲突</p><p><strong>Private Claims</strong>：双方约定的自定义字段（如 <code>userId</code>、<code>roles</code>）</p><p>Signature（签名）：</p><p>用 <code>Base64Url(Header) + &quot;.&quot; + Base64Url(Payload)</code>，再加上密钥，通过指定算法（如 HMAC SHA256）计算得到。</p><p>防止数据被篡改：接收方用<strong>相同算法和密钥校验签名</strong>。</p><h4 id="2-为什么要设置-exp，以及如何处理过期？"><a href="#2-为什么要设置-exp，以及如何处理过期？" class="headerlink" title="2.为什么要设置 exp，以及如何处理过期？"></a>2.为什么要设置 <code>exp</code>，以及如何处理过期？</h4><p>限制令牌的有效期，降低泄露后滥用风险，强制客户端<strong>定期获取新令牌</strong>，有助于权限变更及时生效。</p><p>自动处理过期：</p><p><strong>自动拒绝</strong>：在解析 JWT 时，库（如 jjwt）会抛出 <code>ExpiredJwtException</code>，拦截器／过滤器捕获后返回 <code>401 Unauthorized</code>。</p><p><strong>Refresh Token</strong> 机制：</p><p>Access Token（短时有效）+ Refresh Token（长期有效且存放更安全）</p><p>Access Token 过期后，客户端用 Refresh Token 向专门接口换取新的 Access Token。</p><p><strong>服务端黑名单</strong>：对关键场景，可在 Redis 等存储过期或手动废弃的 Token ID 列表，拦截时进一步比对。</p><h3 id="3-对称加密（HS256）与非对称加密（RS256）的区别？"><a href="#3-对称加密（HS256）与非对称加密（RS256）的区别？" class="headerlink" title="3.对称加密（HS256）与非对称加密（RS256）的区别？"></a>3.对称加密（HS256）与非对称加密（RS256）的区别？</h3><div class="table-container"><table><thead><tr><th>特性</th><th>HS256（对称）</th><th>RS256（非对称）</th></tr></thead><tbody><tr><td><strong>密钥</strong></td><td>同一个密钥用于签名和校验</td><td>使用私钥签名，公钥校验</td></tr><tr><td><strong>安全性</strong></td><td>只要共享密钥不会泄露；多服务时需安全分发密钥</td><td>私钥只在签发端保存，公钥可公开，泄露风险低</td></tr><tr><td><strong>性能</strong></td><td>HMAC 速度快</td><td>RSA 运算相对慢一些</td></tr><tr><td><strong>应用场景</strong></td><td>小规模或单体应用，部署简单</td><td>分布式/微服务或第三方验证场景，私钥保护更好</td></tr></tbody></table></div><h3 id="4-HandlerInterceptor-与-Filter-的区别？"><a href="#4-HandlerInterceptor-与-Filter-的区别？" class="headerlink" title="4.HandlerInterceptor 与 Filter 的区别？"></a>4.<code>HandlerInterceptor</code> 与 <code>Filter</code> 的区别？</h3><div class="table-container"><table><thead><tr><th>方面</th><th>Filter</th><th>HandlerInterceptor</th></tr></thead><tbody><tr><td><strong>加载时机</strong></td><td>最早，Servlet 容器启动时配置，位于 Spring MVC 之前</td><td>在 Spring MVC 内部，Controller 调用前后拦截</td></tr><tr><td><strong>接口</strong></td><td><code>javax.servlet.Filter</code></td><td><code>org.springframework.web.servlet.HandlerInterceptor</code></td></tr><tr><td><strong>职责</strong></td><td>通用请求预处理：如日志、跨域、请求包装、字符编码</td><td>更贴近 MVC：可以访问 Handler（Controller）信息，做方法级鉴权</td></tr><tr><td><strong>配置方式</strong></td><td><code>@WebFilter</code>、<code>FilterRegistrationBean</code> 等</td><td>实现 <code>WebMvcConfigurer#addInterceptors</code> 注册</td></tr><tr><td><strong>方法</strong></td><td><code>doFilter</code></td><td><code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code></td></tr></tbody></table></div><h3 id="5-如何配置某些路径放行？"><a href="#5-如何配置某些路径放行？" class="headerlink" title="5.如何配置某些路径放行？"></a>5.如何配置某些路径放行？</h3><p>比如我们让他不用登录就能看的一些页面，商品展示等等</p><p>在 Spring MVC 拦截器注册时，通过 <code>excludePathPatterns(...)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(jwtInterceptor)</span><br><span class="line">        .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>)           <span class="comment">// 拦截所有 /api/**</span></span><br><span class="line">        .excludePathPatterns(</span><br><span class="line">            <span class="string">&quot;/api/auth/**&quot;</span>,                  <span class="comment">// 放行认证相关</span></span><br><span class="line">            <span class="string">&quot;/swagger-ui/**&quot;</span>, <span class="string">&quot;/v3/api-docs&quot;</span>  <span class="comment">// 放行 Swagger</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>如果是 Filter，可在内部判断请求 URI，或在 <code>FilterRegistrationBean</code> 中设置 <code>setUrlPatterns</code> 与 <code>setOrder</code>。</p><h3 id="6-Spring-Boot-默认哪些静态资源路径？是否会被拦截？"><a href="#6-Spring-Boot-默认哪些静态资源路径？是否会被拦截？" class="headerlink" title="6.Spring Boot 默认哪些静态资源路径？是否会被拦截？"></a>6.Spring Boot 默认哪些静态资源路径？是否会被拦截？</h3><ul><li><strong>默认路径（classpath 下）</strong><ul><li><code>/static</code></li><li><code>/public</code></li><li><code>/resources</code></li><li><code>/META-INF/resources</code></li></ul></li><li><strong>是否被拦截？</strong><ul><li>Spring MVC 的拦截器默认只拦截 <code>/**</code>，但静态资源由 <code>ResourceHttpRequestHandler</code> 处理，优先级高于一般的 Controller 调用。</li><li><strong>如果</strong>在 <code>addInterceptors</code> 中使用了拦截所有 <code>/**</code>，且拦截匹配到静态资源路径，就有可能拦截；但通常我们会在 <code>excludePathPatterns(&quot;/**/*.js&quot;, &quot;/**/*.css&quot;, &quot;/**/*.png&quot;, ...&quot;)</code> 或直接排除静态资源目录，确保静态资源正常加载。</li></ul></li></ul><h3 id="7-为什么要在-afterCompletion-清理-ThreadLocal？"><a href="#7-为什么要在-afterCompletion-清理-ThreadLocal？" class="headerlink" title="7.为什么要在 afterCompletion 清理 ThreadLocal？"></a>7.为什么要在 <code>afterCompletion</code> 清理 <code>ThreadLocal</code>？</h3><p><code>ThreadLocal</code> 存储的数据与当前线程绑定。</p><p>在高并发环境下，使用线程池复用线程，如果不手动清理，后续请求可能读取到上一个用户的信息，导致<strong>数据泄露</strong>或<strong>安全漏洞</strong>。</p><p><code>afterCompletion</code> 保证在请求处理完毕后无论正常或异常，都能移除数据，防止内存泄露。</p><p>或者是如果不清理的话，因为是弱引用，ThreadLocal的key很容易被清理，其还有null的键，一直在那里呆着。所以要使用remove清理或者是，查找与当前线程关联的Map并将键值对设置为当前线程和null，Huoz是在finally中关闭ThreadLocal。</p><h3 id="8-并发场景下-ThreadLocal-的适用与限制？"><a href="#8-并发场景下-ThreadLocal-的适用与限制？" class="headerlink" title="8.并发场景下 ThreadLocal 的适用与限制？"></a>8.并发场景下 <code>ThreadLocal</code> 的适用与限制？</h3><p><strong>适用</strong>：</p><ul><li>存放与当前请求、当前<strong>线程强关联的数据</strong>（如用户上下文、事务 ID）</li><li>避免在方法间频繁传参</li></ul><p><strong>限制</strong>：</p><ul><li>必须在请求<strong>结束后清理</strong>，否则线程复用会导致“上下文串库”</li><li>不能跨线程（如异步执行、线程池任务）共享；如果在子线程里尝试取数据，需要显式传递或使用 <code>InheritableThreadLocal</code>（但要注意 GC 风险）</li><li>大量数据存放会增加内存压力</li></ul><p>或者是如果不清理的话，因为是弱引用，ThreadLocal的key很容易被清理，其还有null的键，一直在那里呆着。所以要使用remove清理或者是，查找与当前线程关联的Map并将键值对设置为当前线程和null，Huoz是在finally中关闭ThreadLocal。</p><h3 id="9-如何安全地存储用户密码？"><a href="#9-如何安全地存储用户密码？" class="headerlink" title="9.如何安全地存储用户密码？"></a>9.如何安全地存储用户密码？</h3><p><strong>一定要哈希</strong>，切忌明文存储。</p><p><strong>使用强单向哈希算法</strong>，推荐：</p><ul><li>BCrypt（Spring Security 默认支持）</li><li>Argon2、PBKDF2</li></ul><p><strong>加盐</strong>：每个用户使用<strong>独立随机盐</strong>，防止彩虹表攻击。</p><p><strong>适当迭代</strong>：增加计算成本，防止暴力破解。</p><h3 id="10-为什么不要把敏感信息（如密码）放到-JWT-里？"><a href="#10-为什么不要把敏感信息（如密码）放到-JWT-里？" class="headerlink" title="10.为什么不要把敏感信息（如密码）放到 JWT 里？"></a>10.为什么不要把敏感信息（如密码）放到 JWT 里？</h3><p><strong>JWT Payload 可被任意方 Base64Url 解码</strong>，不具备机密性。</p><p>即使<strong>签名防篡改</strong>，也无法防止任何人读取其中的明文数据。</p><p>应只放必要的非敏感标识（如 <code>userId</code>、<code>roles</code>），<strong>敏感数据应在后台按需查询</strong>。</p><h3 id="11-Token-在前端如何存储（localStorage-vs-HttpOnly-Cookie）？"><a href="#11-Token-在前端如何存储（localStorage-vs-HttpOnly-Cookie）？" class="headerlink" title="11.Token 在前端如何存储（localStorage vs HttpOnly Cookie）？"></a>11.Token 在前端如何存储（localStorage vs HttpOnly Cookie）？</h3><div class="table-container"><table><thead><tr><th>存储方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>localStorage</strong></td><td>简单易用，JS 可直接读写</td><td>易受 XSS 攻击：恶意脚本可读取并窃取 Token</td></tr><tr><td><strong>HttpOnly Cookie</strong></td><td>JS 无法读取，能自动随请求带上，防止 XSS</td><td>需防范 CSRF（可配合 SameSite、双重提交 Cookie）</td></tr></tbody></table></div><p><strong>最佳实践</strong>：</p><ul><li>推荐将 <strong>Access Token</strong> 存在 <strong>HttpOnly</strong>、Secure、SameSite=strict 的 Cookie 中；</li><li>如果仍需在 JS 中访问，可用 Refresh Token 短时写入 <code>localStorage</code>，但严格防 XSS。</li><li>同时配合 CSRF 令牌、CORS 白名单、内容安全策略（CSP）等。</li></ul><h2 id="技术升级-双重拦截器-双token"><a href="#技术升级-双重拦截器-双token" class="headerlink" title="技术升级-双重拦截器-双token"></a>技术升级-双重拦截器-双token</h2><p>介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">登录成功</span><br><span class="line">    ↓</span><br><span class="line">后端生成 Access Token（<span class="number">10</span>分钟） 和 Refresh Token（<span class="number">7</span>天）</span><br><span class="line">    ↓</span><br><span class="line">前端存储：</span><br><span class="line">    - Access Token（如内存/Store）</span><br><span class="line">    - Refresh Token（如 Cookie/LocalStorage）</span><br><span class="line">    ↓</span><br><span class="line">请求接口时携带 Access Token</span><br><span class="line">    ↓</span><br><span class="line">如果 Access Token 过期</span><br><span class="line">    ↓</span><br><span class="line">用 Refresh Token 向 refresh 接口获取新的 Access Token</span><br><span class="line">    ↓</span><br><span class="line">成功则自动重试原请求；失败则跳转登录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一级拦截器：JWT 认证拦截器（<code>AuthInterceptor</code>）</strong></p><p>提取请求头中的 <code>Authorization: Bearer &lt;token&gt;</code> 携带的是access token</p><p>解析 JWT 获取用户 ID（从 Payload 中解析出 <code>userId</code>）</p><p>校验签名、是否过期（<code>exp</code>）</p><p>若有效，查询用户信息并写入 <code>ThreadLocal</code></p><p>异常处理：</p><ul><li>无 Token、Token 无效或过期 → 返回 401 响应</li></ul><p><strong>二级拦截器：Token 刷新拦截器（<code>RefreshInterceptor</code>）</strong></p><ul><li>作用：<ul><li>检查 Token 是否临近过期（如距 <code>exp</code> 仅剩 5 分钟）或者是access token已经过期，返回401</li><li>去redis中查找refrush token，找到了就续签</li><li>重新生成 Token，并将其通过响应头或 Cookie 返回给前端</li><li>使用 <code>setHeader(&quot;Authorization&quot;, &quot;Bearer xxx&quot;)</code> 返回新 Token</li><li>然后重新尝试原请求</li></ul></li></ul><p><strong>用户信息存入 <code>ThreadLocal</code></strong></p><ul><li><code>UserHolder.set(userInfo)</code>：拦截器中将用户信息写入 ThreadLocal</li><li>Controller 中通过 <code>UserHolder.get()</code> 获取，无需每次查库（RT 从 200ms 降至 20ms）</li><li>在 <code>afterCompletion</code> 中清理 ThreadLocal，防止线程复用造成用户信息串用</li></ul><h3 id="问题解析-1"><a href="#问题解析-1" class="headerlink" title="问题解析"></a>问题解析</h3><h4 id="1-你们的认证机制是怎么做的？为什么用-JWT？"><a href="#1-你们的认证机制是怎么做的？为什么用-JWT？" class="headerlink" title="1.你们的认证机制是怎么做的？为什么用 JWT？"></a>1.<strong>你们的认证机制是怎么做的？为什么用 JWT？</strong></h4><p>前后端分离架构下使用 <strong>JWT 无状态令牌</strong>，用户登录后由服务端生成 Token，后续请求携带 Token 完成身份验证</p><p>与传统 Session 相比，JWT 不依赖服务端存储，<strong>更适合分布式微服务场景</strong></p><p>签名机制可防止 Token 被伪造，Payload 可携带 <code>userId</code> 等信息减少数据库查询</p><h4 id="2-如何设计-Token-刷新机制？"><a href="#2-如何设计-Token-刷新机制？" class="headerlink" title="2.如何设计 Token 刷新机制？"></a>2.如何设计 Token 刷新机制？</h4><p>在拦截器中检查 Token 剩余有效时间</p><p>当 Token 临近过期（例如剩余 &lt;5 分钟）时，<strong>自动生成新 Token 并通过响应头或 Cookie 返回</strong></p><p>提高用户体验，避免频繁重新登录</p><p>可配合 Refresh Token 强化安全性</p><h4 id="3-为什么使用-ThreadLocal？是否存在线程安全问题？"><a href="#3-为什么使用-ThreadLocal？是否存在线程安全问题？" class="headerlink" title="3.为什么使用 ThreadLocal？是否存在线程安全问题？"></a>3.为什么使用 ThreadLocal？是否存在线程安全问题？</h4><p>ThreadLocal 将<strong>用户信息与线程</strong>绑定，避免在每个方法中重复查询、传参，减少数据库/Redis 压力</p><p>在 Controller 层可直接通过 <code>UserHolder.get()</code> 获取用户信息，提升性能（如从 200ms 降到 20ms）</p><p><strong>线程安全性保障</strong>：</p><ul><li>每个线程有独立副本</li><li>使用线程池时必须手动 <code>remove()</code>，否则用户数据串用 → 安全隐患</li></ul><p><strong>限制</strong>：</p><ul><li>必须在请求<strong>结束后清理</strong>，否则线程复用会导致“上下文串库”</li><li>不能跨线程（如异步执行、线程池任务）共享；如果在子线程里尝试取数据，需要显式传递或使用 <code>InheritableThreadLocal</code>（但要注意 GC 风险）</li><li>大量数据存放会增加内存压力</li></ul><p>或者是如果不清理的话，因为是弱引用，ThreadLocal的key很容易被清理，其还有null的键，一直在那里呆着。所以要使用remove清理或者是，查找与当前线程关联的Map并将键值对设置为当前线程和null，Huoz是在finally中关闭ThreadLocal。</p><h4 id="4-为什么要使用两个拦截器？不能一个实现所有功能吗？"><a href="#4-为什么要使用两个拦截器？不能一个实现所有功能吗？" class="headerlink" title="4.为什么要使用两个拦截器？不能一个实现所有功能吗？"></a>4.<strong>为什么要使用两个拦截器？不能一个实现所有功能吗？</strong></h4><p>职责单一，遵循 <strong>单一职责原则</strong>，代码更清晰、可维护性更好</p><p>一级负责认证，二级负责续签，分层逻辑解耦，便于扩展和测试</p><p>也方便后期引入更多层（如角色校验、日志记录等）</p><h4 id="5-Token-在前端如何存储？如何防止被盗用？"><a href="#5-Token-在前端如何存储？如何防止被盗用？" class="headerlink" title="5.Token 在前端如何存储？如何防止被盗用？"></a>5.Token 在前端如何存储？如何防止被盗用？</h4><p>推荐使用 <strong>HttpOnly + Secure 的 Cookie 存储 Token</strong>，防止 JS 脚本读取（防 XSS）</p><p>结合 <code>SameSite=Strict</code> 属性防止 CSRF 攻击</p><p>避免把 Token 存在 localStorage 中，localStorage 易被 XSS 攻击读取</p><p>可选使用双 Token：Access Token + Refresh Token，提升安全性</p><h4 id="6-为什么要使用-Access-Token-和-Refresh-Token-双-token？"><a href="#6-为什么要使用-Access-Token-和-Refresh-Token-双-token？" class="headerlink" title="6.为什么要使用 Access Token 和 Refresh Token 双 token？"></a>6.为什么要使用 Access Token 和 Refresh Token 双 token？</h4><p>Access Token 短期有效，暴露风险小；</p><p>Refresh Token 保护用户无需频繁登录；</p><p>避免频繁验证数据库或 Redis，提高性能；</p><p>配合双拦截器自动刷新，增强用户体验。</p><h4 id="7-Refresh-Token-要不要存-Redis？"><a href="#7-Refresh-Token-要不要存-Redis？" class="headerlink" title="7.Refresh Token 要不要存 Redis？"></a>7.<strong>Refresh Token 要不要存 Redis？</strong></h4><p>建议存 Redis：</p><ul><li>可主动登出/注销 refresh token；</li><li>可强制下线；</li><li>可限制一个用户只有一个有效 refresh token；</li><li>提高安全性（Refresh Token 不应被频繁验证，但一旦泄露影响很大）。</li></ul><h4 id="8-Refresh-Token-过期后怎么办？"><a href="#8-Refresh-Token-过期后怎么办？" class="headerlink" title="8.Refresh Token 过期后怎么办？"></a>8.Refresh Token 过期后怎么办？</h4><p>前端收到 401 后无法再自动续签；</p><p>引导用户重新登录；</p><p>后端返回特定错误码区分 access 与 refresh 失效。</p><h4 id="9-如何防止-Refresh-Token-被盗用？"><a href="#9-如何防止-Refresh-Token-被盗用？" class="headerlink" title="9.如何防止 Refresh Token 被盗用？"></a>9.如何防止 Refresh Token 被盗用？</h4><p>限制 IP、设备标识（User-Agent）等；</p><p>加入 Redis 黑名单机制；</p><p>建议设置 HttpOnly Cookie 存储 refresh token，防止 XSS；</p><h2 id="接口支档编写与测试"><a href="#接口支档编写与测试" class="headerlink" title="接口支档编写与测试"></a>接口支档编写与测试</h2><p>使用Swagger编写接口支档，开发过程中进行接口联调测试提升开发效率</p><p>Swagger 是一套 <strong>开放源代码项目</strong>，用于生成、描述、调用和可视化 RESTful 风格 Web 服务的工具集。主要包括：</p><ul><li>Swagger UI：提供一个交互式文档页面，可以直接测试接口。</li><li>Swagger Editor：在线编辑 OpenAPI 规范文档。</li><li>Swagger Codegen：根据文档生成客户端 SDK 或服务端模板代码。</li></ul><p>常见注解：</p><div class="table-container"><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@Operation(summary = &quot;...&quot;)</code></td><td>用于方法上，描述接口作用</td></tr><tr><td><code>@Parameter(name = &quot;...&quot;)</code></td><td>用于方法参数上，描述参数</td></tr><tr><td><code>@Schema(description = &quot;...&quot;)</code></td><td>用于实体类字段上，描述字段</td></tr><tr><td><code>@Tag(name = &quot;...&quot;)</code></td><td>用于 Controller 上，分组描述</td></tr><tr><td><code>@RequestBody</code> + <code>@Schema</code></td><td>描述请求体</td></tr><tr><td><code>@ApiResponse(responseCode = &quot;200&quot;, description = &quot;...&quot;)</code></td><td>描述响应码与内容</td></tr></tbody></table></div><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;用户接口&quot;, description = &quot;用户相关接口文档&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;新增用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Parameter(description = &quot;用户信息&quot;)</span> UserDTO user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;添加成功: &quot;</span> + user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;根据ID获取用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;UserDTO&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><h4 id="1-Swagger-有什么作用？使用它有什么优势？"><a href="#1-Swagger-有什么作用？使用它有什么优势？" class="headerlink" title="1.Swagger 有什么作用？使用它有什么优势？"></a>1.Swagger 有什么作用？使用它有什么优势？</h4><p>Swagger 可以<strong>自动生成接口文档</strong>，支持接口调试，提升前后端联调效率。优势包括：</p><ul><li>接口文档自动同步，无需手写维护</li><li>可视化交互式页面，便于测试接口</li><li>支持导出 OpenAPI 规范，便于生成 SDK 或 Mock 接口</li></ul><h4 id="2-Swagger-在-Spring-Boot-项目中如何接入？"><a href="#2-Swagger-在-Spring-Boot-项目中如何接入？" class="headerlink" title="2.Swagger 在 Spring Boot 项目中如何接入？"></a>2.Swagger 在 Spring Boot 项目中如何接入？</h4><p>使用 <code>springdoc-openapi</code> 依赖，添加依赖后即可自动扫描 <code>@RestController</code> 注解的方法生成接口文档，常用注解包括 <code>@Operation</code>、<code>@Schema</code>、<code>@Parameter</code> 等。</p><h4 id="3-Swagger-与-Postman-有何区别？"><a href="#3-Swagger-与-Postman-有何区别？" class="headerlink" title="3.Swagger 与 Postman 有何区别？"></a>3.Swagger 与 Postman 有何区别？</h4><p>Swagger 更适合开发阶段自动生成文档和接口调试；</p><p>Postman 更适合接口自动化测试、团队共享测试集合、压测脚本等；</p><p>两者可互补：Swagger 导出 OpenAPI 规范，Postman 可导入执行。</p><h4 id="4-如何通过-Swagger-实现接口-Mock？"><a href="#4-如何通过-Swagger-实现接口-Mock？" class="headerlink" title="4.如何通过 Swagger 实现接口 Mock？"></a>4.如何通过 Swagger 实现接口 Mock？</h4><p>Swagger 本身不提供 Mock 功能，但可以通过：</p><ul><li>SwaggerHub 提供在线 Mock；</li><li>使用 Swagger JSON 配合工具如 <a href="https://github.com/stoplightio/prism">Prism</a>、[WireMock] 实现；</li><li>本地模拟返回固定数据，用于前端调试。</li></ul><h4 id="5-MOCK是啥"><a href="#5-MOCK是啥" class="headerlink" title="5.MOCK是啥"></a>5.MOCK是啥</h4><p><strong>用于在真实对象不可用、未完成或不方便调用时，使用伪造的“替代对象”来模拟其行为</strong>。</p><p>本质：使用假的对象或返回结果，代替真实依赖或真实数据，方便开发和测试。</p><p>性能与部署优化：使用Redis缓存热门菜品数据居，应对高并发，减少数据库访尚，缩短接口响应时间：配置g作为日P服务器，外理静态资源赔部置、反同代单及负的律，提升系统稳定性与响应能力</p><h2 id="优惠劵"><a href="#优惠劵" class="headerlink" title="优惠劵"></a>优惠劵</h2><h3 id="优惠劵的超卖重复问题，使用lua脚本保持原子性"><a href="#优惠劵的超卖重复问题，使用lua脚本保持原子性" class="headerlink" title="优惠劵的超卖重复问题，使用lua脚本保持原子性"></a>优惠劵的超卖重复问题，使用lua脚本保持原子性</h3><p><strong>使用 Lua 脚本实现购买优惠券的原子性操作</strong>，常用于防止并发问题，比如<strong>超卖</strong>、<strong>重复领取</strong>等。</p><p>Redis 是<strong>单线程</strong>的，它执行 Lua 脚本时会<strong>串行执行整个脚本内容</strong>，所以可以用 Lua 脚本在 Redis 内部实现多个命令的<strong>原子执行</strong>，避免并发问题。</p><p>场景需求：</p><ul><li>用户未领取过优惠券</li><li>库存 &gt; 0</li><li>扣减库存，记录用户领取状态</li></ul><p><code>stock:coupon:&#123;couponId&#125;</code>：优惠券库存</p><p><code>user:coupon:&#123;couponId&#125;</code>：领取记录的 Set（存储 userId）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- KEYS[<span class="number">1</span>]：库存Key</span><br><span class="line">-- KEYS[<span class="number">2</span>]：领取记录Key</span><br><span class="line">-- ARGV[<span class="number">1</span>]：用户ID</span><br><span class="line"></span><br><span class="line">-- 判断是否领取过</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;sismember&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span> then</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> -- 已领取</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 获取库存</span><br><span class="line"><span class="type">local</span> <span class="variable">stock</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">if</span> stock &lt;= <span class="number">0</span> then</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> -- 库存不足</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 扣减库存</span><br><span class="line">redis.call(<span class="string">&#x27;decr&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">-- 记录用户</span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> -- 成功</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span> script = <span class="string">&quot;...&quot;</span>; <span class="comment">// 上面的 Lua 脚本内容</span></span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; keys = <span class="title class_">Arrays</span>.<span class="title function_">asList</span>(<span class="string">&quot;stock:coupon:1001&quot;</span>, <span class="string">&quot;user:coupon:1001&quot;</span>);</span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; args = <span class="title class_">Arrays</span>.<span class="title function_">asList</span>(<span class="string">&quot;user123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span> result = jedis.<span class="built_in">eval</span>(script, keys, args);</span><br><span class="line"><span class="keyword">switch</span> ((<span class="title class_">Long</span>) result) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;重复领取&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;库存不足&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;领取成功&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优惠券库存减 1 关键是要防止超卖，即多个请求同时扣库存导致数据错乱。</p><p>一种常见做法是使用 <strong>乐观锁（CAS）</strong>：</p><ul><li>数据表中给优惠券记录加个 <strong>版本号（version）</strong> 或 <strong>更新时间戳</strong></li><li>更新库存时带上版本号或时间戳条件，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon <span class="type">SET</span> <span class="variable">stock</span> <span class="operator">=</span> stock - <span class="number">1</span>, version = version + <span class="number">1</span> </span><br><span class="line"><span class="type">WHERE</span> <span class="variable">coupon_id</span> <span class="operator">=</span> ? AND stock &gt; <span class="number">0</span> <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> ?</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/workmenu/crmeb/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM-java虚拟机hot面试</title>
      <link>https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/</link>
      <guid>https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/</guid>
      <pubDate>Sat, 24 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerlink&quot; title=&quot;内存模型&quot;&gt;&lt;/a&gt;内存模型&lt;/h1&gt;&lt;h2 id=&quot;1-JVM的内存模型介绍一下&quot;&gt;&lt;a href=&quot;#1-JVM的内存模型介绍一下&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="1-JVM的内存模型介绍一下"><a href="#1-JVM的内存模型介绍一下" class="headerlink" title="1.JVM的内存模型介绍一下"></a>1.JVM的内存模型介绍一下</h2><p>根据 JDK 8 规范，JVM 运行时内存共分为<strong>虚拟机栈、堆、元空间、程序计数器、本地方法栈</strong>五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p><p>JVM的内存结构主要分为以下几个部分：</p><ul><li><strong>程序计数器</strong>：可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>，用于存储当前线程正在执行的 Java 方法的 JVM 指令地址。相当于指针，<strong>如果线程执行的是 Native 方法，计数器值为 null。</strong>是唯一一个在 Java 虚拟机规范中<strong>没有规定任何 OutOfMemoryError</strong> 情况的区域，生命周期与线程相同。</li><li><strong>Java 虚拟机栈</strong>：<strong>每个线程都有自己独立的 Java 虚拟机栈</strong>，生命周期与线程相同。每个<strong>方法在执行时都会创建一个栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。可能会抛出 <strong>StackOverflowError 和 OutOfMemoryError</strong> 异常。</li><li><strong>本地方法栈</strong>：与 Java 虚拟机栈类似，主<strong>要为虚拟机使用到的 Native 方法服务</strong>，在 <strong>HotSpot 虚拟机中和 Java 虚拟机栈合二为一</strong>。本地方法执行时也会创建栈帧，<strong>同样可能出现 StackOverflowError 和 OutOfMemoryError 两种错误。</strong></li><li><strong>Java 堆</strong>：是 <strong>JVM 中最大的一块内存区域，被所有线程共享</strong>，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区（From Survivor 和 To Survivor）。如果在堆中没有内存完成实例分配，<strong>并且堆也无法扩展时会抛出 OutOfMemoryError 异常。</strong></li><li><strong>方法区（元空间）</strong>：在 JDK 1.8 及以后的版本中，<strong>方法区被元空间取代，使用本地内存</strong>。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。虽然方法区被描述为堆的逻辑部分，但有 “非堆” 的别名。<strong>方法区可以选择不实现垃圾收集，内存不足时会抛出 OutOfMemoryError 异常。</strong></li><li><strong>运行时常量池</strong>：是方法区的一部分，<strong>用于存放编译期生成的各种字面量和符号引用</strong>，具有动态性，运行时也可将新的常量放入池中。当无法申请到足够内存时，会抛出 OutOfMemoryError 异常。</li><li><strong>直接内存</strong>：不属于 JVM 运行时数据区的一部分，<strong>通过 NIO 类引入，是一种堆外内存，可以显著提高 I/O 性能。</strong>直接内存的使用受到本机总内存的限制，若分配不当，可能导致 OutOfMemoryError 异常。</li></ul><h2 id="2-JVM内存模型里的堆和栈有什么区别？"><a href="#2-JVM内存模型里的堆和栈有什么区别？" class="headerlink" title="2.JVM内存模型里的堆和栈有什么区别？"></a>2.JVM内存模型里的堆和栈有什么区别？</h2><ul><li><strong>用途</strong>：<strong>栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。</strong>每当一个方法被调用，一个栈帧（stack frame）就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆用于存储对象的实例（包括类的实例和数组）。<strong>当你使用<code>new</code>关键字创建一个对象时，对象的实例就会在堆上分配空间。</strong></li><li><strong>生命周期</strong>：栈中的数据具有<strong>确定的生命周期</strong>，当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，<strong>对象会在垃圾回收机制（Garbage Collection, GC）检测到对象不再被引用时才被回收。</strong></li><li><strong>存取速度</strong>：<strong>栈的存取速度通常比堆快</strong>，因为栈遵循先进后出（LIFO, Last In First Out）的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。</li><li><strong>存储空间</strong>：<strong>栈的空间相对较小，且固定，由操作系统管理</strong>。当栈溢出时，通常是因为递归过深或局部变量过大。堆的空间较大，动态扩展，由JVM管理。<strong>堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。</strong></li><li><strong>可见性</strong>：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。</li></ul><h2 id="3-栈中存的到底是指针还是对象？"><a href="#3-栈中存的到底是指针还是对象？" class="headerlink" title="3.栈中存的到底是指针还是对象？"></a>3.栈中存的到底是指针还是对象？</h2><p>在JVM内存模型中，栈（Stack）主要用于<strong>管理线程的局部变量和方法调用的上下文</strong>，而堆（Heap）则是用于<strong>存储所有类的实例和数组。</strong></p><p>当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。</p><p>这里的关键点是，栈中存储的<strong>不是</strong>对象，而是<strong>对象的引用</strong>。也就是说，<strong>当你在方法中声明一个对象，比如<code>MyObject obj = new MyObject();</code>，这里的<code>obj</code>实际上是一个存储在栈上的引用</strong>，<strong>指向堆中实际的对象实例</strong>。这个引用是一个固定大小的数据（例如在64位系统上是8字节），它指向堆中分配给对象的内存区域。</p><h2 id="4-堆分为哪几部分呢？"><a href="#4-堆分为哪几部分呢？" class="headerlink" title="4.堆分为哪几部分呢？"></a>4.堆分为哪几部分呢？</h2><p>Java堆（Heap）是Java虚拟机（JVM）中内存管理的一个重要区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt=""></p><ul><li><strong>新生代（Young Generation）</strong>:新生代分为<strong>Eden Space和Survivor Space</strong>。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，<strong>称为S0（Survivor 0）和S1（Survivor 1）</strong>。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。<strong>这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</strong></li><li><strong>老年代（Old Generation/Tenured Generation）</strong>:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。<strong>老年代中的对象生命周期较长</strong>，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的<strong>空间通常比新生代大</strong>，以存储更多的长期存活对象。</li><li><strong>元空间（Metaspace）</strong>:从Java 8开始，永久代（Permanent Generation）被<strong>元空间</strong>取代，<strong>用于存储类的元数据信息，如类的结构信息（如字段、方法信息等）</strong>。元空间并不在Java堆中，而是使用<strong>本地内存</strong>，这解决了永久代容易出现的内存溢出问题。</li><li><strong>大对象区（Large Object Space / Humongous Objects）</strong>:在某些JVM实现中（如G1垃圾收集器），<strong>为大对象分配了专门的区域，称为大对象区或Humongous Objects区域</strong>。大对象是指<strong>需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。</strong></li></ul><h2 id="5-如果有个大对象一般是在哪个区域？"><a href="#5-如果有个大对象一般是在哪个区域？" class="headerlink" title="5.如果有个大对象一般是在哪个区域？"></a>5.如果有个大对象一般是在哪个区域？</h2><p><strong>大对象通常会直接分配到老年代。</strong></p><p>新生代主要用于<strong>存放生命周期较短的对象，并且其内存空间相对较小</strong>。如果将大对象分配到新生代，可能会很快导致新生代空间不足，从而频繁触发 Minor GC。而每次 Minor GC 都需要进行对象的复制和移动操作，这会带来一定的性能开销。将大对象直接分配到老年代，可以减少新生代的内存压力，降低 Minor GC 的频率。</p><p><strong>大对象通常需要连续的内存空间</strong>，如果在新生代中频繁分配和回收大对象，<strong>容易产生内存碎片，导致后续分配大对象时可能因为内存不连续而失败。</strong>老年代的空间相对较大，更适合存储大对象，有助于减少内存碎片的产生。</p><h2 id="6-程序计数器的作用，为什么是私有的？"><a href="#6-程序计数器的作用，为什么是私有的？" class="headerlink" title="6.程序计数器的作用，为什么是私有的？"></a>6.程序计数器的作用，为什么是私有的？</h2><p>Java程序是支持多线程一起运行的，多个线程一起运行的时候cpu会有一个调动器组件给它们分配时间片，比如说会给线程1分给一个时间片，它在时间片内如果它的代码没有执行完，<strong>它就会把线程1的状态执行一个暂存</strong>，切换到线程2去，执行线程2的代码，等线程2的代码执行到了一定程度，线程2的时间片用完了，再切换回来，再继续执行线程1剩余部分的代码。</p><p>我们考虑一下，<strong>如果在线程切换的过程中，下一条指令执行到哪里了，是不是还是会用到我们的程序计数器啊。每个线程都有自己的程序计数器，因为它们各自执行的代码的指令地址是不一样的呀，所以每个线程都应该有自己的程序计数器。</strong></p><h2 id="7-方法区中的方法的执行过程？"><a href="#7-方法区中的方法的执行过程？" class="headerlink" title="7.方法区中的方法的执行过程？"></a>7.方法区中的方法的执行过程？</h2><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p><ul><li><strong>解析方法调用</strong>：JVM会根据<strong>方法的符号引用找到实际的方法地址</strong>（如果之前没有解析过的话）。</li><li><strong>栈帧创建</strong>：在调用一个方法前，JVM会在当前线程的Java<strong>虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</strong></li><li><strong>执行方法</strong>：执行方法内的<strong>字节码指令</strong>，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。</li><li><strong>返回处理</strong>：方法执行完毕后，可<strong>能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。</strong></li></ul><h2 id="8-HotSpot-为什么要分为新生代和老年代？"><a href="#8-HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="8.HotSpot 为什么要分为新生代和老年代？"></a>8.HotSpot 为什么要分为新生代和老年代？</h2><p>HotSpot 将堆内存划分为新生代和老年代，是为了<strong>利用对象生命周期的差异来优化垃圾回收性能。</strong>大多数对象生命周期短，适合在新生代中用高效的<strong>复制算法</strong>快速回收；少量长寿命对象存放在老年代，<strong>减少回收频率。分代设计能有效缩短停顿时间、提高吞吐量，避免每次 GC 都扫描整个堆，从而提升整体系统运行效率。</strong></p><h2 id="9-方法区中还有哪些东西？"><a href="#9-方法区中还有哪些东西？" class="headerlink" title="9.方法区中还有哪些东西？"></a>9.方法区中还有哪些东西？</h2><p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><ul><li>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。</li><li>常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。</li><li>静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。</li><li>方法字节码：存储类的方法字节码，即编译后的代码。</li><li>符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。</li><li>运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。</li><li>常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。</li></ul><h2 id="10-String保存在哪里呢？"><a href="#10-String保存在哪里呢？" class="headerlink" title="10.String保存在哪里呢？"></a>10.String保存在哪里呢？</h2><p>String 保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享</p><h2 id="11-String-s-new-String（“abc”）执行过程中分别对应哪些内存区域？"><a href="#11-String-s-new-String（“abc”）执行过程中分别对应哪些内存区域？" class="headerlink" title="11.String s = new String（“abc”）执行过程中分别对应哪些内存区域？"></a>11.String s = new String（“abc”）执行过程中分别对应哪些内存区域？</h2><p>首先，我们看到这个代码中有一个new关键字，我们知道<strong>new</strong>指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在<strong>运行期</strong>才能确定的，创建的字符串对象是在<strong>堆内存上</strong>。</p><p>其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时，JVM拿字面量”abc”去<strong>字符串常量池</strong>试图获取其对应String对象的引用。<strong>于是在堆中创建了一个”abc”的String对象</strong>，并将其引用保存到字符串常量池中，然后返回；</p><p>所以，<strong>如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new String这个实例对象。如果abc这字符串常量存在，则只会创建一个对象</strong>。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="1-为什么软引用可以防止内存溢出"><a href="#1-为什么软引用可以防止内存溢出" class="headerlink" title="1.为什么软引用可以防止内存溢出"></a><strong>1.为什么软引用可以防止内存溢出</strong></h2><p>减轻内存压力：</p><p>软引用对象在内存紧张时会被 GC 回收，这意味着,对于一些<strong>缓存型对象</strong>（如图片缓存、数据缓存）：</p><ul><li>使用软引用能让 JVM 在不影响系统运行的前提下<strong>自动清理不重要的对象</strong>；</li><li>避免这些对象<strong>一直占用内存</strong>导致 OOM（OutOfMemoryError）。</li></ul><p>有利于缓存系统的实现：</p><p>比如在图片浏览器、数据库连接池、网页浏览器中，常常需要缓存大量数据；使用软引用作为缓存的基础可以确保：</p><ul><li>缓存不会<strong>占用过多堆内存</strong>；</li><li>系统空闲时缓存仍可用；</li><li>一旦内存紧张，<strong>缓存自动释放</strong>，系统依旧安全运行。</li></ul><p>相比强引用更灵活、相比弱引用更安全</p><div class="table-container"><table><thead><tr><th>引用类型</th><th>回收时机</th><th>是否适合做缓存</th><th>对系统安全性的影响</th></tr></thead><tbody><tr><td>强引用</td><td>永不回收（除非没有引用）</td><td>❌ 会导致 OOM</td><td>高风险</td></tr><tr><td>弱引用</td><td>GC 时就回收</td><td>⚠️ 不适合</td><td>稳定但易失效</td></tr><tr><td>软引用</td><td>内存不足时回收</td><td>✅ 非常适合</td><td>✅ 安全可靠</td></tr></tbody></table></div><p>为什么弱引用/虚引用用得少？</p><p><strong>弱引用</strong>：一旦 GC 触发，不管内存够不够都会被回收，<strong>太激进，不适合缓存</strong>；</p><p><strong>虚引用</strong>：更偏底层，<strong>用于监控对象被回收的时机</strong>，不具备访问能力，<strong>需要配合 ReferenceQueue 使用</strong>，复杂度高。</p><h2 id="2-引用类型有哪些？有什么区别？"><a href="#2-引用类型有哪些？有什么区别？" class="headerlink" title="2.引用类型有哪些？有什么区别？"></a>2.引用类型有哪些？有什么区别？</h2><p>引用类型主要分为强软弱虚四种：</p><ul><li>强引用指的就是<strong>代码中普遍存在的赋值方式</strong>，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。就是一个对象</li><li>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。<strong>系统在发生内存溢出前会对这类引用的对象进行回收。</strong></li><li>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，<strong>弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。</strong></li><li>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，<strong>他必须和ReferenceQueue一起使用</strong>，同样的当发生GC的时候，虚引用也会被回收。<strong>可以用虚引用来管理堆外内存。</strong></li></ul><h2 id="3-弱引用了解吗-举例说明在哪里可以用"><a href="#3-弱引用了解吗-举例说明在哪里可以用" class="headerlink" title="3.弱引用了解吗?举例说明在哪里可以用?"></a>3.弱引用了解吗?举例说明在哪里可以用?</h2><p>Java中的弱引用是一种引用类型，它不会阻止一个对象被垃圾回收。</p><p>在Java中，弱引用是通过<code>Java.lang.ref.WeakReference</code>类实现的。弱引用的一个主要用途是创建非强制性的对象引用，<strong>这些引用可以在内存压力大时被垃圾回收器清理，从而避免内存泄露。</strong></p><p>弱引用的使用场景：</p><ul><li><strong>缓存系统</strong>：弱引用常用于<strong>实现缓存</strong>，特别是当希望缓存项能够在内存压力下自动释放时。如果缓存的大小不受控制，可能会导致内存溢出。使用弱引用来维护缓存，可以让JVM在需要更多内存时自动清理这些缓存对象。</li><li><strong>对象池</strong>：在对象池中，<strong>弱引用可以用来管理那些暂时不使用的对象。当对象不再被强引用时，它们可以被垃圾回收，释放内存。</strong></li><li><strong>避免内存泄露</strong>：当一个对象<strong>不应该被长期引用时</strong>，使用弱引用可以防止该对象被意外地保留，从而避免潜在的内存泄露。</li></ul><p>示例代码：</p><p>假设我们有一个缓存系统，我们使用弱引用来维护缓存中的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> Java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> Java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WeakReference&lt;MyHeavyObject&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyHeavyObject <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        WeakReference&lt;MyHeavyObject&gt; ref = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ref.get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MyHeavyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHeavyObject</span>();</span><br><span class="line">            cache.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj));</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设MyHeavyObject是一个占用大量内存的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHeavyObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] largeData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 10MB data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用<code>WeakReference</code>来存储<code>MyHeavyObject</code>实例，当内存压力增大时，垃圾回收器可以自由地回收这些对象，而不会影响缓存的正常运行。</p><p>如果一个对象被垃圾回收，下次尝试从缓存中获取时，<code>get()</code>方法会返回<code>null</code>，这时我们可以重新创建对象并将其放入缓存中。因此，使用弱引用时要注意，一旦对象被垃圾回收，通过弱引用获取的对象可能会变为<code>null</code>，因此在使用前通常需要检查这一点。</p><div class="table-container"><table><thead><tr><th>特性</th><th>软引用（SoftReference）</th><th>弱引用（WeakReference）</th></tr></thead><tbody><tr><td>回收时机</td><td>内存不足时才回收</td><td>下一次 GC 就可能回收</td></tr><tr><td>存活时间</td><td>相对更长</td><td>非常短，随时可能被清除</td></tr><tr><td>适合场景</td><td>缓存（保留尽可能多对象）</td><td>映射、辅助引用、监听器、ThreadLocal 等</td></tr><tr><td>安全性</td><td>更高（内存紧张时才回收）</td><td>更低（不稳定，随时可能为 null）</td></tr><tr><td>被使用的典型类</td><td><code>SoftReferenceCache</code></td><td><code>WeakHashMap</code>、<code>ThreadLocal</code> 底层</td></tr></tbody></table></div><h2 id="4-内存泄漏和内存溢出的理解？"><a href="#4-内存泄漏和内存溢出的理解？" class="headerlink" title="4.内存泄漏和内存溢出的理解？"></a>4.内存泄漏和内存溢出的理解？</h2><p><strong>内存泄露</strong>：内存泄漏是<strong>指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。</strong>虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。</p><p>内存泄露常见原因：</p><ul><li><strong>静态集合</strong>：使用静态数据结构（如<code>HashMap</code>或<code>ArrayList</code>）存储对象，且未清理。</li><li><strong>事件监听</strong>：未取消对事件源的监听，导致对象持续被引用。</li><li><strong>线程</strong>：未停止的线程可能持有对象引用，无法被回收。</li></ul><p>内存溢出：内存溢出是指<strong>Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发<code>OutOfMemoryError</code>。这通常发生在堆内存不足以存放新创建的对象时。</strong></p><p>内存溢出常见原因：</p><ul><li><strong>大量对象创建</strong>：程序中不断创建大量对象，超出JVM堆的限制。</li><li><strong>持久引用</strong>：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。</li><li><strong>递归调用</strong>：深度递归导致栈溢出。</li></ul><p>内存泄漏是还没满，内存溢出是已经满了</p><h2 id="5-jvm-内存结构有哪几种内存溢出的情况？"><a href="#5-jvm-内存结构有哪几种内存溢出的情况？" class="headerlink" title="5.jvm 内存结构有哪几种内存溢出的情况？"></a>5.jvm 内存结构有哪几种内存溢出的情况？</h2><ul><li><strong>堆内存溢出</strong>：当出现Java.lang.OutOfMemoryError:Java heap space异常时，就是堆内存溢出了。原因是代码中<strong>可能存在大对象分配，或者发生了内存泄露</strong>，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。</li><li><strong>栈溢出</strong>：如果我们<strong>写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</strong>类似这种情况，JVM 实际会抛出 StackOverFlowError；<strong>当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</strong></li><li><strong>元空间溢出</strong>：元空间的溢出，系统会抛出Java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是<strong>系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。</strong></li><li><strong>直接内存内存溢出</strong>：在使用<strong>ByteBuffer中的allocateDirect()的时候会用到</strong>，很多JavaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出Java.lang.OutOfMemoryError: Direct buffer memory异常。</li></ul><p>除了<strong>程序计数器</strong>都会出现OOM</p><h2 id="6-有具体的内存泄漏和内存溢出的例子么请举例及解决方案"><a href="#6-有具体的内存泄漏和内存溢出的例子么请举例及解决方案" class="headerlink" title="6.有具体的内存泄漏和内存溢出的例子么请举例及解决方案?"></a>6.有具体的内存泄漏和内存溢出的例子么请举例及解决方案?</h2><blockquote><p>1、静态属性导致内存泄露</p></blockquote><p>会导致内存泄露的一种情况就是<strong>大量使用static静态变量</strong>。在Java中，静态属性的生命周期通常伴随着应用整个生命周期（除非ClassLoader符合垃圾回收的条件）。下面来看一个具体的会导致内存泄露的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticTest</span>().populateList();</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果监控内存堆内存的变化，会发现在打印Point1和Point2之间，堆内存会有一个明显的增长趋势图。但当执行完populateList方法之后，对堆内存并没有被垃圾回收器进行回收。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112907539.png" alt="image-20240820112907539"></p><p>但针对上述程序，如果将定义list的变量前的static关键字去掉，再次执行程序，会发现内存发生了具体的变化。VisualVM监控信息如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112851893.png" alt="image-20240820112851893"></p><p>对比两个图可以看出，程序执行的前半部分内存使用情况都一样，但当执行完populateList方法之后，后者不再有引用指向对应的数据，垃圾回收器便进行了回收操作。因此，我们要十分留意static的变量，<strong>如果集合或大量的对象定义为static的，它们会停留在整个应用程序的生命周期当中。而它们所占用的内存空间，本可以用于其他地方。</strong></p><p>那么如何优化呢？<strong>第一，进来减少静态变量；第二，如果使用单例，尽量采用懒加载。</strong></p><blockquote><p>2、 未关闭的资源</p></blockquote><p>无论什么时候当我们创建一个连接或打开一个流，JVM都会分配内存给这些资源。比如，数据库链接、输入流和session对象。</p><p><strong>忘记关闭这些资源，会阻塞内存，从而导致GC无法进行清理。</strong>特别是当程序发生异常时，没有在finally中进行资源关闭的情况。这些未正常关闭的连接，如果不进行处理，轻则影响程序性能，重则导致OutOfMemoryError异常发生。</p><p>如果进行处理呢？<strong>第一，始终记得在finally中进行资源的关闭；第二，关闭连接的自身代码不能发生异常；第三，Java7以上版本可使用try-with-resources代码方式进行资源关闭。</strong></p><p>try-with-resources:</p><p><code>try()</code> 中定义的对象，必须实现 <code>AutoCloseable</code> 接口（<code>Closeable</code> 也可以，间接继承）；</p><p>try 块执行完后，Java 会自动调用这些资源的 <code>.close()</code> 方法；</p><blockquote><p>3、 使用ThreadLocal</p></blockquote><p>ThreadLocal提供了<strong>线程本地变量</strong>，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。<strong>ThreadLocal相当于提供了一种线程隔离</strong>，将变量与线程相绑定，从而实现线程安全的特性。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112835783.png" alt="image-20240820112835783"></p><p>ThreadLocal的实现中，<strong>每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。</strong></p><p>ThreadLocalMap使用ThreadLocal的<strong>弱引用作为key</strong>，如果一个ThreadLocal<strong>没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</strong></p><p>如果当前线程迟迟不结束的话，<strong>这些key为null的Entry的value就会一直存在一条强引用链</strong>：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><p>如何解决此问题？</p><ul><li>第一，<strong>使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除</strong>；</li><li>第二，不要使用ThreadLocal.set(null) 的方式清除value，它实际上并没有清除值，而是<strong>查找与当前线程关联的Map并将键值对分别设置为当前线程和null。</strong></li><li>第三，<strong>最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(System.nanoTime());</span><br><span class="line">    <span class="comment">//... further processing</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><h2 id="1-创建对象的过程？"><a href="#1-创建对象的过程？" class="headerlink" title="1.创建对象的过程？"></a>1.创建对象的过程？</h2><p>在Java中创建对象的过程包括以下几个步骤：</p><ol><li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</li><li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为<strong>新生对象分配内存</strong>。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</li><li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要<strong>将分配到的内存空间都初始化为零值</strong>（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所<strong>以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</strong></li></ol><h2 id="2-对象的生命周期"><a href="#2-对象的生命周期" class="headerlink" title="2.对象的生命周期"></a>2.对象的生命周期</h2><p>对象的生命周期包括创建、使用和销毁三个阶段：</p><ul><li>创建：对象通过<strong>关键字new在堆内存中被实例化</strong>，构造函数被调用，对象的内存空间被分配。</li><li>使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。</li><li>销毁：当对象不再被引用时，通过<strong>垃圾回收机制自动回收对象所占用的内存空间</strong>。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。</li></ul><h2 id="3-类加载器有哪些？"><a href="#3-类加载器有哪些？" class="headerlink" title="3.类加载器有哪些？"></a>3.类加载器有哪些？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png" alt=""></p><ul><li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这是<strong>最顶层的类加载器</strong>，负责加载Java的核心库（如位于jre/lib/rt.jar中的类），它是用C++编写的，是JVM的一部分。启动类加载器无法被Java程序直接引用。</li><li><strong>扩展类加载器（Extension Class Loader）</strong>：它是Java语言实现的，<strong>继承自ClassLoader类</strong>，负责加载Java扩展目录（jre/lib/ext或由系统变量Java.ext.dirs指定的目录）下的jar包和类库。<strong>扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。</strong></li><li><strong>系统类加载器（System Class Loader）/ 应用程序类加载器（Application Class Loader）</strong>：这也是Java语言实现的，<strong>负责加载用户类路径（ClassPath）上的指定类库</strong>，是我们平时编写Java程序时默认使用的类加载器。系统类加载器的父加载器是扩展类加载器。它可以通过ClassLoader.getSystemClassLoader()方法获取到。</li><li><strong>自定义类加载器（Custom Class Loader）</strong>：开发者可以根据需求定制类的加载方式，比如从网络加载class文件、数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是Java动态性的一个重要体现。</li></ul><p>这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，<strong>而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</strong></p><p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载</p><h2 id="3-双亲委派模型的作用"><a href="#3-双亲委派模型的作用" class="headerlink" title="3.双亲委派模型的作用"></a>3.双亲委派模型的作用</h2><ul><li><strong>保证类的唯一性</strong>：通过委托机制，<strong>确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况</strong>，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</li><li><strong>保证安全性</strong>：由于Java核心库被启动类加载器加载，而<strong>启动类加载器只加载信任的类路径中的类</strong>，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li><li><strong>支持隔离和层次划分</strong>：双亲委派模型<strong>支持不同层次的类加载器服务于不同的类加载需求</strong>，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li><li><strong>简化了加载流程</strong>：通过委派，<strong>大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。</strong></li></ul><h2 id="4-讲一下类加载过程？"><a href="#4-讲一下类加载过程？" class="headerlink" title="4.讲一下类加载过程？"></a>4.讲一下类加载过程？</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt=""></h3><ul><li><strong>加载</strong>：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，<strong>转化为方法区运行时的数据结构</strong>，在内存中生成一个代表该类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li><li><strong>连接</strong>：验证、准备、解析 3 个阶段统称为连接。<ul><li><strong>验证</strong>：<strong>确保class文件中的字节流包含的信息，符合当前虚拟机的要求</strong>，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证</li><li><strong>准备</strong>：为类中的<strong>静态字段分配内存，并设置默认的初始值</strong>，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</li><li><strong>解析</strong>：解析阶段是<strong>虚拟机将常量池的「符号引用」直接替换为「直接引用」的过程</strong>。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</li></ul></li><li><strong>初始化</strong>：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是<strong>执行类的构造器方法（()</strong> ），要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。</li><li><strong>使用</strong>：使用类或者创建对象</li><li><strong>卸载</strong>：如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 3. 类对应的Java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="5-讲一下类的加载和双亲委派原则"><a href="#5-讲一下类的加载和双亲委派原则" class="headerlink" title="5.讲一下类的加载和双亲委派原则"></a>5.讲一下类的加载和双亲委派原则</h2><p>我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化。</p><p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ul><li>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li><li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li><li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。</li></ul><p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p><p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="1-什么是Java里的垃圾回收？如何触发垃圾回收？"><a href="#1-什么是Java里的垃圾回收？如何触发垃圾回收？" class="headerlink" title="1.什么是Java里的垃圾回收？如何触发垃圾回收？"></a>1.什么是Java里的垃圾回收？如何触发垃圾回收？</h2><p>垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，它负责自动释放不再被程序引用的对象所占用的内存，这种机制减少了内存泄漏和内存管理错误的可能性。垃圾回收可以通过多种方式触发，具体如下：</p><ul><li><strong>内存不足时</strong>：当JVM检测到<strong>堆内存不足</strong>，无法为新的对象分配内存时，会自动触发垃圾回收。</li><li><strong>手动请求</strong>：虽然垃圾回收是自动的，<strong>开发者可以通过调用 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 建议 JVM 进行垃圾回收。</strong>不过这只是一个建议，并不能保证立即执行。</li><li><strong>JVM参数</strong>：启动 Java 应用时可以通过 <strong>JVM 参数来调整垃圾回收的行为</strong>，比如：<code>-Xmx</code>（最大堆大小）、<code>-Xms</code>（初始堆大小）等。</li><li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。</li></ul><h2 id="2-判断垃圾的方法有哪些？"><a href="#2-判断垃圾的方法有哪些？" class="headerlink" title="2.判断垃圾的方法有哪些？"></a>2.判断垃圾的方法有哪些？</h2><p>在Java中，判断对象是否为垃圾（即不再被使用，可以被垃圾回收器回收）主要依据两种主流的垃圾回收算法来实现：<strong>引用计数法和可达性分析算法</strong>。</p><blockquote><p>引用计数法（Reference Counting）</p></blockquote><ul><li><strong>原理</strong>：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。</li><li><strong>缺点</strong>：<strong>不能解决循环引用的问题</strong>，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。</li></ul><blockquote><p>可达性分析算法（Reachability Analysis）</p></blockquote><p><img src="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" alt="img"></p><p>Java虚拟机主要采用此算法来判断对象是否为垃圾。</p><ul><li><strong>原理</strong>：从一组称为<strong>GC Roots（垃圾收集根）的对象出发</strong>，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。<strong>如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。</strong>GC Roots对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等。</li></ul><h2 id="3-垃圾回收算法是什么，是为了解决了什么问题？"><a href="#3-垃圾回收算法是什么，是为了解决了什么问题？" class="headerlink" title="3.垃圾回收算法是什么，是为了解决了什么问题？"></a>3.垃圾回收算法是什么，是为了解决了什么问题？</h2><p>JVM有垃圾回收机制的原因是为了<strong>解决内存管理的问题</strong>。在传统的编程语言中，开发人员需要手动分配和释放内存，这可能导致<strong>内存泄漏、内存溢出</strong>等问题。而Java作为一种高级语言，旨在提供更简单、更安全的编程环境，因此引入了垃圾回收机制来自动管理内存。</p><p>垃圾回收机制的主要目标是<strong>自动检测和回收**</strong>不再使用的对象<strong>，从而释放它们所占用的内存空间。这样可以</strong>避免内存泄漏（一些对象被分配了内存却无法被释放，导致内存资源的浪费）。同时，垃圾回收机制还可以防止内存溢出（即程序需要的内存超过了可用内存的情况）。**</p><p>通过垃圾回收机制，JVM可以在程序运行时自动识别和清理不再使用的对象，使得开发人员无需手动管理内存。这样可以提高开发效率、减少错误，并且使程序更加可靠和稳定。</p><h2 id="4-垃圾回收算法有哪些？"><a href="#4-垃圾回收算法有哪些？" class="headerlink" title="4.垃圾回收算法有哪些？"></a>4.垃圾回收算法有哪些？</h2><ul><li><strong>标记-清除算法</strong>：标记-清除算法分为<strong>“标记”和“清除”</strong>两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，<strong>标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。</strong>有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</li><li><strong>复制算法</strong>：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。<strong>因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</strong></li><li><strong>标记-整理算法</strong>：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，<strong>但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</strong></li><li><strong>分代回收算法</strong>：分代收集是将内存划分成了<strong>新生代和老年代</strong>。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，<strong>一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</strong></li></ul><p>比如新生代我们使用复制算法效率较高，老年代使用标记-整理算法更好</p><h2 id="5-垃圾回收器有哪些？"><a href="#5-垃圾回收器有哪些？" class="headerlink" title="5.垃圾回收器有哪些？"></a>5.垃圾回收器有哪些？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png" alt=""></p><h2 id="6-标记清除算法的缺点是什么？"><a href="#6-标记清除算法的缺点是什么？" class="headerlink" title="6.标记清除算法的缺点是什么？"></a>6.标记清除算法的缺点是什么？</h2><p>主要缺点有两个：</p><ul><li>一个是效率问题，标记和清除过程的效率都不高；</li><li>另外一个是空间问题，标记清除之后会产生<strong>大量不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到<strong>足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong></li></ul><h2 id="7-垃圾回收算法哪些阶段会stop-the-world"><a href="#7-垃圾回收算法哪些阶段会stop-the-world" class="headerlink" title="7.垃圾回收算法哪些阶段会stop the world?"></a>7.垃圾回收算法哪些阶段会stop the world?</h2><p>标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：</p><ul><li><strong>标记阶段，即从GC Roots集合开始，标记活跃对象；</strong></li><li><strong>转移阶段，即把活跃对象复制到新的内存地址上；</strong></li><li><strong>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</strong></li></ul><p>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1718783586342-9da40db7-1dac-42ec-8148-81c10d8bfc04.png" alt="img"></p><p>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。</p><p><strong>标记阶段停顿分析</strong></p><ul><li>初始标记阶段：初始标记阶段是指从GC Roots出发标记<strong>全部直接子节点</strong>的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。</li><li>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。</li><li>再标记阶段：<strong>重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。</strong></li></ul><p><strong>清理阶段停顿分析</strong></p><ul><li><strong>清理阶段清点</strong>出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。</li></ul><p><strong>复制阶段停顿分析</strong></p><ul><li><strong>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，</strong>其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。</li></ul><p>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。</p><p>因此，G1停顿时间的瓶颈<strong>主要是标记-复制中的转移阶段STW。</strong></p><h2 id="8-minorGC、majorGC、fullGC的区别，什么场景触发full-GC"><a href="#8-minorGC、majorGC、fullGC的区别，什么场景触发full-GC" class="headerlink" title="8.minorGC、majorGC、fullGC的区别，什么场景触发full GC"></a>8.minorGC、majorGC、fullGC的区别，什么场景触发full GC</h2><p>在Java中，垃圾回收机制是自动管理内存的重要组成部分。根据其作用范围和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。以下是这三种GC的区别和触发场景：</p><blockquote><p>Minor GC (Young GC)</p></blockquote><ul><li><strong>作用范围</strong>：只针对<strong>年轻代</strong>进行回收，包括Eden区和两个Survivor区（S0和S1）。</li><li><strong>触发条件</strong>：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。</li><li><strong>特点</strong>：<strong>通常发生得非常频繁</strong>，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。</li></ul><blockquote><p>Major GC</p></blockquote><ul><li><strong>作用范围</strong>：主要<strong>针对老年代进行回收</strong>，但不一定只回收老年代。</li><li><strong>触发条件</strong>：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。</li><li><strong>特点</strong>：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。</li></ul><blockquote><p>Full GC</p></blockquote><ul><li><strong>作用范围</strong>：<strong>对整个堆内存（包括年轻代、老年代以及永久代/元空间）进行回收</strong>。</li><li><strong>触发条件</strong>：<ul><li>直接调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>方法时，虽然不能保证立即执行，但JVM会尝试执行Full GC。</li><li>Minor GC（新生代垃圾回收）时，如<strong>果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。</strong></li><li>当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时。</li></ul></li><li><strong>特点</strong>：Full GC是最昂贵的操作，因为它需要停止所有的工作线程（Stop The World），遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发。</li></ul><h2 id="9-垃圾回收器-CMS-和-G1的区别？"><a href="#9-垃圾回收器-CMS-和-G1的区别？" class="headerlink" title="9.垃圾回收器 CMS 和 G1的区别？"></a>9.垃圾回收器 CMS 和 G1的区别？</h2><p><strong>区别一：使用的范围不一样：</strong></p><ul><li>CMS收集器是<strong>老年代</strong>的收集器，可以<strong>配合新生代的Serial和ParNew收集器一起使用</strong></li><li>G1收集器收集范围是<strong>老年代和新生代</strong>。不需要结合其他收集器使用</li></ul><p><strong>区别二：STW的时间：</strong></p><ul><li>CMS收集器以<strong>最小的停顿时间</strong>为目标的收集器。目标是交互更多一点</li><li>G1收集器可预测<a href="https://so.csdn.net/so/search?q=垃圾回收&amp;spm=1001.2101.3001.7020">垃圾回收 (opens new window)</a>的停顿时间（建立可预测的停顿时间模型），目标是高吞吐量</li></ul><p><strong>区别三： 垃圾碎片</strong></p><ul><li>CMS收集器是使用“标记-清除”<strong>算法进行的垃圾回收，容易产生内存碎片</strong></li><li>G1收集器使用的是“<strong>标记-整理</strong>”算法，进行了空间整合，没有内存空间碎片</li></ul><p>局部上看是标记-复制算法</p><p><strong>区别四： 垃圾回收的过程不一样</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1716015294690-efd71a12-f4b1-4356-9de2-5164393482a5.png" alt="img"></p><p>注意这两个收集器第四阶段得不同</p><p><strong>区别五: CMS会产生浮动垃圾</strong></p><ul><li>CMS产生浮动垃圾过多时<strong>会退化为serial old，效率低</strong>，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户线程同时工作会产生浮动垃圾，<strong>也就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾</strong></li><li>而G1没有浮动垃圾，<strong>G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收，</strong>在执行‘并发清理’步骤时，<strong>用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。</strong>如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,<strong>一旦出现此错误时便会切换到SerialOld收集方式。</strong></li></ul><h2 id="10-什么情况下使用CMS，什么情况使用G1"><a href="#10-什么情况下使用CMS，什么情况使用G1" class="headerlink" title="10.什么情况下使用CMS，什么情况使用G1?"></a>10.什么情况下使用CMS，什么情况使用G1?</h2><p>CMS适用场景：</p><ul><li><strong>低延迟需求</strong>：适用于对停顿时间要求敏感的应用程序。</li><li><strong>老生代收集</strong>：主要针对老年代的垃圾回收。</li><li><strong>碎片化管理</strong>：容易出现内存碎片，可能需要定期进行Full GC来压缩内存空间。</li></ul><p>G1适用场景：</p><ul><li><strong>大堆内存</strong>：适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。</li><li><strong>对内存碎片敏感</strong>：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。</li><li><strong>比较平衡的性能</strong>：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。</li></ul><h2 id="11-G1回收器的特色是什么？"><a href="#11-G1回收器的特色是什么？" class="headerlink" title="11.G1回收器的特色是什么？"></a>11.G1回收器的特色是什么？</h2><p><strong>G1 的特点：</strong></p><ul><li>G1最大的特点是<strong>引入分区的思路，弱化了分代的概念。</strong></li><li><strong>合理利用垃圾收集各个周期的资源</strong>，解决了其他收集器、甚至 CMS 的众多缺陷</li></ul><p><strong>G1 相比较 CMS 的改进：</strong></p><ul><li><strong>算法</strong>： G1 基于标记—整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。</li><li><strong>停顿时间可控</strong>： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。</li><li><strong>并行与并发</strong>：G1 能更充分的利用 <strong>CPU 多核环境下的硬件优势</strong>，来缩短 stop the world 的停顿时间。</li></ul><h2 id="12-GC只会对堆进行GC吗？"><a href="#12-GC只会对堆进行GC吗？" class="headerlink" title="12.GC只会对堆进行GC吗？"></a>12.GC只会对堆进行GC吗？</h2><p>JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。</p><ol><li><strong>堆（Heap）：</strong> 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，因为大多数对象都会被分配在堆上，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。</li><li><strong>方法区（Method Area）：</strong> 方法区是用于<strong>存储类信息、常量、静态变量</strong>等数据的区域。虽然方法区中的垃圾回收与堆有所不同，<strong>但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。</strong></li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/jvm/">jvm</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM-java虚拟机</title>
      <link>https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/</link>
      <guid>https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/</guid>
      <pubDate>Sat, 24 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;JVM 是 Java Virtual Machine</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p> JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。<strong>它直接和操作系统进行交互</strong>，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" alt=""></p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进 JVM 里面来。</p><p><img src="https://static001.geekbang.org/infoq/2f/2f012fde94376f43a25dbe1dd07e0dd8.png" alt=""></p><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p><p>类加载器将 .class 文件搬过来就是先丢到这一块上</p><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系</p><p><strong>程序计数器</strong>主要就是完成一个<strong>加载工作</strong>，类似于一个指针一样的，指向<strong>下一行我们需要执行的代码。和栈一样</strong>，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p><p><img src="https://static001.geekbang.org/infoq/c6/c602f57ea9297f50bbc265f1821d6263.png" alt=""></p><p>而 JVM 的调优主要就是围绕堆，栈两大块进行</p><p>线程共享区就是线程不安全的区域</p><p>执行过程：</p><p>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</p><p>JVM 找到 App 的主程序入口，执行 main 方法</p><p>这个 main 中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</p><p>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</p><p>执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</p><p>执行 sayName()</p><p>只需要知道对象实例初始化时会去<strong>方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</strong></p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>之前也提到了它是<strong>负责加载.class 文件</strong>的，它们在文件开头会有特定的文件标示，<strong>将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，</strong>并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</p><p>从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><ol><li><p>将 class 文件加载到内存</p></li><li><p>将静态数据结构转化成方法区中运行时的数据结构</p></li><li><p>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</p></li><li><p>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，<strong>其实就是一个安全检查</strong></p></li><li><p>准备：<strong>为 static 变量在方法区中分配内存空间，设置变量的初始值</strong>，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</p></li><li><p>解析：虚拟机将<strong>常量池内的符号引用替换为直接引用的过程</strong>（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，<strong>直接引用就是指针或者对象地址</strong>，注意引用对象一定是在内存进行）</p></li><li><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由<strong>编译器收集</strong>，<strong>顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句</strong>。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，<strong>初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</strong></p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p></blockquote></li></ol><p>8.GC 将无用对象从内存中卸载</p><h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p>加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li>BootStrap ClassLoader：rt.jar</li><li>Extension ClassLoader: 加载扩展的 jar 包</li><li>App ClassLoader：指定的 classpath 下面的 jar 包</li><li>Custom ClassLoader：自定义的类加载器</li></ol><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，<strong>而是委派给父类去完成</strong>，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，<strong>只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</strong></p><p>这样做的好处是，<strong>加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader</strong> 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 <code>java.lang.String</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">public class String &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p><hr><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><h2 id="本地方法栈和程序计数器"><a href="#本地方法栈和程序计数器" class="headerlink" title="本地方法栈和程序计数器"></a>本地方法栈和程序计数器</h2><p>比如说我们现在点开 Thread 类的源码，会看到它的 start0 方法带有一个 native 关键字修饰，而且不存在方法体，<strong>这种用 native 修饰的方法就是本地方法</strong>，这是使用 C 来实现的，<strong>然后一般这些方法都会放到一个叫做本地方法栈的区域。</strong></p><p>程序计数器其实就是<strong>一个指针</strong>，它指向了<strong>我们程序中下一句需要执行的指令</strong>，<strong>它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。</strong>这个内存仅代表<strong>当前线程所执行的字节码的行号指示器</strong>，字节码解析器通过<strong>改变这个计数器的值选取下一条需要执行的字节码指令。</strong></p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要的作用是<strong>存放类的元数据信息</strong>，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h2 id="虚拟机栈和虚拟机堆"><a href="#虚拟机栈和虚拟机堆" class="headerlink" title="虚拟机栈和虚拟机堆"></a>虚拟机栈和虚拟机堆</h2><p>一句话便是：<strong>栈管运行，堆管存储</strong>。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>它是 Java 方法执行的<strong>内存模型</strong>。里面会对<strong>局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。</strong>同时如果我们听到局部变量表，那也是在说虚拟机栈</p><p>如果线程请求的<strong>栈的深度大于虚拟机栈的最大深度</strong>，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，<strong>放到 Java 中其实就是方法</strong>，它也是存放在栈中的。</p><p>栈中的<strong>数据都是以栈帧</strong>的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。<strong>它是一个先进后出，后进先出原则。</strong></p><p>局部变量表用于存放<strong>方法参数和方法内部所定义的局部变量</strong>。它的容量是以 Slot 为最小单位，<strong>一个 slot 可以存放 32 位以内的数据类型</strong>。</p><p>虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，范围为 <code>[0,局部变量表的 slot 的数量]</code>。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，<strong>这些 slot 是可以复用的</strong>，<strong>当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。</strong>当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 <strong>-XX:+UsePSAdaptiveSurvivorSizePolicy</strong> 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。<strong>非堆内存其实我们已经说过了，就是方法区</strong>。在 1.8 中已经移除永久代，<strong>替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MetaspaceSize：初始化元空间大小，控制发生GC</span><br><span class="line">MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</span><br></pre></td></tr></table></figure><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><p><strong>年轻代：：：：</strong></p><p>当我们 new 一个对象后，会先放到 Eden 划分出来的<strong>一块作为存储空间的内存，</strong>但是我们知道对堆内存是线程共享的，<strong>所以有可能会出现两个对象共用一个内存的情况</strong>。这里 JVM 的处理是<strong>为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB，</strong>有兴趣可以了解一下</p><p>修正：当 Eden 区内存空间满了的时候，就会触发 <strong>Minor GC</strong>，Survivor0 区满不会触发 Minor GC 。</p><p><strong>那 Survivor0 区 的对象什么时候垃圾回收呢？</strong></p><p>假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，<strong>此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换</strong></p><p><strong>老年代</strong>：：：：：</p><p>老年代是<strong>存储长期存活的对象</strong>的，占满时就会触发我们最常听说的 <strong>Full GC</strong>，<strong>期间会停止所有线程等待 GC 的完成</strong>。所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p><p><strong>而且当老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 OOM</strong>，这时候就是<strong>虚拟机中的堆内存不足</strong>，原因可能会是堆内存设置的<strong>大小过小</strong>，这个可以通过参数-Xms、-Xmx 来调整。<strong>也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</strong></p><p><img src="https://static001.geekbang.org/infoq/39/398255141fde8ba208f6c99f4edaa9fe.png" alt=""></p><p><strong>回收：：：：</strong></p><p><img src="https://static001.geekbang.org/infoq/1b/1ba7f3cff6e07c6e9c6765cc4ef74997.png" alt=""></p><p>图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而 Java 堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，<strong>计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</strong></p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的 <strong>GC ROOTS</strong> 作为起始的存活对象集，<strong>从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言</strong>，例如 Java，C#等都是靠这招去判定对象是否存活的。</p><p>3.<strong>终结器</strong>（Finalizer）：如果对象重写了<code>finalize()</code>方法，垃圾回收器会在回收该对象之前调用<code>finalize()</code>方法，对象可以在<code>finalize()</code>方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。这个类似于try-catch-finally中的finally</p><p>一个对象的 finalize()方法只会被<strong>系统自动调用一次</strong>，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。</p><p>补充一句：并不提倡在程序中调用 finalize()来进行自救。<strong>建议忘掉 Java 程序中该方法的存在。</strong>因为它执行的时间不确定，甚至是否被执行也不确定（Java 程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java9 中已经被标记为 <strong>deprecated</strong> ，且 <code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 <code>finalize</code> 来的更加的轻量及可靠。</p><hr><p>在 Java 语言汇总能作为 GC Roots 的对象分为以下几种：</p><ol><li>虚拟机栈（栈帧中的本地方法表）中引用的对象（<strong>局部变量</strong>）</li><li>方法区中静态变量所引用的对象（<strong>静态变量</strong>）</li><li>方法区中<strong>常量引用的对象</strong></li><li><strong>本地方法栈（即 native 修饰的方法）中 JNI 引用的对象</strong>（JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li>已启动的且未终止的 Java 线程</li></ol><p>这种方法的优点是能够<strong>解决循环引用的问题</strong>，可它的实现需要耗费大量资源和时间，也需要 GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果<strong>对象进行可达性分析之后没发现与 GC Roots 相连的引用链</strong>，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。<strong>如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</strong></li><li>GC 对 F-Queue 队列中的对象进行二次标记。<strong>如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</strong></li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p><hr><h1 id="垃圾回收算法（GC）"><a href="#垃圾回收算法（GC）" class="headerlink" title="垃圾回收算法（GC）"></a>垃圾回收算法（GC）</h1><h2 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。1.8之后改为元空间（方法区）</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt=""></p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把<strong>新生代的对象提前转移到老年代中去</strong>，老年代上的空间足够存放 <code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>大对象就是需要<strong>大量连续内存空间的对象</strong>（比如：字符串、数组）。</p><p>大对象直接进入老年代的行为是由<strong>虚拟机动态决定</strong>的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p><ul><li>G1 垃圾回收器会根据 <code>-XX:G1HeapRegionSize</code> 参数设置的堆区域大小和 <code>-XX:G1MixedGCLiveThresholdPercent</code> 参数设置的阈值，来决定哪些对象会直接进入老年代。</li><li>Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(<code>XX:ThresholdTolerance</code>是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。</li></ul><p>既然虚拟机采用了<strong>分代收集</strong>的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，<strong>虚拟机给每个对象一个对象年龄（Age）计数器。</strong></p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(<strong>Eden 区-&gt;Survivor 区后对象的初始年龄变为 1</strong>)。</p><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 <strong>survivor 区的 50% 时</strong>（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，）取这个年龄和 MaxTenuringThreshold 中更小的一个值，<strong>作为新的晋升年龄阈值”。</strong></p><p><strong>默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对<strong>老年代进行垃圾收集</strong>。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>空间分配担保是为了<strong>确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</strong></p><p>JDK 6 Update 24 之前，<strong>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，<strong>则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</strong></p><p>JDK 6 Update 24 之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>，就会进行 Minor GC，否则将进行 Full GC。</p><h2 id="对象死亡的判断方法"><a href="#对象死亡的判断方法" class="headerlink" title="对象死亡的判断方法"></a>对象死亡的判断方法</h2><h3 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h3><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p><p>例子：</p><p>如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。<strong>但是他们因为互相引用对方，导致它们的引用计数器都不为 0</strong>，于是引用计数算法无法通知 GC 回收器回收他们。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机<strong>栈(栈帧中的局部变量表)中引用的对象</strong></li><li><strong>本地方法栈(Native 方法)中引用的对象</strong></li><li>方法区中<strong>类静态属性</strong>引用的对象</li><li>方法区中<strong>常量</strong>引用的对象</li><li>所有<strong>被同步锁</strong>持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><p>然后要进行两次标记之后，才会真正给他回收了</p><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果<strong>对象进行可达性分析之后没发现与 GC Roots 相连的引用链</strong>，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。<strong>如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</strong></li><li>GC 对 F-Queue 队列中的对象进行二次标记。<strong>如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</strong></li></ol><h3 id="使用终结器"><a href="#使用终结器" class="headerlink" title="使用终结器"></a>使用终结器</h3><p>但是他嗯，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。</p><h2 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h2><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱），<strong>强引用就是 Java 中普通的对象</strong>，而软引用、弱引用、虚引用在 JDK 中定义的类分别是 <code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>就是程序代码中普遍存在的引用赋值，这是使用最普遍的引用，其代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 <strong>OutOfMemoryError</strong> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。软引用代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p><p><strong>软引用可以和一个引用队列</strong>（ReferenceQueue）联合使用，<strong>如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</strong></p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line">str = <span class="literal">null</span>; <span class="comment">//str变成软引用，可以被收集</span></span><br></pre></td></tr></table></figure><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</strong>不过，由于垃圾回收器是<strong>一个优先级很低</strong>的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p><strong>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</strong></p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> <strong>虚引用必须和引用队列（ReferenceQueue）联合使用。</strong>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，<strong>那么就可以在所引用的对象的内存被回收之前采取必要的行动。</strong></p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><p><strong>1.为什么软引用可以防止内存溢出</strong></p><p>减轻内存压力：</p><p>软引用对象在内存紧张时会被 GC 回收，这意味着,对于一些<strong>缓存型对象</strong>（如图片缓存、数据缓存）：</p><ul><li>使用软引用能让 JVM 在不影响系统运行的前提下<strong>自动清理不重要的对象</strong>；</li><li>避免这些对象<strong>一直占用内存</strong>导致 OOM（OutOfMemoryError）。</li></ul><p>有利于缓存系统的实现：</p><p>比如在图片浏览器、数据库连接池、网页浏览器中，常常需要缓存大量数据；使用软引用作为缓存的基础可以确保：</p><ul><li>缓存不会<strong>占用过多堆内存</strong>；</li><li>系统空闲时缓存仍可用；</li><li>一旦内存紧张，<strong>缓存自动释放</strong>，系统依旧安全运行。</li></ul><p>相比强引用更灵活、相比弱引用更安全</p><div class="table-container"><table><thead><tr><th>引用类型</th><th>回收时机</th><th>是否适合做缓存</th><th>对系统安全性的影响</th></tr></thead><tbody><tr><td>强引用</td><td>永不回收（除非没有引用）</td><td>❌ 会导致 OOM</td><td>高风险</td></tr><tr><td>弱引用</td><td>GC 时就回收</td><td>⚠️ 不适合</td><td>稳定但易失效</td></tr><tr><td>软引用</td><td>内存不足时回收</td><td>✅ 非常适合</td><td>✅ 安全可靠</td></tr></tbody></table></div><p>为什么弱引用/虚引用用得少？</p><p><strong>弱引用</strong>：一旦 GC 触发，不管内存够不够都会被回收，<strong>太激进，不适合缓存</strong>；</p><p><strong>虚引用</strong>：更偏底层，<strong>用于监控对象被回收的时机</strong>，不具备访问能力，<strong>需要配合 ReferenceQueue 使用</strong>，复杂度高。</p><h2 id="判断是不是该废弃"><a href="#判断是不是该废弃" class="headerlink" title="判断是不是该废弃"></a>判断是不是该废弃</h2><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><blockquote><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，<strong>如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量</strong>，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类所有的<strong>实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</strong></li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在<strong>任何地方被引用</strong>，<strong>无法在任何地方通过反射访问该类的方法。</strong></li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：<strong>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</strong></p><p>它是最<strong>基础</strong>的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p><ol><li>当一个对象被创建时，给一个标记位，假设为 0 (false)；</li><li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</li><li>扫描阶段清除的就是标记位为 0 (false)的对象。</li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。<strong>它可以将内存分为大小相同的两块，每次使用其中的一块。</strong>当这一块的内存使用完后，<strong>就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</strong>这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果<strong>存活对象数量比较大，复制性能会变得很差</strong>。</li></ul><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记-整理（Mark-and-Compact）算法是根据<strong>老年代</strong>的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<strong>而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</strong></p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-compact-garbage-collection-algorithm.png" alt=""></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在<strong>新生代</strong>中，每次收集都会有大量对象死去，<strong>所以可以选择“复制”算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，<strong>所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8: <strong>Parallel Scavenge（新生代）+ Parallel Old（老年代）</strong></li><li>JDK 9 ~ JDK22: <strong>G1</strong></li></ul><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>Serial<strong>（串行）收集器</strong>是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，<strong>更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png" alt="Serial 收集器"></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。<strong>Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</strong></p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/parnew-garbage-collector.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，<strong>只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</strong></p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上</li></ul><h3 id="Parallerl-Scavenge"><a href="#Parallerl-Scavenge" class="headerlink" title="Parallerl Scavenge"></a>Parallerl Scavenge</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure><p>Parallel Scavenge 收集器关注点是<strong>吞吐量（高效率的利用 CPU）</strong>。CMS 等垃圾收集器的关注点更多的是<strong>用户线程的停顿时间</strong>（提高用户体验）。所谓吞吐量就是 <strong>CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值</strong>。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，<strong>使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png" alt=""></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">262921408</span> -XX:MaxHeapSize=<span class="number">4206742528</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_211</span>-b12)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.211</span>-b12, mixed mode)</span></span><br></pre></td></tr></table></figure><p>JDK1.8 默认使用的是 <strong>Parallel Scavenge + Parallel Old</strong>，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：<strong>一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png" alt="Serial 收集器"></p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 短暂停顿，<strong>标记直接与 root 相连的对象（根对象）；</strong></li><li><strong>并发标记：</strong> <strong>同时开启 GC 和用户线程</strong>，用一个<strong>闭包结构</strong>去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。<strong>所以这个算法里会跟踪记录这些发生引用更新的地方。</strong></li><li><strong>重新标记：</strong> 重新标记阶段就是为了<strong>修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png" alt="CMS 收集器"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><p><strong>CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。</strong></p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：<strong>G1 能充分利用 CPU、多核环境下的硬件优势</strong>，使用多个 CPU（CPU 或者 CPU 核心）来缩短 <strong>Stop-The-World 停顿时间</strong>(暂停其他的线程)。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，<strong>G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</strong></li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了<strong>分代</strong>的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</strong></li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，<strong>但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</strong>。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong>： 短暂停顿（Stop-The-World，STW），<strong>标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象</strong></li><li><strong>并发标记</strong>：<strong>与应用并发运行</strong>，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</li><li><strong>最终标记</strong>： 短暂停顿（STW），<strong>处理并发标记阶段结束后残留的少量未处理的引用变更。</strong></li><li><strong>筛选回收</strong>：根据标记结果，<strong>选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。</strong></li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png" alt="G1 收集器"></p><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，<strong>保证了 G1 收集器在有限时间内可以尽可能高的收集效率</strong>（把内存化整为零）。</p><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>与 CMS 中的 ParNew 和 G1 类似，<strong>ZGC 也采用标记-复制算法</strong>，不过 ZGC 对该算法做了重大改进。</p><p><strong>ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。</strong></p><p>ZGC 在 Java11 中引入，处于试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java15 已经可以正式使用了。</p><p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启用 ZGC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseZGC className</span><br></pre></td></tr></table></figure><p>在 Java21 中，<strong>引入了分代 ZGC，暂停时间可以缩短到 1 毫秒以内。</strong></p><p>你可以通过下面的参数启用分代 ZGC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseZGC -XX:+ZGenerational className</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/infoq/9f/9ff72176ab0bf58bc43e142f69427379.png" alt=""></p><h1 id="JVM-的常用参数"><a href="#JVM-的常用参数" class="headerlink" title="JVM 的常用参数"></a>JVM 的常用参数</h1><div class="table-container"><table><thead><tr><th>参数名</th><th>作用描述</th><th>示例值/说明</th></tr></thead><tbody><tr><td><code>-Xms</code></td><td>初始堆内存大小</td><td><code>-Xms512m</code></td></tr><tr><td><code>-Xmx</code></td><td>最大堆内存大小</td><td><code>-Xmx1024m</code></td></tr><tr><td><code>-Xmn</code></td><td>新生代大小（控制 Eden + Survivor 区）</td><td><code>-Xmn256m</code></td></tr><tr><td><code>-XX:PermSize</code>（JDK 8 前）</td><td>初始永久代大小（方法区）</td><td><code>-XX:PermSize=128m</code></td></tr><tr><td><code>-XX:MaxPermSize</code>（JDK 8 前）</td><td>最大永久代大小</td><td><code>-XX:MaxPermSize=256m</code></td></tr><tr><td><code>-XX:MetaspaceSize</code>（JDK 8+）</td><td>元空间初始大小</td><td><code>-XX:MetaspaceSize=128m</code></td></tr><tr><td><code>-XX:MaxMetaspaceSize</code>（JDK 8+）</td><td>元空间最大大小</td><td><code>-XX:MaxMetaspaceSize=512m</code></td></tr><tr><td><code>-XX:+PrintGCDetails</code></td><td>输出 GC 详细信息</td><td>调试用</td></tr><tr><td><code>-XX:+UseSerialGC</code></td><td>使用串行垃圾收集器</td><td>适合单核或小内存环境</td></tr><tr><td><code>-XX:+UseParallelGC</code></td><td>使用并行收集器（吞吐量优先）</td><td>默认在 JDK 8</td></tr><tr><td><code>-XX:+UseG1GC</code></td><td>使用 G1 收集器（低延迟场景）</td><td>推荐在大内存、服务端场景中使用</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>Eden 与 Survivor 区大小比</td><td><code>-XX:SurvivorRatio=8</code></td></tr><tr><td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td><td>OOM 时导出内存快照</td><td>用于定位内存泄漏</td></tr><tr><td><code>-XX:HeapDumpPath</code></td><td>指定 heap dump 文件路径</td><td><code>-XX:HeapDumpPath=/tmp/dump.hprof</code></td></tr><tr><td><code>-Xss</code></td><td>设置每个线程的栈大小</td><td><code>-Xss256k</code></td></tr><tr><td><code>-XX:+PrintGCDateStamps</code></td><td>打印 GC 日志时附带时间戳</td><td>调试用</td></tr><tr><td><code>-XX:+UseCompressedOops</code></td><td>压缩对象指针（节省 64 位 JVM 内存）</td><td>默认开启</td></tr><tr><td><code>-Dkey=value</code></td><td>设置系统属性（常用于配置）</td><td>示例：<code>-Denv=prod</code></td></tr></tbody></table></div>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/jvm/">jvm</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络期末考试复习</title>
      <link>https://blog.tokenlen.top/2025/05/25/network/networktest/</link>
      <guid>https://blog.tokenlen.top/2025/05/25/network/networktest/</guid>
      <pubDate>Sat, 24 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h1&gt;&lt;h2 id=&quot;1-ARP&quot;&gt;&lt;a href=&quot;#1-ARP&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="1-ARP"><a href="#1-ARP" class="headerlink" title="1.ARP**"></a>1.ARP**</h2><p>ARP（地址解析协议）用于<strong>根据 IP 地址获取对应的 MAC 地址</strong>，<strong>是主机通信前</strong>必须完成的地址解析步骤；RARP（逆地址解析协议）则相反，<strong>用于根据已知的 MAC 地址获取 IP 地址</strong>，常用于无盘工作站启动时向网络请求 IP。ARP 常见于局域网通信，RARP 已被 DHCP 等协议取代。</p><p>其中的单播和广播</p><h2 id="2-CDN"><a href="#2-CDN" class="headerlink" title="2.CDN*"></a>2.CDN*</h2><p>内容分发网络，用于将<strong>内容缓存至离用户更近的节点</strong>，提高访问速度、降低延迟。</p><h2 id="3-CSMA"><a href="#3-CSMA" class="headerlink" title="3.CSMA"></a>3.CSMA</h2><p>载波监听多路访问，用于以太网的介质访问控制方式，通过“监听-发送”机制减少冲突。</p><h2 id="4-CRC"><a href="#4-CRC" class="headerlink" title="4.CRC*"></a>4.CRC*</h2><p><strong>循环冗余校验</strong>，链路层常用的差错检测机制，能发现传输过程中的数据错误。</p><h2 id="5-CSP"><a href="#5-CSP" class="headerlink" title="5.CSP"></a>5.CSP</h2><p>内容安全策略，用于防止 XSS 等网页攻击，浏览器通过该策略限制网页资源加载来源。</p><h2 id="6-MAC"><a href="#6-MAC" class="headerlink" title="6.MAC*"></a>6.MAC*</h2><p>媒体访问控制地址，是网卡的物理地址，也指链路层控制子层，用于网络访问管理。</p><h2 id="7-MAN"><a href="#7-MAN" class="headerlink" title="7.MAN"></a>7.MAN</h2><p>城域网，覆盖城市范围的计算机网络，规模介于局域网（LAN）和广域网（WAN）之间。</p><h2 id="8-MTU"><a href="#8-MTU" class="headerlink" title="8.MTU*"></a>8.MTU*</h2><p>最大传输单元，指网络层一次能够传输的最大数据报长度，影响分片与传输效率。</p><h2 id="9-NAT"><a href="#9-NAT" class="headerlink" title="9.NAT*"></a>9.NAT*</h2><p>网络地址转换，用于将私有 IP 映射为公网 IP，实现内网设备访问外网。</p><h2 id="10-NTP"><a href="#10-NTP" class="headerlink" title="10.NTP"></a>10.NTP</h2><p>网络时间协议，用于在互联网上同步主机时间1。</p><h2 id="11-RTT"><a href="#11-RTT" class="headerlink" title="11.RTT"></a>11.RTT</h2><p>RTT 是从发送方发出数据到接收方应答回来所经历的时间总和，衡量网络延迟。</p><h2 id="12-RIP"><a href="#12-RIP" class="headerlink" title="12.RIP"></a>12.RIP</h2><p>RIP 是一种基于跳数的内部网关协议，用于在自治系统内部传播路由信息。</p><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h2 id="1-http请求和响应报文"><a href="#1-http请求和响应报文" class="headerlink" title="1.http请求和响应报文"></a>1.http请求和响应报文</h2><p>分为起始行、头部字段和消息主体三部分</p><p>请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求行（Request Line）</span><br><span class="line">请求头（Request Headers）</span><br><span class="line">空行</span><br><span class="line">请求体（Request Body）【仅部分请求有，如 POST】</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常见请求头</strong>：Host、User-Agent、Accept、Content-Type、Authorization</p><p>响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态行（Status Line）</span><br><span class="line">响应头（Response Headers）</span><br><span class="line">空行</span><br><span class="line">响应体（Response Body）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常见响应头</strong>：Content-Type、Content-Length、Set-Cookie、Cache-Control</p><h2 id="2-网络体系结构"><a href="#2-网络体系结构" class="headerlink" title="2.网络体系结构"></a>2.网络体系结构</h2><p>OSI七层模型</p><p>每一层负责的职能都不同，如下：</p><ul><li>应用层，负责给应用程序提供统一的接口；</li><li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li><li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li><li>传输层，负责端到端的数据传输；</li><li>网络层，负责数据的路由、转发、分片；</li><li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li><li>物理层，负责在物理网络中传输数据帧；</li></ul><p>tcp/ip四层模型</p><ul><li>应用层 支持 HTTP、SMTP 等最终用户进程</li><li>传输层 处理主机到主机的通信（TCP、UDP）</li><li>网络层 寻址和路由数据包（IP 协议）</li><li>链路层 通过网络的物理电线、电缆或无线信道移动比特</li></ul><p>五层模型</p><h2 id="3-tcp-udp区别"><a href="#3-tcp-udp区别" class="headerlink" title="3.tcp/udp区别"></a>3.tcp/udp区别</h2><p><strong>TCP 面向连接、可靠传输，有三次握手和四次挥手机制</strong>，适用于对数据完整性要求高的场景；而 <strong>UDP 是无连接、尽最大努力交付、效率高但不保证可靠性</strong>，适合实时性要求高的应用如视频通话、DNS 查询等。</p><div class="table-container"><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>是（三次握手）</td><td>否</td></tr><tr><td>是否可靠</td><td>是（确认、重传）</td><td>否（尽力而为）</td></tr><tr><td>顺序保证</td><td>有</td><td>无</td></tr><tr><td>开销与速度</td><td>大、慢</td><td>小、快</td></tr><tr><td>典型应用场景</td><td>HTTP、FTP、SMTP 等</td><td>DNS、视频会议、VoIP 等</td></tr></tbody></table></div><ul><li>假定某UDP接收方对接收到的UDP报文段计算因特网检验和，并发现它与承载在检验和字段中的值<br>相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。</li></ul><p>不能，udp的错误检测机制不可能检测到所有的错误，不是百分比可靠的</p><ul><li>我们曾经说过，应用程序可能选择UDP作为运输协议，因为UDP提供了（比TCP）更好的应用层<br>控制，以决定在报文段中发送什么数据和发送时机。<br>a.应用程序为什么对在报文段中发送什么数据有更多的控制？<br>b-应用程序为什么对何时发送报文段有更多的控制？ </li></ul><p>因为udp是无连接的，没有建立连接维持连接结束连接的过程，可以自由自在的决定何时发送如何发送数据</p><p>udp无连接，没有流量控制和拥塞控制机制。可以在任何时间发送</p><h2 id="4-网络层的控制平面和数据平面"><a href="#4-网络层的控制平面和数据平面" class="headerlink" title="4.网络层的控制平面和数据平面"></a>4.网络层的控制平面和数据平面</h2><p>我们注意到网络层功能可被大体分成数据平面功能和控制平面功能。数据平面的主要功能是什么?控制平面的主要功能呢?</p><p>在网络层，<strong>控制平面</strong>负责“决策”——即如<strong>何选路</strong>（如路由协议 OSPF、BGP），而<strong>数据平面</strong>负责“转发”——<strong>即将数据包按照路由表实际转发出去</strong>。</p><p>控制平面构建和维护路由表，转发表，处理协议交互。</p><p>数据平面使用路由表完成转发，决定如何转发数据包。匹配数据包头部，转发或者丢弃修改数据。</p><p>网络层核心解决的问题是<strong>寻址与选路</strong>，相关知识包括 <strong>IP 地址划分、子网掩码、路由协议（静态/动态）、转发表、最长前缀匹配、NAT、ICMP</strong> 等，是理解网络通信的关键基础。</p><h2 id="5-RDT"><a href="#5-RDT" class="headerlink" title="5.RDT"></a>5.RDT</h2><p>在我们的rdt协议中，为什么需要引入序号?</p><p>在我们的rdt协议中，为什么需要引入定时器?</p><p>在 RDT（可靠数据传输）协议中，<strong>引入计时器是为了应对数据丢失或 ACK 丢失的情况，保证发送方能在超时后重传数据</strong>；<strong>对帧编号是为了解决数据重复、乱序等问题，使接收方能够识别每个数据帧的唯一性与顺序</strong>。这两个机制共同确保了在不可靠信道上传输的可靠性</p><h2 id="6-url解析的过程"><a href="#6-url解析的过程" class="headerlink" title="6.url解析的过程"></a>6.url解析的过程</h2><p><strong>浏览器输入 URL</strong><br> 如 <code>http://www.example.com/index.html</code></p><p><strong>DNS 解析</strong><br> 浏览器<strong>先查询本地缓存</strong>，没有则通过递归/迭代方式向 DNS 服务器请求，将域名（www.example.com）转换为<strong>对应的 IP 地址。</strong></p><p><strong>CDN 节点选择（如果启用 CDN）</strong></p><ul><li>DNS 返回的不是源站 IP，而是离用户最近的 CDN 边缘节点 IP。</li><li>用户请求会被引导到该 CDN 节点，减少跨域和长距离传输。</li></ul><p><strong>建立 TCP 连接</strong><br> 浏览器与 CDN 节点（或源站服务器）之间建立 TCP 连接（三次握手），若是 HTTPS，还会进行 TLS 握手。</p><p><strong>发送 HTTP 请求</strong><br> 浏览器发送请求报文，请求具体资源（如 index.html）。</p><p><strong>服务器/CDN 节点响应</strong></p><ul><li>CDN 节点若<strong>缓存命中</strong>，直接返回缓存内容。</li><li>缓存未命中时，<strong>CDN 节点向源站服务器请求资源，然后缓存后返回给用户。</strong></li></ul><p><strong>浏览器接收响应，渲染页面</strong><br> 浏览器解析 HTML，加载 CSS、JS、图片等资源，完成页面展示。</p><h2 id="7-ARP请求为什么是广播-应答为什么是单播"><a href="#7-ARP请求为什么是广播-应答为什么是单播" class="headerlink" title="7.ARP请求为什么是广播,应答为什么是单播"></a>7.ARP请求为什么是广播,应答为什么是单播</h2><p>ARP 请求采用广播的原因</p><p>未知目标 MAC 地址：ARP 请求的目的是通过 IP 地址 查询对应的 MAC 地址，但<strong>初始时并不知道目标设备的 MAC，因此必须广播到 局域网（LAN）内的所有设备</strong>，确保目标设备能收到请求。</p><p>广播域限制:ARP 仅在同一子网内生效，广播方式能覆盖该网络内的所有主机。</p><p>ARP 应答采用单播的原因</p><p>已知请求方的 MAC 地址：在 ARP 请求报文中，<strong>发送方已经填写了自己的 MAC 和 IP，因此目标设备可以直接 单播回复，</strong>无需再次广播。</p><p>减少网络流量：如果 ARP 应答也广播，<strong>会导致不必要的网络拥塞</strong>，而单播仅发送给请求方，更高效。</p><p>目标明确：ARP 应答的 目标 MAC 和 IP 直接取自 ARP 请求的 发送方字段，因此能精准送达。</p><h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><h2 id="ip地址划分"><a href="#ip地址划分" class="headerlink" title="ip地址划分"></a><strong>ip地址划分</strong></h2><p>主要是子网掩码的计算，还有是不是在一个网段里</p><p>其中广播地址全是1，网络地址全是0.然后/25代表网络号有多少，剩下的是主机号。主要是2^n的数量</p><h2 id="crc循环冗余校验"><a href="#crc循环冗余校验" class="headerlink" title="crc循环冗余校验"></a><strong>crc循环冗余校验</strong></h2><p>例题：</p><p>补的位数是除数位数-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原始数据:     1101</span><br><span class="line">补0后数据:    1101000</span><br><span class="line">除数 G:       1011</span><br><span class="line"></span><br><span class="line">第一轮:</span><br><span class="line">1101 XOR 1011 = 0110</span><br><span class="line">拼接 0 → 01100</span><br><span class="line"></span><br><span class="line">第二轮:</span><br><span class="line">1100 XOR 1011 = 0111</span><br><span class="line">拼接 0 → 01110</span><br><span class="line"></span><br><span class="line">第三轮:</span><br><span class="line">1110 XOR 1011 = 0101</span><br><span class="line"></span><br><span class="line">最终CRC校验码 = 最后结果的后三位 = 101</span><br><span class="line">最终发送数据 = 原始数据 + 校验码 = 1101 101</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后原始数据+crc校验码=最终数据</p><p><strong>D(x)</strong> = 1010101010</p><p> <strong>G(x)</strong> = 10011</p><p>求最终：</p><p>余数为0100</p><p>然后相加即可</p><h2 id="二进制回退算法，等多少时间-发生了几次碰撞"><a href="#二进制回退算法，等多少时间-发生了几次碰撞" class="headerlink" title="二进制回退算法，等多少时间,发生了几次碰撞"></a><strong>二进制回退算法，等多少时间,发生了几次碰撞</strong></h2><p>最大是10 在[0…2^n- 1]中任意选一个数，这就是等待时间。是CSMA/CD的关键组成</p><p>在CSMA/CD中，在第5次碰撞后，节点选择K =4的概率有多大？结果K=4在10Mbps以太网上对<br>应于多少秒的时延？</p><p>2^5-1=31,然后0-31有32个数，概率为1/32</p><p>然后等待时间=K×slot time</p><p>以太网标准中：</p><ul><li>10 Mbps 的以太网 ⇒ slot time = <strong>512 bit times</strong></li><li>每 bit 时间 = 1 / 10,000,000 = <code>0.1 μs</code></li><li>所以：</li></ul><script type="math/tex; mode=display">Slot time=512×0.1μs=51.2μs</script><script type="math/tex; mode=display">Delay=4×51.2μs=204.8μs=0.0002048 秒</script><h2 id="TCP计算"><a href="#TCP计算" class="headerlink" title="TCP计算"></a>TCP计算</h2><p>考虑仅有一条单一的TCP （Reno）连接使用一条10Mbps链路，且该链路没有缓存任何数据。假设<br>这条链路是发送主机和接收主机之间的唯一拥塞链路。假定某TCP发送方向接收方有一个大文件要<br>发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个TCP报文段长度为1500<br>字节；该连接的双向传播时延是150ms；并且该TCP连接总是处于拥塞避免阶段，即忽略了慢<br>启动。<br>a.这条TCP连接能够取得的最大窗口长度（以报文段计）是多少？<br>b. 这条TCP连接的平均窗口长度（以报文段计）和平均吞吐量（以bps计）是多少？<br>c. 这条TCP连接在从丢包恢复后，再次到达其最大窗口要经历多长时间？</p><p>最大窗口大小（报文段） = <strong>带宽 × RTT / MSS</strong></p><script type="math/tex; mode=display">10Mbps×0.15s=1.5Mb=1,500,000bit</script><p>报文段大小 MSS=12,000 bit</p><p>所以<strong>最大窗口长度</strong>为125</p><p><strong>平均窗口大小</strong>为：平均窗口长度=w/2+w/4=3/4*w，带入报文窗口为125，等于93.75个报文段</p><p><strong>平均吞吐量</strong>（bps）：平均窗口大小 × MSS / RTT = 7,500,000 bps=7.5 Mbps</p><p>每 RTT 将窗口增加 1 个报文段，丢包发生时窗口减半：从 <code>W</code> 降到 <code>W/2</code>，要从 <code>W/2</code> 增长到 <code>W</code>，需增加 <code>W/2</code> 个报文段。RTT*w/2=9.375</p><p><strong>考虑从主机 A 向主机 B 传输一个大小为 LLL 字节的大文件，假设：</strong></p><ul><li>每个 TCP 报文段的最大报文段大小 MSS = 536 字节</li><li>TCP 序号字段占 4 字节（即 32 位）</li><li>每个报文段附加运输层、网络层和链路层首部共计 66 字节</li><li>使用一条速率为 155 Mbps 的链路</li><li>忽略拥塞控制与流量控制，即主机 A 可连续不断地发送数据</li></ul><p>TCP 最大允许传输字节数=2^32=4GB</p><p>传输该文件的最短时间:</p><p>报文段数量=4GB/536=8,013,297</p><p>每个报文段大小（含头部）=536+66=602</p><p>总发送比特数:8,013,297×602×8=38,562,998,592 bit</p><p>t=总发送比特数/155 *10^6=248.76 秒</p><p><strong>假设主机A通过一条TCP连接向主机B</strong>发送两个紧接着的TCP报文段°第一个报文段的序号为90,<br>第二个报文段序号为110</p><p>a.第一个报文段中有多少数据? <strong>20</strong><br>b.假设第一个报文段丢失而第二个报文段到达主机B。那么在主机B发往主机A的确认报文中,<br>确认号应该是多少？ <strong>90</strong></p><p>假设某应用每20ms生成一个40字节的数据块，每块封装在一个TCP报文段中，TCP报文段再封装<br>在一个IP数据报中。每个数据报的开销有多大？应用数据所占百分比是多少？  </p><div class="table-container"><table><thead><tr><th>协议层</th><th>头部大小</th></tr></thead><tbody><tr><td>TCP</td><td>20 字节</td></tr><tr><td>IP</td><td>20 字节</td></tr></tbody></table></div><p>总大小为40+20+20=80</p><p>占50%</p><p>考虑向具有700字节MTU的一条链路发送一个2400字节的数据报。假定初始数据报标有标识号<br>422。将会生成多少个分片？在生成相关分片的数据报中各个字段的值是多少?</p><p>IP头部占20字节，所以最多是680字节</p><p>总数据为2400-20=2380</p><p>2380/680=3.5，所以需要四个分片</p><h2 id="反码："><a href="#反码：" class="headerlink" title="反码："></a><strong>反码</strong>：</h2><p>UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110,<br>01110100.这些8比特字节和的反码是多少？（注意到尽管UDP和TCP使用16比特的字来计算检验<br>和，但对于这个问题，你应该考虑8比特和。）写岀所有工作过程。UDP为什么要用该和的反码，即<br>为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 1比特的差错将可能检测不出<br>来吗？ 2比特的差错呢？</p><p>逐个相加，但需注意 <strong>溢出的进位（carry）要加回</strong></p><p>可以先全转为十进制得到301，然后转为2进制，发现为9位超了。然后再回绕，把高位的1加到低位里面</p><p>就是45+1=46然后转为2进制取反</p><p>得到<strong>11010001</strong></p><p>或者是直接二进制运算，但是注意也是要回退的，11的时候返回0，进位1</p><h2 id="网络时延"><a href="#网络时延" class="headerlink" title="网络时延"></a>网络时延</h2><p>考虑两台主机 A 和 B 由一条速率为 <strong>R bps</strong> 的链路相连，两主机间距离为 <strong>m 米</strong>，链路的<strong>传播速率</strong>为 <strong>s 米/秒</strong>。主机 A 向 B 发送一个长度为 <strong>L 比特</strong> 的分组。</p><p>传播时延=m/s</p><p>传输时延=L/R</p><p>忽略排队时延，端到端的延时表达式=m/s+L/R</p><p>若主机 A 在时刻 0 开始传输分组，在 L/R 时，最后一个比特在哪？最后一个比特<strong>刚刚离开 A</strong>，还在链路起点，尚未传播。</p><p>若传播时延&gt;传输时延的时候，t=L/R的时候，第一个比特在哪？</p><p>第一个比特尚未到达 B，正在链路上传播中，位置为：s*L/R</p><p>反过来呢，第一个bit已经到达了B</p><p><strong>那么再加上排队时延和缓存呢？</strong></p><p>总时延=处理时延+排队时延+m/s+L/R</p><p><strong>缓存大小</strong>主要影响的是：</p><ul><li><strong>排队时延（<code>d_queue</code>）是否为 0 或变大</strong></li><li>当链路缓冲区已满，新的分组将被丢弃（产生丢包）→ 导致<strong>TCP重传、拥塞控制触发</strong></li></ul><p><strong>你点击了一个超链接</strong> </p><ul><li><strong>本地没有 DNS 缓存</strong>，必须<strong>依次查询 n 个 DNS 服务器</strong></li><li><strong>HTML 页面只包含一个对象</strong>，<strong>对象传输时间忽略</strong></li><li>用 RTT1,RTT2,…,RTTnRTT_1, RTT_2, …, RTT_nRTT1,RTT2,…,RTTn 表示 DNS 查询链每一跳的往返时延</li><li>RTT0RTT_0RTT0 表示浏览器与目标服务器（Web服务器）之间的 RTT</li></ul><p><strong>总时延=DNS+2*RTT</strong></p><p>然后dns是需要递归的就是RTT1+RTT2。。。到RTTN,然后tcp是一个RTT0,http是第二个RTT0</p><p>考虑图3・58。假设TCP Reno是一个经历如上<br>所示行为的协议，回答下列问题。在各种情<br>况中，简要地论证你的回答。<br>指出TCP慢启动运行时的时间间隔。<br>指出TCP拥塞避免运行时的时间间隔。<br>在第16个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测岀<br>来的？ ~<br>在第22个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测出<br>来的？<br>在第1个传输轮回里，ssthresh的初始值设置为多少？<br>在第18个传输轮回里，ssthresh的值设置为多少？<br>在第24个传输轮回里，ssthresh的值设置为多少？<br>h. 在哪个传输轮回内发送第70个报文段？<br>i. 假定在第26个传输轮回后，通过收到3个冗余ACK检测出有分组丢失，拥塞的窗口长度和<br>ssthresh的值应当是多少？<br>j. 假定使用TCP Tahoe （而不是TCP Reno）,并假定在第16个传输轮回收到3个冗余ACK。在第19<br>个传输轮回，ssthresh和拥塞窗口长度是什么？</p><p>k.再次假设使用TCP Tahoe,在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传<br>输轮回（包括这两个传输轮回），一共发送了多少分组？</p><ul><li>考虑互联3个子网（子网1、子网2和子网3）的一台路由器。假定这3个子网的所有接口要求具有<br>前缀223.1.17/24。还假定子网1要求支持多达60个接口，子网2要求支持多达90个接口，子网3<br>要求支持多达12个接口。提供3个满足这些限制的网络地址（形式为a. b.c.d/x）o</li><li>考虑一个具有前缀12&amp; 119. 40. 128/26的子网。给出能被分配给该网络的一个IP地址（形式为<br>xxx. XXX. xxx. xxx）的例子o假定一个ISP拥有形式为12&amp; 119. 40. 64/26的地址块。假定它要从该地<br>址块生成4个子网，每块具有相同数量的IP地址。这4个子网（形式为a. b. c. d/x）的前缀是什么?</li><li>考虑在图4-25中建立的网络。假定ISP现在为路由器分配地址24.34.112.235,家庭网络的网络地<br>址是 192. 16&amp; 1/24。<br>a.在家庭网络中为所有接口分配地址。<br>P17.<br>b.假定每台主机具有两个进行中的TCP连接，所有都是针对主机128.119. 40. 86的80端口的。在<br>NAT转换表中提供6个对应表项。</li></ul><p>•如图6・33所示，考虑通过两台路由器互联的3个局域网。<br>a. 对所有的接口分配IP地址。对子网1使用形式为192. 168. 1. xxx的地址，对子网2使用形式为</p><p>xxx的地址，对子网3使用形式为192. 16&amp; 3. xxx的地址。<br>b. 为所有的适配器分配MAC地址。<br>c. 考虑从主机E向主机B发送一个1P数据报。假设所有的ARP表都是最新的。就像在6.4.1节中<br>对单路由器例子所做的那样，列举出所有步骤。<br>d. 重复（c）,现在假设在发送主机中的ARP表为空（并且其他表都是最新的）。</p><h1 id="综合题目"><a href="#综合题目" class="headerlink" title="综合题目"></a>综合题目</h1><h2 id="CSMA-CD-课件6-P33"><a href="#CSMA-CD-课件6-P33" class="headerlink" title="CSMA/CD(课件6 P33)"></a>CSMA/CD(课件6 P33)</h2><p><img src="C:\Users\ikeife\AppData\Roaming\Typora\typora-user-images\image-20250529135805545.png" alt="image-20250529135805545"></p><p><img src="C:\Users\ikeife\AppData\Roaming\Typora\typora-user-images\image-20250529135812262.png" alt="image-20250529135812262"></p><p>网卡接受来自网络层的数据报，并生成帧。</p><p>如果网卡检测到信道空闲，则开始帧的传输，如果信道繁忙，就等到空闲的时候再继续传输</p><p>如果网卡传输了整个帧，但是没有检测另一个帧。网卡将先完成帧的传输</p><p>如果网卡在传输过程中，遇到了另一个传输，将会中止并发送干扰信号</p><p>终止后，网卡将进入二进制回退：</p><p>​    在经历m次碰撞后，网卡在0…2^m-1中任意选择K，网卡将会等待k*512位使劲按</p><p>​    更长的实践回避，避免更多冲突</p><p>Ttorp=LAN中两个节点直接的最大传播延迟</p><p>ttans=最大传输尺寸帧的时间</p><p>效率就是那个公式</p><h2 id="bob-cdn"><a href="#bob-cdn" class="headerlink" title="bob cdn"></a>bob cdn</h2><p><img src="C:\Users\ikeife\AppData\Roaming\Typora\typora-user-images\image-20250529135827082.png" alt="image-20250529135827082"></p><p>bob从网页的url中获取视频的url，解析视频url到本地的dns，返回的是一个cdn地址。</p><p>本地dns继续递归解析cdn url像cdn的权威服务器请求，获取离bob最近的cdn节点的ip地址</p><p>浏览器向最近的cdn节点发送http请求。</p><p><img src="C:\Users\ikeife\AppData\Roaming\Typora\typora-user-images\image-20250529135831982.png" alt="image-20250529135831982"></p><p><img src="C:\Users\ikeife\AppData\Roaming\Typora\typora-user-images\image-20250529135844667.png" alt="image-20250529135844667"></p><h1 id="重点题目"><a href="#重点题目" class="headerlink" title="重点题目"></a>重点题目</h1><ul><li>描述应用程序开发者为什么可能选择在UDP上运行应用程序而不是在TCP上运行的原因</li></ul><p>由于 UDP 是无连接的传输协议，不需要建立连接、无需三次握手，也不进行确认应答和重传机制，因此适合对时效性要求高、可以容忍少量数据丢失的应用场景，如视频会议、在线游戏、实时语音通信等。此外，UDP 的协议开销更小，资源消耗更低，适合需要快速传输小数据包的轻量级应用。</p><ul><li>当某应用程序运行在UDP上时，该应用程序可能得到可靠数据传输吗？如果能，如何实现？</li></ul><p><strong>可以通过在应用层自行设计机制</strong>来实现可靠传输。具体做法包括：为每个数据包添加序号以便接收方能检测是否有丢包、重复包或乱序数据，并利用应答机制（ACK）让接收方告知发送方哪些数据已成功收到；如果发送方在一定时间内未收到 ACK，则可以重传数据包。此外，还可以设置超时重传、滑动窗口、流量控制等机制来进一步增强可靠性</p><ul><li>假定在主机C端口 80上运行的一个Web服务器。假定这个Web服务器使用持续连接，并且正在接 收来自两台不同主机A和B的请求。被发送的所有请求都通过位于主机C的相同套接字吗？如果它 们通过不同的套接字传递，这两个套接字都具有端口 80吗？讨论和解释之：</li></ul><p><strong>会将来自主机 A 和主机 B 的请求都通过同一个套接字处理</strong>。虽然所有请求最初都是通过 <strong>端口 80</strong> 到达服务器的，但操作系统会为每一个客户端连接创建一个 <strong>新的套接字（socket）</strong> 来进行实际通信。</p><ul><li><p>通过一条TCP连接向主机B发送两个紧接着的TCP报文段°第一个报文段的序号为90,<br>第二个报文段序号为110</p><p>第一个报文段中有多少数据?<br>b.假设第一个报文段丢失而第二个报文段到达主机B。那么在主机B发往主机A的确认报文中,<br>确认号应该是多少？</p></li></ul><p>数据=110-90=20</p><p>还是90，然后触发重传机制</p><ul><li>假设两条TCP连接存在于一个带宽为R bps的瓶颈链路上。它们都要发送一个很大的文件（以相同<br>方向经过瓶颈链路），并且两者是同时开始发送文件。那么TCP将为每条连接分配什么样的传输<br>速率？</li></ul><p>当两条 TCP 连接同时通过带宽为 R bps 的瓶颈链路发送大文件时，由于 TCP 拥塞控制机制的作用，系统会根据链路的拥塞情况<strong>动态调整发送速率，使每条连接最终获得约 R/2 bps</strong> 的传输速率，从而公平地共享瓶颈带宽。这种公平性是 TCP 拥塞控制的自然结果，尤其是在网络条件一致、没有其他影响因素时更为明显。</p><h1 id="作业题目字典"><a href="#作业题目字典" class="headerlink" title="作业题目字典"></a>作业题目字典</h1><p>第一章：</p><ul><li><p>“主机”和“端系统”之间有什么不同？列举几种不同类型的端系统。Web服务器是一种端系统吗?</p></li><li><p>7.以太LAN的传输速率是多少?</p></li><li><p>.描述今天最为流行的无线因特网接入技术。对它们进行比较和对照。</p></li><li><p>假定在发送主机和接收主机间只有一台分组交换机。发送主机和交换机间以及交换机和接收主机间<br>的传输速率分别是&amp;和忌。假设该交换机使用存储转发分组交换方式，发送一个长度为厶的分组<br>的端到端总时延是什么？（忽略排队时延、传播时延和处理时延。）</p></li><li><p>假定用户共享一条2Mbps链路。同时假定当每个用户传输时连续以1Mbps传输，但每个用户仅传输<br>20%的时间。<br>a.当使用电路交换时，能够支持多少用户?<br>b. 作为该题的后继问题，假定使用分组交换。 为什么如果两个或更少的用户同时传输的话，在链<br>路前面基本上没有排队时延？为什么如果3个用户同时传输的话，将有排队时延?<br>c. 求出某指定用户正在传输的概率。<br>d. 假定现在有3个用户。求出在任何给定的时间，所有3个用户在同时传输的概率。求出队列增长<br>j 的时间比率。</p></li><li><p>—个长度为1000字节的分组经距离为2500km的链路传播，传播速率为2.5xl08m/s并且传输速率<br>为2Mbps,它需要用多长时间？更为一般地，一个长度为厶的分组经距离为/的链路传播，传播速率为并且传输速率为Rbps,它需要用多长时间？该时延与传输速率相关吗？</p></li><li><p>因特网协议栈中的5个层次有哪些？在这些层次中，每层的主要任务是什么？</p></li><li><p>路由器处理因特网协议栈中的哪些层次？链路层交换机处理的是哪些层次？主机处理的是哪些层次？</p></li><li><p>式（1・1）给出了经传输速率为R的7V段链路发送长度厶的一个分组的端到端时延。对于经过/V段链<br>路一个接一个地发送P个这样的分组，一般化地表示出这个公式。</p></li><li><p>这个习题开始探讨传播时延和传输时延，这是数据网络中的两个重要概念。考虑两台主机A和B由<br>一条速率为Abps的链路相连。假定这两台主机相隔肌米，沿该链路的传播速率为.sm/so主机A向<br>主机B发送长度L比特的分组。<br>a. 用m和s来表示传播时延”pmp。<br>b. 用厶和/?来确定该分组的传输时间血亦。<br>c. 忽略处理和排队时延，得出端到端时延的表达式。<br>d. 假定主机A在时刻20开始传输该分组。在时刻/二血唤，该分组的最后一个比特在什么地方？<br>e. 假定心卿大于＜n8o在时刻2血g 该分组的第一个比特在何处？<br>f. 假定如中小于血昨。在时刻2九阳，该分组的第一个比特在何处？<br>g. 假定5=2.5 xlO8, L = 120比特，56kbps。，求出使心哪等于血込的距离叫</p></li><li><p>假定用户共享一条3Mbps的链路。又设每个用户传输时要求150kbps，但是每个用户仅有10%的时间<br>传输。（参见1.3节中关于“分组交换与电路交换的对比”的讨论。）<br>当使用电路交换时，能够支持多少用户？<br>对于本习题的后续小题，假定使用分组交换。求出某给定用户正在传输的概率。<br>假定有120个用户。求出在任何给定时刻，实际有n个用户在同时传输的概率。（提示：使用二项<br>式分布。）<br>求出有21个或更多用户同时传输的概率</p></li><li><p>考虑在1.3节“分组交换与电路交换的对比”的讨论中，给出了一个具有一条1Mbps链路的例子。<br>用户在忙时以100kbps速率产生数据，但忙时仅以p=0. 1的概率产生数据。假定用lGbp$链路替代<br>1Mbps的链路。<br>a. 当采用电路交换技术时，能被同时支持的最大用户数量/V是多少？<br>b. 现在考虑分组交换和有M个用户的情况。给出多于/V用户发送数据的概率公式（用p、M、/V<br>表不）O</p></li><li><p>a.假定有N个分组同时到达一条当前没有分组传输或排队的链路。每个分组长为厶，链路传输速率<br>为R。对N个分组而言.其平均排队时延是多少？<br>b.现在假定每隔LN/R秒有N个分组同时到达链路。一个分组的平均排队时延是多少？</p></li><li><p>对两进程之间的通信会话而言，哪个进程是客户，哪个进程是服务器?</p></li><li><p>运行在一台主机上的一个进程，使用什么信息来标识运行在另一台主机上的进程?</p></li><li><p>假定你想尽快地处理从远程客户到服务器的事务，你将使用UDP还是TCP?为什么？</p></li><li><p>前面讲过TCP能用SSL来强化，以提供进程到进程的安全性服务，包括加密。SSL运行在运输层还<br>是应用层？如果某应用程序研制者想要用SSL来强化UDP,该研制者应当做些什么工作？</p></li><li><p>握手协议的作用是什么？</p></li><li><p>考虑一个电子商务网站需要保留每一个客户的购买记录。描述如何使用cookie来完成该功能？</p></li><li><p>CDN通常采用两种不同的服务器放置方法之一。列举并简单描述它们。 </p></li><li><p>除了如时延、丢包和带宽性能等网络相关的考虑外，设计一种CDN服务器选择策略时还有其他重<br>要因素。它们是什么？</p></li><li><p>7节中所描述的UDP服务器仅需要一个套接字，而TCP服务器需要两个套接字。为什么？如果<br>TCP服务器支持几个并行连接，每条连接来自不同的客户主机，那么TCP服务器将需要多少个套<br>接字？</p></li><li><p>对于2. 7节所描述的运行在TCP之上的客户-服务器应用程序，服务器程序为什么必须先于客户程序<br>运行？对于运行在UDP之上的客户-服务器应用程序，客户程序为什么可以先于服务器程序运行？</p></li><li><p>考虑一个要获取给定URL的Web文档的HTTP客户。该HTTP服务器的IP地址开始时并不知道。在<br>这种情况下，除了 HTTP外，还需要什么运输层和应用层协议？</p></li><li><p>假定你在浏览器中点击一条超链接获得Web页面。相关联的URL的IP地址没有缓存在本地主机上,<br>因此必须使用DNS lookup以获得该IP地址。如果主机从DNS得到IP地址之前已经访问了 n个DNS<br>服务器；相继产生的RTT依次为RTT|、…、RTT“<br>。 进一步假定与链路相关的Web页面只包含一个<br>对象，即由少量的HTML文本组成。令RTT。表示本地主机和包含对象的服务器之间的RTT值。假定<br>该对象传输时间为零，则从该客户点击该超链接到它接收到该对象需要多长时间？</p></li><li><p>参照习题P7,假定在同一服务器上某HTML文件引用了 8个非常小的对象。忽略发送时间，在下列<br>情况下需要多长时间：<br>a.没有并行TCP连接的非持续HTTP。</p><p>b.配置有5个并行连接的非持续HTTP。<br>c.持续 HTTPO</p></li><li><p>在一台主机上安装编译TCPClient和UDPClient Python程序，在另一台主机上安装编译TCPServer和<br>UDPServer 程序。<br>乩假设你在运行TCPServer之前运行TCPClient,将发生什么现象？为什么？<br>b. 假设你在运行UDPServer之前运行UDPClient,将发生什么现象？为什么？<br>c. 如果你对客户端和服务器端使用了不同的端口，将发生什么现象？</p></li><li><p>你能够配置浏览器以打开对某Web站点的多个并行连接吗？有大量的并行TCP连接的优点和缺点<br>是什么</p></li><li><p>我们已经看到因特网TCP套接字将数据处理为字节流，而UDP套接字识别报文边界。面<br>与显式识别和维护应用程序定义的报文边界的API相比，试给出一个优点和一个缺点。</p></li><li><p><strong>描述应用程序开发者为什么可能选择在UDP上运行应用程序而不是在TCP上运行的原因</strong></p></li><li><p>在今天的因特网中，为什么语音和图像流量常常是经过TCP而不是经UDP发送° （提示：我们寻找<br>的答案与TCP的拥塞控制机制没有关系。） </p></li><li><p>当某应用程序运行在UDP上时，该应用程序可能得到可靠数据传输吗？如果能，如何实现？</p></li><li><p>假定在主机C端口 80上运行的一个Web服务器。假定这个Web服务器使用持续连接，并且正在接<br>收来自两台不同主机A和B的请求。被发送的所有请求都通过位于主机C的相同套接字吗？如果它<br>们通过不同的套接字传递，这两个套接字都具有端口 80吗？讨论和解释之：</p></li><li><p>.在我们的rdt协议中，为什么需要引入序号?</p></li><li><p>.在我们的rdt协议中，为什么需要引入定时器?</p></li><li><p>假设主机A通过一条TCP连接向主机B发送两个紧接着的TCP报文段°第一个报文段的序号为90,<br>第二个报文段序号为110</p><p>第一个报文段中有多少数据?<br>b.假设第一个报文段丢失而第二个报文段到达主机B。那么在主机B发往主机A的确认报文中,<br>确认号应该是多少？</p></li><li><p>假设两条TCP连接存在于一个带宽为R bps的瓶颈链路上。它们都要发送一个很大的文件（以相同<br>方向经过瓶颈链路），并且两者是同时开始发送文件。那么TCP将为每条连接分配什么样的传输<br>速率？</p></li><li><p>UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110,<br>01110100.这些8比特字节和的反码是多少？（注意到尽管UDP和TCP使用16比特的字来计算检验<br>和，但对于这个问题，你应该考虑8比特和。）写岀所有工作过程。UDP为什么要用该和的反码，即<br>为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 1比特的差错将可能检测不出<br>来吗？ 2比特的差错呢？</p></li><li><p>假定某UDP接收方对接收到的UDP报文段计算因特网检验和，并发现它与承载在检验和字段中的值<br>相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。</p></li><li><p>我们曾经说过，应用程序可能选择UDP作为运输协议，因为UDP提供了（比TCP）更好的应用层<br>控制，以决定在报文段中发送什么数据和发送时机。<br>a.应用程序为什么对在报文段中发送什么数据有更多的控制？<br>b-应用程序为什么对何时发送报文段有更多的控制？ </p></li><li><p>考虑从主机A向主机B传输L字节的大文件，假设MSS为536字节。<br>a. 为了使得TCP序号不至于用完，厶的最大值是多少？前面讲过TCP的序号字段为4字节。<br>b. 对于你在（a）中得到的厶，求出传输此文件要用多长时间？假定运输层、网络层和数据链路层<br>首部总共为66字节，并加在每个报文段上，然后经155Mbps链路发送得到的分组。忽略流量控<br>制和拥塞控制，使主机A能够一个接一个和连续不断地发送这些报文段。</p></li><li><p>主机A和B直接经一条100Mbps链路连接。在这两台主机之间有一条TCP连接。主机A经这条连<br>接向主机B发送一个大文件。主机A能够向它的TCP套接字以高达120Mbps的速率发送应用数据,<br>而主机B能够以最大50Mbps的速率从它的TCP接收缓存中读岀数据。描述TCP流量控制的影响。</p></li><li><p>在3. 5. 4节中，我们看到TCP直到收到3个冗余ACK才执行快速重传。你对TCP设计者没有选择<br>在收到对报文段的第一个冗余ACK后就快速重传有何看法？</p></li><li><p>考虑图3・58。假设TCP Reno是一个经历如上<br>所示行为的协议，回答下列问题。在各种情<br>况中，简要地论证你的回答。<br>指出TCP慢启动运行时的时间间隔。<br>指出TCP拥塞避免运行时的时间间隔。<br>在第16个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测岀<br>来的？ ~<br>在第22个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测出<br>来的？<br>在第1个传输轮回里，ssthresh的初始值设置为多少？<br>在第18个传输轮回里，ssthresh的值设置为多少？<br>在第24个传输轮回里，ssthresh的值设置为多少？<br>h. 在哪个传输轮回内发送第70个报文段？<br>i. 假定在第26个传输轮回后，通过收到3个冗余ACK检测出有分组丢失，拥塞的窗口长度和<br>ssthresh的值应当是多少？<br>j. 假定使用TCP Tahoe （而不是TCP Reno）,并假定在第16个传输轮回收到3个冗余ACK。在第19<br>个传输轮回，ssthresh和拥塞窗口长度是什么？</p><p>k.再次假设使用TCP Tahoe,在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传<br>输轮回（包括这两个传输轮回），一共发送了多少分组？</p></li></ul><ul><li>考虑仅有一条单一的TCP （Reno）连接使用一条10Mbps链路，且该链路没有缓存任何数据。假设<br>这条链路是发送主机和接收主机之间的唯一拥塞链路。假定某TCP发送方向接收方有一个大文件要<br>发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个TCP报文段长度为1500<br>字节；该连接的双向传播时延是150ms；并且该TCP连接总是处于拥塞避免阶段，即忽略了慢<br>启动。<br>&amp;这条TCP连接能够取得的最大窗口长度（以报文段计）是多少？<br>b. 这条TCP连接的平均窗口长度（以报文段计）和平均吞吐量（以bps计）是多少？<br>c. 这条TCP连接在从丢包恢复后，再次到达其最大窗口要经历多长时间？</li><li>我们注意到网络层功能可被大体分成数据平面功能和控制平面功能。数据平面的主要功能是什么?<br>控制平面的主要功能呢?</li><li>我们对网络层执行的转发功能和路由选择功能进行区别路由选择和转发的主要区别是什么</li><li>路由器中转发表的主要作用是什么?</li><li>在4.2节中，我们看到路由器通常由输入端口、输出端口、交换结构和路由选择处理器组成。其中<br>哪些是用硬件实现的，哪些是用软件实现的？为什么？转到网络层的数据平面和控制平面的概念,<br>哪些是用硬件实现的，哪些是用软件实现的？为什么?</li><li>假设一个到达分组匹配了路由器转发表中的两个或更多表项。采用传统的基于目的地转发，路由器<br>用什么原则来确定这条规则可以用于确定输出端口，使得到达的分组能交换到输出端口？</li><li>描述在输入端口会出现分组丢失的原因。描述在输入端口如何消除分组丢失（不使用无限大缓存区）</li><li>描述在输出端口会出现分组丢失的原因。通过提高交换结构速率，能够防止这种丢失吗?</li><li>假定主机A向主机B发送封装在一个IP数据报中的TCP报文段。当主机B接收到该数据报时，主<br>机B中的网络层怎样知道它应当将该报文段（即数据报的有效载荷）交给TCP而不是UDP或某个<br>其他东西呢？</li><li>什么时候一个大数据报分割成多个较小的数据报？较小的数据报在什么地方装配成一个较大的数据报？</li><li>假设在一个源主机和一个目的主机之间有3台路由器。不考虑分片，一个从源主机发送给目的主机<br>的IP数据报将通过多少个接口？为了将数据报从源移动到目的地需要检索多少个转发表？4</li><li>假设某应用每20ms生成一个40字节的数据块，每块封装在一个TCP报文段中，TCP报文段再封装<br>在一个IP数据报中。每个数据报的开销有多大？应用数据所占百分比是多少？</li><li>假定你购买了一个无线路由器并将其与电缆调制解调器相连。同时假定ISP动态地为你连接的设备<br>（即你的无线路由器）分配一个IP地址。还假定你家有5台PC,均使用802. 11以无线方式与该无<br>线路由器相连。怎样为这5台PC分配IP地址？该无线路由器使用NAT吗？为什么?</li><li>“路由聚合” 一词意味着什么？路由器执行路由聚合为什么是有用的</li><li>什么是专用网络地址？具有专用网络地址的数据报会出现在大型公共因特网中吗？解释理由。</li><li>通用转发与基于目的地转发有何不同？</li><li>路由器或交换机的“匹配加动作”意味着什么？在基于目的地转发的分组交换机场合中，要匹配什<br>么并采取什么动作？在SDN的场合中，举出3个能够被匹配的字段和3个能被采取的动作。</li><li>假设两个分组在完全相同的时刻到达一台路由器的两个不同输入端口。同时假设在该路由器中没有<br>其他分组。<br>假设这两个分组朝着两个不同的输出端口转发。当交换结构使用一条共享总线时，这两个分组可<br>能在相同时刻通过该交换结构转发吗？ ‘<br>假设这两个分组朝着两个不同的输岀端口转发。当交换结构使用经内存交换时，这两个分组可能<br>在相同时刻通过该交换结构转发吗？ “ . 假设这两个分组朝着相同的输出端口转发。当交换结构使用纵横式时，这两个分组可能在相同时<br>刻通过该交换结构转发吗？</li><li>考虑使用32比特主机地址的某数据报网络°假定一台路由器具有4条链路.编号为0~3,分组能被<br>转发到如下的各链路接口：<br>目的地址范围<br>11100000 00000000 00000000 00000000<br>到<br>11100000 00111111 11111111 11111111<br>链路接口<br>0<br>11100000 01000000 00000000 00000000<br>到 1<br>11100000 01000000 11111111 11111111<br>111(X)000 01000(X)1 0(X)00000 00000000<br>到 2<br>11100001 01111111 11111111 11111111<br>其他 3<br>网络层:数据平 239<br>a. 提供一个具有5个表项的转发表，使用最长前缀匹配，转发分组到正确的链路接口。<br>b. 描述你的转发表是如何为具有下列目的地址的数据报决定适当的链路接口的。<br>11001000 10010001 01010001 01010101<br>11100001 01000000 11000011 00111100<br>11100001 10000000 00010001 01110111</li><li>考虑互联3个子网（子网1、子网2和子网3）的一台路由器。假定这3个子网的所有接口要求具有<br>前缀223.1.17/24。还假定子网1要求支持多达60个接口，子网2要求支持多达90个接口，子网3<br>要求支持多达12个接口。提供3个满足这些限制的网络地址（形式为a. b.c.d/x）o</li><li>考虑一个具有前缀12&amp; 119. 40. 128/26的子网。给出能被分配给该网络的一个IP地址（形式为<br>xxx. XXX. xxx. xxx）的例子o假定一个ISP拥有形式为12&amp; 119. 40. 64/26的地址块。假定它要从该地<br>址块生成4个子网，每块具有相同数量的IP地址。这4个子网（形式为a. b. c. d/x）的前缀是什么?</li><li>考虑向具有700字节MTU的一条链路发送一个2400字节的数据报。假定初始数据报标有标识号<br>422。将会生成多少个分片？在生成相关分片的数据报中各个字段的值是多少?</li><li><p>考虑在图4-25中建立的网络。假定ISP现在为路由器分配地址24.34.112.235,家庭网络的网络地<br>址是 192. 16&amp; 1/24。<br>a.在家庭网络中为所有接口分配地址。<br>P17.<br>b.假定每台主机具有两个进行中的TCP连接，所有都是针对主机128.119. 40. 86的80端口的。在<br>NAT转换表中提供6个对应表项。</p></li><li><p>比较和对照链路状态和距离矢量这两种路由选择算法</p></li><li>为什么在因特网中用到了不同的AS间与AS内部协议？</li><li>在OSPF自治系统中区域表示什么？为什么引入区域的概念?</li><li>假定你要在SDN控制平面中实现一个新型路由选择协议。你将在哪个层次中实现该协议？解释<br>理由。</li><li>.什么类型的报文流跨越SDN控制器的北向和南向API?谁是从控制器跨越南向接口发送的这些报文<br>的接收者？谁是跨越北向接口从控制器发送的这些报文的接收者？</li><li>描述两种从受控设备到控制器发送的0penFlow报文（由你所选）类型的目的。描述两种从控制器<br>到受控设备发送的OpenFlow报文（由你所选）类型的目的。</li><li>在发送主机执行Traceroute程序，收到哪两种类型的ICMP报文?</li><li><strong>第五章习题7</strong> 考虑下图所示的网络段。兀只有两个相连邻居⑷与y。⑷有一条通向目的地仏（没有显示）的最低开<br>销路径，其值为5, y有一条通向目的地”的最低开销路径，其值为6。从如与y到u （以及⑷与y之<br>间）的完整路径未显示出来。网络中所有链路开销皆为正整数值。<br>5<br>/<br>a-给出x对目的地⑷、y和u的距离向量。<br>280 第5袁<br>b. 给出对于c&amp;, w)或c(%, y)的链路开销的变化，使得执行了距离向量算法后，％将通知其邻居<br>有一条通向“的新最低开销路径。<br>c. 给出对c(%, w)或c(g y)的链路开销的变化，使得执行了距离向量算法后，力将不通知其邻居<br>有一条通向x的新最低开销路径。</li><li>如果在因特网中的所有链路都提供可靠的交付服务，TCP可靠传输服务将是多余的吗？为什么？</li><li><p>在CSMA/CD中，在第5次碰撞后，节点选择K =4的概率有多大？结果K=4在10Mbps以太网上对<br>应于多少秒的时延？</p></li><li><p>MAC地址空间有多大？ IPv4的地址空间呢？ IPv6的地址空间呢?</p></li><li><p>ARP査询为什么要在广播帧中发送呢？ ARP响应为什么要在一个具有特定目的MAC地址的帧中发<br>送呢?</p></li><li><p>考虑5比特生成多项式，6 = 10011,并且假设。的值为lOlOlOlOlOo /?的值是什么</p></li><li><p>考虑上一个习题，这时假设D具有值：<br>a. 1001010101c<br>b. 0101101010o •一一<br>c. 1010100000</p></li><li><p>•如图6・33所示，考虑通过两台路由器互联的3个局域网。<br>a. 对所有的接口分配IP地址。对子网1使用形式为192. 168. 1. xxx的地址，对子网2使用形式为</p><p>xxx的地址，对子网3使用形式为192. 16&amp; 3. xxx的地址。<br>b. 为所有的适配器分配MAC地址。<br>c. 考虑从主机E向主机B发送一个1P数据报。假设所有的ARP表都是最新的。就像在6.4.1节中<br>对单路由器例子所做的那样，列举出所有步骤。<br>d. 重复（c）,现在假设在发送主机中的ARP表为空（并且其他表都是最新的）。</p></li><li><p>在某网络中标识为A到F的6个节点以星形与一台交换机连接，考虑在该网络环境中某个正在<br>学习的交换机的运行情况。假定：（i） B向E发送一个帧；（ii） E向B回答一个帧；（iii） A<br>向B发送一个帧；（iv） B向A回答一个帧“该交换机表初始为空。显示在这些事件的前后该<br>交换机表的状态。对于每个事件，指出在其上面转发传输的帧的链路，并简要地评价你的<br>答案。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/25/network/networktest/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试题目hot2集合</title>
      <link>https://blog.tokenlen.top/2025/05/23/javase/javase3/</link>
      <guid>https://blog.tokenlen.top/2025/05/23/javase/javase3/</guid>
      <pubDate>Thu, 22 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;1-数组与集合区别，用过哪些？&quot;&gt;&lt;a href=&quot;#1-数组与集合区别，用过哪些？&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-数组与集合区别，用过哪些？"><a href="#1-数组与集合区别，用过哪些？" class="headerlink" title="1.数组与集合区别，用过哪些？"></a>1.数组与集合区别，用过哪些？</h2><p>数组和集合的区别：</p><ul><li>数组是<strong>固定长度</strong>的数据结构，一旦创建长度就无法改变，而集合是<strong>动态长度</strong>的数据结构，可以根据需要动态增加或减少元素。</li><li>数组可以<strong>包含基本数据类型和对象</strong>，而集合<strong>只能包含对象</strong>。</li><li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</li></ul><p>我用过的一些 Java 集合类：</p><ol><li><strong>ArrayList：</strong> 动态数组，实现了List接口，支持动态增长。</li><li><strong>LinkedList：</strong> 双向链表，也实现了List接口，支持快速的插入和删除操作。</li><li><strong>HashMap：</strong> 基于哈希表的Map实现，存储键值对，通过键快速查找值。</li><li><strong>HashSet：</strong> 基于HashMap实现的Set集合，用于存储唯一元素。</li><li><strong>TreeMap：</strong> 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。</li><li><strong>LinkedHashMap：</strong> 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。</li><li><strong>PriorityQueue：</strong> 优先队列，可以按照比较器或元素的自然顺序进行排序。</li></ol><h2 id="2-说说Java中的集合？"><a href="#2-说说Java中的集合？" class="headerlink" title="2.说说Java中的集合？"></a>2.说说Java中的集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt=""></p><p>List是<strong>有序的Collection</strong>，使用此接口能够精确的控制每个元素的插入位置，用户能根据索引访问List中元素。常用的实现List的类有LinkedList，ArrayList，Vector，Stack。</p><ul><li>ArrayList是容量可变的非线程安全列表，其底层使用数组实现。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>ArrayList支持对元素的快速随机访问，但插入与删除速度很慢。</strong></li><li>LinkedList本质是<strong>一个双向链表</strong>，与ArrayList相比，，<strong>其插入和删除速度更快</strong>，但随机访问速度更慢。</li></ul><p>Set不允许存在重复的元素，与List不同，set中的元素是<strong>无序的</strong>。常用的实现有HashSet，LinkedHashSet和TreeSet。</p><ul><li>HashSet通过HashMap实现，HashMap的Key即HashSet存储的元素，<strong>所有Key都是用相同的Value</strong>，一个名为<strong>PRESENT</strong>的Object类型常量。使用Key保证元素唯一性，但不保证有序性。由于HashSet是HashMap实现的，因此线程不安全。</li><li>LinkedHashSet继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序。</li><li>TreeSet通过TreeMap实现的，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。</li></ul><p>Map 是<strong>一个键值对集合</strong>，存储键、值和之间的映射。Key 无序，唯一；value 不要求有序，允许重复。Map 没有继承于 Collection 接口，从 Map 集合中检索元素时，<strong>只要给出键对象，就会返回对应的值对象</strong>。主要实现有TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap</p><ul><li>HashMap：JDK1.8 之前 HashMap <strong>由数组+链表组成的</strong>，数组是 HashMap 的主体，<strong>链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）</strong>，JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间</strong></li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是<strong>基于拉链式散列结构即由数组和链表或红黑树组成。</strong>另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，<strong>使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</strong></li><li>HashTable：<strong>数组+链表</strong>组成的，数组是 HashTable 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap：<strong>红黑树（自平衡的排序二叉树）</strong></li><li>ConcurrentHashMap：<strong>Node数组+链表+红黑树实现</strong>，<strong>线程安全的</strong>（jdk1.8以前<strong>Segment</strong>锁，<strong>1.8以后volatile + CAS 或者 synchronized）</strong></li></ul><h2 id="3-Java中的线程安全的集合是什么？"><a href="#3-Java中的线程安全的集合是什么？" class="headerlink" title="3.Java中的线程安全的集合是什么？"></a>3.Java中的线程安全的集合是什么？</h2><ul><li><strong>Vector</strong>：<strong>线程安全的动态数组</strong>，其内部方法基本都经过synchronized修饰，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，<strong>当数组已满时，会创建新的数组，并拷贝原有数组数据。</strong></li><li><strong>Hashtable</strong>：线程安全的哈希表，<strong>HashTable 的加锁方法是给每个方法加上 synchronized 关键字，这样锁住的是整个 Table 对象，</strong>不支持 null 键和值**，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用ConcurrentHashMap。</li></ul><p>java.util.concurrent 包提供的都是线程安全的集合：</p><p>并发Map：</p><ul><li><strong>ConcurrentHashMap</strong>：它与 HashTable 的主要区别是<strong>二者加锁粒度</strong>的不同，在<strong>JDK1.7</strong>，ConcurrentHashMap加的是<strong>分段锁，也就是Segment锁</strong>，每个Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在<strong>JDK 1.8</strong> ，它取消了Segment字段，<strong>直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。</strong>对于put操作，如果Key对应的数组元素为null，<strong>则通过CAS操作（Compare and Swap）将其设置为当前值</strong>。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，<strong>则对该元素使用 synchronized 关键字申请锁，然后进行操作</strong>。如果该 put 操作使得当前链表长度超过一定阈值，<strong>则将该链表转换为红黑树，从而提高寻址效率。</strong></li><li><strong>ConcurrentSkipListMap</strong>：实现了一个<strong>基于SkipList（跳表）</strong>算法的可排序的并发集合，SkipList是<strong>一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的“跳跃”链接来实现高效查找。</strong></li></ul><p>并发Set：</p><ul><li><strong>ConcurrentSkipListSet</strong>：是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</li><li><strong>CopyOnWriteArraySet</strong>：是<strong>线程安全的Set实现</strong>，它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，<strong>HashSet是通过“散列表”实现的</strong>，而<strong>CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。</strong></li></ul><p>并发List：</p><ul><li><strong>CopyOnWriteArrayList</strong>：它是 ArrayList 的线程安全的变体，<strong>其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现</strong>，<strong>允许存储 null 元素</strong>。即当对象进行写操作时，<strong>使用了Lock锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；</strong>若进行的读操作，则直接返回结果，操作过程中不需要进行同步。</li></ul><p>并发 Queue：</p><ul><li><strong>ConcurrentLinkedQueue</strong>：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。通常，ConcurrentLinkedQueue 的性能要好于 BlockingQueue 。</li><li><strong>BlockingQueue</strong>：与 ConcurrentLinkedQueue 的使用场景不同，BlockingQueue 的主要功能并不是在于提升高并发时的队列性能，<strong>而在于简化多线程间的数据共享。</strong>BlockingQueue 提供一种读写阻塞等待的机制，<strong>即如果消费者速度较快，则 BlockingQueue 则可能被清空，此时消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。</strong>反之，如果生产线程较快，则 BlockingQueue 可能会被装满，此时，生产线程再试图向 BlockingQueue 队列装入数据时，便会被阻塞等待。</li></ul><p>并发 Deque：</p><ul><li><strong>LinkedBlockingDeque</strong>：是<strong>一个线程安全的双端队列</strong>实现。它的内部使用<strong>链表结构</strong>，每一个节点都维护了一个前驱节点和一个后驱节点。<strong>LinkedBlockingDeque 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作</strong></li><li><strong>ConcurrentLinkedDeque</strong>：ConcurrentLinkedDeque是一种<strong>基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作</strong>。当<strong>许多线程同时访问一个公共集合时</strong>，ConcurrentLinkedDeque是一个合适的选择</li></ul><h2 id="4-Collections和Collection的区别"><a href="#4-Collections和Collection的区别" class="headerlink" title="4.Collections和Collection的区别"></a>4.Collections和Collection的区别</h2><ul><li>Collection是<strong>Java集合框架中的一个接口</strong>，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。Collection接口有许多实现类，如List、Set和Queue等。</li><li>Collections（注意有一个s）<strong>是Java提供的一个工具类</strong>，位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。</li></ul><h2 id="5-集合遍历的方法有哪些？"><a href="#5-集合遍历的方法有哪些？" class="headerlink" title="5.集合遍历的方法有哪些？"></a>5.集合遍历的方法有哪些？</h2><ul><li><strong>普通 for 循环：</strong> 可以使用带有索引的普通 for 循环来遍历 List。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>增强 for 循环（for-each循环）：</strong> 用于循环访问数组或集合中的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Iterator 迭代器：</strong> 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ListIterator 列表迭代器：</strong> ListIterator是迭代器的子类，可以双向访问列表并在迭代过程中修改元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; listIterator= list.listIterator();</span><br><span class="line"><span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> listIterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 forEach 方法：</strong> Java 8引入了 forEach 方法，可以对集合进行快速遍历。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><ul><li><strong>Stream API：</strong> Java 8的Stream API提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="1-讲一下java里面list的几种实现，几种实现有什么不同？"><a href="#1-讲一下java里面list的几种实现，几种实现有什么不同？" class="headerlink" title="1.讲一下java里面list的几种实现，几种实现有什么不同？"></a>1.讲一下java里面list的几种实现，几种实现有什么不同？</h2><ul><li>Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用<strong>对象数组</strong>来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li><li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，<strong>Vector 在扩容时会提高 1 倍，</strong>而 ArrayList 则是增加 <strong>50%。</strong></li><li>LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</li></ul><blockquote><p>这几种实现具体在什么场景下应该用哪种？</p></blockquote><ul><li>Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合<strong>随机访问</strong>的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。</li><li>而 LinkedList 进行节点插入、<strong>删除却要高效得多，但是随机访问性能则要比动态数组慢。</strong></li></ul><h2 id="2-list可以一边遍历一边修改元素吗？"><a href="#2-list可以一边遍历一边修改元素吗？" class="headerlink" title="2.list可以一边遍历一边修改元素吗？"></a>2.list可以一边遍历一边修改元素吗？</h2><ul><li>使用普通for循环遍历：可以在遍历过程中修改元素，只要修改的索引不超出<code>List</code>的范围即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用普通for循环遍历并修改元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list.set(i, list.get(i) * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用foreach循环遍历：一般不建议在<code>foreach</code>循环中直接修改正在遍历的<code>List</code>元素，因为<strong>这可能会导致意外的结果或<code>ConcurrentModificationException</code>异</strong>常。在<code>foreach</code>循环中修改元素可能会破坏迭代器的内部状态，因为<code>foreach</code>循环底层是基于迭代器实现的，在遍历过程中修改集合结构，会导致迭代器的预期结构和实际结构不一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用foreach循环遍历并尝试修改元素，会抛出ConcurrentModificationException异常</span></span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            list.set(list.indexOf(num), num * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代器遍历：<strong>可以使用迭代器的<code>remove</code>方法来删除元素，但如果要修改元素的值，需要通过迭代器的<code>set</code>方法来进行</strong>，而不是直接通过<code>List</code>的<code>set</code>方法，否则也可能会抛出<code>ConcurrentModificationException</code>异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器遍历并修改元素</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用迭代器的set方法修改元素</span></span><br><span class="line">                iterator.set(<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于线程安全的<code>List</code>，如<code>CopyOnWriteArrayList</code>，由于其采用了写时复制的机制，<strong>在遍历的同时可以进行修改操作，不会抛出<code>ConcurrentModificationException</code>异常，</strong>但可能会读取到旧的数据，因为修改操作是在新的副本上进行的。</p><h2 id="3-list如何快速删除某个指定下标的元素？"><a href="#3-list如何快速删除某个指定下标的元素？" class="headerlink" title="3.list如何快速删除某个指定下标的元素？"></a>3.list如何快速删除某个指定下标的元素？</h2><p><code>ArrayList</code>提供了<code>remove(int index)</code>方法来删除指定下标的元素，<strong>该方法在删除元素后，会将后续元素向前移动，以填补被删除元素的位置。</strong>如果删除的是列表末尾的元素，时间复杂度为 O (1)；如果删除的是列表中间的元素，时间复杂度为 O (n)，n 为列表中元素的个数，因为需要移动后续的元素。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除下标为1的元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LinkedList</code>的<code>remove(int index)</code>方法也可以用来删除指定下标的元素。<strong>它需要先遍历到指定下标位置，然后修改链表的指针来删除元素。</strong>时间复杂度为 O (n)，n 为要删除元素的下标。不过，如果已知要删除的元素是链表的头节点或尾节点，可以直接通过修改头指针或尾指针来实现删除，时间复杂度为 O (1)。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除下标为1的元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copyOnWriteArrayList</code>的<code>remove</code>方法同样可以删除指定下标的元素。由于<code>CopyOnWriteArrayList</code>在写操作时会创建一个新的数组，<strong>所以删除操作的时间复杂度取决于数组的复制速度，通常为 O (n)</strong>，n 为数组的长度。但在并发环境下，它的删除操作不会影响读操作，具有较好的并发性能。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除下标为1的元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Arraylist和LinkedList的区别，哪个集合是线程安全的？"><a href="#4-Arraylist和LinkedList的区别，哪个集合是线程安全的？" class="headerlink" title="4.Arraylist和LinkedList的区别，哪个集合是线程安全的？"></a>4.Arraylist和LinkedList的区别，哪个集合是线程安全的？</h2><p>ArrayList和LinkedList都是Java中常见的集合类，它们都实现了List接口。</p><ul><li><strong>底层数据结构不同</strong>：ArrayList使用<strong>数组</strong>实现，通过索引进行快速访问元素。LinkedList使用<strong>链表</strong>实现，通过节点之间的指针进行元素的访问和操作。</li><li><strong>插入和删除操作的效率不同</strong>：ArrayList<strong>在尾部的插入和删除操作效率较高，但在中间或开头的插入和删除操作效率较低</strong>，需要移动元素。<strong>LinkedList在任意位置的插入和删除操作效率都比较高</strong>，因为只需要调整节点之间的指针，但是LinkedList是<strong>不支持随机访问的</strong>，所以除了头结点外插入和删除的时间复杂度都是0(n)，效率也不是很高所以LinkedList基本没人用。</li><li><strong>随机访问的效率不同</strong>：ArrayList<strong>支持通过索引进行快速随机访问</strong>，时间复杂度为O(1)。LinkedList需要从头或尾开始遍历链表，时间复杂度为O(n)。</li><li><strong>空间占用</strong>：ArrayList在创建时需要<strong>分配一段连续的内存空间，因此会占用较大的空</strong>间。LinkedList每个节点只需要存储元素和指针，因此相对较小。</li><li><strong>使用场景</strong>：<strong>ArrayList适用于频繁随机访问和尾部的插入删除操作，而LinkedList适用于频繁的中间插入删除操作和不需要随机访问的场景。</strong></li><li><strong>线程安全</strong>：这两个集合<strong>都不是线程安全的</strong>，Vector是线程安全的</li></ul><h2 id="5-ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？"><a href="#5-ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？" class="headerlink" title="5.ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？"></a>5.ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？</h2><p>不是线程安全的，ArrayList变成线程安全的方式有：</p><ul><li>使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用Vector类代替ArrayList，Vector是线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><h2 id="6-线程安全的-List，-CopyonWriteArraylist是如何实现线程安全的"><a href="#6-线程安全的-List，-CopyonWriteArraylist是如何实现线程安全的" class="headerlink" title="6.线程安全的 List， CopyonWriteArraylist是如何实现线程安全的"></a>6.线程安全的 List， CopyonWriteArraylist是如何实现线程安全的</h2><p>CopyOnWriteArrayList底层也是<strong>通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p><strong>在写入操作时，加了一把互斥锁ReentrantLock以保证线程安全。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取到当前List集合保存数据的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">//获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//将当前数组拷贝一份的同时，让其长度加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//替换引用，将数组的引用指向给新数组的地址</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到源码可以知道写入新元素时，首先<strong>会先将原来的数组拷贝一份并且让原来数组的长度+1后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置都在新数组最后一个位置后，用新数组的地址替换掉老数组的地址就能得到最新的数据了。</strong></p><p>在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。</p><p>现在我们来看读操作，读是没有加锁的，所以读是一直都能读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-为什么ArrayList不是线程安全的，具体来说是哪里不安全？"><a href="#7-为什么ArrayList不是线程安全的，具体来说是哪里不安全？" class="headerlink" title="7.为什么ArrayList不是线程安全的，具体来说是哪里不安全？"></a>7.为什么ArrayList不是线程安全的，具体来说是哪里不安全？</h2><p>在高并发添加数据下，ArrayList会暴露三个问题;</p><ul><li>部分值为null（我们并没有add null进去）</li><li>索引越界异常</li><li>size与我们add的数量不符</li></ul><p>为了知道这三种情况是怎么发生的，ArrayList，add 增加元素的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ensureCapacityInternal()这个方法的详细代码我们可以暂时不看，它的作用就是判断如果将当前的新元素加到列表后面，列表的elementData数组的大小是否满足，如果size + 1的这个需求长度大于了elementData这个数组的长度，那么就要对这个数组进行扩容。</p><p>大体可以分为三步：</p><ul><li>判断数组需不需要扩容，如果需要的话，调用grow方法进行扩容；</li><li>将数组的size位置设置值（因为数组的下标是从0开始的）；</li><li>将当前集合的大小加1</li></ul><p>下面我们来分析三种情况都是如何产生的：</p><ul><li>部分值为null：当线程1走到了扩容那里发现当前size是9，而数组容量是10，所以不用扩容，这时候cpu让出执行权，线程2也进来了，发现size是9，而数组容量是10，所以不用扩容，这时候线程1继续执行，将数组下标索引为9的位置set值了，还没有来得及执行size++，这时候线程2也来执行了，又把数组下标索引为9的位置set了一遍，这时候两个先后进行size++，导致下标索引10的地方就为null了。</li><li>索引越界异常：线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）；</li><li>size与我们add的数量不符：这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的；</li><li></li></ul><h2 id="8-ArrayList的扩容机制说一下"><a href="#8-ArrayList的扩容机制说一下" class="headerlink" title="8.ArrayList的扩容机制说一下"></a>8.ArrayList的扩容机制说一下</h2><p>ArrayList在添加元素时，如果当前元素个数已经达到了内部数组的容量上限，就会触发扩容操作。ArrayList的扩容操作主要包括以下几个步骤：</p><ul><li>计算新的容量：一般情况下，新的容量会扩大为原容量的1.5倍（在JDK 10之后，扩容策略做了调整），然后检查是否超过了最大容量限制。</li><li>创建新的数组：根据计算得到的新容量，创建一个新的更大的数组。</li><li>将元素复制：将原来数组中的元素逐个复制到新数组中。</li><li>更新引用：将ArrayList内部指向原数组的引用指向新数组。</li><li>完成扩容：扩容完成后，可以继续添加新元素。</li></ul><p>ArrayList的扩容操作涉及到数组的复制和内存的重新分配，所以在频繁添加大量元素时，扩容操作可能会影响性能。为了减少扩容带来的性能损耗，可以在初始化ArrayList时预分配足够大的容量，避免频繁触发扩容操作。</p><p>之所以扩容是 1.5 倍，是因为 <strong>1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新容量计算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="9-arratlist的尾插法，为什么要用换尾插法"><a href="#9-arratlist的尾插法，为什么要用换尾插法" class="headerlink" title="9.arratlist的尾插法，为什么要用换尾插法"></a>9.arratlist的尾插法，为什么要用换尾插法</h2><p>通常推荐使用尾插法</p><p>头插法：</p><p>每次插入都需要将<strong>所有已有元素整体后移一位</strong>。</p><p>时间复杂度：<code>O(n)</code>，n 为当前元素数量。</p><p>尾插法：</p><p>直接插入到数组末尾，无需移动元素。</p><p>时间复杂度：<code>O(1)</code>（摊还），只在扩容时需要重新分配数组并拷贝数据，其他情况为常数时间。</p><p>✅ <strong>性能更高</strong>：</p><ul><li>尾插法不会频繁移动元素，尤其是数据量大时，性能差距明显。</li><li>头插法每次插入都要整体移动，效率低下。</li></ul><p>✅ <strong>减少内存拷贝开销</strong>：</p><ul><li>尾插法只在扩容时才整体拷贝数组。</li><li>头插法<strong>每次插入都在触发拷贝</strong>（位置偏移），浪费 CPU 时间和内存带宽。</li></ul><p>✅ <strong>符合 <code>ArrayList</code> 的设计特点</strong>：</p><ul><li><code>ArrayList</code> 本质是一个<strong>动态数组</strong>，不适合频繁从头部插入或删除。</li></ul><h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h2 id="1-hashmap的key可以重复吗？如果不能重复说出他的原因。"><a href="#1-hashmap的key可以重复吗？如果不能重复说出他的原因。" class="headerlink" title="1.hashmap的key可以重复吗？如果不能重复说出他的原因。"></a>1.hashmap的key可以重复吗？如果不能重复说出他的原因。</h2><p>HashMap的<strong>key不允许重复，</strong>当你尝试使用已存在的键插入新值时，<strong>会覆盖原有的值</strong>。</p><p>HashMap基于哈希表实现，每个键（key）通过哈希函数计算出一个唯一的哈希值，用于确定存储位置。</p><p><code>HashMap</code> 通过 <code>hashCode()</code> 计算键的哈希值，决定其在数组中的位置，如果两个不同的键产生相同哈希值（哈希冲突），则通过 <code>equals()</code> 方法进一步比较键的内容：</p><ul><li><strong>若</strong> <code>equals()</code> <strong>返回</strong> <code>true</code>：视为同一键，新值覆盖旧值。</li><li><strong>若</strong> <code>equals()</code> <strong>返回</strong> <code>false</code>：视为不同键，通过链表或红黑树存储</li></ul><p>解决hash冲突的方法是<strong>链地址法</strong>，链表超过 8 转红黑树</p><p>为什么不能重复的原因：</p><ul><li><strong>哈希表的基本语义</strong>：哈希表通过键快速定位值，若键重复会导致语义混乱。</li><li><strong>数据一致性</strong>：避免同一键对应多个值，确保数据的确定性。</li><li><strong>业务需求</strong>：大多数场景下，键作为唯一标识（如用户 ID、订单号），不允许重复。</li></ul><h2 id="2-如何对map进行快速遍历？"><a href="#2-如何对map进行快速遍历？" class="headerlink" title="2.如何对map进行快速遍历？"></a>2.如何对map进行快速遍历？</h2><ul><li>使用for-each循环和entrySet()方法：这是一种较为常见和简洁的遍历方式，它可以同时获取<code>Map</code>中的键和值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用for-each循环和entrySet()遍历Map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用for-each循环和keySet()方法：如果只需要遍历<code>Map</code>中的键，可以使用<code>keySet()</code>方法，这种方式相对简单，性能也较好。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用for-each循环和keySet()遍历Map的键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代器：通过获取Map的entrySet()或keySet()的迭代器，也可以实现对Map的遍历，这种方式在需要<strong>删除元素</strong>等操作时比较有用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器遍历Map</span></span><br><span class="line">        Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 Lambda 表达式和forEach()方法：在 Java 8 及以上版本中，可以使用 Lambda 表达式和<code>forEach()</code>方法来遍历<code>Map</code>，这种方式更加简洁和函数式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式和forEach()方法遍历Map</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Stream API：Java 8 引入的<code>Stream API</code>也可以用于遍历<code>Map</code>，可以将<code>Map</code>转换为流，然后进行各种操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Stream API遍历Map</span></span><br><span class="line">        map.entrySet().stream()</span><br><span class="line">          .forEach(entry -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还可以进行其他操作，如过滤、映射等</span></span><br><span class="line">        Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()</span><br><span class="line">                                            .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">                                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">        System.out.println(filteredMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-HashMap实现原理介绍一下？"><a href="#3-HashMap实现原理介绍一下？" class="headerlink" title="3.HashMap实现原理介绍一下？"></a>3.HashMap实现原理介绍一下？</h2><p>在 JDK 1.7 版本之前， HashMap 数据结构是<strong>数组和链表</strong>，HashMap通过哈希算法将元素的键（Key）映射到数组中的<strong>槽位（Bucket）</strong>。<strong>如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，</strong>因为链表的<strong>查询时间是O(n)</strong>，所以冲突很严重，一个索引上的链表非常长，效率就很低了。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719565480532-57a14329-c36b-4514-8e7d-2f2f1df88a82.webp" alt=""></p><p>所以在 <strong>JDK 1.8</strong> 版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用<strong>红黑树</strong>，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，<strong>但是在数量较少时，即数量小于6时，会将红黑树转换回链表。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1719565481289-0c2164f4-f755-46e3-bb39-b5f28621bb6b.webp" alt=""></p><h2 id="4-了解的哈希冲突解决方法有哪些？"><a href="#4-了解的哈希冲突解决方法有哪些？" class="headerlink" title="4.了解的哈希冲突解决方法有哪些？"></a>4.了解的哈希冲突解决方法有哪些？</h2><ul><li><p>链接法：使用链表或<strong>其他数据结构（红黑树）</strong>来存储冲突的键值对，将它们链接在同一个哈希桶中。</p><p>hashmap就用的这个方法</p></li><li><p>开放寻址法：在<strong>哈希表中找到另一个可用的位置来存储冲突的键值对</strong>，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。</p><p>Redis 的 Hash 字典底层用的是 <strong>开放寻址 + rehash + 平滑扩容</strong></p></li><li><p>再哈希法（Rehashing）：当发生冲突时，<strong>使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</strong></p></li></ul><p><strong>一些嵌入式设备中的 Hash 表实现</strong>，或者一些 <strong>空间敏感的数据结构库</strong></p><ul><li>哈希桶扩容：当哈希冲突过多时，<strong>可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。</strong></li></ul><p>Java HashMap 扩容，Redis 渐进式 rehash</p><h2 id="5-HashMap是线程安全的吗？"><a href="#5-HashMap是线程安全的吗？" class="headerlink" title="5.HashMap是线程安全的吗？"></a>5.HashMap是线程安全的吗？</h2><p>hashmap不是线程安全的，hashmap在多线程会存在下面的问题：</p><ul><li>JDK 1.7 HashMap 采用数组 + 链表的数据结构，多线程背景下，<strong>在数组扩容的时候，存在 Entry 链死循环和数据丢失问题。</strong></li><li>JDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。<strong>但是多线程背景下，put 方法存在数据覆盖的问题。</strong></li></ul><p>如果要保证线程安全，可以通过这些方法来保证：</p><ul><li>多线程环境可以使用<strong>Collections.synchronizedMap</strong>同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</li><li><strong>ConcurrentHashmap</strong>在JDK1.7和1.8的版本改动比较大，<strong>1.7使用Segment+HashEntry分段锁</strong>的方式实现，1.8则抛弃了Segment，改为使用<strong>CAS+synchronized+Node</strong>实现，同样也加入了红黑树，避免链表过长导致性能的问题。</li></ul><h2 id="6-hashmap的put过程介绍一下"><a href="#6-hashmap的put过程介绍一下" class="headerlink" title="6. hashmap的put过程介绍一下"></a>6. hashmap的put过程介绍一下</h2><p>HashMap HashMap的put()方法用于向HashMap中添加键值对，当调用HashMap的put()方法时，会按照以下详细流程执行（JDK8 1.8版本）：</p><blockquote><p>第一步：根据要添加的键的哈希码计算在数组中的位置（索引）。</p><p>第二步：检查该位置是否为空（即没有键值对存在）</p></blockquote><ul><li>如果为空，则直接在该位置<strong>创建一个新的Entry对象</strong>来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。<strong>将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。</strong></li></ul><blockquote><p>第三步：如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？</p></blockquote><ul><li><strong>如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。</strong></li></ul><blockquote><p>第四步：如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键：</p></blockquote><p>如果键值对集合是链表结构，<strong>从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。</strong></p><ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，<strong>则将新的键值对添加到链表的头部。</strong></li></ul><p>如果键值对集合是红黑树结构，在红黑树中使用<strong>哈希码和equals()方法</strong>进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，<strong>直到找到相同的键或达到红黑树末尾。</strong></p><ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，<strong>则将新的键值对添加到红黑树中。</strong></li></ul><blockquote><p>第五步：检查链表长度是否达到阈值（默认为8）：</p></blockquote><ul><li>如果<strong>链表长度超过阈值，且HashMap的数组长度大于等于64</strong>，则会将链表转换为红黑树，以提高查询效率。</li></ul><blockquote><p>第六步：检查负载因子是否超过阈值（默认为0.75）：</p></blockquote><ul><li><strong>如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作</strong>。</li></ul><blockquote><p>第七步：扩容操作：</p></blockquote><ul><li>创建一个<strong>新的两倍大小</strong>的数组。</li><li>将旧数组中的键值对<strong>重新计算哈希码</strong>并分配到新数组中的位置。</li><li>更新HashMap的数组引用和阈值参数。</li></ul><blockquote><p>第八步：完成添加操作。</p></blockquote><p>此外，HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。</p><h2 id="7-HashMap的put-key-val-和get-key-过程"><a href="#7-HashMap的put-key-val-和get-key-过程" class="headerlink" title="7.HashMap的put(key,val)和get(key)过程"></a>7.HashMap的put(key,val)和get(key)过程</h2><ul><li>存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash<strong>从而得到bucket位</strong>置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(<strong>超过Load Facotr则resize为原来的2倍</strong>)。</li><li>获取对象时，我们将K传给get，它调用hashCode计算hash从而得到<strong>bucke</strong>t位置，并进一步调<strong>用equals()方法确定键值对</strong>。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</li></ul><h2 id="8-hashmap-调用get方法一定安全吗？"><a href="#8-hashmap-调用get方法一定安全吗？" class="headerlink" title="8.hashmap 调用get方法一定安全吗？"></a>8.hashmap 调用get方法一定安全吗？</h2><p>不是，调用 get 方法有几点需要注意的地方：</p><ul><li><strong>空指针异常（NullPointerException）</strong>：如果你尝试用 <code>null</code> 作为键调用 <code>get</code> 方法，<strong>而 <code>HashMap</code> 没有被初始化（即为 <code>null</code>）</strong>，那么会抛出空指针异常。不过，如果 <code>HashMap</code> 已经初始化，使用 <code>null</code> 作为键是允许的，因为 <code>HashMap</code> 支持 <code>null</code> 键。</li><li><strong>线程安全</strong>：<code>HashMap</code> 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 <code>HashMap</code> 进行读写操作可能会导致不可预测的行为。例如，<strong>在一个线程中调用 <code>get</code> 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 <code>ConcurrentModificationException</code>。</strong>如果需要在多线程环境中使用类似 <code>HashMap</code> 的数据结构，可以考虑使用 <code>ConcurrentHashMap</code>。</li></ul><h2 id="9-HashMap一般用什么做Key？为啥String适合做Key呢？"><a href="#9-HashMap一般用什么做Key？为啥String适合做Key呢？" class="headerlink" title="9.HashMap一般用什么做Key？为啥String适合做Key呢？"></a>9.HashMap一般用什么做Key？为啥String适合做Key呢？</h2><p>用 string 做 key，<strong>因为 String对象是不可变的</strong>，一旦创建就不能被修改，这确保了Key的稳定性。如果Key是可变的，<strong>可能会导致hashCode和equals方法的不一致，</strong>进而影响HashMap的正确性。</p><h2 id="10-为什么HashMap要用红黑树而不是平衡二叉树？"><a href="#10-为什么HashMap要用红黑树而不是平衡二叉树？" class="headerlink" title="10.为什么HashMap要用红黑树而不是平衡二叉树？"></a>10.为什么HashMap要用红黑树而不是平衡二叉树？</h2><ul><li>平衡二叉树追求的是一种 <strong>“完全平衡”</strong> 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，<strong>导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则</strong>，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li><li>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因。</li></ul><h2 id="11-hashmap-key可以为null吗？"><a href="#11-hashmap-key可以为null吗？" class="headerlink" title="11.hashmap key可以为null吗？"></a>11.hashmap key可以为null吗？</h2><p>可以为 null。但是需要<strong>初始化</strong></p><ul><li>hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1720685862193-66a32b79-ddf0-46d5-87df-d2fc2b3d87cb.png" alt="img"></p><ul><li>hashMap虽然支持key和value为null，<strong>但是null作为key只能有一个</strong>，null作为value可以有多个；</li><li>因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个</li></ul><h2 id="12-重写HashMap的equal和hashcode方法需要注意什么？"><a href="#12-重写HashMap的equal和hashcode方法需要注意什么？" class="headerlink" title="12.重写HashMap的equal和hashcode方法需要注意什么？"></a>12.重写HashMap的equal和hashcode方法需要注意什么？</h2><p>HashMap使用Key对象的<strong>hashCode()和equals方法去决定key-value对的索引</strong>。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，<strong>两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</strong></p><p>同样的，<strong>所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复</strong>，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p><ul><li>如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。</li><li>如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</li></ul><h2 id="13-重写HashMap的equal方法不当会出现什么问题？"><a href="#13-重写HashMap的equal方法不当会出现什么问题？" class="headerlink" title="13.重写HashMap的equal方法不当会出现什么问题？"></a>13.重写HashMap的equal方法不当会出现什么问题？</h2><p>HashMap在比较元素时，<strong>会先通过hashCode进行比较，相同的情况下再通过equals进行比较。</strong></p><p>所以 equals相等的两个对象，hashCode一定相等。<strong>hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）</strong>散列冲突是指：两个不同的对象（或值）经过哈希函数计算后，得到相同的哈希值</p><p><strong>重写了equals方法，不重写hashCode方法时</strong>，可能会出现equals方法返回为true，而hashCode方法却返回false，<strong>这样的一个后果会导致在hashmap等类中存储多个一模一样的对象，导致出现覆盖存储的数据的问题，这与hashmap只能有唯一的key的规范不符合。</strong></p><h2 id="14-列举HashMap在多线程下可能会出现的问题？"><a href="#14-列举HashMap在多线程下可能会出现的问题？" class="headerlink" title="14.列举HashMap在多线程下可能会出现的问题？"></a>14.列举HashMap在多线程下可能会出现的问题？</h2><ul><li>JDK1.7中的 HashMap 使用<strong>头插法</strong>插入元素，在多线程的环境下，<strong>扩容的时候有可能导致环形链表的出现，形成死循环。</strong>因此，JDK1.8使用<strong>尾插法</strong>插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li><li><strong>多线程同时执行 put 操作</strong>，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li></ul><h2 id="15-HashMap的扩容机制介绍一下"><a href="#15-HashMap的扩容机制介绍一下" class="headerlink" title="15.HashMap的扩容机制介绍一下"></a>15.HashMap的扩容机制介绍一下</h2><p>hashMap默认的<strong>负载因子是0.75</strong>，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容分为两个步骤：</p><ul><li><strong>第1步</strong>是对<strong>哈希表长度的扩展（2倍）</strong></li><li><strong>第2步</strong>是将旧哈希表中的数据放到新的哈希表中。</li></ul><p>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</strong></p><p>如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>。可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p><p>这个设计确实非常的巧妙，<strong>既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了</strong></p><h2 id="16-HashMap的大小为什么是2的n次方大小呢？"><a href="#16-HashMap的大小为什么是2的n次方大小呢？" class="headerlink" title="16.HashMap的大小为什么是2的n次方大小呢？"></a>16.HashMap的大小为什么是2的n次方大小呢？</h2><p>在 JDK1.7 中，HashMap <strong>整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。</strong>这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p><p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。<strong>由于扩容数组的长度是 2 倍关系</strong>，所以对于假设初始 tableSize = 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），<strong>在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。</strong></p><p>之所以能通过这种“与运算“来重新分配索引，<strong>是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，</strong>所以扩容的过程就能<strong>把之前哈希冲突的元素再随机分布到不同的索引中去。</strong></p><h2 id="17-往hashmap存20个元素，会扩容几次？"><a href="#17-往hashmap存20个元素，会扩容几次？" class="headerlink" title="17.往hashmap存20个元素，会扩容几次？"></a>17.往hashmap存20个元素，会扩容几次？</h2><p>当插入 20 个元素时，HashMap 的扩容过程如下：</p><p><strong>初始容量</strong>：16</p><ul><li>插入第 1 到第 12 个元素时，不需要扩容。</li><li>插入第 13 个元素时，达到负载因子限制，<strong>需要扩容。此时，HashMap 的容量从 16 扩容到 32。</strong></li></ul><p><strong>扩容后的容量</strong>：32</p><ul><li>插入第 14 到第 24 个元素时，不需要扩容。</li></ul><p>因此，总共会进行<strong>一次扩容</strong>。</p><h2 id="18-说说hashmap的负载因子"><a href="#18-说说hashmap的负载因子" class="headerlink" title="18.说说hashmap的负载因子"></a>18.说说hashmap的负载因子</h2><p>HashMap 负载因子 loadFactor 的默认值是 0.75，当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。</p><p>默认负载因子为 0.75，是因为它<strong>提供了空间和时间复杂度之间的良好平衡</strong>。</p><p><strong>负载因子太低会导致大量的空桶浪费空间</strong>，<strong>负载因子太高会导致大量的碰撞</strong>，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。</p><h2 id="19-Hashmap和Hashtable有什么不一样的？Hashmap一般怎么用？"><a href="#19-Hashmap和Hashtable有什么不一样的？Hashmap一般怎么用？" class="headerlink" title="19.Hashmap和Hashtable有什么不一样的？Hashmap一般怎么用？"></a>19.Hashmap和Hashtable有什么不一样的？Hashmap一般怎么用？</h2><ul><li><strong>HashMap线程不安全</strong>，<strong>效率高一点，可以存储null的key和value，</strong>null的key只能有一个，null的value可以有多个。<strong>默认初始容量为16</strong>，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li><strong>HashTable线程安全</strong>，<strong>效率低一点，其内部方法基本都经过synchronized修饰</strong>，<strong>不可以有null的key和value</strong>。<strong>默认初始容量为11</strong>，<strong>每次扩容变为原来的2n+1</strong>。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li><li><strong>怎么用</strong>：HashMap主要用来存储键值对，可以调用put方法向其中加入元素，调用get方法获取某个键对应的值，也可以通过containsKey方法查看某个键是否存在等</li></ul><h2 id="20-ConcurrentHashMap怎么实现的？"><a href="#20-ConcurrentHashMap怎么实现的？" class="headerlink" title="20.ConcurrentHashMap怎么实现的？"></a>20.ConcurrentHashMap怎么实现的？</h2><blockquote><p>JDK 1.7 ConcurrentHashMap</p></blockquote><p>在 JDK 1.7 中它使用的是<strong>数组加链表的形式</strong>实现的，而数组又分为：<strong>大数组 Segment 和小数组 HashEntry</strong>。 Segment 是一种<strong>可重入锁</strong>（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；<strong>HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1721807523151-41ad316a-6264-48e8-9704-5b362bc0083c.webp" alt="img"></p><p>JDK 1.7 ConcurrentHashMap <strong>分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</strong></p><blockquote><p>JDK 1.8 ConcurrentHashMap</p></blockquote><p>在 JDK 1.7 中，ConcurrentHashMap 虽然是线程安全的，<strong>但因为它的底层实现是数组 + 链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表</strong>，而 JDK 1.8 则使用了数组 + 链表/红黑树的方式优化了 ConcurrentHashMap 的实现，具体实现结构如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721807523128-7b1419e7-e6ba-47e6-aba0-8b29423a8ce7.webp" alt="img"></p><p>JDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap <strong>主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的</strong>。添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 CAS 来初始化</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空。<ul><li>如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；</li><li>如果根据存储的元素计算结果不为空，<strong>则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中</strong>，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul></li></ul><p>如果把上面的执行用一句话归纳的话，<strong>就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。</strong></p><p>而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。</p><h2 id="21-分段锁怎么加锁的？"><a href="#21-分段锁怎么加锁的？" class="headerlink" title="21.分段锁怎么加锁的？"></a>21.分段锁怎么加锁的？</h2><p>在 ConcurrentHashMap 中，将整个数据结构分为<strong>多个 Segment，每个 Segment 都类似于一个小的 HashMap，</strong>每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。</p><p>在 ConcurrentHashMap 中，对于插入、更新、删除等操作，<strong>需要先定位到具体的 Segment，然后再在该 Segment 上加锁，</strong>而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。</p><h2 id="22-已经用了synchronized，为什么还要用CAS呢？"><a href="#22-已经用了synchronized，为什么还要用CAS呢？" class="headerlink" title="22.已经用了synchronized，为什么还要用CAS呢？"></a>22.已经用了synchronized，为什么还要用CAS呢？</h2><p>ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，<strong>主要是根据锁竞争程度来判断的</strong>。</p><p>比如：在putVal中，如果<strong>计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值</strong>，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，<strong>那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。</strong></p><p>当<strong>发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了</strong>，因此这时候使用<strong>synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。</strong></p><h2 id="23-ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#23-ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="23.ConcurrentHashMap用了悲观锁还是乐观锁?"></a>23.ConcurrentHashMap用了悲观锁还是乐观锁?</h2><p>悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 <strong>CAS （乐观锁）</strong> 来初始化。</li><li>如果容器不为空，则<strong>根据存储的元素计算该位置是否为空。</strong></li><li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点；</li><li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul><h2 id="24-HashTable-底层实现原理是什么？"><a href="#24-HashTable-底层实现原理是什么？" class="headerlink" title="24.HashTable 底层实现原理是什么？"></a>24.HashTable 底层实现原理是什么？</h2><ul><li>Hashtable的底层数据结构主要是<strong>数组加上链表</strong>，数组是主体，<strong>链表是解决hash冲突存在的。</strong></li><li>HashTable是线程安全的，实现方式是<strong>Hashtable的所有公共方法均采用synchronized关键字</strong>，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1719982934770-8587cb0a-6e1d-4007-9a22-bc1e41276491.png" alt=""></p><h2 id="25-HashTable线程安全是怎么实现的？"><a href="#25-HashTable线程安全是怎么实现的？" class="headerlink" title="25.HashTable线程安全是怎么实现的？"></a>25.HashTable线程安全是怎么实现的？</h2><p>因为它的put，get做成了同步方法，保证了Hashtable的线程安全性，每个操作数据的方法都进行同步控制之后，由此带来的问题任何一个时刻<strong>只能有一个线程可以操纵Hashtable，所以其效率比较低</strong>。</p><p>Hashtable 的 put(K key, V value) 和 get(Object key) 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"><span class="comment">// Make sure the value is not null</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line"><span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">        entry.value = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> addEntry(hash, key, value, index);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (V)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Hashtable是通过使用了 synchronized 关键字来保证其线程安全</strong>。</p><p>在Java中，可以使用synchronized关键字来标记一个方法或者代码块，<strong>当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</strong></p><h2 id="26-说一下HashMap和Hashtable、ConcurrentMap的区别"><a href="#26-说一下HashMap和Hashtable、ConcurrentMap的区别" class="headerlink" title="26.说一下HashMap和Hashtable、ConcurrentMap的区别"></a>26.说一下HashMap和Hashtable、ConcurrentMap的区别</h2><ul><li>HashMap<strong>线程不安全</strong>，效率高一点，<strong>可以存储null的key和value，null的key只能有一个，null的value可以有多个</strong>。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li>HashTable线程安全，效率低一点，<strong>其内部方法基本都经过synchronized修饰</strong>，不可以有null的key和value。<strong>默认初始容量为11</strong>，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li><li>ConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的<strong>实现原理主要基于分段锁和CAS操作</strong>。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。<strong>在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。</strong></li></ul><h2 id="27-说说concurrenthashmap和hashmap的区别，说说copyonwritearraylist，copyonwrite会加锁吗？"><a href="#27-说说concurrenthashmap和hashmap的区别，说说copyonwritearraylist，copyonwrite会加锁吗？" class="headerlink" title="27.说说concurrenthashmap和hashmap的区别，说说copyonwritearraylist，copyonwrite会加锁吗？"></a>27.说说concurrenthashmap和hashmap的区别，说说copyonwritearraylist，copyonwrite会加锁吗？</h2><p><strong>HashMap</strong>：<strong>非线程安全</strong>，在并发写入时可能导致数据不一致，甚至死循环（JDK 1.7 链表转成环形）。</p><p><strong>ConcurrentHashMap</strong>：<strong>线程安全</strong>，内部通过分段锁（JDK 1.7）或 <strong>CAS + synchronized（JDK 1.8）</strong> 实现并发访问控制。</p><p><code>ConcurrentHashMap</code> 用 <strong>CAS + synchronized</strong> 控制粒度细的写操作</p><p>使用 <code>Node</code> 数组 + 链表 + 红黑树结构，提升查询效率</p><p>读操作（如 <code>get</code>）<strong>无锁</strong></p><p>写操作（如 <code>put/remove</code>）使用 <code>synchronized</code> 仅锁住<strong>当前桶</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>HashMap</th><th>ConcurrentHashMap</th></tr></thead><tbody><tr><td>线程安全</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>底层结构</td><td>数组 + 链表/红黑树</td><td>相同，但加了线程安全控制</td></tr><tr><td>并发机制</td><td>无</td><td>分段锁（1.7），CAS+锁（1.8）</td></tr><tr><td>允许 null key/value</td><td>✅ 是</td><td>❌ 都不允许</td></tr></tbody></table></div><p>CopyOnWriteArrayList</p><ul><li>写时复制，读无锁，<strong>写操作加锁</strong></li><li>适合<strong>读多写少</strong>场景</li><li>不适合频繁写入（复制开销大</li></ul><p>是的，<strong><code>CopyOnWriteArrayList</code> 的写操作会加锁</strong>，使用的是 <strong><code>ReentrantLock</code></strong></p><blockquote><p><strong>写操作时复制数组，修改新数组，最后替换原数组引用</strong>。</p></blockquote><p>为了保证“复制 + 修改 + 替换”这整个过程是<strong>原子的、线程安全的</strong>，就必须在写操作时加锁。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="1-Set集合有什么特点？如何实现key无重复的？"><a href="#1-Set集合有什么特点？如何实现key无重复的？" class="headerlink" title="1.Set集合有什么特点？如何实现key无重复的？"></a>1.Set集合有什么特点？如何实现key无重复的？</h2><ul><li><strong>set集合特点</strong>：Set集合中的元素是<strong>唯一</strong>的，不会出现重复的元素。</li><li><strong>set实现原理</strong>：Set集合通过<strong>内部的数据结构（如哈希表、红黑树等）来实现key的无重复。</strong>当向Set集合中插入元素时，会<strong>先根据元素的hashCode值来确定元素的存储位置，然后再通过equals方法来判断是否已经存在相同的元素</strong>，如果存在则不会再次插入，保证了元素的唯一性。</li></ul><h2 id="2-有序的Set是什么？记录插入顺序的集合是什么？"><a href="#2-有序的Set是什么？记录插入顺序的集合是什么？" class="headerlink" title="2.有序的Set是什么？记录插入顺序的集合是什么？"></a>2.有序的Set是什么？记录插入顺序的集合是什么？</h2><ul><li><strong>有序的 Set 是TreeSet和LinkedHashSet</strong>。<strong>TreeSet是基于红黑树实现，保证元素的自然顺序。LinkedHashSet是基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序</strong></li><li><strong>记录插入顺序的集合通常指的是LinkedHashSet</strong>，它不仅保证元素的唯一性，<strong>还可以保持元素的插入顺序</strong>。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/23/javase/javase3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC-线程池面试题hot</title>
      <link>https://blog.tokenlen.top/2025/05/22/java-stack/juc2/</link>
      <guid>https://blog.tokenlen.top/2025/05/22/java-stack/juc2/</guid>
      <pubDate>Wed, 21 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;h2 id=&quot;1-线程池用过没有？-说说他的核心参数？&quot;&gt;&lt;a href=&quot;#1-线程池用过没有？-说说他的核心参数？&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-线程池用过没有？-说说他的核心参数？"><a href="#1-线程池用过没有？-说说他的核心参数？" class="headerlink" title="1.线程池用过没有？ 说说他的核心参数？"></a>1.线程池用过没有？ 说说他的核心参数？</h2><p>线程在正常执行或者异常中断时会被销毁，如果频繁的创建很多线程，不仅会消耗系统资源，还会降低系统的稳定性，一不小心把系统搞崩了。</p><p>使用线程池可以带来以下几个好处：</p><ul><li>线程池内部的线程数是可控的，可以灵活的设置参数；</li><li>线程池内会保留部分线程，当提交新的任务可以直接运行；</li><li>方便内部线程资源的管理，调优和监控；</li></ul><p><strong>为了减少频繁的创建线程和销毁线程带来的性能损耗</strong></p><p>首先，所有任务的调度都是由<strong>execute</strong>方法完成的，这部分完成的工作是：检查现在线程池的<strong>运行状态、运行线程数、运行策略</strong>，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p><p>首先检测线程池运行状态，如果不是<strong>RUNNING</strong>，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</p><p>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</p><p>如果workerCount &gt;= corePoolSize，且线程池内的<strong>阻塞队列</strong>未满，则将任务添加到该阻塞队列中。</p><p>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则<strong>创建并启动一个线程</strong>来执行新提交的任务。</p><p>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据<strong>拒绝策略</strong>来处理该任务, <strong>默认的处理方式是直接抛异常。</strong></p><p>七大核心参数：</p><p><strong>corePoolSize</strong>：线程池核心线程数量，如果设置为5，线程池初始化后默认保持5个线程待命。默认情况下，线程池中线程的数量如果 &lt;= corePoolSize，那么即使这些线程处于空闲状态，那也不会被销毁。</p><p><strong>maximumPoolSize</strong>：线程池允许的最大线程数。当任务队列已满，且当前线程数小于 <code>maximumPoolSize</code> 时，线程池会创建新的线程来处理任务，直至线程数达到 <code>maximumPoolSize</code>。</p><p><strong>keepAliveTime</strong>：当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过了keepAliveTime，那么这个线程就会被销毁。</p><p><strong>unit</strong>：就是keepAliveTime时间的单位。</p><p><strong>workQueue</strong>：工作队列。当没有空闲的线程执行新任务时，该任务就会被放入工作队列中，等待执行。</p><p><strong>threadFactory</strong>：用于创建线程的工厂。通过自定义线程工厂，你可以为线程设置名称、优先级等属性。</p><p><strong>handler</strong>：拒绝策略。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程，就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略</p><h2 id="2-线程池的拒绝策略"><a href="#2-线程池的拒绝策略" class="headerlink" title="2.线程池的拒绝策略"></a>2.线程池的拒绝策略</h2><p>常用的四种拒绝策略包括：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy，此外，还可以通过实现<strong>RejectedExecutionHandler</strong>接口来自定义拒绝策略。</p><p>CallerRunsPolicy，使用线程池的调用者所在的线程去执行被拒绝的任务，除非线程池被停止或者线程池的任务队列已有空缺。</p><p><strong>AbortPolicy，直接抛出一个任务被线程池拒绝的异常。</strong>这个是默认的</p><p>DiscardPolicy，不做任何处理，静默拒绝提交的任务。</p><p>DiscardOldestPolicy，抛弃最老的任务，然后执行该任务。</p><p>自定义拒绝策略，通过实现接口可以自定义任务拒绝策略。</p><p><strong>RejectedExecutionHandler实现</strong></p><h2 id="3-描述一下创建一个线程池，提交任务的过程"><a href="#3-描述一下创建一个线程池，提交任务的过程" class="headerlink" title="3.描述一下创建一个线程池，提交任务的过程"></a>3.描述一下创建一个线程池，提交任务的过程</h2><p>我们创建线程池的时候，需要使用到ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    corePoolSize,     <span class="comment">// 核心线程数</span></span><br><span class="line">    maximumPoolSize,  <span class="comment">// 最大线程数</span></span><br><span class="line">    keepAliveTime,    <span class="comment">// 非核心线程最大空闲存活时间</span></span><br><span class="line">    unit,             <span class="comment">// 时间单位</span></span><br><span class="line">    workQueue,        <span class="comment">// 阻塞队列（任务队列）</span></span><br><span class="line">    threadFactory,    <span class="comment">// 线程工厂（创建线程的策略）</span></span><br><span class="line">    handler           <span class="comment">// 拒绝策略</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提交任务的过程：</p><p>调用 <code>ThreadPoolExecutor.execute()</code> </p><p>判断线程数是否小于核心线程数</p><p>如果当前线程数 <strong>&lt; 核心线程数</strong>：</p><ul><li>直接创建线程执行任务（<strong>立刻执行，不入队列</strong>）</li></ul><p>核心线程已满 → 尝试将任务放入工作队列</p><p>如果核心线程都在运行，任务会尝试<strong>进入阻塞队列</strong>。</p><p>如果入队成功：</p><ul><li>等待空闲线程从队列中取任务执行</li></ul><p>如果入队失败（队列满了）：尝试创建非核心线程，如果线程数 &lt; 最大线程数，则创建非核心线程执行任务。</p><p>线程数也满了 → 启动拒绝策略</p><p>还包括一个addWorker()方法，是创建线程的核心方法</p><p>使用线程工厂创建线程</p><p>将线程封装为 <code>Worker</code> 对象</p><p>加入 <code>workers</code> 工作线程集合</p><p>启动线程并执行任务</p><p>每个工作线程在启动后会不断循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    task.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>getTask()</code> 从阻塞队列中获取任务。</p><p>核心线程：空闲时仍保留</p><p>非核心线程：如果超过 keepAliveTime 未获取到任务，则被销毁</p><h2 id="4-一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的"><a href="#4-一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的" class="headerlink" title="4.一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的"></a>4.一个任务执行完后，如果再往线程池中提交一个任务，过程是什么样的</h2><p>如果<strong>线程池仍然存活</strong>，此时<strong>再提交一个任务的过程</strong>，与最初提交任务时几乎相同，但会受到<strong>已有线程空闲可复用</strong>的影响.</p><p>线程池中已有线程执行完任务，进入<strong>空闲状态</strong>；</p><p>此时再次提交一个新任务。</p><p>依旧会执行 <code>ThreadPoolExecutor.execute(Runnable command)</code></p><p>检查是否需要创建新线程,一般是当前线程数已达到核心线程数；上一个任务刚执行完，线程处于空闲状态；</p><p>尝试将任务加入队列，如果线程池使用的是有界队列（LinkedBlockingQueue）任务直接入队；<strong>等待空闲线程来取任务执行</strong>，不再新建线程。</p><p>如果是 <code>SynchronousQueue</code>，进行下一步</p><p>是否需要创建非核心线程，，如果队列失败，线程数尚未超过最大线程数：，创建线程执行任务（非核心线程）</p><p>否则，进入拒绝策略，队列满、线程也满 → 拒绝任务</p><p>Woker循环</p><p>会尝试从队列中获取下一个任务；</p><p>如果任务队列中有新任务：</p><ul><li>该线程<strong>继续执行新任务</strong>；</li></ul><p>如果队列无任务：</p><ul><li>核心线程：一直等待；</li><li>非核心线程：空闲超过 <code>keepAliveTime</code> 会销毁。</li></ul><p>如果线程池被 shutdown，则 <code>execute()</code> 会拒绝任务；</p><h2 id="5-执行完第二个任务后，线程池里面还会有几个线程"><a href="#5-执行完第二个任务后，线程池里面还会有几个线程" class="headerlink" title="5.执行完第二个任务后，线程池里面还会有几个线程"></a>5.执行完第二个任务后，线程池里面还会有几个线程</h2><p>一般情况（默认配置、核心线程不回收）：</p><ul><li><strong>执行两个任务后，线程池中会保留两个核心线程</strong>。</li></ul><p>若用非核心线程、任务执行完后等待空闲：</p><ul><li>执行完立即：线程池中还有 2 个线程（核心 + 非核心）；</li><li>超过 <code>keepAliveTime</code> 后：只剩下核心线程；</li></ul><h2 id="6-有线程池参数设置的经验吗？"><a href="#6-有线程池参数设置的经验吗？" class="headerlink" title="6.有线程池参数设置的经验吗？"></a>6.有线程池参数设置的经验吗？</h2><p>核心线程数（corePoolSize）设置的经验：</p><ul><li>CPU密集型：corePoolSize = CPU核数 + 1（避免过多线程竞争CPU）</li><li>IO密集型：corePoolSize = CPU核数 x 2（或更高，具体看IO等待时间）</li></ul><p>场景一：电商场景，<strong>特点瞬时高并发、任务处理时间短</strong>，线程池的配置可设置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                     <span class="comment">// corePoolSize = 16（假设8核CPU × 2）</span></span><br><span class="line">    <span class="number">32</span>,                     <span class="comment">// maximumPoolSize = 32（突发流量扩容）</span></span><br><span class="line">    <span class="number">10</span>, TimeUnit.SECONDS,   <span class="comment">// 非核心线程空闲10秒回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), <span class="comment">// 不缓存任务，直接扩容线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>()       <span class="comment">// 直接拒绝，避免系统过载</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>使用<code>SynchronousQueue</code><strong>确保任务直达线程，避免队列延迟</strong>。</li><li>拒绝策略快速失败，前端返回“活动火爆”提示，结合降级策略（如缓存预热）。</li></ul><p>场景二：后台数据处理服务，特点稳定流量、任务处理时间长（秒级）、允许一定延迟，线程池的配置可设置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>,                      <span class="comment">// corePoolSize = 8（8核CPU）</span></span><br><span class="line">    <span class="number">8</span>,                      <span class="comment">// maximumPoolSize = 8（禁止扩容，避免资源耗尽）</span></span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS,    <span class="comment">// 不回收线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="comment">// 有界队列，容量1000</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CallerRunsPolicy</span>()  <span class="comment">// 队列满后由调用线程执行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>固定线程数避免资源波动，队列缓冲任务，拒绝策略兜底。</li><li>配合监控告警（如队列使用率&gt;80%触发扩容）。</li></ul><p>场景三：微服务HTTP请求处理，特点IO密集型、依赖下游服务响应时间，线程池的配置可设置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                     <span class="comment">// corePoolSize = 16（8核 × 2）</span></span><br><span class="line">    <span class="number">64</span>,                     <span class="comment">// maximumPoolSize = 64（应对慢下游）</span></span><br><span class="line">    <span class="number">60</span>, TimeUnit.SECONDS,   <span class="comment">// 非核心线程空闲60秒回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">200</span>), <span class="comment">// 有界队列容量200</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRetryPolicy</span>() <span class="comment">// 自定义拒绝策略（重试或降级）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>根据下游RT（响应时间）调整线程数，队列防止瞬时峰值。</li><li>自定义拒绝策略将任务暂存Redis，异步重试。</li></ul><h2 id="7-核心线程数设置为0可不可以？"><a href="#7-核心线程数设置为0可不可以？" class="headerlink" title="7.核心线程数设置为0可不可以？"></a>7.<strong>核心线程数设置为0可不可以？</strong></h2><p>可以，当核心线程数为0的时候，会创建一个非核心线程进行执行。</p><p>从下面的源码也可以看到，当核心线程数为 0 时，来了一个任务之后，会先将任务添加到任务队列，同时也会判断当前工作的线程数是否为 0，如果为 0，则会创建线程来执行线程池的任务。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820113849549.png" alt="image-20240820113849549"></p><h2 id="8-线程池种类有哪些？"><a href="#8-线程池种类有哪些？" class="headerlink" title="8.线程池种类有哪些？"></a>8.线程池种类有哪些？</h2><ul><li><strong>ScheduledThreadPool</strong>：可以<strong>设置定期的执行任务</strong>，它支持定时或周期性执行任务，比如每隔 10 秒钟执行一次任务，我通过这个实现类设置定期执行任务的策略。</li><li>FixedThreadPool：它的<strong>核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池</strong>，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</li><li>CachedThreadPool：可以称作<strong>可缓存线程池</strong>，<strong>它的特点在于线程数是几乎可以无限增加</strong>的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。</li><li>SingleThreadExecutor：它会<strong>使用唯一的线程去执行任务</strong>，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，<strong>所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景</strong>，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</li><li>SingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。</li></ul><h2 id="9-线程池一般是怎么用的？"><a href="#9-线程池一般是怎么用的？" class="headerlink" title="9.线程池一般是怎么用的？"></a>9.线程池一般是怎么用的？</h2><p>Java 中的 Executors 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，<strong>而应该手动 new ThreadPoolExecutor 来创建线程池。</strong>这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 newFixedThreadPool 和 newCachedThreadPool，可能因为资源耗尽导致 OOM 问题。</p><p>所以，不建议使用 Executors 提供的两种快捷的线程池，原因如下：</p><ul><li>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。</li><li>任何时候，都应该为<strong>自定义线程池指定有意义的名称</strong>，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。</li></ul><p>除了建议手动声明线程池以外，我还建议用<strong>一些监控手段来观察线程池的状态</strong>。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p><h2 id="10-线程池中shutdown-，shutdownNow-这两个方法有什么作用？"><a href="#10-线程池中shutdown-，shutdownNow-这两个方法有什么作用？" class="headerlink" title="10.线程池中shutdown ()，shutdownNow()这两个方法有什么作用？"></a>10.线程池中shutdown ()，shutdownNow()这两个方法有什么作用？</h2><p>从下面的源码【高亮】注释可以很清晰的看出两者的区别：</p><ul><li>shutdown<strong>使用了以后会置状态为SHUTDOWN</strong>，正在执行的任务会继续执行下去，没有被执行的则中断。<strong>此时，则不能再往线程池中添加任何任务，否则将会抛出 RejectedExecutionException 异常</strong> 比较平缓的关闭方式</li><li>而 shutdownNow <strong>为STOP，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。</strong> 它试图终止线程的方法是通过调用 <strong>Thread.interrupt() 方法来实现的，</strong>但是这种方法的作用有限，<strong>如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。</strong>所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。</li></ul><p><strong>shutdown 源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">checkShutdownAccess();</span><br><span class="line"><span class="comment">// 高亮</span></span><br><span class="line">advanceRunState(SHUTDOWN);</span><br><span class="line">interruptIdleWorkers();</span><br><span class="line">onShutdown();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shutdownNow 源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">List&lt;Runnable&gt; tasks;</span><br><span class="line"><span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">checkShutdownAccess();</span><br><span class="line"><span class="comment">// 高亮</span></span><br><span class="line">advanceRunState(STOP);</span><br><span class="line">interruptWorkers();</span><br><span class="line"><span class="comment">// 高亮</span></span><br><span class="line">tasks = drainQueue();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">mainLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">tryTerminate();</span><br><span class="line"><span class="comment">// 高亮</span></span><br><span class="line"><span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-提交给线程池中的任务可以被撤回吗？"><a href="#11-提交给线程池中的任务可以被撤回吗？" class="headerlink" title="11.提交给线程池中的任务可以被撤回吗？"></a>11.提交给线程池中的任务可以被撤回吗？</h2><p>可以，当向线程池提交任务时，<strong>会得到一个<code>Future</code>对象。这个<code>Future</code>对象提供了几种方法来管理任务的执行，包括取消任务。</strong></p><p>取消任务的主要方法是<code>Future</code>接口中的<code>cancel(boolean mayInterruptIfRunning)</code>方法。这个方法尝试取消执行的任务。<strong>参数<code>mayInterruptIfRunning</code>指示是否允许中断正在执行的任务</strong>。如果设置为<code>true</code>，则表示如果任务已经开始执行，那么允许中断任务；如果设置为<code>false</code>，任务已经开始执行则不会被中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 是否取消线程的执行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 线程是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//线程是否执行完毕</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">      <span class="comment">// 立即获得线程返回的结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">      <span class="comment">// 延时时间后再获得线程返回的结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消线程池中任务的方式，代码如下，通过 future 对象的 cancel(boolean) 函数来定向取消特定的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> service.submit(<span class="keyword">new</span> <span class="title class_">TheradDemo</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 可能抛出异常</span></span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//终止任务的执行</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-java里面的线程和操作系统的线程一样吗？"><a href="#1-java里面的线程和操作系统的线程一样吗？" class="headerlink" title="1.java里面的线程和操作系统的线程一样吗？"></a>1.java里面的线程和操作系统的线程一样吗？</h2><p>Java 底层会调用 pthread_create 来创建线程，所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。</p><h2 id="2-使用多线程要注意哪些问题？"><a href="#2-使用多线程要注意哪些问题？" class="headerlink" title="2.使用多线程要注意哪些问题？"></a>2.使用多线程要注意哪些问题？</h2><p>要保证多线程的程序是安全，不要出现数据竞争造成的数据混乱的问题。</p><p>Java的线程安全在三个方面体现：</p><ul><li><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了<strong>atomic</strong>包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和synchronized关键字来确保原子性；比如CAS</li><li><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了<strong>synchronized和volatile</strong>这两个关键字确保可见性；</li><li><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。比如volatile</li></ul><h2 id="3-保证数据的一致性有哪些方案呢？"><a href="#3-保证数据的一致性有哪些方案呢？" class="headerlink" title="3.保证数据的一致性有哪些方案呢？"></a>3.保证数据的一致性有哪些方案呢？</h2><ul><li><strong>事务管理</strong>：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。</li><li><strong>锁机制</strong>：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。</li><li><strong>版本控制</strong>：通过乐观锁的方式，在<strong>更新数据时记录数据的版本信息</strong>，从而避免同时对同一数据进行修改，进而保证数据的一致性。</li></ul><h2 id="4-线程的创建方式有哪些"><a href="#4-线程的创建方式有哪些" class="headerlink" title="4.线程的创建方式有哪些?"></a>4.线程的创建方式有哪些?</h2><blockquote><p>1.继承Thread类</p></blockquote><p>这是最直接的一种方式，用户自定义类继承java.lang.Thread类，<strong>重写其run()方法</strong>，run()方法中定义了线程执行的具体任务。创建该类的实例后，通过调用start()方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用继承Thread类方式</p><ul><li>优点: 编写简单，如果需要访问当前线程，无需使用Thread.currentThread ()方法，直接使用this，即可获得当前线程</li><li>缺点:因为线程类已经<strong>继承了Thread类，所以不能再继承其他的父类</strong></li></ul><blockquote><p>2.实现Runnable接口</p></blockquote><p>如果一个类已经继承了其他类，就不能再继承Thread类，此时可以实现java.lang.Runnable接口。<strong>实现Runnable接口需要重写run()方法</strong>，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其start()方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用实现Runnable接口方式：</p><ul><li>优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li><li>缺点：<strong>编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</strong></li></ul><blockquote><ol><li>实现Callable接口与FutureTask</li></ol></blockquote><p>java.util.concurrent.Callable接口类似于Runnable，<strong>但Callable的call()方法可以有返回值并且可以抛出异常。</strong>要执行Callable任务，需将它包装进一个<strong>FutureTask</strong>，因为Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码，这里返回一个整型结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();  <span class="comment">// 获取线程执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用实现Callable接口方式：</p><ul><li>缺点：编程稍微复杂，如果需要访问当前线程，<strong>必须调用Thread.currentThread()方法。</strong></li><li>优点：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</li></ul><blockquote><ol><li>使用线程池（Executor框架）</li></ol></blockquote><p>从Java 5开始引入的java.util.concurrent.ExecutorService和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过<strong>Executors</strong>类的静态方法创建不同类型的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);  <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());  <span class="comment">// 提交任务到线程池执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();  <span class="comment">// 关闭线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用线程池方式：</p><ul><li>缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。<strong>错误的配置可能导致死锁、资源耗尽等问题</strong>，这些问题的诊断和修复可能较为复杂。</li><li>优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。</li></ul><p>Exectors提供的三个线程池不好使，要实际应该还是应该自己设计一个线程池</p><h2 id="5-怎么启动线程-？"><a href="#5-怎么启动线程-？" class="headerlink" title="5.怎么启动线程 ？"></a>5.怎么启动线程 ？</h2><p>启动线程的通过Thread类的<strong>start()</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个线程，用start启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();  </span><br></pre></td></tr></table></figure><p>新建线程调用<strong>start()方法后</strong>，线程并不会立即进入运行状态。线程的状态变化是：<strong>新建→就绪→运行</strong>。调用start()方法后，线程会进入就绪状态，等待CPU调度才能进入运行状态。这取决于线程调度器的调度策略。start()方法会<strong>创建新的线程并执行run()方法</strong>，而直接调用run()方法只会在<strong>当前线程中执行</strong>，不会启动新线程。</p><h2 id="6-如何停止一个线程的运行"><a href="#6-如何停止一个线程的运行" class="headerlink" title="6.如何停止一个线程的运行?"></a>6.如何停止一个线程的运行?</h2><p>主要有这些方法：</p><ul><li><strong>异常法停止</strong>：<strong>线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态</strong>，如果是中断状态则抛出异常，达到中断线程的效果。</li><li><strong>在沉睡中停止</strong>：先将<strong>线程sleep</strong>，然后<strong>调用interrupt标记中断状态</strong>，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果</li><li><strong>stop()暴力停止</strong>：线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些请理性的工作得不到完成。可以使用shutdown方法</li><li><strong>使用return停止线程</strong>：<strong>调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return</strong>，能达到停止线程的效果。</li></ul><h2 id="7-调用-interrupt-是如何让线程抛出异常的"><a href="#7-调用-interrupt-是如何让线程抛出异常的" class="headerlink" title="7.调用 interrupt 是如何让线程抛出异常的?"></a>7.调用 interrupt 是如何让线程抛出异常的?</h2><p>每个线程都一个与之关联的布尔属性来表示其中断状态，<strong>中断状态的初始值为false</strong>，当一个线程被其它线程调用<code>Thread.interrupt()</code>方法中断时，会根据实际情况做出响应。</p><ul><li>如果该线程正在执行低级别的可中断方法（如<code>Thread.sleep()</code>、<code>Thread.join()</code>或<code>Object.wait()</code>），则会<strong>解除阻塞</strong>并<strong>抛出<code>InterruptedException</code>异常</strong>。</li><li>否则<code>Thread.interrupt()</code>仅设置线程的中断状态，<strong>在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。</strong></li></ul><p><img src="https://uploadfiles.nowcoder.com/images/20250422/59_1745314586904/AB85F6C1A80F74538F959A181704EA92" alt=""></p><h2 id="8-Java线程的状态有哪些？"><a href="#8-Java线程的状态有哪些？" class="headerlink" title="8.Java线程的状态有哪些？"></a>8.Java线程的状态有哪些？</h2><div class="table-container"><table><thead><tr><th>线程状态</th><th>解释</th></tr></thead><tbody><tr><td>NEW</td><td>尚未启动的线程状态，即线程创建，<strong>还未调用start方法</strong></td></tr><tr><td>RUNNABLE</td><td><strong>就绪状态</strong>（调用start，等待调度）+<strong>正在运行</strong></td></tr><tr><td>BLOCKED</td><td><strong>等待监视器锁</strong>时，陷入阻塞状态</td></tr><tr><td>WAITING</td><td>等待状态的线程正在<strong>等待</strong>另一线程执行特定的操作（如notify）</td></tr><tr><td>TIMED_WAITING</td><td>具有<strong>指定等待时间</strong>的等待状态</td></tr><tr><td>TERMINATED</td><td>线程完成执行，<strong>终止状态</strong></td></tr></tbody></table></div><h2 id="9-sleep-和-wait的区别是什么？"><a href="#9-sleep-和-wait的区别是什么？" class="headerlink" title="9.sleep 和 wait的区别是什么？"></a>9.sleep 和 wait的区别是什么？</h2><p>对比例表：</p><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><code>sleep()</code></th><th><code>wait()</code></th></tr></thead><tbody><tr><td>所属类</td><td><code>Thread</code> 类（静态方法）</td><td><code>Object</code> 类（实例方法）</td></tr><tr><td>锁释放</td><td>❌</td><td>✅</td></tr><tr><td>使用前提</td><td>任意位置调用</td><td>必须在同步块内（持有锁）</td></tr><tr><td>唤醒机制</td><td>超时自动恢复</td><td>需 <code>notify()</code>/<code>notifyAll()</code> 或超时</td></tr><tr><td>设计用途</td><td>暂停线程执行，不涉及锁协作</td><td>线程间协调，释放锁让其他线程工作</td></tr></tbody></table></div><ul><li><strong>所属分类的不同</strong>：sleep 是 <code>Thread</code> 类的静态方法，可以在任何地方直接通过 <code>Thread.sleep()</code> 调用，无需依赖对象实例。wait 是 <code>Object</code> 类的实例方法，这意味着必须通过对象实例来调用。</li><li><strong>锁释放的情况</strong>：<code>Thread.sleep()</code> 在调用时，线程会暂停执行指定的时间，但不会释放持有的对象锁。也就是说，在 <code>sleep</code> 期间，其他线程无法获得该线程持有的锁。<code>Object.wait()</code>：调用该方法时，<strong>线程会释放持有的对象锁，进入等待状态，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它</strong></li><li><strong>使用条件</strong>：sleep 可在任意位置调用，无需事先获取锁。 <strong>wait 必须在同步块或同步方法内调用（即线程需持有该对象的锁），否则抛出 <code>IllegalMonitorStateException</code>。</strong></li><li><strong>唤醒机制</strong>：sleep 休眠时间结束后，线程 自动恢复 到就绪状态，等待CPU调度。wait 需要其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法才能被唤醒。<code>notify()</code> 会随机唤醒一个在该对象上等待的线程，而 <code>notifyAll()</code> 会唤醒所有在该对象上等待的线程。</li></ul><h2 id="10-sleep会释放cpu吗？"><a href="#10-sleep会释放cpu吗？" class="headerlink" title="10.sleep会释放cpu吗？"></a>10.sleep会释放cpu吗？</h2><p>是的，调用 <code>Thread.sleep()</code> 时，线程会释放 CPU，但不会释放持有的锁。</p><p><strong>当线程调用</strong> <code>sleep()</code> <strong>后，会主动让出 CPU 时间片</strong>，进入 <code>TIMED_WAITING</code> 状态。此时操作系统会触发调度，将 CPU 分配给其他处于就绪状态的线程。这样其他线程（无论是需要同一锁的线程还是不相关线程）便有机会执行。</p><p><code>sleep()</code> <strong>不会释放线程已持有的任何锁</strong>（如 <code>synchronized</code> 同步代码块或方法中获取的锁）。因此，如果有其他线程试图获取同一把锁，它们仍会被阻塞，直到原线程退出同步代码块。</p><h2 id="11-blocked和waiting有啥区别"><a href="#11-blocked和waiting有啥区别" class="headerlink" title="11.blocked和waiting有啥区别"></a>11.blocked和waiting有啥区别</h2><p>区别如下：</p><ul><li><strong>触发条件</strong>:线程进入BLOCKED状态通常是<strong>因为试图获取一个对象的锁（monitor lock），但该锁已经被另一个线程持有。</strong>这通常发生在尝试进入synchronized块或方法时，如果锁已被占用，则线程将被阻塞直到锁可用。<strong>线程进入WAITING状态是因为它正在等待另一个线程执行某些操作</strong>，例如调用Object.wait()方法、Thread.join()方法或LockSupport.park()方法。在这种状态下，<strong>线程将不会消耗CPU资源，并且不会参与锁的竞争。</strong></li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/93a0d1531ea1271770686b9e91664a9c.png" alt="img"></p><ul><li><strong>唤醒机制</strong>:当一个线程被阻塞等待锁时，<strong>一旦锁被释放，线程将有机会重新尝试获取锁</strong>。如果锁此时未被其他线程获取，那么线程可以从BLOCKED状态变为RUNNABLE状态。线程在<strong>WAITING状态中需要被显式唤醒</strong>。例如，如果线程调用了Object.wait()，那么它必须等待另一个线程调用同一对象上的Object.notify()或Object.notifyAll()方法才能被唤醒。</li></ul><p>所以，BLOCKED和WAITING两个状态最大的区别有两个：</p><ul><li>BLOCKED是<strong>锁竞争失败后被被动触发的状态，WAITING是人为的主动触发的状态</strong></li><li>BLCKED的<strong>唤醒时自动触发</strong>的，而WAITING状态是必须要通过特定的方法来主动唤醒</li></ul><h2 id="12-wait-状态下的线程如何进行恢复到-running-状态"><a href="#12-wait-状态下的线程如何进行恢复到-running-状态" class="headerlink" title="12.wait 状态下的线程如何进行恢复到 running 状态?"></a>12.wait 状态下的线程如何进行恢复到 running 状态?</h2><p>程从 <code>等待（WAIT）</code> 状态恢复到 <code>运行（RUNNING）</code> 状态的核心机制是 <strong>通过外部事件触发或资源可用性变化</strong>，比如等待的线程<strong>被其他线程对象唤醒</strong>，<code>notify()</code>和<code>notifyAll()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 线程进入等待状态，释放锁</span></span><br><span class="line">    lock.wait(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他线程调用以下代码唤醒等待线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.notify();      <span class="comment">// 唤醒单个线程</span></span><br><span class="line">    <span class="comment">// lock.notifyAll(); // 唤醒所有等待线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-notify-和-notifyAll-的区别"><a href="#13-notify-和-notifyAll-的区别" class="headerlink" title="13.notify 和 notifyAll 的区别?"></a>13.notify 和 notifyAll 的区别?</h2><p>同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制哪个线程获得锁。</p><p>区别在于：</p><ul><li>notify：<strong>唤醒一个线程</strong>，其他线程依然处于wait的等待唤醒状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断</li><li>notifyAll：所有线程退出wait的状态，<strong>开始竞争锁</strong>，<strong>但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁</strong></li></ul><h2 id="14-notify-选择哪个线程"><a href="#14-notify-选择哪个线程" class="headerlink" title="14.notify 选择哪个线程?"></a>14.notify 选择哪个线程?</h2><p>notify在源码的注释中说到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725230457096.png" alt="image-20240725230457096"></p><p>JVM有很多实现，比较流行的就是<strong>hotspot</strong>，hotspot对notofy()的实现并不是我们以为的随机唤醒,，<strong>而是“先进先出”的顺序唤醒。</strong></p><h2 id="15-不同的线程之间如何通信？"><a href="#15-不同的线程之间如何通信？" class="headerlink" title="15.不同的线程之间如何通信？"></a>15.不同的线程之间如何通信？</h2><p><strong>共享变量</strong>是最基本的线程间通信方式。多个线程可以访问和修改同一个共享变量，从而实现信息的传递。为了保证线程安全，通常需要使用 <code>synchronized</code> 关键字或 <code>volatile</code> 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedVariableExample</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 关键字保证变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改共享变量</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Producer: Flag is set to true.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="comment">// 等待共享变量被修改</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer: Flag is now true.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释</p><ul><li><code>volatile</code> 关键字确保了 <code>flag</code> 变量在多个线程之间的可见性，即一个线程修改了 <code>flag</code> 的值，其他线程能立即看到。</li><li>生产者线程在睡眠 2 秒后将 <code>flag</code> 设置为 <code>true</code>，消费者线程在 <code>flag</code> 为 <code>false</code> 时一直等待，直到 <code>flag</code> 变为 <code>true</code> 才继续执行。</li></ul><p><strong><code>Object</code> 类中的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法可以用于线程间的协作</strong>。<code>wait()</code> 方法使当前线程进入等待状态，<code>notify()</code> 方法唤醒在此对象监视器上等待的单个线程，<code>notifyAll()</code> 方法唤醒在此对象监视器上等待的所有线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producer: Producing...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producer: Production finished. Notifying consumer.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumer: Waiting for production to finish.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 进入等待状态</span></span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumer: Production finished. Consuming...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><ul><li><code>lock</code> 是一个用于同步的对象，生产者和消费者线程都需要获取该对象的锁才能执行相应的操作。</li><li>消费者线程调用 <code>lock.wait()</code> 方法进入等待状态，释放锁；生产者线程执行完生产任务后调用 <code>lock.notify()</code> 方法唤醒等待的消费者线程。</li></ul><p><strong><code>java.util.concurrent.locks</code> 包中的 <code>Lock</code> 和 <code>Condition</code> 接口提供了比 <code>synchronized</code> 更灵活的线程间通信方式。</strong><code>Condition</code> 接口的 <code>await()</code> 方法类似于 <code>wait()</code> 方法，<code>signal()</code> 方法类似于 <code>notify()</code> 方法，<code>signalAll()</code> 方法类似于 <code>notifyAll()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockConditionExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Producing...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Production finished. Notifying consumer.&quot;</span>);</span><br><span class="line">                <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Waiting for production to finish.&quot;</span>);</span><br><span class="line">                <span class="comment">// 进入等待状态</span></span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Production finished. Consuming...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><ul><li><code>ReentrantLock</code> 是 <code>Lock</code> 接口的一个实现类，<code>condition</code> 是通过 <code>lock.newCondition()</code> 方法创建的。</li><li>消费者线程调用 <code>condition.await()</code> 方法进入等待状态，生产者线程执行完生产任务后调用 <code>condition.signal()</code> 方法唤醒等待的消费者线程。</li></ul><p><strong><code>java.util.concurrent</code> 包中的 <code>BlockingQueue</code> 接口提供了线程安全的队列操作</strong>，当队列满时，插入元素的线程会被阻塞；当队列为空时，获取元素的线程会被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Producing...&quot;</span>);</span><br><span class="line">                queue.put(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Production finished.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Waiting for production to finish.&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Consumed item: &quot;</span> + item);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><ul><li><code>LinkedBlockingQueue</code> 是 <code>BlockingQueue</code> 接口的一个实现类，容量为 1。</li><li>生产者线程调用 <code>queue.put(1)</code> 方法将元素插入队列，如果队列已满，线程会被阻塞；消费者线程调用 <code>queue.take()</code> 方法从队列中取出元素，如果队列为空，线程会被阻塞。</li></ul><h2 id="16-线程间通信方式有哪些？"><a href="#16-线程间通信方式有哪些？" class="headerlink" title="16.线程间通信方式有哪些？"></a>16.线程间通信方式有哪些？</h2><p><strong>Object 类的 wait()、notify() 和 notifyAll() 方法。</strong>这是 Java 中最基础的线程间通信方式，基于对象的监视器（锁）机制。</p><ul><li><code>wait()</code>：使当前线程进入等待状态，直到其他线程调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。</li><li><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。</li><li><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumerMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="comment">/* 条件不满足 */</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">producerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行相应操作</span></span><br><span class="line">        notify(); <span class="comment">// 或者 notifyAll()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong><code>Lock</code> 和 <code>Condition</code> 接口。<code>Lock</code> 接口提供了比 <code>synchronized</code> 更灵活的锁机制，<code>Condition</code> 接口则配合 <code>Lock</code> 实现线程间的等待 / 通知机制。</strong></p><ul><li><code>await()</code>：使当前线程进入等待状态，直到被其他线程唤醒。</li><li><code>signal()</code>：唤醒一个等待在该 <code>Condition</code> 上的线程。</li><li><code>signalAll()</code>：唤醒所有等待在该 <code>Condition</code> 上的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="comment">/* 条件不满足 */</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行相应操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行相应操作</span></span><br><span class="line">            condition.signal(); <span class="comment">// 或者 signalAll()</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>volatile</code> 关键字。<code>volatile</code> <strong>关键字用于保证变量的可见性，即当一个变量被声明为 <code>volatile</code> 时，它会保证对该变量的写操作会立即刷新到主内存中，而读操作会从主内存中读取最新的值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<strong>CountDownLatch。<code>CountDownLatch</code> 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。</strong></p><ul><li><code>CountDownLatch(int count)</code>：构造函数，指定需要等待的线程数量。</li><li><code>countDown()</code>：减少计数器的值。</li><li><code>await()</code>：使当前线程等待，直到计数器的值为 0。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程任务完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<strong>CyclicBarrier。<code>CyclicBarrier</code> 是一个同步辅助类，它允许一组线程相互等待，直到所有线程都到达某个公共屏障点。</strong></p><ul><li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>：构造函数，指定参与的线程数量和所有线程到达屏障点后要执行的操作。</li><li><code>await()</code>：使当前线程等待，直到所有线程都到达屏障点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(threadCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程都到达屏障点&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 到达屏障点&quot;</span>);</span><br><span class="line">                    barrier.await();</span><br><span class="line">                    <span class="comment">// 继续执行后续任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、<strong>Semaphore。<code>Semaphore</code> 是一个计数信号量，它可以控制同时访问特定资源的线程数量。</strong></p><ul><li><code>Semaphore(int permits)</code>：构造函数，指定信号量的初始许可数量。</li><li><code>acquire()</code>：获取一个许可，如果没有可用许可则阻塞。</li><li><code>release()</code>：释放一个许可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">permitCount</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(permitCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得许可&quot;</span>);</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放许可&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-如何停止一个线程？"><a href="#17-如何停止一个线程？" class="headerlink" title="17.如何停止一个线程？"></a>17.如何停止一个线程？</h2><p>在 Java 中，停止线程的正确方式是 <strong>通过协作式的逻辑控制线程终止</strong>，而非强制暴力终止（如已废弃的 <code>Thread.stop()</code>）。以下是实现安全停止线程的多种方法：</p><p><strong>第一种方式：通过共享标志位主动终止</strong>。<strong>定义一个 可见的 状态变量，由主线程控制其值，工作线程循环检测该变量以决定是否退出。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeStopWithFlag</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理任务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获中断异常后设置 running=false</span></span><br><span class="line">                running = <span class="literal">false</span>;</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread terminated safely.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止线程的方法（由外部调用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SafeStopWithFlag</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeStopWithFlag</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 某个时刻调用停止</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">task.stop();</span><br></pre></td></tr></table></figure><p><strong>第二种方式使用线程中断机制</strong>。通过 <code>Thread.interrupt()</code> 触发线程中断状态，结合中断检测逻辑实现安全停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Working...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 当阻塞时被中断，抛出异常并清除中断状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted during sleep!&quot;</span>);</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// 重新设置中断标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread terminated by interrupt.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread(new InterruptExample());</span><br><span class="line">thread.start();</span><br><span class="line">// 中断线程</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure><ul><li><code>interrupt()</code> <strong>不会立刻终止线程，只是设置中断标志位。</strong></li><li>线程需手动检查中断状态（<code>isInterrupted()</code>）或触发可中断操作（如<code>sleep()</code>，<code>wait()</code>，<code>join()</code>)响应中断。</li><li>阻塞操作中收到中断请求时，会抛出 <code>InterruptedException</code> 并清除中断状态。</li></ul><p><strong>第三种方式通过 <code>Future</code> 取消任务</strong>。使用线程池提交任务，并通过 <code>Future.cancel()</code> 停止线程，依赖中断机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCancelDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task running...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task interrupted.&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            future.cancel(<span class="literal">true</span>); <span class="comment">// true表示尝试中断任务线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四种方式**</strong>处理不可中断的阻塞操作。**某些 I/O 或同步操作（如 <code>Socket.accept()</code>、<code>Lock.lock()</code>）无法通过中断直接响应。此时需结合资源关闭操作。比如，关闭 Socket 释放阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketHandler</span><span class="params">(ServerSocket serverSocket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverSocket = serverSocket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// serverSocket.accept()阻塞时无法响应中断</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// 处理连接...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread stopped by interrupt.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊关闭方法（销毁资源）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket.close(); <span class="comment">// 关闭资源使accept()抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error closing socket: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：调用 <code>stop()</code> 方法关闭资源以解除阻塞。</p><p>线程停止的正确实践，如下表格：</p><div class="table-container"><table><thead><tr><th><strong>方法</strong></th><th><strong>适用场景</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr><td><strong>循环检测标志位</strong></td><td>简单无阻塞的逻辑</td><td>确保标志位使用 <code>volatile</code> 或通过锁保证可见性</td></tr><tr><td><strong>中断机制</strong></td><td>可中断的阻塞操作</td><td>正确处理 <code>InterruptedException</code> 并恢复中断标志</td></tr><tr><td><strong>Future.cancel()</strong></td><td>线程池管理任务</td><td>需要线程池任务支持中断处理机制</td></tr><tr><td><strong>资源关闭</strong></td><td>不可中断的阻塞操作（如Sockets）</td><td>显式关闭资源触发异常，结合中断状态判断回滚</td></tr></tbody></table></div><p>避免使用以下已废弃方法：</p><ul><li><code>Thread.stop()</code>：暴力终止，可能导致状态不一致。</li><li><code>Thread.suspend()</code>/<code>resume()</code>：易导致死锁。</li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="1-juc包下你常用的类？"><a href="#1-juc包下你常用的类？" class="headerlink" title="1.juc包下你常用的类？"></a>1.juc包下你常用的类？</h2><p><strong>线程池相关：</strong></p><ul><li><code>ThreadPoolExecutor</code>：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求。</li><li><code>Executors</code>：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池，如<code>newFixedThreadPool</code>（创建固定线程数的线程池）、<code>newCachedThreadPool</code>（创建可缓存线程池）、<code>newSingleThreadExecutor</code>（创建单线程线程池）等，方便开发者快速创建线程池。</li></ul><p><strong>并发集合类：</strong></p><ul><li><code>ConcurrentHashMap</code>：线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。它采用了<strong>分段锁</strong>等技术，允许多个线程同时访问不同的段，提高了并发性能，在高并发场景下比传统的<code>Hashtable</code>性能更好。</li><li><code>CopyOnWriteArrayList</code>：线程安全的列表，在对列表进行修改操作时，会<strong>创建一个新的底层数组，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行，从而实现了读写分离，提高了并发读的性能，适用于读多写少的场景。</strong></li></ul><p><strong>同步工具类：</strong></p><ul><li><code>CountDownLatch</code>：允许一个或多个线程等待其他一组线程完成操作后再继续执行。它通过一个计数器来实现，计数器初始化为线程的数量，每个线程完成任务后调用<code>countDown</code>方法将计数器减一，当计数器为零时，等待的线程可以继续执行。<strong>常用于多个线程完成各自任务后，再进行汇总或下一步操作的场景。</strong></li><li><code>CyclicBarrier</code>：让一组线程互相等待，直到所有线程都到达某个屏障点后，再一起继续执行。与<code>CountDownLatch</code>不同的是，<code>CyclicBarrier</code>可以重复使用，当所有线程都通过屏障后，计数器会重置，可以再次用于下一轮的等待。<strong>适用于多个线程需要协同工作，在某个阶段完成后再一起进入下一个阶段的场景。</strong></li><li><code>Semaphore</code>：信号量，<strong>用于控制同时访问某个资源的线程数量。</strong>它维护了一个许可计数器，线程在访问资源前需要获取许可，如果有可用许可，则获取成功并将许可计数器减一，否则线程需要等待，直到有其他线程释放许可。常用于控制对有限资源的访问，如数据库连接池、线程池中的线程数量等。</li></ul><p><strong>原子类：</strong></p><ul><li><code>AtomicInteger</code>：原子整数类，提供了<strong>对整数类型的原子操作</strong>，如自增、自减、比较并交换等。通过硬件级别的原子指令来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销，在多线程环境下对整数进行计数、状态标记等操作非常方便。</li><li><code>AtomicReference</code>：原子引用类，用于对对象引用进行原子操作。可以保证在多线程环境下，对对象的更新操作是原子性的，即要么全部成功，要么全部失败，不会出现数据不一致的情况。常用于实现无锁数据结构或需要对对象进行原子更新的场景。</li></ul><h2 id="2-怎么保证多线程安全？"><a href="#2-怎么保证多线程安全？" class="headerlink" title="2.怎么保证多线程安全？"></a>2.怎么保证多线程安全？</h2><ul><li><strong>synchronized关键字</strong>:可以使用<code>synchronized</code>关键字来同步代码块或方法，<strong>确保同一时刻只有一个线程可以访问这些代码</strong>。对象锁是通过<code>synchronized</code>关键字锁定对象的监视器（monitor）来实现的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anotherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>volatile关键字</strong>:<code>volatile</code>关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> sharedVariable;</span><br></pre></td></tr></table></figure><ul><li><strong>Lock接口和ReentrantLock类</strong>:<code>java.util.concurrent.locks.Lock</code>接口提供了比<code>synchronized</code>更强大的锁定机制，<code>ReentrantLock</code>是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>原子类</strong>：Java并发库（<code>java.util.concurrent.atomic</code>）提供了原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span> counter.incrementAndGet();</span><br></pre></td></tr></table></figure><ul><li><strong>线程局部变量</strong>:<code>ThreadLocal</code>类可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; threadLocalVar = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">threadLocalVar.set(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocalVar.get();</span><br></pre></td></tr></table></figure><ul><li><strong>并发集合</strong>:使用<code>java.util.concurrent</code>包中的线程安全集合，如<code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>等，这些集合内部已经实现了线程安全的逻辑。</li><li><strong>JUC工具类</strong>: 使用<code>java.util.concurrent</code>包中的一些工具类可以用于控制线程间的同步和协作。例如：<code>Semaphore</code>和<code>CyclicBarrier</code>等。</li></ul><h2 id="3-Java中有哪些常用的锁，在什么场景下使用？"><a href="#3-Java中有哪些常用的锁，在什么场景下使用？" class="headerlink" title="3.Java中有哪些常用的锁，在什么场景下使用？"></a>3.Java中有哪些常用的锁，在什么场景下使用？</h2><p>Java中的锁是用于管理多线程并发访问共享资源的关键机制。锁可以确保在任意给定时间内只有一个线程可以访问特定的资源，从而避免数据竞争和不一致性。Java提供了多种锁机制，可以分为以下几类：</p><ul><li><strong>内置锁（synchronized）</strong>：Java中的<code>synchronized</code>关键字是内置锁机制的基础，可以用于方法或代码块。<strong>当一个线程进入<code>synchronized</code>代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。</strong>如果其他线程尝试获取同一个对象的锁，它们将被<strong>阻塞</strong>，直到锁被释放。其中，syncronized加锁时<strong>有无锁、偏向锁、轻量级锁和重量级锁几个级别</strong>。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用<strong>偏向锁</strong>，以减少锁的开销。<strong>轻量级锁</strong>使用线程栈上的数据结构，避免了操作系统级别的锁。<strong>重量级锁则涉及操作系统级的互斥锁</strong>。</li><li><strong>ReentrantLock</strong>：<code>java.util.concurrent.locks.ReentrantLock</code>是一个显式的锁类，提供了比<code>synchronized</code>更高级的功能，如可<strong>中断的锁等待、定时锁等待、公平锁选项</strong>等。<code>ReentrantLock</code>使用<code>lock()</code>和<code>unlock()</code>方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。</li><li><strong>读写锁（ReadWriteLock）</strong>：<code>java.util.concurrent.locks.ReadWriteLock</code>接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。</li><li><strong>乐观锁和悲观锁</strong>：悲观锁（Pessimistic Locking）通常指<strong>在访问数据前就锁定资源</strong>，假设最坏的情况，即数据很可能被其他线程修改。<code>synchronized</code>和<code>ReentrantLock</code>都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，<strong>而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。比如CAS</strong></li><li><strong>自旋锁</strong>：自旋锁是一种锁机制，线程在等待锁时会<strong>持续循环检查锁是否可用，</strong>而不是放弃CPU并阻塞。通常可以使用CAS来实现。<strong>这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。</strong></li></ul><h2 id="4-怎么在实践中用锁的？"><a href="#4-怎么在实践中用锁的？" class="headerlink" title="4.怎么在实践中用锁的？"></a>4.怎么在实践中用锁的？</h2><p>Java提供了多种锁的实现，包括<code>synchronized</code>关键字、<code>java.util.concurrent.locks</code>包下的<code>Lock</code>接口及其具体实现如<code>ReentrantLock</code>、<code>ReadWriteLock</code>等。下面我们来看看这些锁的使用方式。</p><blockquote><ol><li><code>synchronized</code></li></ol></blockquote><p><code>synchronized</code>关键字可以用于方法或代码块，它是Java中最早的锁实现，使用起来非常简单。</p><p><strong>示例：synchronized方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：synchronized代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>使用<code>Lock</code>接口</li></ol></blockquote><p><code>Lock</code>接口提供了比<code>synchronized</code>更灵活的锁操作，包括尝试锁、可中断锁、定时锁等。<code>ReentrantLock</code>是<code>Lock</code>接口的一个实现。</p><p><strong>示例：使用ReentrantLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>使用<code>ReadWriteLock</code></li></ol></blockquote><p><code>ReadWriteLock</code>接口提供了一种读写锁的实现，允许多个读操作同时进行，但写操作是<strong>独占</strong>的。</p><p><strong>示例：使用ReadWriteLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(Object newData)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Java-并发工具你知道哪些？"><a href="#5-Java-并发工具你知道哪些？" class="headerlink" title="5.Java 并发工具你知道哪些？"></a>5.Java 并发工具你知道哪些？</h2><ul><li><strong>CountDownLatch</strong>：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。它使用一个计数器进行初始化，调用 <code>countDown()</code> 方法会使计数器减一，当计数器的值减为 0 时，等待的线程会被唤醒。可以把它想象成一个倒计时器，当倒计时结束（计数器为 0）时，等待的事件就会发生。示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberOfThreads</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(numberOfThreads);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动三个工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在工作&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟工作时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();  <span class="comment">// 完成工作，计数器减一</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成工作&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待工作线程完成&quot;</span>);</span><br><span class="line">        latch.await();  <span class="comment">// 主线程等待，直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有工作线程已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>CyclicBarrier</strong>：CyclicBarrier 允许一组线程互相等待，直到到达一个公共的屏障点。当所有线程都到达这个屏障点后，它们可以继续执行后续操作，并且这个屏障可以被重置循环使用。与 <code>CountDownLatch</code> 不同，<code>CyclicBarrier</code> 侧重于线程间的相互等待，而不是等待某些操作完成。示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberOfThreads</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(numberOfThreads, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程都到达了屏障，继续执行后续操作&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在运行&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟运行时间</span></span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经通过屏障&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Semaphore</strong>：Semaphore 是一个计数信号量，用于控制同时访问某个共享资源的线程数量。通过 <code>acquire()</code> 方法获取许可，使用 <code>release()</code> 方法释放许可。如果没有许可可用，线程将被阻塞，直到有许可被释放。可以用来限制对某些资源（如数据库连接池、文件操作等）的并发访问量。代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);  <span class="comment">// 允许 2 个线程同时访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得了许可&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟资源使用</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放了许可&quot;</span>);</span><br><span class="line">                    semaphore.release();  <span class="comment">// 释放许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Future 和 Callable</strong>：Callable 是一个类似于 <code>Runnable</code> 的接口，但它可以返回结果，并且可以抛出异常。<strong>Future 用于表示一个异步计算的结果，可以通过它来获取 <code>Callable</code> 任务的执行结果或取消任务。代码如下：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行 Callable 任务&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 返回结果</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executorService.submit(callable);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 等待 Callable 任务完成并获取结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Callable 任务的结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ConcurrentHashMap</strong>：ConcurrentHashMap 是一个线程安全的哈希表，它允许多个线程同时进行读操作，在一定程度上支持并发的修改操作，避免了 <code>HashMap</code> 在多线程环境下需要使用 <code>synchronized</code> 或 <code>Collections.synchronizedMap()</code> 进行同步的性能问题。代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发读操作</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发写操作</span></span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;key3&quot;</span>, k -&gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-CountDownLatch-是做什么的讲一讲？"><a href="#6-CountDownLatch-是做什么的讲一讲？" class="headerlink" title="6.CountDownLatch 是做什么的讲一讲？"></a>6.CountDownLatch 是做什么的讲一讲？</h2><p>CountDownLatch 是 Java 并发包（<code>java.util.concurrent</code>）中的一个同步工具类，<strong>用于让一个或多个线程等待其他线程完成操作后再继续执行</strong>。</p><p>其核心是通过一个计数器（Counter）实现线程间的协调，常用于多线程任务的分阶段控制或主线程等待多个子线程就绪的场景，核心原理：</p><ul><li><strong>初始化计数器</strong>：创建 <code>CountDownLatch</code> 时指定一个初始计数值（如 <code>N</code>）。</li><li><strong>等待线程阻塞</strong>：调用 <code>await()</code> 的线程会被阻塞，直到计数器变为 0。</li><li><strong>任务完成通知</strong>：其他线程完成任务后调用 <code>countDown()</code>，使计数器减 1。</li><li><strong>唤醒等待线程</strong>：当计数器减到 0 时，所有等待的线程会被唤醒。</li></ul><p>主线程等待所有子线程就绪后启动，代码例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程启动多个子线程执行任务，等待全部完成后统计结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThreadWaitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    latch.countDown(); <span class="comment">// 任务完成，计数器-1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 主线程等待所有子线程完成任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-synchronized和reentrantlock及其应用场景？"><a href="#7-synchronized和reentrantlock及其应用场景？" class="headerlink" title="7.synchronized和reentrantlock及其应用场景？"></a>7.synchronized和reentrantlock及其应用场景？</h2><blockquote><p>synchronized 工作原理</p></blockquote><p>synchronized是Java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为<strong>监视器锁</strong>，</p><p>使用synchronized之后，会在<strong>编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。</strong></p><p>执行monitorenter指令时会尝试获取对象锁，<strong>如果对象没有被锁定或者已经获得了锁，锁的计数器+1</strong>。此时其他竞争锁的线程则会进入等待队列中。<strong>执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。</strong></p><p>synchronized是<strong>排它锁</strong>，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态，这种转换非常消耗性能。</p><p>从内存语义来说，加锁的过程会<strong>清除工作内存中的共享变量，再从主内存读取</strong>，而释放锁的过程则是将工作内存中的共享变量写回主内存。</p><p>实际上大部分时候我认为说到monitorenter就行了，但是为了更清楚的描述，还是再具体一点。</p><p>如果再深入到源码来说，synchronized实际上有两个队列waitSet和entryList。</p><ol><li>当多个线程进入同步代码块时，首先进入entryList</li><li>有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1</li><li>如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁</li><li>如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null<img src="https://cdn.xiaolincoding.com//picgo/1719918642412-181e3769-49d8-4c78-8f33-a866367a4693.png" alt="img"></li></ol><blockquote><p>reentrantlock工作原理</p></blockquote><p>ReentrantLock 的底层实现主要依赖于 AbstractQueuedSynchronizer<strong>（AQS）这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等。</strong></p><p>ReentrantLock 在 AQS 的基础上通过内部类 <strong>Sync</strong> 来实现具体的锁操作。<strong>不同的 Sync 子类实现了公平锁和非公平锁的不同逻辑：</strong></p><ul><li><strong>可中断性</strong>： ReentrantLock 实现了<strong>可中断性</strong>，这意味着线程在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，ReentrantLock 使用了与 <strong>LockSupport.park() 和 LockSupport.unpark() 相关的机制来实现可中断性。</strong></li><li><strong>设置超时时间</strong>： ReentrantLock <strong>支持在尝试获取锁时设置超时时间</strong>，即等待一定时间后如果还未获得锁，则放弃锁的获取。这是通过内部的 <strong>tryAcquireNanos 方法来实现的</strong>。</li><li><strong>公平锁和非公平锁</strong>： 在直接创建 ReentrantLock 对象时，<strong>默认情况下是非公平锁</strong>。公平锁是按照线程等待的顺序来获取锁，而非公平锁则允许多个线程在同一时刻竞争锁，不考虑它们申请锁的顺序。公平锁可以通过在创建 ReentrantLock 时传入 true 来设置，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>多个条件变量</strong>： ReentrantLock <strong>支持多个条件变量</strong>，每个条件变量可以与一个 ReentrantLock 关联。这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的 wait() 和 notify()。多个条件变量的实现依赖于 Condition 接口，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 使用下面方法进行等待和唤醒</span></span><br><span class="line">condition.await();</span><br><span class="line">condition.signal();</span><br></pre></td></tr></table></figure><ul><li><strong>可重入性</strong>： ReentrantLock <strong>支持可重入性</strong>，<strong>即同一个线程可以多次获得同一把锁</strong>，而不会造成死锁。这是通过<strong>内部的 holdCount 计数来实现的</strong>。当一个线程多次获取锁时，holdCount 递增，释放锁时递减，只有当 holdCount 为零时，其他线程才有机会获取锁。</li></ul><blockquote><p>应用场景的区别</p></blockquote><p><strong>synchronized</strong>：</p><ul><li><strong>简单同步需求</strong>： 当你需要对<strong>代码块或方法进行简单的同步控制时</strong>，<code>synchronized</code>是一个很好的选择。它使用起来简单，不需要额外的资源管理，因为锁会在方法退出或代码块执行完毕后自动释放。</li><li><strong>代码块同步</strong>： 如果你想对特定代码段进行同步，而不是整个方法，可以使用<code>synchronized</code>代码块。这可以让你更精细地控制同步的范围，从而减少锁的持有时间，提高并发性能。</li><li><strong>内置锁的使用</strong>： <code>synchronized</code>关键字使用对象的内置锁（也称为监视器锁），这在需要使用对象作为锁对象的情况下很有用，尤其是在对象状态与锁保护的代码紧密相关时。</li></ul><p><strong>ReentrantLock：</strong></p><ul><li><strong>高级锁功能需求</strong>： <code>ReentrantLock</code>提供了<code>synchronized</code>所不具备的高级功能，如公平锁、响应中断、定时锁尝试、以及多个条件变量。当你需要这些功能时，<code>ReentrantLock</code>是更好的选择。</li><li><strong>性能优化</strong>： 在高度竞争的环境中，<code>ReentrantLock</code>可以提供比<code>synchronized</code>更好的性能，因为它提供了<strong>更细粒度的控制，如尝试锁定和定时锁定，可以减少线程阻塞的可能性</strong>。</li><li><strong>复杂同步结构</strong>： 当你需要更复杂的同步结构，如需要多个条件变量来协调线程之间的通信时，<code>ReentrantLock</code>及其配套的<code>Condition</code>对象可以提供更灵活的解决方案。</li></ul><p>综上，<code>synchronized</code>适用于简单同步需求和不需要额外锁功能的场景，而<code>ReentrantLock</code>适用于需要更高级锁功能、性能优化或复杂同步逻辑的情况。选择哪种同步机制取决于具体的应用需求和性能考虑。</p><h2 id="8-除了用synchronized，还有什么方法可以实现线程同步？"><a href="#8-除了用synchronized，还有什么方法可以实现线程同步？" class="headerlink" title="8.除了用synchronized，还有什么方法可以实现线程同步？"></a>8.除了用synchronized，还有什么方法可以实现线程同步？</h2><ul><li><strong>使用<code>ReentrantLock</code>类</strong>：<code>ReentrantLock</code>是一个可重入的互斥锁，相比<code>synchronized</code>提供了更灵活的锁定和解锁操作。它还支持公平锁和非公平锁，以及可以响应中断的锁获取操作。</li><li><strong>使用<code>volatile</code>关键字</strong>：虽然<code>volatile</code>不是一种锁机制，但它可以确保变量的可见性。当一个变量被声明为<code>volatile</code>后，线程将直接从主内存中读取该变量的值，这样就能保证线程间变量的可见性。但它不具备原子性。</li><li><strong>使用<code>Atomic</code>类</strong>：Java提供了一系列的原子类，例如<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等，用于实现对单个变量的原子操作，这些类在实现细节上利用了CAS（Compare-And-Swap）算法，可以用来实现无锁的线程安全。</li></ul><h2 id="9-synchronized锁静态方法和普通方法区别？"><a href="#9-synchronized锁静态方法和普通方法区别？" class="headerlink" title="9.synchronized锁静态方法和普通方法区别？"></a>9.synchronized锁静态方法和普通方法区别？</h2><p>锁的对象不同：</p><ul><li><strong>普通方法</strong>：锁的是<strong>当前对象实例</strong>（<code>this</code>）。同一对象实例的 <code>synchronized</code> 普通方法，同一时间只能被一个线程访问；不同对象实例间互不影响，可被不同线程同时访问各自的同步普通方法。</li><li><strong>静态方法</strong>：锁的是<strong>当前类的 <code>Class</code> 对象</strong>。由于类的 <code>Class</code> 对象全局唯一，无论多少个对象实例，该静态同步方法同一时间只能被一个线程访问。</li></ul><p>作用范围不同：</p><ul><li><strong>普通方法</strong>：仅对同一对象实例的同步方法调用互斥，不同对象实例的同步普通方法可并行执行。</li><li><strong>静态方法</strong>：对整个类的所有实例的该静态方法调用都互斥，一个线程进入静态同步方法，其他线程无法进入同一类任何实例的该方法。</li></ul><p>多实例场景影响不同：</p><ul><li><strong>普通方法</strong>：多线程访问不同对象实例的同步普通方法时，可同时执行。</li><li><strong>静态方法</strong>：不管有多少对象实例，同一时间仅一个线程能执行该静态同步方法。</li></ul><h2 id="10-synchronized和reentrantlock区别？"><a href="#10-synchronized和reentrantlock区别？" class="headerlink" title="10.synchronized和reentrantlock区别？"></a>10.synchronized和reentrantlock区别？</h2><p>synchronized 和 ReentrantLock 都是 Java 中提供的可重入锁：</p><ul><li><strong>用法不同</strong>：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。</li><li><strong>获取锁和释放锁方式不同</strong>：synchronized 会<strong>自动加锁和释放锁</strong>，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要<strong>手动加锁和释放锁</strong></li><li><strong>锁类型不同</strong>：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。</li><li><strong>响应中断不同</strong>：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。</li><li><strong>底层实现不同</strong>：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。</li></ul><h2 id="11-怎么理解可重入锁？"><a href="#11-怎么理解可重入锁？" class="headerlink" title="11.怎么理解可重入锁？"></a>11.怎么理解可重入锁？</h2><p>可重入锁是指同一个线程在获取了锁之后，<strong>可以再次重复获取该锁而不会造成死锁或其他问题</strong>。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。</p><p>ReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。</p><ul><li>当一个线程第一次获取锁时，计数器会加1，表示该线程持有了锁。在此之后，如果同一个线程再次获取锁，计数器会再次加1。每次线程成功获取锁时，都会将计数器加1。</li><li>当线程释放锁时，计数器会相应地减1。<strong>只有当计数器减到0时，锁才会完全释放，其他线程才有机会获取锁。</strong></li></ul><p>这种计数器的设计使得同一个线程可以多次获取同一个锁，而不会造成死锁或其他问题。每次获取锁时，计数器加1；每次释放锁时，计数器减1。只有当计数器减到0时，锁才会完全释放。</p><p><strong>ReentrantLock通过这种计数器的方式，实现了可重入锁的机制。它允许同一个线程多次获取同一个锁，并且能够正确地处理锁的获取和释放，避免了死锁和其他并发问题。</strong></p><h2 id="12-synchronized-支持重入吗？如何实现的"><a href="#12-synchronized-支持重入吗？如何实现的" class="headerlink" title="12.synchronized 支持重入吗？如何实现的?"></a>12.synchronized 支持重入吗？如何实现的?</h2><p>synchronized是基于<strong>原子性的内部锁机制</strong>，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，<strong>也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</strong></p><p>synchronized底层是利用<strong>计算机系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态status。</strong></p><p>当一个线程请求方法时，会去检查锁状态。</p><ol><li>如果锁状态是0，代表该锁没有被占用，使用CAS操作获取锁，将线程ID替换成自己的线程ID。</li><li>如果锁状态不是0，代表有线程在访问该方法。此<strong>时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法；如果是非重入锁，就会进入阻塞队列等待。</strong></li></ol><p>在释放锁时，</p><ol><li>如果是可重入锁的，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。</li><li>如果非可重入锁的，线程退出方法，直接就会释放该锁。</li></ol><h2 id="13-syncronized锁升级的过程讲一下"><a href="#13-syncronized锁升级的过程讲一下" class="headerlink" title="13.syncronized锁升级的过程讲一下"></a>13.syncronized锁升级的过程讲一下</h2><p>具体的锁升级的过程是：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</p><ul><li><strong>无锁</strong>：这是没有开启偏向锁的时候的状态，在JDK1.6之后偏向锁的默认开启的，但是有一个偏向延迟，需要在JVM启动之后的多少秒之后才能开启，这个可以通过JVM参数进行设置，同时是否开启偏向锁也可以通过JVM参数设置。</li><li><strong>偏向锁</strong>：这个是在偏向锁开启之后的锁的状态，如果还没有一个线程拿到这个锁的话，这个状态叫做匿名偏向，当一个线程拿到偏向锁的时候，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID进行比较，如果线程ID相同则直接获取锁（相当于锁偏向于这个线程），不需要进行CAS操作和将线程挂起的操作。</li><li><strong>轻量级锁</strong>：在这个状态下线程主要是通过CAS操作实现的。将对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，如果设置成功则获取锁。在线程出临界区的时候，也需要使用CAS，如果使用CAS替换成功则同步成功，如果失败表示有其他线程在获取锁，那么就需要在释放锁之后将被挂起的线程唤醒。</li><li><strong>重量级锁</strong>：<strong>当有两个以上的线程获取锁的时候轻量级锁就会升级为重量级锁</strong>，因为CAS如果没有成功的话始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源。</li></ul><p>了解完 4 种锁状态之后，我们就可以整体的来看一下锁升级的过程了。 <img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="image.png"> 线程A进入 synchronized 开始抢锁，JVM 会判断当前是否是偏向锁的状态，如果是就会根据 Mark Word 中存储的线程 ID 来判断，当前线程A是否就是持有偏向锁的线程。如果是，则忽略 check，线程A直接执行临界区内的代码。</p><p>但如果 Mark Word 里的线程不是线程 A，就会通过自旋尝试获取锁，如果获取到了，就将 Mark Word 中的线程 ID 改为自己的;如果竞争失败，就会立马撤销偏向锁，膨胀为轻量级锁。</p><p>后续的竞争线程都会通过自旋来尝试获取锁，如果自旋成功那么锁的状态仍然是轻量级锁。然而如果竞争失败，锁会膨胀为重量级锁，后续等待的竞争的线程都会被阻塞。</p><h2 id="14-JVM对Synchornized的优化？"><a href="#14-JVM对Synchornized的优化？" class="headerlink" title="14.JVM对Synchornized的优化？"></a>14.JVM对Synchornized的优化？</h2><p>synchronized 核心优化方案主要包含以下 4 个：</p><ul><li><strong>锁膨胀</strong>：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，<strong>大部分的场景都不需要用户态到内核态的转换了</strong>，这样就大幅的提升了 synchronized 的性能。</li><li><strong>锁消除</strong>：指的是在某些情况下，JVM 虚拟机如果<strong>检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉</strong>，从而到底提高程序性能的目的。</li><li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li><strong>自适应自旋锁</strong>：指通过自身循环，尝试获取锁的一种方式，优点在于它<strong>避免一些线程的挂起和恢复操作</strong>，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。</li></ul><h2 id="15-介绍一下AQS"><a href="#15-介绍一下AQS" class="headerlink" title="15.介绍一下AQS"></a>15.介绍一下AQS</h2><p>AQS全称为AbstractQueuedSynchronizer，是Java中的一个抽象类。 AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。</p><p>AQS核心思想是，<strong>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。</strong>这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p>主要原理图如下： <img src="https://cdn.xiaolincoding.com//picgo/1721809581196-7c09ce04-1429-4810-ade4-bb3098a9303d.png" alt="image.png"></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><p>AQS广泛用于控制并发流程的类，如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720958362111-45aa351b-c338-4eb8-8dad-da5e6f95a3c3.png" alt="img"></p><p>其中<code>Sync</code>是这些类中都有的内部类，其结构如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720958362187-35b5e5ef-04e0-44a6-b5f8-205f43df8847.png" alt="img"></p><p>可以看到：<code>Sync</code>是<code>AQS</code>的实现。 <code>AQS</code>主要完成的任务：</p><ul><li>同步状态（比如说计数器）的原子性管理；</li><li>线程的阻塞和解除阻塞；</li><li>队列的管理。</li></ul><blockquote><p>AQS原理</p></blockquote><p>AQS最核心的就是三大部分：</p><ul><li>状态：state；</li><li>控制线程抢锁和配合的FIFO队列（双向链表）；</li><li>期望协作工具类去实现的获取/释放等重要方法（重写）。</li></ul><p><strong>状态state</strong></p><ul><li>这里state的具体含义，会根据具体实现类的不同而不同：比如在Semapore里，他表示剩余许可证的数量；在CountDownLatch里，它表示还需要倒数的数量；在ReentrantLock中，state用来表示“锁”的占有情况，<strong>包括可重入计数，当state的值为0的时候，标识该Lock不被任何线程所占有。</strong></li><li><strong>state是volatile修饰的，并被并发修改</strong>，所以修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于unsafe类。</li></ul><p><strong>FIFO队列</strong></p><ul><li>这个队列用来存放“等待的线程，AQS就是“排队管理器”，<strong>当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。</strong></li><li>AQS会维护一个等待的线程队列，把线程都放到这个队列里，这个队列是双向链表形式。</li></ul><p><strong>实现获取/释放等方法</strong></p><ul><li>这里的获取和释放方法，是利用AQS的协作工具类里最重要的方法，是由协作类自己去实现的，并且含义各不相同；</li><li>获取方法：获取操作会以来state变量，经常会阻塞（比如获取不到锁的时候）。在Semaphore中，获取就是acquire方法，作用是获取一个许可证； 而在CountDownLatch里面，获取就是await方法，作用是等待，直到倒数结束；</li><li>释放方法：在Semaphore中，释放就是release方法，作用是释放一个许可证； 在CountDownLatch里面，获取就是countDown方法，作用是将倒数的数减一；</li><li><strong>需要每个实现类重写tryAcquire和tryRelease等方法。</strong></li></ul><h2 id="16-CAS-和-AQS-有什么关系？"><a href="#16-CAS-和-AQS-有什么关系？" class="headerlink" title="16.CAS 和 AQS 有什么关系？"></a>16.CAS 和 AQS 有什么关系？</h2><p>CAS 和 AQS 两者的区别：</p><ul><li>CAS 是一种<strong>乐观锁机制</strong>，它包含三个操作数：内存位置（V）、预期值（A）和新值（B）。CAS 操作的逻辑是，如果内存位置 V 的值等于预期值 A，则将其更新为新值 B，否则不做任何操作。整个过程是原子性的，通常由硬件指令支持，如在现代处理器上，<code>cmpxchg</code> 指令可以实现 CAS 操作。</li><li>AQS 是一个用于<strong>构建锁和同步器的框架</strong>，许多同步器如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都是基于 AQS 构建的。AQS 使用一个 <code>volatile</code> 的整数变量 <code>state</code> 来表示同步状态，通过内置的 <code>FIFO</code> 队列来管理等待线程。它提供了一些基本的操作，如 <code>acquire</code>（获取资源）和 <code>release</code>（释放资源），这些操作会修改 <code>state</code> 的值，并根据 <code>state</code> 的值来判断线程是否可以获取或释放资源。AQS 的 <code>acquire</code> 操作通常会先尝试获取资源，如果失败，线程将被添加到等待队列中，并阻塞等待。<code>release</code> 操作会释放资源，并唤醒等待队列中的线程。</li></ul><p>CAS 和 AQS 两者的联系：</p><ul><li><strong>CAS 为 AQS 提供原子操作支持</strong>：AQS 内部使用 CAS 操作来更新 <code>state</code> 变量，以实现线程安全的状态修改。在 <code>acquire</code> 操作中，当线程尝试获取资源时，会使用 CAS 操作尝试将 <code>state</code> 从一个值更新为另一个值，如果更新失败，说明资源已被占用，线程会进入等待队列。在 <code>release</code> 操作中，当线程释放资源时，也会使用 CAS 操作将 <code>state</code> 恢复到相应的值，以保证状态更新的原子性。</li></ul><h2 id="17-如何用-AQS-实现一个可重入的公平锁？"><a href="#17-如何用-AQS-实现一个可重入的公平锁？" class="headerlink" title="17.如何用 AQS 实现一个可重入的公平锁？"></a>17.如何用 AQS 实现一个可重入的公平锁？</h2><p>AQS 实现一个可重入的公平锁的详细步骤：</p><ol><li><strong>继承 AbstractQueuedSynchronizer</strong>：创建一个内部类继承自 <code>AbstractQueuedSynchronizer</code>，重写 <code>tryAcquire</code>、<code>tryRelease</code>、<code>isHeldExclusively</code> 等方法，这些方法将用于实现锁的获取、释放和判断锁是否被当前线程持有。</li><li><strong>实现可重入逻辑</strong>：在 <code>tryAcquire</code> 方法中，检查当前线程是否已经持有锁，如果是，则增加锁的持有次数（通过 <code>state</code> 变量）；如果不是，尝试使用 CAS操作来获取锁。</li><li><strong>实现公平性</strong>：在 <code>tryAcquire</code> 方法中，按照队列顺序来获取锁，即先检查等待队列中是否有线程在等待，如果有，当前线程必须进入队列等待，而不是直接竞争锁。</li><li><strong>创建锁的外部类</strong>：创建一个外部类，内部持有 <code>AbstractQueuedSynchronizer</code> 的子类对象，并提供 <code>lock</code> 和 <code>unlock</code> 方法，这些方法将调用 <code>AbstractQueuedSynchronizer</code> 子类中的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairReentrantLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断锁是否被当前线程持有</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 公平性检查：检查队列中是否有前驱节点，如果有，则当前线程不能获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 可重入逻辑：如果是当前线程持有锁，则增加持有次数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread()!= getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供一个条件变量，用于实现更复杂的同步需求，这里只是简单实现</span></span><br><span class="line">        ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前线程是否持有锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个条件变量，用于实现更复杂的同步需求，这里只是简单实现</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><p><strong>内部类 Sync</strong>：</p><ul><li><code>isHeldExclusively</code>：使用 <code>getExclusiveOwnerThread</code> 方法检查当前锁是否被当前线程持有。</li><li><code>tryAcquire</code>：<ul><li>首先获取当前锁的状态 <code>c</code>。</li><li>如果 <code>c</code> 为 0，表示锁未被持有，此时进行公平性检查，通过 <code>hasQueuedPredecessors</code> 检查是否有前驱节点在等待队列中。如果没有，使用 <code>compareAndSetState</code> 尝试将状态设置为 <code>acquires</code>（通常为 1），并设置当前线程为锁的持有线程。</li><li>如果 <code>c</code> 不为 0，说明锁已被持有，检查是否为当前线程持有。如果是，增加锁的持有次数（可重入），但要防止溢出。</li></ul></li><li><code>tryRelease</code>：<ul><li>先将状态减 <code>releases</code>（通常为 1）。</li><li>检查当前线程是否为锁的持有线程，如果不是，抛出异常。</li><li>如果状态减为 0，说明锁被完全释放，将持有线程设为 <code>null</code>。</li></ul></li><li><code>newCondition</code>：创建一个 <code>ConditionObject</code> 用于更复杂的同步操作，如等待 / 通知机制。</li></ul><p><strong>外部类 FairReentrantLock</strong>：</p><ul><li><code>lock</code> 方法：调用 <code>sync.acquire(1)</code> 尝试获取锁。</li><li><code>unlock</code> 方法：调用 <code>sync.release(1)</code> 释放锁。</li><li><code>isLocked</code> 方法：调用 <code>sync.isHeldExclusively</code> 判断锁是否被当前线程持有。</li><li><code>newCondition</code> 方法：调用 <code>sync.newCondition</code> 提供条件变量。</li></ul><h2 id="18-Threadlocal作用，原理，具体里面存的key-value是啥，会有什么问题，如何解决"><a href="#18-Threadlocal作用，原理，具体里面存的key-value是啥，会有什么问题，如何解决" class="headerlink" title="18.Threadlocal作用，原理，具体里面存的key value是啥，会有什么问题，如何解决?"></a>18.Threadlocal作用，原理，具体里面存的key value是啥，会有什么问题，如何解决?</h2><p><code>ThreadLocal</code>是Java中用于解决线程安全问题的一种机制，它允许创建线程局部变量，即每个线程都有自己独立的变量副本，从而避免了线程间的资源共享和同步问题。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png" alt="img"></p><p>从内存结构图，我们可以看到：</p><ul><li>Thread类中，有个ThreadLocal.ThreadLocalMap 的成员变量。</li><li>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key<strong>是</strong>ThreadLocal<strong>本身</strong>，value是ThreadLocal的泛型对象值。</li></ul><blockquote><p>ThreadLocal的作用</p></blockquote><ul><li><strong>线程隔离</strong>：<code>ThreadLocal</code>为每个线程提供了<strong>独立的变量副本，这意味着线程之间不会相互影响，可以安全地在多线程环境中使用这些变量而不必担心数据竞争或同步问题。</strong></li><li><strong>降低耦合度</strong>：在同一个线程内的多个函数或组件之间，使用<code>ThreadLocal</code>可以减少参数的传递，降低代码之间的耦合度，使代码更加清晰和模块化。</li><li><strong>性能优势</strong>：由于<code>ThreadLocal</code>避免了线程间的同步开销，所以在大量线程并发执行时，相比传统的锁机制，它可以提供更好的性能。</li></ul><blockquote><p>ThreadLocal的原理</p></blockquote><p><code>ThreadLocal</code>的实现依赖于<code>Thread</code>类中的一个<code>ThreadLocalMap</code>字段，这是一个存储<code>ThreadLocal</code>变量本身和对应值的映射。每个线程都有自己的<code>ThreadLocalMap</code>实例，用于存储该线程所持有的所有<code>ThreadLocal</code>变量的值。</p><p>当你创建一个<code>ThreadLocal</code>变量时，它实际上就是一个<code>ThreadLocal</code>对象的实例。每个<code>ThreadLocal</code>对象都可以存储任意类型的值，这个值对每个线程来说是独立的。</p><ul><li>当调用<code>ThreadLocal</code>的<code>get()</code>方法时，<code>ThreadLocal</code>会检查当前线程的<code>ThreadLocalMap</code>中是否有与之关联的值。</li><li>如果有，返回该值；</li><li>如果没有，会调用<code>initialValue()</code>方法（如果重写了的话）来初始化该值，然后将其放入<code>ThreadLocalMap</code>中并返回。</li><li>当调用<code>set()</code>方法时，<code>ThreadLocal</code>会将给定的值与当前线程关联起来，即在当前线程的<code>ThreadLocalMap</code>中存储一个键值对，键是<code>ThreadLocal</code>对象自身，值是传入的值。</li><li>当调用<code>remove()</code>方法时，会从当前线程的<code>ThreadLocalMap</code>中移除与该<code>ThreadLocal</code>对象关联的条目。</li></ul><blockquote><p>可能存在的问题</p></blockquote><p>当一个线程结束时，其<code>ThreadLocalMap</code>也会随之销毁，但是<code>ThreadLocal</code>对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。</p><p>因此，在使用<code>ThreadLocal</code>时需要注意，<strong>如果不显式调用<code>remove()</code>方法，或者线程结束时未正确清理<code>ThreadLocal</code>变量，可能会导致内存泄漏，因为<code>ThreadLocalMap</code>会持续持有<code>ThreadLocal</code>变量的引用，即使这些变量不再被其他地方引用。</strong></p><p>因此，实际应用中需要在使用完<code>ThreadLocal</code>变量后调用<code>remove()</code>方法释放资源。</p><h2 id="19-悲观锁和乐观锁的区别？"><a href="#19-悲观锁和乐观锁的区别？" class="headerlink" title="19.悲观锁和乐观锁的区别？"></a>19.悲观锁和乐观锁的区别？</h2><ul><li>乐观锁： 就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总 是会发生，<strong>因此它不需要持有锁</strong>，<strong>将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</strong></li><li>悲观锁： 还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总 是会发生，<strong>因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。</strong></li></ul><h2 id="20-Java中想实现一个乐观锁，都有哪些方式？"><a href="#20-Java中想实现一个乐观锁，都有哪些方式？" class="headerlink" title="20.Java中想实现一个乐观锁，都有哪些方式？"></a>20.Java中想实现一个乐观锁，都有哪些方式？</h2><ol><li><strong>CAS（Compare and Swap）操作：</strong> CAS 是乐观锁的基础。Java 提供了 java.util.concurrent.atomic 包，包含各种原子变量类（如 AtomicInteger、AtomicLong），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁。</li><li><strong>版本号控制</strong>：<strong>增加一个版本号字段记录数据更新时候的版本</strong>，每次更新时递增版本号。在更新数据时，同时比较版本号，若当前版本号和更新前获取的版本号一致，则更新成功，否则失败。</li><li><strong>时间戳</strong>：使用时间戳记录数据的更新时间，在更新数据时，在比较时间戳。如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败。</li></ol><h2 id="21-CAS-有什么缺点？"><a href="#21-CAS-有什么缺点？" class="headerlink" title="21.CAS 有什么缺点？"></a>21.CAS 有什么缺点？</h2><p>CAS的缺点主要有3点：</p><ul><li><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，<strong>当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A</strong>，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。Java中有<strong>AtomicStampedReference</strong>来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</li><li><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</li><li><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。</li></ul><h2 id="22-为什么不能所有的锁都用CAS？"><a href="#22-为什么不能所有的锁都用CAS？" class="headerlink" title="22.为什么不能所有的锁都用CAS？"></a>22.为什么不能所有的锁都用CAS？</h2><p>CAS操作是基于循环重试的机制，如果CAS操作一直未能成功，线程会一直自旋重试，占用CPU资源。在高并发情况下，大量线程自旋会导致CPU资源浪费。</p><h2 id="23-CAS-有什么问题，Java是怎么解决的？"><a href="#23-CAS-有什么问题，Java是怎么解决的？" class="headerlink" title="23.CAS 有什么问题，Java是怎么解决的？"></a>23.CAS 有什么问题，Java是怎么解决的？</h2><p>会有 ABA 的问题，变量值在操作过程中先被其他线程从 <strong>A</strong> 修改为 <strong>B</strong>，又被改回 <strong>A</strong>，CAS 无法感知中途变化，导致操作误判为“未变更”。比如：</p><ul><li>线程1读取变量为<code>A</code>，准备改为<code>C</code>。</li><li>此时线程2将变量<code>A</code>→<code>B</code>→<code>A</code>。</li><li>线程1的CAS执行时发现仍是<code>A</code>，但状态已丢失中间变化。</li></ul><p>Java 提供的工具类会在 CAS 操作中增加<strong>版本号（Stamp）或标记</strong>，每次修改都更新版本号，使得即使值相同也能识别变更历史。比如，可以用 AtomicStampedReference 来解决 ABA 问题，通过比对值<strong>和</strong>版本号识别ABA问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference&lt;Integer&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改值并更新版本号</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(<span class="number">100</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 前提：当前值=100 且 版本号=0，才会更新为（200,1）</span></span><br></pre></td></tr></table></figure><h2 id="24-voliatle关键字有什么作用？"><a href="#24-voliatle关键字有什么作用？" class="headerlink" title="24.voliatle关键字有什么作用？"></a>24.voliatle关键字有什么作用？</h2><p>volatite作用有 2 个：</p><ul><li><strong>保证变量对所有线程的可见性</strong>。当一个变量被声明为volatile时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，从而确保了多线程环境下对该变量访问的可见性。这意味着一个线程修改了volatile变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。</li><li><strong>禁止指令重排序优化</strong>。volatile关键字在Java中主要通过内存屏障来禁止特定类型的指令重排序。<ul><li>1）<strong>写-写（Write-Write）屏障</strong>：在对volatile变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。</li><li>2）<strong>读-写（Read-Write）屏障</strong>：在对volatile变量执行读操作之后，会插入一个读屏障。它确保了对volatile变量的读操作之后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取到的数据是最新的。</li><li>3）<strong>写-读（Write-Read）屏障</strong>：这是最重要的一个屏障，它发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作（包括写操作）都不会被重排序到volatile读之后，同时也确保了volatile读操作之后的所有内存操作（包括读操作）都不会被重排序到volatile写之前。</li></ul></li></ul><h2 id="25-指令重排序的原理是什么？"><a href="#25-指令重排序的原理是什么？" class="headerlink" title="25.指令重排序的原理是什么？"></a>25.指令重排序的原理是什么？</h2><p>在执行程序时，为了提高性能，处理器和编译器常常会对指令进行重排序，但是重排序要满足下面 2 个条件才能进行：</p><ul><li><strong>在单线程环境下不能改变程序运行的结果</strong></li><li><strong>存在数据依赖关系的不允许重排序。</strong></li></ul><p>所以<strong>重排序不会对单线程有影响，只会破坏多线程的执行语义。</strong></p><p>我们看这个例子，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面，如果C排到A和B的前面，那么程序的结果将会被改变。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><h2 id="26-volatile可以保证线程安全吗？"><a href="#26-volatile可以保证线程安全吗？" class="headerlink" title="26.volatile可以保证线程安全吗？"></a>26.volatile可以保证线程安全吗？</h2><p>volatile关键字可以保证可见性，<strong>但不能保证原子性</strong>，因此不能完全保证线程安全。volatile关键字用于修饰变量，当一个线程修改了volatile修饰的变量的值，其他线程能够立即看到最新的值，从而避免了线程之间的数据不一致。</p><p>但是，volatile并不能解决多线程并发下的复合操作问题，<strong>比如i++这种操作不是原子操作，如果多个线程同时对i进行自增操作，volatile不能保证线程安全。</strong>对于复合操作，需要使用synchronized关键字或者Lock来保证原子性和线程安全。</p><h2 id="27-volatile和sychronized比较？"><a href="#27-volatile和sychronized比较？" class="headerlink" title="27.volatile和sychronized比较？"></a>27.volatile和sychronized比较？</h2><p>Synchronized解决了多线程访问共享资源时可能出现的竞态条件和数据不一致的问题，保证了线程安全性。Volatile解决了变量在多线程环境下的可见性和有序性问题，确保了变量的修改对其他线程是可见的。</p><ul><li>Synchronized: Synchronized是一种排他性的同步机制，保证了多个线程访问共享资源时的互斥性，即<strong>同一时刻只允许一个线程访问共享资源</strong>。通过对代码块或方法添加Synchronized关键字来实现同步。</li><li>Volatile: Volatile是一种轻量级的同步机制，用来保证变量的可见性和禁止指令重排序。当一个变量被声明为Volatile时，线程在读取该变量时会直接从内存中读取，而不会使用缓存，同时对该变量的写操作会立即刷回主内存，而不是缓存在本地内存中。</li></ul><h2 id="28-什么是公平锁和非公平锁？"><a href="#28-什么是公平锁和非公平锁？" class="headerlink" title="28.什么是公平锁和非公平锁？"></a>28.什么是公平锁和非公平锁？</h2><ul><li><strong>公平锁：</strong> 指多个线程<strong>按照申请锁的顺序来获取锁</strong>，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点在于各个线程公平平等，每个线程等待一段时间后，都有执行的机会，而它的缺点就在于整体执行速度更慢，吞吐量更小。</li><li><strong>非公平锁：</strong> <strong>多个线程加锁时直接尝试获取锁，能抢到锁到直接占有锁</strong>，抢不到才会到等待队列的队尾等待。非公平锁的优势就在于整体执行速度更快，吞吐量更大，但同时也可能产生线程饥饿问题，也就是说如果一直有线程插队，那么在等待队列中的线程可能长时间得不到运行。</li></ul><h2 id="29-非公平锁吞吐量为什么比公平锁大？"><a href="#29-非公平锁吞吐量为什么比公平锁大？" class="headerlink" title="29.非公平锁吞吐量为什么比公平锁大？"></a>29.非公平锁吞吐量为什么比公平锁大？</h2><ul><li><strong>公平锁执行流程</strong>：获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，<strong>锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态</strong>，但线程<strong>每次休眠和恢复都需要从用户态转换成内核态</strong>，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。</li><li><strong>非公平锁执行流程</strong>：当线程获取锁时，<strong>会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。</strong>这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。</li></ul><p>看出公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：<strong>hasQueuedPredecessors() 为 false</strong>，这个方法就是判断在等待队列中是否已经有线程在排队了。</p><h2 id="30-什么情况会产生死锁问题？如何解决？"><a href="#30-什么情况会产生死锁问题？如何解决？" class="headerlink" title="30.什么情况会产生死锁问题？如何解决？"></a>30.什么情况会产生死锁问题？如何解决？</h2><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件：互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</li><li>持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</li><li>不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</li><li>环路等待条件：环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</li></ul><p>例如，线程 A 持有资源 R1 并试图获取资源 R2，而线程 B 持有资源 R2 并试图获取资源 R1，此时两个线程相互等待对方释放资源，从而导致死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread A acquired resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread A acquired resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread B acquired resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread B acquired resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p><p>那什么是资源有序分配法呢？线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1737006711792-cd31cdf7-f5e3-4091-8fb7-bde2d5f117bc.webp" alt="null"></p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="1-多线程打印奇偶数，怎么控制打印的顺序"><a href="#1-多线程打印奇偶数，怎么控制打印的顺序" class="headerlink" title="1.多线程打印奇偶数，怎么控制打印的顺序"></a>1.多线程打印奇偶数，怎么控制打印的顺序</h2><p>可以利用wait()和notify()来控制线程的执行顺序。</p><p>以下是一个基于这种方法的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintOddEven</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">printOdd</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt;= MAX_COUNT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">printEven</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (count &lt;= MAX_COUNT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count++);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oddThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printOdd, <span class="string">&quot;OddThread&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">evenThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printEven, <span class="string">&quot;EvenThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<strong>通过一个共享的锁对象lock来控制两个线程的交替执行</strong>。一个线程负责打印奇数，另一个线程负责打印偶数，<strong>通过wait()和notify()方法来在两个线程之间实现顺序控制。当当前应该打印奇数时，偶数线程会进入等待状态，反之亦然。</strong></p><h2 id="2-3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？"><a href="#2-3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？" class="headerlink" title="2.3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？"></a>2.3个线程并发执行，1个线程等待这三个线程全部执行完在执行，怎么实现？</h2><ul><li>创建 3 个并发执行的线程，在每个线程的任务结束时调用 <code>countDown</code> 方法将计数器减 1。</li><li>创建第 4 个线程，使用 <code>await</code> 方法等待计数器为 0，即等待其他 3 个线程完成任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CountDownLatch，初始计数为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动 3 个并发线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNumber</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threadNumber + <span class="string">&quot; is working.&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟线程执行任务</span></span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread &quot;</span> + threadNumber + <span class="string">&quot; has finished.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务完成后，计数器减 1</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动第 4 个线程，等待其他 3 个线程完成</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Waiting for other threads to finish.&quot;</span>);</span><br><span class="line">                <span class="comment">// 等待计数器为 0</span></span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;All threads have finished, this thread starts to work.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong>：</p><ul><li>首先，创建了一个 <code>CountDownLatch</code> 对象 <code>latch</code>，并将其初始计数设置为 3。</li><li>然后，使用 <code>for</code> 循环创建并启动 3 个线程。每个线程会执行一些工作（这里使用 <code>Thread.sleep</code> 模拟），在工作完成后，会调用 <code>latch.countDown()</code> 方法，将 <code>latch</code> 的计数减 1。</li><li>最后，创建第 4 个线程。这个线程在开始时调用 <code>latch.await()</code> 方法，它会阻塞，直到 <code>latch</code> 的计数为 0，即前面 3 个线程都调用了 <code>countDown()</code> 方法。一旦计数为 0，该线程将继续执行后续任务。</li></ul><h2 id="3-单例模型既然已经用了synchronized，为什么还要在加volatile？"><a href="#3-单例模型既然已经用了synchronized，为什么还要在加volatile？" class="headerlink" title="3.单例模型既然已经用了synchronized，为什么还要在加volatile？"></a>3.单例模型既然已经用了synchronized，为什么还要在加volatile？</h2><p>使用 <code>synchronized</code> 和 <code>volatile</code> 一起，可以创建一个既线程安全又能正确初始化的单例模式，避免了多线程环境下的各种潜在问题。这是一种比较完善的线程安全的单例模式实现方式，尤其适用于高并发环境。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code> 关键字的作用用于确保在多线程环境下，只有一个线程能够进入同步块（这里是 <code>synchronized (Singleton.class)</code>）。在创建单例对象时，<strong>通过 <code>synchronized</code> 保证了创建过程的线程安全性，避免多个线程同时创建多个单例对象。</strong></p><p><code>volatile</code> 确保了对象引用的可见性和创建过程的有序性，避免了由于指令重排序而导致的错误。</p><p><code>instance = new Singleton();</code> 这行代码并不是一个原子操作，它实际上可以分解为以下几个步骤：</p><ul><li>分配内存空间。</li><li>实例化对象。</li><li>将对象引用赋值给 <code>instance</code>。</li></ul><p><strong>由于 Java 内存模型允许编译器和处理器对指令进行重排序</strong>，在没有 <code>volatile</code> 的情况下，可能会出现重排序，例如先将对象引用赋值给 <code>instance</code>，但对象的实例化操作尚未完成。</p><p>这样，其他线程在检查 <code>instance == null</code> 时，会认为单例已经创建，从而得到一个未完全初始化的对象，导致错误。</p><p><code>volatile</code> 可以保证变量的可见性和禁止指令重排序。它确保对 <code>instance</code> 的修改对所有线程都是可见的，并且保证了上述三个步骤按顺序执行，避免了在单例创建过程中因指令重排序而导致的问题。</p><h2 id="4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？"><a href="#4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？" class="headerlink" title="4.假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？"></a>4.假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</h2><p>在没有任何同步机制的情况下，两个线程并发对同一个整型变量进行 50 次加 1 操作，<strong>最终结果可能是 100，也可能小于 100，最坏的结果是 50，</strong>也就是最终的结果可能是在 [50, 100] 。</p><p>小于 100 情况的分析，由于对整型变量的 <code>num++</code> 操作不是原子操作，它实际上包含了三个步骤：<strong>读取变量的值、将值加 1、将新值写回变量。</strong>在多线程环境下，可能会出现线程安全问题。例如，线程 1 和线程 2 同时读取了变量的当前值，然后各自将其加 1，<strong>最后都将相同的新值写回变量，这就导致了一次加 1 操作的丢失。</strong>这种情况会多次发生，最终结果就会小于 100。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式：通过 <code>synchronized</code> 关键字或 <code>ReentrantLock</code> 确保操作的互斥性，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/juc/">juc</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/22/java-stack/juc2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql进阶技术栈</title>
      <link>https://blog.tokenlen.top/2025/05/21/mysql/mysqlstack/</link>
      <guid>https://blog.tokenlen.top/2025/05/21/mysql/mysqlstack/</guid>
      <pubDate>Tue, 20 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;主从同步&quot;&gt;&lt;a href=&quot;#主从同步&quot; class=&quot;headerlink&quot; title=&quot;主从同步&quot;&gt;&lt;/a&gt;主从同步&lt;/h1&gt;&lt;h2 id=&quot;1-MySQL-主从架构有什么优缺点？&quot;&gt;&lt;a href=&quot;#1-MySQL-主从架构有什么优缺点？&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h1><h2 id="1-MySQL-主从架构有什么优缺点？"><a href="#1-MySQL-主从架构有什么优缺点？" class="headerlink" title="1.MySQL 主从架构有什么优缺点？"></a>1.MySQL 主从架构有什么优缺点？</h2><p>MySQL Replication 是 MySQL 官方提供的主从同步方案，用于将 MySQL 主库的数据同步到从库中，从库可以供应用程序读取数据。</p><p>Replication 是目前 MySQL 使用最多的灾备方案，主要有 3 个作用：</p><ol><li><strong>读写分离</strong>，写主库读从库。这样大大降低主库的负载，即使主库出现类似锁表之类的情况，也不影响应用读取数据。</li><li><strong>实现灾备</strong>，当主库发生故障时，可以方便地把从库切换成主库，实现<strong>高可用</strong>（HA）。</li><li><strong>水平扩展</strong>，当应用访问量导致数据库 I/O 高时，可以通过水平扩展的方式将降低单机负载，降低磁盘 I/O。</li></ol><p><strong>同步原理：</strong></p><p>MySQL 通过 binlog 实现同步过程中，会用到 3 个线程：</p><ul><li><strong>IO thread</strong>: 从库执行 START SLAVE 语句时，会创建一个 IO thread，负责连接主节点，请求更新的 <strong>binlog**</strong>，接收到 binlog 后写入 relaylog；**</li><li>dump thread：主库接收到从库的 binlog 请求后，创建一个 <strong>dump thread</strong>，把 binlog 同步给从库；</li><li>sql thread：<strong>读取 relaylog，解析 relaylog 的命令并执行，将数据落库。</strong></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8A2qPg567sK8NyS4KJ7rn97XibbwjO9bs8gTv2ODQNRyT8W98jvmGzgYVyBibLELp2nkdp9eT5BPjg/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>在从库上执行 <strong>change master 命令，设置要连接主库的用户名、密码、ip、端口以及请求同步的 binlog 中的位置，这个位置包含文件名和binlog offset；</strong></p><p>从库执行 <strong>start slave</strong> 命令，这时会启动上面的 <strong>IO thread 和 sql thread</strong>，其中 IO thread 负责跟主库建立连接；</p><p>主库收到从库的连接请求后，校验用户名密码；</p><p>主库校验通过后创建 <strong>dump thread，按照从库请求 binlog 的 offset 将 binlog 发给从库；</strong></p><p>从库收到主库发送的 binlog 后，将日志写入 <strong>relaylog；</strong></p><p>sql thread 读取 relaylog，解析出命令后执行。</p><p><strong>缺点：</strong></p><p><strong>最大的缺点就是主从延迟</strong>。</p><p>原因：：：：：</p><p>从库所在机器性能差，命令执行慢；</p><p>从库查询压力大，消耗了大量 CPU 资源，影响了 sql thread 执行；</p><p>主库有<strong>大事务</strong>（比如大表DDL），这个事务里面执行的 sql 比较多，一方面主库需要等待事务执行完成才能写入 binlog，另一方面同步到从库和在从库执行都需要花费很多时间，导致主从延迟；</p><p>数据库版本低，<strong>在 MySQL 5.6 之前，只支持单线程复制，效率比较低；</strong></p><p>表上无主键，主库利用索引更改数据，从库只能用全表扫描。</p><p>要解决主备延迟的问题，可以考虑下面方法：</p><ol><li>优化业务逻辑，避免使用大事务，或者大事务场景尽量放在业务低峰期执行；</li><li>提高从库所在机器的性能；</li><li>保障网络性能，避免网络延迟；</li><li>引入 <strong>semi-sync 半同步复制</strong>，配合异步复制。</li></ol><p><strong>主从同步的第二个缺点就是数据丢失</strong>。</p><blockquote><p>MySQL 有 3 种主从复制方式：</p><ol><li><strong>异步复制</strong>：主<strong>库执行完客户端提交的事务后立即将结果返回给客户端，不关心从库是否同步完成</strong>。这种方式很容易发生数据丢失，比如主库的日志还未同步给从库就宕机了，这时需要在从库中选择一个作为新主库，之前未同步完成的数据就丢失了；</li><li>全同步复制：<strong>主库执行完客户端提交的事务并且等待从库也执行完成数据同步后再把结果返回给客户端</strong>。这种方式能够保证不丢失数据，但是数据库的性能会受到影响；</li><li>半同步复制：是介于全同步和异步复制的一种方式，<strong>主库至少等待一个从库接收 binlog 并成功写入到 relaylog 后给客户端返回结果</strong>。主库不需要等待所有从库返回 ACK。</li></ol></blockquote><p>MySQL 中默认采用<strong>异步复制</strong>，这样很容易导致数据丢失。一个好的方式就是采用 <strong>semi-sync 半同步复制插件</strong>。不过 semi-sync 存在一个问题，主库写数据到 binlog 后执行 commit，才会给从库同步数据。如果从库还没有返回 ACK，主库发生了宕机，从库还没有写完 relaylog 就被选择为主库，也会发生数据丢失。</p><p>MySQL 5.7 引入了增强版<strong>半同步复制</strong>。主库写入数据到 binlog 后，就给从库进行同步，直到至少一个从库返回给主库 ACK，主库才会进行 commit 操作。</p><h2 id="2-MySQL双主架构有什么优缺点？"><a href="#2-MySQL双主架构有什么优缺点？" class="headerlink" title="2.MySQL双主架构有什么优缺点？"></a>2.<strong>MySQL双主架构有什么优缺点？</strong></h2><p>双主架构是 MySQL 常见的一种架构模式，它的特点是<strong>有两个主节点对外提供服务，并且这两个主节点互为主备</strong>。今天来学习一下双主架构。</p><h3 id="1-双主复制"><a href="#1-双主复制" class="headerlink" title="1.双主复制"></a>1.双主复制</h3><p>这种架构的特点配置两个主库，<strong>每个主库都提供读写服务，并且这两个主库互为主备。</strong>如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd9JI16DxScxchEPaXKy2zRrpict4icZnFhokHazh1k4LyCP2J5YBkvTjA9WmzAJoLiabXOZaqfcG25jg/640?wx_fmt=png&amp;from=appmsg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=wxpic" alt=""></p><p>在 M1 写入的数据要同步到 M2，在 M2 写入的数据要同步到 M1。这种两个主库同时支持写入，这种架构模式一个明显的优势写入效率高。比如一个应用在不同的城市部署了两个主节点，请求可以就近选择写入数据库。</p><p>但这种架构在数据同步时很容易出问题。 </p><p>案例一：<strong>M1 和 M2 同时收到一张表的插入请求，这张表是自增主键，两张表插入后主键相同。这时发生数据同步，这条插入语句在 binlog 里面记录的是 row 格式，同步时发生主键冲突。</strong></p><blockquote><p>MySQL binlog 有三种格式：</p><ul><li>STATEMENT：记录的是 SQL 语句本身；</li><li>ROW：记录的是数据的变化；</li><li>MIXED：STATEMENT 和 ROW 格式的结合，MySQL 会根据 SQL 语句特性选择使用 STATEMENT 还是 ROW 格式。</li></ul></blockquote><p>解决方法：：：</p><p>MySQL 5.0 后可以通过设置 <strong>auto_increment_increment</strong> 和 <strong>auto_increment_offset</strong> 这两个选项来解决这个问题。</p><p>案例二：在 M1 上执行了一条语句，生成 binlog 后发给 M2 进行同步，M2 执行完成后又生成 binlog 同步给 A，<strong>导致一条语句循环复制</strong>。</p><p>这个问题的解决方法是要求 <strong>M1 和 M2 的 server id</strong>不相同，M1 产生的 binlog 记录 server id 是 M1，M2 执行同步时生成的 binlog 也记录 server id 为 M1。这样同步给 M1 是，M1 判断到 server id 跟自己相同，就丢弃这个日志，不做同步。</p><p>案例三：<strong>同步过程中会有数据不一致的问题</strong>。比如用户 xiaoming 的账户余额是 100。M1 执行了 update 操作把账户余额更新成 150，M2 执行了 update 操作更新成 130。</p><p>解决这种数据不一致问题的一个思路是<strong>严格划分数据和设置权限</strong>，比如案例中小明的所有数据只能在 M1 上操作。</p><p>案例四：<strong>因为节点发生故障，M1 不能复制了</strong>，但是应用可以写数据库，M2 能正常写和复制，这个问题就很难解决了。</p><p>解决这个问题，<strong>需要给 M1 和 M2 配置从节点，主节点故障后切换到从节点进行工作。</strong></p><h3 id="2-主备复制"><a href="#2-主备复制" class="headerlink" title="2.主备复制"></a>2.主备复制</h3><p>这个架构模式的特点是双主节点中，<strong>同一时刻只有一个主节点提供写服务，另一个主节点只能提供读服务。</strong>如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd9JI16DxScxchEPaXKy2zRr1tqZkws2VGynmsyOtvbm3ia5VxnjCf6klRRyTChQo1dsXn5FsK1SJwA/640?wx_fmt=png&amp;from=appmsg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=wxpic" alt=""></p><p>这个架构相当于比单主节点架构多了一个热备，有如下优势：</p><ol><li>因为 M1 和 M2 配置对称，切换主备比较容易；</li><li>有助于故障转移和恢复；</li><li>可以在不影响应用的情况下进行数据库升级和维护；</li><li>不用考虑循环复制问题和主备不一致问题。</li></ol><p>当然，主备架构也有缺点，<strong>那就是写性能不能得到提升。</strong></p><h3 id="3-主主架构拥有备库"><a href="#3-主主架构拥有备库" class="headerlink" title="3.主主架构拥有备库"></a>3.主主架构拥有备库</h3><p>主主架构中每个主库也可以拥有备库，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd9JI16DxScxchEPaXKy2zRrpict4icZnFhokHazh1k4LyCP2J5YBkvTjA9WmzAJoLiabXOZaqfcG25jg/640?wx_fmt=png&amp;from=appmsg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=wxpic" alt=""></p><p>这种配置为每个主库增加了一个备份，<strong>可以防止单点故障，同时备库也可以处理读请求，提高数据库整体读效率。</strong></p><p>这个架构的缺点是增加了机器成本。</p><h3 id="4-环形复制"><a href="#4-环形复制" class="headerlink" title="4.环形复制"></a>4.环形复制</h3><p>环形复制架构是 MySQL 集群中拥有多个主库，主库之间形成一个环形，<strong>前面一个节点是当前节点的主库，当前节点是前面节点的备库，也是后面一个节点的主库</strong>。如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd9JI16DxScxchEPaXKy2zRrZm1OfPH5HMCAyzHxCdicCmrh98dL9p1uWnLlIbAFhXH1ibAic8icxv8jyg/640?wx_fmt=png&amp;from=appmsg&amp;wxfrom=5&amp;wx_lazy=1&amp;tp=wxpic" alt=""></p><p>环形复制这种架构其实并不推荐，<strong>因为它很难做到故障转移</strong>，高可用特性依赖于每个节点不出故障。但是如果一个节点出了故障，去掉这个节点，<strong>这个节点产生的 binlog 将一直循环复制下去，因为只有通过这个节点的 server id 才能做出判断停止复制。</strong></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="1-mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？"><a href="#1-mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？" class="headerlink" title="1.mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？"></a>1.mysql索引的类型，聚集索引和非聚集索引是什么？非聚集索引一定回表查询吗？索引下推是什么？</h2>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/21/mysql/mysqlstack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>tcpfile上传</title>
      <link>https://blog.tokenlen.top/2025/05/21/workmenu/tcpfile/</link>
      <guid>https://blog.tokenlen.top/2025/05/21/workmenu/tcpfile/</guid>
      <pubDate>Tue, 20 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;1、  课程设计目的&lt;/p&gt;
&lt;p&gt;本课程设计旨在实现一个基于 &lt;strong&gt;TCP 协议&lt;/strong&gt; 的文件传输系统，模拟实际网络传输过程，并结合多种文件存储方案，完成文件接收与保存的后端处理。通过该系统，学生能深入理解：&lt;/p&gt;
&lt;p&gt;基于 Socket 的</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>1、  课程设计目的</p><p>本课程设计旨在实现一个基于 <strong>TCP 协议</strong> 的文件传输系统，模拟实际网络传输过程，并结合多种文件存储方案，完成文件接收与保存的后端处理。通过该系统，学生能深入理解：</p><p>基于 Socket 的 TCP 通信原理；</p><p>文件传输协议的设计与实现；</p><p>网络编程中数据流的处理方式；</p><p>结合 Spring Boot 完成服务模块封装；</p><p>将传输后的文件按需保存至本地或云存储系统。</p><p>使用git进行代码的版本管理和代码托管</p><p>项目的github地址：<strong><a href="https://github.com/mengnankkkk/tcp-file-transfer">https://github.com/mengnankkkk/tcp-file-transfer</a></strong></p><p>2、课程设计要求</p><p>实现 TCP Server，持续监听客户端连接，接收文件数据流；</p><p>设计传输协议，确保文件名、大小、内容等完整接收；</p><p>实现服务端文件保存功能，支持多种存储后端（本地 / 腾讯云 / 阿里云 / MinIO）；</p><p>文件传输完成后记录文件元信息（文件名、时间）；</p><p>提供文件列表接口（/files）供前端查看已上传文件；</p><p>使用 Java + Spring Boot 构建后端服务，模块清晰，便于扩展；</p><p>3、相关知识</p><p><strong>Socket</strong> <strong>编程</strong>：Java 中通过 ServerSocket / Socket 实现 TCP 通信。</p><p><strong>阻塞式 I/O 流处理</strong>：使用 InputStream / OutputStream 处理文件字节流。</p><p><strong>协议设计</strong>：客户端按顺序发送文件名长度、文件名、文件大小、文件内容；服务端按顺序解析。</p><p><strong>线程并发</strong>：TCP Server 通常使用线程池处理多个客户端的连接请求。</p><p><strong>Spring Boot</strong> <strong>框架</strong></p><p>组件注入、配置自动化；</p><p>使用 @Service、@Controller 等注解模块化业务逻辑；</p><p>条件注入（@ConditionalOnProperty）实现多存储适配；</p><p><strong>文件存储知识</strong></p><p>本地文件保存：使用 FileOutputStream 写入磁盘；</p><p>腾讯云 COS、阿里云 OSS、MinIO：通过各自 SDK 上传对象；</p><p>统一封装接口 FileStorageService 抽象存储细节，提升系统解耦能力；</p><p><strong>Git**</strong>知识**</p><p>Git的版本管理，git的使用教程</p><p>4、课程设计分析</p><p>流程：</p><p>TCP Client-&gt;TCP Server-&gt;FileStorageService-&gt;文件信息写入列表</p><p>功能：</p><p><strong>TCP</strong> <strong>服务端（FileReceiveServer）</strong><br> 启动后监听指定端口，接受来自客户端的文件传输请求，并使用线程池处理多个连接</p><p><strong>文件存储模块（FileStorageService）</strong><br> 根据配置自动选择保存方式，支持本地或对象存储。</p><p><strong>文件信息管理（FileListService）</strong><br> 用于展示历史上传文件，供用户查看。</p><p>5.程序测试</p><p>springboot@value注入文件</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>文件上传controller</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><p>运行项目，returnlog日志</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></p><p>Postman进行上传测试</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img"></p><p>上传两次图片试验</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></p><p>Log日志返回提示信息</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg" alt="img"></p><p>阿里云桶中发现文件上传成功</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg" alt="img"></p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg" alt="img"></p><p>腾讯云上传service功能</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg" alt="img"></p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg" alt="img"></p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg" alt="img"></p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg" alt="img"></p><p>下载功能</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg" alt="img"></p><p>下载功能get到文件</p><p><img src="file:///C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image028.jpg" alt="img"></p><p>6、相关扩展和未来开发展望</p><p> <strong>文件完整性校验</strong>：客户端发送文件 hash 值，服务端验证一致性；</p><p> <strong>断点续传与多线程上传</strong>：使用标志位和分片文件实现；</p><p> <strong>文件压缩与解压传输</strong>：节省带宽，提高效率；</p><p> <strong>TCP + SSL</strong> <strong>加密传输</strong>：保障文件安全；</p><p> <strong>前端可视化页面</strong>：展示上传记录、实时传输状态；</p><p> <strong>服务端上传进度回调</strong>：通过 WebSocket 推送上传进度；</p><p> <strong>多存储联邦模式</strong>：按文件类型或大小自动选择不同存储后端；</p><p> <strong>Docker</strong> <strong>容器部署 TCP 服务端与文件服务</strong>：便于部署与测试；</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/21/workmenu/tcpfile/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase知识总结</title>
      <link>https://blog.tokenlen.top/2025/05/19/javase/javase1/</link>
      <guid>https://blog.tokenlen.top/2025/05/19/javase/javase1/</guid>
      <pubDate>Sun, 18 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>java中有8种基本类型：</p><p>byte, short, int, long, float, double, boolean, char</p><p>还有引用类型</p><p>类、数组、接口等。</p><p>比如<strong>String</strong>就是引用类型。引用类型的默认是 <code>null</code></p><div class="table-container"><table><thead><tr><th>类型</th><th>位数</th><th>默认值</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>0</td><td>Byte</td></tr><tr><td>short</td><td>16</td><td>0</td><td>Short</td></tr><tr><td>int</td><td>32</td><td>0</td><td>Integer</td></tr><tr><td>long</td><td>64</td><td>0L</td><td>Long</td></tr><tr><td>float</td><td>32</td><td>0.0f</td><td>Float</td></tr><tr><td>double</td><td>64</td><td>0.0d</td><td>Double</td></tr><tr><td>char</td><td>16</td><td>‘\u0000’</td><td>Character</td></tr><tr><td>boolean</td><td>1</td><td>false</td><td>Boolean</td></tr></tbody></table></div><p>浮点数的默认类型是double 赋给 <code>float</code> 需加 <code>f</code> 后缀。精度变小</p><p><strong>byte是循环的，满了128就从-128开始</strong></p><p>double和long都是默认占64位的存储空间</p><p>long用于存储整数值，范围为-2^63^到 2^63^-1，double用于存储浮点数，遵循IEEE 754标准。</p><p>基本数据类型和引用类型的主要区别在于:</p><ol><li><p>基本类型变量存储的是实际的数据值</p></li><li><p>引用类型变量存储的是对象的引用(内存地址)</p></li><li><p>基本类型在栈中分配内存,引用类型在堆中分配内存</p></li></ol><p>   只有 <strong>Byte、Short、Integer、Long</strong> 实现了缓存机制，且默认缓存 -128 到 127 范围内的值。缓存机制可以提升性能，减少不必要的对象创建。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><div class="table-container"><table><thead><tr><th>类名</th><th>可变性</th><th>线程安全</th><th>性能</th></tr></thead><tbody><tr><td>String</td><td>不可变</td><td>安全</td><td>最低</td></tr><tr><td>StringBuilder</td><td>可变</td><td>不安全</td><td><strong>最快</strong></td></tr><tr><td>StringBuffer</td><td>可变</td><td>安全</td><td>中等</td></tr></tbody></table></div><p>String类型只要是字符串一样，<strong>==与equals都一样</strong>，因为都在<strong>字符串常量池</strong>的一个位置里。会调用原先有的 String是需要初始化的。但是如果是new了一个的话就不一样了</p><p>单纯的字符串是一样的。他们是线程共享的。然后String是final，是不可以修改的。</p><p>如果连接字符串的时候，<strong>遇见数字，直接连接</strong>，没有遇到就按数学计算</p><p>StringBuilder是非线程安全的,不需要维护线程同步,所以运行速度最快。他<strong>是单线程操作的</strong>，适用于单线程环境中需要大量修改字符串的场景，如高频拼接操作。</p><p>StringBuffer运行速度确实比String快。<strong>因为String的不可变性</strong>,每次操作都会产生新对象,而<strong>StringBuffer是可变的,在原对象上直接修改。</strong>但是他们都是final修饰的</p><p>StringBuffer的所有公共方法都是<strong>synchronized</strong>修饰的,是线程安全的,适合在多线程环境下使用。</p><p>可以直接修改字符串</p><p>在 Java 8 及以后，编译器会对字符串的常量拼接做优化，<strong>将字符串拼接转换为 StringBuilder</strong> 操作，这种优化提高了代码性能。</p><p>- String适用于<strong>少量的字符串操作的情况</strong><br>- StringBuilder适用<strong>于单线程</strong>下在字符缓冲区进行大量操作的情况<br>- StringBuffer适用于<strong>多线程下</strong>在字符缓冲区进行大量操作的情况</p><p>这三者性能从高到低排序为:StringBuilder &gt; StringBuffer &gt; String</p><p>但是<strong>intern</strong>方法会在首先在常量池中寻找，有的话就直接用</p><h3 id="运算法则"><a href="#运算法则" class="headerlink" title="运算法则"></a>运算法则</h3><p>boolean b = true ? false : true==true ? false : true</p><p>首先要明确<strong>三元运算符</strong>的结合性是从<strong>右到左</strong>的，但此处有一个条件表达式true在最前面</p><p>他直接是true了，所以直接返回false</p><p><strong>复合赋值运算符/=的优先级低于++运算符</strong></p><p>double类型除以int类型，结果会自动转换为double类型</p><p>在进行除法运算的话，<strong>如果都是整形，那么会向下取整，舍去小数部分</strong></p><blockquote><blockquote><p>是算术右移运算符，它使所有的位向右移动，但保持符号位不变。对于负数，左边会自动补1，正数则补0。</p></blockquote></blockquote><p>>&gt;&gt; 是逻辑右移运算符（也称无符号右移），它使所有的位向右移动，并且左边总是补0，不管原来的数是正数还是负数。</p><p>他俩都是相当于/2，但是正负数的时候不同。由二进制可看出来</p><p>其中有&lt;&lt;=</p><p>没有&lt;&lt;&lt;=</p><p>==是比较在内存中的位置，equals是比较value的大小</p><p>在java中小于int精度的计算都会自动转为int进行计算</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final<strong>不能修饰接口和抽象类</strong>。final表示”最终的”含义,而接口和抽象类本身就是需要被实现或继承的,与final的语义相矛盾。final只能修饰<strong>具体的类、方法和变量。</strong></p><p>final修饰的方法不能被重写(Override),但是<strong>可以被重载</strong>(Overload)。重写是子类对父类方法的覆盖,而重载是同一个类中方法名相同但参数不同。</p><p>final修饰的变量是常量,一旦被赋值就不能再次修改。对于<strong>基本类型,是值不能改变;对于引用类型,是引用不能改变(但对象的内容可以改变)。</strong></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><code>static</code> 表示“静态”的含义，用于修饰类的成员（变量、方法、代码块、内部类）。被 <code>static</code> 修饰的成员<strong>属于类本身</strong>，而不是某个对象。</p><p>因此，<strong>无需创建对象即可访问静态成员</strong>，推荐通过“类名.成员”的方式调用。</p><p><strong>static 不能修饰构造方法和局部变量</strong>，因为构造方法是用来创建对象的，局部变量只在方法执行时存在，二者与类无关。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>this</code> 表示<strong>当前对象的引用</strong>，常用于区分成员变量与局部变量、在构造方法中调用其他构造方法、将当前对象作为参数传递等。</p><p><code>this()</code> 调用构造器必须放在构造方法的第一行。</p><p>this和super不能同时使用在一个构造函数里</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code> 表示<strong>父类对象的引用</strong>，可用于访问父类的成员变量、方法、构造方法。</p><p>因为在子类构造方法中调用父类构造方法<strong>super()</strong>必须位于<strong>第一行</strong>,这是Java语言规范的要求。这样设计的原因是为了确保在初始化子类之前,父类已经完成初始化。</p><p><strong>不能在static环境</strong>(包括static方法和static代码块)中使用。因为static成员属于类,而不是实例,而this和super都是和实例相关的概念。</p><p>super不仅可以在<strong>子类构造方法</strong>中使用,还可以在<strong>子类的实例方法</strong>中使用,<strong>用于调用父类被覆盖的方法或访问父类的属性。</strong></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code> 是 <strong>轻量级的同步机制</strong>，用于修饰<strong>成员变量</strong>，确保多线程间变量的可见性。</p><p><strong>不保证原子性</strong>，如 <code>count++</code> 仍需配合 <code>synchronized</code> 或 <code>AtomicInteger</code>。</p><p>不适用于复合操作（读-改-写）。</p><p><strong>保证变量的可见性</strong>：一个线程修改了值，其他线程能立即看到。</p><p><strong>禁止指令重排序</strong>：用于保证一定的执行顺序，适合标志类变量。</p><p>volatile的实现确实遵循<strong>happens-before</strong>原则。happens-before原则是Java内存模型中的重要概念，它保证了volatile写操作一定happens-before于后续对这个volatile变量的读操作。</p><p><strong>volatile关键字是Java中用于保证变量可见性和有序性的重要机制。</strong></p><p>volatile变量在每次被线程访问时，<strong>都强制从主内存中重新读取最新值，而不是使用线程工作内存中的值。这确保了变量的可见性。</strong></p><p>volatile关键字通过<strong>内存屏障(Memory Barrier)来阻止指令重排序</strong>。它能确保volatile变量读写操作的顺序性，防止编译器和处理器对这些操作进行重排序优化。</p><p>volatile不能保证线程安全。它只能保证变量的可见性和禁止指令重排序，但不能保证原子性。</p><p>volatile只能保证<strong>可见性和有序性</strong>,<strong>无法保证互斥性和原子性</strong>。例如count++这样的操作,volatile无法保证其原子性,因为这个操作实际包含读取、递增、写入三个步骤。所以不能包装线程安全</p><p>volatile只能用于<strong>修饰变量</strong>,不能修饰方法和类。作用是告诉编译器和虚拟机，<strong>该变量可能会被多个线程同时访问</strong>，因此不应该进行编译器优化或缓存</p><h3 id="接口-amp-抽象类"><a href="#接口-amp-抽象类" class="headerlink" title="接口&amp;抽象类"></a>接口&amp;抽象类</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类是一种特殊的类,其最<strong>显著的特征就是不能被实例化。抽象类主要用于被其他类继承</strong>,为子类提供通用的属性和方法实现,同时也可以<strong>声明抽象方法要求子类必须实现。</strong>只有<strong>当子类是非抽象类时才必须实现所有抽象方法</strong>，如果子类也是抽象类则可以不实现父类的抽象方法。</p><p>抽象类中可以包含普通方法,也可以包含抽象方法,并不要求所有方法都是抽象方法。抽象类中的普通方法可以有具体的实现代码。</p><p>一个类可以被声明为抽象类，<strong>即使它不包含任何抽象方法。这种设计可以用来阻止类的实例化</strong></p><p>抽象类可以有构造方法。尽管抽象类不能被实例化,但其构造方法可以被子类通过super()调用,用于初始化从抽象类继承的属性。</p><p>抽象类的主要作用是作为<strong>基类</strong>使用,通过<strong>继承和多态机制</strong>实现代码的复用和扩展。它既可以包含抽象方法强制子类实现,又可以提供通用方法的具体实现,是面向对象编程中重要的设计工具。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是一种特殊的抽象类型,其中定义的方法默认都是public abstract的。在Java接口中,方法的修饰符具有严格的限制。</p><p>默认访问权限是default（包访问权限）</p><p>接口内的变量都具有默认的修饰符，<strong>等价于public static final。</strong></p><p>❌ 不能定义构造方法，就是方法他也不能实现，不能使用大括号 可以使用static default private方法(jdk9)</p><p>✅ 只能是 <code>public static final</code> 常量</p><p>接口中的方法默认就是public和abstract的。这是Java接口的特性，即使不显式声明这些修饰符，编译器也会自动添加。这样可以确保接口方法的可访问性和抽象性。</p><div class="table-container"><table><thead><tr><th>特性</th><th>接口（interface）</th><th>抽象类（abstract class）</th></tr></thead><tbody><tr><td><strong>是否可以实例化</strong></td><td>否</td><td>否</td></tr><tr><td><strong>是否支持构造方法</strong></td><td>❌ 不能定义构造方法</td><td>✅ 可以有构造方法（用于子类构造时调用）</td></tr><tr><td><strong>是否可以包含成员变量</strong></td><td>✅ 只能是 <code>public static final</code> 常量</td><td>✅ 可以有普通字段、静态字段、常量等</td></tr><tr><td><strong>是否可以包含方法实现</strong></td><td>✅ 从 Java 8 开始：— <code>default</code> 默认方法— <code>static</code> 静态方法— Java 9 起允许 <code>private</code> 方法</td><td>✅ 可以包含抽象方法、非抽象方法（即有方法体的）</td></tr><tr><td><strong>继承机制</strong></td><td>只能继承接口（多继承）隐式继承 <code>Object</code> 的方法签名（如 <code>toString()</code>），但不继承其实现</td><td>只能继承一个抽象类（单继承）显式或隐式继承 <code>Object</code></td></tr><tr><td><strong>访问修饰符限制</strong></td><td>方法默认是 <code>public</code>，不能是 <code>protected</code>、<code>private</code>（Java 9 起可以定义 <code>private</code> 方法）</td><td>方法、字段可以用 <code>private</code>、<code>protected</code>、<code>public</code></td></tr><tr><td><strong>关键字约束</strong></td><td>默认方法用 <code>default</code> 修饰；所有变量自动是 <code>public static final</code></td><td>抽象方法必须使用 <code>abstract</code> 修饰；类必须用 <code>abstract</code> 修饰</td></tr><tr><td><strong>实现/继承方式</strong></td><td>使用 <code>implements</code> 实现一个或多个接口</td><td>使用 <code>extends</code> 继承抽象类（只能单继承）</td></tr><tr><td><strong>适合场景</strong></td><td>关注“规范”，用于定义行为接口，强调能力的实现（like 能说话、能飞）</td><td>关注“共性”，用于抽象出共享代码或状态（like 动物有名字、吃饭等）</td></tr></tbody></table></div><h3 id="匿名对象类"><a href="#匿名对象类" class="headerlink" title="匿名对象类"></a>匿名对象类</h3><p>匿名内部类可以<strong>继承一个类或实现一个接口</strong>，并且可以重写父类的方法<br>方法重写时，<strong>子类方法返回值类型、方法名和参数必须与父类相同</strong><br>通过对象调用方法时，优先<strong>调用对象实际类型中的方法</strong>（动态绑定）</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象的四种创建方式</p><p>这四种方式各有特点和适用场景:<br>- new操作符适用于普通对象创建<br>- 反射方式适用于动态加载场景<br>- clone方式适用于对象复制场景<br>- 反序列化方式适用于数据传输场景</p><p>实例化对象的顺序：</p><p>父类Ｂ<strong>静态</strong>代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数</p><ul><li><strong>静态代码块</strong>只执行一次，随类加载而执行；</li><li><strong>实例初始化块</strong>每次 new 时执行，优先于构造方法；</li><li>构造方法最后执行，用于初始化对象本身。</li></ul><p>函数调用的两种主要参数传递方式:<strong>传值调用</strong>(call by value)和<strong>引用调用</strong>(call by reference)的特点。</p><p>传值调用保护了<strong>实际参数不被修改</strong>,而引用调用则允许通过引用修改实际参数的内容,<strong>但不能改变引用本身指向的地址</strong>。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><strong>反射机制允许在运行时加载类、访问属性、调用方法、构造对象</strong>。</p><ul><li>运行时动态操作对象</li><li>解耦合，提高灵活性</li></ul><p>使用场景：</p><ul><li><strong>判断对象所属类</strong>：<code>obj.getClass()</code> 获取对象的 Class 对象。</li><li><strong>加载类</strong>：<code>Class.forName(&quot;全类名&quot;)</code> 动态加载类。</li><li><strong>获取构造器并实例化对象</strong>：<code>clazz.getConstructor(...)</code> + <code>constructor.newInstance(...)</code></li><li><strong>访问类的成员变量和方法</strong>：<code>clazz.getDeclaredFields()</code>, <code>clazz.getDeclaredMethods()</code></li><li><strong>调用对象方法</strong>：<code>method.invoke(obj, args...)</code></li><li><strong>访问私有成员</strong>：通过 <code>setAccessible(true)</code> 取消访问检查。+</li></ul><p>反射机制<strong>实际上会降低程序的性能</strong>,因为它需要在运行时进行类型检查和解析。同时,反射也可能破坏封装性,带来安全风险,因为它可以访问私有成员。</p><p>反射机制不仅可以访问public成员,通过s<strong>etAccessible(true)方法</strong>,它还可以访问private、protected等其他访问控制级别的成员。这也是反射强大但需要谨慎使用的原因之一。违反了封装性</p><p>JAVA反射机制主要提供以下功能：</p><p>在运行时判断一个对象所属的类</p><p>在运行时构造一个类的对象</p><p>在运行时判断一个类所具有的成员变量和方法</p><p>在运行时调用一个对象的方法</p><div class="table-container"><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>提高程序灵活性和扩展性</strong>，支持动态加载类和调用</td><td><strong>性能较慢</strong>，需要绕过 JVM 优化，存在额外开销</td></tr><tr><td>支持框架、工具实现通用逻辑和动态操作</td><td><strong>破坏封装性</strong>，可访问私有成员，可能导致安全风险</td></tr><tr><td>支持动态代理、注解解析等高级功能</td><td><strong>编译时缺乏类型检查</strong>，错误只能运行时发现</td></tr></tbody></table></div><p>反射性能优化建议：</p><ul><li><strong>避免频繁调用</strong>反射操作，尤其是在热点代码中。</li><li><strong>缓存反射的 Class、Method、Field 对象</strong>，减少重复解析。</li><li>使用 Java 8+ 的 <code>MethodHandle</code> 或 <code>LambdaMetafactory</code> 替代传统反射调用，提升性能。</li><li>只在初始化或配置阶段使用反射，业务逻辑中尽量避免。</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化是将<strong>Java对象的状态转换成字节流</strong>的过程，方便对象的存储（如写入文件）或网络传输。反序列化是从字节流重构Java对象的过程。</p><p>对象所属的类必须实现<code>java.io.Serializable</code>接口。</p><ul><li><strong>Serializable是一个标记接口</strong>，不包含任何方法，只表示该类的对象可以被序列化。</li></ul><p><strong>静态变量和transient修饰的成员变量不会被序列化。</strong></p><p>与 JSON/BSON 序列化不同，Java 序列化格式是 <strong>二进制不可读</strong></p><p>transient关键字：</p><p>用于声明不需要被序列化的字段。</p><p>序列化时，这些字段的值不会被保存。</p><p>反序列化后，transient字段被赋予该类型的默认值：</p><ul><li>基本类型：0, false等</li><li>引用类型：null</li></ul><p>正确的序列化操作步骤：</p><ol><li>类实现<code>Serializable</code>接口。</li><li>创建<code>ObjectOutputStream</code>，并包装一个字节输出流（如<code>FileOutputStream</code>）。</li><li>调用<code>writeObject()</code>方法，将对象写出。</li><li>反序列化时使用<code>ObjectInputStream</code>调用<code>readObject()</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">oos.writeObject(obj);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">ois.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>选项</th><th>说明</th><th>正确与否</th></tr></thead><tbody><tr><td>A</td><td>FileOutputStream只能写字节数据，不能直接序列化对象</td><td>错误</td></tr><tr><td>B</td><td>PrintWriter写字符文本，不能进行对象序列化</td><td>错误</td></tr><tr><td>C</td><td>transient修饰的变量不会被序列化，反序列化后为默认值</td><td>正确</td></tr><tr><td>D</td><td>类必须实现Serializable接口才能被序列化</td><td>正确</td></tr></tbody></table></div><p>FileOutputStream是字节流,它只能处理原始字节数据的写入,不能直接序列化对象。要序列化对象,需要使用<strong>ObjectOutputStream</strong>包装FileOutputStream。</p><p>PrintWriter是处理字符数据的输出流,主要用于写入文本数据,不能直接进行对象序列化。要序列化对象必须使用<strong>ObjectOutputStream</strong>。</p><h3 id="深拷贝-amp-浅拷贝"><a href="#深拷贝-amp-浅拷贝" class="headerlink" title="深拷贝&amp;浅拷贝"></a>深拷贝&amp;浅拷贝</h3><div class="table-container"><table><thead><tr><th>对比项</th><th>浅拷贝（Shallow Copy）</th><th>深拷贝（Deep Copy）</th></tr></thead><tbody><tr><td>拷贝级别</td><td>拷贝对象本身+<strong>引用地址</strong></td><td>拷贝对象本身+<strong>引用对象的内容</strong></td></tr><tr><td>引用对象</td><td>原对象与副本<strong>共享引用对象</strong></td><td>副本拥有独立的引用对象</td></tr><tr><td>默认实现</td><td>Object.clone() 默认是浅拷贝</td><td>需手动实现递归复制</td></tr><tr><td>影响</td><td>改变副本的引用成员，会影响原对象</td><td>改变副本不影响原对象</td></tr><tr><td>应用场景</td><td>轻量对象复制，性能优先</td><td>要求对象完全独立、互不干扰</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person implements Cloneable &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    public Person clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        // 浅拷贝</span><br><span class="line">        return (Person) super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person deepClone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Person p = (Person) super.clone();</span><br><span class="line">        p.address = new Address(this.address.city); // 手动复制引用类型</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型是一种参数化类型机制</strong>，允许类、接口、方法在定义时使用类型参数。</p><p>目的是让代码更加<strong>类型安全</strong>、<strong>可重用</strong>，避免频繁的类型转换。</p><p>好处：</p><p><strong>编译期类型检查</strong>，提升代码安全性，防止运行时类型转换异常（ClassCastException）。编译时会自动装箱拆箱来配合基本类型的包装类。</p><p><strong>避免强制类型转换</strong>，代码更简洁清晰。</p><p><strong>提高代码复用性</strong>，同一份代码可以处理不同类型的数据。</p><p>不能用于：<strong>基本数据类型（如int、double等）</strong>，只能使用对应的包装类（Integer、Double等）。</p><p>泛型可以用于数组的引用类型声明，但<strong>不能直接创建泛型数组实例</strong>（如<code>new T[]</code>不合法）。</p><p>类型擦除机制：</p><p>Java 泛型采用<strong>类型擦除</strong>实现，泛型信息在编译后被擦除，泛型变量变为原始类型（通常是Object或边界类型）。</p><p>类型擦除意味着泛型的类型信息<strong>在运行时不可用</strong>，这限制了泛型在某些场景的应用（如无法创建泛型数组、无法进行类型判断等）。</p><p>不能直接创建泛型数组的原因：</p><p>泛型类型在运行时被擦除为原始类型，导致<strong>创建参数化类型的数组会产生类型安全隐患</strong>。</p><p>因此只能创建原始类型数组，或者创建Object数组再强制转换（不安全）。</p><p>但是，可以声明泛型数组的引用变量，如<code>List&lt;String&gt;[] array</code>是允许的。</p><div class="table-container"><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>类型参数</td><td>泛型只能是引用类型，不支持基本数据类型</td></tr><tr><td>类型擦除</td><td>编译后泛型类型被擦除为原始类型，运行时泛型信息不可用</td></tr><tr><td>适用范围</td><td>类、接口、方法均支持泛型</td></tr><tr><td>泛型数组</td><td>不能创建泛型数组实例，但可以声明泛型数组类型的变量</td></tr><tr><td>装箱与拆箱</td><td>基本类型通过包装类实现与泛型兼容</td></tr><tr><td>类型限制</td><td>支持上限（extends）、下限（super）</td></tr><tr><td>编译期检查</td><td>泛型提供静态类型安全保障，避免运行时类型错误</td></tr></tbody></table></div><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Java中所有异常和错误的基类是java.lang.Throwable。其中：</p><p>- Error和Exception都继承自Throwable<br>- RuntimeException是Exception的子类</p><p>java.lang.Throwable<br> ├── Error （系统错误，通常不捕获）<br> └── Exception<br>      ├── RuntimeException（非受检异常，不强制捕获）<br>      │    ├─ NullPointerException<br>      │    ├─ ClassCastException<br>      │    ├─ ArrayIndexOutOfBoundsException<br>      │    └─ ArithmeticException<br>      └── 受检异常（必须捕获或声明）<br>           ├─ IOException<br>           │    └─ FileNotFoundException<br>           └─ NoSuchMethodException</p><p>error:</p><p>代表JVM级别的错误或资源耗尽，如：</p><ul><li><code>StackOverflowError</code>（栈溢出）</li><li><code>OutOfMemoryError</code>（内存溢出）</li></ul><p>通常是严重错误，程序不应捕获，无法恢复。</p><p> Exception:</p><p>受检异常（Checked Exception）:</p><p>继承自<code>Exception</code>，但<strong>不继承</strong><code>RuntimeException</code>。</p><p>必须被显式处理：用<code>try-catch</code>捕获，或在方法签名中用<code>throws</code>声明。</p><p>通常表示<strong>程序外部问题</strong>，如文件I/O、网络错误等。</p><p>典型例子：</p><ul><li><code>IOException</code></li><li><code>FileNotFoundException</code>（<code>IOException</code>子类）</li><li><code>NoSuchMethodException</code></li></ul><p>编译器会检查这些异常的处理，确保程序健壮。</p><p>非受检异常（Unchecked Exception）:</p><ul><li><p>继承自<code>RuntimeException</code>。</p></li><li><p><strong>不强制处理</strong>，可选择捕获。</p></li><li><p>代表程序错误，如逻辑漏洞、编程错误。</p></li><li><p>常见异常：</p><ul><li><code>NullPointerException</code>：空指针访问</li><li><code>ArrayIndexOutOfBoundsException</code>：数组越界</li><li><code>ClassCastException</code>：类型转换异常</li><li><code>ArithmeticException</code>：算术异常（如除0）</li></ul></li></ul><div class="table-container"><table><thead><tr><th>异常类型</th><th>是否必须处理</th><th>典型示例</th><th>处理方式</th></tr></thead><tbody><tr><td>Error</td><td>不需要且不推荐</td><td>StackOverflowError, OutOfMemoryError</td><td>一般不捕获</td></tr><tr><td>受检异常</td><td>必须处理</td><td>IOException, FileNotFoundException</td><td>try-catch或throws声明</td></tr><tr><td>运行时异常</td><td>不强制必须处理</td><td>NullPointerException, ArrayIndexOutOfBoundsException</td><td>可捕获也可忽略，应该通过代码逻辑避免</td></tr></tbody></table></div><p><strong>异常处理顺序原则:</strong></p><p>“先具体后笼统”</p><p>多重catch语句应遵循<strong>“先具体异常后父类异常”</strong>原则。</p><p>例如，先捕获<code>FileNotFoundException</code>，再捕获<code>IOException</code>，最后捕获<code>Exception</code>。</p><p>否则，子类异常永远不会被捕获，造成编译错误。</p><div class="table-container"><table><thead><tr><th>误区描述</th><th>正确说明</th></tr></thead><tbody><tr><td><code>Error</code>可以被捕获且建议处理</td><td>虽然可以捕获，但通常不建议捕获，错误多为不可恢复的严重问题。</td></tr><tr><td>运行时异常必须用try-catch捕获</td><td>不必须，运行时异常不强制捕获，建议通过代码逻辑避免。</td></tr><tr><td>所有异常都继承自Exception</td><td>不对，Error和Exception都继承自Throwable。</td></tr><tr><td><code>FileNotFoundException</code>不是受检异常</td><td>错误，它是IOException子类，是受检异常。</td></tr><tr><td>多个catch的顺序无关紧要</td><td>错误，必须先捕获子类异常，再捕获父类异常。</td></tr></tbody></table></div><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合体系分为三大部分：</p><ul><li><strong>Collection 接口族</strong>：List、Set、Queue</li><li><strong>Map 接口族</strong>：HashMap、TreeMap、ConcurrentHashMap</li><li><strong>工具类</strong>：Collections、Arrays、Objects</li></ul><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>有序、可重复，支持按索引访问。</p><p><strong>ArrayList</strong></p><ul><li><strong>底层结构</strong>：动态数组（Object[]）</li><li><strong>是否线程安全</strong>：否（使用 <code>Collections.synchronizedList</code> 或 <code>CopyOnWriteArrayList</code>）</li><li><strong>访问快，插入删除慢</strong></li><li><strong>默认初始容量</strong>：10，扩容为原容量的 <strong>1.5 倍</strong></li></ul><p><strong>为什么 ArrayList 默认扩容机制是扩容为原数组的 1.5 倍？</strong></p><ul><li><p>ArrayList 的扩容机制是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 即1.5倍</span></span><br></pre></td></tr></table></figure></li><li><p><strong>兼顾性能与内存浪费的平衡</strong>：</p><ul><li>小扩容频繁迁移，效率低</li><li>大扩容浪费内存</li><li><strong>1.5 倍是经验权衡结果</strong>，比 Hashtable 的 2 倍更节省空间</li></ul></li><li><p><strong>适用场景</strong>：读多写少、频繁随机访问</p></li></ul><p><strong>写时复制机制（Copy-On-Write）</strong>：</p><ul><li>每次写操作（如 add、remove）会：<ul><li>复制当前数组</li><li>在新数组上修改</li><li>替换原数组引用</li></ul></li></ul><p>优点：</p><ul><li>读操作无需加锁，<strong>读写分离，读性能高</strong></li></ul><p>缺点：</p><ul><li>写操作开销大，不适合写多读少场景</li></ul><p><strong>LinkedList</strong></p><p>基于 <strong>双向链表</strong> 实现。在中间插入或删除元素只需要改变相邻节点的引用,<strong>操作开销是固定的。</strong></p><p>插入和删除操作效率高，<strong>适用于频繁插入/删除的场景</strong>。要访问任意位置的元素<strong>必须从头节点或尾节点遍历</strong>,不能像数组那样直接通过索引访问,因此不支持高效的随机访问。</p><p><strong>支持 null 和重复元素</strong>。</p><p>插入顺序即遍历顺序。</p><p><strong>访问元素性能不如 ArrayList</strong>（需要从头/尾遍历）。</p><p>实现了 <code>Deque</code> 接口，可作为队列或栈使用。</p><p><strong>不是线程安全的</strong>。</p><p><strong>Vector</strong></p><p>基于 <strong>数组实现的动态数组</strong>。</p><p><strong>线程安全</strong>，所有方法都用 <code>synchronized</code> 修饰。</p><p>线程安全导致性能较低，<strong>不推荐在新项目中使用</strong>，推荐使用 <code>ArrayList + 显式同步</code>。</p><p><strong>允许 null 和重复元素</strong>。</p><p><strong>是stack的父类</strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>hashset</strong></p><p>元素唯一，不允许重复。</p><p>ashSet是基于HashMap实现的无序集合,不保证元素的顺序</p><p><strong>不允许重复元素</strong>（根据 <code>equals()</code> 和 <code>hashCode()</code> 判断）。</p><p><strong>不保证元素顺序</strong>。</p><p><strong>允许 null 元素</strong>，最多一个。</p><p><strong>线程不安全</strong>。</p><p>HashSet作为Java集合框架中的一个重要实现类,通过<strong>hashCode()和equals()</strong>这两个方法的组合来确保元素的唯一性。这是因为HashSet<strong>内部实际使用HashMap来存储</strong>数据,其中<strong>元素的hashCode值用于确定存储位置,而equals方法则用于处理hash冲突时的比较。</strong></p><p>具体工作流程是:<br>\1. 当添加元素时,先调用hashCode()方法计算元素的哈希值<br>\2. 根据哈希值确定元素在HashSet中的存储位置<br>\3. 如果发生hash冲突,则调用equals()方法判断元素是否真正相等</p><p><strong>linkedHashSet</strong></p><p>LinkedHashSet在<strong>HashSet的基础上增加了一个双向链表</strong>来维护元素的插入顺序,因此是有序的。</p><p><strong>有序集合</strong>，迭代顺序为插入顺序。</p><p>插入、删除、查找操作时间复杂度仍为 <strong>O(1)</strong>。</p><p><strong>Treeset</strong></p><p>TreeMap基于<strong>红黑树</strong>实现,可以保证键的自然顺序或指定顺序</p><p>保证<strong>键的有序性</strong>：</p><ul><li>默认按键的 <strong>自然顺序（Comparable）</strong> 排序。</li><li>或使用构造函数传入的 <strong>Comparator</strong> 自定义排序。</li></ul><p><strong>键必须实现 Comparable 接口或提供 Comparator</strong>。</p><p>查询、插入、删除操作时间复杂度为 <strong>O(log n)</strong>。</p><p><strong>不允许 null 键</strong>（会抛 <code>NullPointerException</code>），但允许 null 值。</p><p><strong>线程不安全</strong>。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>键值对存储，key 唯一，value 可重复。</p><p><strong>Hashmap</strong></p><p><strong>底层结构</strong>：数组 + 链表（JDK 1.7）或数组 + 链表/红黑树（JDK 1.8+）</p><p><strong>默认初始容量</strong>：16，负载因子 0.75，扩容为原容量的 2 倍</p><p><strong>线程不安全</strong></p><p><strong>允许一个 null 键，多个 null 值</strong></p><p><strong>hash 冲突处理</strong>：链地址法，链表超过 8 转红黑树</p><p>HashMap的主要特点：<br>\1. <strong>允许null键和null值</strong><br>\2. <strong>不保证元素的顺序</strong><br>\3. 非线程安全<br>\4. 查找效率高,时间复杂度接近O(1)<br>\5. <strong>键必须是唯一的,而值可以重复</strong></p><p>HashMap中解决哈希冲突采用的是<strong>链地址法(拉链法)</strong>,而不是开放地址法</p><p>在HashMap的实现中,当<strong>多个key的哈希值映射到数组的同一个位置时</strong>,HashMap会在<strong>该位置构建一个链表</strong>(JDK1.8之后在链表长度超过8时会转换为红黑树)<strong>来存储所有映射到该位置的Entry</strong>。这种方式就是链地址法。</p><p>HashMap的底层确实使用<strong>Entry数组(在JDK1.8中改名为Node但本质相同)</strong>存储键值对。每个Entry包含key、value、next指针等信息。</p><p><strong>HashMap 的添加元素流程</strong></p><ol><li>计算 key 的 hash 值，定位数组索引</li><li>若该索引为空，直接插入节点</li><li>若存在冲突（哈希碰撞）：<ul><li>使用链表或红黑树进行存储</li></ul></li><li><p>添加元素后，判断是否超过阈值（<code>容量 × 负载因子</code>）：</p><ul><li>若超过，<strong>触发扩容</strong></li></ul><p><strong>HashMap 扩容加载因子为什么是 0.75？</strong></p></li></ol><p><strong>0.75 是经验值</strong>，在<strong>时间效率（查找速度）和空间利用率之间取得平衡</strong>。</p><p>太低会浪费内存，太高会增加哈希碰撞。</p><p> <strong>HashMap 扩容为什么扩容为数组长度的 2 倍？</strong></p><p>旧长度为 <code>n</code>，新长度为 <code>2n</code>：</p><ul><li>原 hash 值与新容量 <code>&amp;</code> 计算时，<strong>元素位置要么保持不变，要么移动到 <code>index + n</code></strong>。</li></ul><p>这样可以<strong>避免重新计算 hash，提高扩容效率</strong></p><p>hashmap并不是线程安全的，</p><p>多线程环境下使用：</p><ul><li><code>ConcurrentHashMap</code></li><li><code>Collections.synchronizedMap</code></li><li><p>自行加锁</p><p><strong>ConcurrentHashMap 的实现原理</strong></p></li></ul><p>DK 1.7：</p><ul><li><strong>Segment 分段锁机制</strong>（ReentrantLock）</li></ul><p>JDK 1.8：</p><ul><li><strong>CAS + synchronized 实现并发控制</strong></li><li>使用 <strong>链表 + 红黑树</strong> 解决冲突</li><li>核心结构：<ul><li>Node[] 数组 + 每个桶内链表或红黑树</li><li>高并发下比 Hashtable 更优</li></ul></li></ul><p>当在遍历<strong>HashMap</strong>的同时对其进行结构性修改(如删除元素)时,会抛出<strong>ConcurrentModificationException</strong>异常。代码会运行错误</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>` `<span class="keyword">static</span>` `<span class="keyword">void</span>` `main(String[] args) &#123;</span><br><span class="line">  ``Map&lt;Integer, String&gt; map = ``<span class="keyword">new</span>` `HashMap&lt;&gt;();</span><br><span class="line">  ``map.put(``<span class="number">1</span>``, ``<span class="string">&quot;A&quot;</span>``);</span><br><span class="line">  ``map.put(``<span class="number">2</span>``, ``<span class="string">&quot;B&quot;</span>``);</span><br><span class="line">  ``map.put(``<span class="number">3</span>``, ``<span class="string">&quot;C&quot;</span>``);</span><br><span class="line">  ``map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    ``<span class="keyword">if</span>` `(key == ``<span class="number">2</span>``) &#123;</span><br><span class="line">      ``map.remove(key);</span><br><span class="line">    ``&#125;</span><br><span class="line">  ``&#125;);</span><br><span class="line">  ``System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会抛出异常，运行错误</p><p>正确做法是：</p><p>正确做法之一是使用 <code>Iterator</code> 遍历并使用其 <code>remove()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey() == <span class="number">2</span>) &#123;</span><br><span class="line">        iterator.remove(); <span class="comment">// 安全删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>java.util.HashMap类是Java集合框架中实现键值对存储的主要类,它实现了Map接口,允许我们使用键值对(key-value pair)的形式来存储数据。HashMap使用<strong>哈希表的数据结构</strong>,每个元素都包含一个键和与之对应的值。</p><p><strong>LinkedHashMap</strong></p><p><strong>HashMap + 双向链表</strong></p><p><strong>维护插入顺序或访问顺序</strong></p><p><strong>常用于实现 LRU 缓存</strong></p><p><strong>TreeMap</strong></p><p><strong>底层结构</strong>：红黑树</p><p><strong>键排序（自然或自定义）</strong></p><p><strong>不允许 null 键，允许 null 值</strong></p><p><strong>线程不安全</strong></p><p><strong>Hashtable（过时）</strong></p><p>老版本的 Map 实现，<strong>线程安全</strong>，所有方法都被 <code>synchronized</code> 修饰。</p><p>不允许 <strong>null 键或 null 值</strong>。</p><p><strong>不保证顺序</strong>。</p><p>已被 <code>ConcurrentHashMap</code> 替代，在现代项目中已很少使用。</p><p><strong>ConcurrentHashMap</strong></p><p><strong>线程安全，替代 Hashtable</strong></p><p>JDK 1.7：Segment 分段锁（ReentrantLock）</p><p>JDK 1.8：<strong>CAS + synchronized + 分段数组</strong></p><p><strong>支持高并发读写操作</strong></p><p><strong>适合多线程环境</strong></p><h2 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h2><p>常用于并发</p><p>两者内部都使用 <strong><code>ReentrantLock</code></strong> 和 <strong><code>Condition</code></strong> 控制线程安全和阻塞操作。</p><p>它们都属于 <strong>阻塞队列（Blocking Queue）的一种实现</strong>，适用于多线程生产者-消费者模型。</p><p>两者构造方法中可以设置<strong>容量上限</strong>（有界）。</p><ul><li><code>new LinkedBlockingQueue&lt;&gt;(1000)</code> 限定最大容量为 1000。</li></ul><p>如果使用无参构造，默认容量是：<code>Integer.MAX_VALUE</code>，<strong>理论上无界</strong>。</p><p>所以 <strong>从默认行为看是无界的</strong>，但实际上 <strong>可以设置为有界队列</strong>。</p><p><strong>LinkedBlockingQueue</strong></p><ul><li><strong>阻塞队列，线程安全</strong></li><li><strong>基于链表结构</strong></li><li><strong>支持 FIFO（先进先出）操作</strong></li><li>插入满了会阻塞，移除空了也会阻塞</li><li><strong>常用于生产者-消费者模型</strong></li><li>支持一个方向的插入和移除（头出尾进）。</li></ul><p>使用 <strong><code>ReentrantLock</code></strong> 实现线程安全</p><p>使用两个锁：<strong>takeLock、putLock</strong>，避免入队和出队相互阻塞</p><p><strong>LinkedBlockingDeque</strong></p><p><strong>线程安全</strong></p><p><strong>基于链表结构</strong></p><p><strong>双端阻塞队列</strong>（支持两端操作）</p><p>既可以作为 <strong>队列（FIFO）</strong>，也可以作为 <strong>栈（LIFO）</strong> 使用</p><p>能实现 <strong>队列模型</strong>（tail add，head remove）</p><p>也能实现 <strong>栈模型</strong>（head add，head remove）</p><div class="table-container"><table><thead><tr><th>集合类型</th><th>线程安全方式</th></tr></thead><tbody><tr><td><code>Vector</code></td><td>synchronized</td></tr><tr><td><code>Hashtable</code></td><td>synchronized</td></tr><tr><td><code>Collections.synchronizedXXX</code></td><td>显式同步包装</td></tr><tr><td><code>CopyOnWriteArrayList</code></td><td>写时复制机制</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>CAS + synchronized</td></tr></tbody></table></div><h1 id="Io"><a href="#Io" class="headerlink" title="Io"></a>Io</h1><ul><li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<strong><em>字节流</em></strong>。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<strong><em>字符流</em></strong>。</p><p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p><p>同步IO是指，<strong>读写IO时代码必须等待数据返回后才继续执行后续代码</strong>，它的优点是代码编写简单，缺点是CPU执行效率低。</p><p>而异步IO是指，<strong>读写IO时仅发出请求，然后立刻执行后续代码</strong>，它的优点是CPU执行效率高，缺点是代码编写复杂。</p><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>要构造一个<code>File</code>对象，需要传入文件路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。</p><p>有盘符的是绝对路径，没盘符的是相对路径</p><p>File对象有3种形式表示的路径，一种是<code>getPath()</code>，返回构造方法传入的路径，一种是<code>getAbsolutePath()</code>，返回绝对路径，一种是<code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p><p>绝对路径可以表示成<code>C:\Windows\System32\..\notepad.exe</code>，而规范路径就是把<code>.</code>和<code>..</code>转换成标准的绝对路径后的路径：<code>C:\Windows\notepad.exe</code>。</p><p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p><p>有些时候，程序需要读写一些临时文件，File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p><p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream`并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是`int read()</span><br></pre></td></tr></table></figure><p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p><p><code>InputStream</code>和<code>OutputStream</code>都是通过<code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><p>注意在方法完成后一定要关闭流</p><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code></p><p><code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。能强制把缓冲区内容输出。</p><h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(inputStreamFromClassPath(<span class="string">&quot;/default.properties&quot;</span>));</span><br><span class="line">props.load(inputStreamFromFile(<span class="string">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure><p>读取配置文件，但是这个之后就被Spring取代了吧哈哈</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p><p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p>除了特殊的<strong><code>CharArrayReader</code>和<code>StringReader</code></strong>，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p><p>既然<code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器，那么，如果我们已经有一个<code>InputStream</code>，想把它转换为<code>Reader</code>，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何<code>InputStream</code>转换为<code>Reader</code>。</p><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p><code>Writer</code>是基于<code>OutputStream</code>构造的，可以通过<code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code>，转换时需要指定编码。</p><h2 id="printstream"><a href="#printstream" class="headerlink" title="printstream"></a>printstream</h2><p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p><ul><li>写入<code>int</code>：<code>print(int)</code></li><li>写入<code>boolean</code>：<code>print(boolean)</code></li><li>写入<code>String</code>：<code>print(String)</code></li><li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/19/javase/javase1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试题目hot1基础</title>
      <link>https://blog.tokenlen.top/2025/05/19/javase/javase2/</link>
      <guid>https://blog.tokenlen.top/2025/05/19/javase/javase2/</guid>
      <pubDate>Sun, 18 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础面试题目&quot;&gt;&lt;a href=&quot;#基础面试题目&quot; class=&quot;headerlink&quot; title=&quot;基础面试题目&quot;&gt;&lt;/a&gt;基础面试题目&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础面试题目"><a href="#基础面试题目" class="headerlink" title="基础面试题目"></a>基础面试题目</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="1-说一下Java的特点"><a href="#1-说一下Java的特点" class="headerlink" title="1.说一下Java的特点"></a>1.说一下Java的特点</h3><p><strong>平台无关性</strong>：Java的编写一次，运无不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。<br><strong>面向对象</strong>：JaVa是一严格的面可对象编程语言，几乎一切都是对象。面可对象编程（OOP）特性使得代码更易于维护和重用，包括类（class）、对象（object）、继承（inheritance）、多态　(polymorphism）、抽象（abstraction）和封装（encapsulation）。<br><strong>内存管理</strong>：JaVa有目己的垃圾回收机制，目动管理内存和回收不再使用的对象。这样，开发者不需要手动管埋内存，从而减少内存泄漏和其他内存相关的问题。</p><h3 id="2-Java-的优势和劣势是什么？"><a href="#2-Java-的优势和劣势是什么？" class="headerlink" title="2.Java 的优势和劣势是什么？"></a>2.Java 的优势和劣势是什么？</h3><p>首先，Java的优势，我记得<strong>跨平台</strong>应该是一个大点，因为<strong>JVM</strong>的存在，一次编写到处运行。然后<strong>面向对象</strong>，这个可能也是优势，不过现在很多语言都支持面向对象，但是Java的设计从一开始就是OOP的。还有<strong>强大的生态系统</strong>，比如Spring框架，Hibernate，各种库和工具，社区支持大，企业应用广泛。另外，<strong>内存管理方面</strong>，自动垃圾回收机制，减少了内存泄漏的问题，对开发者友好。<strong>还有多线程支持</strong>，内置的线程机制，方便并发编程。安全性方面，<strong>Java有安全模型</strong>，比如沙箱机制，适合网络环境。还有稳定性，企业级应用长期使用，版本更新也比较注重向后兼容。</p><p>劣势的话，<strong>性能</strong>可能是一个，虽然JVM优化了很多，但相比C++或者Rust这种原生编译语言，还是有一定开销。<strong>特别是启动时间</strong>，比如微服务场景下，可能不如Go之类的快。语法繁琐，比如样板代码多，之前没有lambda的时候更麻烦，现在有了但比起Python还是<strong>不够简洁</strong>。内存消耗，<strong>JVM本身占内存，对于资源有限的环境可能不太友好</strong>。<strong>还有面向对象过于严格</strong>，有时候写简单程序反而麻烦，虽然Java8引入了函数式编程，但不如其他语言自然。还有开发效率，相比动态语言如Python，<strong>Java需要更多代码，编译过程也可能拖慢开发节奏。</strong></p><h3 id="3-Java为什么是跨平台的？"><a href="#3-Java为什么是跨平台的？" class="headerlink" title="3.Java为什么是跨平台的？"></a>3.Java为什么是跨平台的？</h3><p> Java 能支持跨平台，主要依赖于 <strong>JVM</strong> 关系比较大。</p><p><strong>JVM也是一个软件，不同的平台有不同的版本</strong>。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。<strong>Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。</strong>也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p><p>JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。</p><p>编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</p><p>所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。</p><h3 id="4-JVM、JDK、JRE三者关系？"><a href="#4-JVM、JDK、JRE三者关系？" class="headerlink" title="4.JVM、JDK、JRE三者关系？"></a>4.JVM、JDK、JRE三者关系？</h3><ul><li><strong>JVM</strong>是Java虚拟机，<strong>是Java程序运行的环境</strong>。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li><li><strong>JDK</strong>是Java开发工具包，<strong>是开发Java程序所需的工具集合</strong>。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。<strong>JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</strong></li><li><strong>JRE</strong>是Java运行时环境，<strong>是Java程序运行所需的最小环境</strong>。它包含了JVM和一组Java类库，用于支持Java程序的执行。<strong>JRE不包含开发工具，只提供Java程序运行所需的运行环境。</strong></li></ul><h3 id="5-为什么Java解释和编译都有？"><a href="#5-为什么Java解释和编译都有？" class="headerlink" title="5.为什么Java解释和编译都有？"></a>5.为什么Java解释和编译都有？</h3><p>首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt=""></p><p><strong>编译性</strong>：</p><ul><li>Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。</li></ul><p><strong>解释性：</strong></p><ul><li>JVM中一个<strong>方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。</strong>否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。</li></ul><p>所以Java既是<strong>编译型也是解释性语言</strong>，默认采用的是解释器和编译器混合的模式。</p><h3 id="6-jvm是什么"><a href="#6-jvm是什么" class="headerlink" title="6.jvm是什么"></a>6.jvm是什么</h3><p>JVM是 <strong>java 虚拟机</strong>，主要工作是<strong>解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。</strong></p><p>JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“<strong>一次编译，到处运行的</strong>”原因。</p><h3 id="7-编译型语言和解释型语言的区别？"><a href="#7-编译型语言和解释型语言的区别？" class="headerlink" title="7.编译型语言和解释型语言的区别？"></a>7.<strong>编译型语言和解释型语言的区别？</strong></h3><p>编译型语言和解释型语言的区别在于：</p><ul><li>编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接<strong>运行编译后的代码，速度快，但跨平台性较差</strong>。</li><li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由<strong>解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。</strong></li><li>典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="1-八种基本的数据类型"><a href="#1-八种基本的数据类型" class="headerlink" title="1.八种基本的数据类型"></a>1.八种基本的数据类型</h3><p>Java支持数据类型分为两类： 基本数据类型和引用数据类型。</p><p>基本数据类型共有8种，可以分为三类：</p><ul><li>数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</li><li>字符型：char</li><li>布尔型：boolean</li></ul><p>8种基本数据类型的默认值、位数、取值范围，如下表所示：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>占用大小（字节）</th><th>位数</th><th>取值范围</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1</td><td>8</td><td>-128（-2^7） 到 127（2^7 - 1）</td><td>0</td><td>是最小的整数类型，适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据。</td></tr><tr><td><code>short</code></td><td>2</td><td>16</td><td>-32768（-2^15） 到 32767（2^15 - 1）</td><td>0</td><td>较少使用，通常用于在需要节省内存且数值范围在该区间的场景。</td></tr><tr><td><code>int</code></td><td>4</td><td>32</td><td>-2147483648（-2^31） 到 2147483647（2^31 - 1）</td><td>0</td><td>最常用的整数类型，可满足大多数日常编程中整数计算的需求。</td></tr><tr><td><code>long</code></td><td>8</td><td>64</td><td>-9223372036854775808（-2^63） 到 9223372036854775807（2^63 - 1）</td><td>0L</td><td>用于表示非常大的整数，当 <code>int</code> 类型无法满足需求时使用，定义时数值后需加 <code>L</code> 或 <code>l</code>。</td></tr><tr><td><code>float</code></td><td>4</td><td>32</td><td>1.4E - 45 到 3.4028235E38</td><td>0.0f</td><td>单精度浮点数，用于表示小数，精度相对较低，定义时数值后需加 <code>F</code> 或 <code>f</code>。</td></tr><tr><td><code>double</code></td><td>8</td><td>64</td><td>4.9E - 324 到 1.7976931348623157E308</td><td>0.0d</td><td>双精度浮点数，精度比 <code>float</code> 高，是 Java 中表示小数的默认类型。</td></tr><tr><td><code>char</code></td><td>2</td><td>16</td><td>‘\u0000’（0） 到 ‘\uffff’（65535）</td><td>‘\u0000’</td><td>用于表示单个字符，采用 Unicode 编码，可表示各种语言的字符。</td></tr><tr><td><code>boolean</code></td><td>无明确字节大小（理论上 1 位）</td><td>无明确位数</td><td><code>true</code> 或 <code>false</code></td><td><code>false</code></td><td>用于逻辑判断，只有两个取值，常用于条件判断和循环控制等逻辑场景。</td></tr></tbody></table></div><ul><li>Java八种基本数据类型的字节数：1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)</li><li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）</li><li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li><li>八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写</li><li>char类型是无符号的，不能为负，所以是0开始的</li></ul><h3 id="2-int和long是多少位，多少字节的？"><a href="#2-int和long是多少位，多少字节的？" class="headerlink" title="2.int和long是多少位，多少字节的？"></a>2.int和long是多少位，多少字节的？</h3><ul><li><code>int</code>类型是 <strong>32 位（bit），占 4 个字节（byte）</strong>，int 是有符号整数类型，其取值范围是从 <strong>-2^31 到 2^31-1</strong> 。例如，在一个简单的计数器程序中，如果使用<code>int</code>类型来存储计数值，它可以表示的最大正数是 <strong>2,147,483,647</strong>。如果计数值超过这个范围，就会发生溢出，导致结果不符合预期。</li><li><code>long</code>类型是 <strong>64 位，占 8 个字节</strong>，<code>long</code>类型也是有符号整数类型，它的取值范围是从 <strong>-2^63 到 2^63 -1</strong> ，在处理较大的整数数值时，果<code>int</code>类型的取值范围不够，就需要使用<code>long</code>类型。例如，在一个文件传输程序中，文件的大小可能会很大，使用<code>int</code>类型可能无法准确表示，而<code>long</code>类型就可以很好地处理这种情况。</li></ul><h3 id="3-long和int可以互转吗-？"><a href="#3-long和int可以互转吗-？" class="headerlink" title="3.long和int可以互转吗 ？"></a>3.long和int可以互转吗 ？</h3><p>可以的，Java中的<code>long</code>和<code>int</code>可以相互转换。由于<code>long</code>类型的范围比<code>int</code>类型大，因此将<code>int</code>转换为<code>long</code>是安全的，而将<code>long</code>转换为<code>int</code>可能会导致数据丢失或溢出。</p><p>将<code>int</code>转换为<code>long</code>可以通过<strong>直接赋值或强制类型转换</strong>来实现。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int intValue = 10;</span><br><span class="line">long longValue = intValue; // 自动转换，安全的</span><br></pre></td></tr></table></figure><p>将<code>long</code>转换为<code>int</code>需要使用<strong>强制类型转换</strong>，但需要注意潜在的数据丢失或溢出问题。</p><p>在将<code>long</code>转换为<code>int</code>时，如果<code>longValue</code>的值超出了<code>int</code>类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查<code>longValue</code>的值是否在<code>int</code>类型的范围内，以避免数据丢失或溢出的问题。</p><p><strong>低-&gt;高直接转</strong></p><h3 id="4-数据类型转换方式你知道哪些？"><a href="#4-数据类型转换方式你知道哪些？" class="headerlink" title="4.数据类型转换方式你知道哪些？"></a>4.数据类型转换方式你知道哪些？</h3><ul><li><strong>自动类型转换（隐式转换）</strong>：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将<code>int</code>转换为<code>long</code>、将<code>float</code>转换为<code>double</code>等。</li><li><strong>强制类型转换（显式转换）</strong>：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将<code>long</code>转换为<code>int</code>、将<code>double</code>转换为<code>int</code>等。语法为：目标类型 变量名 = (目标类型) 源类型。</li><li>字符串转换：<strong>Java提供了将字符串表示的数据转换为其他类型数据的方法</strong>。例如，将字符串转换为整型<code>int</code>，可以使用<code>Integer.parseInt()</code>方法；将字符串转换为浮点型<code>double</code>，可以使用<code>Double.parseDouble()</code>方法等。</li><li>数值之间的转换：<strong>Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。</strong>这些转换方式可以通过类型的包装类来实现，例如<code>Character</code>类、<code>Integer</code>类等提供了相应的转换方法。</li></ul><h3 id="5-类型互转会出现什么问题吗？"><a href="#5-类型互转会出现什么问题吗？" class="headerlink" title="5.类型互转会出现什么问题吗？"></a>5.类型互转会出现什么问题吗？</h3><ul><li>数据丢失：当将<strong>一个范围较大的数据类型转换为一个范围较小的数据类型时</strong>，可能会发生数据丢失。例如，将一个<code>long</code>类型的值转换为<code>int</code>类型时，如果<code>long</code>值超出了<code>int</code>类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。</li><li>数据溢出：与数据丢失相反，<strong>当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。</strong>例如，将一个<code>int</code>类型的值转换为<code>long</code>类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。</li><li>精度损失：<strong>在进行浮点数类型的转换时，可能会发生精度损失。</strong>由于浮点数的表示方式不同，将一个单精度浮点数(<code>float</code>)转换为双精度浮点数(<code>double</code>)时，精度可能会损失。</li><li>类型不匹配导致的错误：在进行类型转换时，<strong>需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误。</strong></li></ul><h3 id="6-为什么用bigDecimal-不用double-？"><a href="#6-为什么用bigDecimal-不用double-？" class="headerlink" title="6.为什么用bigDecimal 不用double ？"></a>6.为什么用bigDecimal 不用double ？</h3><p>double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1/3(1/3=0.3333…)，也就是说二进制表示小数的时候只能够表示能够用1/(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1/(2^n)的和的形式。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.05</span> + <span class="number">0.01</span>);</span><br><span class="line">System.out.println(<span class="number">1.0</span> - <span class="number">0.42</span>);</span><br><span class="line">System.out.println(<span class="number">4.015</span> * <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="number">123.3</span> / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0.060000000000000005</span></span><br><span class="line"><span class="number">0.5800000000000001</span></span><br><span class="line"><span class="number">401.49999999999994</span></span><br><span class="line"><span class="number">1.2329999999999999</span></span><br></pre></td></tr></table></figure><p>可以看到在<strong>Java中进行浮点数运算的时候，会出现丢失精度的问题。</strong>那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。</p><p><strong>而 Decimal 是精确计算 , 所以一般牵扯到金钱的计算 , 都使用 Decimal。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">sum</span> <span class="operator">=</span> num1.add(num2);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">product</span> <span class="operator">=</span> num1.multiply(num2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Sum: <span class="number">0.3</span></span><br><span class="line">Product: <span class="number">0.02</span></span><br></pre></td></tr></table></figure><p>这样的使用<code>BigDecimal</code>可以确保精确的十进制数值计算，避免了使用<code>double</code>可能出现的舍入误差。需要注意的是，在创建<code>BigDecimal</code>对象时，应该使用<strong>字符串作为参数</strong>，而不是直接使用浮点数值，以避免浮点数精度丢失。</p><h3 id="7-装箱和拆箱是什么？"><a href="#7-装箱和拆箱是什么？" class="headerlink" title="7.装箱和拆箱是什么？"></a>7.装箱和拆箱是什么？</h3><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。</p><p>自动装箱主要发生在两种情况，<strong>一种是赋值时，另一种是在方法调用的时候。</strong></p><blockquote><p>赋值时</p></blockquote><p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before autoboxing</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iObject</span> <span class="operator">=</span> Integer.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="type">Int</span> <span class="variable">iPrimitive</span> <span class="operator">=</span> iObject.intValue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//after java5</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">iObject</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//autobxing - primitive to wrapper conversion</span></span><br><span class="line"><span class="type">int</span> <span class="variable">iPrimitive</span> <span class="operator">=</span> iObject; <span class="comment">//unboxing - object to primitive conversion</span></span><br></pre></td></tr></table></figure><blockquote><p>方法调用时</p></blockquote><p>当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;autoboxing example - method invocation i: &quot;</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure><p>show方法接受Integer对象作为参数，当调用<code>show(3)</code>时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而<code>int result = show(3);</code>中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。</p><p>自动装箱有一个问题，<strong>那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;   sum+=i; &#125; </span><br></pre></td></tr></table></figure><p>上面的代码<code>sum+=i</code>可以看成<code>sum = sum + i</code>，但是<code>+</code>这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i; <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result); </span><br></pre></td></tr></table></figure><p>由于我们这里声明的sum为Integer类型，<strong>在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。</strong>因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p><h3 id="8-Java为什么要有Integer？"><a href="#8-Java为什么要有Integer？" class="headerlink" title="8.Java为什么要有Integer？"></a>8.Java为什么要有Integer？</h3><p>Integer对应是int类型的包装类，就是把int类型包装成Object对象，<strong>对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起</strong>，比如Integer就有parseInt()等方法来专门处理int型相关的数据。</p><p>另一个非常重要的原因就是在<strong>Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，</strong>也就是Integer才能被List所接受。所以Integer的存在是很必要的。</p><p>在Java中，<strong>泛型只能使用引用类型</strong>，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。</p><p>在Java中，<strong>基本类型和引用类型不能直接进行转换，必须使用包装类来实现。</strong>例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。</p><p>Java<strong>集合中只能存储对象，而不能存储基本数据类型。</strong>因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。</p><h3 id="9-Integer相比int有什么优点？"><a href="#9-Integer相比int有什么优点？" class="headerlink" title="9.Integer相比int有什么优点？"></a>9.Integer相比int有什么优点？</h3><p>int是Java中的原始数据类型，而Integer是int的包装类。</p><p>Integer和 int 的区别：</p><ul><li>基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，<strong>它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。</strong>这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，<strong>基本数据类型的操作通常比相应的引用类型快。</strong></li><li>自动装箱和拆箱：其次，Integer作为int的包装类，<strong>它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。</strong>这使得Java程序员<strong>更加方便地进行数据类型转换。</strong>例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。</li><li>空指针异常：另外，<strong>int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。</strong>如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了<strong>null值</strong>，而null值是无法进行自动拆箱的。</li></ul><h3 id="10-那为什么还要保留int类型？"><a href="#10-那为什么还要保留int类型？" class="headerlink" title="10.那为什么还要保留int类型？"></a>10.那为什么还要保留int类型？</h3><p>包装类是引用类型，对象的引用和对象本身是分开存储的，<strong>而对于基本类型数据，变量对应的内存块直接存储数据本身。</strong></p><p>因此，基本类型数据在<strong>读写效率方面，要比包装类高效</strong>。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。</p><p>也就是说，<strong>不管是读写效率，还是存储效率，基本类型都比包装类高效。</strong></p><h3 id="11-说一下-integer的缓存"><a href="#11-说一下-integer的缓存" class="headerlink" title="11.说一下 integer的缓存"></a>11.说一下 integer的缓存</h3><p>Java的Integer类内部实现了一个<strong>静态缓存池</strong>，用于存储特定范围内的整数值对应的Integer对象。</p><p>默认情况下，<strong>这个范围是-128至127。</strong>当通过<strong>Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。</strong></p><p>但是你new的话就是一个新的对象了。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-怎么理解面向对象？简单说说封装继承多态"><a href="#1-怎么理解面向对象？简单说说封装继承多态" class="headerlink" title="1.怎么理解面向对象？简单说说封装继承多态"></a>1.怎么理解面向对象？简单说说封装继承多态</h2><p>面向对象是一种编程范式，它<strong>将现实世界中的事物抽象为对象</strong>，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。</p><p>Java面向对象的三大特性包括：<strong>封装、继承、多态</strong>：</p><ul><li><strong>封装</strong>：封装是指将对象的<strong>属性（数据）和行为（方法）结合在一起</strong>，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。<strong>封装的目的是增强安全性和简化编程，使得对象更加独立。</strong></li><li><strong>继承</strong>：继承是一种可以使得<strong>子类自动共享父类数据结构和方法的机制</strong>。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。</li><li><strong>多态</strong>：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为<strong>编译时多态（重载）和运行时多态（重写）</strong>。它使得程序具有良好的灵活性和扩展性。</li></ul><h2 id="2-多态体现在哪几个方面？"><a href="#2-多态体现在哪几个方面？" class="headerlink" title="2.多态体现在哪几个方面？"></a>2.多态体现在哪几个方面？</h2><p>多态在面向对象编程中可以体现在以下几个方面：</p><ul><li>方法重载：<ul><li>方法重载是指同一类中可以有<strong>多个同名方法，它们具有不同的参数列表</strong>（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。</li><li>示例：对于一个 <code>add</code> 方法，可以定义为 <code>add(int a, int b)</code> 和 <code>add(double a, double b)</code>。</li></ul></li><li>方法重写：<ul><li>方法重写是<strong>指子类能够提供对父类中同名方法的具体实现</strong>。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。</li><li>示例：在一个动物类中，定义一个 <code>sound</code> 方法，子类 <code>Dog</code> 可以重写该方法以实现 <code>bark</code>，而 <code>Cat</code> 可以实现 <code>meow</code>。</li></ul></li><li>接口与实现：<ul><li>多态也体现在接口的使用上，<strong>多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。</strong></li><li>示例：多个类（如 <code>Dog</code>, <code>Cat</code>）都实现了一个 <code>Animal</code> 接口，当用 <code>Animal</code> 类型的引用来调用 <code>makeSound</code> 方法时，会触发对应的实现。</li></ul></li><li>向上转型和向下转型：<ul><li>在Java中，<strong>可以使用父类类型的引用指向子类对象，这是向上转型。</strong>通过这种方式，可以在运行时期采用不同的子类实现。</li><li>向下转型是将<strong>父类引用转回其子类类型</strong>，但在执行前需要确认引用实际指向的对象类型以避免 <code>ClassCastException</code>。</li></ul></li></ul><h2 id="3-多态解决了什么问题？"><a href="#3-多态解决了什么问题？" class="headerlink" title="3.多态解决了什么问题？"></a>3.多态解决了什么问题？</h2><p>多态是<strong>指子类可以替换父类，</strong>在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，<strong>比如继承、接口类</strong>。</p><p><strong>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</strong>比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等</p><h2 id="4-面向对象的设计原则你知道有哪些吗"><a href="#4-面向对象的设计原则你知道有哪些吗" class="headerlink" title="4.面向对象的设计原则你知道有哪些吗"></a>4.面向对象的设计原则你知道有哪些吗</h2><p>面向对象编程中的六大原则：</p><ul><li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li><li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li><li><strong>里氏替换原则（LSP）</strong>：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li><li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li><li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。</li><li><strong>最少知识原则 (Law of Demeter)</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。</li></ul><h2 id="5-重载与重写有什么区别？"><a href="#5-重载与重写有什么区别？" class="headerlink" title="5.重载与重写有什么区别？"></a>5.重载与重写有什么区别？</h2><ul><li>重载（Overloading）指的是在<strong>同一个类中，可以有多个同名方法，它们具有不同的参数列表</strong>（参数类型、参数个数或参数顺序不同），编译器根据调用时的参数类型来决定调用哪个方法。</li><li>重写（Overriding）指的是<strong>子类可以重新定义父类中的方法，</strong>方法名、参数列表和返回类型必须与父类中的方法一致，通过<strong>@override</strong>注解来明确表示这是对父类方法的重写。</li></ul><p>重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。</p><h2 id="6-抽象类和普通类区别？"><a href="#6-抽象类和普通类区别？" class="headerlink" title="6.抽象类和普通类区别？"></a>6.抽象类和普通类区别？</h2><ul><li>实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。</li><li>方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。</li><li>继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。</li><li>实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。</li></ul><h2 id="7-Java抽象类和接口的区别是什么？"><a href="#7-Java抽象类和接口的区别是什么？" class="headerlink" title="7.Java抽象类和接口的区别是什么？"></a>7.Java抽象类和接口的区别是什么？</h2><p><strong>两者的特点：</strong></p><ul><li>抽象类用于<strong>描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。</strong>适用于有明显<strong>继承</strong>关系的场景。</li><li>接口用于定义行为规范，可以多实现，<strong>只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。</strong>适用于定义类的能力或功能。</li></ul><p><strong>两者的区别：</strong></p><ul><li>实现方式：实现接口的关键字为<strong>implements</strong>，继承抽象类的关键字为<strong>extends</strong>。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li>方法方式：<strong>接口只有定义，不能有方法的实现</strong>，java 1.8中可以定义default方法体，而抽<strong>象类可以有定义与实现，方法可在抽象类中实现。</strong></li><li>访问修饰符：<strong>接口成员变量默认为public static final</strong>，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。<strong>抽象类中成员变量默认default</strong>，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li><li>变量：<strong>抽象类可以包含实例变量和静态变量，而接口只能包含常量（</strong>即静态常量）。</li></ul><h2 id="8-抽象类能加final修饰吗？"><a href="#8-抽象类能加final修饰吗？" class="headerlink" title="8.抽象类能加final修饰吗？"></a>8.抽象类能加final修饰吗？</h2><p><strong>不能</strong>，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。</p><h2 id="9-接口里面可以定义哪些方法？"><a href="#9-接口里面可以定义哪些方法？" class="headerlink" title="9.接口里面可以定义哪些方法？"></a>9.接口里面可以定义哪些方法？</h2><ul><li><strong>抽象方法</strong></li></ul><p>抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>默认方法</strong></li></ul><p>默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>静态方法</strong></li></ul><p>静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>私有方法</strong></li></ul><p>私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-抽象类可以被实例化吗？"><a href="#10-抽象类可以被实例化吗？" class="headerlink" title="10.抽象类可以被实例化吗？"></a>10.抽象类可以被实例化吗？</h2><p>在Java中，抽象类本身不能被实例化。</p><p>这意味着不能使用<code>new</code>关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由<code>abstract</code>关键字修饰且无方法体的方法），这些方法需要在子类中被实现。</p><p><strong>抽象类可以有构造器，他可以有构造方法，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。</strong>然而，这个过程并不是直接实例化抽象类，<strong>而是创建了子类的实例，间接地使用了抽象类的构造器。</strong></p><p>简而言之，抽象类不能直接实例化，但通过继承抽象类并实现所有抽象方法的子类是可以被实例化的。</p><h2 id="11-接口可以包含构造函数吗？"><a href="#11-接口可以包含构造函数吗？" class="headerlink" title="11.接口可以包含构造函数吗？"></a>11.接口可以包含构造函数吗？</h2><p><strong>在接口中，不可以有构造方法</strong>,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。</p><p>为什么呢？构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用，那么问题来了Java的接口，都不能new 那么要构造函数干嘛呢？根本就没法调用</p><h2 id="12-解释Java中的静态变量和静态方法"><a href="#12-解释Java中的静态变量和静态方法" class="headerlink" title="12.解释Java中的静态变量和静态方法"></a>12.解释Java中的静态变量和静态方法</h2><p>在Java中，<strong>静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。</strong></p><blockquote><p>静态变量</p></blockquote><p>静态变量（也称为类变量）是在类中使用<code>static</code>关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：</p><ul><li><strong>共享性</strong>：<strong>所有该类的实例共享同一个静态变量</strong>。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</li><li><strong>初始化</strong>：<strong>静态变量在类被加载时初始化，只会对其进行一次分配内存。</strong></li><li><strong>访问方式</strong>：静态变量可以直接通过<strong>类名访问</strong>，也可以通过实例访问，但推荐使用类名。</li></ul><blockquote><p>静态方法</p></blockquote><p>静态方法是在类中使用<code>static</code>关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：</p><ul><li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。<strong>对于静态方法来说，不能直接访问非静态的成员变量或方法</strong>，因为静态方法没有上下文的实例。</li><li><strong>访问静态成员</strong>：静态方法<strong>可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</strong></li><li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）。</li></ul><h2 id="13-非静态内部类和静态内部类的区别？"><a href="#13-非静态内部类和静态内部类的区别？" class="headerlink" title="13.非静态内部类和静态内部类的区别？"></a>13.非静态内部类和静态内部类的区别？</h2><p>区别包括：</p><ul><li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。</li><li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。</li><li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。</li><li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。</li><li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。</li></ul><p>总结来说<strong>一内一外</strong></p><h2 id="14-非静态内部类可以直接访问外部方法，编译器是怎么做到的？"><a href="#14-非静态内部类可以直接访问外部方法，编译器是怎么做到的？" class="headerlink" title="14.非静态内部类可以直接访问外部方法，编译器是怎么做到的？"></a>14.非静态内部类可以直接访问外部方法，编译器是怎么做到的？</h2><p>非静态内部类可以直接访问外部方法是因为<strong>编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</strong></p><p>这个引用使得非静态内部类能够访问外部类的实例变量和方法。<strong>编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</strong></p><h1 id="关键词-amp-泛型-amp-反射"><a href="#关键词-amp-泛型-amp-反射" class="headerlink" title="关键词&amp;泛型&amp;反射"></a>关键词&amp;泛型&amp;反射</h1><h2 id="1-Java-中-final-作用是什么？"><a href="#1-Java-中-final-作用是什么？" class="headerlink" title="1.Java 中 final 作用是什么？"></a>1.Java 中 final 作用是什么？</h2><p><code>final</code>关键字主要有以下三个方面的作用：用于修饰类、方法和变量。</p><ul><li>修饰类：当<code>final</code>修饰一个类时，<strong>表示这个类不能被继承</strong>，是类继承体系中的最终形态。例如，Java 中的<code>String</code>类就是用<code>final</code>修饰的，这保证了<code>String</code>类的不可变性和安全性，防止其他类通过继承来改变<code>String</code>类的行为和特性。</li><li>修饰方法：<strong>用<code>final</code>修饰的方法不能在子类中被重写</strong>。比如，<code>java.lang.Object</code>类中的<code>getClass</code>方法就是<code>final</code>的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。</li><li>修饰变量：<strong>当<code>final</code>修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。</strong>例如，<code>final int num = 10;</code>，这里的<code>num</code>就是一个常量，不能再对其进行重新赋值操作，否则会导致编译错误。<strong>对于引用数据类型，<code>final</code>修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。</strong>例如，<code>final StringBuilder sb = new StringBuilder(&quot;Hello&quot;);</code>，不能让<code>sb</code>再指向其他<code>StringBuilder</code>对象，但可以通过<code>sb.append(&quot; World&quot;);</code>来修改字符串的内容。</li></ul><h2 id="2-什么是泛型？"><a href="#2-什么是泛型？" class="headerlink" title="2.什么是泛型？"></a>2.什么是泛型？</h2><p>泛型是 Java 编程语言中的一个重要特性，<strong>它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</strong></p><p>泛型的主要目的是<strong>在编译时提供更强的类型检查，并且在编译后能够保留类型信息，</strong>避免了在运行时出现类型转换异常。</p><blockquote><p>为什么需要泛型？</p></blockquote><ul><li><strong>适用于多种数据类型执行相同的代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li></ul><p>看下这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，<strong>且很容易出现java.lang.ClassCastException异常。</strong></p><p>引入泛型，它将提供类型的约束，<strong>提供编译前的检查：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure><p>好处：</p><p><strong>编译期类型检查</strong>，提升代码安全性，防止运行时类型转换异常（ClassCastException）。编译时会自动装箱拆箱来配合基本类型的包装类。</p><p><strong>避免强制类型转换</strong>，代码更简洁清晰。</p><p><strong>提高代码复用性</strong>，同一份代码可以处理不同类型的数据。</p><p>他只能使用包装类，不能用于基本的数据类型</p><p>Java 泛型采用<strong>类型擦除</strong>实现，泛型信息在编译后被擦除，泛型变量变为原始类型（通常是Object或边界类型）。</p><p>运行的时候是不能使用的，比如不能创建泛型数组，无法进行类型判断等</p><h2 id="3-什么是反射"><a href="#3-什么是反射" class="headerlink" title="3.什么是反射"></a>3.什么是反射</h2><p>Java 反射机制是<strong>在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；</strong>这种<strong>动态获取</strong>的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><p>反射具有以下特性：</p><ol><li><strong>运行时类信息访问</strong>：反射机制允许程序在<strong>运行时获取类的完整结构信息</strong>，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</li><li><strong>动态对象创建</strong>：可以使用<strong>反射API动态地创建对象实例</strong>，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。</li><li><strong>动态方法调用</strong>：可以在<strong>运行时动态地调用对象的方法</strong>，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</li><li><strong>访问和修改字段值</strong>：反射还允许<strong>程序在运行时访问和修改对象的字段值</strong>，即使是私有的。这是通过Field类的get()和set()方法完成的。</li></ol><p>使用实例：</p><blockquote><p>加载数据库驱动</p></blockquote><p>我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。</p><p>这时候我们在使用 <strong>JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，</strong>如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>配置文件加载</p></blockquote><p>Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p><p>Spring通过XML配置模式装载Bean的过程：</p><ul><li>将程序中所有XML或properties配置文件加载入内存</li><li>Java类里面<strong>解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</strong></li><li>使用反射机制，根据这个字符串获得<strong>某个类的Class实例</strong></li><li>动态配置实例的属性</li></ul><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=com.example.reflectdemo.TestInvoke</span><br><span class="line">methodName=printlnState</span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析配置文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\IdeaProjects\AllDemos\language-specification\src\main\resources\application.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException &#123;</span><br><span class="line">    <span class="comment">// 使用反射机制，根据这个字符串获得Class对象</span></span><br><span class="line">    Class&lt;?&gt; c = Class.forName(getName(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">    System.out.println(c.getSimpleName());</span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getDeclaredMethod(getName(<span class="string">&quot;methodName&quot;</span>));</span><br><span class="line">    <span class="comment">// 绕过安全检查</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="type">TestInvoke</span> <span class="variable">testInvoke</span> <span class="operator">=</span> (TestInvoke)c.newInstance();</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    method.invoke(testInvoke);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>判断对象所属类</strong>：<code>obj.getClass()</code> 获取对象的 Class 对象。</li><li><strong>加载类</strong>：<code>Class.forName(&quot;全类名&quot;)</code> 动态加载类。</li><li><strong>获取构造器并实例化对象</strong>：<code>clazz.getConstructor(...)</code> + <code>constructor.newInstance(...)</code></li><li><strong>访问类的成员变量和方法</strong>：<code>clazz.getDeclaredFields()</code>, <code>clazz.getDeclaredMethods()</code></li><li><strong>调用对象方法</strong>：<code>method.invoke(obj, args...)</code></li><li><strong>访问私有成员</strong>：通过 <code>setAccessible(true)</code> 取消访问检查。</li></ul><p>反射机制<strong>实际上会降低程序的性能</strong>,因为它需要在运行时进行类型检查和解析。同时,反射也可能破坏封装性,带来安全风险,因为它可以访问私有成员</p><div class="table-container"><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>提高程序灵活性和扩展性</strong>，支持动态加载类和调用</td><td><strong>性能较慢</strong>，需要绕过 JVM 优化，存在额外开销</td></tr><tr><td>支持框架、工具实现通用逻辑和动态操作</td><td><strong>破坏封装性</strong>，可访问私有成员，可能导致安全风险</td></tr><tr><td>支持动态代理、注解解析等高级功能</td><td><strong>编译时缺乏类型检查</strong>，错误只能运行时发现</td></tr></tbody></table></div><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="1-深拷贝和浅拷贝的区别"><a href="#1-深拷贝和浅拷贝的区别" class="headerlink" title="1.深拷贝和浅拷贝的区别"></a>1.深拷贝和浅拷贝的区别</h2><ul><li>浅拷贝是指<strong>只复制对象本身和其内部的值类型字段</strong>，但不会复制对象内部的引用类型字段。换句话说，<strong>浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中</strong>，但如果原对象内部有引用类型的字段，<strong>只是将引用复制到新对象中</strong>，<strong>两个对象指向的是同一个引用对象。</strong></li><li>深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，<strong>生成一个全新的对象以及其内部的所有对象。</strong></li></ul><div class="table-container"><table><thead><tr><th>对比项</th><th>浅拷贝（Shallow Copy）</th><th>深拷贝（Deep Copy）</th></tr></thead><tbody><tr><td>拷贝级别</td><td>拷贝对象本身+<strong>引用地址</strong></td><td>拷贝对象本身+<strong>引用对象的内容</strong></td></tr><tr><td>引用对象</td><td>原对象与副本<strong>共享引用对象</strong></td><td>副本拥有独立的引用对象</td></tr><tr><td>默认实现</td><td>Object.clone() 默认是浅拷贝</td><td>需手动实现递归复制</td></tr><tr><td>影响</td><td>改变副本的引用成员，会影响原对象</td><td>改变副本不影响原对象</td></tr><tr><td>应用场景</td><td>轻量对象复制，性能优先</td><td>要求对象完全独立、互不干扰</td></tr></tbody></table></div><h2 id="2-实现深拷贝的方式"><a href="#2-实现深拷贝的方式" class="headerlink" title="2.实现深拷贝的方式"></a>2.实现深拷贝的方式</h2><blockquote><p>实现 Cloneable 接口并重写 clone() 方法</p></blockquote><p>这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用序列化和反序列化</p></blockquote><p>通过将<strong>对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝</strong>。要求对象及其所有引用类型字段都实现 <strong>Serializable</strong> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>手动递归复制</p></blockquote><p>针对特定对象结构，<strong>手动递归复制对象及其引用类型字段</strong>。适用于对象结构复杂度不高的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">        copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">        copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-创建对象的五种方式"><a href="#1-创建对象的五种方式" class="headerlink" title="1.创建对象的五种方式"></a>1.创建对象的五种方式</h2><p><strong>使用new关键字</strong>：通过new关键字直接调用类的构造方法来创建对象。</p><p><strong>使用Class类的newInstance()方法</strong>：通过反射机制，可以使用Class类的newInstance()方法创建对象。</p><p><strong>使用Constructor类的newInstance()方法</strong>：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。一般跟反射一块用吧，获取类的构造器之后新建对象</p><p><strong>使用clone()方法</strong>：如果类实现了<strong>Cloneable</strong>接口，可以使用clone()方法复制对象。</p><p>这就是<strong>拷贝</strong></p><p><strong>使用反序列化</strong>：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。</p><h2 id="2-new出的对象什么时候回收"><a href="#2-new出的对象什么时候回收" class="headerlink" title="2.new出的对象什么时候回收"></a>2.new出的对象什么时候回收</h2><p>通过过关键字<code>new</code>创建的对象，由<strong>Java的垃圾回收器</strong>（Garbage Collector）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。</p><p>具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：</p><ol><li>引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li><li><strong>可达性分析算法</strong>：<strong>从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，</strong>如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li><li><strong>终结器</strong>（Finalizer）：如果对象重写了<code>finalize()</code>方法，垃圾回收器会在回收该对象之前调用<code>finalize()</code>方法，对象可以在<code>finalize()</code>方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。这个类似于try-catch-finally中的finally</li></ol><h2 id="3-如何获取私有对象？"><a href="#3-如何获取私有对象？" class="headerlink" title="3.如何获取私有对象？"></a>3.如何获取私有对象？</h2><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code> 的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问。</p><p>不过，可以通过下面两种方式来间接获取私有对象。</p><ul><li><strong>使用公共访问器方法（getter 方法）</strong>：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（即 <code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共的 getter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrivateField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> privateField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="comment">// 通过调用 getter 方法获取私有对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> obj.getPrivateField();</span><br><span class="line">        System.out.println(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通<strong>过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。</strong>但是却会破坏封装性，安全不会得到保障</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="comment">// 获取 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">        <span class="comment">// 获取私有字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        privateField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取私有字段的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) privateField.get(obj);</span><br><span class="line">        System.out.println(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="1-能讲一讲Java注解的原理吗？"><a href="#1-能讲一讲Java注解的原理吗？" class="headerlink" title="1.能讲一讲Java注解的原理吗？"></a>1.能讲一讲Java注解的原理吗？</h2><p>注解本质是一个<strong>继承了Annotation的特殊接口</strong>，其具体实现类<strong>是Java运行时生成的动态代理类。</strong></p><p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的<strong>invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</strong></p><h2 id="2-对注解解析的底层实现了解吗？"><a href="#2-对注解解析的底层实现了解吗？" class="headerlink" title="2.对注解解析的底层实现了解吗？"></a>2.对注解解析的底层实现了解吗？</h2><p>注解本质上是一种<strong>特殊的接口</strong>，它继承自 <code>java.lang.annotation.Annotation</code> 接口，<strong>所以注解也叫声明式接口</strong>，例如，定义一个简单的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，Java 编译器会将其转换为一个继承自 <code>Annotation</code> 的接口，并生成相应的字节码文件。</p><p>根据注解的作用范围，Java 注解可以分为以下几种类型：</p><ul><li><strong>源码级别注解</strong> ：<strong>仅存在于源码中</strong>，编译后不会保留（<code>@Retention(RetentionPolicy.SOURCE)</code>）。</li><li><strong>类文件级别注解</strong> ：<strong>保留在 <code>.class</code> 文件中，但运行时不可见</strong>（<code>@Retention(RetentionPolicy.CLASS)</code>）。</li><li><strong>运行时注解</strong> ：保留在 <code>.class</code> 文件中，<strong>并且可以通过反射在运行时访问</strong>（<code>@Retention(RetentionPolicy.RUNTIME)</code>）。</li></ul><p>只有运行时注解可以通过反射机制进行解析。</p><p>当注解被标记为 <code>RUNTIME</code> 时，Java 编译器会在生成的 <code>.class</code> 文件中保存注解信息。这些信息存储在字节码的属性表（Attribute Table）中，具体包括以下内容：</p><ul><li><strong>RuntimeVisibleAnnotations</strong> ：存储运行时可见的注解信息。</li><li><strong>RuntimeInvisibleAnnotations</strong> ：存储运行时不可见的注解信息。</li><li><strong>RuntimeVisibleParameterAnnotations</strong> 和 <strong>RuntimeInvisibleParameterAnnotations</strong> ：存储方法参数上的注解信息。</li></ul><p>通过工具（如 <code>javap -v</code>）可以查看 <code>.class</code> 文件中的注解信息。</p><p>注解的解析主要依赖于 Java 的反射机制。以下是解析注解的基本流程：</p><p>1、获取注册信息：通过反射 API 可以获取类、方法、字段等元素上的注解。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(annotation.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、底层原理：反射机制的核心类是 <code>java.lang.reflect.AnnotatedElement</code>，它是所有可以被注解修饰的元素（如 <code>Class</code>、<code>Method</code>、<code>Field</code> 等）的父接口。该接口提供了以下方法：</p><ul><li><code>getAnnotation(Class&lt;T&gt; annotationClass)</code>：获取指定类型的注解。</li><li><code>getAnnotations()</code>：获取所有注解。</li><li><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>：判断是否包含指定注解。</li></ul><p>这些方法的底层实现依赖于 JVM 提供的本地方法（Native Method），例如：</p><ul><li><code>native Annotation[] getDeclaredAnnotations0(boolean publicOnly);</code></li><li><code>native &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass);</code></li></ul><p>JVM 在加载类时会解析 <strong><code>.class</code> 文件中的注解信息，并将其存储在内存中，供反射机制使用。</strong></p><p>因此，注解解析的底层实现主要<strong>依赖于 Java 的反射机制和字节码文件的存储</strong>。通过 <code>@Retention</code> 元注解可以控制注解的保留策略，当使用 <code>RetentionPolicy.RUNTIME</code> 时，可以在运行时通过<strong>反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值。</strong></p><h2 id="3-Java注解的作用域呢？"><a href="#3-Java注解的作用域呢？" class="headerlink" title="3.Java注解的作用域呢？"></a>3.Java注解的作用域呢？</h2><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p><ol><li><strong>类级别作用域</strong>：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，<strong>如类的访问级别、继承关系、注释等。</strong></li><li><strong>方法级别作用域</strong>：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，<strong>如方法的访问级别、返回值类型、异常类型、注释等。</strong></li><li><strong>字段级别作用域</strong>：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，<strong>如字段的访问级别、默认值、注释等。</strong></li></ol><p>除了这三种作用域，Java还提供了其他一些注解作用域，例如<strong>构造函数作用域和局部变量作用域</strong>。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="1-介绍一下Java异常"><a href="#1-介绍一下Java异常" class="headerlink" title="1.介绍一下Java异常"></a>1.介绍一下Java异常</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt=""></p><p>Java的异常体系主要基于两大类：Throwable类及其子类。Throwable有两个重要的子类：Error和Exception，它们分别代表了不同类型的异常情况。</p><ol><li><strong>Error（错误）</strong>：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常，<strong>程序不应该尝试捕获这类错误</strong>。例如，OutOfMemoryError、StackOverflowError等。</li><li><strong>Exception（异常）</strong>：表示程序本身可以处理的异常条件。异常分为两大类：<ul><li><strong>非运行时异常</strong>：这类异常<strong>在编译时期就必须被捕获或者声明抛出</strong>。它们通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。</li><li><strong>运行时异常</strong>：这类异常包括运行时异常（RuntimeException）和错误（Error）。运行时异常由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。<strong>运行时异常是不需要在编译时强制捕获或声明的。</strong></li></ul></li></ol><h2 id="2-Java异常处理有哪些？"><a href="#2-Java异常处理有哪些？" class="headerlink" title="2.Java异常处理有哪些？"></a>2.Java异常处理有哪些？</h2><p>异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：</p><ul><li><strong>try-catch语句块</strong>：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType3 e3) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型3的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 可选的finally块，用于定义无论是否发生异常都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>throw语句</strong>：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ExceptionType(&quot;Exception message&quot;);</span><br></pre></td></tr></table></figure><ul><li><strong>throws关键字</strong>：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span> <span class="keyword">throws</span> ExceptionType &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>finally块</strong>：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码</span></span><br></pre></td></tr></table></figure><h2 id="3-抛出异常为什么不用throws？"><a href="#3-抛出异常为什么不用throws？" class="headerlink" title="3.抛出异常为什么不用throws？"></a>3.抛出异常为什么不用throws？</h2><p>如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。</p><ul><li><strong>Unchecked Exceptions</strong>：<strong>未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，</strong>编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。</li><li><strong>捕获和处理异常</strong>：另一种常见情况是，<strong>在方法内部捕获了可能抛出的异常，并在方法内部处理它们，</strong>而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。</li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="1-怎么把一个对象从一个jvm转移到另一个jvm"><a href="#1-怎么把一个对象从一个jvm转移到另一个jvm" class="headerlink" title="1.怎么把一个对象从一个jvm转移到另一个jvm?"></a>1.怎么把一个对象从一个jvm转移到另一个jvm?</h2><ul><li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。</li><li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。</li><li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。</li><li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。</li></ul><h2 id="2-序列化和反序列化让你自己实现你会怎么做"><a href="#2-序列化和反序列化让你自己实现你会怎么做" class="headerlink" title="2.序列化和反序列化让你自己实现你会怎么做?"></a>2.序列化和反序列化让你自己实现你会怎么做?</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷。</p><ul><li><strong>无法跨语言</strong>： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。</li><li><strong>容易被攻击</strong>：Java 序列化是不安全的，我们知道对象是通过在 <strong>ObjectInputStream 上调用 readObject() 方法进行反序列化的，</strong>这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，<strong>该方法可以执行任意类型的代码，这是非常危险的。</strong></li><li>序列化后的流太大：序列化后的二进制流大小能体现序列化的性能。<strong>序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。</strong>如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。</li></ul><p>我会考虑用主流序列化框架，比如FastJson、<strong>Protobuf</strong>来替代Java 序列化。</p><p>如果追求性能的话，Protobuf 序列化框架会比较合适，<strong>Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。</strong>可以说 Protobuf 的整体性能非常优秀。</p><h2 id="3-将对象转为二进制字节流具体怎么实现"><a href="#3-将对象转为二进制字节流具体怎么实现" class="headerlink" title="3.将对象转为二进制字节流具体怎么实现?"></a>3.将对象转为二进制字节流具体怎么实现?</h2><p>在Java中通过序列化对象流来完成序列化和反序列化：</p><ul><li>ObjectOutputStream：通过writeObject(）方法做序列化操作。</li><li>ObjectInputStrean：通过readObject()方法做反序列化操作。</li></ul><p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p><p>实现对象序列化：</p><ul><li>让类实现Serializable接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建输出流并写入对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现对象反序列化：</p><ul><li>创建输入流并读取对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，对象obj会被序列化并写入到文件”object.ser”中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。</p><p>总结：</p><p>创建文件传输流，然后这边是inputstream流放入outputstream</p><p>然后关闭</p><p>创建文件inputstream，创建outputstream流，output流readObject然后关闭流</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h3 id="1-volatile和sychronized如何实现单例模式"><a href="#1-volatile和sychronized如何实现单例模式" class="headerlink" title="1.volatile和sychronized如何实现单例模式"></a>1.volatile和sychronized如何实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 关键字修饰变量 防止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingleTon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  SingleTon <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块 只有在第一次获取对象的时候会执行到 ，第二次及以后访问时 instance变量均非null故不会往下执行了 直接返回啦</span></span><br><span class="line">            <span class="keyword">synchronized</span>(SingleTon.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。</p><ul><li>保证可见性。使用 volatile 定义的变量，将会保证对所有线程的可见性。</li><li>禁止指令重排序优化。</li></ul><p>由于 volatile 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。</p><h2 id="代理模式-amp-适配器模式"><a href="#代理模式-amp-适配器模式" class="headerlink" title="代理模式&amp;适配器模式"></a>代理模式&amp;适配器模式</h2><h3 id="1-代理模式和适配器模式有什么区别？"><a href="#1-代理模式和适配器模式有什么区别？" class="headerlink" title="1.代理模式和适配器模式有什么区别？"></a>1.代理模式和适配器模式有什么区别？</h3><ul><li><strong>目的不同</strong>：代理模式主要关注<strong>控制对对象的访问</strong>，而适配器模式则用于<strong>接口转换</strong>，使不兼容的类能够一起工作。</li><li><strong>结构不同</strong>：代理模式一般包含<strong>抽象主题、真实主题和代理</strong>三个角色，适配器模式包含<strong>目标接口、适配器和被适配者</strong>三个角色。</li><li><strong>应用场景不同</strong>：代理模式常用于<strong>添加额外功能或控制对对象</strong>的访问，适配器模式<strong>常用于让不兼容的接口协同工作。</strong></li></ul><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="1-Java怎么实现网络IO高并发编程？"><a href="#1-Java怎么实现网络IO高并发编程？" class="headerlink" title="1.Java怎么实现网络IO高并发编程？"></a>1.<strong>Java怎么实现网络IO高并发编程？</strong></h2><p>可以用 Java NIO ，是一种同步非阻塞的I/O模型，也是I/O多路复用的基础。</p><p>传统的BIO里面socket.read()，<strong>如果TCP RecvBuffer里没有数据，函数会一直阻塞</strong>，直到收到数据，返回读到的数据， <strong>如果使用BIO要想要并发处理多个客户端的i/o，那么会使用多线程模式</strong>，一个线程专门处理一个客户端 io，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能。</p><p>NIO 是<strong>基于I/O多路复用实现</strong>的，它可以<strong>只用一个线程处理多个客户端I/O</strong>，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。这个类似redis中的单线程IO多路复用</p><h2 id="2-BIO、NIO、AIO区别是什么？"><a href="#2-BIO、NIO、AIO区别是什么？" class="headerlink" title="2.BIO、NIO、AIO区别是什么？"></a>2.BIO、NIO、AIO区别是什么？</h2><ul><li>BIO（blocking IO）：就是传统的 java.io 包，它是<strong>基于流模型实现</strong>的，交互的方式是<strong>同步、阻塞方式</strong>，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，<strong>提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序</strong>，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，<strong>是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，</strong>所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul><h2 id="3-NIO是怎么实现的？"><a href="#3-NIO是怎么实现的？" class="headerlink" title="3.NIO是怎么实现的？"></a>3.NIO是怎么实现的？</h2><p>NIO是一种<strong>同步非阻塞的IO模型</strong>，所以也可以叫NON-BLOCKINGIO。<strong>同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。</strong></p><p>同步的核心就Selector（I/O多路复用），<strong>Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗</strong>；非阻塞的核心就是通道和缓冲区，<strong>当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待。</strong></p><p>NIO由<strong>一个专门的线程处理所有IO事件，并负责分发。事件驱动机制</strong>，事件到来的时候触发操作，不需要阻塞的监视事件。线程之间通过<strong>wait,notify</strong>通信，减少线程切换。</p><p>NIO主要有三大核心部分：<strong>Channel(通道)，Buffer(缓冲区), Selector。</strong>传统IO基于字节流和字符流进行操作，<strong>而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</strong></p><p>Selector(选择区)用于<strong>监听多个通道的事件</strong>（比如：连接打开，数据到达）。因此，<strong>单个线程可以监听多个数据通道。</strong></p><h1 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h1><h2 id="1-介绍下lambda表达式、Stream流"><a href="#1-介绍下lambda表达式、Stream流" class="headerlink" title="1.介绍下lambda表达式、Stream流"></a>1.介绍下<strong>lambda表达式、Stream流</strong></h2>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/19/javase/javase2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis面试hot</title>
      <link>https://blog.tokenlen.top/2025/05/15/java-stack/redis2/</link>
      <guid>https://blog.tokenlen.top/2025/05/15/java-stack/redis2/</guid>
      <pubDate>Wed, 14 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;1-详细的说说Redis的数据类型&quot;&gt;&lt;a href=&quot;#1-详细的说说Redis的数据类型&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-详细的说说Redis的数据类型"><a href="#1-详细的说说Redis的数据类型" class="headerlink" title="1.详细的说说Redis的数据类型"></a>1.详细的说说Redis的数据类型</h2><p>redis中常用的五种数据结构：<strong>string、list、set、zset、hash</strong>。</p><p>String结构底层是<strong>一个简单动态字符串</strong>，支持扩容，存储字符串。所以可应用于微信文章的阅读数或点赞，缓存对象、常规计数、分布式锁、共享 session 信息等。</p><p>list存储<strong>线性有序且可重复的元素</strong>，底层数据结构可以是双向链表/压缩列表。微薄的粉丝列表或好友列表，消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</p><p>set存<strong>储不可重复的元素</strong>，一般用于求交集、差集等，底层数据结构可以是hash和整数数组，所以可应用于抽奖，通过sadd添加不同的用户，srandom key number选出中将用户。还有集合的运算：sdiff、sintern与sunio就是集合的差交并运算，所以可应用于QQ的共同好友 聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</p><p>zset存储的<strong>是有序不可重复的元素</strong>，zset为每个元素添加了一个score属性作为排序依据，底层数据结构可以是ziplist和跳表，所以可应用于排行榜，类似于微博热搜 排序场景，比如排行榜、电话和姓名排序</p><p>hash类型存储的<strong>是键值对</strong>，底层数据结构是ziplist和hash。redis会在性能以及节省内存间考虑，选择最适合当前状态的底层数据结构实现  可用于存储用户数据，一个key代表一个用户，feild表示用户的各个属性，然后对应的value就是属性对应的值 缓存对象、购物车等。，一般来说key可以作为id，然后value用json数据来存储更多的数据，比如口味，价格等等。</p><p>list(有序可重复) 底层数据结构是双向链表/压缩链表</p><p>set(不可重复) = hash + 整数数组</p><p>zset(有序不可重复)ziplist+hashtable</p><p>hash(键值对) = ziplist+hash</p><p>还有四种特殊的数据类型</p><p>bitmaps：通过位操作（0/1）高效存储布尔型数据，基于 String 实现 </p><p>不是重复的，有序，按照顺序排列</p><ul><li>用户签到（记录每天是否签到）</li><li>活跃用户统计（是否活跃为 1，不活跃为 0）</li><li>商品浏览记录等布尔型状态场景</li><li>二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等</li></ul><p>hyperloglog：基于概率算法，<strong>用于估算唯一元素的数量</strong>，内存占用极小（仅 12KB 即可处理百万级数据）。误差极小。基于 HyperLogLog 算法（稀疏和稠密表示）是自动去重的无序的数据</p><ul><li>网站 UV（独立访客统计</li><li>统计某活动中多少人参与（去重计数）</li><li>分布式唯一用户识别</li></ul><p>geospatial：存储经纬度信息，支持距离计算、范围查询。基于 <strong>zset（跳表 + 哈希）</strong> 实现 不是重复的，按照地理位置的score排序</p><ul><li>附近商家/门店搜索（附近 1 公里内）</li><li>地图打车服务（距离计算）</li><li>地理围栏功能</li><li>存储地理位置信息的场景，比如滴滴叫车</li></ul><p>stream：Redis 的消息队列系统，<strong>支持多消费者组、消费确认、消息持久化等特性</strong>，功能类似 Kafka。底层类似日志结构（追加写），内部由 radix tree + linked list 组织 消息id唯一，但内容可重复。按照消息id排序</p><ul><li>事件驱动架构（Event Sourcing）</li><li>用户行为日志收集</li><li>异步任务队列（如发送通知、消息推送）</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>底层结构</th><th>是否有序</th><th>是否允许重复</th><th>典型应用</th></tr></thead><tbody><tr><td>String</td><td>简单动态字符串</td><td>无</td><td>是</td><td>点赞数、token、配置缓存等</td></tr><tr><td>List</td><td>双向链表 / 压缩列表</td><td>有</td><td>是</td><td>消息列表、任务队列、评论</td></tr><tr><td>Set</td><td>哈希表 / 整数数组</td><td>无</td><td>否</td><td>抽奖、标签、共同好友</td></tr><tr><td>ZSet</td><td>跳表 / ziplist</td><td>有（score 排序）</td><td>否</td><td>排行榜、热搜榜</td></tr><tr><td>Hash</td><td>ziplist / 哈希表</td><td>无</td><td>key 不重复</td><td>用户信息、配置表</td></tr><tr><td><strong>Bitmaps</strong></td><td>String + 位运算</td><td>有（按位）</td><td>否</td><td>签到、活跃状态、开关位标志</td></tr><tr><td><strong>HyperLogLog</strong></td><td>概率结构（哈希桶）</td><td>无</td><td>自动去重</td><td>UV 去重、唯一值估算</td></tr><tr><td><strong>Geo</strong></td><td>基于 ZSet + GeoHash</td><td>有（按位置编码）</td><td>否</td><td>附近位置查找、LBS、导航定位</td></tr><tr><td><strong>Stream</strong></td><td>日志结构 + radix tree</td><td>有（消息 ID）</td><td>内容可重复</td><td>消息队列、日志收集、事件通知</td></tr></tbody></table></div><h2 id="2-说说Redis的单线程架构。"><a href="#2-说说Redis的单线程架构。" class="headerlink" title="2.说说Redis的单线程架构。"></a>2.说说Redis的单线程架构。</h2><p>redis采用的是<strong>单线程+IO多路复用技术</strong>。这里单线程指的是<strong>redis中读写操作和网络IO使用的是是有一个线程来完成</strong>，但是其他操作是有其他线程完成，例如持久化操作。单线程既<strong>可以简化数据结构和算法的实现，同时也消除了线程切换和锁竞争所带来的消耗</strong>。redis中采用的IO多路复用技术实现了<strong>单线程下同时处理多个IO请求</strong>。</p><p>redis为什么这么快：</p><p>1.单线程进行读写操作，避免线程切换和锁竞争带来的消耗。</p><p>2：redis操作是在内存中进行的。</p><p>3.最重要的就是：采用了IO多路复用技术，实现了在网络IO中能够处理大量并发请求，实现高吞吐率。</p><h2 id="3-说说Redis的持久化策略。"><a href="#3-说说Redis的持久化策略。" class="headerlink" title="3.说说Redis的持久化策略。"></a>3.说说Redis的持久化策略。</h2><p>redis的持久化策略有三种：</p><p>1.RDB持久化：将当前进程中的数据已生成<strong>快照</strong>的方式保存到硬盘中，是redis默认的持久化机制。优点：持久化时生成的文件体积小，恢复数据快，缺点：每次运行都需要执行fork操作，RDB持久化策略，<strong>没有做到实时的持久化</strong>，有时可能会丢失最后一步的数据。</p><p>2.AOF持久化：以<strong>独立日志的方式记录每次写入的命令</strong>，重启时执行AOF中的命令即可恢复数据。优点：AOF持久化的安全性更高，保证了数据持久化的<strong>实时性</strong>。缺点：文件要大很多，恢复速度慢。</p><p>3.RDB-AOF持久化：这种方式是基于AOF持久化方式构建出来的。兼具RDB和AOF的优势。</p><h2 id="4-说说Redis的缓存淘汰策略。"><a href="#4-说说Redis的缓存淘汰策略。" class="headerlink" title="4.说说Redis的缓存淘汰策略。"></a>4.说说Redis的缓存淘汰策略。</h2><p>惰性删除、定期删除、maxmemory-policy；</p><p><strong>惰性删除</strong>：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。</p><p>定期删除：redis会将设置了过期时间的key放到一个<strong>独立的字典中</strong>，并对该字典进行<strong>每秒10次的过期扫描</strong>，过期扫描不会遍历字典中所有的key，而是采用了一种简单的<strong>贪心策略</strong>，该策略如下：1、<strong>从过期字典红随机选择20个key,2、删除这20个key中已过期的key，3、如果已过期key的比例超过25%，则重复步骤1；</strong></p><p>当写入数据将超出maxmemory限制时，Redis会采用maxmemory-policy所制定的策略进行数据淘汰 即 <strong>LRU</strong> （最近最少使用原则）LRU算法的不足之处在于,若一个key很少被访问,只是刚刚偶尔被访问了一次,则它就被认为是热点数据,短时间内不会被淘汰。</p><p>LFU算法正式用于解决上述问题,<strong>LFU</strong>（Least Frequently Used）是Redis4新增的淘汰策略,<strong>它根据key的最近访问频率进行淘汰</strong>。LFU在LRU的基础上,为每个数据增加了一个<strong>计数器</strong>,来统计这个数据的访问次数。当使用LFU策略淘汰数据时,首先会根据数据的访问次数进行筛选,把<strong>访问次数最低</strong>的数据淘汰出内存。如果两个数据的访问次数相同,LFU再比较这两个数据的访问时间,把<strong>访问时间更早</strong>的数据淘汰出内存</p><h2 id="5-如何实现Redis高可用"><a href="#5-如何实现Redis高可用" class="headerlink" title="5.如何实现Redis高可用?"></a>5.如何实现Redis高可用?</h2><p>高可用即需要有<strong>多个副本而不是单体支撑</strong>，主节点不可用可以替换成副节点，那么多个副本需要<strong>合理同步机制</strong>，做到这两点即可实现高可用，redis通过<strong>哨兵模式</strong>，<strong>集群模式</strong>来扩展单节点支撑。同时做好数据同步即实现了高可用 … </p><p>主要有哨兵模式和集群模式这两种方式。 </p><p>哨兵模式：哨兵模式是一个分布式架构，它包含若干个哨兵节点和数据节点，每一个哨兵节点都监控着其他的数据节点和哨兵节点，<strong>当发现节点不可达时，会对节点做下线标识</strong>。如果被标识的是主节点，它就会与其他哨兵节点协商，可以避免误判，<strong>当大多数哨兵节点都认为主节点不可达时</strong>，它们便会选择出一个哨兵节点来做<strong>自动故障转移工作，可以将从节点晋升为主节点</strong>，同时还会实时的<strong>通知到应用方</strong>，整个过程自动的，实现高可用。 </p><p>集群模式：Redis集群采用<strong>虚拟槽分区</strong>来实现数据分片，<strong>它把所有的键根据哈希函数映射到0-16383整数槽内</strong>，计算公式为slot=CRC16(key)&amp;16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。</p><p><strong>主从模式</strong>：一个master主机与多个slave从机，主节点负责写操作，从节点负责读操作。<br> 优点：<strong>读写分离，主节点的数据会自动复制给从节点，分担主节点的压力</strong><br> 缺点：一旦主节点宕机，会导致部分数据未实现同步；主节点宕机与从节点都需要进行重启； </p><h2 id="6-Redis怎么实现延时消息？"><a href="#6-Redis怎么实现延时消息？" class="headerlink" title="6.Redis怎么实现延时消息？"></a>6.Redis怎么实现延时消息？</h2><p>redis通过<strong>zset</strong>有序集合来实现延时消息功能。可以将发送的时间作为<strong>score</strong>发送的内容作为value存储在zset中，<strong>轮询zset检查当前时间是否达成消息的发送时间，来实现延时消息的投递。</strong>   </p><h2 id="7-Redis中的String怎么实现的"><a href="#7-Redis中的String怎么实现的" class="headerlink" title="7.Redis中的String怎么实现的?"></a>7.Redis中的String怎么实现的?</h2><p>String结构底层是<strong>一个简单动态字符串（sds）</strong>，支持扩容，存储字符串。所以可应用于微信文章的阅读数或点赞</p><p>Redis的String类型采用SDS(简单动态字符串)实现，结构包含<strong>长度、空闲空间和字符数组</strong>。支持<strong>二进制</strong>安全数据存储，<strong>自动预分配空间减少内存重分配次数</strong>，通过len字段实现O(1)时间复杂度获取长度，采用<strong>惰性空间释放策略优化性能。</strong></p><h2 id="8-Redis中的Zset怎么实现的"><a href="#8-Redis中的Zset怎么实现的" class="headerlink" title="8.Redis中的Zset怎么实现的?"></a>8.Redis中的Zset怎么实现的?</h2><p>Redis 的 ZSet 类型由 <strong>跳表（SkipList）和哈希表（HashTable）共同实现</strong>，跳表用于按 score 排序以<strong>支持范围查询和有序访问</strong>，哈希表用于快速根据成员（member）定位其分数。<strong>插入、删除、查找操作平均复杂度为 O(log N)</strong>，支持高效的排名、分数范围检索、排行榜等功能。ZSet 结构结合了<strong>哈希的快速定位与跳表的有序访问特性</strong>，是 Redis 中实现排行榜、延迟队列等典型场景的核心数据结构。</p><h2 id="9-使用-Redis-实现一个排行榜怎么做？"><a href="#9-使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="9.使用 Redis 实现一个排行榜怎么做？"></a>9.使用 Redis 实现一个排行榜怎么做？</h2><p>Redis 排行榜基于 <strong>ZSet（有序集合）</strong> 实现，成员为用户标识，score 表示排名依据（如积分、分数等）。通过 <code>ZADD</code> 添加或更新分数，<code>ZREVRANGE</code> 获取从高到低的前 N 名，<code>ZREVRANK</code> 查询某个成员的具体排名，<code>ZINCRBY</code> 实现积分累加。ZSet 底层由跳表和哈希表组成，支持高效的排名更新和区间查询，是实现积分榜、热度榜、活跃榜等场景的常用结构。</p><h2 id="10-如何用redis实现注册中心？"><a href="#10-如何用redis实现注册中心？" class="headerlink" title="10.如何用redis实现注册中心？"></a>10.如何用redis实现注册中心？</h2><p>Redis 实现注册中心可利用 <strong>Hash + Set + TTL 机制</strong>。服务注册时使用 <code>HSET</code> 将服务信息（如 IP、端口、元数据）存入 <code>service:服务名:实例ID</code>，并通过 <code>EXPIRE</code> 设置 TTL，服务需定时续约。可通过 <code>SCAN</code> 或维护一个 <code>Set</code> 存储所有实例 ID。服务发现时读取 Hash 信息，过滤过期实例，实现简易的服务注册与发现机制。适合对一致性要求不高的微服务场景，如灰度发布、本地开发模拟。生产推荐使用专业注册中心如 Nacos、Eureka、Consul。</p><h2 id="11-介绍一下Redis的线程模型。"><a href="#11-介绍一下Redis的线程模型。" class="headerlink" title="11.介绍一下Redis的线程模型。"></a>11.介绍一下Redis的线程模型。</h2><p>Redis 使用 <strong>单线程处理网络请求 + epoll I/O 多路复用机制</strong>，通过一个线程完成所有命令解析、执行、响应返回，避免了多线程的上下文切换开销与锁竞争。采用 <strong>Reactor 模式</strong>，基于 <code>epoll</code> 监听多个客户端连接的读写事件，使用 <strong>事件驱动机制</strong> 实现高并发处理。内部通过队列处理定时任务（如过期键删除）、异步任务（如 AOF 重写）。虽为单线程，但在计算密集和 I/O 场景下性能非常优异。Redis 6.0 起引入 <strong>I/O 线程</strong>，用于读写分离进一步优化性能（开启需配置 <code>io-threads</code>）。</p><h2 id="12-介绍一下Redis的事务。"><a href="#12-介绍一下Redis的事务。" class="headerlink" title="12.介绍一下Redis的事务。"></a>12.介绍一下Redis的事务。</h2><p>Redis 事务通过 <code>MULTI</code> 开始，<code>EXEC</code> 执行，中间的命令会被顺序入队，形成一个事务队列。事务期间执行命令不会立即生效，而是等 <code>EXEC</code> 统一执行，具备<strong>原子性（要么全部执行，要么全部不执行）</strong>。但<strong>不支持回滚</strong>，中途某条命令出错不会影响其他命令执行（除非是语法错误）。可以使用 <code>WATCH</code> 监控一个或多个 key，在事务执行前若有改动，<code>EXEC</code> 会失败，实现<strong>乐观锁机制</strong>。<code>DISCARD</code> 可用于取消事务。</p><p>优点：简洁高效，适用于无需回滚的小型批量操作。<br> 缺点：不支持部分失败回滚、不具备隔离性（非串行执行，读写不隔离）。</p><h2 id="13-介绍一下Redis-IO多路复用模型。"><a href="#13-介绍一下Redis-IO多路复用模型。" class="headerlink" title="13.介绍一下Redis IO多路复用模型。"></a>13.介绍一下Redis IO多路复用模型。</h2><p>Redis 的 IO 多路复用模型采用单线程结合操作系统提供的 <code>epoll</code>（Linux）或 <code>select/kqueue</code>（Unix 系统）实现高并发处理。它通过事件驱动的 <strong>Reactor 模式</strong>，在一个主线程中循环监听多个客户端连接的读写事件，统一由事件分发器管理，不依赖多线程/多进程，避免了上下文切换和线程锁开销。所有客户端请求被注册为事件，放入事件队列，当事件触发（如可读、可写）时，Redis 会将对应的文件描述符加入就绪队列，主线程从就绪队列中取出事件依次处理。Redis 使用这个模型能高效处理成千上万个连接，适合短连接、高频 IO 的场景，核心优势是结构简单、响应迅速，但由于是单线程处理命令，慢查询或阻塞操作仍需谨慎使用。</p><h2 id="14-说说Redis的大key，为什么会产生大key？"><a href="#14-说说Redis的大key，为什么会产生大key？" class="headerlink" title="14.说说Redis的大key，为什么会产生大key？"></a>14.说说Redis的大key，为什么会产生大key？</h2><p><strong>Redis 大 key</strong> 是指 <strong>单个 key 对应的 value 过大</strong>，比如字符串内容非常长、集合元素特别多，或哈希字段数量巨大等。这类 key 会占用较多内存，并可能导致阻塞、延迟、网络压力等问题。</p><p><strong>大 key 的原因</strong></p><ul><li><strong>数据结构设计不合理</strong>：未拆分或压入过多元素。</li><li><strong>缺乏过期策略或清理机制</strong>：数据长期堆积。</li><li><strong>没有监控</strong>：大 key 无法被及时发现处理。</li></ul><p><strong>大 key 的危害</strong></p><ul><li><strong>阻塞 Redis 单线程，影响整体性能。</strong></li><li><strong>网络传输耗时，客户端超时或拒绝服务。</strong></li><li><strong>集群迁移/备份异常，影响可用性。</strong></li><li><strong>内存占用异常，触发频繁淘汰或 OOM。</strong></li></ul><p><strong>优化建议</strong></p><ul><li><strong>限制元素数量，避免一次性压入过多数据。</strong></li><li><strong>将大结构拆成多个小 key（如分页、分桶）。</strong></li><li><strong>设置 TTL，定期清理历史数据。</strong></li><li><strong>使用 MEMORY USAGE、SCAN 等命令监控大 key。</strong></li></ul><h2 id="15-介绍一下Redis的集群模式。"><a href="#15-介绍一下Redis的集群模式。" class="headerlink" title="15.介绍一下Redis的集群模式。"></a>15.介绍一下Redis的集群模式。</h2><p>Redis集群模式通过将整个数据空间划分为16384个哈希槽（hash slots），并将这些槽分配给多个节点，实现数据的自动分片和负载均衡。每个节点负责一定范围的槽，客户端根据key的哈希值路由到对应节点。集群支持主从复制，主节点负责读写，从节点做备份，主节点故障时从节点自动接管，保证高可用。节点间通过Gossip协议进行状态通信和故障检测。Redis集群优点是扩展性强、自动故障恢复和客户端智能路由，但管理复杂且跨槽操作有限制，网络分区时可能出现“分裂脑”问题。总体而言，Redis集群是Redis实现水平扩展和高可用的关键方案。</p><h2 id="16-如何利用Redis实现一个分布式锁？"><a href="#16-如何利用Redis实现一个分布式锁？" class="headerlink" title="16.如何利用Redis实现一个分布式锁？"></a>16.如何利用Redis实现一个分布式锁？</h2><p><strong>方案一</strong>：SETNX + EXPIRE</p><p><strong>方案二</strong>：SETNX + value值是（系统时间 + 过期时间）</p><p><strong>方案三</strong>：使用Lua脚本（包含SETNX + EXPIRE两条指令）</p><p><strong>方案四</strong>：SET的扩展命令（SET EX PX NX）</p><p><strong>方案五</strong>：SET EX PX NX + 校验唯一随机值，再释放锁</p><p><strong>方案六</strong>：开源框架：Redisson</p><p><strong>方案七</strong>：多机实现的分布式锁Redlock</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-ZSet用过吗"><a href="#1-ZSet用过吗" class="headerlink" title="1.ZSet用过吗"></a>1.ZSet用过吗</h2><p>用过 zset 实现排行榜的功能。</p><p>以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:1 文章获得了200个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 200 arcticle:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:2 文章获得了40个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 40 arcticle:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:3 文章获得了100个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 100 arcticle:3</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:4 文章获得了50个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 50 arcticle:4</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:5 文章获得了150个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 150 arcticle:5</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>文章 arcticle:4 新增一个赞，可以<strong>使用 ZINCRBY 命令</strong>（为有序集合key中元素member的分值加上increment）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINCRBY user:xiaolin:ranking 1 arcticle:4</span></span><br><span class="line">&quot;51&quot;</span><br></pre></td></tr></table></figure><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZSCORE user:xiaolin:ranking arcticle:4</span></span><br><span class="line">&quot;50&quot;</span><br></pre></td></tr></table></figure><p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHSCORES 表示把 score 也显示出来</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span></span><br><span class="line">1) &quot;arcticle:1&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:3&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span></span><br><span class="line">1) &quot;arcticle:3&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:1&quot;</span><br><span class="line">6) &quot;200&quot;</span><br></pre></td></tr></table></figure><h2 id="2-Zset-底层是怎么实现的？"><a href="#2-Zset-底层是怎么实现的？" class="headerlink" title="2.Zset 底层是怎么实现的？"></a>2.Zset 底层是怎么实现的？</h2><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><p>底层其实也是：跳表（skiplist）+ 哈希表（hashtable）这是数据比较多的时候 查找，添加大量数据。</p><p>少的时候使用listpack/ziplist,占用内存低，但是查找慢。</p><h2 id="3-跳表是怎么实现的？"><a href="#3-跳表是怎么实现的？" class="headerlink" title="3.跳表是怎么实现的？"></a>3.跳表是怎么实现的？</h2><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719804939236-89f12a47-b851-4d06-a5f3-399e1119db57.png" alt="img"></p><p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p><ul><li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；</li><li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li><li>L2 层级只有 1 个节点，也就是节点 3 。</li></ul><p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4<strong>，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</strong></p><p>可以看到，<strong>这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</strong></p><p>那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的level数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><strong>Zset 对象要同时保存「元素」和「元素的权重」</strong>，对应到跳表节点结构里就是 <strong>sds 类型的 ele 变量和 double 类型的 score 变量。</strong>每个跳表节点都有一个<strong>后向指针（struct zskiplistNode *backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</strong></p><p>跳表是一个<strong>带有层级关系</strong>的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</p><p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p><p>比如，下面这张图，展示了各个节点的跨度。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719804939577-56390d43-28b7-4d20-accf-55c79a53142e.png" alt="img"></p><p>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针（struct zskiplistNode *forward）就可以完成了。</p><p>Redis <strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p><p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p><p>虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实<strong>如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</p><h2 id="4-跳表是怎么设置层高的？"><a href="#4-跳表是怎么设置层高的？" class="headerlink" title="4.跳表是怎么设置层高的？"></a>4.跳表是怎么设置层高的？</h2><p>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，<strong>直到随机数的结果大于 0.25 结束，最终确定该节点的层数。</strong></p><h2 id="5-Redis为什么使用跳表而不是用B-树"><a href="#5-Redis为什么使用跳表而不是用B-树" class="headerlink" title="5.Redis为什么使用跳表而不是用B+树?"></a>5.Redis为什么使用跳表而不是用B+树?</h2><p>Redis 是内存数据库，<strong>跳表在实现简单性、写入性能、内存访问模式等方面的综合优势</strong>，使其成为更合适的选择。</p><div class="table-container"><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">跳表优势</th><th style="text-align:left">B+ 树劣势</th></tr></thead><tbody><tr><td style="text-align:left"><strong>内存访问</strong></td><td style="text-align:left">符合CPU缓存局部性，指针跳转更高效</td><td style="text-align:left">节点结构复杂，缓存不友好</td></tr><tr><td style="text-align:left"><strong>实现复杂度</strong></td><td style="text-align:left">代码简洁，无复杂平衡操作</td><td style="text-align:left">节点分裂/合并逻辑复杂，代码量大</td></tr><tr><td style="text-align:left"><strong>写入性能</strong></td><td style="text-align:left">插入/删除仅需调整局部指针</td><td style="text-align:left">插入可能触发递归节点分裂，成本高</td></tr><tr><td style="text-align:left"><strong>内存占用</strong></td><td style="text-align:left">结构紧凑，无内部碎片</td><td style="text-align:left">节点预分配可能浪费内存</td></tr></tbody></table></div><p>Redis 选择使用跳表（Skip List）而不是 B+ 树来实现有序集合（Sorted Set）等数据结构，是经过多方面权衡后的结果。以下是详细的原因分析：</p><blockquote><p>1、内存结构与访问模式的差异</p></blockquote><p><strong>B+ 树的特性</strong></p><ul><li><strong>磁盘友好</strong>：B+ 树的设计目标是<strong>优化磁盘I/O</strong>，通过<strong>减少树的高度来降低磁盘寻道次数</strong>（例如，一个3层的B+树可以管理数百万数据）。</li><li><strong>节点填充率高</strong>：每个节点存储多个键值（Page/Block），适合批量读写。</li><li><strong>范围查询高效</strong>：叶子节点形成有序链表，范围查询（如 <code>ZRANGE</code>）性能极佳。</li></ul><p><strong>跳表的特性</strong></p><ul><li><strong>内存友好</strong>：跳表基于链表，通过多级索引加速查询，<strong>内存访问模式更符合CPU缓存局部性</strong>（指针跳跃更少）。</li><li><strong>简单灵活</strong>：插入/删除时仅需调整局部指针，无需复杂的节点分裂与合并。</li><li><strong>概率平衡</strong>：通过随机层高实现近似平衡，避免了严格的平衡约束（如红黑树的旋转）。</li></ul><p><strong>Redis 是内存数据库</strong>，数据完全存储在内存中，不需要优化磁盘I/O，因此 B+ 树的磁盘友好特性对 Redis 意义不大。而跳表的内存访问模式更优，更适合高频的内存操作。</p><blockquote><p>2、实现复杂度的对比</p></blockquote><p><strong>B+ 树的实现复杂度</strong>：</p><ul><li><strong>节点分裂与合并</strong>：插入/删除时可能触发节点分裂或合并，需要复杂的再平衡逻辑。</li><li><strong>锁竞争</strong>：在并发环境下，B<strong>+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。</strong></li><li><strong>代码复杂度</strong>：B+ 树的实现需要处理大量边界条件（如最小填充因子、兄弟节点借用等）。</li></ul><p><strong>跳表的实现复杂度</strong>：</p><ul><li><strong>无再平衡操作</strong>：插入时只需随机生成层高，删除时直接<strong>移除节点并调整指针</strong>。</li><li><strong>细粒度锁或无锁</strong>：跳表可以通过分段锁或无锁结构（如 CAS）实现高效并发。</li><li><strong>代码简洁</strong>：Redis 的跳表核心代码仅需约 200 行（B+ 树实现通常需要数千行）。</li></ul><p><strong>对于 Redis 这种追求高性能和代码简洁性的项目</strong>，跳表的低实现复杂度更具吸引力，Redis作者Antirez曾表示，跳表的实现复杂度远低于平衡树，且性能相近，是更优选择。</p><blockquote><p>3、性能对比</p></blockquote><p><strong>查询性能</strong></p><ul><li><strong>单点查询</strong>：跳表和 B+ 树的时间<strong>复杂度均为 <code>O(log N)</code>，</strong>但跳表的实际常数更小（内存中指针跳转比磁盘块访问快得多）。</li><li><strong>范围查询</strong>：B+ 树的叶子链表在范围查询时占优，但跳表通过双向链表也能高效支持 <code>ZRANGE</code> 操作。</li></ul><p><strong>写入性能</strong></p><ul><li><strong>B+ 树</strong>：插入可能触发节点分裂，涉及父节点递归更新，成本较高。</li><li><strong>跳表</strong>：插入仅需修改相邻节点的指针，写入性能更优（Redis 的 <code>ZADD</code> 操作时间复杂度为 <code>O(log N)</code>）。</li></ul><p><strong>实测数据</strong>：在内存中，跳表的插入速度比 B+ 树快 2-3 倍，查询速度相当。</p><blockquote><p>4、内存占用</p></blockquote><ul><li><strong>B+ 树</strong>：每个节点需要存储多个键值和子节点指针，存在内部碎片（节点未填满时）。</li><li><strong>跳表</strong>：每个节点只需存储键值、层高和多个前向指针，内存占用更紧凑。</li></ul><h2 id="6-压缩列表是怎么实现的？"><a href="#6-压缩列表是怎么实现的？" class="headerlink" title="6.压缩列表是怎么实现的？"></a>6.压缩列表是怎么实现的？</h2><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720432496274-b95e1802-1ecd-4210-a987-733265534c64.png" alt="img"></p><p>压缩列表在表头有三个字段：</p><ul><li><strong><em>zlbytes\</em></strong>，记录整个压缩列表占用对内存字节数；</li><li><strong><em>zltail\</em></strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是<strong>列表尾的偏移量</strong>；</li><li><strong><em>zllen\</em></strong>，记录压缩列表包含的节点数量；</li><li><strong><em>zlend\</em></strong>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位<strong>第一个元素和最后一个元素</strong>，可以通过<strong>表头三个字段</strong>（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>另外，压缩列表节点（entry）的构成如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720432496229-46da5ac0-0e89-45cd-b1f8-151f7c6d4660.png" alt="img"></p><p>压缩列表节点包含三部分内容：</p><ul><li><strong>prevlen</strong>，记录了「前一个节点」的长度，<strong>目的是为了实现从后向前遍历</strong>；</li><li><strong>encoding</strong>，记录了当前节点实际数据的「<strong>类型和长度」，类型主要有两种：字符串和整数。</strong></li><li><strong>data</strong>，记录了当前节点的实际数据，类型和长度都由 encoding 决定；</li></ul><p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p><p>压缩列表的缺点是会发生<strong>连锁更新</strong>的问题，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p><p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：<strong>quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）</strong>。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p><h2 id="7-什么是连锁更新"><a href="#7-什么是连锁更新" class="headerlink" title="7.什么是连锁更新"></a>7.什么是连锁更新</h2><p><strong>“连锁更新”</strong> 是压缩列表（<code>ziplist</code>）在执行插入或修改操作时可能引发的一种<strong>性能问题</strong>。它的核心原因是：<strong>节点头部的 <code>prevlen</code> 字段长度是变长的</strong>，当插入或修改一个节点导致某个 <code>prevlen</code> 字段的字节长度发生变化时，会<strong>影响后续所有节点的位置，从而引发级联的内存更新</strong>。</p><p>如果前一个节点的长度 ≥ 254 字节，则需要 <strong>5 个字节</strong>（1 + 4）来存储，所以插入了一个很大的节点的话，下一个节点的prelen就要变成5个字节，然后整个链条都要进行移动更新。</p><p>所以引入了quicklist和listpack。使用quicklist代替list的ziplist,listpack代替hash/zset的ziplist。</p><h2 id="8-介绍一下-Redis-中的-listpack"><a href="#8-介绍一下-Redis-中的-listpack" class="headerlink" title="8.介绍一下 Redis 中的 listpack"></a>8.介绍一下 Redis 中的 listpack</h2><p>quicklist 虽然通过控制 <strong>quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</strong></p><p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p><p>于是，Redis 在 5.0 新设计一个数据结构叫 <strong>listpack</strong>，目的是替代压缩列表，<strong>它最大特点是 listpack 中每个节点不再包含前一个节点的长度了</strong>，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p>listpack 采用了压缩列表的很多优秀的设计，比如<strong>还是用一块连续的内存空间来紧凑地保存数据</strong>，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p>我们先看看 listpack 结构：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719035634188-584809ba-ea0b-48ff-a547-9ee4d1b4d365.png" alt="img"></p><p>listpack 头包含两个属性，分别记录了 <strong>listpack 总字节数和元素数量</strong>，然后 listpack 末尾也有个<strong>结尾标识</strong>。图中的 listpack entry 就是 listpack 的节点了。</p><p>每个 listpack 节点结构如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719035634415-c436d60e-58a7-4dfc-9e69-db8e2f96d19c.png" alt="img"></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，<strong>encoding+data的总长度；</strong></li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p><h2 id="9-哈希表是怎么扩容的？"><a href="#9-哈希表是怎么扩容的？" class="headerlink" title="9.哈希表是怎么扩容的？"></a>9.哈希表是怎么扩容的？</h2><p>进行 rehash 的时候，需要用上 2 个哈希表了。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725232515019.png" alt="image-20240725232515019"></p><p>在<strong>正常服务请求阶段，插入的数据，都会写入到「哈希表 1」</strong>，此时的「哈希表 2 」 并没有被分配空间。</p><p>随着<strong>数据逐步增多</strong>，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，<strong>一般会比「哈希表 1」 大 2 倍；</strong></li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 <strong>新创建一个空白的哈希表，为下次 rehash 做准备。</strong></li><li>这个跟arraylist的复制差不多，只不过扩容的长度不相同。但是跟hashmap的扩容一样</li></ul><p>为了方便你理解，我把 rehash 这三个过程画在了下面这张图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725232528097.png" alt="image-20240725232528097"></p><p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。</p><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」 分配空间；</li><li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li><li>随着<strong>处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</strong></li></ul><p>这样就巧妙地把一次性大量数据迁移工作的开销<strong>，分摊到了多次处理请求的过程中</strong>，避免了一次性 rehash 的耗时操作。</p><p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，<strong>哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</strong>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><p>另外，<strong>在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</strong></p><p>就像一个慢性一个急性的问题一样。</p><h2 id="10-哈希表扩容的时候，有读请求怎么查？"><a href="#10-哈希表扩容的时候，有读请求怎么查？" class="headerlink" title="10.哈希表扩容的时候，有读请求怎么查？"></a>10.哈希表扩容的时候，有读请求怎么查？</h2><p>查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><h2 id="11-String-是使用什么存储的-为什么不用-c-语言中的字符串"><a href="#11-String-是使用什么存储的-为什么不用-c-语言中的字符串" class="headerlink" title="11.String 是使用什么存储的?为什么不用 c 语言中的字符串?"></a>11.<strong>String 是使用什么存储的?为什么不用 c 语言中的字符串?</strong></h2><p>Redis 的 String 字符串是用 <strong>SDS 数据结构</strong>存储的。</p><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725232549832.png" alt="image-20240725232549832"></p><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，<strong>可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，</strong>所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 <strong>sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64</strong>，后面在说明区别之处。</li><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li></ul><p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p><blockquote><p>O（1）复杂度获取字符串长度</p></blockquote><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p><p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p><blockquote><p>二进制安全</p></blockquote><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p><p>因此， SDS 的 API 都是以处理二进制的方式来处理 <strong>SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。</strong></p><p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p><blockquote><p>不会发生缓冲区溢出</p></blockquote><p>C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p><p>所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 <code>**alloc - len</code> 计算**，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p><p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小</strong>，以满足修改所需的大小。</p><p>跳表节点的底层也是由sds作为数据结构的来存储节点的。</p><h2 id="12-Quicklist-是什么？"><a href="#12-Quicklist-是什么？" class="headerlink" title="12.Quicklist 是什么？"></a>12.Quicklist 是什么？</h2><p><strong>Quicklist 是由多个 ziplist 或 listpack 组成的双向链表，每个节点称为 quicklist node，存储的是一个压缩列表（ziplist 或 listpack）</strong>。</p><p>既节省内存（使用压缩结构）又支持高效插入/删除（链表结构）</p><div class="table-container"><table><thead><tr><th>特性</th><th>ziplist</th><th>listpack</th><th>quicklist</th></tr></thead><tbody><tr><td>类型</td><td>连续内存结构</td><td>连续内存结构（ziplist 替代品）</td><td><strong>双向链表，节点内是 ziplist/listpack</strong></td></tr><tr><td>引入版本</td><td>很早</td><td>Redis 5.0</td><td>Redis 3.2</td></tr><tr><td>优点</td><td>紧凑节省内存</td><td>更快、更省空间</td><td>高效插入/删除 + 内存节省</td></tr><tr><td>缺点</td><td>插入/删除代价高，连锁更新</td><td>复杂性高</td><td>管理多个节点需要额外逻辑</td></tr><tr><td>用于 List</td><td>❌（早期用）</td><td>✅（Redis 5.0 起）</td><td>✅（官方默认 List 实现）</td></tr><tr><td>关系</td><td>被 listpack 替代</td><td>替代 ziplist</td><td><strong>封装 ziplist/listpack 的双向链表</strong></td></tr></tbody></table></div><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="1-Redis为什么快？"><a href="#1-Redis为什么快？" class="headerlink" title="1.Redis为什么快？"></a>1.Redis为什么快？</h2><p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W/每秒</strong>，如下图所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1718937885119-ff470de4-b583-407c-b7e1-000fb9926539.webp" alt="img"></p><p>之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：</p><ul><li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且<strong>采用了高效的数据结构</strong>，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了 <strong>I/O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是我们经常听到的 <strong>select/epoll 机制</strong>。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。<strong>内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，</strong>这就实现了一个 Redis 线程处理多个 IO 流的效果。</li></ul><h2 id="2-Redis哪些地方使用了多线程"><a href="#2-Redis哪些地方使用了多线程" class="headerlink" title="2.Redis哪些地方使用了多线程?"></a>2.Redis哪些地方使用了多线程?</h2><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，<strong>分别处理关闭文件、AOF 刷盘这两个任务；</strong></li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来<strong>异步释放 Redis 内存，也就是 lazyfree 线程</strong>。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，<strong>好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</strong></li></ul><p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p><p>后台线程相当于一个消费者，生产者把<strong>耗时任务</strong>丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721630818566-ee627936-3a35-4457-a9c7-2b58a88a7da5.png" alt="img"></p><p>虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是<strong>在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</strong>。</p><p>所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解Redis 有多线程同时执行命令</strong>。</p><p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上</strong>。</p><p>Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想<strong>开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读请求也使用io多线程</span></span><br><span class="line">io-threads-<span class="keyword">do</span>-reads yes</span><br></pre></td></tr></table></figure><p>同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）</span></span><br><span class="line">io-threads <span class="number">4</span></span><br></pre></td></tr></table></figure><p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p><p>因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p><ul><li>Redis-server ： Redis的主线程，主要负责执行命令；</li><li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li><li>io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，<strong>io-threads 默认是 4</strong> ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。</li></ul><h2 id="3-Redis怎么实现的io多路复用？"><a href="#3-Redis怎么实现的io多路复用？" class="headerlink" title="3.Redis怎么实现的io多路复用？"></a>3.Redis怎么实现的io多路复用？</h2><p>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</p><p>因为 Redis 是跑在「单线程」中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入 或 输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导，致整个进程无法对其它客户提供服务。而 I/O 多路复用就是为了解决这个问题而出现的。<strong>为了让单线程(进程)的服务端应用同时处理多个客户端的事件，</strong>Redis 采用了 IO 多路复用机制。</p><p>这里“多路”指的是多个网络连接客户端，“复用”指的是复用同一个线程(单进程)。I/O 多路复用其实是使用一个线程来检查多个 Socket 的就绪状态，在单个线程中通过记录跟踪每一个 socket（I/O流）的状态来管理处理多个 I/O 流。如下图是 Redis 的 I/O 多路复用模型：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720433058791-94f03cb5-e89c-45ed-ba34-88a0dac99d98.png" alt="img"></p><p>如上图对 Redis 的 I/O 多路复用模型进行一下描述说明：</p><ul><li>一个 socket 客户端与服务端连接时，会生成<strong>对应一个套接字描述符</strong>(套接字描述符是文件描述符的一种)，每一个 socket 网络连接其实都对应一个文件描述符。</li><li>多个客户端与服务端连接时，Redis 使用 I/O 多路复用程序 <strong>将客户端 socket 对应的 FD 注册到监听列表(一个队列)中。</strong>当客服端执行 read、write 等操作命令时，<strong>I/O 多路复用程序会将命令封装成一个事件，并绑定到对应的 FD 上。</strong></li><li>文件事件处理器使用 I/O 多路复用模块同时监控多个文件描述符（fd）的读写情况，当 accept、read、write 和 close 文件事件产生时，<strong>文件事件处理器就会回调 FD 绑定的事件处理器进行处理相关命令操作。</strong></li></ul><p>例如：以 Redis 的 I/O 多路复用程序 epoll 函数为例。多个客户端连接服务端时，Redis 会将<strong>客户端 socket 对应的 fd 注册进 epoll，然后 epoll 同时监听多个文件描述符(FD)是否有数据到来，如果有数据来了就通知事件处理器赶紧处理，这样就不会存在服务端一直等待某个客户端给数据的情形。</strong></p><p>整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，当其中一个 client 端达到写或读的状态，文件事件处理器就马上执行，从而就不会出现 I/O 堵塞的问题，提高了网络通信的性能。</p><p>Redis 的 I/O 多路复用模式使用的是 <strong>Reactor 设置模式</strong>的方式来实现。</p><h2 id="4-Redis的网络模型是怎样的？"><a href="#4-Redis的网络模型是怎样的？" class="headerlink" title="4.Redis的网络模型是怎样的？"></a>4.Redis的网络模型是怎样的？</h2><p>Redis 6.0 版本之前，是用的是单Reactor单线程的模式</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721630566038-d16ec13e-e7e6-4e0b-a48c-e7affdbf312e.png" alt="img"></p><p>单 <strong>Reactor 单进程</strong>的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。</p><p>但是，这种方案存在 2 个缺点：</p><ul><li>第一个缺点，因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li><li>第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<strong>如果业务处理耗时比较长，那么就造成响应的延迟</strong>；</li></ul><p>所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p><p>Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</p><p><strong>到 Redis 6.0 之后，就将网络IO的处理改成多线程的方式了</strong>，目的是为了<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</strong>。</p><p>所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解</strong> Redis 有多线程同时执行命令。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1-redis的事务和mysql事务有什么区别？"><a href="#1-redis的事务和mysql事务有什么区别？" class="headerlink" title="1.redis的事务和mysql事务有什么区别？"></a>1.redis的事务和mysql事务有什么区别？</h2><p>Redis 事务和 MySQL 事务在概念和实现机制上有显著区别。</p><p>Redis 事务是通过 <code>MULTI</code> 和 <code>EXEC</code> 命令将一组 Redis 命令打包，<strong>按顺序、一次性执行</strong>，但它并不支持传统意义上的回滚机制。Redis 事务保证的是命令的<strong>有序性</strong>和<strong>单线程执行的隔离性</strong>，<strong>不具备真正的原子性</strong>和错误回滚能力：即使其中某条命令出错（如类型错误），其他命令仍会继续执行。因此，Redis 事务更像是一个<strong>命令队列的批处理机制</strong>。</p><p>相比之下，MySQL 事务是围绕 <strong>ACID 四大特性（原子性、一致性、隔离性、持久性）</strong> 实现的完整事务机制。它可以<strong>确保多条 SQL 操作要么全部成功，要么全部失败，</strong>并通过日志（如 redo/undo log）和锁机制（如行锁、表锁）来保障数据的一致性和隔离性。如果在事务中发生异常，可以通过 <code>ROLLBACK</code> 完整撤销已执行的操作，具有<strong>真正的回滚能力</strong>。</p><p>总结来说，Redis 的事务偏向“批处理语义”，适用于命令顺序性要求较高但对一致性要求不高的场景；而 MySQL 事务适用于强一致性、复杂逻辑、数据回滚需求的业务处理场景。两者适用场景和保障能力有本质差异。</p><h2 id="2-如何实现redis-原子性？"><a href="#2-如何实现redis-原子性？" class="headerlink" title="2.如何实现redis 原子性？"></a>2.如何实现redis 原子性？</h2><p>redis 执行一条命令的时候是具备原子性的，因为 redis 执行命令的时候是单线程来处理的，不存在多线程安全的问题。</p><p>如果要保证 2 条命令的原子性的话，可以考虑用 <strong>lua 脚本</strong>，将多个操作写到一个 Lua 脚本中，Redis <strong>会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。</strong></p><p>比如说，在用 redis 实现分布式锁的场景下，解锁期间涉及 2 个操作，<strong>分别是先判断锁是不是自己的，是自己的才能删除锁，</strong>为了保证这 2 个操作的原子性，会通过 lua 脚本来保证原子性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="3-除了lua有没有什么也能保证redis的原子性？"><a href="#3-除了lua有没有什么也能保证redis的原子性？" class="headerlink" title="3.除了lua有没有什么也能保证redis的原子性？"></a>3.除了lua有没有什么也能保证redis的原子性？</h2><p>redis 事务也可以保证多个操作的原子性。</p><p>如果 redis 事务正常执行，没有发生任何错误，那么<strong>使用 MULTI 和 EXEC 配合使用，就可以保证多个操作都完成。</strong></p><p>但是，如果事务执行发生错误了，就没办法保证原子性了。比如说 2 个操作，第一个操作执行成果了，但是第二个操作执行的时候，命令出错了，<strong>那事务并不会回滚，因为Redis 中并没有提供回滚机制。</strong></p><p>举个小例子。事务中的 LPOP 命令对 String 类型数据进行操作，入队时没有报错，但是，在 EXEC 执行时报错了。LPOP 命令本身没有执行成功，但是事务中的 DECR 命令却成功执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">#发送事务中的第一个操作，LPOP命令操作的数据类型不匹配，此时并不报错</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPOP a:stock</span><br><span class="line">QUEUED</span><br><span class="line">#发送事务中的第二个操作</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR b:stock</span><br><span class="line">QUEUED</span><br><span class="line">#实际执行事务，事务第一个操作执行报错</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">8</span></span><br></pre></td></tr></table></figure><p>因此，Redis 对事务原子性属性的保证情况：</p><ul><li><strong>Redis 事务正常执行，可以保证原子性；</strong></li><li>Redis 事务执行中某一个操作执行失败，不保证原子性；</li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="1-缓存三大问题兄弟"><a href="#1-缓存三大问题兄弟" class="headerlink" title="1.缓存三大问题兄弟"></a>1.缓存三大问题兄弟</h2><p>缓存雪崩：</p><p>大量 key 设置了相同的 TTL，到期后一起失效。</p><p>解决：</p><p>设置过期时间<strong>加上随机值，避免集中过期</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire(&quot;key&quot;, baseTime + random(0, 60));</span><br></pre></td></tr></table></figure><p>构建多级缓存（如本地 Caffeine + Redis）</p><p>对关键数据使用持久缓存（不过期）</p><p>本地降级等等。</p><p>缓存穿透：</p><p>查询的 key 本身是无效的，数据库也没有，导致缓存永远不会命中。</p><p>对“查不到”的 key 缓存空值（如空字符串、特殊标记）</p><p>使用<strong>布隆过滤器</strong>提前拦截非法 key（高效过滤不存在的 key）</p><p>做接口层防护（黑名单、防刷策略）</p><p>缓存击穿：</p><p>一个访问量极高的热点 key 在某个时刻刚好过期了，此时大量请求并发访</p><p>加互斥锁（保证一个线程重建缓存）</p><p>提前预热，设置不过期 key</p><p>使用逻辑过期 + 异步更新机制（如异步刷新线程）</p><p>分布式锁、逻辑过期 + 延迟双写</p><h2 id="2-Redis怎么做内存优化"><a href="#2-Redis怎么做内存优化" class="headerlink" title="2.Redis怎么做内存优化"></a>2.<strong>Redis怎么做内存优化</strong></h2><ol><li><strong>选择合适的数据结构</strong></li></ol><ul><li>合理使用数据结构可以显著节省内存：<ul><li>使用 <code>Hash</code> 存储多个字段数据，字段较小时共享内部结构（节省元数据开销）</li><li>使用 <code>ListPack</code> 代替 <code>Ziplist</code>，支持压缩</li><li>合理使用 <code>Set</code>、<code>ZSet</code>、<code>Bitmap</code>、<code>HyperLogLog</code> 等以最小内存实现目标</li></ul></li></ul><ol><li><strong>合理配置小对象聚合（如 hash-max-ziplist-entries）</strong></li></ol><ul><li><p>当 <code>Hash</code> 的字段数量不多时，Redis 会使用<strong>压缩结构（listpack）</strong>来节省内存。</p></li><li><p>默认阈值可通过以下参数调整：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>开启内存压缩模块（Redis 7 引入）</strong></li></ol><ul><li>Redis 7 支持数据的内存压缩模块 <code>RedisMemoryCompressModule</code></li><li>对于<strong>冷数据使用压缩算法</strong>（如 LZ4）减少空间</li></ul><ol><li><strong>使用合理的数据编码</strong></li></ol><ul><li>Redis 针对不同数据量和内容，自动采用最优编码（如整数优化、小对象压缩）</li><li>使用 <code>OBJECT encoding key</code> 查看键的实际编码方式</li></ul><ol><li><strong>设置过期时间（TTL）</strong></li></ol><ul><li>对非永久数据设置 <code>EXPIRE</code>，及时释放无用数据</li><li>降低内存占用，防止内存泄漏</li></ul><ol><li><strong>启用 maxmemory 策略</strong></li></ol><ul><li><p>限制最大内存，并设定淘汰策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 1gb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure></li><li><p>常见淘汰策略：</p><ul><li><code>volatile-lru</code>：只对设置了 TTL 的 key 使用 LRU</li><li><code>allkeys-lru</code>：所有 key 都参与淘汰</li><li><code>volatile-ttl</code>：根据 TTL 剩余时间淘汰</li><li><code>allkeys-random</code>：随机淘汰任意 key</li></ul></li></ul><ol><li><strong>避免大 Key、大 Value</strong></li></ol><ul><li>拆分大 Key（如大型 Hash）为多个小 Key</li><li>减少内存碎片和阻塞风险（特别是在持久化和复制时）</li></ul><ol><li><strong>使用压缩数据格式存储业务数据</strong></li></ol><ul><li>业务上可将 JSON 压缩为 <strong>MsgPack、Protobuf、Snappy</strong> 等格式后再存入 Redis</li></ul><h2 id="3-过期删除策略和内存淘汰策略有什么区别？"><a href="#3-过期删除策略和内存淘汰策略有什么区别？" class="headerlink" title="3.过期删除策略和内存淘汰策略有什么区别？"></a>3.过期删除策略和内存淘汰策略有什么区别？</h2><p>区别：</p><ul><li>内存淘汰策略是在内存满了的时候，redis 会触发<strong>内存淘汰策略</strong>，来淘汰一些不必要的内存资源，以腾出空间，来保存新的内容</li><li>过期键删除策略是将<strong>已过期的键值对进行删除</strong>，Redis 采用的删除策略是惰性删除+定期删除。</li></ul><h2 id="4-介绍一下Redis-内存淘汰策略"><a href="#4-介绍一下Redis-内存淘汰策略" class="headerlink" title="4.介绍一下Redis 内存淘汰策略"></a>4.介绍一下Redis 内存淘汰策略</h2><p>在 32 位操作系统中，<strong>maxmemory 的默认值是 3G</strong>，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。</p><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1717480443917-64e65a05-b9f9-4a6e-a969-8f18f72f2133.png" alt="img"></p><p><em>1、不进行数据淘汰的策略：</em></p><ul><li><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当<strong>运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据</strong>，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</li></ul><p><em>2、进行数据淘汰的策略：</em></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p><ul><li>在设置了过期时间的数据中进行淘汰：</li><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：<strong>淘汰所有设置了过期时间的键值中，最久未使用的键值；</strong></li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li><li>在所有数据范围内进行淘汰：</li><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><h2 id="5-介绍一下Redis过期删除策略"><a href="#5-介绍一下Redis过期删除策略" class="headerlink" title="5.介绍一下Redis过期删除策略"></a>5.介绍一下Redis过期删除策略</h2><p><strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><p>Redis 的<strong>惰性删除策略</strong>由 <strong>db.c 文件中的 expireIfNeeded</strong> 函数实现，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int expireIfNeeded(redisDb *db, robj *key) &#123;</span><br><span class="line">    // 判断 key 是否过期</span><br><span class="line">    if (!keyIsExpired(db,key)) return 0;</span><br><span class="line">    ....</span><br><span class="line">    /* 删除过期键 */</span><br><span class="line">    ....</span><br><span class="line">    // 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；</span><br><span class="line">    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：</p><ul><li>如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 lazyfree_lazy_expire 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；</li><li>如果没有过期，不做任何处理，然后返回正常的键值对给客户端；</li></ul><p>惰性删除的流程图如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1717480558040-db8f2883-fb68-43fa-bcf8-42f5ac736c09.webp" alt="img"></p><p><strong>Redis 的定期删除是每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p><em>1、这个间隔检查的时间是多长呢？</em></p><p>在 Redis 中，<strong>默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</strong>特别强调下，每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机抽取一定数量的 key 进行过期检查。</p><p><em>2、随机抽查的数量是多少呢？</em></p><p>我查了下源码，定期删除的实现在 expire.c 文件下的 activeExpireCycle 函数中，其中随机抽查的数量由 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 定义的，它是写死在代码中的，数值是 20。也就是说，数据库每轮抽查时，会随机选择 20 个 key 判断是否过期。接下来，详细说说 Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。针对定期删除的流程，我写了个伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//已过期的数量</span></span><br><span class="line">    expired = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//随机抽取的数量</span></span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="comment">//1. 从过期字典中随机抽取 1 个 key</span></span><br><span class="line">        <span class="comment">//2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超过时间限制则退出</span></span><br><span class="line">    <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (expired &gt; <span class="number">20</span>/<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>定期删除的流程如下：<img src="https://cdn.xiaolincoding.com//picgo/1717480609871-26ec98a9-5407-43cf-af2f-dd0cfe826541.webp" alt="img"></p><h2 id="6-Redis的缓存失效会不会立即删除？"><a href="#6-Redis的缓存失效会不会立即删除？" class="headerlink" title="6.Redis的缓存失效会不会立即删除？"></a>6.Redis的缓存失效会不会立即删除？</h2><p>不会，Redis 的过期删除策略是选择「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p><ul><li>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></li><li>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></li></ul><p>那么为什么不过期就删除</p><p>在过期 key 比较多的情况下，<strong>删除过期 key 可能会占用相当一部分 CPU 时间</strong>，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</p><h2 id="7-为什么先写-MySQL-再删除-Redis？"><a href="#7-为什么先写-MySQL-再删除-Redis？" class="headerlink" title="7.为什么先写 MySQL 再删除 Redis？"></a>7.为什么先写 MySQL 再删除 Redis？</h2><p>在缓存更新策略中，<strong>先写 MySQL 再删除 Redis</strong> 是一种常见做法，用于<strong>避免并发下的数据不一致问题。</strong>具体流程是：先将<strong>新数据写入 MySQL，确保数据持久化成功后，再删除 Redis 缓存，让缓存失效，下一次请求就会从数据库中读取最新数据并回填到 Redis。</strong>如果反过来操作，先删除 Redis 再写 MySQL，可能在高并发场景下导致<strong>旧数据被回写 Redis</strong>，造成<strong>缓存脏数据</strong>。例如，请求 A 删除了缓存但尚未完成数据库写入时，请求 B 恰好读到旧数据并写入 Redis，最终缓存中存储的是错误值。因此，推荐顺序是先更新数据库，再删除缓存，以减少数据不一致风险。在高并发或强一致性要求场景下，还可以结合<strong>延迟双删、分布式锁、消息队列</strong>等机制进一步增强数据一致性保障。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="1-redis分布式锁的原理"><a href="#1-redis分布式锁的原理" class="headerlink" title="1.redis分布式锁的原理"></a>1.redis分布式锁的原理</h2><p><strong>在 Redis 中设置一个键代表“加锁”，删除该键代表“释放锁”</strong>。</p><div class="table-container"><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>原子性</td><td>如果用 <code>SETNX</code> 和 <code>EXPIRE</code> 分开写，不具备原子性，可能导致死锁</td></tr><tr><td>锁续期</td><td>如果业务执行超过锁的 TTL，锁可能自动过期，导致多个线程并发进入</td></tr><tr><td>锁释放</td><td>用 <code>DEL</code> 删除锁可能误删其他线程的锁（锁被提前释放或被其他线程获取）</td></tr></tbody></table></div><h2 id="2-哨兵集群里的脑裂问题"><a href="#2-哨兵集群里的脑裂问题" class="headerlink" title="2.哨兵集群里的脑裂问题"></a>2.哨兵集群里的脑裂问题</h2><p><strong>由于网络分区、哨兵通信异常或主从状态不同步，多个节点错误地认为自己是主节点，出现“多个主”</strong>。</p><p>情况：</p><p>主节点与部分哨兵断网，但与从节点仍连接；</p><p>剩余哨兵形成多数派，重新选出新主；</p><p>原主未被强制下线，继续对外提供写服务；</p><p>最终出现两个主节点，数据可能不一致，严重时丢失。</p><div class="table-container"><table><thead><tr><th>危害</th><th>描述</th></tr></thead><tbody><tr><td>写丢失</td><td>原主的写操作未同步到新主，最终被覆盖或丢弃</td></tr><tr><td>数据不一致</td><td>客户端连接了不同主节点，写入数据不同步</td></tr><tr><td>系统不可预测</td><td>出现并发写错乱、数据错乱等严重问题</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>机制</th><th>作用</th></tr></thead><tbody><tr><td><strong>投票选主</strong></td><td>只有哨兵多数派（过半）才可以发起主从切换</td></tr><tr><td><strong>主从自动切换</strong></td><td>新主选出后通知其他哨兵、客户端更新连接</td></tr><tr><td><strong>slave-priority=0</strong></td><td>设置某些节点永不当主（避免异常节点被选中）</td></tr><tr><td><strong>protected-mode</strong></td><td>Redis 启动默认开启保护模式，防止意外暴露端口</td></tr><tr><td><strong>config epoch（版本号）</strong></td><td>每次选主有版本，旧主收到新配置后会自动变为从节点</td></tr></tbody></table></div><p>只能<strong>尽量降低发生概率</strong>。在生产环境中，通常建议使用更健壮的集群模式（如 Redis Cluster、ZooKeeper、Raft 等）来代替哨兵。</p><h2 id="4-Redis主从同步中的增量和完全同步怎么实现？"><a href="#4-Redis主从同步中的增量和完全同步怎么实现？" class="headerlink" title="4.Redis主从同步中的增量和完全同步怎么实现？"></a>4.Redis主从同步中的增量和完全同步怎么实现？</h2><blockquote><p>完全同步</p></blockquote><p>完全同步发生在以下几种情况：</p><ul><li><strong>初次同步</strong>：当一个从服务器（slave）首次连接到主服务器（master）时，会进行一次完全同步。</li><li><strong>从服务器数据丢失</strong>：如果从服务器数据由于某种原因（如断电）丢失，它会请求进行完全同步。</li><li><strong>主服务器数据发生变化</strong>：如果从服务器长时间未与主服务器同步，导致数据差异太大，也可能触发完全同步。</li></ul><p>主从服务器间的第一次同步的过程可分为三个阶段：</p><ul><li>第一阶段是建立链接、协商同步；</li><li>第二阶段是主服务器同步数据给从服务器；</li><li>第三阶段是主服务器发送新写操作命令给从服务器。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1720157699223-d4aa2235-35e2-42ec-84a8-522600f531c2.png" alt="img"></p><p><strong>实现过程</strong>：</p><ol><li><strong>从服务器发送SYNC命令</strong>：从服务器向主服务器发送<code>SYNC</code>命令，请求开始同步。</li><li><strong>主服务器生成RDB快照</strong>：接收到<code>SYNC</code>命令后，主服务器会保存<strong>当前数据集的状态到一个临时文件，这个过程称为RDB（Redis Database）快照。</strong></li><li><strong>传输RDB文件</strong>：主服务器将<strong>生成的RDB文件</strong>发送给从服务器。</li><li><strong>从服务器接收并应用RDB文件</strong>：从服务器接收RDB文件后，会清空当前的数据集，并载入RDB文件中的数据。</li><li><strong>主服务器记录写命令</strong>：在RDB文件生成和传输期间，主服务器会<strong>记录所有接收到的写命令到<code>replication backlog buffer</code>。</strong></li><li><strong>传输写命令</strong>：一旦RDB文件传输完成，主服务器会将<code>replication backlog buffer</code>中的命令发送给从服务器，从服务器会执行这些命令，以保证数据的一致性。</li></ol><blockquote><p>增量同步</p></blockquote><p>增量同步允许从服务器从断点处继续同步，而不是每次都进行完全同步。它基于<code>PSYNC</code>命令，使用了<strong>运行ID（run ID）和复制偏移量（offset）的概念。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1720157758362-f61b89b5-5194-4d63-8cbd-f00ca524a417.png" alt="img"></p><p>主要有三个步骤：</p><ul><li>从服务器在恢复网络后，会发送 psync 命令给主服务器，<strong>此时的 psync 命令里的 offset 参数不是 -1；</strong></li><li>主服务器收到该命令后，然后用 <strong>CONTINUE 响应</strong>命令告诉从服务器接下来采用增量复制的方式同步数据；</li><li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li></ul><p>那么关键的问题来了，<strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong></p><p>答案藏在这两个东西里：</p><ul><li><strong>repl_backlog_buffer</strong>，是一个「<strong>环形</strong>」缓冲区，用于主从服务器断连后，从中找到差异的数据；</li><li><strong>replication offset</strong>，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 <strong>master_repl_offset 来记录自己「<em>写</em>」到的位置，从服务器使用 slave_repl_offset 来记录自己「<em>读</em>」到的位置。</strong></li></ul><p>那 repl_backlog_buffer 缓冲区是什么时候写入的呢？</p><p>在主服务器进行命令传播时，<strong>不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里</strong>，因此 这个缓冲区里会保存着最近传播的写命令。</p><p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 <strong>psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</strong></p><ul><li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</li><li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式。</li></ul><p>当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720157935326-a9eb173d-e938-4144-8b9e-c5120ebc39fe.png" alt="img"></p><p><strong>repl_backlog_buffer 缓行缓冲区的默认大小是 1M</strong>，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。</p><p>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。</p><p>因此，<strong>为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些</strong>，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。</p><h2 id="4-redis主从和集群可以保证数据一致性吗-？"><a href="#4-redis主从和集群可以保证数据一致性吗-？" class="headerlink" title="4.redis主从和集群可以保证数据一致性吗 ？"></a>4.redis主从和集群可以保证数据一致性吗 ？</h2><p>redis 主从和集群在CAP理论都属于AP模型，即在面临网络分区时选择保证可用性和分区容忍性，而牺牲了强一致性。这意味着在网络分区的情况下，<strong>Redis主从复制和集群可以继续提供服务并保持可用，但可能会出现部分节点之间的数据不一致。</strong></p><h2 id="5-哨兵机制原理是什么？"><a href="#5-哨兵机制原理是什么？" class="headerlink" title="5.哨兵机制原理是什么？"></a>5.哨兵机制原理是什么？</h2><p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720094217984-6192d46c-16ba-47d2-a58d-ee8ddb1d49de.png" alt="img"></p><p>这时如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。</p><p>这样也不太“智能”了，要是有一个节点能监控「主节点」的状态，当发现主节点挂了，它自动将一个「从节点」切换为「主节点」的话，那么可以节省我们很多事情啊！</p><p>Redis 在 2.8 版本以后提供的<strong>哨兵（\</strong>*<em>\</em>Sentinel**<em>*<em>）机制<strong>，它的作用是实现</strong>主从节点故障转移<strong>。它会</strong>监测主节点是否存活</em></em>，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p><p>哨兵其实是一个运行在特殊模式下的 Redis 进程，<strong>所以它也是一个节点。从“哨兵”这个名字也可以看得出来，它相当于是“观察者节点”，观察的对象是主从节点。</strong></p><p>当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些“动作”，来修复异常状态。</p><p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720094217511-32046190-a2ec-4e4a-8ee4-9c51db2731e0.png" alt="img"></p><h2 id="7-哨兵机制的选主节点的算法介绍一下"><a href="#7-哨兵机制的选主节点的算法介绍一下" class="headerlink" title="7.哨兵机制的选主节点的算法介绍一下"></a>7.哨兵机制的选主节点的算法介绍一下</h2><p>当redis集群的主节点故障时，Sentinel集群将从剩余的从节点中选举一个新的主节点，有以下步骤：</p><ol><li>故障节点主观下线</li><li>故障节点客观下线</li><li>Sentinel集群选举Leader</li><li>Sentinel Leader决定新主节点</li></ol><blockquote><ol><li>故障节点主观下线</li></ol></blockquote><p>Sentinel集群的每一个Sentinel节点会定时对redis集群的所有节点发心跳包检测节点是否正常。<strong>如果一个节点在down-after-milliseconds时间内没有回复Sentinel节点的心跳包，则该redis节点被该Sentinel节点主观下线。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1720159516741-7b080ad9-a776-48b5-b8e4-73c5b532aae9.png" alt="img"></p><blockquote><ol><li>故障节点客观下线</li></ol></blockquote><p>当节点被一个Sentinel节点记为主观下线时，并不意味着该节点肯定故障了，<strong>还需要Sentinel集群的其他Sentinel节点共同判断为主观下线才行。</strong></p><p>该Sentinel节点会询问其他Sentinel节点，如果Sentinel集群中<strong>超过quorum</strong>数量的Sentinel节点认为该redis节点主观下线，则该redis<strong>客观下线</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720159526929-d21d0b01-4ed9-4af7-8278-9d7fbdc4db3b.png" alt="img"></p><p>如果客观下线的redis节点是从节点或者是Sentinel节点，则操作到此为止，没有后续的操作了；如果客观下线的redis节点为主节点，则开始故障转移，从从节点中选举一个节点升级为主节点。</p><blockquote><ol><li>Sentinel集群选举Leader</li></ol></blockquote><p>如果需要从redis集群选举一个节点为主节点，首先需要从Sentinel集群中选举<strong>一个Sentinel节点作为Leader。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1720159546681-cd1809f4-6bbf-44e7-8486-480732e2f5d1.png" alt="img"></p><p>每一个Sentinel节点都可以成为Leader，<strong>当一个Sentinel节点确认redis集群的主节点主观下线后，会请求其他Sentinel节点要求将自己选举为Leader。</strong>被请求的Sentinel节点如果没有同意过其他Sentinel节点的选举请求，则同意该请求(选举票数+1)，否则不同意。</p><p>如果一个Sentinel节点获得的选举票数达到<strong>Leader最低票数(quorum和Sentinel节点数/2+1的最大值)</strong>，则该Sentinel节点选举为Leader；否则重新进行选举。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720159392994-8e2afcb1-d84c-499d-9737-b4ddeeab50c1.png" alt="img"></p><p>举个例子，假设哨兵节点有 3 个，quorum 设置为 2，那么任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以选举成功了。如果没有满足条件，就需要重新进行选举。</p><blockquote><ol><li>Sentinel Leader决定新主节点</li></ol></blockquote><p>当Sentinel集群选举出Sentinel Leader后，由<strong>Sentinel Leader从redis从节点中选择一个redis节点作为主节点：</strong></p><ol><li>过滤故障的节点</li><li>选择<strong>优先级slave-priority最大的从节点</strong>作为主节点，如不存在则继续</li><li>选择<strong>复制偏移量</strong>（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）<strong>最大的从节点作为主节点</strong>，如不存在则继续</li><li>选择<strong>runid（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点</strong></li></ol><p><img src="https://cdn.xiaolincoding.com//picgo/1720159431029-d93622d5-1c95-4999-b775-6c14b5d41849.png" alt="img"></p><h2 id="8-Redis集群的模式了解吗-优缺点了解吗"><a href="#8-Redis集群的模式了解吗-优缺点了解吗" class="headerlink" title="8.Redis集群的模式了解吗 优缺点了解吗"></a>8.Redis集群的模式了解吗 优缺点了解吗</h2><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><p>Redis Cluster 方案采用<strong>哈希槽</strong>（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p><ul><li>根据键值对的 key，按照 <strong>CRC16 算法计算一个 16 bit</strong> 的值。</li><li>再用 <strong>16bit 值对 16384 取模</strong>，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ul><p>接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p><ul><li><strong>平均分配：</strong> 在使用 cluster create 命令创建 Redis 集群时，<strong>Redis 会自动把所有哈希槽平均分布到集群节点上。</strong>比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。</li><li><strong>手动分配：</strong> 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li></ul><p>为了方便你的理解，我通过一张图来解释数据、哈希槽，以及节点三者的映射分布关系。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719903649434-ba6ceaf6-adaf-4245-80de-b5e05ea44804.png" alt="img"></p><p>上图中的切片集群一共有 2 个节点，假设有 4 个哈希槽（Slot 0～Slot 3）时，我们就可以通过命令手动分配哈希槽，比如<strong>节点 1 保存哈希槽 0 和 1，</strong>节点 2 保存哈希槽 2 和 3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span> –p <span class="number">6379</span> cluster addslots <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">redis-cli -h <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span> –p <span class="number">6379</span> cluster addslots <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><p>然后在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到哈希槽 1（对应节点1） 和 哈希槽 2（对应节点2）。</p><p>需要注意的是，<strong>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</strong></p><blockquote><p>Redis集群模式优点/缺点</p></blockquote><p>优点：</p><ul><li><strong>高可用性</strong>：Redis集群最主要的优点是提供了高可用性，节点之间采用主从复制机制，可以保证数据的持久性和容错能力，哪怕其中一个节点挂掉，整个集群还可以继续工作。</li><li><strong>高性能：</strong>Redis集群采用<strong>分片技术</strong>，将数据分散到多个节点，从而提高读写性能。当业务访问量大到单机Redis无法满足时，可以通过添加节点来增加集群的吞吐量。</li><li><strong>扩展性好：</strong>Redis集群的扩展性非常好，可以<strong>根据实际需求动态增加或减少节点，从而实现可扩展性。</strong>集群模式中的某些节点还可以作为代理节点，自动转发请求，增加数据模式的灵活度和可定制性。</li></ul><p>缺点：</p><ul><li><strong>部署和维护较复杂：</strong>Redis集群的部署和维护需要考虑到分片规则、节点的布置、主从配置以及故障处理等多个方面，需要较强的技术支持，增加了节点异常处理的复杂性和成本。</li><li><strong>集群同步问题：</strong>当某些节点失败或者网络出故障，集群中数据同步的问题也会出现。数据同步的复杂度和工作量随着节点的增加而增加，同步时间也较长，导致一定的读写延迟。</li><li><strong>数据分片限制：</strong>Redis集群的数据分片也限制了一些功能的实现，<strong>如在一个key上修改多次，可能会因为该key所在的节点位置变化而失败。</strong>此外，由于将数据分散存储到各个节点，某些操作不能跨节点实现，不同节点之间的一些操作需要额外注意。</li></ul><h2 id="9-为什么用redisson代替setnx，redisson如何解决超时释放问题的？"><a href="#9-为什么用redisson代替setnx，redisson如何解决超时释放问题的？" class="headerlink" title="9.为什么用redisson代替setnx，redisson如何解决超时释放问题的？"></a>9.为什么用redisson代替setnx，redisson如何解决超时释放问题的？</h2><p>普通的setnx+expire:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">lockSuccess</span> <span class="operator">=</span> redis.setnx(<span class="string">&quot;lock:key&quot;</span>, <span class="string">&quot;UUID&quot;</span>); <span class="comment">// 设置锁</span></span><br><span class="line"><span class="keyword">if</span> (lockSuccess) &#123;</span><br><span class="line">    redis.expire(<span class="string">&quot;lock:key&quot;</span>, <span class="number">10</span>); <span class="comment">// 设置过期时间，防止死锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并不是原子性的，释放锁不安全，业务处理时长比锁时间长的话，锁会自动释放</p><p>redisson：</p><p>原子操作：</p><p>Redisson 使用 Lua 脚本实现加锁逻辑，使得 <strong>加锁+设置过期时间是原子操作</strong>，完全避免了 <code>setnx+expire</code> 之间的非原子问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span> then</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自动续期机制（WatchDog）：</p><p>默认锁的过期时间是 30 秒，同时有一个“看门狗 WatchDog 机制”：</p><ul><li>如果业务未完成，Redisson 会每隔 10 秒自动给锁续期（只针对 Redisson 默认锁）。</li><li>防止业务执行超时锁被释放的情况。</li></ul><blockquote><p>注意：只有在你没有手动指定锁的 leaseTime 时，才会启用看门狗</p></blockquote><p>安全释放锁：</p><p>Redisson 释放锁也使用 Lua 脚本判断<strong>是否是自己加的锁再释放</strong>，防止误删别人的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="1-你用zset来实现点赞排行榜，现在有两个用户都是100个赞，怎么实现让先到100个赞的用户排在前面？"><a href="#1-你用zset来实现点赞排行榜，现在有两个用户都是100个赞，怎么实现让先到100个赞的用户排在前面？" class="headerlink" title="1.你用zset来实现点赞排行榜，现在有两个用户都是100个赞，怎么实现让先到100个赞的用户排在前面？"></a>1.你用zset来实现点赞排行榜，现在有两个用户都是100个赞，怎么实现让先到100个赞的用户排在前面？</h2><p>在 Redis 的 <code>ZSet</code>（有序集合）中，<strong>分数（score）相同的成员排序是不稳定的</strong>，因为 Redis 并不会保证 score 相同的元素按插入顺序排序。</p><p>使用复合 score，或者打包技巧来解决</p><p>1.复合分数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复合 score = 点赞数 * 1_000_000_000 - 时间戳</span><br></pre></td></tr></table></figure><p>点赞数越高，score 越大</p><p>时间戳越早，减得越多，score 越大 → 排前面</p><p>时间戳必须是毫秒级或秒级时间戳</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时间（秒级或毫秒级）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 毫秒</span></span><br><span class="line"><span class="type">int</span> <span class="variable">likes</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造复合分数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> likes * <span class="number">1_000_000_000L</span> - now;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入 ZSet 排行榜</span></span><br><span class="line">redisTemplate.opsForZSet().add(<span class="string">&quot;like:rank&quot;</span>, userId, score);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>排序依然是 <code>ZREVRANGE</code>（从大到小）</p><p>以点赞数为主，时间戳倒序为辅，构造唯一、稳定排序的分值。这种方式在排行榜、签到、热度榜等场景非常常见。</p><h2 id="2-为什么使用redis？"><a href="#2-为什么使用redis？" class="headerlink" title="2.为什么使用redis？"></a>2.为什么使用redis？</h2><p>主要是因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p><blockquote><p>1、Redis 具备高性能</p></blockquote><p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。<strong>将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，</strong>操作 Redis 缓存就是直接操作内存，所以速度相当快。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719295874540-61b4d9a2-df45-4992-958c-c8d5571de76b-20240725232737123.png" alt="img"></p><p>如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题。</p><blockquote><p>2、 Redis 具备高并发</p></blockquote><p>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p><p>所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，<strong>所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</strong></p><h2 id="3-为什么redis比mysql要快？"><a href="#3-为什么redis比mysql要快？" class="headerlink" title="3.为什么redis比mysql要快？"></a>3.为什么redis比mysql要快？</h2><ul><li><strong>内存存储</strong>：Redis 是基于内存存储的 NoSQL 数据库，而 MySQL 是基于磁盘存储的关系型数据库。由于内存存储速度快，Redis 能够更快地读取和写入数据，而无需像 MySQL 那样频繁进行磁盘 I/O 操作。</li><li><strong>简单数据结构</strong>：Redis 是基于<strong>键值对</strong>存储数据的，支持简单的数据结构（字符串、哈希、列表、集合、有序集合）。相比之下，MySQL 需要定义表结构、索引等复杂的关系型数据结构，因此在某些场景下 Redis 的数据操作更为简单高效，比如 Redis 用哈希表查询， 只需要O1 时间复杂度，而MySQL引擎的底层实现是B+Tree，时间复杂度是O(logn)</li><li><strong>线程模型</strong>：Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li></ul><h2 id="4-本地缓存和Redis缓存的区别"><a href="#4-本地缓存和Redis缓存的区别" class="headerlink" title="4.本地缓存和Redis缓存的区别?"></a>4.本地缓存和Redis缓存的区别?</h2><p><strong>本地缓存</strong>是指将数据存储在本地应用程序或服务器上，通常用于加速数据访问和提高响应速度。<strong>本地缓存</strong>通常使用内存作为存储介质，利用<strong>内存的高速读写特性</strong>来提高数据访问速度。</p><p>本地缓存的优势：</p><ul><li>访问速度快：由于本地缓存存储在本地内存中，因此访问速度非常快，能够满足频繁访问和即时响应的需求。</li><li>减轻网络压力：本地缓存能够降低对远程服务器的访问次数，从而减轻网络压力，提高系统的可用性和稳定性。</li><li>低延迟：由于本地缓存位于本地设备上，因此能够提供低延迟的访问速度，适用于对实时性要求较高的应用场景。</li></ul><p>本地缓存的不足：</p><ul><li>可扩展性有限：本地缓存的可扩展性受到硬件资源的限制，无法支持大规模的数据存储和访问。</li></ul><p><strong>分布式缓存（</strong>Redis<strong>）</strong>是指将数据<strong>存储在多个分布式节点上，通过协同工作来提供高性能的数据访问服务。分布式缓存通常使用集群方式进行部署</strong>，利用多台服务器来分担数据存储和访问的压力。</p><p>分布式缓存的优势：</p><ul><li>可扩展性强：分布式缓存的节点可以动态扩展，能够支持大规模的数据存储和访问需求。</li><li>数据一致性高：通过分布式一致性协议，分布式缓存能够保证数据在多个节点之间的一致性，减少数据不一致的问题。</li><li>易于维护：分布式缓存通常采用自动化管理方式，能够降低维护成本和管理的复杂性。</li></ul><p>分布式缓存的不足：</p><ul><li>访问速度相对较慢：相对于本地缓存，分布式缓存的访问速度相对较慢，因为数据需要从多个节点进行访问和协同。</li><li>网络开销大：由于分布式缓存需要通过网络进行数据传输和协同操作，因此相对于本地缓存来说，网络开销较大。</li></ul><p>在选择使用本地缓存还是分布式缓存时，我们需要根据具体的应用场景和需求进行权衡。以下是一些考虑因素：</p><ul><li>数据大小：如果数据量较小，且对实时性要求较高，本地缓存更适合；如果数据量较大，且需要支持大规模的并发访问，分布式缓存更具优势。</li><li>网络状况：如果网络状况良好且稳定，分布式缓存能够更好地发挥其优势；如果网络状况较差或不稳定，本地缓存的访问速度和稳定性可能更有优势。</li><li>业务特点：对于实时性要求较</li></ul><h2 id="5-高并发场景，Redis单节点-MySQL单节点能有多大的并发量？"><a href="#5-高并发场景，Redis单节点-MySQL单节点能有多大的并发量？" class="headerlink" title="5.高并发场景，Redis单节点+MySQL单节点能有多大的并发量？"></a>5.高并发场景，Redis单节点+MySQL单节点能有多大的并发量？</h2><ul><li>如果缓存命中的话，4 核心 8g 内存的配置，redis 可以支撑 10w 的 qps</li><li>如果缓存没有命中的话，4 核心 8g 内存的配置，mysql 只能支持 5000 左右的 qps</li></ul><p>所以要防止缓存穿透，使用接口来防护，或者使用布隆过滤器</p><h2 id="6-redis应用场景是什么？"><a href="#6-redis应用场景是什么？" class="headerlink" title="6.redis应用场景是什么？"></a>6.redis应用场景是什么？</h2><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p><ul><li><strong>缓存</strong>: Redis最常见的用途就是作为缓存系统。通过将热门数据存储在内存中，可以极大地提高访问速度，减轻数据库负载，这对于需要快速响应时间的应用程序非常重要。</li><li><strong>排行榜</strong>: Redis的有序集合结构非常适合用于实现排行榜和排名系统，可以方便地进行数据排序和排名。</li><li><strong>分布式锁</strong>: Redis的特性可以用来实现分布式锁，确保多个进程或服务之间的数据操作的原子性和一致性。</li><li><strong>计数器</strong> 由于Redis的原子操作和高性能，它非常适合用于实现计数器和统计数据的存储，如网站访问量统计、点赞数统计等。</li><li><strong>消息队列</strong>: Redis的发布订阅功能使其成为一个轻量级的消息队列，它可以用来实现发布和订阅模式，以便实时处理消息。</li></ul><h2 id="7-Redis除了缓存，还有哪些应用"><a href="#7-Redis除了缓存，还有哪些应用" class="headerlink" title="7.Redis除了缓存，还有哪些应用?"></a>7.Redis除了缓存，还有哪些应用?</h2><p><strong>Redis实现消息队列</strong></p><ul><li><strong>使用Pub/Sub模式：</strong>Redis的Pub/Sub是一种基于发布/订阅的消息模式，任何客户端都可以订阅一个或多个频道，发布者可以向特定频道发送消息，所有订阅该频道的客户端都会收到此消息。该方式实现起来比较简单，发布者和订阅者完全解耦，支持模式匹配订阅。但是这种方式不支持消息持久化，消息发布后若无订阅者在线则会被丢弃；不保证消息的顺序和可靠性传输。</li><li><strong>使用List结构</strong>：使用List的方式通常是使用<code>LPUSH</code>命令将消息推入一个列表，消费者使用<code>BLPOP</code>或<code>BRPOP</code>阻塞地从列表中取出消息（先进先出FIFO）。这种方式可以实现简单的任务队列。这种方式可以结合Redis的过期时间特性实现消息的TTL；通过Redis事务可以保证操作的原子性。但是需要客户端自己实现消息确认、重试等机制，相比专门的消息队列系统功能较弱。</li></ul><p><strong>Redis实现分布式锁</strong></p><ul><li><strong>set nx方式</strong>：Redis提供了几种方式来实现分布式锁，最常用的是<strong>基于<code>SET</code>命令的争抢锁机</strong>制。客户端可以使用<code>SET resource_name lock_value NX PX milliseconds</code>命令设置锁，其中<strong><code>NX</code>表示只有当键不存在时才设置，<code>PX</code>指定锁的有效时间（毫秒）</strong>。如果设置成功，则认为客户端获得锁。客户端完成操作后，<strong>解锁的还需要先判断锁是不是自己，再进行删除，这里涉及到 2 个操作，为了保证这两个操作的原子性，可以用 lua 脚本来实现。</strong></li></ul><ul><li><strong>RedLock算法：</strong>为了提高分布式锁的可靠性，Redis作者Antirez提出了RedLock算法，它基于<strong>多个独立的Redis实例来实现一个更安全的分布式锁</strong>。它的基本原理是客户端尝试在多数（大于半数）Redis实例上同时加锁，<strong>只有当在大多数实例上加锁成功时才认为获取锁成功。锁的超时时间应该远小于单个实例的超时时间，以避免死锁。该方式可以通过跨多个节点减少单点故障的影响，提高了锁的可用性和安全性。</strong></li></ul><h2 id="8-Redis支持并发操作吗？"><a href="#8-Redis支持并发操作吗？" class="headerlink" title="8.Redis支持并发操作吗？"></a>8.Redis支持并发操作吗？</h2><ul><li><strong>单个 Redis 命令的原子性</strong>：Redis 的单个命令是原子性的，这意味着一个命令要么完全执行成功，要么完全不执行，确保操作的一致性。这对于并发操作非常重要。</li><li><strong>多个操作的事务</strong>：Redis 支持事务，可以将一系列的操作放在一个事务中执行，使用 MULTI、EXEC、DISCARD 和 WATCH 等命令来管理事务。这样可以确保一系列操作的原子性。</li></ul><h2 id="9-Redis分布式锁的实现原理？什么场景下用到分布式锁？"><a href="#9-Redis分布式锁的实现原理？什么场景下用到分布式锁？" class="headerlink" title="9.Redis分布式锁的实现原理？什么场景下用到分布式锁？"></a>9.Redis分布式锁的实现原理？什么场景下用到分布式锁？</h2><p><strong>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用</strong>。如下图所示：<img src="https://cdn.xiaolincoding.com//picgo/1719108636409-6ff3328a-f0fb-4028-82ee-059b4f548a8a.webp" alt="img">Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。<strong>Redis 的 SET</strong> 命令有个 <strong>NX</strong> 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p><ul><li>加锁包括了<strong>读取锁变量、检查锁变量值和设置锁变量值</strong>三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 <strong>EX/PX</strong> 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，<strong>每个客户端设置的值是一个唯一值，用于标识客户端；</strong></li></ul><p>满足这三个条件的分布式命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure><ul><li>lock_key 就是 key 键；</li><li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li><li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li><li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li></ul><p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，<strong>解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</strong></p><p>可以看到，解锁是有两个操作，这时就需要 <strong>Lua 脚本</strong>来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p><h2 id="10-Redis的大Key问题是什么？"><a href="#10-Redis的大Key问题是什么？" class="headerlink" title="10.Redis的大Key问题是什么？"></a>10.Redis的大Key问题是什么？</h2><p>edis大key问题指的是某个key对应的value值所占的内存空间比较大，导致Redis的性能下降、内存不足、数据不均衡以及主从同步延迟等问题。</p><p>到底多大的数据量才算是大key？</p><p>没有固定的判别标准，通常认为<strong>字符串类型的key对应的value值占用空间大于1M，或者集合类型的k元素数量超过1万个，就算是大key。</strong></p><p>Redis大key问题的定义及评判准则并非一成不变，而应根据Redis的实际运用以及业务需求来综合评估。</p><p>例如，在高并发且低延迟的场景中，仅10kb可能就已构成大key；然而在低并发、高容量的环境下，大key的界限可能在100kb。因此，在设计与运用Redis时，要依据业务需求与性能指标来确立合理的大key阈值。</p><h2 id="11-大Key问题的缺点？"><a href="#11-大Key问题的缺点？" class="headerlink" title="11.大Key问题的缺点？"></a>11.大Key问题的缺点？</h2><ul><li>内存占用过高。大Key占用过多的内存空间，可能导致可用内存不足，从而触发内存淘汰策略。在极端情况下，可能导致内存耗尽，Redis实例崩溃，影响系统的稳定性。</li><li>性能下降。大Key会占用大量内存空间，导致内存碎片增加，进而影响Redis的性能。对于大Key的操作，如读取、写入、删除等，都会消耗更多的CPU时间和内存资源，进一步降低系统性能。</li><li>阻塞其他操作。某些对大Key的操作可能会导致Redis实例阻塞。例如，使用DEL命令删除一个大Key时，可能会导致Redis实例在一段时间内无法响应其他客户端请求，从而影响系统的响应时间和吞吐量。</li><li>网络拥塞。每次获取大key产生的网络流量较大，可能造成机器或局域网的带宽被打满，同时波及其他服务。例如：一个大key占用空间是1MB，每秒访问1000次，就有1000MB的流量。</li><li>主从同步延迟。当Redis实例配置了主从同步时，大Key可能导致主从同步延迟。由于大Key占用较多内存，同步过程中需要传输大量数据，这会导致主从之间的网络传输延迟增加，进而影响数据一致性。</li><li>数据倾斜。在Redis集群模式中，<strong>某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡</strong>。另外也可能造成Redis内存达到maxmemory参数定义的上限导致重要的key被逐出，甚至引发内存溢出。</li></ul><h2 id="12-Redis大key如何解决？"><a href="#12-Redis大key如何解决？" class="headerlink" title="12.Redis大key如何解决？"></a>12.Redis大key如何解决？</h2><ul><li>对大Key进行拆分。例如将含有数万成员的一个HASH Key拆分为多个HASH Key，并确保每个Key的成员数量在合理范围。<strong>在Redis集群架构中，拆分大Key能对数据分片间的内存平衡起到显著作用。</strong></li><li>对大Key进行清理。将<strong>不适用Redis能力的数据存至其它存储</strong>，并在Redis中删除此类数据。注意，要使用<strong>异步删除</strong>。在后台线程进行删除</li><li>监控Redis的内存水位。可以通过监控系统设置<strong>合理的Redis内存报警阈值</strong>进行提醒，例如Redis内存使用率超过70%、Redis的内存在1小时内增长率超过20%等。</li><li>对过期数据进<strong>行定期清</strong>。堆积大量过期数据会造成大Key的产生，例如在HASH数据类型中以增量的形式不断写入大量数据而忽略了数据的时效性。可以通过定时任务的方式对失效数据进行清理。</li></ul><h2 id="13-什么是热key？"><a href="#13-什么是热key？" class="headerlink" title="13.什么是热key？"></a>13.什么是热key？</h2><p>通常以其接收到的Key被请求频率来判定，例如：</p><ul><li><strong>QPS集中在特定的Key</strong>：Redis实例的总QPS（每秒查询率）为10,000，而其中一个Key的每秒访问量达到了7,000。</li><li>带宽使用率集中在特定的Key：对一个拥有上千个成员且总大小为1 MB的HASH Key每秒发送大量的<strong>HGETALL</strong>操作请求。</li><li>CPU使用时间占比集中在特定的Key：对一个拥有数万个成员的Key（ZSET类型）每秒发送大量的<strong>ZRANGE</strong>操作请求。</li></ul><h2 id="14-如何解决热key问题？"><a href="#14-如何解决热key问题？" class="headerlink" title="14.如何解决热key问题？"></a>14.如何解决热key问题？</h2><ul><li>在Redis集群架构中对<strong>热Key进行复制</strong>。在Redis集群架构中，由于热Key的迁移粒度问题，无法将请求分散至其他数据分片，导致单个数据分片的压力无法下降。此时，<strong>可以将对应热Key进行复制并迁移至其他数据分片</strong>，例如将热Key foo复制出3个内容完全一样的Key并名为foo2、foo3、foo4，将这三个Key迁移到其他数据分片来解决单个数据分片的热Key压力。</li><li>使用<strong>读写分离架构</strong>。如果热Key的产生来自于读请求，您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加Redis集群架构复杂度。不仅要为多个从节点提供转发层（如Proxy，LVS等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。Redis集群架构变更会为监控、运维、故障处理带来了更大的挑战。</li></ul><h2 id="15-如何保证-redis-和-mysql-数据缓存一致性问题？"><a href="#15-如何保证-redis-和-mysql-数据缓存一致性问题？" class="headerlink" title="15.如何保证 redis 和 mysql 数据缓存一致性问题？"></a>15.如何保证 redis 和 mysql 数据缓存一致性问题？</h2><p>对于读数据，我会选择<strong>旁路缓存策略</strong>，<strong>如果 cache 不命中，会从 db 加载数据到 cache。对于写数据，我会选择更新 db 后，再删除缓存。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1720197145123-7e06f9a4-fcc7-42cc-a3d2-c44af4a73214.webp" alt="img"></p><p>缓存是通过<strong>牺牲强一致性</strong>来提高性能的。这是由<strong>CAP理论</strong>决定的。缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。所以，如果需要数据库和缓存数据保持强一致，就不适合使用缓存。</p><p>所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后<strong>缓存一定要设置过期时间</strong>，这个时间太短、或者太长都不好：</p><ul><li>太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。</li><li>太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。</li></ul><p>但是，通过一些方案优化处理，是可以<strong>最终一致性</strong>的。</p><p>针对删除缓存异常的情况，可以使用 2 个方案避免：</p><ul><li>删除缓存重试策略（消息队列）</li><li>订阅 binlog，再删除缓存（Canal+消息队列）</li></ul><blockquote><p>消息队列方案</p></blockquote><p>我们可以引入<strong>消息队列</strong>，将<strong>第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</strong></p><ul><li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li><li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li></ul><p>举个例子，来说明重试机制的过程。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720223533280-96461154-bd99-418c-bc90-52a90bc70cac.webp" alt="img"></p><p>重试删除缓存机制还可以，就是会<strong>造成好多业务代码入侵</strong>。</p><blockquote><p>订阅 MySQL binlog，再操作缓存</p></blockquote><p>「<strong>先更新数据库，再删缓存</strong>」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p><p>于是我们就可以通过<strong>订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除</strong>，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p><p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p><p>下图是 Canal 的工作原理：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720223533277-56afc647-23ee-436c-a99a-ed4a338d07fc.webp" alt="img"></p><p><strong>将binlog日志采集发送到MQ队列里面，然后编写一个简单的缓存删除消息者订阅binlog日志，根据更新log删除缓存，并且通过ACK机制确认处理这条更新log，保证数据缓存一致性</strong></p><p>总结起来的方法是：</p><p>1.延迟双删策略：先删缓存 → 更新数据库 → 延迟一段时间再删缓存</p><p>注意：需考虑缓存雪崩、延迟失败等问题，可配合消息队列或定时任务增强可靠性</p><p>订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除</p><p>2.异步消息队列：数据库更新成功后，将操作消息发到 MQ，消费者异步更新或删除 Redis 缓存</p><p>注意：MQ 丢消息或消费失败需处理（如用 RocketMQ 的事务消息）</p><p>3.<strong>强一致性场景用分布式事务</strong>（如 Seata、TCC）</p><p>比如金融系统对一致性要求极高，可以引入分布式事务中间件，确保数据库和缓存操作成功或失败要么都执行，要么都回滚</p><p>最好的是延迟双删+消息队列，将binlog日志采集发送到MQ队列里面，然后编写一个简单的缓存删除消息者订阅binlog日志，根据更新log删除缓存，并且通过ACK机制确认处理这条更新log，保证数据缓存一致性</p><h2 id="16-布隆过滤器原理介绍一下"><a href="#16-布隆过滤器原理介绍一下" class="headerlink" title="16.布隆过滤器原理介绍一下"></a>16.布隆过滤器原理介绍一下</h2><p>布隆过滤器由<strong>「初始值都为 0 的位图数组」和「 N 个哈希函数」</strong>两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到<strong>每个哈希值在位图数组的对应位置。</strong></li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719903580960-2490c9c0-616b-4b11-a290-4891c2d7511a.png" alt="img"></p><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/redis/">redis</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/15/java-stack/redis2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode双指针</title>
      <link>https://blog.tokenlen.top/2025/05/12/leetcode/leetcode3/</link>
      <guid>https://blog.tokenlen.top/2025/05/12/leetcode/leetcode3/</guid>
      <pubDate>Sun, 11 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;相向双指针&quot;&gt;&lt;a href=&quot;#相向双指针&quot; class=&quot;headerlink&quot; title=&quot;相向双指针&quot;&gt;&lt;/a&gt;相向双指针&lt;/h1&gt;&lt;p&gt;两个指针 &lt;em&gt;left&lt;/em&gt;=0,</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h1><p>两个指针 <em>left</em>=0, <em>right</em>=<em>n</em>−1，从数组的两端开始，向中间移动，这叫<strong>相向双指针</strong>。上面的滑动窗口相当于<strong>同向双指针</strong>。</p><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution344</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left=<span class="number">0</span>,right=n-<span class="number">1</span>;left&lt;right;left++,right--)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单的双指针解决</p><p>就是让头和尾互换值就ok了</p><h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h2><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution125</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(left)))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!Character.isLetterOrDigit(s.charAt(right)))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Character.toLowerCase(s.charAt(left))==Character.toLowerCase(s.charAt(right)))&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到数字啥的就跳过</p><p>如果left与right转成小写相等的话，就继续往前，这样就可以转成回文</p><p>然后没有的话，就为false</p><h2 id="1750-删除字符串两端相同字符后的最短长度"><a href="#1750-删除字符串两端相同字符后的最短长度" class="headerlink" title="1750. 删除字符串两端相同字符后的最短长度"></a><a href="https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/">1750. 删除字符串两端相同字符后的最短长度</a></h2><p>给你一个只包含字符 <code>&#39;a&#39;</code>，<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 的字符串 <code>s</code> ，你可以执行下面这个操作（5 个步骤）任意次：</p><ol><li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的前缀，这个前缀的所有字符都相同。</li><li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的后缀，这个后缀的所有字符都相同。</li><li>前缀和后缀在字符串中任意位置都不能有交集。</li><li>前缀和后缀包含的所有字符都要相同。</li><li>同时删除前缀和后缀。</li></ol><p>请你返回对字符串 <code>s</code> 执行上面操作任意次以后（可能 0 次），能得到的 <strong>最短长度</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1750</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLength</span><span class="params">(String S)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right&amp;&amp;s[left]==s[right])&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[left];</span><br><span class="line">            <span class="keyword">while</span> (left&lt;=right&amp;&amp;s[left]==c) left++;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;=right&amp;&amp;s[right]==c) right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的双指针问题，最后剩下的窗口的长度就是最后的</p><p>代码</p><p>测试用例</p><p>测试结果</p><p>测试结果</p><h2 id="2105-给植物浇水-II"><a href="#2105-给植物浇水-II" class="headerlink" title="2105. 给植物浇水 II"></a><a href="https://leetcode.cn/problems/watering-plants-ii/">2105. 给植物浇水 II</a></h2><p>Alice 和 Bob 打算给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。</p><p>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，<strong>最初是满的</strong> 。他们按下面描述的方式完成浇水：</p><ul><li>Alice 按 <strong>从左到右</strong> 的顺序给植物浇水，从植物 <code>0</code> 开始。Bob 按 <strong>从右到左</strong> 的顺序给植物浇水，从植物 <code>n - 1</code> 开始。他们 <strong>同时</strong> 给植物浇水。</li><li>无论需要多少水，为每株植物浇水所需的时间都是相同的。</li><li>如果 Alice/Bob 水罐中的水足以 <strong>完全</strong> 灌溉植物，他们 <strong>必须</strong> 给植物浇水。否则，他们 <strong>首先</strong>（立即）重新装满罐子，然后给植物浇水。</li><li>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水 <strong>更多</strong> 的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。</li></ul><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有两个整数 <code>capacityA</code> 和 <code>capacityB</code> 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 <strong>次数</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2105</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumRefill</span><span class="params">(<span class="type">int</span>[] plants, <span class="type">int</span> capacityA, <span class="type">int</span> capacityB)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> capacityA;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> capacityB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j = plants.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a&lt;plants[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                a = capacityA;</span><br><span class="line">            &#125;</span><br><span class="line">            a -=plants[i++];</span><br><span class="line">            <span class="keyword">if</span> (b&lt;plants[j])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                b  = capacityB;</span><br><span class="line">            &#125;</span><br><span class="line">            b -=plants[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==j&amp;&amp;Math.max(a,b)&lt;plants[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看他们一个从左开始一个从右开始</p><p>一看就是相向双指针</p><p>如果水不够，就再装一瓶</p><p>够的话，就直接交就行</p><p>然后相遇的时候i=j了，直接比大小就行</p><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution977</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span>n-<span class="number">1</span>;p&gt;=<span class="number">0</span>;p--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i]* nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> nums[j]*nums[j];</span><br><span class="line">            <span class="keyword">if</span> (x&gt;y)&#123;</span><br><span class="line">                ans[p] = x;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans[p] = y;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的双指针，从后面开始遍历，大的就留下，然后指针移动</p><p>最后返回ans数组</p><h2 id="658-找到-K-个最接近的元素"><a href="#658-找到-K-个最接近的元素" class="headerlink" title="658. 找到 K 个最接近的元素"></a><a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></h2><p>给定一个 <strong>排序好</strong> 的数组 <code>arr</code> ，两个整数 <code>k</code> 和 <code>x</code> ，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。</p><p>整数 <code>a</code> 比整数 <code>b</code> 更接近 <code>x</code> 需要满足：</p><ul><li><code>|a - x| &lt; |b - x|</code> 或者</li><li><code>|a - x| == |b - x|</code> 且 <code>a &lt; b</code></li></ul><p>二分写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution658B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n-k;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid+k&lt;n&amp;&amp;x-arr[mid]&gt;arr[mid+k]-x)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>left;i&lt;left+k;i++)&#123;</span><br><span class="line">            list.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution658B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElementsA</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n-k;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid+k&lt;n&amp;&amp;x-arr[mid]&gt;arr[mid+k]-x)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>left;i&lt;left+k;i++)&#123;</span><br><span class="line">            list.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">del</span>  <span class="operator">=</span> n-k;</span><br><span class="line">        <span class="keyword">while</span> (del&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x-arr[left]&gt;arr[right]-x)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            del--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>left;i&lt;left+k;i++)&#123;</span><br><span class="line">            list.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实大同小异哈啊</p><h2 id="1471-数组中的-k-个最强值"><a href="#1471-数组中的-k-个最强值" class="headerlink" title="1471. 数组中的 k 个最强值"></a><a href="https://leetcode.cn/problems/the-k-strongest-values-in-an-array/">1471. 数组中的 k 个最强值</a></h2><p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p><p>设 <code>m</code> 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code> 的值更强：</p><ul><li><code>|arr[i] - m| &gt; |arr[j] - m|</code></li><li><code>|arr[i] - m| == |arr[j] - m|</code>，且 <code>arr[i] &gt; arr[j]</code></li></ul><p>请返回由数组中最强的 <code>k</code> 个值组成的列表。答案可以以 <strong>任意顺序</strong> 返回。</p><p><strong>中位数</strong> 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 <code>n</code> ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code> 的元素。</p><ul><li>例如 <code>arr = [6, -3, 7, 2, 11]</code>，<code>n = 5</code>：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code> ，数组的中间位置为 <code>m = ((5 - 1) / 2) = 2</code> ，中位数 <code>arr[m]</code> 的值为 <code>6</code> 。</li><li>例如 <code>arr = [-7, 22, 17, 3]</code>，<code>n = 4</code>：数组排序后得到 <code>arr = [-7, 3, 17, 22]</code> ，数组的中间位置为 <code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 <code>3</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1471</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getStrongest(<span class="type">int</span>[] arr, <span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> arr.length;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">       <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> arr[(n-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">      <span class="keyword">while</span> (k--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (m-arr[left]&gt;=arr[right]-m)&#123;</span><br><span class="line">               ans[k] = arr[left++];</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               ans[k] = arr[right--];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双指针</p><p>如果比较他们谁更强力，就加入到数组之中。然后指针移动</p><h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h2><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution167</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> s= numbers[left]+numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (s==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s&gt;target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的双指针查找，但是注意一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code></p><p>所以返回的时候返回的式{left+1,right+1}</p><h2 id="2824-统计和小于目标的下标对数目"><a href="#2824-统计和小于目标的下标对数目" class="headerlink" title="2824. 统计和小于目标的下标对数目"></a><a href="https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/">2824. 统计和小于目标的下标对数目</a></h2><p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>target</code> ，请你返回满足 <code>0 &lt;= i &lt; j &lt; n</code> 且 <code>nums[i] + nums[j] &lt; target</code> 的下标对 <code>(i, j)</code> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2824</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPairs</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>,left = <span class="number">0</span>,right = nums.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums.get(left)+nums.get(right)&lt;target)&#123;</span><br><span class="line">                ans +=right-left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为式看到两个ij就想到了双指针，然后判断是不是和小于target就行了</p><p>统计小于的数目，因为是(i,j)的数目，就是right-left</p><p>然后存储到ans中，如果大了就right—;</p><h2 id="LCP-28-采购方案"><a href="#LCP-28-采购方案" class="headerlink" title="LCP 28. 采购方案"></a><a href="https://leetcode.cn/problems/4xy4Wx/">LCP 28. 采购方案</a></h2><p>小力将 N 个零件的报价存于数组 <code>nums</code>。小力预算为 <code>target</code>，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 <code>1e9 + 7 (1000000007)</code> 为底取模，如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solutionlcp28</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">purchasePlans</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>,left = <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left]+nums[right]&lt;target)&#123;</span><br><span class="line">                ans +=right-left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans %=<span class="number">1_000_000_007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上，只不过要先mod之后再加入ans总的，要不然数太大会报错</p><h2 id="1616-分割两个字符串得到回文串"><a href="#1616-分割两个字符串得到回文串" class="headerlink" title="1616. 分割两个字符串得到回文串"></a><a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/">1616. 分割两个字符串得到回文串</a></h2><p>给你两个字符串 <code>a</code> 和 <code>b</code> ，它们长度相同。请你选择一个下标，将两个字符串都在 <strong>相同的下标</strong> 分割开。由 <code>a</code> 可以得到两个字符串： <code>aprefix</code> 和 <code>asuffix</code> ，满足 <code>a = aprefix + asuffix</code> ，同理，由 <code>b</code> 可以得到两个字符串 <code>bprefix</code> 和 <code>bsuffix</code> ，满足 <code>b = bprefix + bsuffix</code> 。请你判断 <code>aprefix + bsuffix</code> 或者 <code>bprefix + asuffix</code> 能否构成回文串。</p><p>当你将一个字符串 <code>s</code> 分割成 <code>sprefix</code> 和 <code>ssuffix</code> 时， <code>ssuffix</code> 或者 <code>sprefix</code> 可以为空。比方说， <code>s = &quot;abc&quot;</code> 那么 <code>&quot;&quot; + &quot;abc&quot;</code> ， <code>&quot;a&quot; + &quot;bc&quot;</code>， <code>&quot;ab&quot; + &quot;c&quot;</code> 和 <code>&quot;abc&quot; + &quot;&quot;</code> 都是合法分割。</p><p>如果 <strong>能构成回文字符串</strong> ，那么请返回 <code>true</code>，否则返回 <code>false</code> 。</p><p><strong>注意</strong>， <code>x + y</code> 表示连接字符串 <code>x</code> 和 <code>y</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1616</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String a, String b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=a.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;a.charAt(i)==b.charAt(j))&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isPalindrome(a,i,j)||isPalindrome(b,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(a,b)||check(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是不是回文的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">        ++i;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &gt;= j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果 <code>i &gt;= j</code>，说明是回文。</p><p>然后判断a,b是否能连成一个回文</p><p>一旦不相等，就说明进入中间的部分了，尝试检查剩余部分是否是回文（即 <code>a[i..j]</code> 或 <code>b[i..j]</code>）；</p><p>为可以选择 <code>a+b</code> 或 <code>b+a</code> 两种拼接方式，因此主函数里判断了 <code>check(a, b)</code> 和 <code>check(b, a)</code> 两种情况。</p><h2 id="905-按奇偶排序数组"><a href="#905-按奇偶排序数组" class="headerlink" title="905. 按奇偶排序数组"></a><a href="https://leetcode.cn/problems/sort-array-by-parity/">905. 按奇偶排序数组</a></h2><p>给你一个整数数组 <code>nums</code>，将 <code>nums</code> 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。</p><p>返回满足此条件的 <strong>任一数组</strong> 作为答案。</p><p>使用双指针，交换最左边的奇数和最右边的偶数</p><p>然后重复这个过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution905</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArrayByParity(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[j]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-array-by-parity-ii/">922. 按奇偶排序数组 II</a></p><p>给定一个非负整数数组 <code>nums</code>， <code>nums</code> 中一半整数是 <strong>奇数</strong> ，一半整数是 <strong>偶数</strong> 。</p><p>对数组进行排序，以便当 <code>nums[i]</code> 为奇数时，<code>i</code> 也是 <strong>奇数</strong> ；当 <code>nums[i]</code> 为偶数时， <code>i</code> 也是 <strong>偶数</strong> 。</p><p>你可以返回 <em>任何满足上述条件的数组作为答案</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution922</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArrayByParityII(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                i +=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[j]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                j +=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                i +=<span class="number">2</span>;</span><br><span class="line">                j+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面相同，只不过是跳着来的</p><h1 id="同向双指针"><a href="#同向双指针" class="headerlink" title="同向双指针"></a>同向双指针</h1><p>两个指针的移动方向相同（都向右，或者都向左）。</p><h2 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611. 有效三角形的个数"></a><a href="https://leetcode.cn/problems/valid-triangle-number/">611. 有效三角形的个数</a></h2><p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p><p>这里是遍历，应用的规则是两边之和大于第三边</p><p>a+b&gt;c</p><p>也就是说c-a&lt;b</p><p>然后c是大的，a是小的，的话</p><p>a=num[i]的话，c=i+2,b=i+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution611</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">triangleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> ans=  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (a==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=i+<span class="number">2</span>;k&lt;n;k++)&#123;</span><br><span class="line">                <span class="keyword">while</span> (nums[k]-nums[j]&gt;=a)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans +=k-j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后逐个遍历即可</p><p>然后当大于了也就说当前的b太小了，j++</p><p>最后的数目是c-b</p><h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></h2><p>个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><p>如果进入了右段，就没有比最大值小的数，所以最后一个比最大值小的数就是中段的右边界，同理，如果进入左段，就不会出现比最小值更大的情况，所以最后一个出现就视为中段左边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左往右找右边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= max) &#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = i; <span class="comment">// 当前值小于 max，说明乱序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右往左找左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= min) &#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = i; <span class="comment">// 当前值大于 min，说明乱序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right == -<span class="number">1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1574-删除最短的子数组使剩余数组有序"><a href="#1574-删除最短的子数组使剩余数组有序" class="headerlink" title="1574. 删除最短的子数组使剩余数组有序"></a><a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">1574. 删除最短的子数组使剩余数组有序</a></h2><p>给你一个整数数组 <code>arr</code> ，请你删除一个子数组（可以为空），使得 <code>arr</code> 中剩下的元素是 <strong>非递减</strong> 的。</p><p>一个子数组指的是原数组中连续的一个子序列。</p><p>请你返回满足题目要求的最短子数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1574</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfShortestSubarray</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span>arr.length,right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到第一个下降的位置</span></span><br><span class="line">        <span class="keyword">while</span> (right&gt;<span class="number">0</span>&amp;&amp;arr[right-<span class="number">1</span>]&lt;=arr[right])&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;left&lt;n ; ++left)&#123;</span><br><span class="line">            <span class="keyword">if</span> (left&gt;<span class="number">0</span>&amp;&amp;arr[left]&lt;arr[left-<span class="number">1</span>]) <span class="keyword">break</span>;<span class="comment">//保证left是递增的</span></span><br><span class="line">            <span class="keyword">while</span> (right&lt;n&amp;&amp;arr[right]&lt;arr[left])&#123;</span><br><span class="line">                right++;<span class="comment">//找到right保证arr[left]&lt;=arr[right]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除 arr[left+1..right-1] 的长度为 right - left - 1</span></span><br><span class="line">            ans = Math.min(ans,right-left-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话0-left是增的 right-n-1是增的</p><p>left-right是 arr[left]&lt;=arr[right]这样保证他们是增的</p><p>删除中间的就是一个非递减的数组了</p><p>[left+1,right-1];</p><h1 id="背向双指针"><a href="#背向双指针" class="headerlink" title="背向双指针"></a>背向双指针</h1><h2 id="1793-好子数组的最大分数"><a href="#1793-好子数组的最大分数" class="headerlink" title="1793. 好子数组的最大分数"></a><a href="https://leetcode.cn/problems/maximum-score-of-a-good-subarray/">1793. 好子数组的最大分数</a></h2><p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p><p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p><p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1793</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[k],minH = nums[k];</span><br><span class="line">        <span class="type">int</span> i=k,j=k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;t&lt;n-<span class="number">1</span>;t++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j==n-<span class="number">1</span>||i&gt;<span class="number">0</span>&amp;&amp;nums[i-<span class="number">1</span>]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                minH = Math.min(minH,nums[--i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                minH = Math.min(minH,nums[++j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,minH*(j-i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是i和j同时从k出发</p><p>—i和++j</p><p>比较 <em>nums</em>[<em>i</em>−1] 和 <em>nums</em>[<em>j</em>+1] 的大小，谁大就移动谁（一样大移动哪个都可以）。</p><blockquote><p>按照这种移动方式，一定会在某个时刻恰好满足 <em>i</em>=<em>L</em> 且 <em>j</em>=<em>R</em>。</p><p>如果 i 先到达 L，那么此时 j&lt;R。设 L 到 R 之间的最小元素为 m，在方法一中我们知道 nums[L−1]&lt;m，由于 nums[i−1]=nums[L−1]&lt;m≤nums[j+1]，那么后续一定是 j 一直向右移动到 R。对于 j 先到达 R 的情况也同理。所以一定会在某个时刻恰好满足 i=L 且 j=R。</p></blockquote><h1 id="原地修改（栈的思想）"><a href="#原地修改（栈的思想）" class="headerlink" title="原地修改（栈的思想）"></a>原地修改（栈的思想）</h1><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p><strong>把 <em>nums</em> 视作一个栈，把不等于 <em>val</em> 的元素入栈，最后返回栈的大小。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution27</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stackSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x!=val)&#123;</span><br><span class="line">                nums[stackSize++] =x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典，不等于的就入栈，然后长度++</p><p>最后返回size</p><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution26A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的遍历</p><h2 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></h2><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p>使用栈的思想去使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution80A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stackSize</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[stackSize-<span class="number">2</span>])&#123;</span><br><span class="line">                nums[stackSize++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(stackSize,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是不能多于两次，所以是和栈顶-2的元素去比较</p><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p>交换排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j++] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到0就交换</p><p>栈的思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution283</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stackSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[stackSize++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(nums,stackSize,nums.length,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1089-复写零"><a href="#1089-复写零" class="headerlink" title="1089. 复写零"></a><a href="https://leetcode.cn/problems/duplicate-zeros/">1089. 复写零</a></h2><p>给你一个长度固定的整数数组 <code>arr</code> ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p><p>注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 <strong>就地</strong> 进行上述修改，不要从函数返回任何东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1089</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">duplicateZeros</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">countZeros</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] ==<span class="number">0</span>)&#123;</span><br><span class="line">                countZeros++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n+countZeros-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j&lt;n) arr[j] = <span class="number">0</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;n)&#123;</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先去统计0的次数</p><p>然后i为原数组的最后一位</p><p>j为新数组的最后一位</p><p>i&gt;=0时且这个位为0的话</p><p>然后将零复制到目标位置，并且目标位置要前移两位</p><p>将非零元素复制到目标位置，并且目标位置前移一位</p><p>这个再图上画一下就好理解多了</p><h2 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>最多**</strong>两次<strong> 。请你找出所有出现 </strong>两次** 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间（不包括存储输出所需的空间）的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 原地数组法</span></span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// for(int i = 0;i &lt; nums.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     int cur = Math.abs(nums[i]);</span></span><br><span class="line">        <span class="comment">//     int index = cur - 1;</span></span><br><span class="line">        <span class="comment">//     if(nums[index] &lt; 0)&#123;</span></span><br><span class="line">        <span class="comment">//         list.add(cur);</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         nums[index] *= -1;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return list;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> item : nums) &#123;</span><br><span class="line">            map[item]++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>hash表是可以的哈哈</p><h2 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h2><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution448</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt; nums.length;++i)&#123;</span><br><span class="line">            <span class="type">int</span> index= Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[index] *=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里和上面那个题都用到了同一个方法</p><p>就是下标的问题</p><p>如果是顺序排序，不缺少元素的话，</p><p>|nums[i]| = index+1 防止负数哈</p><p>然后如果是乱序的话，也是可以对应起来的的 </p><p>如果if (nums[index]&gt;0){<br>                nums[index] *=-1;<br>            }</p><p>的话，缺少的那个正好是正数</p><p>然后要返回那个数的话，i+1即可</p><p>上面那个题，出现两次跟这个缺少是一样的</p><p>会把index变为负的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 值域是 [1, n]，考虑 nums[i] - 1 做下标</span><br><span class="line">2. 标记：将 nums[nums[i] - 1] *= -1</span><br><span class="line">3. 查询：</span><br><span class="line">   - 找缺失 ➜ 哪些 index 上还为正，对应值就是缺失的 i+1</span><br><span class="line">   - 找重复 ➜ 哪些 index 第一次访问时就已经是负数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>👆</p><h1 id="双序列双指针"><a href="#双序列双指针" class="headerlink" title="双序列双指针"></a>双序列双指针</h1><h2 id="2109-向字符串添加空格"><a href="#2109-向字符串添加空格" class="headerlink" title="2109. 向字符串添加空格"></a><a href="https://leetcode.cn/problems/adding-spaces-to-a-string/">2109. 向字符串添加空格</a></h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，以及一个下标从 <strong>0</strong> 开始的整数数组 <code>spaces</code> 。</p><p>数组 <code>spaces</code> 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 <strong>之前</strong> 。</p><ul><li>例如，<code>s = &quot;EnjoyYourCoffee&quot;</code> 且 <code>spaces = [5, 9]</code> ，那么我们需要在 <code>&#39;Y&#39;</code> 和 <code>&#39;C&#39;</code> 之前添加空格，这两个字符分别位于下标 <code>5</code> 和下标 <code>9</code> 。因此，最终得到 <code>&quot;Enjoy ***Y***our ***C***offee&quot;</code> 。</li></ul><p>请你添加空格，并返回修改后的字符串<em>。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solution2109</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addSpaces</span><span class="params">(String s, <span class="type">int</span>[] spaces)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s.length()+spaces.length);</span><br><span class="line">        <span class="type">int</span> j= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;spaces.length&amp;&amp;spaces[j]==i)&#123;</span><br><span class="line">                ans.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是两个指针，I指针指向的是字符串s,然后J指针指向的是数组</p><p>当j&lt;spaces.lenght且spaces[j]==i的时候</p><p>这个时候加入’ ‘；</p><p>然后再就加入s[i]；</p><p><strong>over</strong></p><h2 id="2540-最小公共值"><a href="#2540-最小公共值" class="headerlink" title="2540. 最小公共值"></a><a href="https://leetcode.cn/problems/minimum-common-value/">2540. 最小公共值</a></h2><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们已经按非降序排序，请你返回两个数组的 <strong>最小公共整数</strong> 。如果两个数组 <code>nums1</code> 和 <code>nums2</code> 没有公共整数，请你返回 <code>-1</code> 。</p><p>如果一个整数在两个数组中都 <strong>至少出现一次</strong> ，那么这个整数是数组 <code>nums1</code> 和 <code>nums2</code> <strong>公共</strong> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2540</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCommon</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;nums1.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> nums1[i],b = nums2[j];</span><br><span class="line">            <span class="keyword">if</span> (a==b) <span class="keyword">return</span> a;</span><br><span class="line">            <span class="keyword">if</span> (a&lt;b) i++;</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针写法，一个遍历nums1，一个遍历nums2</p><p>然后相等就返回，因为是按顺序排列的，所以第一个返回的就是最小的</p><p>然后直接返回就行</p><p>然后根据情况移动指针</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution88</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1&gt;=<span class="number">0</span>&amp;&amp;nums1[p1]&gt;nums2[p2])&#123;</span><br><span class="line">                nums1[p--] = nums1[p1--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[p--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并的时候从后面开始看</p><p>大的先排进去就行</p><p>然后指针移动</p><h2 id="LCP-18-早餐组合"><a href="#LCP-18-早餐组合" class="headerlink" title="LCP 18. 早餐组合"></a><a href="https://leetcode.cn/problems/2vYnGI/">LCP 18. 早餐组合</a></h2><p>小扣在秋日市集选择了一家早餐摊位，一维整型数组 <code>staple</code> 中记录了每种主食的价格，一维整型数组 <code>drinks</code> 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 <code>x</code> 元。请返回小扣共有多少种购买方案。</p><p>注意：答案需要以 <code>1e9 + 7 (1000000007)</code> 为底取模，如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionLCP88</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">breakfastNumber</span><span class="params">(<span class="type">int</span>[] staple, <span class="type">int</span>[] drinks, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        Arrays.sort(staple);</span><br><span class="line">        Arrays.sort(drinks);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span>  <span class="operator">=</span> drinks.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;staple.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (staple[i]&gt;x) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;staple[i]+drinks[j]&gt;x)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = (res+(j+<span class="number">1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就双指针遍历</p><p>使s[i]+d[j]&lt;=x</p><p>然后此时 j+1 个饮料都能与 staple[i] 搭配</p><h2 id="1855-下标对中的最大距离"><a href="#1855-下标对中的最大距离" class="headerlink" title="1855. 下标对中的最大距离"></a><a href="https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/">1855. 下标对中的最大距离</a></h2><p>给你两个 <strong>非递增</strong> 的整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组下标均 <strong>从 0 开始</strong> 计数。</p><p>下标对 <code>(i, j)</code> 中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。如果该下标对同时满足 <code>i &lt;= j</code> 且 <code>nums1[i] &lt;= nums2[j]</code> ，则称之为 <strong>有效</strong> 下标对，该下标对的 <strong>距离</strong> 为 <code>j - i</code> 。</p><p>返回所有 <strong>有效</strong> 下标对 <code>(i, j)</code> 中的 <strong>最大距离</strong> 。如果不存在有效下标对，返回 <code>0</code> 。</p><p>一个数组 <code>arr</code> ，如果每个 <code>1 &lt;= i &lt; arr.length</code> 均有 <code>arr[i-1] &gt;= arr[i]</code> 成立，那么该数组是一个 <strong>非递增</strong> 数组。</p><p>简单的双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1855</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; nums1.length &amp;&amp; p2 &lt;nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2])&#123;  <span class="comment">//无效</span></span><br><span class="line">                <span class="keyword">if</span>(p1 == p2)&#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                    p2++;</span><br><span class="line">                &#125;<span class="keyword">else</span> p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;     <span class="comment">//有效</span></span><br><span class="line">                res =Math.max(res,p2-p1);</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="925-长按键入"><a href="#925-长按键入" class="headerlink" title="925. 长按键入"></a><a href="https://leetcode.cn/problems/long-pressed-name/">925. 长按键入</a></h2><p>你的朋友正在使用键盘输入他的名字 <code>name</code>。偶尔，在键入字符 <code>c</code> 时，按键可能会被<em>长按</em>，而字符可能被输入 1 次或多次。</p><p>你将会检查键盘输入的字符 <code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 <code>True</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution925</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLongPressedName</span><span class="params">(String name, String typed)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;typed.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;name.length()&amp;&amp;typed.charAt(j) ==name.charAt(i))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&gt;<span class="number">0</span>&amp;&amp;typed.charAt(j)==typed.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i ==name.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的双指针问题，一个指针在name一个在type</p><p>如果i=j的话，就继续</p><p>如果j=j-1的话，说明重复了，跳过这个继续遍历</p><p>最后i=name.length说明遍历完正好这长度，返回true</p><p>不是的话返回false</p><h2 id="2337-移动片段得到字符串"><a href="#2337-移动片段得到字符串" class="headerlink" title="2337. 移动片段得到字符串"></a><a href="https://leetcode.cn/problems/move-pieces-to-obtain-a-string/">2337. 移动片段得到字符串</a></h2><p>给你两个字符串 <code>start</code> 和 <code>target</code> ，长度均为 <code>n</code> 。每个字符串 <strong>仅</strong> 由字符 <code>&#39;L&#39;</code>、<code>&#39;R&#39;</code> 和 <code>&#39;_&#39;</code> 组成，其中：</p><ul><li>字符 <code>&#39;L&#39;</code> 和 <code>&#39;R&#39;</code> 表示片段，其中片段 <code>&#39;L&#39;</code> 只有在其左侧直接存在一个 <strong>空位</strong> 时才能向 <strong>左</strong> 移动，而片段 <code>&#39;R&#39;</code> 只有在其右侧直接存在一个 <strong>空位</strong> 时才能向 <strong>右</strong> 移动。</li><li>字符 <code>&#39;_&#39;</code> 表示可以被 <strong>任意</strong> <code>&#39;L&#39;</code> 或 <code>&#39;R&#39;</code> 片段占据的空位。</li></ul><p>如果在移动字符串 <code>start</code> 中的片段任意次之后可以得到字符串 <code>target</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2337</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canChange</span><span class="params">(String start, String target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!start.replace(<span class="string">&quot;_&quot;</span>,<span class="string">&quot;&quot;</span>).equals(target.replace(<span class="string">&quot;_&quot;</span>,<span class="string">&quot;&quot;</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;i&lt;start.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (start.charAt(i)==<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (target.charAt(j)==<span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i!=j&amp;&amp;(start.charAt(i)==<span class="string">&#x27;L&#x27;</span>)==(i&lt;j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样正过来想，是有些困难的。那么我们可以反过来思考，要他们相等的话，去掉_应该是相同的，如果不相同返回false</p><p>然后进行双序列双指针遍历</p><p>如果是L且i&lt;j L不能往右移动，不能i==j所以返回false</p><p>如果是R，且i&gt;j R不能往左移动，不能i==j，返回false</p><p>这样检查完，如果可以的话，就返回true</p><p>在这里的话，(start.charAt(i)==’L’)====(i&lt;j)这一个句子包括了L的情况和R的情况</p><h1 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h1><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p><p><strong>进阶：</strong></p><p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution392</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==c&amp;&amp;++i==s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的双指针，但是灵神这个方法也太简单了吧哈哈</p><h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h2><p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> ，找出并返回 <code>dictionary</code> 中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution524</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String t, String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">indext</span> <span class="operator">=</span> <span class="number">0</span>,indexs=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (indext&lt;t.length()&amp;&amp;indexs&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (t.charAt(indext)==s.charAt(indexs))&#123;</span><br><span class="line">                indext++;</span><br><span class="line">            &#125;</span><br><span class="line">            indexs++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indext ==t.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String t:d)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isSubsequence(t,s))&#123;</span><br><span class="line">                <span class="keyword">if</span> (result.length()&lt;t.length()||(result.length()==t.length()&amp;&amp;result.compareTo(t)&gt;<span class="number">0</span>)) &#123;</span><br><span class="line">                    result = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用双指针来做的话，遇到相同的就继续检查下一个，大家指针都移动，不相同就字典的自己移动。最后返回是否能检查完，就是指针到最后的末尾了</p><p>然后编写主方法，遍历字符，在result&gt;0不为空的时候输出</p><h2 id="2486-追加字符以获得子序列"><a href="#2486-追加字符以获得子序列" class="headerlink" title="2486. 追加字符以获得子序列"></a><a href="https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/">2486. 追加字符以获得子序列</a></h2><p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p><p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 <strong>子序列</strong> ，返回需要追加的最少字符数。</p><p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2486</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">appendCharacters</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[]cp = t.toCharArray();</span><br><span class="line">        <span class="type">char</span>[]cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>,n=cp.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:cs)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k&lt;n&amp;&amp;cp[k]==c) k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n-k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把他们都转为数组，然后遍历，如果cp[k]=cs里面的c的话，计数器k++;</p><p>然后到最后一个相等的地方，然后n-k就是需要追加的数量</p><h2 id="2825-循环增长使字符串子序列等于另一个字符串"><a href="#2825-循环增长使字符串子序列等于另一个字符串" class="headerlink" title="2825. 循环增长使字符串子序列等于另一个字符串"></a><a href="https://leetcode.cn/problems/make-string-a-subsequence-using-cyclic-increments/">2825. 循环增长使字符串子序列等于另一个字符串</a></h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>str1</code> 和 <code>str2</code> 。</p><p>一次操作中，你选择 <code>str1</code> 中的若干下标。对于选中的每一个下标 <code>i</code> ，你将 <code>str1[i]</code> <strong>循环</strong> 递增，变成下一个字符。也就是说 <code>&#39;a&#39;</code> 变成 <code>&#39;b&#39;</code> ，<code>&#39;b&#39;</code> 变成 <code>&#39;c&#39;</code> ，以此类推，<code>&#39;z&#39;</code> 变成 <code>&#39;a&#39;</code> 。</p><p>如果执行以上操作 <strong>至多一次</strong> ，可以让 <code>str2</code> 成为 <code>str1</code> 的子序列，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>注意：</strong>一个字符串的子序列指的是从原字符串中删除一些（可以一个字符也不删）字符后，剩下字符按照原本先后顺序组成的新字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canMakeSubsequence</span><span class="params">(String str1, String str2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s1  = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;s1.length&amp;&amp;j&lt;s2.length)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span>  <span class="operator">=</span>s1[i];</span><br><span class="line">            <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> s2[j];</span><br><span class="line">            <span class="keyword">if</span> (a==b||(a-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>)%<span class="number">26</span>==(b-<span class="string">&#x27;a&#x27;</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j==s2.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是标准的子序列问题，两个指针移动，当满足条件的时候子序列的指针移动</p><p>然后字典的一直移动</p><p>看最后子序列的指针能不能到末尾，到了就说明是，反则不是</p><h2 id="1023-驼峰式匹配"><a href="#1023-驼峰式匹配" class="headerlink" title="1023. 驼峰式匹配"></a><a href="https://leetcode.cn/problems/camelcase-matching/">1023. 驼峰式匹配</a></h2><p>给你一个字符串数组 <code>queries</code>，和一个表示模式的字符串 <code>pattern</code>，请你返回一个布尔数组 <code>answer</code> 。只有在待查项 <code>queries[i]</code> 与模式串 <code>pattern</code> 匹配时， <code>answer[i]</code> 才为 <code>true</code>，否则为 <code>false</code>。</p><p>如果可以将 <strong>小写字母</strong> 插入模式串 <code>pattern</code> 得到待查询项 <code>queries[i]</code>，那么待查询项与给定模式串匹配。您可以在模式串中的任何位置插入字符，也可以选择不插入任何字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1023</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String s,String t)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(),n = t.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;j&lt;n;++i,++j)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;m&amp;&amp;s.charAt(i)!=t.charAt(j)&amp;&amp;Character.isLowerCase(s.charAt(i)))&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==m||s.charAt(i)!=t.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;m&amp;&amp;Character.isLowerCase(s.charAt(i)))&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i==m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">camelMatch</span><span class="params">(String[] queries, String pattern)</span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; ans  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String q:queries)&#123;</span><br><span class="line">            ans.add(check(q,pattern));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就分别取检测每一个字符串，check这个是不是能符合子序列的要求</p><p>然后check检测子序列</p><p>不相等，没到s的末尾，小写的化，指针移动跳过</p><p>然后指针到了末尾，如果不相等的化就返回false</p><p>最后看指针是不是在末尾了</p><h2 id="522-最长特殊序列-II"><a href="#522-最长特殊序列-II" class="headerlink" title="522. 最长特殊序列 II"></a><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-ii/">522. 最长特殊序列 II</a></h2><p>给定字符串列表 <code>strs</code> ，返回其中 <strong>最长的特殊序列</strong> 的长度。如果最长特殊序列不存在，返回 <code>-1</code> 。</p><p><strong>特殊序列</strong> 定义如下：该序列为某字符串 <strong>独有的子序列（即不能是其他字符串的子序列）</strong>。</p><p> <code>s</code> 的 <strong>子序列</strong>可以通过删去字符串 <code>s</code> 中的某些字符实现。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是 <code>&quot;aebdc&quot;</code> 的子序列，因为您可以删除<code>&quot;aebdc&quot;</code>中的下划线字符来得到 <code>&quot;abc&quot;</code> 。<code>&quot;aebdc&quot;</code>的子序列还包括<code>&quot;aebdc&quot;</code>、 <code>&quot;aeb&quot;</code> 和 “” (空字符串)。</li></ul><p>因为子序列越长，越不可能是其它字符串的子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubseq</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==c&amp;&amp;++i==s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断子序列的简单算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution522</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubseq</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==c&amp;&amp;++i==s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLUSlength</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">        Arrays.sort(strs,(a,b)-&gt;b.length()-a.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSub</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span>  <span class="operator">=</span> <span class="number">0</span>;j&lt;strs.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (isSubseq(strs[i],strs[j]))&#123;</span><br><span class="line">                    isSub  = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isSub) <span class="keyword">return</span> strs[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就去遍历整个</p><p>i==j继续</p><p>然后如果是子序列的化，is设为true</p><p>然后如果if (!isSub) return strs[i].length();</p><p>找到不是任何人的子序列</p><p>就返回-1</p><p>然后可以返回数量</p><h1 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h1><h2 id="2367-等差三元组的数目"><a href="#2367-等差三元组的数目" class="headerlink" title="2367. 等差三元组的数目"></a><a href="https://leetcode.cn/problems/number-of-arithmetic-triplets/">2367. 等差三元组的数目</a></h2><p>给你一个下标从 <strong>0</strong> 开始、<strong>严格递增</strong> 的整数数组 <code>nums</code> 和一个正整数 <code>diff</code> 。如果满足下述全部条件，则三元组 <code>(i, j, k)</code> 就是一个 <strong>等差三元组</strong> ：</p><ul><li><code>i &lt; j &lt; k</code> ，</li><li><code>nums[j] - nums[i] == diff</code> 且</li><li><code>nums[k] - nums[j] == diff</code></li></ul><p>返回不同 <strong>等差三元组</strong> 的数目<em>。</em></p><p>hash表法先来个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2367</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arithmeticTriplets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> diff)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums) set.add(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(x-diff)&amp;&amp;set.contains(x+diff))</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的hashset实现</p><p>三指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2367</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arithmeticTripletsA</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> diff)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums) set.add(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(x-diff)&amp;&amp;set.contains(x+diff))</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">arithmeticTriplets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> diff)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j]+diff&lt;x)&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]+diff&gt;x)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nums[i]+diff*<span class="number">2</span>&lt;x)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+diff*<span class="number">2</span>==x)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2563-统计公平数对的数目"><a href="#2563-统计公平数对的数目" class="headerlink" title="2563. 统计公平数对的数目"></a><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">2563. 统计公平数对的数目</a></h2><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和两个整数 <code>lower</code> 和 <code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p><p>如果 <code>(i, j)</code> 数对满足以下情况，则认为它是一个 <strong>公平数对</strong> ：</p><ul><li><code>0 &lt;= i &lt; j &lt; n</code>，且</li><li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2536</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countFairPairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lower, <span class="type">int</span> upper)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (r&gt;<span class="number">0</span>&amp;&amp;nums[r-<span class="number">1</span>]&gt;upper-nums[j])&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l&gt;<span class="number">0</span>&amp;&amp;nums[l-<span class="number">1</span>]&gt;=lower-nums[j])&#123;</span><br><span class="line">                l--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=Math.min(r,j)-Math.min(l,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三指针写法，、</p><p>找 &gt;<em>upper</em>−<em>nums</em>[<em>j</em>] 的第一个数</p><p>找 ≥<em>lower</em>−<em>nums</em>[<em>j</em>] 的第一个数</p><p>使用二分查找的话也是找这两个数</p><p>找到这两个数</p><p>他们之间的数量就是数目最后的答案</p><p>然后累加即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (r&gt;0&amp;&amp;nums[r-1]&gt;upper-nums[j])&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            while (l&gt;0&amp;&amp;nums[l-1]&gt;=lower-nums[j])&#123;</span><br><span class="line">                l--;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>做到了类似二分查找的功能</p><h1 id="分组循环"><a href="#分组循环" class="headerlink" title="分组循环"></a>分组循环</h1><p><strong>适用场景</strong>：按照题目要求，数组会被分割成若干组，每一组的判断/处理逻辑是相同的。</p><p>核心思想：</p><p>外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。<br>内层循环负责遍历组，找出这一组最远在哪结束。<br>这个写法的好处是，各个逻辑块分工明确，也不需要特判最后一组（易错点）。以我的经验，这个写法是所有写法中最不容易出 bug 的，推荐大家记住。</p><h2 id="1446-连续字符"><a href="#1446-连续字符" class="headerlink" title="1446. 连续字符"></a><a href="https://leetcode.cn/problems/consecutive-characters/">1446. 连续字符</a></h2><p>给你一个字符串 <code>s</code> ，字符串的<strong>「能量」</strong>定义为：只包含一种字符的最长非空子字符串的长度。</p><p>请你返回字符串 <code>s</code> 的 <strong>能量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1446</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPower</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 内层循环找出从 i 开始这一组字符最远能延伸到哪里</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; s.charAt(j) == s.charAt(i)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计这一组的长度，更新最大值</span></span><br><span class="line">            ans = Math.max(ans, j - i);</span><br><span class="line">            <span class="comment">// i 指向下一组的开头</span></span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1869-哪种连续子字符串更长"><a href="#1869-哪种连续子字符串更长" class="headerlink" title="1869. 哪种连续子字符串更长"></a><a href="https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/">1869. 哪种连续子字符串更长</a></h2><p>给你一个二进制字符串 <code>s</code> 。如果字符串中由 <code>1</code> 组成的 <strong>最长</strong> 连续子字符串 <strong>严格长于</strong> 由 <code>0</code> 组成的 <strong>最长</strong> 连续子字符串，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><ul><li>例如，<code>s = &quot;**11**01**000**10&quot;</code> 中，由 <code>1</code> 组成的最长连续子字符串的长度是 <code>2</code> ，由 <code>0</code> 组成的最长连续子字符串的长度是 <code>3</code> 。</li></ul><p>注意，如果字符串中不存在 <code>0</code> ，此时认为由 <code>0</code> 组成的最长连续子字符串的长度是 <code>0</code> 。字符串中不存在 <code>1</code> 的情况也适用此规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1869</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkZeroOnes</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> max1=  <span class="number">0</span>,max0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span>i;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;n&amp;&amp;s.charAt(j)==s.charAt(i)) j++;</span><br><span class="line">            <span class="type">int</span> len=  j-i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="number">1</span>)&#123;</span><br><span class="line">                max1 = Math.max(max1,len);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max0=Math.max(max0,len);</span><br><span class="line">            &#125;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max1&gt;max0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是简单的统计长度，是1就归为1，是0就归为0</p><p>更新最大值</p><p>然后最后看是不是大于。</p><h2 id="2414-最长的字母序连续子字符串的长度"><a href="#2414-最长的字母序连续子字符串的长度" class="headerlink" title="2414. 最长的字母序连续子字符串的长度"></a><a href="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/">2414. 最长的字母序连续子字符串的长度</a></h2><p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code> 的任意子字符串都是 <strong>字母序连续字符串</strong> 。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是一个字母序连续字符串，而 <code>&quot;acb&quot;</code> 和 <code>&quot;za&quot;</code> 不是。</li></ul><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> ，返回其 <strong>最长</strong> 的 字母序连续子字符串 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2414</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestContinuousSubstring</span><span class="params">(String S)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i-<span class="number">1</span>]+<span class="number">1</span>==s[i])&#123;</span><br><span class="line">                ans = Math.max(ans,++cnt);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接遍历，如果s[i-1]+1==s[i]就cnt+1,然后找出ans即可</p><h2 id="1957-删除字符使字符串变好"><a href="#1957-删除字符使字符串变好" class="headerlink" title="1957. 删除字符使字符串变好"></a><a href="https://leetcode.cn/problems/delete-characters-to-make-fancy-string/">1957. 删除字符使字符串变好</a></h2><p>一个字符串如果没有 <strong>三个连续</strong> 相同字符，那么它就是一个 <strong>好字符串</strong> 。</p><p>给你一个字符串 <code>s</code> ，请你从 <code>s</code> 删除 <strong>最少</strong> 的字符，使它变成一个 <strong>好字符串</strong> 。</p><p>请你返回删除后的字符串。题目数据保证答案总是 <strong>唯一的</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1957</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">makeFancyString</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>res.length();</span><br><span class="line">            <span class="keyword">if</span> (n&gt;=<span class="number">2</span>&amp;&amp;ch==res.charAt(n-<span class="number">1</span>)&amp;&amp;ch==res.charAt(n-<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我想的是遇到3个连续的就不管，统计他们数目，一看不是数目</p><p>哈哈就变成了是3个连续的就不进入</p><h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution674</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r==l||nums[r-<span class="number">1</span>]&lt;nums[r])&#123;</span><br><span class="line">                len = Math.max(len,r-l+<span class="number">1</span>);</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是比较前面一个大于后面的就移动，中断了就从当前这个开始</p><p>就跟个滑动窗口似的</p><h2 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></h2><p>给定一个整数数组 <code>arr</code> ，返回 <code>arr</code> 的 <em>最大湍流子数组的<strong>长度</strong></em> 。</p><p>如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 <strong>湍流子数组</strong> 。</p><p>更正式地来说，当 <code>arr</code> 的子数组 <code>A[i], A[i+1], ..., A[j]</code> 满足仅满足下列条件时，我们称其为<em>湍流子数组</em>：</p><ul><li><p>若 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt;= k &lt; j</span><br></pre></td></tr></table></figure><p> ：</p><ul><li>当 <code>k</code> 为奇数时， <code>A[k] &gt; A[k+1]</code>，且</li><li>当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；</li></ul></li><li><p>或 </p><p>若 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt;= k &lt; j</span><br></pre></td></tr></table></figure><p> ：</p><ul><li>当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code> ，且</li><li>当 <code>k</code> 为奇数时， <code>A[k] &lt; A[k+1]</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution978</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxTurbulenceSize</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;right&lt;arr.length;right++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.compare(arr[right-<span class="number">1</span>],arr[right]);</span><br><span class="line">            <span class="keyword">if</span> (right==arr.length-<span class="number">1</span>||c*Integer.compare(arr[right],arr[right+<span class="number">1</span>])!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (c!=<span class="number">0</span>)&#123;</span><br><span class="line">                    ans = Math.max(ans,right-left+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目和上个题目类似，只不过是奇数的时候前面大，偶数的时候后面的大。或者相反，就是类似波浪的感觉</p><p>所以要是这样的话，中间的right就是最小或者最大的，在波之中</p><p>这样的话说明子数组该结束了，窗口的大小就是子数组的长度</p><h2 id="2110-股票平滑下跌阶段的数目"><a href="#2110-股票平滑下跌阶段的数目" class="headerlink" title="2110. 股票平滑下跌阶段的数目"></a><a href="https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/">2110. 股票平滑下跌阶段的数目</a></h2><p>给你一个整数数组 <code>prices</code> ，表示一支股票的历史每日股价，其中 <code>prices[i]</code> 是这支股票第 <code>i</code> 天的价格。</p><p>一个 <strong>平滑下降的阶段</strong> 定义为：对于 <strong>连续一天或者多天</strong> ，每日股价都比 <strong>前一日股价恰好少</strong> <code>1</code> ，这个阶段第一天的股价没有限制。</p><p>请你返回 <strong>平滑下降阶段</strong> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2110</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDescentPeriods</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>,left = <span class="number">0</span>;right&lt;prices.length;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left!=right&amp;&amp;prices[right]-prices[right-<span class="number">1</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                left  =right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=right-left+<span class="number">1L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目也是类似滑动窗口。</p><p>当不是下降的时候，直接结束这个子数组</p><h2 id="2765-最长交替子数组"><a href="#2765-最长交替子数组" class="headerlink" title="2765. 最长交替子数组"></a><a href="https://leetcode.cn/problems/longest-alternating-subarray/">2765. 最长交替子数组</a></h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果 <code>nums</code> 中长度为 <code>m</code> 的子数组 <code>s</code> 满足以下条件，我们称它是一个 <strong>交替子数组</strong> ：</p><ul><li><code>m</code> 大于 <code>1</code> 。</li><li><code>s1 = s0 + 1</code> 。</li><li>下标从 <strong>0</strong> 开始的子数组 <code>s</code> 与数组 <code>[s0, s1, s0, s1,...,s(m-1) % 2]</code> 一样。也就是说，<code>s1 - s0 = 1</code> ，<code>s2 - s1 = -1</code> ，<code>s3 - s2 = 1</code> ，<code>s4 - s3 = -1</code> ，以此类推，直到 <code>s[m - 1] - s[m - 2] = (-1)m</code> 。</li></ul><p>请你返回 <code>nums</code> 中所有 <strong>交替</strong> 子数组中，最长的长度，如果不存在交替子数组，请你返回 <code>-1</code> 。</p><p>子数组是一个数组中一段连续 <strong>非空</strong> 的元素序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2765</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">alternatingSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>,i=<span class="number">0</span>,n = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i+<span class="number">1</span>]-nums[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i0</span> <span class="operator">=</span> i;</span><br><span class="line">            i +=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n&amp;&amp;nums[i]==nums[i-<span class="number">2</span>])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,i-i0);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先让其前是后的1的情况，然后再考虑搁一个要相等的情况，最后统计数目</p><p>一般来说，分组循环的模板如下（可根据题目调整）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = len(nums)</span><br><span class="line">i = 0</span><br><span class="line">while i &lt; n:</span><br><span class="line">    start = i</span><br><span class="line">    while i &lt; n and ...:</span><br><span class="line">        i += 1</span><br><span class="line">    # 从 start 到 i-1 是一组</span><br><span class="line">    # 下一组从 i 开始，无需 i += 1</span><br></pre></td></tr></table></figure><p>啊</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/12/leetcode/leetcode3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC-线程池</title>
      <link>https://blog.tokenlen.top/2025/05/09/java-stack/juc1/</link>
      <guid>https://blog.tokenlen.top/2025/05/09/java-stack/juc1/</guid>
      <pubDate>Thu, 08 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>JUC是java.util.concurrent包的简称，在Java5.0添加，目的就是为了更好的支持<strong>高并发</strong>任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！</p><p>进程：<strong>一个运行中的程序的集合</strong>; 一个进程往往可以包含多个线程,至少包含一个线程</p><p>Java默认有几个线程? 两个 main线程 gc线程</p><p>线程：线程（thread）是操作系统能够进行运算调度的最小单位。</p><p>并发(多线程操作同一个资源,交替执行)<br>CPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替<br>并行(多个人一起行走, 同时进行)<br>CPU多核,多个线程同时进行 ; 使用线程池操作</p><p>线程实现主要分为三类:<strong>用户级线程(ULT)、内核级线程(KLT)和混合型线程</strong>实现。</p><p>线程实现主要分为三类:用户级线程(ULT)、内核级线程(KLT)和混合型线程实现。轻量级进程(LWP)不是线程的实现方式,而是操作系统内核用来支持线程运行的一种机制。</p><p>分析三种线程实现方式:</p><p>\1. 用户级线程(ULT):<br>- 线程的创建、调度和管理都由用户程序完成<br>- 操作系统对线程一无所知<br>- 优点是切换开销小,缺点是无法利用多处理器</p><p>\2. 内核级线程(KLT):<br>- 线程的创建、调度和管理都由内核完成<br>- 操作系统直接对线程进行调度<br>- 优点是可以利用多处理器,缺点是系统调用开销大</p><p>\3. 混合线程:<br>- 结合了ULT和KLT的优点<br>- 用户级线程与内核级线程进行多对多映射<br>- 既保证了系统调用的效率,又可以充分利用多处理器</p><p>线程的六种状态：</p><p><strong>new runnable blocked waiting time_waiting terminated</strong></p><p><strong>wait和sleep的区别：</strong></p><ol><li>来自不同的类： wait来自object类, sleep来自线程类</li><li>关于锁的释放：wait会释放锁, sleep不会释放锁</li><li>使用的范围不同： wait必须在同步代码块中， sleep可以在任何地方睡眠</li></ol><h2 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h2><p>新建线程调用<strong>start()方法后</strong>，线程并不会立即进入运行状态。线程的状态变化是：<strong>新建→就绪→运行</strong>。调用start()方法后，线程会进入就绪状态，等待CPU调度才能进入运行状态。这取决于线程调度器的调度策略。start()方法会<strong>创建新的线程并执行run()方法</strong>，而直接调用run()方法只会在<strong>当前线程中执行</strong>，不会启动新线程。</p><p><img src="https://uploadfiles.nowcoder.com/images/20250422/59_1745314586904/AB85F6C1A80F74538F959A181704EA92" alt=""></p><p>run（）方法是定义线程执行体的核心方法。当我们创建一个线程类时,必须重写Thread类的run()方法或实现Runnable接口的run()方法,在其中编写具体的线程执行逻辑。</p><p>可以实现线程之间通知和唤醒的方法是：</p><p>Object.wait/notify/notifyAll</p><p>Condition.await/signal/signalAll</p><p><strong>shutdown方法：</strong>shutdown()方法会让线程池进入”关闭”状态,<strong>此时不再接受新的任务提交,但会继续执行队列中的任务直到完成。这是一种平缓的关闭方式。</strong></p><p>如果需要等待任务执行完成,需要配合使用a<strong>waitTermination()</strong>方法</p><p>shutdownNOw()立刻终止正在执行的所有任务，并返回等待执行的任务列表(List)。这些任务是尚未开始执行的任务。</p><p><strong>awaitTermination</strong>(long timeout, TimeUnit unit)是阻塞方法,它会等待直到以下三种情况之一发生:<br>- 所有任务执行完成<br>- 到达指定的超时时间<br>- 当前线程被中断<br>这个方法常用于确保线程池完全关闭。</p><h1 id="JUC结构"><a href="#JUC结构" class="headerlink" title="JUC结构"></a>JUC结构</h1><p>Java多线程实现有两种主要方式:<strong>继承Thread类和实现Runnable接口</strong></p><p>继承Thread类<br>- 直接继承Thread类<br>- 重写run()方法<br>- 创建线程对象后调用start()方法启动线程<br>- 优点是编码简单直观<br>- 缺点是Java不支持多继承,如果类已经继承了其他类就不能再继承Thread</p><p>实现Runnable接口<br>- 实现Runnable接口<br>- 实现run()方法<br>- 将实现类实例传入Thread构造函数创建线程对象<br>- 调用start()方法启动线程<br>- 优点是可以避免单继承限制,更适合多个线程共享同一个资源的情况<br>- <strong>这是更常用的方式</strong></p><h2 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h2><p>又称“信号量三兄弟”，分为三个</p><p><strong>CountDownLatch（闭锁）</strong></p><ul><li>是一个同步辅助类，在<strong>完成一组线程操作之前</strong>，允许<strong>一个或多个线程等待</strong>。</li><li><strong>典型应用：并发执行多个任务后统一汇总结果。</strong></li></ul><p><strong>CyclicBarrier（栅栏）</strong></p><ul><li>允许一组线程互相等待，直到<strong>都达到一个公共屏障点</strong>。</li><li><strong>支持循环使用</strong>（释放后可重用）。</li><li><strong>典型应用：分布式计算中任务拆分后合并。</strong></li></ul><p><strong>Semaphore（信号量）</strong></p><ul><li>控制对某个资源的<strong>访问线程数量</strong>，相当于“共享锁”。</li><li>提供方法：<ul><li><code>acquire()</code>：尝试获取许可，<strong>无则阻塞等待</strong>。</li><li><code>release()</code>：释放持有的许可。</li></ul></li><li><strong>典型应用：限制并发访问数，比如控制数据库连接池数量。</strong></li></ul><h2 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h2><p>是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是<strong>ExecutorService</strong>，里面包含的类有：</p><p>1）ScheduledExecutorService 解决那些需要任务重复执行的问题</p><p><strong>周期性执行或者延迟任务</strong></p><p>2）ScheduledThreadPoolExecutor 周期性任务调度的类实现</p><p><strong>定时任务调度</strong></p><h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>是JDK提供的一组原子操作类，</p><p>包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，他们的实现原理大多是<strong>持有它们各自的对应的类型变量value，而且被volatile关键字修饰了</strong>。借助 <code>Unsafe</code> 类 + CAS 实现原子性。因为volatile并不能保证原子性，这样来保证每次一个线程要使用它都会拿到<strong>最新的值。</strong></p><p>volatile变量在每次被线程访问时，<strong>都强制从主内存中重新读取最新值，而不是使用线程工作内存中的值。这确保了变量的可见性。</strong></p><h2 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h2><p>根据线程获取<strong>锁的抢占机制</strong>,锁可以分为<strong>公平锁和非公平锁</strong>。根据锁只能被单个线程<strong>持有还是能被多个线程共同持有</strong>，锁可以分为<strong>独占锁和共享锁。</strong></p><p>当线程因为抢占式调度而停止运行时,<strong>会被放入可运行队列的前面</strong>。这是为了保证被抢占的线程能够优先得到下一次执行机会,<strong>体现了调度的公平性。</strong></p><p>是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：</p><p>1）<strong>ReentrantLock</strong> 它是<strong>独占锁</strong>，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。可以被主动打断，可以调用<strong>newCondition</strong>方法实现多个条件变量。可以重入，有公平和非公平模式</p><p>2）<strong>ReentrantReadWriteLock</strong> 它包括子类ReadLock和WriteLock。ReadLock是共享锁，而WriteLock是独占锁。</p><p>🔍 <strong>读锁（共享锁）</strong>：多个线程可以<strong>同时读</strong>，不会互相影响。</p><p>✍️ <strong>写锁（独占锁）</strong>：写线程是<strong>排他的</strong>，写的时候不能读也不能写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.put(temp + <span class="string">&quot;&quot;</span>, temp + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;写线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.get(temp + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;读线程&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存类，使用读写锁保证线程安全</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：加写锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入 &quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作：加读锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取 &quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取完成: &quot;</span> + map.get(key));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）<strong>LockSupport</strong> 它具<strong>备阻塞线程和解除阻塞线程</strong>的功能，并且不会引发死锁。</p><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><p>主要是提供线程安全的集合， 比如：</p><p>1）ArrayList对应的高并发类是<strong>CopyOnWrite</strong>ArrayList，</p><p>2）HashSet对应的高并发类是 CopyOnWriteArraySet，</p><p>3）HashMap对应的高并发类是ConcurrentHashMap</p><p>4）Queue对应的高并发类是ConcurrentLinkedQueue</p><p>这里还有一类特殊的集合，内部基于<strong><code>ReentrantLock</code></strong> 和 <strong><code>Condition</code></strong> 控制线程安全和阻塞操作。</p><p>它们都属于 <strong>阻塞队列（Blocking Queue）的一种实现</strong>，适用于多线程生产者-消费者模型。</p><p>两者构造方法中可以设置<strong>容量上限</strong>（有界）。</p><ul><li><code>new LinkedBlockingQueue&lt;&gt;(1000)</code> 限定最大容量为 1000。</li></ul><p>如果使用无参构造，默认容量是：<code>Integer.MAX_VALUE</code>，<strong>理论上无界</strong>。</p><p>所以 <strong>从默认行为看是无界的</strong>，但实际上 <strong>可以设置为有界队列</strong>。</p><hr><p>LinkedBlockingQueue</p><ul><li><strong>阻塞队列，线程安全</strong></li><li><strong>基于链表结构</strong></li><li><strong>支持 FIFO（先进先出）操作</strong></li><li>插入满了会阻塞，移除空了也会阻塞</li><li><strong>常用于生产者-消费者模型</strong></li><li>支持一个方向的插入和移除（头出尾进）。</li></ul><p>使用 <strong><code>ReentrantLock</code></strong> 实现线程安全</p><p>使用两个锁：<strong>takeLock、putLock</strong>，避免入队和出队相互阻塞</p><p>LinkedBlockingDeque</p><p><strong>线程安全</strong></p><p><strong>基于链表结构</strong></p><p><strong>双端阻塞队列</strong>（支持两端操作）</p><p>既可以作为 <strong>队列（FIFO）</strong>，也可以作为 <strong>栈（LIFO）</strong> 使用</p><p>能实现 <strong>队列模型</strong>（tail add，head remove）</p><p>也能实现 <strong>栈模型</strong>（head add，head remove）</p><h1 id="lock（top）"><a href="#lock（top）" class="headerlink" title="lock（top）"></a>lock（top）</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized是Java中的关键字,是一种<strong>内置的同步锁</strong>，用于实现线程间的互斥访问。</p><p>可以修饰：：：：：</p><ol><li>修饰一个代码块，<strong>被修饰的代码块称为同步语句块</strong>，其作用的范围是大括号{}括起来的代码，<strong>作用的对象是调用这个代码块的对象</strong>；<br>　　2. 修饰一个方法，被修饰的方法称为<strong>同步方法</strong>，其作用的范围是整个方法，作用的对象是<strong>调用这个方法的对象</strong>；<br>　　3. 修改一个静态的方法，<strong>其作用的范围是整个静态方法</strong>，作用的对象是<strong>这个类的所有对象；</strong><ol><li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，<strong>作用主的对象是这个类的所有对象。</strong></li></ol></li></ol><p>JDK 提供的显示锁机制，使用时需显式地加锁和释放锁。</p><p>实现类：<strong><code>ReentrantLock</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();  <span class="comment">// 默认是非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();  <span class="comment">// 可设置是否公平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>类型</th><th>特点</th></tr></thead><tbody><tr><td>公平锁</td><td><strong>先进先出排队机制，谁先来谁先得</strong></td></tr><tr><td>非公平锁</td><td><strong>可能插队，性能更好（默认）</strong></td></tr></tbody></table></div><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale(); &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale(); &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale(); &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNum</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 购得第 &quot;</span> + ticketNum-- + <span class="string">&quot; 张票, 剩余 &quot;</span> + ticketNum + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">// 模拟异常情况，增加线程交替</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="synchronized-vs-Lock-区别总结-top"><a href="#synchronized-vs-Lock-区别总结-top" class="headerlink" title="synchronized vs Lock 区别总结(top)"></a><strong><code>synchronized</code> vs <code>Lock</code> 区别总结</strong>(top)</h3><div class="table-container"><table><thead><tr><th>比较点</th><th><code>synchronized</code></th><th><code>Lock</code>（如 <code>ReentrantLock</code>）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>本质</th><th>Java 关键字</th><th>Java 类（接口）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>获取锁状态</th><th>❌ 无法判断</th><th>✅ 可以用 <code>tryLock()</code> 判断是否获取成功</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>自动释放锁</th><th>✅ 出现异常时自动释放</th><th>❌ 必须手动 <code>unlock()</code>，否则易死锁</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>可中断性</th><th>❌ 不支持中断等待锁</th><th>✅ 支持（<code>lockInterruptibly()</code>）</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>公平性支持</th><th>❌ 默认非公平</th><th>✅ 可选公平/非公平</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>适用范围</th><th>少量代码同步场景</th><th>更复杂、灵活的并发控制场景</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>条件变量支持</th><th>❌ 不支持条件队列</th><th>✅ 支持多个 <code>Condition</code>，可精确唤醒</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>特性 / 类型</th><th><code>synchronized</code></th><th><code>Lock</code>（ReentrantLock）</th><th><code>ReadWriteLock</code>（ReentrantReadWriteLock）</th></tr></thead><tbody><tr><td>是否可重入</td><td>✅ 是</td><td>✅ 是</td><td>✅ 是（读锁和写锁都支持）</td></tr><tr><td>公平性选择</td><td>❌ 否（默认非公平）</td><td>✅ 可选（构造函数可设）</td><td>✅ 可选（构造函数可设）</td></tr><tr><td>是否支持中断</td><td>❌ 不支持</td><td>✅ 支持 <code>lockInterruptibly()</code></td><td>✅ 支持（读/写锁都支持中断）</td></tr><tr><td>是否支持超时尝试获取锁</td><td>❌ 不支持</td><td>✅ 支持 <code>tryLock(timeout)</code></td><td>✅ 支持</td></tr><tr><td>是否为读写分离</td><td>❌ 不支持</td><td>❌ 不支持</td><td>✅ 支持，读锁共享，写锁独占</td></tr><tr><td>是否需要手动释放</td><td>❌ 不需要（自动释放）</td><td>✅ 需要 <code>unlock()</code></td><td>✅ 需要分别释放读锁和写锁</td></tr><tr><td>性能</td><td>中（JVM 优化较好）</td><td>高（更灵活，适合复杂控制）</td><td>非常高（读多写少的场景性能最好）</td></tr><tr><td>使用简单性</td><td>✅ 非常简单</td><td>⛔ 相对复杂（需要手动释放）</td><td>⛔ 更复杂（需区分读写锁）</td></tr></tbody></table></div><h3 id="Condition-精准线程通信（生产者-消费者模型）"><a href="#Condition-精准线程通信（生产者-消费者模型）" class="headerlink" title="Condition 精准线程通信（生产者-消费者模型）"></a><code>Condition</code> 精准线程通信（生产者-消费者模型）</h3><div class="table-container"><table><thead><tr><th>Object方法</th><th>Condition对应方法</th></tr></thead><tbody><tr><td><code>wait()</code></td><td><code>await()</code></td></tr><tr><td><code>notify()</code></td><td><code>signal()</code></td></tr><tr><td><code>notifyAll()</code></td><td><code>signalAll()</code></td></tr></tbody></table></div><p>Condition是个接口，基本的方法就是await()和signal()方法；</p><p>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在<strong>lock.lock()和lock.unlock</strong>之间才可以使用</p><p>常用try tatch finally中</p><p>try中是条件，catch捕捉异常，finally执行解锁</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();<span class="comment">//wait</span></span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt; &quot;</span> + number);</span><br><span class="line">            condition.signalAll();<span class="comment">//唤醒其他等待线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">// 必须释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &gt;&gt; &quot;</span> + number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程之间使用 <code>Condition</code> 精准控制等待和唤醒</p><h1 id="线程共享和线程安全"><a href="#线程共享和线程安全" class="headerlink" title="线程共享和线程安全"></a>线程共享和线程安全</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>使用 <code>Vector</code>（线程安全，效率低）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new Vector&lt;&gt;();</span><br></pre></td></tr></table></figure><p>使用同步包装器（JDK 提供的工具类）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>使用 <strong>CopyOnWriteArrayList</strong> ✅ 推荐！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>核心机制：写时复制（Copy-On-Write，简称 COW）</strong></p><ul><li>写数据时：先复制出一个新数组，把数据添加到新数组，<strong>然后再用新数组替换原数组</strong></li><li>读数据时：直接读旧数组，不会受写操作影响，做到了<strong>读写分离</strong></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>HashSet</code> 底层就是 <code>HashMap</code>，而 <code>HashMap</code> 线程不安全，因此 <code>HashSet</code> 也不安全</p><p>使用Collections.synchronizedSet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br></pre></td></tr></table></figure><p>使用 CopyOnWriteArraySet（线程安全）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><p>不是线程安全的，并发环境中，<code>HashMap</code> 容易出现：</p><ul><li>死循环（JDK 1.7）</li><li>数据丢失</li><li>键值覆盖</li></ul><p>推荐使用ConcurrentHashMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>分段锁机制（JDK 1.7）→ JDK 1.8 后使用 <strong>CAS + synchronized</strong> 优化</p><p>支持高并发场景，性能远优于 <code>Hashtable</code></p><p>或者是使用<code>Collections.synchronizedMap</code></p><p>还有Hashtable</p><p>老版本的 Map 实现，<strong>线程安全</strong>，所有方法都被 <code>synchronized</code> 修饰。</p><p>不允许 <strong>null 键或 null 值</strong>。</p><p><strong>不保证顺序</strong>。</p><p>已被 <code>ConcurrentHashMap</code> 替代，在现代项目中已很少使用。</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p><strong>线程环境是线程安全的</strong>（因为没有竞争）</p><p><strong>单例模式中的双重检查（DCL）</strong>：</p><ul><li>需要 <code>volatile</code> 修饰变量，防止 <strong>指令重排序</strong>。</li></ul><p><strong>SimpleDateFormat 是非线程安全的</strong>：</p><p>当多个线程同时使用同一个SimpleDateFormat对象时,可能会导致解析和格式化错误。这是因为SimpleDateFormat的设计中包含了可变的成员变量,在多线程环境下会相互影响。</p><ul><li>推荐：每线程一个实例 or 使用 <code>ThreadLocal&lt;SimpleDateFormat&gt;</code>。</li></ul><h2 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h2><p><strong>线程共享区域：</strong></p><ul><li><strong>方法区</strong>：类型信息、静态变量、常量等。</li><li><strong>Java 堆</strong>：对象实例的主要内存区域。</li></ul><p><strong>线程私有区域：</strong></p><ul><li><strong>程序计数器</strong>：记录当前线程执行位置。</li><li><strong>虚拟机栈</strong>：每个线程有独立方法栈，存局部变量等信息。</li></ul><h1 id="callable"><a href="#callable" class="headerlink" title="callable"></a>callable</h1><p>多线程的另一种实验方式</p><p><strong>还可以使用使用Callable接口</strong>，Callable接口的<strong>call()方法确实可以返回值，并且能够抛出异常</strong>。这是它区别于Runnable接口run()方法的重要特征。run()方法既不能返回值，也不能抛出受检异常。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个 FutureTask，包装一个 Callable 对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程，实际执行的是 futureTask.run()，内部会调用 call() 方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待 call() 执行结果返回</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个线程任务，实现 Callable 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>特性</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>是否有返回值</th><th>❌ 没有</th><th>✅ 有返回值</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>是否抛异常</th><th>❌ 不能抛 checked 异常</th><th>✅ 可以抛异常</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>方法名</th><th><code>run()</code></th><th><code>call()</code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>执行方式</th><th><code>Thread</code> / <code>ExecutorService</code></th><th>一般配合 <code>FutureTask</code> 使用</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a><code>FutureTask</code></h2><ul><li>是 <code>Runnable</code> + <code>Future</code> 的实现类</li><li>可以传入一个 <code>Callable</code>，通过 <code>Thread</code> 执行它</li><li>可以用 <code>.get()</code> 获取返回值，<strong>该方法会阻塞，直到任务执行完毕</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigStar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">100</span>);</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="辅助类—tool"><a href="#辅助类—tool" class="headerlink" title="辅助类—tool"></a>辅助类—tool</h1><h2 id="CountDownLatch（倒计时锁）"><a href="#CountDownLatch（倒计时锁）" class="headerlink" title="CountDownLatch（倒计时锁）"></a><code>CountDownLatch</code>（倒计时锁）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>); <span class="comment">// 初始化计数器为5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 执行完后调用 countDown</span></span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latch.await(); <span class="comment">// 等待计数器归零</span></span><br><span class="line">System.out.println(<span class="string">&quot;main线程继续执行&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>countDown()</code>：每调用一次，计数器减1。</p><p><code>await()</code>：阻塞等待，直到计数器为0再往下执行。</p><p>多个子任务完成后主线程才执行（比如：并行加载资源 → 全部完成 → 主线程继续）。</p><h2 id="CyclicBarrier（循环屏障）"><a href="#CyclicBarrier（循环屏障）" class="headerlink" title="CyclicBarrier（循环屏障）"></a><code>CyclicBarrier</code>（循环屏障）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;召唤神龙成功！&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        barrier.await(); <span class="comment">// 等待所有线程到齐</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所有线程都调用 <code>await()</code>，等数量满后触发回调（可选），<strong>同时释放所有线程</strong>。</p><p><strong>可以重复使用（循环屏障）</strong>。</p><p>多个线程<strong>并发阶段性同步</strong>，如：多线程分批写入数据库，每批完成后统一提交。</p><h2 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a><code>Semaphore</code>（信号量）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 同时只能有3个线程访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        semaphore.acquire(); <span class="comment">// 请求许可（占坑）</span></span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        semaphore.release(); <span class="comment">// 释放许可（离开）</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>acquire()</code>：申请资源，没资源就阻塞。</p><p><code>release()</code>：释放资源，唤醒等待的线程。</p><p>控制同时访问资源的线程数，比如：限流、数据库连接池、停车场3个车位6辆车示例等。</p><p><strong>CyclicBarrier和CountDownLatch</strong>确实都可以让<strong>一组线程等待其他线程</strong>。CyclicBarrier用于让一组线程互相等待，直到所有线程都到达某个公共屏障点。CountDownLatch则允许一个或多个线程等待其他线程完成一组操作。</p><h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>接口</strong>：<code>java.util.concurrent.BlockingQueue&lt;E&gt;</code></li><li><strong>特点</strong>：当队列空时，取元素的操作会<strong>阻塞等待</strong>；当队列满时，存元素的操作会<strong>阻塞等待</strong>。</li><li><strong>典型场景</strong>：生产者–消费者模型、线程池内部任务队列、并发限流（令牌桶）等。</li></ul><p>队满队空的时候会阻塞</p><h2 id="四类API"><a href="#四类API" class="headerlink" title="四类API"></a>四类API</h2><div class="table-container"><table><thead><tr><th>分组</th><th>插入（Add）</th><th>移除（Remove）</th><th>检查（Examine）</th></tr></thead><tbody><tr><td><strong>1. 抛异常</strong></td><td><code>add(e)</code></td><td><code>remove()</code> / <code>remove(e)</code></td><td><code>element()</code></td></tr><tr><td><strong>2. 特殊值</strong></td><td><code>offer(e)</code></td><td><code>poll()</code></td><td><code>peek()</code></td></tr><tr><td><strong>3. 阻塞</strong></td><td><code>put(e)</code></td><td><code>take()</code></td><td>—</td></tr><tr><td><strong>4. 超时阻塞</strong></td><td><code>offer(e, timeout)</code></td><td><code>poll(timeout)</code></td><td>—</td></tr></tbody></table></div><p>抛异常组：</p><p><strong><code>add(e)</code></strong>：队满时抛 <code>IllegalStateException</code></p><p><strong><code>remove()</code></strong>：队空时抛 <code>NoSuchElementException</code></p><p><strong><code>element()</code></strong>：队空时抛 <code>NoSuchElementException</code></p><p>特殊值组：</p><p><strong><code>offer(e)</code></strong>：队满时返回 <code>false</code>，否则返回 <code>true</code></p><p><strong><code>poll()</code></strong>：队空时返回 <code>null</code></p><p><strong><code>peek()</code></strong>：队空时返回 <code>null</code></p><p>阻塞组：</p><p><strong><code>put(e)</code></strong>：队满时<strong>阻塞</strong>直到有空间</p><p><strong><code>take()</code></strong>：队空时<strong>阻塞</strong>直到有元素</p><p>超时阻塞组：</p><ul><li><strong><code>offer(e, timeout, unit)</code></strong>：等待指定时间仍满则返回 <code>false</code></li><li><strong><code>poll(timeout, unit)</code></strong>：等待指定时间仍空则返回 <code>null</code></li></ul><h2 id="常见实现类"><a href="#常见实现类" class="headerlink" title="常见实现类"></a>常见实现类</h2><div class="table-container"><table><thead><tr><th>实现类</th><th>特点</th></tr></thead><tbody><tr><td><code>ArrayBlockingQueue</code></td><td><strong>有界</strong>阻塞队列，基于数组，<strong>FIFO</strong></td></tr><tr><td><code>LinkedBlockingQueue</code></td><td>可选有界/无界，基于双向链表，<strong>吞吐量高</strong></td></tr><tr><td><code>PriorityBlockingQueue</code></td><td><strong>无界</strong>，支持<strong>优先级排序</strong>，不允许null</td></tr><tr><td><code>DelayQueue</code></td><td><strong>延迟队列</strong>，元素只有到期后才能取出</td></tr><tr><td><code>SynchronousQueue</code></td><td><strong>零容量</strong>队列，每个 <code>put</code> 必须等待 <code>take</code></td></tr><tr><td><code>LinkedTransferQueue</code></td><td>支持 <strong>transfer</strong> 操作的无界队列</td></tr></tbody></table></div><p><strong>SynchronousQueue：</strong></p><p><strong>容量为 0</strong>，不存储元素。</p><p>每一次 <code>put(e)</code> 必须等待另一个线程来 <code>take()</code>，否则<strong>一直阻塞</strong>。</p><p>典型用于<strong>直接交替</strong>的场景，例如：线程间<strong>直接交换数据</strong>，或线程池的手动切换策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 生产线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T1 put 1&quot;</span>);</span><br><span class="line">    queue.put(<span class="string">&quot;1&quot;</span>);   <span class="comment">// 阻塞直到被取</span></span><br><span class="line">    System.out.println(<span class="string">&quot;T1 put 2&quot;</span>);</span><br><span class="line">    queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;T2 take=&gt; &quot;</span> + queue.take());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;T2 take=&gt; &quot;</span> + queue.take());</span><br><span class="line">&#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>意思就是生成完不消费的话，就会一直block</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>线程池</strong>：<code>ThreadPoolExecutor</code> 内部使用 <code>BlockingQueue&lt;Runnable&gt;</code> 来缓存任务。</p><p><strong>生产者–消费者</strong>：高效的线程间传递数据。</p><p><strong>限流/令牌桶</strong>：控制并发量或速率。</p><p><strong>直接交互</strong>：<code>SynchronousQueue</code> 做快速交替传递。</p><h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>TLS(线程局部存储)是一种特殊的存储机制，它为每个线程提供<strong>独立的变量副本</strong></p><p>避免多线程访问冲突</p><p>每个线程只能访问自己的变量副本，<strong>其他线程无法访问</strong>。</p><p>注意：如果变量操作涉及多个步骤或访问共享资源，<strong>仍然需要同步机制</strong>。</p><p>Java 中的 <strong><code>ThreadLocal</code></strong> 是 TLS 的具体实现。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code> 是 Java 实现 <strong>线程本地存储</strong> 的重要机制。设计的目的是为了保证线程安全</p><p>每个线程内部维护一个 <strong><code>ThreadLocalMap</code> 哈希表</strong>，存储自己的变量副本。</p><p>本质：<strong>避免多线程共享数据</strong>，每个线程有自己的数据副本，实现数据隔离。</p><p>每个线程访问ThreadLocal变量时，实际是在<strong>操作自己的ThreadLocalMap中的副本。</strong></p><p><code>ThreadLocal</code>：</p><ul><li><strong>不是继承 Thread 类</strong></li><li><strong>不实现 Runnable 接口</strong></li></ul><p>使用了 <strong>开放定址法</strong> 解决哈希冲突。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>就是一个可以<strong>复用线程</strong>的技术</p><p>原理：</p><p>分为工作线程和任务队列两部分</p><p>任务是一个实现Runnable或者Callable的对象</p><p>会控制任务的数量和线程的数量，不会占用过多的资源</p><h2 id="3大创建方式"><a href="#3大创建方式" class="headerlink" title="3大创建方式"></a>3大创建方式</h2><div class="table-container"><table><thead><tr><th>方法</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><code>Executors.newFixedThreadPool(int n)</code></td><td>固定大小线程池</td><td>核心线程数固定，任务队列无界，<strong>容易 OOM</strong></td></tr><tr><td><code>Executors.newSingleThreadExecutor()</code></td><td>单线程线程池</td><td>一个核心线程，顺序执行，<strong>串行任务执行</strong></td></tr><tr><td><code>Executors.newCachedThreadPool()</code></td><td>可伸缩线程池</td><td>无限线程数，有空线程就复用，<strong>容易线程爆炸</strong></td></tr></tbody></table></div><p>这三种方法不推荐在生产使用！因为：</p><ul><li>队列是无界的，容易导致 <strong>内存溢出</strong></li><li>缺少参数控制，维护困难</li></ul><h2 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,              // <span class="number">1.</span> 核心线程数</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,           // <span class="number">2.</span> 最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,            // <span class="number">3.</span> 线程最大空闲时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,                 // <span class="number">4.</span> 时间单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue, // <span class="number">5.</span> 任务队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory,   // <span class="number">6.</span> 线程工厂（可选：自定义命名）</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler // <span class="number">7.</span> 拒绝策略</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigStar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为2，最大线程数为4，保持空闲线程时间为60秒，任务队列容量为10</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>, <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">4</span>, <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">60</span>, <span class="comment">// 线程空闲保持时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>) <span class="comment">// 阻塞队列容量为10</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务到线程池</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;aaa&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bbb&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ccc&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池，防止新任务提交，但会执行完已提交的任务</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程池中任务完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                executor.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            executor.shutdownNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">2</span>, <span class="comment">// corePoolSize</span></span><br><span class="line">    <span class="number">5</span>, <span class="comment">// maximumPoolSize</span></span><br><span class="line">    <span class="number">3</span>, TimeUnit.SECONDS, <span class="comment">// keepAliveTime</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">// workQueue 容量为3</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">// threadFactory</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><strong>临时线程什么时候创建</strong>？新任务提交的时候核心线程都在忙，任务队列满了，并还可以创建新的临时线程，才会创建临时线程</li><li><strong>什么时候会开始拒绝新任务</strong>？核心线程和临时线程都在忙，任务队列也满了，新的任务才会开始拒绝新任务</li></ul><p>核心线程数量应该是多少？</p><ul><li>计算密集的 cpu+1</li><li>IO密集的 cpu*2</li></ul><h2 id="关闭策略"><a href="#关闭策略" class="headerlink" title="关闭策略"></a>关闭策略</h2><p>shutdown()方法会让线程池进入”关闭”状态,此时不再接受新的任务提交,但会继续执行队列中的任务直到完成。这是一种<strong>平缓的关闭方式。</strong></p><p>shutdownNow()方法会<strong>尝试终止所有正在执行的任务,并返回等待执行的任务列表(List)</strong>。这些任务是尚未开始执行的任务。</p><p>awaitTermination(long timeout, TimeUnit unit)是阻塞方法,它会等待直到以下三种情况之一发生:<br>- 所有任务执行完成<br>- 到达指定的超时时间<br>- 当前线程被中断<br>这个方法常用于<strong>确保线程池完全关闭</strong>。</p><h2 id="四大拒绝策略"><a href="#四大拒绝策略" class="headerlink" title="四大拒绝策略"></a>四大拒绝策略</h2><div class="table-container"><table><thead><tr><th>策略类</th><th>策略说明</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>抛出 <code>RejectedExecutionException</code> 异常</td></tr><tr><td><code>CallerRunsPolicy</code></td><td><strong>谁提交谁执行</strong>（回退给调用线程）</td></tr><tr><td><code>DiscardPolicy</code></td><td>直接丢弃任务，不抛异常</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃最早的任务，然后尝试加入新任务</td></tr></tbody></table></div><h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><p><strong>线程池执行流程</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (当前线程数 &lt; corePoolSize)</span><br><span class="line">    创建新线程执行任务</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (队列未满)</span><br><span class="line">    放入阻塞队列</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (当前线程数 &lt; maximumPoolSize)</span><br><span class="line">    创建非核心线程处理</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    启动拒绝策略</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>为什么不用 Executors 创建线程池？</strong></p><p><code>Executors.newFixedThreadPool</code> 和 <code>newSingleThreadExecutor</code> 使用的都是<strong>无界阻塞队列</strong>（如 <code>LinkedBlockingQueue</code>），在任务积压时会无限添加任务导致内存溢出（OOM）</p><p><code>newCachedThreadPool</code> 使用的是<strong>无界线程数</strong>，短时间大量任务可能创建海量线程，导致 <strong>CPU 被打爆或内存溢出</strong>。因此生产推荐使用 <code>ThreadPoolExecutor</code> 并指定参数</p><p>用手动创建更好</p><p><strong>核心线程与最大线程的区别？</strong></p><p><code>corePoolSize</code> 是核心线程数，线程池创建后<strong>优先使用核心线程</strong>；核心线程默认是常驻线程，即使空闲也不回收（除非设置 <code>allowCoreThreadTimeOut(true)</code>）。<br><code>maximumPoolSize</code> 是线程池能容纳的<strong>最大线程数</strong>，当核心线程+队列都满后才会创建非核心线程，超过该数量后再有任务就触发拒绝策略。</p><p><strong>线程池如何避免资源耗尽？</strong></p><p>1）合理设置 <code>corePoolSize</code> 和 <code>maximumPoolSize</code>；<br>2）合理设置队列大小（如 <code>ArrayBlockingQueue</code>）；<br>3）选择合适的 <code>RejectedExecutionHandler</code> 拒绝策略（如 <code>CallerRunsPolicy</code> 可回退执行）；<br>4）限制任务提交速率（限流）或增加监控报警机制。</p><p><strong>线程池为什么需要 keepAliveTime？</strong></p><p><code>keepAliveTime</code> 用于控制<strong>非核心线程的生存时间</strong>：线程在空闲超过这个时间后会被回收，避免线程长时间闲置浪费资源。可通过 <code>allowCoreThreadTimeOut(true)</code> 让核心线程也参与超时机制，提升资源利用率。</p><p><strong>如何定位线程池满的情况？</strong></p><p>可从以下几个方面进行排查：<br>1）日志中会抛出 <code>RejectedExecutionException</code>（默认拒绝策略）；<br>2）设置自定义拒绝策略中记录日志或告警；<br>3）使用线程池监控工具如 <strong>Arthas</strong>、<strong>JFR (Java Flight Recorder)</strong>、<strong>VisualVM</strong>，查看线程池状态：活跃线程数、任务队列长度等；<br>4）通过 <code>ThreadPoolExecutor</code> 的 <code>getPoolSize()</code>、<code>getActiveCount()</code>、<code>getQueue().size()</code> 等方法动态采集指标并写入监控系统（如 Prometheus + Grafana）。</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p><strong>CAS（Compare And Swap）</strong> 是一种 <strong>无锁的并发原子操作</strong>，用于在多线程环境下安全地更新变量值，避免使用传统的加锁机制。</p><p>CAS 有三个操作数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(V, E, N)</span><br></pre></td></tr></table></figure><ul><li><strong>V</strong>：要更新的变量（内存值）</li><li><strong>E</strong>：预期值（Expected）</li><li><strong>N</strong>：新值（New）</li></ul><p>它的逻辑是：</p><blockquote><p>如果变量当前值 == 预期值 E，就将其更新为新值 N，返回 true；<br> 否则说明别的线程已经修改了这个值，不做操作，返回 false。</p></blockquote><p>Java 的 <code>Unsafe</code> 类、<code>AtomicInteger</code>、<code>ConcurrentHashMap</code> 等底层都用了 CAS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">ai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">ai.compareAndSet(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 如果当前值为 0，则设为 1</span></span><br></pre></td></tr></table></figure><p>这是一个典型的 <strong>CAS 操作：原子地比较并更新</strong>。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/juc/">juc</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/09/java-stack/juc1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode各类题目模板分析题目总结</title>
      <link>https://blog.tokenlen.top/2025/05/09/leetcode/leetcodetotal/</link>
      <guid>https://blog.tokenlen.top/2025/05/09/leetcode/leetcodetotal/</guid>
      <pubDate>Thu, 08 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h1&gt;&lt;p&gt;看到一串数组，要求数量的时候，可能就会用到滑动窗口&lt;/p&gt;
&lt;h2 id=&quot;定长&quot;&gt;&lt;a href=&quot;#定长&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>看到一串数组，要求数量的时候，可能就会用到滑动窗口</p><h2 id="定长"><a href="#定长" class="headerlink" title="定长"></a>定长</h2><p>只需要考虑进出即可</p><p>然后考虑窗口大小不足的时候,continue</p><p>模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution643</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMaxAverage</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxS</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> s=  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            s +=nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&lt;k-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxS = Math.max(maxS,s);</span><br><span class="line">            s -=nums[i-k+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) maxS/k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头进尾部出，然后考虑变化</p><h2 id="不定长"><a href="#不定长" class="headerlink" title="不定长"></a>不定长</h2><p>不定长的基本就是考虑窗口的缩小。</p><h3 id="求最值"><a href="#求最值" class="headerlink" title="求最值"></a>求最值</h3><p>模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2958</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarrayLength</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, left= <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;nums.length;right++)&#123;</span><br><span class="line">            cnt.merge(nums[right],<span class="number">1</span>,Integer::sum);</span><br><span class="line">            <span class="keyword">while</span> (cnt.get(nums[right])&gt;k)&#123;</span><br><span class="line">                cnt.merge(nums[left++],-<span class="number">1</span>,Integer::sum);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是右边进入了，然后check一下，然后进行某些操作，然后左边出去</p><p>一般到最后需要的都是窗口的长度right-left+1</p><h3 id="求数目"><a href="#求数目" class="headerlink" title="求数目"></a>求数目</h3><p>分为越长越合法，越短越合法和<strong>恰好形</strong></p><p><strong>越长越合法</strong>是指</p><p>[left,right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，<strong>[left−1,right]</strong> 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1,right]，还有 [left−2,right],[left−3,right],…,[0,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…,left−1 的所有子数组都是满足要求的，这一共有 <strong>left</strong> 个。</p><p><strong>越短越合法</strong>是指：</p><p>[left,right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left,right]，还有 <strong>[left+1,right]</strong>,[left+2,right],…,[right,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left,left+1,left+2,…,right 的所有子数组都是满足要求的，这一共有 <strong>right−left+1</strong> 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution713</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans= <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;nums.length;right++)&#123;</span><br><span class="line">            x *=nums[right];</span><br><span class="line">            <span class="keyword">while</span> (x&gt;=k)&#123;</span><br><span class="line">                x /=nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=right-left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本差不多，都是右边进去了，，然后经过check，然后左边出去，窗口缩小。‘</p><p>只不过返回的不同罢了</p><p><strong>恰好</strong>就是正好为这个的数目</p><p>例如，要计算有多少个元素和恰好等于 k 的子数组，可以把问题变成：</p><p>计算有多少个元素和 ≥k 的子数组。<br>计算有多少个元素和 &gt;k，也就是 ≥k+1 的子数组。<br>答案就是元素和 ≥k 的子数组个数，减去元素和 ≥k+1 的子数组个数。这里把 &gt; 转换成 ≥，从而可以把滑窗逻辑封装成一个函数 f，然后用 <strong>f(k) - f(k + 1)</strong> 计算，无需编写两份滑窗代码。</p><p>总结：<strong>「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。</strong></p><p>注：也可以把问题变成 <strong>≤k 减去 ≤k−1（两个至多）。可根据题目选择合适的变形方式。</strong></p><p>也可以把两个滑动窗口合并起来，维护同一个右端点 <em>right</em> 和两个左端点 <em>left</em>1 和 <em>left</em>2，我把这种写法叫做<strong>三指针滑动窗口</strong>。</p><p>一般来说一个函数写f(k) - f(k + 1)</p><p>另一个函数实现滑动窗口，就足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution930</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSumA</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>, left1=<span class="number">0</span>,left2=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;nums.length;right++)&#123;</span><br><span class="line">            sum1 +=nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum1&gt;=goal&amp;&amp;left1&lt;=right)&#123;</span><br><span class="line">                sum1 -=nums[left1++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans1 +=left1;</span><br><span class="line">            sum2 +=nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum2&gt;=goal+<span class="number">1</span>&amp;&amp;left2&lt;=right)&#123;</span><br><span class="line">                sum2 -=nums[left2++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans2 +=left2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans1-ans2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atMost(nums,goal)-atMost(nums,goal+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">atMost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>,left = <span class="number">0</span>,sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;nums.length;right++)&#123;</span><br><span class="line">            sum +=nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum&gt;=goal&amp;&amp;left&lt;=right)&#123;</span><br><span class="line">                sum -=nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找的原理就是取一个中间值，然后那中间值和目标值进行比较。</p><p>如果比目标值大的话，说明目标值在左边，中间值mid就变为右边right</p><p>相对应的，小于目标值的话，说明目标值在右边，中间值mid就变为left</p><p>二分查找的总结：</p><p>必须数组/序列是<strong>有序的</strong>，二分前必须先进行排序。</p><p>要确定搜索区间常见形式：<code>[lo, hi]</code>、<code>[lo, hi)</code>、<code>(lo, hi]</code>、<code>(lo, hi)</code></p><p>确定开区间闭区间</p><p>开区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>闭区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mid的取值：通常用 <code>mid = lo + (hi - lo) / 2</code>（或无符号右移 <code>&gt;&gt;&gt; 1</code>）这样来防止溢出</p><p>还要设计check条件：</p><p>将问题转化为一个布尔函数 <code>check(mid)</code>，能准确告诉你“mid 是否满足某侧条件”。</p><p>根据 <code>check(mid)</code> 结果，把 <code>lo</code> 或 <code>hi</code> 缩到 <code>mid</code> 及其左／右一侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> L, hi = R;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">        hi = mid;      <span class="comment">// 保留 mid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lo = mid + <span class="number">1</span>;  <span class="comment">// 丢弃 mid</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lo;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>lowerBound</code>: 找到<strong>第一个 ≥ target</strong> 的索引</p><p><code>upperBound</code>: 找到<strong>第一个 &gt; target</strong> 的索引</p><div class="table-container"><table><thead><tr><th>场景</th><th>区间形式</th><th>备注</th></tr></thead><tbody><tr><td>查找某值 / 插入位置</td><td><code>[0, n-1]</code></td><td>经典闭区间；找不到时返回 <code>lo</code> 作为插入点</td></tr><tr><td>lowerBound / upperBound</td><td><code>(-1, n]</code></td><td>开区间；<code>left = -1, right = n</code></td></tr><tr><td>最接近元素（差值比较）</td><td><code>[0, n-k]</code></td><td>窗口长度为 <code>k</code>，比较左右边界距离取决于差值大小</td></tr><tr><td>双指针对撞</td><td><code>lo &lt; hi</code></td><td>例如找最大满足条件的下标</td></tr></tbody></table></div><p><strong>可以使用查找某些值的问题，省去了遍历</strong></p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="单序列"><a href="#单序列" class="headerlink" title="单序列"></a>单序列</h2><p>相向双指针：两个指针 <em>left</em>=0, <em>right</em>=<em>n</em>−1，从数组的两端开始，向中间移动，这叫<strong>相向双指针</strong>。上面的滑动窗口相当于<strong>同向双指针</strong>。</p><p>然后到中间去汇聚</p><p>一般来说条件是left&lt;right</p><p>然后进行运行</p><h3 id="同向双指针"><a href="#同向双指针" class="headerlink" title="同向双指针"></a><strong>同向双指针</strong></h3><p>两个指针的移动方向相同（都向右，或者都向左）。</p><p>从同一个方向开始</p><p>外层循环控制右指针，内层条件满足时移动左指针收缩窗口</p><p>就是滑动窗口哈哈</p><h3 id="背向双指针"><a href="#背向双指针" class="headerlink" title="背向双指针"></a>背向双指针</h3><p>从中间开始往两边</p><h3 id="原地修改："><a href="#原地修改：" class="headerlink" title="原地修改："></a><strong>原地修改：</strong></h3><p>主要是运用到了栈的思想</p><p>常用于数组原地修改，慢指针标记“结果区域”，快指针用于扫描</p><p><strong>原地修改+下标</strong></p><p>就是下标的问题</p><p>如果是顺序排序，不缺少元素的话，</p><p>|nums[i]| = index+1 防止负数哈</p><p>然后如果是乱序的话，也是可以对应起来的的 </p><p>如果if (nums[index]&gt;0){<br>                nums[index] *=-1;<br>            }</p><p>的话，缺少的那个正好是正数</p><p>然后要返回那个数的话，i+1即可</p><p>上面那个题，出现两次跟这个缺少是一样的</p><p>会把index变为负的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 值域是 [1, n]，考虑 nums[i] - 1 做下标</span><br><span class="line">2. 标记：将 nums[nums[i] - 1] *= -1</span><br><span class="line">3. 查询：</span><br><span class="line">   - 找缺失 ➜ 哪些 index 上还为正，对应值就是缺失的 i+1</span><br><span class="line">   - 找重复 ➜ 哪些 index 第一次访问时就已经是负数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>👆</p><h2 id="双序列"><a href="#双序列" class="headerlink" title="双序列"></a>双序列</h2><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><p>还是标准的子序列问题，两个指针移动，当满足条件的时候子序列的指针移动</p><p>然后字典的一直移动</p><p>看最后子序列的指针能不能到末尾，到了就说明是，反则不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubseq</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==c&amp;&amp;++i==s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/09/leetcode/leetcodetotal/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring基础</title>
      <link>https://blog.tokenlen.top/2025/05/05/java-stack/spring1/</link>
      <guid>https://blog.tokenlen.top/2025/05/05/java-stack/spring1/</guid>
      <pubDate>Sun, 04 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Spring是一个支持快速开发Java</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。</p><p>Spring Framework主要包括几个模块：</p><ul><li>支持IoC和AOP的容器；</li><li>支持JDBC和ORM的数据访问模块；</li><li>支持声明式事务的模块；</li><li>支持基于Servlet的MVC开发；</li><li>支持基于Reactive的Web开发；</li><li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li></ul><h1 id="Ioc容器"><a href="#Ioc容器" class="headerlink" title="Ioc容器"></a>Ioc容器</h1><p>在学习Spring框架时，我们遇到的第一个也是最核心的概念就是<strong>容器。</strong></p><p>什么是容器？容器是<strong>一种为某种特定组件的运行提供必要支持的一个软件环境</strong>。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p><p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p><p>Spring的核心就是提供了一个<strong>IoC容器</strong>，它可以<strong>管理所有轻量级的JavaBean组件</strong>，提供的底层服务包括<strong>组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</strong></p><h2 id="Ioc原理"><a href="#Ioc原理" class="headerlink" title="Ioc原理"></a>Ioc原理</h2><p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p><p>我们假定一个在线书店，通过<code>BookService</code>获取书籍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBook</span><span class="params">(<span class="type">long</span> bookId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了从数据库查询书籍，<code>BookService</code>持有一个<code>DataSource</code>。为了实例化一个<code>HikariDataSource</code>，又不得不实例化一个<code>HikariConfig</code>。</p><p>现在，我们继续编写<code>UserService</code>获取用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HikariConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>UserService</code>也需要访问数据库，因此，我们不得不也实例化一个<code>HikariDataSource</code>。</p><p>在处理用户购买的<code>CartServlet</code>中，我们需要实例化<code>UserService</code>和<code>BookService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentUserId</span> <span class="operator">=</span> getFromCookie(req);</span><br><span class="line">        <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> userService.getUser(currentUserId);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getBook(req.getParameter(<span class="string">&quot;bookId&quot;</span>));</span><br><span class="line">        cartService.addToCart(currentUser, book);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，在购买历史<code>HistoryServlet</code>中，也需要实例化<code>UserService</code>和<code>BookService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HistoryServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述每个组件都采用了一种简单的通过<code>new</code>创建实例并持有的方式。仔细观察，会发现以下缺点：</p><ol><li>实例化一个组件其实很难，例如，<code>BookService</code>和<code>UserService</code>要创建<code>HikariDataSource</code>，实际上需要读取配置，才能先实例化<code>HikariConfig</code>，再实例化<code>HikariDataSource</code>。</li><li>没有必要让<code>BookService</code>和<code>UserService</code>分别创建<code>DataSource</code>实例，完全可以共享同一个<code>DataSource</code>，但谁负责创建<code>DataSource</code>，谁负责获取其他组件已经创建的<code>DataSource</code>，不好处理。类似的，<code>CartServlet</code>和<code>HistoryServlet</code>也应当共享<code>BookService</code>实例和<code>UserService</code>实例，但也不好处理。</li><li>很多组件需要销毁以便释放资源，例如<code>DataSource</code>，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li><li>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</li><li>测试某个组件，例如<code>BookService</code>，是复杂的，因为必须要在真实的数据库环境下执行。</li></ol><p>从上面的例子可以看出，如果<strong>一个系统有大量的组件</strong>，其生命周期和相互之间的依赖关系<strong>如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</strong></p><p>因此，核心问题是：</p><ol><li>谁负责创建组件？</li><li>谁负责根据依赖关系组装组件？</li><li>销毁时，如何按依赖顺序正确销毁？</li></ol><p>解决这一问题的核心方案就是IoC。</p><p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，<strong>所有组件不再由应用程序自己创建和配置，而是由IoC容器负责</strong>，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code>BookService</code>自己并不会创建<code>DataSource</code>，而是等待外部通过<code>setDataSource()</code>方法来注入一个<code>DataSource</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p><ol><li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li><li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li><li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li></ol><p>IoC又称为<strong>依赖注入</strong>（DI：Dependency Injection），它解决了一个最主要的问题：<strong>将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</strong></p><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;HikariDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;BookService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p><p>在Spring的IoC容器中，我们把<strong>所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</strong></p><p>我们从上面的代码可以看到，依赖注入可以通过<code>set()</code>方法实现。<strong>但依赖注入也可以通过构造方法实现。</strong></p><p>很多Java类都具有带参数的构造方法，如果我们把<code>BookService</code>改造为通过构造方法注入，那么实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookService</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</strong></p><p>Spring的IoC容器是一个<strong>高度可扩展的无侵入容器</strong>。所谓无侵入，<strong>是指应用程序的组件无需实现Spring的特定接口，</strong>或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p><ol><li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li><li><p>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</p><p><strong>小结：</strong></p></li></ol><p>IoC是一种设计原则，其核心思想是<strong>将对象的创建和管理的控制权从程序代码转移到外部容器</strong>，这个外部容器通常是一个框架。这样做的目的是为了<strong>降低程序代码之间的耦合度，提高代码的模块化和可维护性。</strong></p><h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><p>因为让容器来为我们创建并装配Bean能获得很大的好处，那么到底如何使用IoC容器？装配好的Bean又如何使用？</p><p>我们来看一个具体的用户注册登录的例子。整个工程的结构如下：</p><p>首先，我们用Maven创建工程并引入<code>spring-context</code>依赖：</p><ul><li>org.springframework:spring-context:6.0.0</li></ul><p>我们先编写一个<code>MailService</code>，用于在用户登录和注册成功后发送邮件通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZoneId</span><span class="params">(ZoneId zoneId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.zoneId = zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZonedDateTime.now(<span class="built_in">this</span>.zoneId).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLoginMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;Hi, %s! You are logged in at %s&quot;</span>, user.getName(), getTime()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendRegistrationMail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;Welcome, %s!&quot;</span>, user.getName()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再编写一个<code>UserService</code>，实现用户注册和登录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMailService</span><span class="params">(MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of( <span class="comment">// users:</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Bob&quot;</span>), <span class="comment">// bob</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;alice@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Alice&quot;</span>), <span class="comment">// alice</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;tom@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Tom&quot;</span>))); <span class="comment">// tom</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail().equalsIgnoreCase(email) &amp;&amp; user.getPassword().equals(password)) &#123;</span><br><span class="line">                mailService.sendLoginMail(user);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;login failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.users.stream().filter(user -&gt; user.getId() == id).findFirst().orElseThrow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        users.forEach((user) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail().equalsIgnoreCase(email)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;email exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(users.stream().mapToLong(u -&gt; u.getId()).max().getAsLong() + <span class="number">1</span>, email, password, name);</span><br><span class="line">        users.add(user);</span><br><span class="line">        mailService.sendRegistrationMail(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>UserService</code>通过<code>setMailService()</code>注入了一个<code>MailService</code>。</p><p>然后，我们需要编写一个特定的<code>application.xml</code>配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mailService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.MailService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意观察上述配置文件，其中与XML Schema相关的部分格式是固定的，我们只关注两个<code>&lt;bean ...&gt;</code>的配置：</p><ul><li>每个<code>&lt;bean ...&gt;</code>都有一个<code>id</code>标识，相当于Bean的唯一ID；</li><li>在<code>userService</code>Bean中，通过<code>&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;</code>注入了另一个Bean；</li><li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li></ul><p>把上述XML配置文件用Java代码写出来，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"><span class="type">MailService</span> <span class="variable">mailService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MailService</span>();</span><br><span class="line">userService.setMailService(mailService);</span><br></pre></td></tr></table></figure><p>只不过Spring容器是通过读取XML文件后使用反射完成的。</p><p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maximumPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Bean:</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line"><span class="comment">// 正常调用:</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们从创建Spring容器的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p><p>获得了<code>ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code>ApplicationContext</code>中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br></pre></td></tr></table></figure><p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.xml&quot;</span>));</span><br><span class="line"><span class="type">MailService</span> <span class="variable">mailService</span> <span class="operator">=</span> factory.getBean(MailService.class);</span><br></pre></td></tr></table></figure><p><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，<strong>我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</strong></p><p><strong>小结：</strong></p><p>Spring的IoC容器接口是<code>ApplicationContext</code>，并提供了多种实现类；</p><p>通过XML配置文件创建IoC容器时，使用<code>ClassPathXmlApplicationContext</code>；</p><p>持有IoC容器后，通过<code>getBean()</code>方法获取Bean的引用。</p><h2 id="使用Annotation配置"><a href="#使用Annotation配置" class="headerlink" title="使用Annotation配置"></a>使用Annotation配置</h2><p>使用Spring的IoC容器，实际上就是通过<strong>类似XML这样的配置文件</strong>，把我们自己的<strong>Bean的依赖关系描述出来，然后让容器来创建并装配Bean</strong>。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。</p><p>有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p><p>我们把上一节的示例改造一下，先删除XML配置文件，然后，给<code>UserService</code>和<code>MailService</code>添加几个注解。</p><p>首先，我们给<code>MailService</code>添加一个<code>@Component</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p><p>然后，我们给<code>UserService</code>添加一个<code>@Component</code>注解和一个<code>@Autowired</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(<span class="meta">@Autowired</span> MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般把<code>@Autowired</code>写在字段上，通常使用package权限的字段，便于测试。</p><p>最后，编写一个<code>AppConfig</code>类启动容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>main()</code>方法外，<code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br></pre></td></tr></table></figure><p>使用的实现类是<code>AnnotationConfigApplicationContext</code>，<strong>必须传入一个标注了<code>@Configuration</code>的类名。</strong></p><p>此外，<code>AppConfig</code>还标注了<code>@ComponentScan</code>，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p><p>使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：</p><ul><li>每个Bean被标注为<code>@Component</code>并正确使用<code>@Autowired</code>注入；</li><li>配置类被标注为<code>@Configuration</code>和<code>@ComponentScan</code>；</li><li>所有Bean均在指定包以及子包内。</li></ul><p>使用<code>@ComponentScan</code>非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p><p><strong>小结：</strong></p><p>使用<strong>Annotation可以大幅简化配置，每个Bean通过<code>@Component</code>和<code>@Autowired</code>注入；</strong></p><p>必须合理设计包的层次结构，才能发挥<code>@ComponentScan</code>的威力。</p><h2 id="定制Bean"><a href="#定制Bean" class="headerlink" title="定制Bean"></a>定制Bean</h2><p>对于Spring容器来说，当我们把一个Bean标记为<code>@Component</code>后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用<code>getBean(Class)</code>获取到的Bean总是同一个实例。</p><p>还有一种Bean，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code>@Scope</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// @Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailSession</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，分别使用3个<code>Validator</code>对用户参数进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!email.matches(<span class="string">&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid email: &quot;</span> + email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!password.matches(<span class="string">&quot;^.&#123;6,20&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid password&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isBlank() || name.length() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid name: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们通过一个<code>Validators</code>作为入口进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Validators</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;Validator&gt; validators;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> validator : <span class="built_in">this</span>.validators) &#123;</span><br><span class="line">            validator.validate(email, password, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>Validators</code>被注入了一个<code>List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code>Validator</code>的Bean装配为一个<code>List</code>注入进来，这样一来，我们每新增一个<code>Validator</code>类型，就自动被Spring装配到<code>Validators</code>中了，非常方便。</p><p>因为Spring是通过扫描classpath获取到所有的Bean，而<code>List</code>是有序的，要指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选注入"><a href="#可选注入" class="headerlink" title="可选注入"></a>可选注入</h3><p>默认情况下，当我们标记了一个<code>@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常。</p><p>可以给<code>@Autowired</code>增加一个<code>required = false</code>的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建第三方Bean"><a href="#创建第三方Bean" class="headerlink" title="创建第三方Bean"></a>创建第三方Bean</h3><p>这个参数告诉Spring容器，如果找到一个类型为<code>ZoneId</code>的Bean，就注入，如果找不到，就忽略。</p><p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p><p>如果一个Bean不在我们自己的package管理之内，例如<code>ZoneId</code>，如何创建它？</p><p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个Bean:</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring对标记为<code>@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p><h3 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h3><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个<code>init()</code>方法进行初始化，定义一个<code>shutdown()</code>方法进行清理，然后，引入JSR-250定义的Annotation：</p><ul><li>jakarta.annotation:jakarta.annotation-api:2.1.1</li></ul><p>在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init mail service with zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutdown mail service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring容器会对上述Bean做如下初始化流程：</p><ul><li>调用构造方法创建<code>MailService</code>实例；</li><li>根据<code>@Autowired</code>进行注入；</li><li>调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li></ul><p>而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</p><p>Spring只根据Annotation查找<em>无参数</em>方法，对方法名不作要求。</p><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code>DataSource</code>实例。</p><p>如果我们在<code>@Configuration</code>类中创建了多个同类型的Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring会报<code>NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。</p><p>这个时候，需要给每个Bean添加不同的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;z&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;utc8&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用<code>@Bean(&quot;name&quot;)</code>指定别名，也可以用<code>@Bean</code>+<code>@Qualifier(&quot;name&quot;)</code>指定别名。</p><p>存在多个同类型的Bean时，注入<code>ZoneId</code>又会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException: No qualifying bean of type &#x27;java.time.ZoneId&#x27; available: expected single matching bean but found 2</span><br></pre></td></tr></table></figure><p>意思是期待找到唯一的<code>ZoneId</code>类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;z&quot;)</span> <span class="comment">// 指定注入名称为&quot;z&quot;的ZoneId</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方法是把其中某个Bean指定为<code>@Primary</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span> <span class="comment">// 指定为主要Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;z&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;utc8&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneOfUTC8</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code>@Primary</code>的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为<code>@Primary</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    DataSource <span class="title function_">createMasterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;slave&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">createSlaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p><h3 id="使用FactoryBean"><a href="#使用FactoryBean" class="headerlink" title="使用FactoryBean"></a>使用FactoryBean</h3><p>我们在设计模式的<a href="https://liaoxuefeng.com/books/java/design-patterns/creational/factory-method/index.html">工厂方法</a>中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p><p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZoneIdFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;ZoneId&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">zone</span> <span class="operator">=</span> <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ZoneId <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p><p>由于可以用<code>@Bean</code>方法创建第三方Bean，本质上<code>@Bean</code>方法就是工厂方法，所以，<code>FactoryBean</code>已经用得越来越少了。</p><p><strong>小结：</strong></p><p>Spring默认使用Singleton创建Bean，也可指定Scope为Prototype；</p><p>可将相同类型的Bean注入<code>List</code>或数组；</p><p>可用<code>@Autowired(required=false)</code>允许可选注入；</p><p>可用带<code>@Bean</code>标注的方法创建Bean；</p><p>可使用<code>@PostConstruct</code>和<code>@PreDestroy</code>对Bean进行初始化和清理；</p><p>相同类型的Bean只能有一个指定为<code>@Primary</code>，其他必须用<code>@Qualifier(&quot;beanName&quot;)</code>指定别名；</p><p>注入时，可通过别名<code>@Qualifier(&quot;beanName&quot;)</code>指定某个Bean；</p><p>可以定义<code>FactoryBean</code>来使用工厂模式创建Bean。</p><h2 id="使用Resource"><a href="#使用Resource" class="headerlink" title="使用Resource"></a>使用Resource</h2><p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p><p>例如，AppService需要读取<code>logo.txt</code>这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p><p>Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>jarkata.annotation.Resource</code>或<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;classpath:/logo.txt&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String logo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logo = reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入<code>Resource</code>最常用的方式是通过classpath，即类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p><p>也可以直接指定文件的路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;file:/path/to/logo.txt&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br></pre></td></tr></table></figure><p>但使用classpath是最简单的方式。上述工程结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-resource</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               └── AppService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── logo.txt</span><br></pre></td></tr></table></figure><p>使用Maven的标准目录结构，所有资源文件放入<code>src/main/resources</code>即可。</p><p><strong>小结：</strong></p><p>Spring提供了Resource类便于注入资源文件。</p><p>最常用的注入是通过classpath以<code>classpath:/path/to/file</code>的形式注入</p><h2 id="注入配置"><a href="#注入配置" class="headerlink" title="注入配置"></a>注入配置</h2><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p><p>例如，<code>MailService</code>根据配置的<code>app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的<code>Resource</code>来读取位于classpath下的一个<code>app.properties</code>文件。但是，这样仍然比较繁琐。</p><p>Spring容器还提供了一个更简单的<code>@PropertySource</code>来自动读取配置文件。我们只需要在<code>@Configuration</code>配置类上再添加一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;app.properties&quot;)</span> <span class="comment">// 表示读取classpath的app.properties</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span></span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring容器看到<code>@PropertySource(&quot;app.properties&quot;)</code>注解后，自动读取这个配置文件，然后，我们使用<code>@Value</code>正常注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span></span><br><span class="line">String zoneId;</span><br></pre></td></tr></table></figure><p>注意注入的字符串语法，它的格式如下：</p><ul><li><code>&quot;$&#123;app.zone&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，如果key不存在，启动将报错；</li><li><code>&quot;$&#123;app.zone:Z&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，但如果key不存在，就使用默认值<code>Z</code>。</li></ul><p>这样一来，我们就可以根据<code>app.zone</code>的配置来创建<code>ZoneId</code>。</p><p>还可以把注入的注解写到方法参数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ZoneId <span class="title function_">createZoneId</span><span class="params">(<span class="meta">@Value(&quot;$&#123;app.zone:Z&#125;&quot;)</span> String zoneId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p><p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code>SmtpConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;smtp.port:25&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String smtpHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> smtpPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意观察<code>#&#123;&#125;</code>这种注入语法，它和<code>$&#123;key&#125;</code>不同的是，<code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性，即调用<code>getHost()</code>方法。一个Class名为<code>SmtpConfig</code>的Bean，它在Spring容器中的默认名称就是<code>smtpConfig</code>，除非用<code>@Qualifier</code>指定了名称。</p><p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code>#&#123;bean.property&#125;</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果<code>SmtpConfig</code>决定从数据库中读取相关配置项，那么<code>MailService</code>注入的<code>@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</code>仍然可以不修改正常运行。</p><p><strong>小结：</strong></p><p>Spring容器可以通过<code>@PropertySource</code>自动读取配置，并以<code>@Value(&quot;$&#123;key&#125;&quot;)</code>的形式注入；</p><p>可以通过<code>$&#123;key:defaultValue&#125;</code>指定默认值；</p><p>以<code>#&#123;bean.property&#125;</code>形式注入时，Spring容器自动把指定Bean的指定属性值注入。</p><h2 id="使用条件配置"><a href="#使用条件配置" class="headerlink" title="使用条件配置"></a>使用条件配置</h2><p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p><p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p><ul><li>native</li><li>test</li><li>production</li></ul><p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建。例如，以下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;!test&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.systemDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">    ZoneId <span class="title function_">createZoneIdForTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的Profile设置为<code>test</code>，则Spring容器会调用<code>createZoneIdForTest()</code>创建<code>ZoneId</code>，否则，调用<code>createZoneId()</code>创建<code>ZoneId</code>。注意到<code>@Profile(&quot;!test&quot;)</code>表示非test环境。</p><p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p><p>实际上，Spring允许指定多个Profile，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=test,master</span><br></pre></td></tr></table></figure><p>可以表示<code>test</code>环境，并使用<code>master</code>分支代码。</p><p>要满足多个Profile条件，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123; &quot;test&quot;, &quot;master&quot; &#125;)</span> <span class="comment">// 满足test或master</span></span><br><span class="line">ZoneId <span class="title function_">createZoneId</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Conditional"><a href="#使用Conditional" class="headerlink" title="使用Conditional"></a>使用Conditional</h3><p>除了根据<code>@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code>@Conditional</code>决定是否创建某个Bean。</p><p>例如，我们对<code>SmtpMailService</code>添加如下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Conditional(OnSmtpEnvCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpMailService</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的意思是，如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。<code>OnSmtpEnvCondition</code>的条件是什么呢？我们看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnSmtpEnvCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(System.getenv(<span class="string">&quot;smtp&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>OnSmtpEnvCondition</code>的条件是存在环境变量<code>smtp</code>，值为<code>true</code>。这样，我们就可以通过环境变量来控制是否创建<code>SmtpMailService</code>。</p><p>Spring只提供了<code>@Conditional</code>注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在<code>app.smtp=true</code>，则创建<code>MailService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name=&quot;app.smtp&quot;, havingValue=&quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前classpath中存在类<code>javax.mail.Transport</code>，则创建<code>MailService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;javax.mail.Transport&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;file&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploader</span> <span class="keyword">implements</span> <span class="title class_">Uploader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生产环境运行时，我们会把文件存储到类似AWS S3上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;app.storage&quot;, havingValue = &quot;s3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S3Uploader</span> <span class="keyword">implements</span> <span class="title class_">Uploader</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他需要存储的服务则注入<code>Uploader</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserImageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Uploader uploader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当应用程序检测到配置文件存在<code>app.storage=s3</code>时，自动使用<code>S3Uploader</code>，如果存在配置<code>app.storage=file</code>，或者配置<code>app.storage</code>不存在，则使用<code>FileUploader</code>。</p><p>可见，使用条件注解，能更灵活地装配Bean。</p><p>小结：</p><p>Spring允许通过<code>@Profile</code>配置不同的Bean；</p><p>Spring还提供了<code>@Conditional</code>来进行条件装配，Spring Boot在此基础上进一步提供了基于配置、Class、Bean等条件进行装配。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>AOP是Aspect Oriented Programming，即<strong>面向切面编程。</strong></p><p>AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。</p><p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化。</p><p>考察业务模型可以发现，<code>BookService</code>关心的是自身的核心逻辑，但整个系统还要求关注安全检查、日志、事务等功能，这些功能实际上“横跨”多个业务方法，为了实现这些功能，不得不在每个业务方法上重复编写代码。</p><p>一种可行的方式是使用<a href="https://liaoxuefeng.com/books/java/design-patterns/structural/proxy/index.html">Proxy模式</a>，将某个功能，例如，权限检查，放入Proxy中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityCheckBookService</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BookService target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityCheckBookService</span><span class="params">(BookService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        target.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">securityCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的缺点是比较麻烦，必须先抽取接口，然后，针对每个方法实现Proxy。</p><p>另一种方法是，既然<code>SecurityCheckBookService</code>的代码都是标准的Proxy样板代码，不如把权限检查视作一种切面（Aspect），把日志、事务也视为切面，然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p><p>如果我们以AOP的视角来编写上述业务，可以依次实现：</p><ol><li>核心逻辑，即BookService；</li><li>切面逻辑，即：<ol><li>权限检查的Aspect；</li><li>日志的Aspect；</li><li>事务的Aspect。</li></ol></li></ol><p>然后，以某种方式，让框架来把上述3个Aspect以Proxy的方式“织入”到<code>BookService</code>中，这样一来，就不必编写复杂而冗长的Proxy模式。</p><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；<strong>编译时增强</strong></li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，<strong>对目标类的字节码重新“增强”；</strong></li><li>运行期：目标对象和切面都是普通Java类，<strong>通过JVM的动态代理功能或者第三方库实现运行期动态织入。</strong></li></ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p><p>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p><p>需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。</p><h2 id="装配AOP"><a href="#装配AOP" class="headerlink" title="装配AOP"></a>装配AOP</h2><p>在AOP编程中，我们经常会遇到下面的概念：</p><ul><li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li><li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li><li>Pointcut：切入点，即一组连接点的集合；</li><li>Advice：增强，指特定连接点上执行的动作；</li><li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li><li>Weaving：织入，指将切面整合到程序的执行流程中；</li><li>Interceptor：拦截器，是一种实现增强的方式；</li><li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li><li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li></ul><p>看完上述术语，是不是感觉对AOP有了进一步的困惑？其实，我们不用关心AOP创造的“术语”，只需要理解AOP本质上只是一种代理模式的实现方式，在Spring的容器中实现AOP特别方便。</p><p>我们以<code>UserService</code>和<code>MailService</code>为例，这两个属于核心业务逻辑，现在，我们准备给<code>UserService</code>的每个业务方法执行前添加日志，给<code>MailService</code>的每个业务方法执行前后添加日志，在Spring中，需要以下步骤：</p><p>首先，我们通过Maven引入Spring对AOP的支持：</p><ul><li>org.springframework:spring-aspects:6.0.0</li></ul><p>上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便，因为它的定义比较简单。</p><p>然后，我们定义一个<code>LoggingAspect</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察<code>doAccessCheck()</code>方法，我们定义了一个<code>@Before</code>注解，后面的字符串是告诉AspectJ应该在何处执行该方法，这里写的意思是：执行<code>UserService</code>的每个<code>public</code>方法前执行<code>doAccessCheck()</code>代码。</p><p>再观察<code>doLogging()</code>方法，我们定义了一个<code>@Around</code>注解，它和<code>@Before</code>不同，<code>@Around</code>可以决定是否执行目标方法，因此，我们在<code>doLogging()</code>内部先打印日志，再调用方法，最后打印日志后返回结果。</p><p>在<code>LoggingAspect</code>类的声明处，除了用<code>@Component</code>表示它本身也是一个Bean外，我们再加上<code>@Aspect</code>注解，表示它的<code>@Before</code>标注的方法需要注入到<code>UserService</code>的每个<code>public</code>方法执行前，<code>@Around</code>标注的方法需要注入到<code>MailService</code>的每个<code>public</code>方法执行前后。</p><p>紧接着，我们需要给<code>@Configuration</code>类加上一个<code>@EnableAspectJAutoProxy</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。执行代码，我们可以看到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">Welcome, test!</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendRegistrationMail(User)</span><br><span class="line">[Before] do access check...</span><br><span class="line">[Around] start void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br><span class="line">Hi, Bob! You are logged in at 2020-02-14T23:13:52.167996+08:00[Asia/Shanghai]</span><br><span class="line">[Around] done void com.itranswarp.learnjava.service.MailService.sendLoginMail(User)</span><br></pre></td></tr></table></figure><p>这说明执行业务逻辑前后，确实执行了我们定义的Aspect（即<code>LoggingAspect</code>的方法）。</p><p>有些童鞋会问，<code>LoggingAspect</code>定义的方法，是如何注入到其他Bean的呢？</p><p>其实AOP的原理非常简单。我们以<code>LoggingAspect.doAccessCheck()</code>为例，要把它注入到<code>UserService</code>的每个<code>public</code>方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserServiceAopProxy <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="keyword">private</span> LoggingAspect aspect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceAopProxy</span><span class="params">(UserService target, LoggingAspect aspect)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.aspect = aspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 先执行Aspect的代码:</span></span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="comment">// 再执行UserService的逻辑:</span></span><br><span class="line">        <span class="keyword">return</span> target.login(email, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="keyword">return</span> target.register(email, password, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的<code>UserService</code>（原始的<code>UserService</code>实例作为内部变量隐藏在<code>UserServiceAopProxy</code>中）。如果我们打印从Spring容器获取的<code>UserService</code>实例类型，它类似<code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p><p><strong>Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</strong></p><p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p><ol><li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li><li>标记<code>@Component</code>和<code>@Aspect</code>；</li><li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li></ol><p>拦截器，就是拦截代码的执行</p><p>顾名思义，拦截器有以下类型：</p><ul><li>@Before：这种拦截器<strong>先执行拦截代码，</strong>再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li><li>@After：这种拦截器<strong>先执行目标代码</strong>，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li><li>@AfterReturning：和@After不同的是，<strong>只有当目标代码正常返回时，才执行拦截器代码；</strong></li><li>@AfterThrowing：和@After不同的是，<strong>只有当目标代码抛出了异常时，才执行拦截器代码；</strong></li><li>@Around：能完全控制目标代码是否执行，<strong>并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</strong></li></ul><h2 id="使用注解装配AOP"><a href="#使用注解装配AOP" class="headerlink" title="使用注解装配AOP"></a>使用注解装配AOP</h2><p>上一节我们讲解了使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code>语法来定义应该如何装配AOP。</p><p>在实际项目中，这种写法其实很少使用。假设你写了一个<code>SecurityAspect</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SecurityContext.getCurrentUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;check failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个<code>check()</code>方法拦截。</p><p>还有的童鞋喜欢用方法名前缀进行拦截：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(public * update*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 对update开头的方法切换数据源:</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">old</span> <span class="operator">=</span> setCurrentDataSource(<span class="string">&quot;master&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    restoreCurrentDataSource(old);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p><p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p><p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的<code>@Transactional</code>就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上<code>@Transactional</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 有事务:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无事务:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有事务:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接在class级别注解，表示“所有public方法都被安排了”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@Transactional</code>，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MetricTime &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要被监控的关键方法上标注该注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 监控register()方法性能:</span></span><br><span class="line">    <span class="meta">@MetricTime(&quot;register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">register</span><span class="params">(String email, String password, String name)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义<code>MetricAspect</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(metricTime)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">metric</span><span class="params">(ProceedingJoinPoint joinPoint, MetricTime metricTime)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> metricTime.value();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">            <span class="comment">// 写入日志或发送至JMX:</span></span><br><span class="line">            System.err.println(<span class="string">&quot;[Metrics] &quot;</span> + name + <span class="string">&quot;: &quot;</span> + t + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法参数类型是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p><p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome, Bob!</span><br><span class="line">[Metrics] register: 16ms</span><br></pre></td></tr></table></figure><p>还是一样的步骤，调用AOP</p><ul><li><p>写一个Aspect类，标注注解检查</p></li><li><pre><code class="lang-java">@Aspect@Component<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用</span><br><span class="line"></span><br><span class="line">在`@Configuration`类上标注`@EnableAspectJAutoProxy`。</span><br><span class="line"></span><br><span class="line">小结：</span><br><span class="line"></span><br><span class="line">使用注解实现AOP需要先定义注解，然后使用`@Around(&quot;@annotation(name)&quot;)`实现装配；</span><br><span class="line"></span><br><span class="line">使用注解既简单，又能明确标识AOP装配，是使用AOP推荐的方式。</span><br><span class="line"></span><br><span class="line">## 使用模板</span><br><span class="line"></span><br><span class="line">注解定义、切面实现、方法标注、开启代理、组件扫描。</span><br><span class="line"></span><br><span class="line">### 定义注解</span><br><span class="line"></span><br><span class="line">如果你要通过注解（如 `@MetricTime`）来控制哪些方法需要切面增强：</span><br><span class="line"></span><br></pre></td></tr></table></figure>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MetricTime &#123;  String value();&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 切面类实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>@Aspect@Componentpublic class MetricAspect &#123;  @Around(&quot;@annotation(metricTime)&quot;) // 匹配使用了 @MetricTime 的方法  public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable &#123;      String name = metricTime.value();      long start = System.currentTimeMillis();      try &#123;          return joinPoint.proceed(); // 执行目标方法      &#125; finally &#123;          long duration = System.currentTimeMillis() - start;          System.out.println(&quot;[Metrics] &quot; + name + &quot;: &quot; + duration + &quot;ms&quot;);      &#125;  &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; ☑️ 记得使用 `@Aspect` 和 `@Component` 标记，Spring 才会识别这是一个切面。</span><br><span class="line"></span><br><span class="line">### 注解使用具体方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>@Componentpublic class UserService &#123;  @MetricTime(&quot;register&quot;) // 表明这个方法需要记录耗时  public User register(String email, String password, String name) &#123;      // 业务逻辑  &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 启用</span><br><span class="line"></span><br><span class="line">在你的配置类（通常是启动类或配置类）上加：</span><br><span class="line"></span><br></pre></td></tr></table></figure>@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;  // Bean 配置等&#125;</code></pre></li></ul><h3 id="使用-ComponentScan扫描包"><a href="#使用-ComponentScan扫描包" class="headerlink" title="使用@ComponentScan扫描包"></a><strong>使用@ComponentScan扫描包</strong></h3><p>确保你的 <code>@Component</code> 和 <code>@Aspect</code> 所在包能被 Spring 扫到。</p><p><strong>扫描的时候扫描的是他和他的子包里的bean</strong></p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring/">spring</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/05/java-stack/spring1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
