<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Sun, 16 Mar 2025 06:55:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Mysql面试题目</title>
      <link>https://blog.tokenlen.top/2025/03/15/mysql12/</link>
      <guid>https://blog.tokenlen.top/2025/03/15/mysql12/</guid>
      <pubDate>Fri, 14 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;1-什么是mysql&quot;&gt;&lt;a href=&quot;#1-什么是mysql&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-什么是mysql"><a href="#1-什么是mysql" class="headerlink" title="1.什么是mysql"></a>1.什么是mysql</h2><p>MySQL 是一个<strong>开源的关系型数据库</strong>，现在隶属于 Oracle 公司。是我们国内使用频率最高的一种数据库，我在本地安装的是最新的 8.3 版本。</p><p><strong>怎么删除建立一张表？</strong></p><p>使用DROP TABLE 来删除表</p><p>CREATE TABLE来创建表</p><p>创建表的时候可以使用PRIMARY KEY来创建主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    email VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>写一个升序/降序的sql语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>, name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>排序的第一依据是salary 降序，第二一依据是name 升序</p><p><strong>MYsql出现性能差的原因是什么？</strong></p><p>可能是sql查询的时候使用了全表扫描，也可能是查询语句过于复杂</p><p>也有可能是单表数据量过大。</p><p>我们可以添加索引来解决大部分问题，对于一些热点数据，可以使用Redis缓存</p><h2 id="2-表的连接"><a href="#2-表的连接" class="headerlink" title="2.表的连接"></a>2.表的连接</h2><p>内连接：</p><p>返回两个表中有<strong>匹配关系</strong>的行，找出两张表的<strong>交集</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT users.name, orders.order_id</span><br><span class="line">FROM users</span><br><span class="line">INNER JOIN orders ON users.id = orders.user_id;</span><br></pre></td></tr></table></figure><p>INNER JOIN orders ON users.id = orders.user_id;连接条件：</p><p>users.id = orders.user_id</p><p>外连接：</p><p>不仅返回两个表中匹配的行，还返回没有匹配的行，用 <code>null</code> 来填充。</p><p>想当与找<strong>并集</strong></p><p>left join右表没匹配的null填充</p><p>right join左表没匹配的null填充</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.id, users.name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure><p>交叉连接：</p><p>返回两张表的<strong>笛卡尔积</strong>，也就是将左表的每一行与右表的每一行进行组合，返回的行数是两张表行数的乘积。</p><h2 id="3-数据库的三大范式"><a href="#3-数据库的三大范式" class="headerlink" title="3.数据库的三大范式"></a>3.数据库的三大范式</h2><p>第一范式：确保表的每一列都是<strong>不可分割的基本数据单元</strong>，比如说用户地址，应该拆分成省、市、区、详细地址等 4 个字段。</p><p>第二范式：要求表中的<strong>每一列都和主键直接相关</strong>。比如在订单表中，商品名称、单位、商品价格等字段应该拆分到商品表中。</p><p>第三范式：<strong>非主键列应该只依赖于主键列</strong>。比如说在设计订单信息表的时候，可以把客户名称、所属公司、联系方式等信息拆分到客户信息表中，然后在订单信息表中用客户编号进行关联。</p><p>建表的原则：</p><p>考虑表是否符合数据库的三大范式，确保字段不可再分，消除非主键依赖，确保字段仅依赖于主键等。</p><p>然后在选择字段类型时，应该尽量选择合适的数据类型。</p><p>在字符集上，尽量选择 utf8mb4，这样不仅可以支持中文和英文，还可以支持表情符号等。</p><p>当数据量较大时，比如上千万行数据，需要考虑分表。比如订单表，可以采用水平分表的方式来分散单表存储压力。</p><h2 id="4-varchar和char的区别"><a href="#4-varchar和char的区别" class="headerlink" title="4.varchar和char的区别"></a>4.varchar和char的区别</h2><p>varchar是可变长度的字符类型，原则上最多可以容纳 65535 个字符，但考虑字符集，以及 MySQL 需要 1 到 2 个字节来表示字符串长度，所以实际上最大可以设置到 65533。</p><p>varch中空格也要占一个字节</p><p>char是固定长度的字符类型，当定义一个 <code>CHAR(10)</code> 字段时，不管实际存储的字符长度是多少，都只会占用 10 个字符的空间。如果插入的数据小于 10 个字符，剩余的部分会用空格填充。</p><h2 id="5-blob和text有什么区别"><a href="#5-blob和text有什么区别" class="headerlink" title="5.blob和text有什么区别"></a>5.blob和text有什么区别</h2><p>blob用于存储二进制数据，如图片音频等等，但是实际应用中，我们会把这些文件存储到oss或者文件服务器上，数据库存储文件的url</p><p>text用于存储文本数据，如文章评论等。</p><h2 id="6-DATETIME和TIMESTAMP有什么区别"><a href="#6-DATETIME和TIMESTAMP有什么区别" class="headerlink" title="6.DATETIME和TIMESTAMP有什么区别"></a>6.DATETIME和TIMESTAMP有什么区别</h2><p>DATETIME直接存储日期和时间的完整值，与时区无关。</p><p>TIMESTAMP存储的是 Unix 时间戳，1970-01-01 00:00:01 UTC 以来的秒数，受<strong>时区</strong>影响。</p><p>DATETIME 的默认值为 <strong>null</strong>，占用 <strong>8</strong> 个字节；TIMESTAMP 的默认值为当前时间——<strong>CURRENT_TIMESTAMP</strong>，占 <strong>4</strong> 个字节，实际开发中更常用，因为可以自动更新。</p><h2 id="7-in和exists的区别"><a href="#7-in和exists的区别" class="headerlink" title="7.in和exists的区别"></a>7.in和exists的区别</h2><p>使用 IN 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着<strong>子查询的结果集需要全部加载到内存</strong>中。</p><p>EXISTS 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 <code>EXISTS</code> 条件为真。<code>EXISTS</code> 关注的是<strong>子查询是否返回行</strong>，而不是返回的具体值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 可以利用关联索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o </span><br><span class="line">            <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> u.id <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>In适用于子查询结果集较小的情况。如果子查询返回大量数据，<code>IN</code> 的性能可能会下降，因为它需要将整个结果集加载到内存。</p><p>EXISTS适用于子查询结果集可能很大的情况。由于 <code>EXISTS</code> 只需要判断子查询是否返回行，而不需要加载整个结果集，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p><p><strong>NUll值陷？</strong></p><p>IN：如果子查询的结果集中包含 <code>NULL</code> 值，可能会导致意外的结果。例如，<code>WHERE column IN (subquery)</code>，如果 <code>subquery</code> 返回 <code>NULL</code>，则 <code>column IN (subquery)</code> 永远不会为真，除非 <code>column</code> 本身也为 <code>NULL</code>。</p><p>EXISTS：对 <code>NULL</code> 值的处理更加直接。<code>EXISTS</code> 只是检查子查询是否返回行，不关心行的具体值，因此不受 <code>NULL</code> 值的影响。</p><h2 id="8-记录货币"><a href="#8-记录货币" class="headerlink" title="8.记录货币"></a>8.记录货币</h2><p>货币在数据库中 MySQL 常用 <strong>Decimal</strong> 和 <strong>Numeric</strong> 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。</p><p> salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。</p><p>不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有<strong>一定的误差</strong>。</p><p>会出现大问题的！</p><h2 id="9-如何存储emoji"><a href="#9-如何存储emoji" class="headerlink" title="9.如何存储emoji"></a>9.如何存储emoji</h2><p>utf8 字符集仅支持最多 3 个字节的 UTF-8 字符，但是 emoji 表情（😊）是 4 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 表情时，需要使用 utf8mb4 字符集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h2 id="10-drop-delete-turncate的区别"><a href="#10-drop-delete-turncate的区别" class="headerlink" title="10.drop,delete,turncate的区别"></a>10.drop,delete,turncate的区别</h2><p>都表示删除，但是三者有一些差别：</p><div class="table-container"><table><thead><tr><th>区别</th><th>delete</th><th>truncate</th><th>drop</th></tr></thead><tbody><tr><td>类型</td><td>属于 DML</td><td>属于 DDL</td><td>属于 DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>从数据库中删除表，所有数据行，索引和权限也会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table></div><p>因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。</p><h2 id="11-UNION和UNION-ALL的区别"><a href="#11-UNION和UNION-ALL的区别" class="headerlink" title="11.UNION和UNION ALL的区别"></a>11.UNION和UNION ALL的区别</h2><ul><li>如果使用 UNION，会在表链接后<strong>筛选掉重复</strong>的记录行</li><li>如果使用 UNION ALL，不会合并重复的记录行</li><li>从效率上说，UNION ALL 要比 UNION 快很多，如果合并<strong>没有刻意要删除重复行，那么就使用 UNION All</strong></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/15/mysql12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sql原理之索引</title>
      <link>https://blog.tokenlen.top/2025/03/07/sql3/</link>
      <guid>https://blog.tokenlen.top/2025/03/07/sql3/</guid>
      <pubDate>Thu, 06 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p><h1 id="常见的查询算法以及数据结构"><a href="#常见的查询算法以及数据结构" class="headerlink" title="常见的查询算法以及数据结构"></a>常见的查询算法以及数据结构</h1><p>建立索引，其实就是为了构建一种数据结构，可以应用到上面的一种算法。提供查询的效率</p><p>索引的本质是：</p><p>帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是<strong>数据结构</strong>。</p><p>如果没用索引的话，会按照上下顺序来查找，就会匹配整张表，这叫全表扫描，这样的效率是很低的。</p><p>而mysql中的索引是在引擎层中实现的</p><p>b+tree索引    最常见的    都支持</p><p>hash索引    精确匹配    memory支持</p><p>r-tree索引    空间位置    myisam支持</p><p>full-text索引    除了memory不支持其他都支持</p><p>b-tree多路平衡查找树</p><p>几阶b-tree就最多有几个节点，会有n+1个指针</p><h2 id="查询算法"><a href="#查询算法" class="headerlink" title="查询算法"></a>查询算法</h2><p>顺序查找：</p><p>对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。 </p><p>数据结构是<strong>队列</strong></p><p>时间复杂度是O(n)</p><p>二分查找：</p><p>查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。</p><p>数据结构是<strong>数组</strong></p><p>时间复杂度：O(logn)</p><p>二叉排序树查找：</p><p>二叉排序树的特点是：</p><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ol><p>搜索的原理：</p><ol><li>若b是空树，则搜索失败，否则：</li><li>若x等于b的根节点的数据域之值，则查找成功；否则：</li><li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li><li>查找右子树。</li></ol><p>数据结构是<strong>二叉排序树</strong></p><p>时间复杂度：O(log2N)</p><p>哈希表：其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。</p><p>数据结构：哈希表</p><p>时间复杂度：几乎是<code>O(1)</code>，取决于产生冲突的多少（hash碰撞）。</p><p>分块查找：</p><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”<strong>按块有序</strong>”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。<br>　　<br>算法流程：</p><ol><li>先选取各块中的最大关键字构成一个索引表；</li><li>查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</li></ol><p>这种搜索算法每一次比较都使<strong>搜索范围缩小一半</strong>。它们的查询速度就有了很大的提升，复杂度为。</p><p>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p>B树，它就是一种平衡多路查找树。下图就是一个典型的B树：</p><p><img src="https://img-blog.csdn.net/20160926140212457" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/3e9a3201e1f546bc88cc9aa83e5ad078.jpeg" alt=""></p><p><strong>满了中间元素向上分裂</strong>每一个key都会对应</p><p>由于B-Tree的特性，在B-Tree中按<strong>key检索数据</strong>的算法非常直观：首先从根节点进行<strong>二分查找</strong>，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。</p><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为<code>logd((N+1)/2)</code>，检索一个key，其查找节点个数的渐进复杂度为<code>O(logdN)</code>。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>在b+树中所有的元素都会在叶子节点，叶子节点会形成一个单向链表，<strong>非叶子节点</strong>只会起到<strong>索引</strong>的作用</p><p>mysql的所有，会形成了一个带有顺序的指针b+tree</p><p>所有的数据都会在<strong>叶子节点</strong>，用来存储数据，存储在页中</p><p>特点：</p><ul><li>每个节点的指针上限为2d而不是2d+1；</li><li>内节点不存储data，只存储key；</li><li>叶子节点不存储指针；</li></ul><p>下面就是一个B+Tree</p><p><img src="https://img-blog.csdn.net/20160926140413000" alt=""></p><p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p>为什么innodb引擎选择使用b+tree？</p><ul><li><p>对于b+树对于二叉树的层级更少，搜索效率高</p></li><li><p>相对于b-ree无论是叶子节点还是非叶子节点，都会保存<strong>数据</strong>，会导致键值变少，指针变少，同样要保留大量数据，只能增加树的高度，导致性能降低</p></li><li>对于hash索引来说，可以<strong>范围索引和排序</strong></li></ul><h1 id="涉及的计算机原理"><a href="#涉及的计算机原理" class="headerlink" title="涉及的计算机原理"></a>涉及的计算机原理</h1><h2 id="两种类型的存储"><a href="#两种类型的存储" class="headerlink" title="两种类型的存储"></a>两种类型的存储</h2><p>在计算机系统中一般包含两种类型的存储，<strong>计算机主存</strong>（RAM）和<strong>外部存储器</strong>（如硬盘、CD、SSD等）。在设计索引算法和存储结构时，我们必须要考虑到这两种类型的存储特点。主存的读取速度快，相对于主存，外部磁盘的数据读取速率要比主从慢好几个数量级，具体它们之间的差别后面会详细介绍。 上面讲的所有查询算法都是假设数据存储在计算机主存中的，计算机主存一般比较小，实际数据库中数据都是存储到外部存储器的。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以<strong>索引文件的形式存储的磁盘上</strong>。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，<strong>所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度</strong>。换句话说，<strong>索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</strong>下面详细介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h2 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h2><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。 </p><p><img src="https://img-blog.csdn.net/20160926140724145" alt=""></p><p>从抽象角度看，<strong>主存是一系列的存储单元组成的矩阵</strong>，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。</p><p>主存的存取过程如下：</p><p>当系统需要读取主存时，则将<strong>地址信号放到地址总线</strong>上传给主存，主存读到地址信号后，解析信号并定位到<strong>指定存储单元</strong>，然后将此存储单元数据放到<strong>数据总线</strong>上，供其它部件读取。写主存的过程类似，系统将要写入单元地址和数据分别放在<strong>地址总线和数据总线</strong>上，主存读取两个总线的内容，做相应的写操作。</p><p>这里可以看出，<strong>主存存取的时间仅与存取次数呈线性关系</strong>，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h2 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h2><p>上文说过，索引一般以<strong>文件</strong>形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>磁盘读取数据靠的是<strong>机械运动</strong>，当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，<strong>即确定要读的数据在哪个磁道，哪个扇区</strong>。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，<strong>磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，<em>**</em></strong>然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间<strong>**，最后便是对读取数据的传输。 所以每次读取数据花费的时间可以分为</strong>寻道时间、旋转延迟、传输时间**三个部分。其中：</p><ul><li>寻道时间是<strong>磁臂移动到指定磁道</strong>所需要的时间，主流磁盘一般在5ms以下。</li><li>旋转延迟就是我们经常听说的<strong>磁盘转速</strong>，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。</li><li>传输时间指的是<strong>从磁盘读出或将数据写入磁盘的时间</strong>，一般在零点几毫秒，相对于前两个时间可以忽略不计。</li></ul><p>那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><h2 id="局部性原理和磁盘预读"><a href="#局部性原理和磁盘预读" class="headerlink" title="局部性原理和磁盘预读"></a>局部性原理和磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，<strong>磁盘往往不是严格按需读取，而是每次都会预读</strong>，即使只需要一个字节，<strong>磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存</strong>。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于<strong>磁盘顺序读取</strong>的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为<strong>页（page）的整倍数</strong>。页是<strong>计算机管理存储器的逻辑块</strong>，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，<strong>每个存储块称为一页</strong>（在许多操作系统中，页得大小通常为<strong>4k</strong>），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问<code>h-1</code>个节点（根节点常驻内存）。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，<strong>这样每个节点只需要一次I/O就可以完全载入</strong>。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，<strong>就实现了一个node只需一次I/O</strong>。一个节点物理上也是存在一个页里面</p><p>B-Tree中一次检索<strong>最多需要<code>h-1</code>次I/O</strong>（根节点常驻内存），渐进复杂度为<code>O(h)=O(logdN)</code>。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，如果我们<strong>采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，</strong>所以用B-Tree作为索引结构效率是非常高的。</p><h2 id="B-Tree-2"><a href="#B-Tree-2" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>从上面介绍我们知道，B树的搜索复杂度为<code>O(h)=O(logdN)</code>，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以<strong>增加出度d的宽度</strong>，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmax=floor(pagesize/(keysize+datasize+pointsize))//floor表示向下取整</span><br></pre></td></tr></table></figure><p>由于B+Tree内节点去掉了data域，因此可以拥有<strong>更大的出度</strong>，从而拥有更好的性能。</p><p>B-树和B+树查找过程基本一致。如上图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生<strong>一次IO</strong>，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生<strong>第二次IO</strong>，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，<strong>发生第三次IO</strong>，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，<strong>3层的b+树可以表示上百万的数据，</strong>如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><p><img src="https://img-blog.csdn.net/20160926141127260" alt=""></p><p>所以说很多数据的话，也只需要<strong>3次IO</strong>，这样的话效率就非常高了。</p><h1 id="mysql中的索引"><a href="#mysql中的索引" class="headerlink" title="mysql中的索引"></a>mysql中的索引</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>索引的分类：</p><p>主键索引，对于主键的创建的索引，只能有<strong>一个</strong>，默认自动创建 <strong>primary</strong></p><p>唯一索引，避免同一个表中的数据列的值重复，<strong>unique</strong></p><p>常规索引 快速定位数据</p><p>全文索引 查找文本中的关键字，而不是索引中的值，关键词<strong>fulltext</strong></p><p>还分为</p><p>聚集索引：数据存储和索引放在一个，必须有而且<strong>只能有一个</strong></p><p>二级索引，将数据和索引分开，<strong>叶子节点关联的是对应的主键</strong></p><p>聚集索引：</p><ul><li>存在主键，<strong>主键索引就是聚集索引</strong></li><li>不存在主键，将会引用第一个唯一索引作为聚集索引</li><li>没有主键，没有唯一索引，Innodb会自动生成一个rowid作为隐藏的聚集索引</li></ul><p>回表查询：先走二级索引找到对应的主键值，再到聚集索引中拿到这一行的行数据</p><p>思考：</p><p>innodb的b+tree高度是多少？</p><p><strong>16*1171^h</strong>,高度为h</p><p>语法：</p><p>创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE/FULLLTEXT] INDEX INDEX_NAME ON TABLE_NAME(INDEX_COL_NAME...);</span><br></pre></td></tr></table></figure><p>一个索引是可以关联多个字段的</p><p>查看索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from table_name;</span><br></pre></td></tr></table></figure><p>删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table_name;</span><br></pre></td></tr></table></figure><p>索引名字格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idx_user_name;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_name <span class="keyword">ON</span> uers(name);</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">UNIQUE</span> INDEX idx_users_email <span class="keyword">ON</span> users(email);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_name_age <span class="keyword">ON</span> users(name,age);</span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDXE id_users_bio <span class="keyword">ON</span> users(bio);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">DROP</span> INDEX id_users_name <span class="keyword">ON</span> users;</span><br></pre></td></tr></table></figure><h2 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h2><p>查询当前数据的增删改查执行效率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure><p>可以统计 <code>Com_select</code>、<code>Com_insert</code>、<code>Com_update</code>、<code>Com_delete</code> 等的执行次数，判断数据库的查询负载。</p><p><strong>慢查询：</strong></p><p>查询当前sql超时标准（默认long_query_time为10s，超过10s的记录才会查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;long_query_time&#x27;;</span><br></pre></td></tr></table></figure><p>开启慢查询日志，编辑 <strong><code>/etc/my.cnf</code></strong> 或 <strong><code>my.ini</code></strong>（Windows）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询慢查询日志文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;slow_query_log_file&#x27;;</span><br></pre></td></tr></table></figure><p>然后 <code>cat</code> 或 <code>tail -f</code> 这个文件，查看慢查询 SQL。</p><p><strong>PROFILES：</strong></p><p>查看sql执行的时间分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br></pre></td></tr></table></figure><p>默认是关闭的状态，需要手动开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET profiling = 1;</span><br></pre></td></tr></table></figure><p>执行查询完成后，再次查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILE CPU FOR QUERY 16;</span><br></pre></td></tr></table></figure><p>这里 <code>16</code> 是 <code>SHOW PROFILES</code> 里查询的 <code>Query_ID</code>，可以查看具体 SQL 的 <strong>CPU 耗时</strong> 详情。</p><p><strong>explain:</strong></p><p>EXPLAIN + sql语句可以看到sql语句的执行情况</p><p>返回的详情为：</p><p>id:sql执行的顺序，数值越大，越先执行</p><p>select_type:</p><ul><li>simple 简单查询 不用表连接和子查询</li><li>primary 主查询 即外层的查询</li><li>union union后的查询 union中的第二个或者后面的查询语句</li><li>subquery 子查询 select/where之后包含了子查询</li></ul><p>type：查询类型，效率从高到低排序</p><ul><li>null</li><li>system</li><li>const</li><li>eq_ref</li><li>ref</li><li>range</li><li>index</li><li>all 全表扫描</li></ul><p>possible_keys：可能用到的索引</p><p>key:实际用到的索引</p><p>key_len：索引的长度</p><p>rows：预估扫描的行数</p><p>filtered:过滤后返回的行数占比，越大越好</p><h2 id="索引的原则"><a href="#索引的原则" class="headerlink" title="索引的原则"></a>索引的原则</h2><p><strong>最左前缀法则：</strong></p><p>查询使用索引要从索引的最左列开始，不能跳过，跳过的话，后面的索引会失效。</p><p>必须包含最左边的一列，在哪无所谓，必须要存在</p><p>比如我们建立一个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br></pre></td></tr></table></figure><p>如果我们sql语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27;;</span><br><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; AND age = 30;</span><br></pre></td></tr></table></figure><p>这样的话索引不会失效，但是如果从age开始的话，索引就会失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE age = 30;</span><br></pre></td></tr></table></figure><p><strong>范围查询：</strong></p><p>联合查询中，出现范围查询（&lt;&gt;）范围查询右侧的索引列失效</p><p>使用大于等于或者小于等于就可以避免后面的索引失效</p><p>比如我们建立一个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br></pre></td></tr></table></figure><p>进行精确查询，索引不会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; AND age = 30;</span><br></pre></td></tr></table></figure><p>但是进行范围查询的时候，后面的索引就会失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; AND age &gt; 25 AND city = &#x27;New York&#x27;;</span><br></pre></td></tr></table></figure><p><strong>索引列运算操作：</strong></p><p>不饿能在索引列上进行运算操作，否则索引会失效</p><p>不能不加单引号，否则索引也会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE YEAR(created_at) = 2024;</span><br></pre></td></tr></table></figure><p>这样索引会失效的</p><p>但是我们进行一些优化，进行范围查询（带着等于的），索引就不会失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE created_at &gt;= &#x27;2024-01-01&#x27; AND created_at &lt; &#x27;2025-01-01&#x27;;</span><br></pre></td></tr></table></figure><p><strong>模糊查询：</strong></p><p>尾部进行模糊查询，索引不会失效，头部进行模糊匹配索引会失效。</p><p>后面加%可以进行索引，前面加%索引就会失效，一般别写这种sql语句</p><p>尾部匹配是有效的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name LIKE &#x27;Alice%&#x27;;</span><br></pre></td></tr></table></figure><p>但是头部匹配索引就会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name LIKE &#x27;%Alice&#x27;;</span><br></pre></td></tr></table></figure><p>如果我们想使用模糊匹配的话，可以使用FULLTEXT索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX idx_users_bio ON users(bio);</span><br><span class="line">SELECT * FROM users WHERE MATCH(bio) AGAINST(&#x27;keyword&#x27;);</span><br></pre></td></tr></table></figure><p>这样来进行匹配查询</p><p><strong>OR</strong>：</p><p>OR左右两侧都要有索引，否则索引会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; OR age = 30;</span><br></pre></td></tr></table></figure><p>为了不让其失效，我们可以使用UNION ALL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT * FROM users WHERE age = 30;</span><br></pre></td></tr></table></figure><p><strong>数据分布影响索引：</strong></p><p>索引适用于高选择性字段（不同值较多的列）</p><p>如果 <strong>查询大量数据</strong>，可能 <strong>全表扫描比索引更快</strong>，可以<strong>忽略索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users IGNORE INDEX(idx_user_name) WHERE status = &#x27;active&#x27;;</span><br></pre></td></tr></table></figure><p><strong>sql提示：</strong></p><p>use index使用某个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users USE INDEX(idx_user_name) WHERE name = &#x27;Alice&#x27;;</span><br></pre></td></tr></table></figure><p>ignore index 忽略索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users IGNORE INDEX(idx_user_name) WHERE name = &#x27;Alice&#x27;;</span><br></pre></td></tr></table></figure><p>force index 强制使用某个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users FORCE INDEX(idx_user_name) WHERE name = &#x27;Alice&#x27;;</span><br></pre></td></tr></table></figure><p><strong>覆盖索引：</strong></p><p>查询的字段都在索引列内，可以避免回表，提高查询效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br><span class="line">SELECT name, age FROM users WHERE name = &#x27;Alice&#x27;; -- 只查询索引列，避免回表</span><br></pre></td></tr></table></figure><p><strong>前缀过长：</strong></p><p>适用于字符串索引过长的情况，只索引字符串的一部分</p><p>计算型索引（越接近1.0越好）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT email) / COUNT(*) FROM users;</span><br></pre></td></tr></table></figure><p>前缀索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_email_5 ON users(email(5)); -- 仅索引 email 前 5 个字符</span><br></pre></td></tr></table></figure><p><strong>联合索引：</strong></p><p>更推荐联合索引，索引效率更加高效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br></pre></td></tr></table></figure><p>大原则：</p><ul><li>数据量大，查询比较频繁的表要建立索引，对查询条件进行索引，尽量使用<strong>联合索引</strong>。</li><li>要使用区分度高的索引</li><li>字符串类型的索引，要建立前缀索引。要考虑前缀的区分度</li><li>要控制索引的效率</li><li>索引不能存储null值，建立表的时候要采用not null的约束</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/07/sql3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络重要问题总结</title>
      <link>https://blog.tokenlen.top/2025/03/06/net3/</link>
      <guid>https://blog.tokenlen.top/2025/03/06/net3/</guid>
      <pubDate>Wed, 05 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;1-说下计算机网络体系结构&quot;&gt;&lt;a href=&quot;#1-说下计算机网络体系结构&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-说下计算机网络体系结构"><a href="#1-说下计算机网络体系结构" class="headerlink" title="1.说下计算机网络体系结构"></a>1.说下计算机网络体系结构</h2><p>计算机网络体系结构通过复杂的网络通信分为不同的层次，来实现交互化的目的。常见的模型分为OSI七层模型，tcp/ip四层模型和五层体系结构</p><p>OSI是理论上的网络通信模型，TCP/IP是实际应用层面的网络通信模型，五层结构是为了方便理解和记忆</p><p><strong>OSI七层模型</strong>是一个网络架构模型，由国际标准化祖师提出，用于描述和标准化各种计算机网络的功能和过程。这七层分别是<br>应用层：最靠近用户的层，负责处理特定的应用程序细节。这一层提供了网络服务和用户应用软件之间的接口，例如web浏览器,ftp客户端和服务器，电子邮件客户端等等。</p><p>表示层：<strong>确保一个系统发送的信息可以被另一个系统的应用层读取</strong>。负责数据的转换压缩和加密。例如，确保数据从一种编码格式转换为另一种。ASCII-&gt;EBCDIC</p><p>会话层:管理用户的会话，空网络上两节点之间的对话和数据交换的管理。负责建立维护和终止会话。例如建立一个回鹘令牌，以便在网络上两个节点进行传递。</p><p>传输层：提供<strong>端到端</strong>的通信服务，保证数据的完整性和正确顺序。这一层包括TCP和UDP等。</p><p>网络层：负责在多个网络之间进行数据传输，确保数据能够在复杂的网络结构中找到源到目的地的最佳路径，这层使用的是IP协议</p><p>数据链路层：在物理连接中提供可靠的<strong>传输</strong>，负责建立和维护两个相邻节点的链路。包括帧同步,MAC</p><p>物理层:负责在<strong>物理媒介</strong>上实现原始的数据传输，比如电缆光缆和无线信号传输。涉及的内容包括电压，接口，针脚，电缆的规格和传输速率等。</p><p><strong>TCP/IP协议四层模型</strong>是互联网通信的核心，定义了一系列协议和标准，确保设备间可以可靠地进行数据传输。</p><p>应用层：直接面向用户和应用程序，提供各种网络服务。它包含了用于<strong>特定应用的协议和服务</strong>，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</p><p>传输层：提供<strong>端到端</strong>的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 TCP 和 UDP。</p><p>网络层：负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。</p><p>网络接口层：负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。</p><p><strong>五层结构体系</strong></p><p>对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</p><ul><li>应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li><li>传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li><li>网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li><li>数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li><li>物理层：电缆、光纤、无线电频谱、网络适配器等</li></ul><p>TCP的三次握手和四次挥手在哪一层？</p><p>三次握手和四次挥手都是工作在<strong>传输层</strong>。传输层（Transport Layer）是 OSI 模型的第四层，负责提供端到端的通信服务，包括数据传输的建立、维护和终止。</p><p>TCP作为一种面向连接的协议，通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性和完整性。</p><p>将一下计算机网络？</p><p>计算机网络是指将多台计算机通过<strong>通信设备</strong>互联起来，实现资源共享和信息传递的系统。</p><h2 id="2-说一下每层对应的网络协议有哪些"><a href="#2-说一下每层对应的网络协议有哪些" class="headerlink" title="2.说一下每层对应的网络协议有哪些"></a>2.说一下每层对应的网络协议有哪些</h2><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad64bbac-e0d5-4286-9b77-d008e8c8d419.jpg" alt=""></p><h2 id="3-数据在各层之中时怎么传输的"><a href="#3-数据在各层之中时怎么传输的" class="headerlink" title="3.数据在各层之中时怎么传输的"></a>3.数据在各层之中时怎么传输的</h2><p>对发送方而言，从上层到下层层层包装，对于接受方来说，从下层到上层层层解开包装。</p><ul><li>发送方的应用进程向接受方的应用进程传送数据</li><li>AP 先将数据交给本主机的<strong>应用层</strong>，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li><li>传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元</li><li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li><li>最后的物理层，进行比特流的传输</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg" alt=""></p><h1 id="网络综合"><a href="#网络综合" class="headerlink" title="网络综合"></a>网络综合</h1><h2 id="4-从浏览器地址栏输入url到显示网页的过程"><a href="#4-从浏览器地址栏输入url到显示网页的过程" class="headerlink" title="4.从浏览器地址栏输入url到显示网页的过程"></a>4.从浏览器地址栏输入url到显示网页的过程</h2><p>过程包括多个步骤，涵盖了 DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 响应、浏览器处理响应并渲染页面等多个环节。</p><ol><li><strong>DNS 解析</strong>：浏览器会发起一个 DNS 请求到 DNS 服务器，将<strong>域名解析为服务器的 IP 地址</strong>。</li><li><strong>TCP 连接</strong>：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接。这一步涉及到 TCP 的三次握手，用于确保双方都已经准备好进行数据传输了。</li><li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求，包括请求行、请求头和请求体；然后将请求发送到服务器。</li><li><strong>服务器处理请求</strong>：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理，生成 HTTP 响应消息；响应消息包括状态行、响应头和响应体。</li><li><strong>浏览器接收 HTTP 响应</strong>：浏览器接收到服务器返回的 HTTP 响应数据后，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。</li><li><strong>断开连接</strong>：TCP 四次挥手，连接结束</li></ol><p>各个过程用了哪些协议：</p><p>DNS解析：DNS协议</p><p>剩下的步骤：TCP协议，IP协议，OPSF协议</p><p>ARP协议，HTTP协议</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f5ff6e46-4524-4594-b294-56a23c366df9.jpg" alt=""></p><h2 id="5-DNS解析的过程"><a href="#5-DNS解析的过程" class="headerlink" title="5.DNS解析的过程"></a>5.DNS解析的过程</h2><p>DNS是域名解析系统，可以将域名映射到对应的IP地址上，</p><p>比如说我们访问 www.tokenlen.top，实际上访问的是我在阿里云上一台丐版服务器，它的 IP 地址是 xxx.xxx.xxx.xxx。</p><p>当然也可以直接使用IP地址来访问，但是IP地址不太好记。</p><p>域名到IP的映射就需要DNS来完成</p><p>DNS解析过程：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-03408af8-3ca8-49bd-9244-6afa6fe132c6.jpg" alt=""></p><h2 id="6-webSOCKET和Socket的区别"><a href="#6-webSOCKET和Socket的区别" class="headerlink" title="6.webSOCKET和Socket的区别"></a>6.webSOCKET和Socket的区别</h2><p>Socket=IP+端口+协议</p><p>是一套标准，完成了对TCP/IP的高度封装，屏蔽网络细节，以便更好的网络编程</p><p>webSocket是一个持久化的协议，伴随H5而出的协议，用来解决</p><p>http不支持持久化连接的问题</p><p>Socket是一个<strong>网络编程的标准接口</strong>，webSocket则是<strong>应用层通信协议</strong></p><h2 id="7-常见的端口及其对应的服务"><a href="#7-常见的端口及其对应的服务" class="headerlink" title="7.常见的端口及其对应的服务"></a>7.常见的端口及其对应的服务</h2><p>port           server</p><p>21            ftp</p><p>22            ssh</p><p>23             telent</p><p>53            dns</p><p>80            http</p><p>443            https</p><p>1080            sockets</p><p>3306            mysql</p><p>5524            alist</p><p>8080            测试端口</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="8-http常用的状态码及其意义"><a href="#8-http常用的状态码及其意义" class="headerlink" title="8.http常用的状态码及其意义"></a>8.http常用的状态码及其意义</h2><p>1xx：成功，需要进一步操作,100 continue</p><p>2xx:成功，200ok完成 204缺少一部分body</p><p>3xx:重定向 301 永久重定向,302临时重定向</p><p>4xx:客户端有问题,404资源不存在，403没有权限访问</p><p>5xx:服务器有问题，500服务器内部问题，502网关或者代理出了问题，504网关超时</p><h2 id="9-http请求"><a href="#9-http请求" class="headerlink" title="9.http请求"></a>9.http请求</h2><p>get：获取数据，是幂等的，不能发送太多，限制2kb</p><p>post:提交数据，不是幂等的，发送一般不限制</p><p>delete:删除指定的资源</p><p>put:更新指定的资源</p><p>herd:类似get请求，返回响应中没有具体的内容，获取报头。用于检查资源资源是否存在，验证资源的更新时间等等</p><p>options:获取服务器支持的Http方法</p><p>trace:回显服务器收到的请求，用于测试</p><p>connect:建立一个到目标资源的隧道，用于客户端和服务器之间进行加密的隧道传输。</p><h2 id="10-get和post请求的区别"><a href="#10-get和post请求的区别" class="headerlink" title="10.get和post请求的区别"></a>10.get和post请求的区别</h2><p>get主要用于获取数据，参数附加在url栏中，存在长度限制,2kb，这个长度限制不是url的限制而是服务器的限制，是针对整个url的限制，而不是对数据部分的限制，容易被浏览器缓存，有安全风险，post用于提交数据，参数放在请求体中,适合提交大量或者敏感的数据。</p><p>get请求是幂等的，多次提交不会改变服务器状态，post请求不是幂等的，可能会对服务器数据有影响。</p><h2 id="11-http请求的过程和原理"><a href="#11-http请求的过程和原理" class="headerlink" title="11.http请求的过程和原理"></a>11.http请求的过程和原理</h2><p>http是基于tcp/ip协议的应用层协议，使用tcp作为传输层协议，通过建立tcp连接来传输数据</p><p>http遵循标准的客户端-服务器模型，客户端打开连接发出请求，然后等待服务器返回的响应</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-9a1a42b7-c14a-43d8-b8d8-f1f18c9b923b.jpg" alt=""></p><ul><li>在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。</li><li>TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。</li><li>服务器收到请求后，会根据请求的信息处理请求。</li><li>处理完请求后，服务器会返回一个 HTTP 响应给浏览器。</li><li>浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。</li></ul><p>客户端发送一个请求到服务器，服务器处理请求并返回一个响应。这个过程是同步的，也就是说，<strong>客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。</strong></p><p>利用多线程来下载一个数据</p><p>可以采用分块下载的策略，首先使用head来获取文件的总大小，然后根据文件大小和线程数，将文件进行切割，每个线程负责下载一个特定范围的数据</p><p>可以通过设置http请求头的range字段指定下载的字节区间</p><p>例如，<code>Range: bytes=0-1023</code> 表示下载文件的前 1024 字节。</p><p>最后启动多线程下载。</p><h2 id="12-http的报文结构"><a href="#12-http的报文结构" class="headerlink" title="12.http的报文结构"></a>12.http的报文结构</h2><p>http的报文结构分为请求报文和响应报文</p><p>都包含了起始行，头部，和消息正文</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-2ea62914-e1ed-418c-9580-e13ecf7b8992.jpg" alt=""></p><p>请求报文：</p><p>请求报文由请求行，请求头部，空行和消息正文组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.javabetter.cn</span><br><span class="line">Accept: text/html</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br></pre></td></tr></table></figure><p>GET /index.html HTTP/1.1请求行，包括请求url和http协议的版本</p><p>请求头部包含请求的附加信息：</p><ul><li><code>Host: www.javabetter.cn</code>，表示请求的主机名（域名）</li><li><code>Accept: text/html</code>，表示客户端可以接收的媒体类型</li><li><code>User-Agent: Mozilla/5.0</code>，表示客户端的浏览器类型</li><li>Range：用于指定请求内容的范围，如断点续传时表示请求的字节范围。</li></ul><p>请求头部和消息正文之间有一个空行，表示请求头部结束</p><p>消息正文是可选的，如post请求中的表单数据，get请求没有正文</p><p>响应报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;mengnankk&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>状态行：包括http协议的方法，状态码，和消息状态</p><p>响应头部：</p><ul><li><code>Content-Type: text/plain</code>，表示响应的内容类型</li><li><code>Content-Length: 137582</code>，表示响应的内容长度</li><li><code>Expires: Thu, 05 Dec 1997 16:00:00 GMT</code>，表示资源的过期时间</li><li><code>Last-Modified: Wed, 5 August 1996 15:55:28 GMT</code>，表示资源的最后修改时间</li><li><code>Server: Apache 0.84</code>，表示服务器类型</li></ul><p>空行：表示响应头部结束</p><p>消息正文：响应的具体内容，例如html界面，不是所有的响应都有正文消息，例如204(没有响应中的body)</p><h2 id="13-url和uri有什么区别"><a href="#13-url和uri有什么区别" class="headerlink" title="13.url和uri有什么区别"></a>13.url和uri有什么区别</h2><p>URI：统一资源标识符(Uniform Resource Identifier， URI)，标识的是 Web <strong>上每一种可用的资源</strong>，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。</p><p>URL：统一资源定位符（Uniform Resource Location），它是 URI 的一种子集，主要作用是<strong>提供资源的路径。</strong></p><p>URL <strong>除了提供了资源的标识，还提供了资源访问的方式</strong>。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx 职业技术学院/14 号宿舍楼/525 号寝/张三.男。</p><h2 id="15-http长连接"><a href="#15-http长连接" class="headerlink" title="15.http长连接"></a>15.http长连接</h2><p>在Http中，长连接是指客户端和服务器在完成一次http通信后，连接不会立即断开，而是保留连接以供后序使用</p><p>这种机制可以减少了频繁建立和关闭连接的开销</p><p>设置长连接：通过 <strong>Connection: keep-alive</strong> 实现。在 HTTP/1.1 中，长连接是默认开启的。</p><p>超时：</p><p>http一般会有httpd守护进程，里面可以设置keep-alive timeout，当tcp连接闲置超过这个时间就会关闭，也可以在http里的header里设置超时时间</p><p>TCP 的 <strong>keep-alive</strong> 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. tcp_keepalive_intvl = 15</span><br><span class="line">2. tcp_keepalive_probes = 5</span><br><span class="line">3. tcp_keepalive_time = 1800</span><br></pre></td></tr></table></figure><h2 id="16-http和https的区别"><a href="#16-http和https的区别" class="headerlink" title="16.http和https的区别"></a>16.http和https的区别</h2><p>https是http的增强版，是在http的基础上加入了ssl/tls协议，确保数据在传输过程中是加密的</p><p>http的默认端口是80,url以<a href="http://开头,https默认端口是443,url以https://开头">http://开头,https默认端口是443,url以https://开头</a></p><p>https基于<strong>传输层</strong>，http基于<strong>应用层</strong></p><p>https在浏览器显示绿色安全锁，http则没有</p><h2 id="17-https连接的建立过程"><a href="#17-https连接的建立过程" class="headerlink" title="17.https连接的建立过程"></a>17.https连接的建立过程</h2><p><img src="https://cdn.tobebetterjavaer.com/stutymore/network-20240418124713.png" alt=""></p><ol><li>客户端向服务器发送请求</li><li>服务器接收到请求后，返回自己的数字证书，包含了公匙，颁发机构等</li><li>客户端接收到服务器的证书后，验证证书的合法性，如果合法，会生成一个随机码，然后用服务器的公匙加密整个随机码，然后发送给服务器</li><li>服务器收到会话密钥后，用私钥解密，得到会话密钥</li><li>客户端和服务器通过会吗密码对通信内容进行加密，然后传输</li></ol><p>通信内容被截取，没有会话密钥，无法解密。新的连接建立后，生成的密钥是新的</p><p><strong>url会被https加密吗？</strong></p><p>https会加密url，因为url是http头部的一部分。但是完整的url可能会在web服务器的日志中记录，浏览器中也是可以看到的。所以敏感信息不应该通过url来传输</p><p><strong>中间人攻击</strong>？</p><p>攻击者可以在通信的两端插入自己，以窃取通信双方的信息。</p><p>中间人攻击是一个<strong>缺乏相互认证</strong>的攻击，因此大多数加密协议都会专门加入一些特殊的认证方法，以防止中间人攻击。像 SSL 协议，就是通过验证服务器的数字证书，是否由 CA（权威的受信任的数字证书认证机构）签发，来防止中间人攻击的</p><p><strong>http如何保证建立的信道是安全的？</strong></p><p>通过 SSL/TLS 协议的多层次安全机制，首先在握手阶段，客户端和服务器使用得是非对称加密，生成的会话密钥只<strong>有服务器的私钥</strong>才能解密，而私钥只有服务器持有。</p><h2 id="18-如何理解http是无状态的"><a href="#18-如何理解http是无状态的" class="headerlink" title="18.如何理解http是无状态的"></a>18.如何理解http是无状态的</h2><p>http协议是无状态的，表明每个http请求都是<strong>独立</strong>的，服务器不会保留任何关于<strong>客户端请求的历史信息</strong></p><ul><li>每个 HTTP 请求都包含了所必须的信息，服务器在处理当前请求时，不依赖于之前的任何请求信息。</li><li>服务器不会记录任何客户端请求的状态，每次请求都像是第一次与服务器通信。</li></ul><p>维持记录状态</p><p>cookies：服务器通过 Set-Cookie 响应头将状态信息存储在客户端，客户端在后续请求中发送该 Cookie 以维持状态。</p><p>session：服务器生成一个唯一的会话 ID，存储在 Cookie 中，并在服务器端维护与该会话 ID 关联的状态信息。</p><p>token：使用 JWT（JSON Web Token）等机制在客户端存储状态信息，客户端在每次请求中发送该 Token。</p><h1 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h1><h2 id="19-详细说一下tcp的三次握手机制"><a href="#19-详细说一下tcp的三次握手机制" class="headerlink" title="19.详细说一下tcp的三次握手机制"></a>19.详细说一下tcp的三次握手机制</h2><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-a6c0457e-544e-4291-98d9-862fc6a18631.jpg" alt=""></p><p>第一次握手：客户端将TCP报文标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p><p>第二次握手：服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个序号值<code>seq=K</code>，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</p><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code>状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>服务器发送完<strong>SYN－ACK</strong>包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的<strong>最大重传次数</strong>，系统将该连接信息从<strong>半连接队列</strong>中删除。</p><p>第三次握手：客户端收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><p><strong>全连接队列</strong>就是三次握手已经完成了，建立起的连接就会放到全连接队列里，队列满了就会出现丢包。</p><p>其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而<strong>第三次握手是可以携带数据</strong>的。</p><p>其中上面的ack和ACK不是同一个概念</p><ul><li>小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，<code>ack=seq+1</code>。</li><li>大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。</li></ul><p><strong>说说SYN的概念</strong></p><p>SYN是TCP 协议中用来建立连接的一个标志位，全称为 Synchronize Sequence Numbers，也就是同步序列编号。</p><p>不仅确保了序列号的同步，使得后续的数据能够有序传输，还能防止旧的报文段被误认为是新连接。</p><p><strong>泛洪攻击</strong></p><p>是一种常见的 DoS（拒绝服务）攻击，攻击者会发送大量的伪造的 TCP 连接请求，导致服务器资源耗尽，无法处理正常的连接请求。</p><p>半连接服务拒绝，也称为 SYN 洪泛攻击或 SYN Flood。</p><p>所谓的半连接就是指在 TCP 的三次握手过程中，当服务器接收到来自客户端的第一个 SYN 包后，它会回复一个 SYN-ACK 包，此时连接处于“半开”状态，因为连接的建立还需要客户端发送最后一个 ACK 包。</p><p>在收到最后的 ACK 包之前，服务器会为这个尚未完成的连接分配一定的资源，并在它的队列中保留这个连接的位置。</p><p>解决方法：</p><p>重新设计 TCP 的连接建立过程，可以考虑引入 SYN cookies，这种技术通过在 SYN-ACK 响应中编码连接信息，从而在不占用大量资源的情况下验证客户端。</p><h2 id="20-tcp握手为什么是三次？"><a href="#20-tcp握手为什么是三次？" class="headerlink" title="20.tcp握手为什么是三次？"></a>20.tcp握手为什么是三次？</h2><p>使用三次握手可以建立一个可靠的连接，确保双方都知道对方已经准备好通信，同步双方的序列号，保证数据包的顺序和完整。</p><p>为什么不能是两次？</p><ul><li>防止客户端一直在等待</li><li>放置客户端已经将失效的连接请求传输到服务器</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad16baac-f8fa-4fb1-a459-8a98e4db85ca.jpg" alt=""></p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-4209349f-b80c-4387-8461-c6ecd0e2129b.jpg" alt=""></p><h2 id="21-三次握手中每一次没收到报文会发生什么情况"><a href="#21-三次握手中每一次没收到报文会发生什么情况" class="headerlink" title="21.三次握手中每一次没收到报文会发生什么情况"></a>21.三次握手中每一次没收到报文会发生什么情况</h2><p>第一次：第一次握手服务端未收到 SYN 报文</p><p>服务器不会进行任何的动作，如果客户端没收到发来的SYN-ACK包的话，等待一段时间后，会重新发送SYN报文，如果仍然没有回复，会重复这个过程。知道发送次数超过最大重传次数之后，返回连接建立失败。</p><p>第二次：第二次握手客户端未收到服务端响应的 ACK 报文</p><p>客户端会继续重传，服务端会阻塞在accpet()处，等待客户端发送ACK报文</p><p>第三次：第三次握手服务端为收到客户端发送过来的 ACK 报文</p><p>服务器同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态。</p><h2 id="22-第二次握手回传了ACK为什么还要传回SYN"><a href="#22-第二次握手回传了ACK为什么还要传回SYN" class="headerlink" title="22.第二次握手回传了ACK为什么还要传回SYN"></a>22.第二次握手回传了ACK为什么还要传回SYN</h2><p>ACK是为了告诉客户端传输的数据已经接受无误</p><p>SYN是为了告诉客户端，服务器响应的确实是客户端发送的报文。</p><h2 id="23-TCP半连接"><a href="#23-TCP半连接" class="headerlink" title="23.TCP半连接"></a>23.TCP半连接</h2><p>TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种未完全建立的状态。</p><p>就是第二次握手完成后，但是第三次握手还没完成</p><p>如果服务器回复了 SYN-ACK，但客户端还没有回复 ACK，该连接将一直保留在半连接队列中，直到超时或被拒绝。</p><p><strong>半连接队列</strong></p><p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f95c3cbb-cf2d-4444-9878-44ec076beb86.jpg" alt=""></p><p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p><ul><li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 <strong>ACK 和 SYN</strong>，状态由 <strong>LISTEN 变为 SYN_RCVD</strong>，此时这个连接就被推入了 <strong>SYN 队列</strong>，即半连接队列。</li><li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。</li></ul><p><strong>SYN FLood</strong></p><p>SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造<strong>不存在的 IP 地址</strong>, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 <strong>SYN</strong> 接收队列（半连接队列），使得服务器不能为正常⽤户服务。</p><p>应对方案：</p><p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p><ul><li><strong>syn cookie</strong>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li><li><strong>SYN Proxy 防火墙</strong>：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li></ul><h2 id="24-TCP四次挥手的过程"><a href="#24-TCP四次挥手的过程" class="headerlink" title="24.TCP四次挥手的过程"></a>24.TCP四次挥手的过程</h2><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ba156295-03af-46dc-8ef3-869b44b11303.jpg" alt=""></p><p>第一次挥手：客户端向服务器发送一个FIN结束报文，表示客户端没有数据可以发送了，但仍然可以接受数据，客户端进入FIN-WAIT-1状态</p><p>第二次挥手：服务器接受到FIN报文后，向客户端发送一个ACK报文，表示已经接受到客户端的FIN请求，服务器进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态</p><p>第三次挥手：服务器向客户端发送一个FIN请求，表示服务器也没有数据要发送了，服务器进入LAST-ACK状态</p><p>第四次挥手：客户端接收到FIN报文后，向服务器发送一个ACK请求，确认已经接受到服务器的FIN请求，客户端进入TIME-WAIT状态，等等一段时间后确保服务器接受到ACK请求，服务器收到ACK报文后进入CLOSE状态，客户端等待一段时间（2MSL）后进入CLOSE状态。</p><h2 id="25-为什么需要挥手四次"><a href="#25-为什么需要挥手四次" class="headerlink" title="25.为什么需要挥手四次"></a>25.为什么需要挥手四次</h2><p> TCP 是<strong>全双工通信协议</strong>，数据的发送和接收需要两次<strong>一来一回</strong>，也就是四次，<strong>来确保双方都能正确关闭连接</strong>。</p><p><strong>MSL</strong>：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p> <strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</p><p><strong>2. 防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p><p>等待 2 倍的 MSL，⽐较合理的解释是：<strong>⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应</strong>，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p><h2 id="26-保活计时器有什么用"><a href="#26-保活计时器有什么用" class="headerlink" title="26.保活计时器有什么用"></a>26.保活计时器有什么用</h2><p>除去时间等待器以外，TCP 还有一个保活计时器（keepalive timer）。</p><p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p><p>简单点理解就是检测客户端是否存活的一个计时器，设定好时间。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/06/net3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT100题</title>
      <link>https://blog.tokenlen.top/2025/03/02/leetcodehot/</link>
      <guid>https://blog.tokenlen.top/2025/03/02/leetcodehot/</guid>
      <pubDate>Sat, 01 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;hash&quot;&gt;&lt;a href=&quot;#hash&quot; class=&quot;headerlink&quot; title=&quot;hash&quot;&gt;&lt;/a&gt;hash&lt;/h1&gt;&lt;h2 id=&quot;1-hash映射&quot;&gt;&lt;a href=&quot;#1-hash映射&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><h2 id="1-hash映射"><a href="#1-hash映射" class="headerlink" title="1.hash映射"></a>1.<a href="https://leetcode.cn/problems/two-sum/solutions/6873/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/?envType=study-plan-v2&amp;envId=top-100-liked">hash映射</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p>wp:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里主要是用了map映射，</p><p>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 <strong>target-nums[i]</strong> 的 key 值<br>如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止</p><h2 id="2-字母异位词分组"><a href="#2-字母异位词分组" class="headerlink" title="2.字母异位词分组"></a>2.<a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p>wp:</p><p>字母相同，但排列不同的字符串，排序后都一定是相同的。因为每种字母的个数都是相同的，那么排序后的字符串就一定是相同的。</p><p>所以我们直接进行排序</p><p>使用stream流来做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">getAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.stream(strs).collect(Collectors.groupingBy(str -&gt; Stream.of(str.split(<span class="string">&quot;&quot;</span>)).sorted().collect(Collectors.joining()))).values());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str -&gt; split -&gt; stream -&gt; sort -&gt; join</p><h2 id="3-128-最长连续序列"><a href="#3-128-最长连续序列" class="headerlink" title="3.128. 最长连续序列"></a>3.<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>wp:</p><p>首先本题是不能排序来做的，因为排序的时间复杂度为O(<em>n</em>log<em>n</em>)</p><p>不符合题目的要求</p><p>对于 <em>nums</em> 中的元素 <em>x</em>，以 <em>x</em> 为起点，不断查找下一个数 <em>x</em>+1,<em>x</em>+2,⋯ 是否在 <em>nums</em> 中，并统计序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            st.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:st)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.contains(x-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(st.contains(y))&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,y-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要使用了hashset来存储nums这个数组</p><p>主要的核心就是for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:st)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.contains(x-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(st.contains(y))&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,y-x);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是去试x周围的数据，x-1和x+1。最后取值y-x获得最大序列的长度</p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="4-283-移动零"><a href="#4-283-移动零" class="headerlink" title="4.283. 移动零"></a>4.<a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p>wp:</p><p>这里我们参考快速排序的方法，以0为基准元素</p><p>我们使用两个指针 <code>i</code> 和 <code>j</code>，只要 <code>nums[i]!=0</code>，我们就交换 <code>nums[i]</code> 和 <code>nums[j]</code>在</p><p>这样我们很快就能完成排序</p><p>时间复杂度：<em>O</em>(<em>n</em>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j++] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-11-盛最多水的容器"><a href="#5-11-盛最多水的容器" class="headerlink" title="5.11. 盛最多水的容器"></a>5.<a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p>用一句话概括双指针解法的要点：<strong>指针每一次移动，都意味着排除掉了一个柱子</strong>。</p><p>如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> (j-i)*Math.min(height[i],height[j]);</span><br><span class="line">            res = Math.max(res,area);</span><br><span class="line">            <span class="keyword">if</span> (height[i]&lt;height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.<a href="https://leetcode.cn/problems/3sum/">三数之和</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p>首先对数组进行排序</p><p>固定一个数i</p><p>L是i后面一个，R是len的最后一个</p><p>如果nums[i]大于0的话,sum必然大于0</p><p>如果num[i]==nums[i-1]的话，说明数字重复了，需要跳过</p><p>sum==0的时候，nums[L]==nums[L+1]重复舍去</p><p>nums[R] = nums[R-1]重负舍去</p><p>其中L是++的，R是——的</p><p>然后开始编码</p><p>当sum&gt;0的时候说明R太大了，R—</p><p>Sum&lt;0的时候说明L太小了，L++</p><p>wp:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution6</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||len&lt;<span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L] == nums[L+<span class="number">1</span>]) L++;</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R] == nums[R-<span class="number">1</span>]) R--;</span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="6-无重复字符的最长子串"><a href="#6-无重复字符的最长子串" class="headerlink" title="6.无重复字符的最长子串"></a>6.<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p>wp:</p><p>hashmap <code>dic</code>统计：指针j遍历字符s，哈希表统计s[j]最后一次出现的索引</p><p>根据上轮i与dis[s[j]]更新左边界i，保证[i+1,j]内无重复字符且最大</p><p>i= max(dic[s[j]],i)</p><p>更新res就是[i+1,j]的len即j-1的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution7</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lenOfLongesSubstring</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; dic  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i=-<span class="number">1</span>,res = <span class="number">0</span>,len =s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dic.containsKey(s.charAt(j)))</span><br><span class="line">                i = Math.max(i,dic.get(s.charAt(j)));</span><br><span class="line">            dic.put(s.charAt(j),j);</span><br><span class="line">            res = Math.max(res,j-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="7-相交链表"><a href="#7-相交链表" class="headerlink" title="7.相交链表"></a>7.<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA, B = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = (A != <span class="literal">null</span>) ? A.next : headB;</span><br><span class="line">            B = (B != <span class="literal">null</span>) ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先处理一下A与B不为空的情况</p><p>最重要的是</p><p>while (A != B) {<br>            A = (A != null) ? A.next : headB;<br>            B = (B != null) ? B.next : headA;<br>        }</p><p>两个具有相同结尾的链表拼接，无论哪一个在前，哪一个在后，这两种拼接方式，他们总能保持最后的一段相同的节点是不变的。</p><h2 id="8-反转链表"><a href="#8-反转链表" class="headerlink" title="8.反转链表"></a>8.<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>直接通过双指针反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next; <span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">            cur.next = pre;          <span class="comment">// 修改 next 引用指向</span></span><br><span class="line">            pre = cur;               <span class="comment">// pre 暂存 cur</span></span><br><span class="line">            cur = tmp;               <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.<a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></p><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>这个题是在上面的基础上进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution9</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head,pre  = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span>middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span>  <span class="operator">=</span> reverList(mid);</span><br><span class="line">        <span class="keyword">while</span> (head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val!=head2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">       &#125;<span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找到中间的节点，也就是middleNode函数</p><p>slow比慢等到fast.next到终点的时候.slow就是中间的节点</p><p>然后反正mid那一部分，如果mid与反转后的相同的话，那么就是回文串</p><p>返回ture反之则false</p><h2 id="9-环形链表1"><a href="#9-环形链表1" class="headerlink" title="9.环形链表1"></a>9.环形链表1</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p>如果一个链表存在环，那么<strong>快慢指针必然会相遇</strong>。实现代码如下</p><p>所以我们直接编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution10</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="10-环形链表2"><a href="#10-环形链表2" class="headerlink" title="10.环形链表2"></a>10.环形链表2</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p>根据分析，有环的标识是fast==slow</p><p>然后fast和slow第二次相遇的node就是环的节点</p><p>所以很简单的就可以分析出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution11</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head,slwo = head;</span><br><span class="line">            <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                slwo = slwo.next;</span><br><span class="line">                <span class="keyword">if</span> (fast == slwo) &#123;</span><br><span class="line">                    fast = head;</span><br><span class="line">                    <span class="keyword">while</span> (slwo!=fast)&#123;</span><br><span class="line">                        slwo = slwo.next;</span><br><span class="line">                        fast = fast.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> fast;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接使用两次相遇，相遇的fast就是环的起点；</p><h2 id="11-合并两个有序链表"><a href="#11-合并两个有序链表" class="headerlink" title="11.合并两个有序链表"></a>11.<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p> 我们使用递归算法</p><p>当两个链表都为空的时候，说明已经合并完毕了</p><p>l1和l2哪个同头节点更小，较小节点的Next指针就指向其余节点的合并结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution12</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">mergeTowLists</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l2==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">                l1.next = mergeTowLists(l1.next,l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l2.next = mergeTowLists(l1,l2.next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="12-两数相加"><a href="#12-两数相加" class="headerlink" title="12.两数相加"></a>12.<a href="https://leetcode.cn/problems/add-two-numbers/">两数相加</a></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。‘</p><p>计算每一位的时候要考虑上一位的进位问题，计算结束后同样要跟更新进位</p><p>如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution13</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre;</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line"></span><br><span class="line">                carry = sum / <span class="number">10</span>;</span><br><span class="line">                sum = sum % <span class="number">10</span>;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line"></span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="13-删除链表的倒数第-N-个结点"><a href="#13-删除链表的倒数第-N-个结点" class="headerlink" title="13.删除链表的倒数第 N 个结点"></a>13.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre<br>start 先向前移动n步<br>之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点</p><p>因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 <code>start.next != null</code></p><p>删除后返回 <code>pre.next</code>，为什么不直接返回 <code>head</code> 呢，因为 <code>head</code> 有可能是被删掉的点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution14</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                pre.next = head;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre, end = pre;</span><br><span class="line">                <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                    start = start.next;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;<span class="comment">//start先提前移动</span></span><br><span class="line">                <span class="keyword">while</span> (start.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    start = start.next;</span><br><span class="line">                    end = end.next;</span><br><span class="line">                &#125;<span class="comment">//一块移动</span></span><br><span class="line">                end.next = end.next.next;<span class="comment">//删除某节点</span></span><br><span class="line">                <span class="keyword">return</span> pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="14-两两交换链表中的节点"><a href="#14-两两交换链表中的节点" class="headerlink" title="14.两两交换链表中的节点"></a>14.<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换<br>终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换</p><p>假设链表为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp -&gt; (A) -&gt; (B) -&gt; (C) -&gt; (D) -&gt; null</span><br><span class="line">start -&gt; (B)</span><br><span class="line">end -&gt; (C)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使tmp.next = end;</p><p>链表现在变成了这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(A) -&gt; (C) -&gt; (D) -&gt; null</span><br><span class="line">(B) (断开)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再start.next = end.next;</p><p>(B)就指向了（D）</p><p>end.next = start;</p><p>然后（C）就指向了（B）</p><p>所以链表就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(A) -&gt; (C) -&gt; (B) -&gt; (D) -&gt; null</span><br></pre></td></tr></table></figure><p>最后tmp = start;</p><p>再从B开始继续迭代循环</p><p>最终完成了链表节点的交换</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="comment">//没有节点，或者只剩一个的时候</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs1(next.next);<span class="comment">//</span></span><br><span class="line">        next.next = head;<span class="comment">//后节点等于头节点</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs2</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next!=<span class="literal">null</span>&amp;&amp;tmp.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> tmp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> tmp.next.next;</span><br><span class="line">            tmp.next = end;<span class="comment">//head</span></span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            tmp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-随机链表的复制"><a href="#15-随机链表的复制" class="headerlink" title="15. 随机链表的复制"></a>15.<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/"> 随机链表的复制</a></h2><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution16</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span>head;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(cur,<span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while (cur!=null){<br>            map.put(cur,new Node(cur.val));<br>            cur = cur.next;<br>        }</p><p>先把链表复制一份</p><p>构建新节点的 <code>next</code> 和 <code>random</code> 引用指向。都是随机的</p><p>然后迭代下一个节点</p><p>最后返回head节点</p><h2 id="16-排序链表"><a href="#16-排序链表" class="headerlink" title="16.排序链表"></a>16.<a href="https://leetcode.cn/problems/sort-list/">排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p>我们使用新建链表的方式</p><p>把val值排序后再组成一个新链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution17</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i] = cur.val;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">listNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        cur = listNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[i]);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17-LRU-缓存"><a href="#17-LRU-缓存" class="headerlink" title="17.LRU 缓存"></a>17.<a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a></h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>基于LinkedHashMap来实现</p><p><code>LinkedHashMap</code> 是 <strong>有序哈希表</strong>，可以按<strong>插入顺序</strong>或<strong>访问顺序</strong>存储键值对。</p><p>super(capacity, 0.75F, true);</p><p><strong>capacity</strong>: 初始容量</p><p><strong>0.75F</strong>: 负载因子（默认 <code>0.75</code>）</p><p><strong>true</strong>: 启用 <strong>访问顺序</strong>，即 <strong>最近访问的元素会被移到链表尾部</strong>，最久未使用的元素会在链表头部。</p><p><code>size() &gt; capacity</code> 时，返回 <code>true</code>，<code>LinkedHashMap</code> 会自动删除 <strong>链表头部的最老元素</strong>（即最近最少使用的元素）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer,Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer,Integer&gt; eldest)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="18-最大子数组和"><a href="#18-最大子数组和" class="headerlink" title="18.最大子数组和"></a>18.<a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution18</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用循环来完成这个目的</p><h2 id="19-合并区间"><a href="#19-合并区间" class="headerlink" title="19.合并区间"></a>19.<a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><ol><li><p>把 <em>intervals</em>[0] 加入答案。注意，答案的最后一个区间表示<strong>当前正在合并的区间</strong>。</p></li><li><p>遍历到 intervals[1]=[2,6]，由于左端点 2 不超过当前合并区间的右端点 3，可以合并。由于右端点 6&gt;3，那么更新当前合并区间的右端点为 6。注意，由于我们已经按照左端点排序，所以 intervals[1] 的左端点 2 必然大于等于合并区间的左端点，所以无需更新当前合并区间的左端点。</p></li><li><p>遍历到 intervals[2]=[8,10]，由于左端点 8 大于当前合并区间的右端点 6，无法合并（两个区间不相交）。再次利用区间按照左端点排序的性质，更后面的区间的左端点也大于 6，无法与当前合并区间相交，所以当前合并区间 [1,6] 就固定下来了，把新的合并区间 [8,10] 加入答案。</p></li><li><p>遍历到 intervals[3]=[15,18]，由于左端点 15 大于当前合并区间的右端点 10，无法合并（两个区间不相交），我们找到了一个新的合并区间 [15,18] 加入答案。</p><p>上述算法同时说明，按照左端点排序后，合并的区间一定是 <em>intervals</em> 中的连续子数组。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution19</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals)&#123;</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>] - q[<span class="number">0</span>]);<span class="comment">//按照左端点从小到大排序</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;<span class="comment">//限制范围</span></span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-轮转数组"><a href="#20-轮转数组" class="headerlink" title="20.轮转数组"></a>20.<a href="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h2><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        k%=nums.length;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = nums[temp];</span><br><span class="line">            start+=<span class="number">1</span>;</span><br><span class="line">            end-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个主要是轮转，</p><p>首先对整个数组实行翻转，这样子原数组中需要翻转的子数组，就会跑到数组最前面。</p><p>这时候，从 <em>k</em> 处分隔数组，左右两数组，各自进行翻转即可。</p><p>然后k逐渐求余</p><p>然后就构建一个反转函数就行了</p><h2 id="21-除自身以外数组的乘积-x"><a href="#21-除自身以外数组的乘积-x" class="headerlink" title="21.除自身以外数组的乘积(x)"></a>21.<a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a>(x)</h2><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 <strong>不要使用除法，</strong>且在 <code>O(n)</code> 时间复杂度内完成此题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="comment">//假如nums为[1,2,3,4]，那么answer的值分别为[(2,3,4),(1,3,4),(1,2,4),(1,2,3)]</span></span><br><span class="line">        <span class="comment">//如果吧i当前值相乘的时候看做是1那么就有如下样式</span></span><br><span class="line">        <span class="comment">//  1, 2, 3, 4 </span></span><br><span class="line">        <span class="comment">//  1, 1, 3, 4</span></span><br><span class="line">        <span class="comment">//  1, 2, 1, 4</span></span><br><span class="line">        <span class="comment">//  1, 2, 3, 1</span></span><br><span class="line">        <span class="comment">// 他的对角线1将他们分割成了两个三角形，对于answer的元素，</span></span><br><span class="line">        <span class="comment">//我们可以先计算一个三角形每行的乘积，然后再去计算另外一个三角形每行的乘积，</span></span><br><span class="line">        <span class="comment">//然后各行相乘，就是answer每个对应的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先初始化一个answer数组,但是很多解答都没说明的是这个answer数组，</span></span><br><span class="line">        <span class="comment">//并不是以此计算就得出的结果,而是两次乘积之后的结果</span></span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">//初始化一个初始值，作为三角乘积计算的开始</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先计算左边三角的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">            answer[i] = answer[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次计算右边三角形,为什么是length-2呢？</span></span><br><span class="line">        <span class="comment">//length-1是最后一个值的索引，但是最后一个值temp[length-1] = 1,</span></span><br><span class="line">        <span class="comment">//也是对应对角线上的1，所以不在进行相乘处理</span></span><br><span class="line">        <span class="comment">//temp的作用是计算右边三角形的乘积的累计值，然后再和answer相乘，</span></span><br><span class="line">        <span class="comment">//注意!!!:不能直接nums[i+1]相乘那会在计算右三角的时候变成每行乘积与nums[i+1]的错误答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//先将每行乘积赋予一个中间值</span></span><br><span class="line">            temp *= nums[i+<span class="number">1</span>];</span><br><span class="line">            answer[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="22-二叉树的中序遍历"><a href="#22-二叉树的中序遍历" class="headerlink" title="22.二叉树的中序遍历"></a>22.<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p> 中序遍历是左-&gt;根-&gt;右</p><p>可以使用递归完成dfs的中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution22</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        dfs(res, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; res,TreeNode root)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(res,root.left);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            dfs(res,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-二叉树的最大深度"><a href="#23-二叉树的最大深度" class="headerlink" title="23.二叉树的最大深度"></a>23.<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是左子树和右子树分别往下找，然后他们两个最大的+1（root）就是最大深度</p><h2 id="24-翻转二叉树"><a href="#24-翻转二叉树" class="headerlink" title="24.翻转二叉树"></a>24.<a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution24</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是左子树变成右子树，右子树变成左子树</p><p>直接设置一个中间值，然后直接递归交换即可。</p><h2 id="25-对称二叉树"><a href="#25-对称二叉树" class="headerlink" title="25.对称二叉树"></a>25.<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">null</span>||recur(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L,TreeNode R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>&amp;&amp;R==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>||R==<span class="literal">null</span>||L.val!=R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是递归的方法，如果左空右空，那么就肯定对称啊</p><p>左不为空或者右不为空，val还不一样肯定不是对称</p><p>然后递归往下顺延</p><p>左的左，对应右的右。左的右对应右的左。然后递归往下找下一个节点</p><h2 id="26-二叉树的直径"><a href="#26-二叉树的直径" class="headerlink" title="26.二叉树的直径"></a>26.<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a></h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution26</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">llen</span> <span class="operator">=</span> dfs(node.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rlen</span> <span class="operator">=</span> dfs(node.right)+<span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans,llen+rlen);</span><br><span class="line">        <span class="keyword">return</span> Math.max(llen,rlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到左子树的最大长，和右子树的最大长，加起来就是长度。</p><p>其中+1是经过root节点</p><h2 id="27-二叉树的层序遍历"><a href="#27-二叉树的层序遍历" class="headerlink" title="27.二叉树的层序遍历"></a>27.<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p>使用递归的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution27</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sized</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (sized--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                layer.add(poll.val);</span><br><span class="line">                <span class="keyword">if</span> (poll.left!=<span class="literal">null</span>) que.add(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right!=<span class="literal">null</span>) que.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(layer);</span><br><span class="line">        &#125;<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while (sized—&gt;0){<br>                TreeNode poll = que.poll();<br>                layer.add(poll.val);<br>                if (poll.left!=null) que.add(poll.left);<br>                if (poll.right!=null) que.add(poll.right);<br>            }</p><p>sized逐渐递减，大于0的时候执行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode poll = que.poll();</span><br><span class="line">                layer.add(poll.val);</span><br><span class="line">                if (poll.left!=null) que.add(poll.left);</span><br><span class="line">                if (poll.right!=null) que.add(poll.right);</span><br></pre></td></tr></table></figure><p>poll为队列弹出的</p><p>然后List加入弹出的值</p><p>然后先向左递归，然后再向右递归</p><p>直到完成que为空，最后返回res</p><h2 id="28-将有序数组转换为二叉搜索树"><a href="#28-将有序数组转换为二叉搜索树" class="headerlink" title="28.将有序数组转换为二叉搜索树"></a>28.<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution28</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo&gt;hi)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = dfs(nums,lo,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = dfs(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了二分查找，主要是设定了mid为lo加上hi-lo的位置，这个位置就是root</p><p>然后递归查找，就可以出现二叉搜索树了。</p><p>二叉搜索树就是二分查找中出现的</p><h2 id="29-验证二叉搜索树"><a href="#29-验证二叉搜索树" class="headerlink" title="29.验证二叉搜索树"></a>29.<a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution29</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node,<span class="type">long</span> left,<span class="type">long</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="keyword">return</span> left&lt;x&amp;&amp;x&lt;right&amp;&amp;</span><br><span class="line">                isValidBST(node.left,left,x)&amp;&amp;</span><br><span class="line">                isValidBST(node.right,x,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉搜索树的特点是左子树是小于根节点的</p><p>右子树是大于根节点的</p><p>我们就根据这个来判断就行</p><p>return left&lt;x&amp;&amp;x&lt;right&amp;&amp;<br>                isValidBST(node.left,left,x)&amp;&amp;<br>                isValidBST(node.right,x,right);</p><p>这就是成立条件，其中用到了递归</p><h2 id="30-二叉搜索树中第-K-小的元素"><a href="#30-二叉搜索树中第-K-小的元素" class="headerlink" title="30. 二叉搜索树中第 K 小的元素"></a>30.<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/"> 二叉搜索树中第 K 小的元素</a></h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution30</span>&#123;</span><br><span class="line">    <span class="type">int</span> res,k;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (--k==<span class="number">0</span>) res = root.val;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是找第K小的数，所以先从左子树开始</p><p>然后如果递归下去—k==0了说明不在左子树，是根节点</p><p>然后递归右子树</p><h2 id="31-二叉树的右视图"><a href="#31-二叉树的右视图" class="headerlink" title="31.二叉树的右视图"></a>31.<a href="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution31</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode  root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth==ans.size())&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>,ans);</span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是右视图，所以是从右边开始</p><p>如果深度首次遇到，说明是遇到了最右边的，把值收入</p><p>先递归右子树，保证首次遇到的一定是最右边的节点</p><p>然后逐渐递归，最先右边的递归</p><h2 id="32-二叉树展开为链表"><a href="#32-二叉树展开为链表" class="headerlink" title="32. 二叉树展开为链表"></a>32.<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/"> 二叉树展开为链表</a></h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution32</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span>) &#123; <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.right = root.right; <span class="comment">// 右子树接到左子树的最右节点上</span></span><br><span class="line">                root.right = root.left; <span class="comment">// 左子树变成右子树</span></span><br><span class="line">                root.left = <span class="literal">null</span>; <span class="comment">// 断开左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right; <span class="comment">// 继续处理下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-路径总和-III"><a href="#33-路径总和-III" class="headerlink" title="33.路径总和 III"></a>33.<a href="https://leetcode.cn/problems/path-sum-iii/">路径总和 III</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        Map&lt;Long, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        cnt.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">        dfs(root, <span class="number">0</span>, targetSum, cnt);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">long</span> s,<span class="type">int</span> targetsum,Map&lt;Long,Integer&gt; cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s+= node.val;</span><br><span class="line">        ans+=cnt.getOrDefault(s-targetsum,<span class="number">0</span>);</span><br><span class="line">        cnt.merge(s,<span class="number">1</span>,Integer::sum);<span class="comment">//cnt[s++]</span></span><br><span class="line">        dfs(node.left,s,targetsum,cnt);</span><br><span class="line">        dfs(node.right,s,targetsum,cnt);</span><br><span class="line">        cnt.merge(s,-<span class="number">1</span>,Integer::sum);<span class="comment">//归零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> cnt.merge(s,1,Integer::sum);//想当与逐渐+1</p><p>然后走的时候先走左再走右</p><p>最后清零sum</p><h2 id="34-二叉树的最近公共祖先"><a href="#34-二叉树的最近公共祖先" class="headerlink" title="34.二叉树的最近公共祖先"></a>34.<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution34</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个节点有一个跟根节点相同的话，那么最近公共祖先就是root</p><p>然后继续递归，当到最下的时候，为Null就是上一个节点</p><h2 id="35-从前序与中序遍历序列构造二叉树"><a href="#35-从前序与中序遍历序列构造二叉树" class="headerlink" title="35.从前序与中序遍历序列构造二叉树"></a>35.<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> in=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree2</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> my(preorder,inorder,Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">my</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder,<span class="type">int</span> stop)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == preorder.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inorder[in] ==stop)&#123;</span><br><span class="line">        in++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre++]);</span><br><span class="line">    root.left = my(preorder,inorder,root.val);</span><br><span class="line">    root.right = my(preorder,inorder,stop);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeNode root = new TreeNode(preorder[pre++]);逐渐获得前序遍历的值</p><p>然后构造左子树，构造右子树</p><p>没有子树的时候，返回in++，直到到stop</p><p>然后调用递归</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="36-搜索插入位置"><a href="#36-搜索插入位置" class="headerlink" title="36.搜索插入位置"></a>36.<a href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p>简单的二分查找，不比多说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution36</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-搜索二维矩阵"><a href="#37-搜索二维矩阵" class="headerlink" title="37.搜索二维矩阵"></a>37.<a href="https://leetcode.cn/problems/search-a-2d-matrix/">搜索二维矩阵</a></h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p> 简单的矩阵二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution37</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m*n;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>(left+right)&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//计算中位数，即使为负数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> matrix[mid/n][mid%n];</span><br><span class="line">            <span class="keyword">if</span> (x==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;target)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>a</em>[<em>i</em>]=<em>matrix</em>[i/n】[imod<em>n</em>]</p><p>将矩阵转化为一个数组</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/02/leetcodehot/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English三月篇</title>
      <link>https://blog.tokenlen.top/2025/03/01/en7/</link>
      <guid>https://blog.tokenlen.top/2025/03/01/en7/</guid>
      <pubDate>Fri, 28 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;每日一话-单词遗忘表3-1&quot;&gt;&lt;a href=&quot;#每日一话-单词遗忘表3-1&quot; class=&quot;headerlink&quot; title=&quot;每日一话+单词遗忘表3.1&quot;&gt;&lt;/a&gt;每日一话+单词遗忘表3.1&lt;/h1&gt;&lt;p&gt;There is something in</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="每日一话-单词遗忘表3-1"><a href="#每日一话-单词遗忘表3-1" class="headerlink" title="每日一话+单词遗忘表3.1"></a>每日一话+单词遗忘表3.1</h1><p>There is something in every human being, even the most degraded, that slavery cannot corrupt – the soul’s instinct for freedom.</p><ul><li>spade 铲子</li><li>steer 驾驶</li><li>stock 股票</li><li>storey 楼层</li></ul><h1 id="每日一话-单词遗忘表3-2"><a href="#每日一话-单词遗忘表3-2" class="headerlink" title="每日一话+单词遗忘表3.2"></a>每日一话+单词遗忘表3.2</h1><p>It always seems impossible until it’s done.</p><ul><li><strong>stove</strong> 火炉</li><li>straight 直的</li><li>strain 张力</li><li>strategy 战略</li><li>sphere 球</li><li>stretch 延申</li><li><strong>stride</strong> 大步</li><li>strike 罢工</li><li>strip 剥去</li><li><strong>strive</strong> 努力</li><li><strong>speculate</strong> 思考</li></ul><h1 id="每日一话-单词遗忘表3-3"><a href="#每日一话-单词遗忘表3-3" class="headerlink" title="每日一话+单词遗忘表3.3"></a>每日一话+单词遗忘表3.3</h1><p>One cannot always be a hero, but one can always be a man.</p><ul><li>strap 捆绑</li><li>subsequent 随后的</li><li>substance 实质的</li><li><strong>subtract</strong> 减去</li><li>suburb 郊区</li><li>suck 吮吸</li><li>equivalent 平等的</li><li>oblige 强制的</li><li>nuisance 讨厌的人</li></ul><h1 id="每日一话-单词遗忘表3-4"><a href="#每日一话-单词遗忘表3-4" class="headerlink" title="每日一话+单词遗忘表3.4"></a>每日一话+单词遗忘表3.4</h1><p>Education is the ability to listen to almost anything without losing your temper or your self-confidence.</p><ul><li>superior 上级</li><li>supervise 监督</li><li>supplement 增补物</li><li>surf 海浪</li><li>surgery 外科</li><li>surrender 投降</li><li><strong>suspend</strong> 推迟</li><li><strong>suspicion</strong> 嫌疑</li><li>sway 动摇</li><li>swear 辱骂</li></ul><h1 id="每日一话-单词遗忘表3-5"><a href="#每日一话-单词遗忘表3-5" class="headerlink" title="每日一话+单词遗忘表3.5"></a>每日一话+单词遗忘表3.5</h1><p>Spring has returned. The Earth is like a child that knows poems.</p><ul><li>swift 快的</li><li>swipe 猛击</li><li>sympathy 同情</li><li><strong>tackle</strong> 处理</li><li>tailor 裁剪</li><li>spit 吐口水</li><li>orient 朝向</li></ul><h1 id="每日一话-单词遗忘表3-6"><a href="#每日一话-单词遗忘表3-6" class="headerlink" title="每日一话+单词遗忘表3.6"></a>每日一话+单词遗忘表3.6</h1><p>Problems are not stop signs, they are guidelines.</p><ul><li>strain 拉紧</li><li>strap 抽打</li><li>parcel 包裹</li><li><strong>tedious</strong> 冗长的</li><li>temper 脾气</li><li>telescope 望远镜</li><li>tense 拉紧</li></ul><h1 id="每日一话-单词遗忘表3-7"><a href="#每日一话-单词遗忘表3-7" class="headerlink" title="每日一话+单词遗忘表3.7"></a>每日一话+单词遗忘表3.7</h1><p>The difference between genius and stupidity is: genius has its limits.</p><ul><li>tent 帐篷</li><li>terrific 极好的</li><li>territory 领土</li><li>textile 纺织品</li><li>theft 偷窃</li><li>theory 伦理</li><li>therapy 治疗</li></ul><h1 id="每日一话-单词遗忘表3-8"><a href="#每日一话-单词遗忘表3-8" class="headerlink" title="每日一话+单词遗忘表3.8"></a>每日一话+单词遗忘表3.8</h1><p>A girl should be two things: who and what she wants.</p><ul><li>thesis 论文</li><li>thief 小偷</li><li>fertile 丰饶的</li><li>thorough 彻底的</li><li>faculty 能力</li><li>thrive 繁荣的</li><li>throat 嗓子</li><li>thunder 雷</li></ul><h1 id="每日一话-单词遗忘表3-9"><a href="#每日一话-单词遗忘表3-9" class="headerlink" title="每日一话+单词遗忘表3.9"></a>每日一话+单词遗忘表3.9</h1><p>The question isn’t who’s going to let me; it’s who is going to stop me.</p><ul><li>tide 潮汐</li><li>tissue 纸巾</li><li>tobacco 烟草</li><li>toe 脚趾</li><li>toilet 马桶</li><li><strong>tolerate</strong> 忍受</li><li>toll 钟声</li><li>strategy 战法</li><li>straw 稻草</li><li>stripe 稻草</li><li>flee 逃走</li></ul><h1 id="每日一话-单词遗忘表3-10"><a href="#每日一话-单词遗忘表3-10" class="headerlink" title="每日一话+单词遗忘表3.10"></a>每日一话+单词遗忘表3.10</h1><p>Life consists not in holding good cards, but in playing well those you hold.</p><ul><li>tongue 舌头</li><li>pigeon 鸽子</li><li>penalty 惩罚</li><li><strong>torture</strong> 折磨</li><li>peril 危险</li><li>toss 投掷</li><li>pesssimism 悲观的</li><li>tractor 拖拉机</li><li>trail 踪迹</li><li>pierce 刺入</li><li>perspective 远景</li></ul><h1 id="每日一话-单词遗忘表3-11"><a href="#每日一话-单词遗忘表3-11" class="headerlink" title="每日一话+单词遗忘表3.11"></a>每日一话+单词遗忘表3.11</h1><p>People always entrust their happiness to the future, which slips away unnoticed.</p><ul><li>tram 电车轨道</li><li>theater 剧院</li><li>thransparent 透明的</li><li>tray 托盘</li><li>superb 杰出的</li><li>tremendous 极大的</li><li><strong>trial</strong> 试炼</li><li><strong>trifle</strong> 琐事</li><li>torture 折磨</li></ul><h1 id="每日一话-单词遗忘表3-12"><a href="#每日一话-单词遗忘表3-12" class="headerlink" title="每日一话+单词遗忘表3.12"></a>每日一话+单词遗忘表3.12</h1><p>If you want to build a ship, don’t drum up people to collect wood and don’t assign them tasks and work, but rather teach them to long for the endless immensity of the sea.</p><ul><li>triumph 胜利</li><li>precaution 预防措施</li><li>tuition 学费</li><li>tumor 肿块</li><li>tune 曲调</li><li>twist 拧</li><li>typewriter 打字机</li><li>thrive 兴隆</li><li>prescribe 开药方</li></ul><p>今天是植树节，是一个特殊的节日。今天也是孙先生逝世的日子，感谢！</p><h1 id="每日一话-单词遗忘表3-13"><a href="#每日一话-单词遗忘表3-13" class="headerlink" title="每日一话+单词遗忘表3.13"></a>每日一话+单词遗忘表3.13</h1><p>Genuine tragedies in the world are not conflicts between right and wrong. They are conflicts between two rights.</p><ul><li>tyre 轮胎</li><li>ultimate 最终的</li><li>umbrella 雨伞</li><li><strong>undergo</strong> 经历</li><li>undertake 承担</li><li>triumph 胜利</li></ul><h1 id="每日一话-单词遗忘表3-14"><a href="#每日一话-单词遗忘表3-14" class="headerlink" title="每日一话+单词遗忘表3.14"></a>每日一话+单词遗忘表3.14</h1><p>Do not seat your love upon a precipice because it is high.</p><ul><li>tragedy 悲剧</li><li>tractor 拖拉机</li><li>upringht 正直的</li><li>upset 使心烦</li><li>therapy 治疗</li><li>usage 用法</li><li>urgent 紧急的</li><li>utility 用法</li><li>theft 偷窃</li><li>utmost 最大可能的</li><li>vacuum 真空</li></ul><h1 id="每日一话-单词遗忘表3-15"><a href="#每日一话-单词遗忘表3-15" class="headerlink" title="每日一话+单词遗忘表3.15"></a>每日一话+单词遗忘表3.15</h1><p>It’s better to light a candle than to curse the darkness.</p><ul><li>vanish 消失</li><li><strong>vapor</strong> 蒸汽</li><li>vehicle 车辆</li><li>tram 车辆</li><li>pretend 假装</li><li>venture 敢于</li><li>victim 牺牲者</li></ul><h1 id="每日一话-单词遗忘表3-16"><a href="#每日一话-单词遗忘表3-16" class="headerlink" title="每日一话+单词遗忘表3.16"></a>每日一话+单词遗忘表3.16</h1><p>Our greatest glory consists not in never falling, but in rising every time we fall.</p><ul><li>vigor 活力</li><li>triumph 胜利</li><li>proof 证明</li><li><strong>violate</strong> 违反</li><li>vigour 精力</li><li>vital 生死攸关的</li><li>tuition 学费</li><li>volume 体积</li><li><strong>vulnrable</strong> 脆弱的</li><li>voyage 航行</li><li>tutor 导师</li></ul><h1 id="每日一话-单词遗忘表3-17"><a href="#每日一话-单词遗忘表3-17" class="headerlink" title="每日一话+单词遗忘表3.17"></a>每日一话+单词遗忘表3.17</h1><p><strong>The more solitary, the more friendless, the more unsustained I am, the more I will respect myself.</strong></p><ul><li>pupil 学生</li><li>wage 工资</li><li>provoke 激起</li><li>wary 机警的</li><li>waterproof 不透水的</li><li>volcano 火山</li></ul><h1 id="每日一话-单词遗忘表3-18"><a href="#每日一话-单词遗忘表3-18" class="headerlink" title="每日一话+单词遗忘表3.18"></a>每日一话+单词遗忘表3.18</h1><p>Don’t bother just to be better than your contemporaries or predecessors. Try to be better than yourself.</p><ul><li>rag 破布</li><li><strong>weird</strong> 怪异的</li><li>welfare 福利</li><li>whale 鲸鱼</li><li>quota 定额</li></ul><h1 id="每日一话-单词遗忘表3-19"><a href="#每日一话-单词遗忘表3-19" class="headerlink" title="每日一话+单词遗忘表3.19"></a>每日一话+单词遗忘表3.19</h1><p>In the end, we will remember not the words of our enemies, but the silence of our friends.</p><ul><li><strong>veteran</strong> 老兵</li><li>whilst 当..时候</li><li>whisper 私语</li><li>amateur 业余的</li><li>ambassador 大使</li><li>versus 对抗</li><li>apparatus 运动器械</li></ul><h1 id="每日一话-单词遗忘表3-21"><a href="#每日一话-单词遗忘表3-21" class="headerlink" title="每日一话+单词遗忘表3.21"></a>每日一话+单词遗忘表3.21</h1><p>Keep away from people who try to belittle your ambitions. Small people always do that, but the really great make you feel that you, too, can become great.</p><ul><li>urgent 紧急的</li><li>utter 绝对的</li><li>vigor 活力</li><li>volume 卷</li><li>voyage 航海</li></ul><h1 id="每日一话-单词遗忘表3-22"><a href="#每日一话-单词遗忘表3-22" class="headerlink" title="每日一话+单词遗忘表3.22"></a>每日一话+单词遗忘表3.22</h1><p>The night opens the flowers quietly and allows the day to get thanks.</p><ul><li>arrest 吸引</li><li>wrap 包</li><li>wreck 失事</li><li>yell 大叫</li><li>veteran 老兵</li><li>yoghurt 酸奶</li><li>realm  王国</li><li>vessel 容器</li><li>reap 收获</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/01/en7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sql原理</title>
      <link>https://blog.tokenlen.top/2025/02/25/sql1/</link>
      <guid>https://blog.tokenlen.top/2025/02/25/sql1/</guid>
      <pubDate>Mon, 24 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png" alt=""></p><p>ACID特性</p><p><strong>原子性</strong>（Atomicity）</p><p><strong>事务</strong>被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><p><strong>一致性</strong>（Consistency）</p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><p><strong>隔离性</strong>（Isolation）</p><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><p><strong>持久性</strong>（Durability）</p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><p>但是这几个特性不是有一种平级关系</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png" alt=""></p><p>在mysql中一般采用autocommit自动提交模式</p><p>除非使用<code>START TRANSACTION</code>开启一个事务</p><p>否则每一个语句都被视作一个事务</p><p>mysql中事务的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">SET @@AUTOCOMIIT = 0;</span><br></pre></td></tr></table></figure><p>设置为手动提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><p>回滚事务</p><p>开启事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION 或 BEGIN;</span><br></pre></td></tr></table></figure><p><strong>实例银行：</strong></p><p>没有发生错误的时候，不需要rollback的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询账户A的余额</span><br><span class="line"><span class="keyword">SELECT</span> MONEY <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 更新账户A的余额，减去<span class="number">1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>更新账户B的余额，增加<span class="number">1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发生错误的时候，则需要rollback</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 查询账户A的余额</span><br><span class="line">    <span class="keyword">SELECT</span> MONEY <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>更新账户A的余额，减去<span class="number">1000</span></span><br><span class="line">    <span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 更新账户B的余额，增加<span class="number">1000</span></span><br><span class="line">    <span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 提交事务</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 如果发生错误，回滚事务</span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 可以添加错误处理的代码，比如记录日志或者返回错误信息</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><h2 id="读取脏数据"><a href="#读取脏数据" class="headerlink" title="读取脏数据"></a>读取脏数据</h2><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是<strong>通过并发控制来保证隔离性</strong>。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡</p><h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><p>锁是计算机调解多个进程或者并发访问某一资源的机制</p><p>分类：</p><ul><li>全局锁 锁住所有表</li><li>表级锁 锁住整张表</li><li>行级锁 锁住整个行的数据</li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>对整个数据库的实例进行加锁，整个实例处于只读状态</p><p>dml 和ddl语句都会阻塞</p><p>数据备份的时候会引发全局锁，从而获得一致性视图，来保证数据的完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;<span class="operator">/</span><span class="operator">/</span>开锁</span><br><span class="line">mysqldump <span class="operator">-</span>u <span class="operator">-</span>p itcast<span class="operator">&gt;</span>itcast.sql;<span class="operator">/</span><span class="operator">/</span>备份</span><br><span class="line">unlock tables;<span class="operator">/</span><span class="operator">/</span>关锁</span><br></pre></td></tr></table></figure><p>在主库上备份，在备份期间都不能更新</p><p>在从库上备份，在备份期间不能执行从主库同步过来的二进制日志，会有主从延迟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p123 itcast &gt;itcast.sql</span><br></pre></td></tr></table></figure><p>这样就能在innnodb引擎上完成不加锁的一致性数据备份</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>1.表级锁</p><p>一次锁住整张表，开销小但并发性差。</p><p><strong>表共享锁（READ LOCK）</strong>：多个事务可以读，但不能写。</p><p><strong>表排他锁（WRITE LOCK）</strong>：只能由一个事务进行读写，其他事务无法访问。</p><p><strong>共享锁(read读锁)之间是兼容的，排他锁（写锁）是不能够兼容的</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES table_name READ;</span><br><span class="line">LOCK TABLES table_name WRITE;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>加锁和释放锁</p><p>2.意向锁</p><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>意向锁是innoDB引擎自动加的锁，用户无法手动加锁</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png" alt=""></p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><p>查询当前锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.innodb_locks;</span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>读写锁</p><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</p><p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png" alt=""></p><h2 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h2><p>避免间隙锁和临键锁</p><p>1.使用 <code>READ COMMITTED</code> 隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样 MySQL 只会使用 <strong>行锁</strong>，不会使用 <strong>Next-Key Lock</strong>，减少锁冲突。</p><p>但可能导致<strong>幻读</strong>。</p><p>2.使用唯一索引</p><p><strong>Next-Key Lock 只会作用于非唯一索引</strong>，如果查询用的是唯一索引，MySQL 只会加<strong>行锁</strong>，不会使用 <strong>Next-Key Lock</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM account WHERE id=5 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>如果 <code>id</code> 是 <strong>主键或唯一索引</strong>，那么 MySQL 只会锁 <code>id = 5</code>，不会锁范围 <code>(1,5]</code>。</p><div class="table-container"><table><thead><tr><th>锁类型</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>表级锁</strong></th><th>整张表</th><th>开销小，但并发低</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>意向锁（IS/IX）</strong></th><th>简化表锁检查</th><th>事务自动加锁，意向锁之间不会冲突</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>行锁（S/X）</strong></th><th>具体行</th><th>只针对索引数据，不走索引会变表锁</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>间隙锁（Gap Lock）</strong></th><th>锁定索引间隙</th><th>防止 <code>INSERT</code> 幻读，可共存</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>Next-Key Lock</strong></th><th>行锁 + 间隙锁</th><th>只在 <code>REPEATABLE READ</code> 级别下生效</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>一级：</p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决<strong>丢失修改问题</strong>，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220440451.png" alt=""></p><p>二级：</p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读<strong>脏数据问题</strong>，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220831843.png" alt=""></p><p>三级：</p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决<strong>不可重复读的问题</strong>，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221313819.png" alt=""></p><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p><strong>加锁和解锁分为两个阶段进行。</strong></p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock<span class="operator">-</span>x(A)...lock<span class="operator">-</span>s(B)...lock<span class="operator">-</span>s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock<span class="operator">-</span>x(A)...unlock(A)...lock<span class="operator">-</span>s(B)...unlock(B)...lock<span class="operator">-</span>s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h3 id="mysql的隐式和显式锁定"><a href="#mysql的隐式和显式锁定" class="headerlink" title="mysql的隐式和显式锁定"></a>mysql的隐式和显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为<strong>隐式锁定</strong>。</p><p>InnoDB 也可以使用特定的语句进行<strong>显示锁定</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">In</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>未提交读（READ UNCOMMITTED）</p><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><p><strong>没提交也能读取</strong></p><p>提交读（READ COMMITTED）</p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><p><strong>提交了才能读取</strong></p><p>可重复读（REPEATABLE READ）</p><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><p><strong>重复读的结果一样</strong></p><p>可串行化（SERIALIZABLE）</p><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><p><strong>事务串行执行</strong></p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png" alt=""></p><h3 id="事务隔离级别对锁的影响"><a href="#事务隔离级别对锁的影响" class="headerlink" title="事务隔离级别对锁的影响"></a><strong>事务隔离级别对锁的影响</strong></h3><div class="table-container"><table><thead><tr><th>隔离级别</th><th>读未提交</th><th>读已提交</th><th>可重复读</th><th>可串行化</th></tr></thead><tbody><tr><td><strong>行锁</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>间隙锁</strong></td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><strong>Next-Key Lock</strong></td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table></div><p>在mysql可以手动设置事务的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION</span><br></pre></td></tr></table></figure><p>查看当前的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION_ISOLATION LEVEL [几种级别]</span><br></pre></td></tr></table></figure><p>设置当前的隔离级别</p><p>实例：</p><p>设置当前事务隔离等级为可重复读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">-- 第一次读取</span></span><br><span class="line"><span class="comment">-- 此时事务 B 插入了一条新的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">-- 结果不变</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ACCOUNT (NAME, MONEY) <span class="keyword">VALUES</span> (<span class="string">&#x27;C&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">-- 事务 A 读取不到这条新增数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>在封锁一节中提到，<strong>加锁</strong>能解决<strong>多个事务同时执行时出现的并发一致性问题</strong>。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 <strong>MVCC</strong> 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p>脏读和不可重复读最根本的原因是<strong>事务读取到其它事务未提交的修改</strong>。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读<strong>取已经提交的快照</strong>。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><ul><li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li></ul><h2 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h2><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p><p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(id,x) <span class="keyword">VALUE</span>(<span class="number">1</span>,&quot;a&quot;);</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;b&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;c&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png" alt=""></p><p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png" alt=""></p><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快<strong>照时在当前所有未提交事务之前进行更改的</strong>，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在<strong>事务启动之后被更改的，因此不可使用</strong>。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：<strong>如果 TRX_ID 在 TRX_IDs 列表中</strong>，表示该数据行快照对应的事务还<strong>未提交</strong>，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：<strong>都不可以使用</strong>。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p><h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><p>1.快照读：</p><p>MVCC 的 SELECT 操作是<strong>快照中的数据</strong>，不需要进行加锁操作。</p><p>2.当前读：</p><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><h2 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁(Next-Key Lock)"></a>临键锁(Next-Key Lock)</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下（innoDB引擎默认的隔离级别），使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><p>Next-Key lock是<strong>间隙锁（Gap Lock）</strong> 的一种特殊形式。</p><p>实际上是<strong>行锁加上间隙锁</strong>的结合</p><p>record locks：</p><p>行锁，锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><p>gap locks：</p><p>间隙锁,锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><strong>查询包含范围条件（<code>BETWEEN</code>, <code>&lt;</code>, <code>&gt;</code>）时</strong>，会触发 <strong>间隙锁</strong>。</p><p>Next-key locks:</p><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个<strong>前开后闭区间</strong></p><p>假设表account里有如下数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id   <span class="operator">|</span> name  <span class="operator">|</span> money</span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"><span class="number">1</span>    <span class="operator">|</span> A     <span class="operator">|</span> <span class="number">1000</span></span><br><span class="line"><span class="number">5</span>    <span class="operator">|</span> B     <span class="operator">|</span> <span class="number">2000</span></span><br><span class="line"><span class="number">10</span>   <span class="operator">|</span> C     <span class="operator">|</span> <span class="number">3000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>事务A执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MySQL 会加 <strong>Next-Key Lock</strong>：</p><ul><li>锁住 <strong>id = 5</strong>（行锁）</li><li>锁住 <strong>(1, 5] 这个区间</strong>（间隙锁）</li><li>其他事务不能在 <code>id = 2, 3, 4</code> 处插入数据</li></ul><p>如果表里<strong>没有 id = 5</strong>，那么 MySQL 仍然会锁住 <code>(1, 10)</code> 之间的范围，防止 <code>id = 5</code> 被插入。</p><h1 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>是现实世界中可以被区分的对象，比如学生，课程等</p><p>实体分为强实体和弱实体</p><p>强实体：能够独立存在的实体，通常有<strong>主键</strong>（Primary Key）。</p><p>弱实体：必须依赖其他实体才能存在，没有主键，依赖于强实体的“识别关系（Identifying Relationship）”来标识。</p><p>弱实体的表示：</p><ul><li><p>用 <strong>双框矩形</strong> 表示弱实体。</p></li><li><p>依赖的关系用 <strong>双菱形</strong> 表示。</p></li><li><p>需要一个<strong>外键（Foreign Key）</strong>来引用强实体的主键。</p></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>实体的属性描述了实体的特征。</p><p><strong>单值属性（Single-valued Attribute）</strong>：例如“姓名（Name）”。</p><p><strong>多值属性（Multivalued Attribute）</strong>：例如“电话号码（Phone Numbers）”，用 <strong>双椭圆</strong> 表示。</p><p><strong>复合属性（Composite Attribute）</strong>：可以再分解，例如“姓名”可以分为“姓”和“名”。</p><p><strong>派生属性（Derived Attribute）</strong>：可以从其他属性计算得到，如“年龄”可以由“出生日期”计算，通常用<strong>虚线椭圆</strong>表示。</p><h3 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li><li><strong>菱形（Diamond）</strong> 表示联系，连接实体</li><li><strong>联系的属性（Attributes of Relationship）</strong>：如果联系本身有属性，则连到菱形上，例如“注册（Enroll）”联系可以有“注册日期（Enroll Date）”。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt=""></p><p> Course 和 Student 是一对多的关系。</p><h2 id="图的特点"><a href="#图的特点" class="headerlink" title="图的特点"></a>图的特点</h2><h3 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt=""></p><h3 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h3><p>用 <strong>一个菱形连接多个实体</strong> 来表示三元或更高阶联系。</p><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt=""></p><h3 id="泛化与特化"><a href="#泛化与特化" class="headerlink" title="泛化与特化"></a>泛化与特化</h3><p><strong>泛化（Generalization）</strong>：将多个子类合并为一个更一般的父类。例如，“本科生（Undergraduate）”和“研究生（Graduate）”可以泛化为“学生（Student）”。</p><p><strong>特化（Specialization）</strong>：将一个较一般的实体分解成多个更具体的子类，例如“员工（Employee）”可以特化为“教师（Teacher）”和“行政人员（Admin）”。</p><p>表示子类</p><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt=""></p><h2 id="E-R图到关系模型的转化"><a href="#E-R图到关系模型的转化" class="headerlink" title="E-R图到关系模型的转化"></a>E-R图到关系模型的转化</h2><p>E-R 图通常会转换为关系型数据库的表：</p><p><strong>强实体 → 直接变成一个表</strong>。</p><p><strong>弱实体 → 需要外键和强实体的主键组合</strong>。</p><p><strong>一对多关系 → 在“多”的一侧添加外键</strong>。</p><p><strong>多对多关系 → 创建一个独立的中间表，存储双方的主键</strong>。</p><p><strong>三元关系 → 也可以转换为一个关系表，包含所有相关实体的外键</strong>。</p><h2 id="E-R图的扩展"><a href="#E-R图的扩展" class="headerlink" title="E-R图的扩展"></a>E-R图的扩展</h2><p>EER（Enhanced Entity-Relationship）模型是 E-R 图的扩展，包括</p><p><strong>层次结构（Hierarchy）</strong>：增加继承关系。</p><p><strong>约束（Constraints）</strong>：如<strong>完全（Total）</strong>和<strong>部分（Partial）</strong>约束。</p><p><strong>集合（Aggregation）</strong>：将一个联系当作一个整体，参与其他联系。</p><h1 id="关系数据库设置理论"><a href="#关系数据库设置理论" class="headerlink" title="关系数据库设置理论"></a>关系数据库设置理论</h1><p>关系数据库的<strong>设计理论</strong>而是<strong>为了确保数据存储的合理性、减少冗余、消除更新异常，同时保持数据的完整性</strong>。</p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 <strong>A 函数决定 B</strong>，也可以说 <strong>B 函数依赖于 A。</strong></p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为<strong>键码</strong>。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是<strong>部分函数依赖</strong>，否则就是<strong>完全函数依赖。</strong></p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table></div><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p>涉及到<strong>表的分解</strong>，根据表之间的逻辑关系</p><p>这些范式的设计过程通常会导致<strong>将一张表分解成多个子表</strong>，以减少冗余和异常。</p><p>第一范式（1NF）</p><p><strong>属性</strong>不可分</p><p>第二范式（2NF）</p><p>每个非主属性完全函数依赖于<strong>键码</strong>。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table></div><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><div class="table-container"><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table></div><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><div class="table-container"><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table></div><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><p>第三范式（3NF）</p><p><strong>非主属性不传递函数依赖于键码。</strong></p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><div class="table-container"><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td></tr></tbody></table></div><p>关系-12</p><div class="table-container"><table><thead><tr><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table></div>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/25/sql1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sql原理基础概念</title>
      <link>https://blog.tokenlen.top/2025/02/25/sql2/</link>
      <guid>https://blog.tokenlen.top/2025/02/25/sql2/</guid>
      <pubDate>Mon, 24 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>数据库（Database）：存放和提供数据的库房</p><p>数据(Data)：数据库中存储的基本对象</p><p>数据库管理系统(DBMS)：位于用户和操作系统之间的一层数据管理软件</p><p>数据库系统：包括数据库，数据库管理系统，应用程序，数据库管理员</p><p>主键：用于唯一标识表中的某一条记录的属性或者属性的集合</p><p>外键：用于与另一张表关联，外键为灵一张表的主键</p><p>超键：超键是唯一能区分元组的属性和属性的集合</p><p>实例：数据库在某一时刻存储的真实数据</p><p>数据操纵语言：增删改查</p><p>数据定义语言：定义、删除、修改数据库中的对象</p><p>数据控制语言：用于控制用户对数据库操纵的权限</p><p>数据模型：现实世界数据特征的抽象，用来定于数据如何组织，数据之间的关系是怎么样的</p><p>并相容性：两个关系具有并相容性需要保证具有相同的属性个数，以及对于每个属性都有相同的域</p><p>视图：视图时虚拟的表，并不是物理存储的数据。是基本表或其他视图派生的数据。对视图的更新，实际上转换为对实际基表的更新。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>现实世界数据特征的抽象，用来定义数据如何组织，数据之间的关系怎样。</p><p>层次：</p><p>概念模型：按用户的观点来对数据或者信息进行建模</p><p>逻辑/实现模型：层次模型，网状模型，关系模型</p><p>物理模型：数据在具体DBMS产品中的物理存储方式</p><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>三级模式结构：</p><ul><li><p>内模式：<strong>数据物理结构和储存方式</strong>的描述，是数据在数据库内部的表示方式</p></li><li><p>概念模式：是对数据库中全体数据的<strong>逻辑结构</strong>和<strong>特征</strong>的描述</p></li><li><p>外模式：数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述</p></li></ul><p>两级映射：</p><ul><li>概念模式/内模式映射</li><li>外模式/概念模式映射</li></ul><p>数据的物理独立性：</p><p><strong>内模式与概念模式</strong>之间的映射提供了数据的<strong>物理独立性</strong>。当数据的物理结构发生变化时，只需要修改内模式与概念模式之间的映射即可。</p><p>数据的逻辑独立性：</p><p><strong>概念模式与外模式</strong>之间的映射提供了数据的<strong>逻辑独立性</strong>。当数据的整体逻辑结构发生变化时，只需要修改各个外模式与概念模式之间的映射即可保证应用程序不受影响。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>完整性约束：</p><ol><li>域约束：对<strong>属性取值范围</strong>的约束</li><li>键约束：每个关系必须要有<strong>主键</strong>，且每个主键必须不相同</li><li>非空约束：属性值不能为NULL</li><li>实体完整性约束：主键值不能为空</li><li>参照完整性约束：外键可以取NULL值，但若外键为另一关系主键，则不能为NULL</li><li>用户定义的完整性</li></ol><p>数据的操作违反的完整性约束：</p><p>插入操作：域约束、键约束、非空约束、实体完整性约束、参照完整性约束</p><p>删除操作：参照完整性约束</p><p>更新操作：域约束、键约束、非空约束、实体完整性约束、参照完整性约束</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>关系看上去像一张二维表，每个表由行和列组成</p><p>行代表一个元组，即<strong>数据记录</strong>。列代表属性，即<strong>字段</strong></p><p>关系的域为一组原子值（不可再分割的值）</p><p>关系中的元组必须各不相同（元组的唯一性）</p><p>五种基本运算：</p><p>并，差，笛卡尔积，选择，投影</p><p>关系代数是用对关系的运算来表达查询，这个时候可以使用关系代数解释器来模拟关系代数。</p><h3 id="并"><a href="#并" class="headerlink" title="并"></a>并</h3><p>运算符<strong>∪</strong></p><p>并运算将两个关系的所有元组合并为一个新关系，前提是两个关系必须有<strong>相同的属性</strong>（列），且每个元组在结果中只出现一次（去重）。</p><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>3</td><td><strong>4</strong></td></tr></tbody></table></div><p><code>R1 ∪ R2</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table></div><p>相当于<strong>增加行</strong></p><h3 id="差"><a href="#差" class="headerlink" title="差"></a>差</h3><p><strong>运算符</strong>：<code>-</code></p><p>差运算返回一个关系中有而另一个关系中没有的元组，前提是两个关系有相同的属性。</p><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table></div><p><code>R1 - R2</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr></tbody></table></div><p>相当于<strong>删减行</strong></p><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p><strong>运算符</strong>：<code>×</code></p><p>笛卡尔积运算将两个关系中的每一对元组组合成一个新的元组，其中一个关系的所有元组与另一个关系的每个元组组合形成一个新的元组。它的结果是一个新关系，包含了<strong>两个关系中所有属性的组合</strong>。</p><p><strong>两个集合相乘的结果</strong></p><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(C, D)  </p><div class="table-container"><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p><code>R1 × R2</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td><td>6</td></tr><tr><td>1</td><td>2</td><td>7</td><td>8</td></tr><tr><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>3</td><td>4</td><td>7</td><td>8</td></tr></tbody></table></div><p>相当于<strong>增加列</strong></p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><strong>运算符</strong>：<code>σ</code></p><p>选择运算用于从关系中选择满足特定条件的元组。选择操作是一种<strong>过滤</strong>操作，它根据指定的条件返回满足条件的元组。</p><p>R(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p><code>σ(A &gt; 4)(R)</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p>相当于<strong>过滤</strong></p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p><strong>运算符</strong>：<code>π</code></p><p>投影运算用于从关系中选择指定的列（属性）。它会返回包含指定列的所有元组，并且会去除重复的元组。</p><p>R(A, B, C)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><p><code>π(A, B)(R)</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>4</td><td>5</td></tr><tr><td>7</td><td>8</td></tr></tbody></table></div><p>相当于<strong>删减列</strong></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><strong>运算符</strong>：<code>⨝</code></p><p>连接是将两个关系中的元组按照某些共享的属性进行组合，生成新的元组。它是关系代数中非常重要的运算，因为它能够合并来自不同表的数据。连接运算通常是基于一个公共的列（或多个列）进行的。</p><p><strong>自然连接（Natural Join）</strong>：在自然连接中，连接操作自动寻找两个关系中相同名称的列，并将它们作为连接条件。自然连接将仅返回匹配的元组，并去除重复的列。</p><p><strong>等值连接（Equi-Join）</strong>：等值连接是指使用等号（<code>=</code>）作为连接条件，将两个关系中某个或某些列的值相等的元组合并。</p><p><strong>外连接（Outer Join）</strong>：外连接除了返回两个关系中匹配的元组外，还会保留在其中一个关系中没有匹配的元组，并用<code>NULL</code>填充缺失的值。外连接有三种类型：</p><ul><li><strong>左外连接（Left Outer Join）</strong>：返回左表中所有元组，以及右表中匹配的元组。<strong>右边的补充null</strong></li><li><strong>右外连接（Right Outer Join）</strong>：返回右表中所有元组，以及左表中匹配的元组。<strong>左边的补充null</strong></li><li><strong>全外连接（Full Outer Join）</strong>：返回两个表中的所有元组，不论它们是否匹配。都补充null</li></ul><p>R1(A, B)  </p><div class="table-container"><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table></div><p>R2(B, C)  </p><div class="table-container"><table><thead><tr><th>B</th><th>C</th></tr></thead><tbody><tr><td>2</td><td>5</td></tr><tr><td>4</td><td>6</td></tr></tbody></table></div><p>如果我们进行自然连接：<code>R1 ⨝ R2</code>，连接条件是属性<code>B</code>，结果会是：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td></tr><tr><td>3</td><td>4</td><td>6</td></tr></tbody></table></div><h3 id="除"><a href="#除" class="headerlink" title="除"></a>除</h3><p><strong>运算符</strong>：<code>÷</code></p><p>除操作用于解决“对于所有”这种类型的查询问题，通常用于查找在某个关系中与所有其他元组匹配的元组。除运算的结果是返回那些“<strong>满足某个条件的所有值</strong>”的元组。</p><p>R1(Student, Course)  </p><div class="table-container"><table><thead><tr><th>Student</th><th>Course</th></tr></thead><tbody><tr><td>Alice</td><td>Math</td></tr><tr><td>Alice</td><td>English</td></tr><tr><td>Bob</td><td>Math</td></tr><tr><td>Bob</td><td>History</td></tr><tr><td>Charlie</td><td>Math</td></tr></tbody></table></div><p>R2(Course)  </p><div class="table-container"><table><thead><tr><th>Course</th></tr></thead><tbody><tr><td>Math</td></tr><tr><td>English</td></tr></tbody></table></div><p><code>R1 ÷ R2</code> 的结果是：</p><div class="table-container"><table><thead><tr><th>Student</th></tr></thead><tbody><tr><td>Alice</td></tr></tbody></table></div><p>相当于<strong>找到某值</strong></p><h2 id="使用关系代数完成查询"><a href="#使用关系代数完成查询" class="headerlink" title="使用关系代数完成查询"></a>使用关系代数完成查询</h2><p>假设有两个关系：</p><ol><li><p><strong>学生（Student）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(学号, 姓名, 年龄, 系别)</span><br></pre></td></tr></table></figure><p>| 学号 | 姓名 | 年龄 | 系别     |<br>| —— | —— | —— | ———— |<br>| 101  | 张三 | 20   | 计算机系 |<br>| 102  | 李四 | 22   | 数学系   |<br>| 103  | 王五 | 21   | 计算机系 |<br>| 104  | 赵六 | 23   | 物理系   |</p></li><li><p><strong>选课（CourseSelection）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CourseSelection(学号, 课程号, 成绩)</span><br></pre></td></tr></table></figure><p>| 学号 | 课程号 | 成绩 |<br>| —— | ——— | —— |<br>| 101  | C1     | 85   |<br>| 101  | C2     | 90   |<br>| 102  | C1     | 78   |<br>| 103  | C3     | 88   |<br>| 104  | C2     | 76   |</p></li></ol><p>查询计算机系所有学生的姓名和年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">π姓名, 年龄(σ系别=′计算机系′(Student))</span><br></pre></td></tr></table></figure><p>查询选修了 C1 课程的学生的姓名</p><script type="math/tex; mode=display">π 姓名​ (σ 课程号= ′ C1 ′​ (CourseSelection)⋈Student)</script><p>查询至少选修了一门课程的学生信息</p><script type="math/tex; mode=display">π 学号, 姓名, 年龄, 系别​ (Student⋈CourseSelection)</script><p>其中π 为投影，代表的是保留哪一列</p><p>σ为选择，代表一个过滤的条件</p><p>后面括号代码查询的是哪个关系</p><p>进行<strong>自然连接（⨝）</strong>，匹配相同“学号”的学生信息。</p><p>÷代表找到某值</p><p>x代表笛卡尔积，表示可能出现所有的一个集合</p><h2 id="三值谓词逻辑"><a href="#三值谓词逻辑" class="headerlink" title="三值谓词逻辑"></a>三值谓词逻辑</h2><ul><li>TRUE</li><li>FALSE</li><li>UNKNOWN</li></ul><p>只有在比较结果为TRUE是才确定为真，e.g. （TRUE与UNKNOWN交为UNKNOWN， 此元组不会出现在结果中）</p><h2 id="将E-R模型映射成逻辑模型的步骤"><a href="#将E-R模型映射成逻辑模型的步骤" class="headerlink" title="将E-R模型映射成逻辑模型的步骤"></a>将E-R模型映射成逻辑模型的步骤</h2><ol><li>映射<strong>强实体型</strong></li><li>映射<strong>弱实体型</strong></li><li>映射1 : 1 二元联系型</li><li>映射1 : N 二元联系型</li><li>映射M : N二元联系型</li><li>映射<strong>多值属性</strong></li><li>映射<strong>N元联系</strong></li></ol><h2 id="关系模型的三个组成部分"><a href="#关系模型的三个组成部分" class="headerlink" title="关系模型的三个组成部分"></a>关系模型的三个组成部分</h2><ul><li>数据结构：基本的数据组织形式是关系，关系由元组和属性组成</li><li>数据操作：包括查询，更新操作</li><li>数据约束：包括实体完整性，参照完整性，用户定义完整性</li></ul><h2 id="关系键"><a href="#关系键" class="headerlink" title="关系键"></a>关系键</h2><p>主码：唯一标识元组的属性或属性组合，不可为空。</p><p>全码：能够唯一标识元组的属性集合，可能包含冗余属性。</p><p>候选码：最小的全码，不能再减少任何属性，否则就无法唯一标识元组。</p><p>外码：一个关系中的某个属性（或属性组），它引用另一个关系的主码。</p><p>外码的属性的值可以为空值</p><p>主属性：属于某个候选码的属性。</p><p>非主属性：不属于任何候选码的属性。</p><h1 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h1><p>数据库管理的需要催生了DBMS，而关系型数据库管理为RDBMS</p><p>常见的数据模型有三种：</p><ol><li>层次模型</li><li>网状模型</li><li>关系模型</li></ol><p>文件管理数据的缺陷：</p><ol><li><strong>数据冗余和不一致性</strong>。数据冗余表示在每个shell脚本中基本上都是/bin/bash，但很多用户使用的都是bash，那么这个可能出现多次，冗余量很大；不一致性，比如有一个数据在多个文件中都被使用，那么修改的时候，需要把每个文件都手动修改。</li><li><strong>数据访问困难</strong>。如果数据库有上千万行数据，那么我们使用时，需要把这上千万行数据全部载入内存中，再使用，对硬件的要求会很高而且载入时间很长，但其实我们需要比较的也只是那一行数据而已。</li><li><strong>数据孤立</strong>。由于数据保存在不同的文件里面，所以这些文件之间的格式可能各不相同，所以后续开发一个软件来管理的话非常困难，因为它们不满足某一个规范，使得数据之间是相互孤立的。</li><li><strong>完整性问题</strong>。例如两个转账的用户之间数额的总和应该是一样的，但如果在转账的过程中出现了问题，那么文件就无法解决，除非应用程序设计上解决，但应用程序本身并无法理解数据之间的逻辑问题。</li><li><strong>原子性问题</strong>。类似于完整性问题，数据必须从一个稳定的状态转换为另外一个稳定的状态。</li><li><strong>并发访问异常问题</strong>。按道理来讲，如果一个用户访问数据库文的前十行，另一个用户访问最后十行，本身他们俩并不会冲突，但如果某个用户需要修改的话，另外一个用户并不能访问。因为为了保证文件的完整性，我们会加锁的，但文件级别的锁安全性太高，并不适合这种访问</li><li><strong>安全性问题</strong>。部分访问授权很难实现，很难使某一个用户只能看到其中指定的某些字段。</li></ol><p>关系型数据库特点：</p><p>关系数据库想要解决<strong>数据冗余问题</strong>，它将每一个关系都看成了一个表，每一列都看成是一个属性，每一行看成是他的一个元组（也就是数据）如果有许多相同值的话，它将具有相同字段的值独立出来，把一张表拆分成两张表，降低所谓的冗余度，这种关系也叫做E-R关系模型（实体关系模型）</p><p>常见的关系模型：</p><ol><li>关系模型：用一张二维表来表示关系模型</li><li>实体关系模型：将一张表拆分，让它们产生某种联系</li><li>对象关系模型：存储一些比较大的文件如何存储呢？可以将一个比较大的文件先存储在数据库文件管理系统当中的某一个存储空间上，表中用一个指针指向这么某一个数据，把它当作一个存储对象来进行管理。</li><li>半结构化数据模型：结构化是指每一行存储的都是一样的，比如/etc/passwd文件中，第一个字段为用户名，第二个为密码等。半结构化表示它并不是唯一的，可能第一行存储的是用户名和性别，第二行存储的是用户名和年龄这种，<strong>所以每一行存储不止存储它的数据，还存储它的标签。</strong></li></ol><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>SQL：Structure Query Language(关系结构化语言)</p><ul><li>DML：数据操作语言，增删改查都是DML语句。</li><li>DDL：数据定义语言，实现数据对象的存储和定义。CREATE、DROP、ALTER</li><li>DCL：数据控制语言，GRANT、REVOKE，用来定义数据库中用户的访问权限</li></ul><p>关系数据库RDB的对象基本有：库、表、索引、视图、用户、存储过程、触发器、事件调度器等。</p><p>实现定义的时候，一定要考虑数据的<strong>约束</strong>关系</p><p>域约束：<strong>数据类型的约束</strong><br>外键约束：<strong>引用完整性约束</strong><br>主键约束：某字段能<strong>唯一</strong>标识此字段所属的实体，并且不允许为空,<strong>一张表中只能有一个主键</strong><br>唯一性约束：每一行的某字段都不允许出现相同值，可以为空，一张表中可以有多个<br>检查性约束：比如年龄只能时int型</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>表示层：表</li><li>逻辑层：存储引擎，实现表和数据文件的解构</li><li>物理层：数据文件</li></ul><p>数据存储和查询</p><ul><li>存储管理器</li><li>查询管理器</li></ul><p>负责接收用户查询，理解用户查询，并将用户的查询包括存储转换为对应的存储管理器可以理解的语句，存储管理器将数据存储到磁盘上或从磁盘上删除的这么一种组件</p><p>存储管理器应该具有的组件（功能）：权限及完整性管理器、事务管理器、文件管理器、缓冲区管理器</p><p>查询管理器应该具有的组件（功能）：DML解释器、DDL解释器、查询执行引擎</p><p>数据存储和执行的过程：</p><ol><li>查询管理器接受用户查询，并理解。使用DML和DDL解释器</li><li>将DML和DDL解释器的结果给查询执行引擎</li><li>查询执行引擎的结果给存储管理器</li><li>存储管理器将操作写入磁盘中</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/25/sql2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络基础</title>
      <link>https://blog.tokenlen.top/2025/02/23/net2/</link>
      <guid>https://blog.tokenlen.top/2025/02/23/net2/</guid>
      <pubDate>Sat, 22 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;传输方式&quot;&gt;&lt;a href=&quot;#传输方式&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>网络根据传输方式可以进行分类，一般分为<strong>面向连接型和面向无连接型</strong>。</p><ul><li>面向连接型中，在发送数据之前，需要在主机之间建立一条通信线路。</li><li>面向无连接型则不要求建立和断开连接，发送方可用于任何时候发送数据。接收端也不知道自己何时从哪里接收到数据。</li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>处在互联网边缘部分的机器，也就是互联网终端主机，它们官方一点的话术就是端系统。</p><p>在互联网应用中，每个终端系统都可以彼此交换信息，这种信息也被称为<code>报文(Message)</code>，报文是一个超集的概念，它可以包括你想要的任何东西，比如文字、数据、电子邮件、音频、视频等。为了从源目的地向端系统发送报文，需要把长报文切分为一个个小的数据块，这种数据块称为<code>分组(Packets)</code>，也就是说，报文是由一个个小块的分组组成。</p><p>这些分组其实就是<strong>包</strong></p><p>在分组的传输过程中，每个分组都要经过通信链路和分组交换机，分组要在端系统之间传输需要经过一定的时间，如果两个端系统之间需要传输的分组为 L 比特，链路的传输速率问 R 比特/秒，那么传输时间就是 L / R秒。</p><p>一个端系统需要经过交换机给其他端系统发送分组，当分组到达分组交换机时，交换机会如何操作？交换机会直接进行转发吗？不是的，交换机可没有这么无私，你想让我帮你转发分组？好，首先你需要先把整个分组数据都给我，我再考虑给你发送的问题，这就是<strong>存储转发传输</strong>。</p><h1 id="数据在不同层的称呼"><a href="#数据在不同层的称呼" class="headerlink" title="数据在不同层的称呼"></a>数据在不同层的称呼</h1><p>四层传输层数据被称作<strong>段</strong>（Segments）；</p><p>三层网络层数据被称做<strong>包</strong>（Packages）；</p><p>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</p><p>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p><strong>网络ip地址：</strong></p><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p><strong>广播地址：</strong></p><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p><strong>组播地址：</strong></p><p>D类地址就是组播地址。</p><p><strong>A，B，C，D类地址</strong></p><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p><p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>255.255.255.255</strong></p><p><strong>该IP地址指的是受限的广播地址</strong>。受限广播地址与一般广播地址（直接广播地址）的区别在于，<strong>受限广播地址只能用于本地网络</strong>，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p><strong>0.0.0.0</strong></p><p><strong>常用于寻找自己的IP地址</strong>，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p>回环地址：</p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是<strong>127.0.0.1。</strong> 也可以用<strong>localhost</strong>来表示</p><p><strong>A、B、C类私有地址</strong></p><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果<strong>两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中</strong>。</p><p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即” 0”地址和广播地址，它们是指主机地址或网络地址全为” 0”或” 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><h3 id="子网掩码的计算"><a href="#子网掩码的计算" class="headerlink" title="子网掩码的计算"></a>子网掩码的计算</h3><p>无需划分：</p><p>在这个无须划分子网里面是按ip地址的类别决定的。比如A类地址占8个网络位，所以是255.0.0.0</p><p>B类地址占16个网络位，所以子网掩码就是255.255.0.0</p><p>C类地址占24个网络位，所以子网掩码就是255.255.255.0</p><p>固定大小的子网：</p><p>通常用于根据特定的网络需求（如特定数量的主机或子网）来划分。计算的关键是确定所需的网络位数和主机位数，并根据此来计算掩码。</p><ul><li><p>确定需要多少个子网，或者每个子网需要多少主机。</p></li><li><p>使用<strong>2的幂</strong>来推算所需的主机位数或子网位数。</p></li><li><p>将其与默认子网掩码结合，进行扩展。</p></li></ul><p>实例：</p><p>假设你有一个<strong>A类地址</strong><code>10.0.0.0</code>，默认子网掩码是<code>255.0.0.0</code>。你希望把这个地址划分为<strong>4个子网</strong>。</p><p>需要划分为4个子网，那么就需要2个子网位，然后又是A类地址，8个网络位。所以一共是10个网络位</p><p>所以新的子网掩码就是（前10位是1，其余是0）</p><p>11111111.11000000.00000000.00000000</p><p>转化为10进制就是</p><p><strong>255.192.0.0</strong></p><p>根据主机数来确定：</p><p>这种方法是通过需求来计算每个子网所能容纳的最大主机数，从而确定子网掩码。</p><ul><li><p>根据你想要的每个子网中的主机数，反推所需的主机位数。</p></li><li><p>用<strong>2的幂</strong>来计算能容纳的最大主机数。公式：<code>2^n - 2</code>（减去2是因为网络地址和广播地址不能用作主机地址）。</p></li><li><p>然后确定剩下的位数就是网络位数，从而确定子网掩码。</p></li></ul><p>实例：</p><p>假设你想要为每个子网容纳50个主机</p><p>2^n - 2 &gt;= 50</p><p><code>2^6 - 2 = 62</code>，所以需要6个主机位。</p><p>如果是C类地址，默认掩码是<code>255.255.255.0</code>，即24个网络位。</p><p>所以那么子网掩码用二进制表示就是</p><p>现在，给定6个主机位，网络位数是：<code>32 - 6 = 26</code></p><p>11111111.11111111.11111111.11000000</p><p>转化为10进制就是<strong>255.255.255.192</strong></p><p>CIDR表示法：</p><p>它允许你直接指定子网掩码的位数，而不是依赖于IP地址的类别。CIDR表示法用斜杠后跟数字的形式表示子网掩码。</p><ul><li><p>CIDR表示法是通过直接指明网络部分的位数来计算子网掩码。例如，<code>/24</code> 表示前24位是网络位，后8位是主机位。</p></li><li><p>你可以通过CIDR来指定任何IP地址和子网掩码，而不仅仅是A类、B类或C类地址。</p></li></ul><p><code>10.0.0.0/8</code>：表示A类地址 <code>10.0.0.0</code>，子网掩码为 <code>255.0.0.0</code>。</p><p><code>172.16.0.0/16</code>：表示B类地址 <code>172.16.0.0</code>，子网掩码为 <code>255.255.0.0</code>。</p><p><code>192.168.1.0/24</code>：表示C类地址 <code>192.168.1.0</code>，子网掩码为 <code>255.255.255.0</code>。</p><p>主机和子网的地址进行计算：</p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10＋1＋1＋1＝13</span><br></pre></td></tr></table></figure><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址</strong></p><p>网关也是要占地址的</p><p>13小于16（2的四次方）所以主机位是4位。256-16=240</p><p>所以子网掩码是<strong>255.255.255.240</strong></p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关实质上是一个网络通向其他网络的IP地址。</p><p>比如有网络A和网络B，网络A的IP地址范围为<code>192.168.1.1~192. 168.1.254</code>，子网掩码为<code>255.255.255.0</code>；</p><p>网络B的IP地址范围为<code>192.168.2.1~192.168.2.254</code>，子网掩码为<code>255.255.255.0</code>。</p><p>而要实现这两个网络之间的通信，则必须通过网关。</p><p><strong>所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。</strong></p><p>如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。</p><p>网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。</p><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><p>核心作用：</p><ul><li><strong>标准化通信：</strong>网络协议为设备之间的通信提供了统一的标准，确保不同厂商、不同操作系统的设备能够互联互通。</li><li><strong>数据可靠传输：</strong>通过错误检测、数据重传等机制，网络协议确保数据在传输过程中不会丢失或损坏。</li><li><strong>高效路由与寻址：</strong>网络协议定义了如何将数据从源设备发送到目标设备，包括地址分配、路由选择等。</li><li><strong>安全性：</strong>现代网络协议通常包含加密和认证机制，保护数据免受窃听或篡改。</li></ul><p>关键组成部分：</p><ul><li><strong>语法:</strong> 定义数据的格式和结构。例如，数据包的头部和尾部如何组织。</li><li><strong>语义:</strong> 定义数据的含义。例如，某个字段表示源地址，另一个字段表示目标地址。</li><li><strong>时序:</strong> 定义数据发送和接收的顺序。例如，TCP协议的三次握手过程。</li><li><strong>网络协议的分层结构:</strong> 网络协议通常按照分层模型组织，最常见的模型是 OSI七层模型 和 TCP/IP四层模型。每一层都有特定的功能和协议。</li></ul><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络通信是指通过计算机网络（如互联网）<strong>在不同设备之间传输数据的过程。</strong>这些设备可以是计算机、智能手机、服务器等。网络通信的核心目标是<strong>实现信息的快速、准确和安全传输。</strong></p><p>基本要素：</p><ul><li><strong>发送方（Sender）</strong>：发送数据的设备或应用程序。</li><li><strong>接收方（Receiver）</strong>：接收数据的设备或应用程序。</li><li><strong>传输介质（Transmission Medium）</strong>：数据在网络中传输的物理路径，如光纤、电缆、无线信号等。</li><li><strong>协议（Protocol）</strong>：规定数据如何传输、如何被接收和处理的规则和标准。</li></ul><p>在网络通信中，数据通常以”包”（Packet）的形式传输。数据封装是指将原始数据按照特定的协议格式打包，添加必要的控制信息（如源地址、目标地址、校验和等）。解封装则是接收方将接收到的数据包还原为原始数据的过程。</p><p>传输过程：</p><ol><li><strong>数据分段</strong>：将大块数据分割成适合传输的小块。</li><li><strong>添加头部信息</strong>：在每个数据段前添加协议头部信息，如IP地址、端口号等。</li><li><strong>传输</strong>：通过网络传输介质将数据包发送到目标设备。</li><li><strong>接收与重组</strong>：接收方接收数据包，并根据头部信息将数据包重组为原始数据。</li></ol><p>在网络通信中，数据被分割成小块进行传输，这些小块被称为数据包、帧或报文，具体名称取决于所在的网络层次。</p><ul><li><strong>数据包（Packet）:</strong> 在网络层（如IP协议）中，数据被封装成数据包，包含源地址、目标地址和数据内容。</li><li><strong>帧（Frame）:</strong> 在数据链路层（如以太网协议）中，数据包被进一步封装成帧，包含MAC地址和错误检测信息。</li><li><strong>报文（Message）:</strong> 在应用层（如HTTP协议）中，数据以报文的形式传输，包含请求或响应的具体内容。</li></ul><p>网络通信的基本流程：</p><ol><li><strong>数据封装</strong><ul><li>应用层生成数据报文。</li><li>传输层添加端口号（TCP/UDP）。</li><li>网络层添加IP地址（IP）。</li><li>数据链路层添加MAC地址（帧）。</li><li>物理层将数据转换为比特流。</li></ul></li><li><strong>数据传输</strong><ul><li>数据通过物理介质（如电缆、光纤）传输。</li></ul></li><li><strong>数据解封装</strong><ul><li>接收设备逐层解析数据，最终将数据传递给目标应用程序。</li></ul></li></ol><h2 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h2><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议</strong></p><p>ARP 把 IP 地址解析为硬件地址</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</p><p><strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>ARP工作流程：</p><ul><li><p><strong>主机A查询ARP缓存</strong>：主机A检查是否有主机B的IP地址和MAC地址映射。如果有，直接使用该映射进行通信。</p></li><li><p><strong>ARP请求广播</strong>：如果ARP缓存中没有对应的映射，主机A会向网络广播ARP请求，询问目标IP（192.168.1.2）的MAC地址，ARP请求包括主机A的IP和MAC地址。</p></li><li><p><strong>主机B接收ARP请求</strong>：网络中的所有主机接收到ARP请求，检查IP地址是否匹配。如果匹配，则继续处理请求；否则丢弃请求。</p></li><li><p><strong>主机B发送ARP回复</strong>：主机B回复ARP请求，发送自己的MAC地址给主机A。</p></li><li><p><strong>主机A更新ARP缓存</strong>：主机A接收到主机B的ARP回复后，更新ARP缓存，并使用主机B的MAC地址进行通信。</p></li><li><p><strong>缓存生存期</strong>：ARP缓存的条目有生存期，生存期过后，主机A需要重新进行ARP过程以更新MAC地址映射。</p></li></ul><p>RARP工作流程：</p><ul><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p>RIP协议 ：底层是<strong>贝尔曼福特算法</strong>，它选择路由的度量标准（metric)是跳数，最大跳数是<strong>15跳</strong>，如果大于15跳，它就会丢弃数据包。</p><p>OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是<strong>迪杰斯特拉算法</strong>，是链路状态路由选择协议，它选择路由的度量标准是<strong>带宽，延迟</strong>。</p><h2 id="tcp-ip"><a href="#tcp-ip" class="headerlink" title="tcp/ip"></a>tcp/ip</h2><p>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：<strong>TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—-TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p>TCP是面向连接的通信协议，是一个<strong>传输层协议</strong>，是一个<strong>双工协议</strong>，这就意味着客户端和服务端可以平等地发送、接收信息。通过<strong>三次握手</strong>建立连接，通讯完成时要通过<strong>四次挥手</strong>拆除连接，这个连接就是一个通道，由于TCP是面向连接的所以只能用于<strong>端到端</strong>（套接字到套接字）的通讯。TCP提供的是一种可靠的<strong>数据流</strong>服务，采用”带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为”滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。<strong>面向字节流</strong>。虽然应用程序与TCP交互是一次一个大小不等的数据块，但<strong>TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系</strong>，例如，发送方应用程序交给发送方的TCP10个数据块，接收方的TCP可能只用收到的4个数据块字节流交付给上层的应用程序</p><h3 id="tcp的可靠性原理"><a href="#tcp的可靠性原理" class="headerlink" title="tcp的可靠性原理"></a>tcp的可靠性原理</h3><p>可靠传输有如下两个特点:</p><ol><li>传输信道无差错,保证传输数据正确;</li><li>不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;</li></ol><p>首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，<strong>从而保证建立的传输信道是可靠的</strong>。</p><p>其次，TCP采用了连续ARQ协议（回退N(Go-back-N)；超时自动重传）来保证数据传输的正确性，使用<strong>滑动窗口协议</strong>来保证接方能够及时处理所接收到的数据，进行流量控制。</p><p>最后，TCP使用<strong>慢开始、拥塞避免、快重传和快恢复</strong>来进行拥塞控制，避免网络拥塞。</p><h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a><strong>TCP报文段</strong></h3><p>TCP虽面向字节流，但传送的数据单元为报文段</p><p>报文段=首部+数据两部分</p><ol><li>首部前20个字符固定、后面有4n个字节是根据需而增加的选项</li><li>故 TCP首部最小长度 = 20字节</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-8011660d-24c8-460f-ac3d-b97ad9c99b13.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3779-20150904110054856-961661137.png" alt=""></p><p><strong>端口</strong>：</p><p>源端口号和目地端口各占16位两个字节，也就是端口的范围是<code>2^16=65535</code></p><p>另外1024以下是系统保留的，从1024-65535是用户使用的端口范围（一般常用的某些端口，比如5244,8080）</p><p><strong>seq序号</strong>：</p><p>占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。</p><p><strong>ack确认号</strong>：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。</p><p>B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1=500），B期望收到A下一个数据序号是501，B发送给A的确认报文段中把ack确认号置为501。</p><p><strong>数据偏移</strong>：</p><p>头部有可选字段，长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远。</p><p><strong>保留</strong>：保留今后使用的，标记为1</p><p><strong>控制位</strong>：由8个标志位构成，每个标志位表示一个控制功能。</p><p>其中比较重要的6个：</p><ul><li><strong>URG紧急指针标志</strong>，为1表示紧急指针有效，为0忽略紧急指针。</li><li><strong>ACK确认序号标志</strong>，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。</li><li><strong>PSH标志</strong>，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。</li><li><strong>RST重置连接标志</strong>，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。</li><li><strong>SYN同步序号</strong>，同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。。</li><li><strong>FIN终止标志</strong>，用于释放连接，为1时表示发送方没有发送了。</li></ul><p><strong>窗口</strong>：滑动窗口的大小，用来告知发送端接受端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。</p><p><strong>校验和</strong>：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。</p><p><strong>紧急指针</strong>：只有控制位中的URG为1时才有效，指出本报文段中的紧急数据的字节数</p><p><strong>选项</strong>：其长度可变，定义其他的可选参数</p><h3 id="tcp的三次握手和三次挥手"><a href="#tcp的三次握手和三次挥手" class="headerlink" title="tcp的三次握手和三次挥手"></a><strong>tcp的三次握手和三次挥手</strong></h3><p><strong>三次握手</strong>：用来建立 TCP 连接，确保双方都准备好进行数据传输：</p><ol><li>客户端发送 SYN 请求，表示希望建立连接。</li><li>服务器回复 SYN-ACK，表示同意建立连接。</li><li>客户端发送 ACK 确认，连接建立成功。</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-f6a9438e-4eb8-4573-9ef5-30e07b8c31df.png" alt=""></p><p>详细的过程</p><p>第一次握手：客户端将TCP报文标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p><p>第二次握手：服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个序号值<code>seq=K</code>，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</p><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code>状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>服务器发送完<strong>SYN－ACK</strong>包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的<strong>最大重传次数</strong>，系统将该连接信息从<strong>半连接队列</strong>中删除。</p><p>第三次握手：客户端收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><p><strong>全连接队列</strong>就是三次握手已经完成了，建立起的连接就会放到全连接队列里，队列满了就会出现丢包。</p><p>其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而<strong>第三次握手是可以携带数据</strong>的。</p><p>其中上面的ack和ACK不是同一个概念</p><ul><li>小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，<code>ack=seq+1</code>。</li><li>大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。</li></ul><p><strong>四次挥手</strong>：用来关闭连接，确保双方都完成数据的传输后才断开连接：</p><ol><li>客户端发送 FIN 请求，表示数据发送完毕，准备关闭连接。</li><li>服务器回复 ACK，确认收到客户端的关闭请求。</li><li>服务器发送 FIN 请求，表示服务器也准备关闭连接。</li><li>客户端回复 ACK，连接正式关闭。</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-4a5e455f-5cf8-47a6-8fe4-a4c83a445f77.png" alt=""></p><p>挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：</p><p>第一次挥手：Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入<code>FIN_WAIT_1</code>状态，这表示Client端没有数据要发送给Server端了。</p><p>第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入<code>FIN_WAIT_2</code>状态，Server端告诉Client端，我确认并同意你的关闭请求。</p><p>第三次挥手：Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入<code>LAST_ACK</code>状态。</p><p>第四次挥手：Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入<code>TIME_WAIT</code>状态，Server端收到Client端的ACK报文段以后，就关闭连接，此时，Client端等待<strong>2MSL</strong>的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</p><p><strong>MSL</strong>：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p>为什么要三次握手？</p><p>在只有两次”握手”的情形下，假设Client想跟Server建立连接，但是<strong>却因为中途连接请求的数据报丢失了</strong>，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被<strong>阻塞</strong>了，这种情形下<strong>Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据</strong>…问题就在这里，<strong>Cient端实际上只有一次请求，而Server端却有2个响应，</strong>极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，<strong>因而造成极大的资源浪费</strong>！所以，”三次握手”很有必要！</p><p>为什么要四次挥手？</p><p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是<strong>保证双方的一个合约的完整执行</strong>！</p><p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>即套接字，是应用层 与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-eff20ef6-9d35-4075-8c53-ab52c7a46ac7.png" alt=""></p><p><code>Socket</code>不是一种协议，而是一个编程调用接口（<code>API</code>），属于传输层（主要解决数据如何在网络中传输）</p><p>对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信</p><h2 id="upd"><a href="#upd" class="headerlink" title="upd"></a>upd</h2><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</strong></p><p>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—-应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>每个UDP报文分UDP报头和UDP数据区两部分。报头由<strong>四个16位长</strong>（2字节）字段组成，分别说明该报文的<strong>源端口、目的端口、报文长度以及校验值</strong>。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li>（1）源端口号；</li><li>（2）目标端口号；</li><li>（3）数据报长度；</li><li>（4）校验值。</li></ul><p><strong>运输层提供应用进程之间的逻辑通信</strong>，运输层之间的通信并不是真正在两个运输层之间直接传输数据。是端对端之间的应用进程传输</p><p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p><p>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</p><h2 id="upd和tcp-ip协议的特点对比"><a href="#upd和tcp-ip协议的特点对比" class="headerlink" title="upd和tcp/ip协议的特点对比"></a>upd和tcp/ip协议的特点对比</h2><p>UDP 的主要特点是 ① <strong>无连接</strong> ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）<strong>upd是不可靠的</strong></p><p>TCP 的主要特点是 ① <strong>面向连接</strong> ② 每一条 TCP 连接只能是一对一的 ③ 提供<strong>可靠</strong>交付 ④ 提供全双工通信 ⑤ 面向字节流</p><h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。<strong>域名是由圆点分开一串单词或缩写组成的</strong>，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。</p><p>我们可以通过windows的ping命令来查找域名所对应的ip地址</p><h3 id="dns解析"><a href="#dns解析" class="headerlink" title="dns解析"></a>dns解析</h3><p>A记录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义www.example.com的ip地址</span><br><span class="line">www.example.com.     IN     A     139.18.28.5;</span><br></pre></td></tr></table></figure><p><code>www.example.com</code> 是要解析的域名。</p><p>A 是记录的类型，A 记录代表着这是一条用于解析 IPv4 地址的记录。</p><p>从这条记录可知，<code>www.example.com</code>的 IP 地址是 139.18.28.5。</p><p>CNAME记录：</p><p>CNAME用于<strong>定义域名的别名</strong>，如下面这条 DNS 记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义www.example.com的别名</span><br><span class="line">a.example.com.          IN     CNAME   b.example.com.</span><br></pre></td></tr></table></figure><p>这条 DNS 记录定义了 <code>a.example.com</code> 是 <code>b.example.com</code> 的别名。</p><p>用户在浏览器中输入 <code>a.example.com</code> 时候，通过 DNS 查询会知道 <code>a.example.com</code> 是 <code>b.example.com</code> 的别名，因此需要实际 IP 的时候，会去拿 <code>b.example.com</code> 的 A 记录。</p><p>当你想把一个网站迁移到新域名，旧域名仍然保留的时候；还有当你想将自己的静态资源放到 CDN 上的时候，CNAME 就非常有用。</p><p>AAAA记录：</p><p>A 记录是域名和 IPv4 地址的映射关系。和 A 记录类似，AAAA 记录则是域名和 IPv6 地址的映射关系。</p><p>MX记录：</p><p>MX 记录是邮件记录，用来描述邮件服务器的域名。</p><p>比如说，发送一封邮件到 <code>xiaoming@xiaoflyfish.com</code>，那么如何知道哪个 IP 地址是邮件服务器呢？</p><p>这个时候就可以用到下面这条 MX 记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN MX mail.xiaoflyfish.com</span><br></pre></td></tr></table></figure><p><code>mail.xiaoflyfish.com</code> 的 IP 地址可以通过查询 <code>mail.xiaoflyfishcom</code>的 A 记录和 AAAA 记录获得。</p><p>NS记录：</p><p>NS记录是描述 DNS 服务器网址。从 DNS 的存储结构上说，Name Server 中含有权威 DNS 服务的目录。</p><p>也就是说，NS 记录指定哪台 Server 是回答 DNS 查询的权威域名服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.com.     IN      NS      ns1.a.com.</span><br><span class="line">a.com.     IN      NS      ns2.a.com.</span><br></pre></td></tr></table></figure><p>当解析 <code>a.com</code> 地址时，我们看到 <code>a.com</code> 有两个 NS 记录，所以确定最终 <code>a.com</code> 的记录在 <code>ns1.a.com</code> 和 <code>ns2.a.com</code> 上。</p><p>从设计上看，ns1 和 ns2 是网站 <code>a.com</code> 提供的智能 DNS 服务器，可以提供负载均衡、分布式 Sharding 等服务。</p><p>比如当一个北京的用户想要访问 <code>a.com</code> 的时候，ns1 看到这是一个北京的 IP 就返回一个离北京最近的机房 IP。</p><p>上面代码中 <code>a.com</code> 配置了两个 NS 记录。</p><p>通常 NS 不会只有一个，这是为了保证高可用，一个挂了另一个还能继续服务。</p><p>通常数字小的 NS 记录优先级更高，也就是 ns1 会优先于 ns2 响应。</p><p>配置了上面的 NS 记录后，如果还配置了 <code>a.com</code> 的 A 记录，那么这个 A 记录会被 NS 记录覆盖。</p><h2 id="nat"><a href="#nat" class="headerlink" title="nat"></a>nat</h2><p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将<strong>私有</strong>（保留）地址转化为<strong>合法IP地址</strong>的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><h2 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h2><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用<strong>UDP协议工作</strong>，主要有两个用途：<strong>给内部网络或网络服务供应商自动分配IP地址</strong>，<strong>给用户或者内部网络管理员作为对所有计算机作中央管理的手段</strong>。</p><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><h3 id="常见的http方法"><a href="#常见的http方法" class="headerlink" title="常见的http方法"></a>常见的http方法</h3><p><strong>GET</strong>：请求服务器返回指定的资源（例如网页）。是从服务器上获取资源，传送的数据量小，不能大于2kb。</p><p><strong>POST</strong>：向服务器提交数据（例如表单数据）。向服务器提交资源，传送的数据量较大，一般默认为不受限制。</p><p>GET请求与Post请求区别：</p><ol><li>GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到body中，在url 中不可见。</li><li>请求的url有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如IE浏览器对 URL的最大限制为<strong>2083</strong>个字符（2kb），如果超过这个数字，提交按钮没有任何反应，因为GET请求的参数是添加到URL中，所以GET请求的URL的长度限制需要将请求参数长度也考虑进去。而POST请求不用考虑请求参数的长度。</li><li><strong>GET</strong>请求产生<strong>一个</strong>数据包; <strong>POST</strong>请求产生<strong>2个</strong>数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为GET没有请求体，所以就发送一个数据包，而POST包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。</li><li>GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>GET是幂等的，而POST不是(幂等表示执行相同的操作，结果也是相同的)</li><li>GET是获取数据，POST是修改数据</li></ol><p><strong>PUT</strong>：更新资源。</p><p><strong>DELETE</strong>：删除资源。</p><p><strong>CONNECT</strong>:HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p><p><strong>OPTIONS</strong>:允许客户端查看服务器的性能。</p><p><strong>TRACE</strong>:回显服务器收到的请求，主要用于测试或诊断。</p><p><strong>PATCH</strong>:是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p><p>根据http规范,get用于信息获取，应该是<strong>安全的</strong>和<strong>幂等的</strong></p><ul><li>所谓 <strong>安全的</strong> 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</li><li><strong>幂等</strong> 的意味着对同一URL的多个请求应该返回同样的结果。</li></ul><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><p>状态码由三位数字构成，第一位定义响应的类别</p><p><strong>1xx</strong>：代表成功表示请求以接收，继续处理</p><p>HTTP/1.1加入了一个新的状态码100。</p><p>客户端事先发送一个只带头域的请求，<strong>如果服务器因为权限拒绝了请求，就回送响应码401</strong>（Unauthorized）；</p><p><strong>如果服务器接收此请求就回送响应码100</strong>，客户端就可以继续发送带实体的完整请求了。</p><p>100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p><p><strong>2xx</strong>：成功，表示请求已经被成功接收、理解、接受，例如 200 OK 表示请求成功。</p><ul><li>200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</li><li>204 No Content 也是常见的成功状态码，与 200 OK 基本相同，<strong>但响应头没有 body 数据。</strong></li><li>206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示<strong>响应返回的 body 数据并不是资源的全部</strong>，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><strong>3xx</strong>：重定向，例如 301 Moved Permanently 表示资源已永久移动。</p><ul><li><p>301 Moved Permanently 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。</p></li><li><p>302 Moved Permanently 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。</p><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p></li><li><p>304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>：客户端发送的<strong>报文有误</strong>，例如 404 Not Found 表示请求的资源不存在。</p><ul><li>400 Bad Request表示客户端请求的报文有错误。</li><li>401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li>404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>：状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，服务器错误，例如 500 Internal Server Error 表示服务器发生错误。</p><ul><li>501 Not Implemented 表示客户端请求的功能还不支持。</li><li>502 Bad Gateway 通常是服务器作为<strong>网关或代理</strong>时返回的错误码，表示服务器自身工作正常，访问<strong>后端服务器</strong>发生了错误。</li><li>503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。</li><li>504 Gateway Timeout：<strong>网关超时</strong>，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</li></ul><h3 id="host字段"><a href="#host字段" class="headerlink" title="host字段"></a>host字段</h3><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.0</span><br></pre></td></tr></table></figure><p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p><strong>服务器应当支持 Host 头字段</strong>，用于处理多个虚拟主机共享同一 IP 地址的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><p>在这个请求中，<code>Host: www.example.com</code> 告诉服务器，该请求是针对 <code>www.example.com</code> 这个主机的，即便该服务器托管多个网站（如 <code>example.net</code>、<code>test.com</code>），它也可以正确解析请求。</p><p>此外，服务器应该接受以绝对路径标记的资源请求。</p><p>HTTP/1.1 允许请求中使用<strong>绝对 URI（absolute URI）</strong>，即完整 URL，包括协议、主机名和路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.example.com/index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><h3 id="https和http的区别"><a href="#https和http的区别" class="headerlink" title="https和http的区别"></a>https和http的区别</h3><p>HTTPS 在 HTTP 上加入了 SSL/TLS 协议，通过<strong>加密保护数据的机密性和完整性</strong>，防止中间人攻击。</p><p>https更加安全，对搜索引擎更友好</p><p>其中http默认为80port，https默认443port</p><p>https基于<strong>传输层</strong>，http基于<strong>应用层</strong></p><p>https在浏览器显示绿色安全锁，http则没有</p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-3c00598c-43c2-44cd-96c6-ee4d40b97abd.png" alt=""></p><p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p><p><strong>常见的HTTP报文头属性</strong></p><ul><li><p>Accpet</p><p>告诉服务端，客户端接收什么类型的响应</p></li><li><p>Referer</p><p>表示这是请求是从哪个URL进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的Referer就是：<a href="https://javabetter.cn/cs/www.baidu.com">www.baidu.com</a></p></li><li><p>Cache-Control</p><p>对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置</p></li><li><p>Accept-Encoding</p><p>这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)</p><p>例如:<code>Accept-Encoding:gzip, deflate</code>(这两种都是压缩格式)</p></li><li><p>Host</p><p>指定要请求的资源所在的主机和端口</p></li><li><p>User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称</p></li><li><p>Connection</p></li></ul><p>​    决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。</p><ul><li><p>持久连接，事务完成后不关闭网络连接 ：<code>Connection: keep-alive</code></p></li><li><p>非持久连接，事务完成后关闭网络连接： <code>Connection: close</code></p></li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-58884113-14dc-4cca-a63e-3320f31a4da5.png" alt=""></p><p>响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)</p><ul><li><p>Cache-Control</p><p>响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存</p></li><li><p>ETag</p><p>表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变</p></li><li><p>Location</p><p>在重定向中或者创建新资源时使用</p></li><li><p>Set-Cookie</p><p>服务端可以设置客户端的cookie</p></li></ul><h2 id="ssl-tls"><a href="#ssl-tls" class="headerlink" title="ssl/tls"></a>ssl/tls</h2><p>SSL（Secure Sockets Layer，安全套接字层）和 TLS（Transport Layer Security，传输层安全协议）是用于<strong>保障网络通信安全</strong>的加密协议。TLS 是 SSL 的后续版本，TLS 1.0 基于 SSL 3.0 发展而来，目前<strong>TLS 已经取代 SSL</strong>，最新版本是 <strong>TLS 1.3</strong>。</p><p>作用：</p><p><strong>加密</strong>：防止数据被窃听，确保传输的机密性。</p><p><strong>完整性</strong>：防止数据被篡改，确保数据完整性。</p><p><strong>身份验证</strong>：通过证书验证服务器（可选客户端）身份，防止中间人攻击。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>客户端hello</strong></p><p>客户端向服务器发送 <code>ClientHello</code> 消息，包含：</p><ul><li>支持的 TLS 版本（如 TLS 1.2、TLS 1.3）</li><li>支持的加密算法（如 AES、RSA、ECDHE 等）</li><li>一个随机数（用于后续密钥生成）</li></ul><p><strong>服务器hello</strong></p><ul><li><p>服务器响应 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerHello</span><br></pre></td></tr></table></figure><p> 消息，包含：</p><ul><li>选定的 TLS 版本和加密算法</li><li>服务器证书（包含公钥）</li><li>一个随机数</li></ul></li></ul><p><strong>密钥交换</strong>：</p><ul><li>TLS 1.2 及更早版本：<ul><li>服务器的证书中包含公钥，客户端使用该公钥加密一个随机密钥并发送给服务器（RSA 密钥交换）。</li><li>也可使用椭圆曲线 Diffie-Hellman（ECDHE）生成共享密钥。</li></ul></li><li>TLS 1.3（优化握手）：<ul><li>直接使用 ECDHE 进行密钥交换，减少握手步骤，提高安全性。</li></ul></li></ul><p><strong>证书验证：</strong></p><p>客户端验证服务器证书是否合法（CA 颁发、未过期等）。</p><p>可选地，服务器也可以要求客户端提供证书进行身份验证（双向 TLS）。</p><p><strong>对称密钥生成：</strong></p><p>双方根据交换的随机数和密钥交换算法，生成会话密钥。</p><p>后续数据通信使用 <strong>对称加密算法</strong>（如 AES）加密，提高效率。</p><p><strong>安全通信：</strong></p><p>双方交换 <code>Finished</code> 消息，表示握手完成。</p><p>之后所有通信数据都使用协商出的密钥进行加密传输。</p><p><strong>使用场景</strong></p><p>HTTPS（安全网站访问）</p><p>邮件加密（SMTP、IMAP、POP3）</p><p>VPN 连接</p><p>安全的消息传输（如 WhatsApp、Telegram）</p><h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p>FTP（File Transfer Protocol，文件传输协议）是一种用于在网络上传输文件的协议。</p><p>FTP 允许用户从一台计算机（客户端）向另一台计算机（服务器）<strong>上传或下载文件</strong>。</p><p>流程：</p><ul><li>客户端连接到服务器的 <strong>21</strong> 端口（默认的控制连接端口）。</li><li>服务器返回状态码 220，表示服务已就绪。</li><li>客户端发送用户名（USER 命令），服务器返回 331，表示需要密码。</li><li>客户端发送密码（PASS 命令），服务器返回 230，表示登录成功。</li></ul><p>文件传输分为两个模式</p><p>一个是主动模式:服务器主动连接到客户端的数据端口。</p><ul><li>客户端发送 PORT 命令，告知服务器自己的 IP 地址和数据端口。</li><li>服务器连接到客户端的数据端口，开始传输文件。</li></ul><p>另一个是被动模式：客户端连接到服务器的数据端口。</p><ul><li>客户端发送 <strong>PASV</strong> 命令，请求进入被动模式。</li><li>服务器返回自己的 IP 地址和数据端口。</li><li>客户端连接到服务器的数据端口，开始传输文件。</li></ul><p>ftp自己本身是并不安全的，因为传输过程中使用明文传输用户名和密码等，所以出现了替代品</p><ul><li><strong>SFTP</strong>：基于 SSH 的文件传输协议，加密传输数据。</li><li><strong>FTPS</strong>：基于 SSL/TLS 的 FTP，加密传输数据。</li></ul><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>SSH（Secure Shell，安全外壳协议）是一种用于安全远程登录和其他网络服务的加密协议。</p><p>SSH 通过加密通信来保护数据在传输过程中的安全性，广泛应用于系统管理、文件传输和远程命令执行等场景。</p><p>流程：</p><ul><li>客户端连接到服务器的 <strong>22</strong> 端口（默认的 SSH 端口）。</li><li>服务器发送自己的公钥给客户端。</li><li>客户端验证服务器公钥（通常通过已知的主机密钥指纹）。</li><li>客户端和服务器协商加密算法（如 AES、RSA 等）。</li><li>客户端生成一个会话密钥，用服务器的公钥加密后发送给服务器。</li><li>双方使用会话密钥加密后续通信。</li></ul><h2 id="smtp"><a href="#smtp" class="headerlink" title="smtp"></a>smtp</h2><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一种用于发送电子邮件的网络协议。</p><p>SMTP 是互联网上电子邮件传输的核心协议之一，负责将邮件从发送方传递到接收方的邮件服务器。</p><p><strong>发送邮件和传递邮件</strong></p><p>连接建立：</p><ul><li>户端连接到服务器的 25 端口（默认的 SMTP 端口）。</li><li>服务器返回状态码 220，表示服务已就绪。</li><li>客户端发送 HELO 或 EHLO 命令，告知服务器自己的域名。</li><li>服务器返回状态码 250，表示命令成功。</li></ul><p>smtp本身也是不安全的，因为使用过程中也是使用明文传输。可以使用下面的来代替</p><ul><li><strong>STARTTLS</strong>：将明文连接升级为加密连接，使用 TLS/SSL 加密数据。</li><li><strong>SMTP AUTH</strong>：通过身份验证机制（如 PLAIN、LOGIN）验证用户身份。</li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改</p><p>数字签名校验数据的完整性</p><p>数字签名有两种功效：</p><ul><li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li><li>数字签名能确定消息的完整性，证明数据是否未被篡改过。</li></ul><p>将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者</p><p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。</p><p>如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p><h2 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h2><p>Session 是<strong>基于Cookie 实现</strong>的另一种记录服务端和客户端会话状态的机制。</p><p>Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。</p><p>Session的认证过程：</p><ol><li>客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID</li><li>客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名</li><li>当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的 Session，如果有对应的 Session 则通过，继续执行请求，否则就中断</li></ol><p><strong>Cookie和Session的区别</strong></p><ol><li>安全性，因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态</li><li>适用性，Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据</li><li>有效期，Cookie 可以设置任意时间有效，而 Session 一般失效时间短</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/23/net2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English二月篇</title>
      <link>https://blog.tokenlen.top/2025/02/01/en6/</link>
      <guid>https://blog.tokenlen.top/2025/02/01/en6/</guid>
      <pubDate>Fri, 31 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;每日一话-单词遗忘表2-1&quot;&gt;&lt;a href=&quot;#每日一话-单词遗忘表2-1&quot; class=&quot;headerlink&quot; title=&quot;每日一话+单词遗忘表2.1&quot;&gt;&lt;/a&gt;每日一话+单词遗忘表2.1&lt;/h1&gt;&lt;p&gt;The more you experience</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="每日一话-单词遗忘表2-1"><a href="#每日一话-单词遗忘表2-1" class="headerlink" title="每日一话+单词遗忘表2.1"></a>每日一话+单词遗忘表2.1</h1><p>The more you experience and appreciate the goodness of life, the more there is to be lived.</p><ul><li>pearl 珍珠</li><li>peasant 农民</li><li>peculiar 特殊的</li><li>pedestrian 步行者</li><li>peer 凝视</li><li>penalty 处罚</li><li>penetrate 刺入</li><li>perhaps 也许</li><li>peril 危险</li><li>persevere 坚持</li><li>persist 持续</li><li>perspective 远景</li><li>persuade 说服</li></ul><h1 id="每日一话-单词遗忘表2-2"><a href="#每日一话-单词遗忘表2-2" class="headerlink" title="每日一话+单词遗忘表2.2"></a>每日一话+单词遗忘表2.2</h1><p>Your generation has come of age facing a challenge like no other generation before you.</p><ul><li>pessimism 悲观的</li><li>petroleum 石油</li><li>phase 相位</li><li>phrase 成语</li><li>pile 堆</li><li>pillar 柱子</li><li>pinch 捏</li></ul><h1 id="每日一话-单词遗忘表2-3"><a href="#每日一话-单词遗忘表2-3" class="headerlink" title="每日一话+单词遗忘表2.3"></a>每日一话+单词遗忘表2.3</h1><p>Don’t try to win a friend by presenting gifts.</p><ul><li>pipe 烟斗</li><li>pistol 手枪</li><li><strong>plague</strong> 瘟疫</li><li>implicit 暗示的</li><li><strong>platform</strong> 月台</li><li>pledge 发誓</li><li>inflate 使充气</li><li>plough 耕</li><li>plunge 投入</li><li><strong>plural</strong> 复数的</li></ul><h1 id="每日一话-单词遗忘表2-4"><a href="#每日一话-单词遗忘表2-4" class="headerlink" title="每日一话+单词遗忘表2.4"></a>每日一话+单词遗忘表2.4</h1><p>Sometimes I have thought it would be an excellent rule to live each day as if we should die tomorrow.</p><ul><li>politics 政治学</li><li>pond 池塘</li><li>pool 水池</li><li>portion 部分</li><li>pause 暂停</li></ul><h1 id="每日一话-单词遗忘表2-5"><a href="#每日一话-单词遗忘表2-5" class="headerlink" title="每日一话+单词遗忘表2.5"></a>每日一话+单词遗忘表2.5</h1><p>The best preparation for good work tomorrow is to do good work today.</p><ul><li>postpone 使。。延期</li><li>pour 倾泻</li><li>poverty 贫困</li><li>powder 火药</li><li>practical 明智的</li><li>praise 称赞</li><li><strong>preach</strong> 说教</li><li>precaution 预防</li><li>precise 精确的</li><li><strong>preface</strong> 前言</li><li>prejudice 成见</li><li>preliminar 初步的</li><li>premier 第一的</li><li>prescribe 开药方</li></ul><h1 id="每日一话-单词遗忘表2-6"><a href="#每日一话-单词遗忘表2-6" class="headerlink" title="每日一话+单词遗忘表2.6"></a>每日一话+单词遗忘表2.6</h1><p>As selfishness and complaint cloud the mind, so love with its joy clears and sharpens the vision.</p><ul><li>preserve 保护</li><li><strong>prevail</strong> 盛行</li><li>priest 牧师</li><li>prince 王子</li><li>principal 主要的</li><li>principle 原则</li><li>prior 先前的</li><li>privilege 特权</li><li>conceal 隐藏</li></ul><h1 id="每日一话-单词遗忘表2-7"><a href="#每日一话-单词遗忘表2-7" class="headerlink" title="每日一话+单词遗忘表2.7"></a>每日一话+单词遗忘表2.7</h1><p>If you don’t design your own life plan, chances are you’ll fall into someone else’s. And guess what they might have planned for you? Not much.</p><ul><li>principal 本金</li><li>pirate 海盗</li><li>contempt 轻视</li><li>procession 队列</li><li>procliam 宣称</li><li>contaminate 污染</li><li>proficient 精通的</li><li>profound 深度的</li><li>prominemt 显著的</li><li><strong>prompt</strong> 敏捷的</li><li>proof 证明</li><li>proportion 部分</li><li>prose 散文</li><li>protein 蛋白质</li><li>constitution 宪法</li></ul><h1 id="每日一话-单词遗忘表2-8"><a href="#每日一话-单词遗忘表2-8" class="headerlink" title="每日一话+单词遗忘表2.8"></a>每日一话+单词遗忘表2.8</h1><p>Keep your friends close, but your enemies closer.</p><ul><li>protest 抗议</li><li>proverb 谚语</li><li>provoke 激怒</li><li>pulse 脉搏</li><li>punch 按键</li><li>purchase 购买</li><li>pure 纯的</li><li>purse 钱包</li><li>pursue 追求</li></ul><h1 id="每日一话-单词遗忘表2-11"><a href="#每日一话-单词遗忘表2-11" class="headerlink" title="每日一话+单词遗忘表2.11"></a>每日一话+单词遗忘表2.11</h1><p>We delight in the beauty of the butterfly, but rarely admit the changes it has gone through to achieve that beauty.</p><ul><li>quarrel 吵架</li><li>quiz 考察</li><li><strong>quota</strong> 配额</li><li>quote 引述</li><li>rack 行李架</li><li><strong>radical</strong> 根本的</li><li>rag 破布</li><li>raid 袭击</li></ul><h1 id="每日一话-单词遗忘表2-12"><a href="#每日一话-单词遗忘表2-12" class="headerlink" title="每日一话+单词遗忘表2.12"></a>每日一话+单词遗忘表2.12</h1><p>I look for her in vain. When all at once I turn my head, I find her there where lantern light is dimly shed.</p><ul><li>rapid 快速的</li><li>realistic 现实的</li><li>realm 领域</li><li><strong>reap</strong> 收割</li><li>rear 后面的</li><li>rebel 造反</li><li>recite 背诵</li><li>reckon 猜想</li></ul><h1 id="每日一话-单词遗忘表2-13"><a href="#每日一话-单词遗忘表2-13" class="headerlink" title="每日一话+单词遗忘表2.13"></a>每日一话+单词遗忘表2.13</h1><p>It never will rain roses. When we want to have more roses we must plant trees.</p><ul><li>recognize 承认</li><li><strong>recreation</strong> 娱乐</li><li>recruit 招聘</li><li><strong>refine</strong> 精炼</li><li>refrain 制止</li><li>reform 改革</li><li>counterpart 地位相当的</li><li>rebel 反抗分子</li><li>intangible 难以琢磨的</li><li>reckon 猜想</li><li>proficient 精炼的</li><li>relative 相对的</li><li>instalment 一部分</li></ul><h1 id="每日一话-单词遗忘表2-14"><a href="#每日一话-单词遗忘表2-14" class="headerlink" title="每日一话+单词遗忘表2.14"></a>每日一话+单词遗忘表2.14</h1><p>The love that lasts the longest is the love that is never returned.</p><ul><li>relay 转播</li><li>relevant 有关的</li><li>religion 宗教</li><li>reluctant 不情愿的</li><li>remedy 药品</li><li>render 提出</li><li>renovate 革新</li></ul><h1 id="每日一话-单词遗忘表2-15"><a href="#每日一话-单词遗忘表2-15" class="headerlink" title="每日一话+单词遗忘表2.15"></a>每日一话+单词遗忘表2.15</h1><p>The worst tragedy for a poet is to be admired through being misunderstood.</p><ul><li>rescue 营救</li><li>resent 怨恨</li><li>respective 各自的</li><li>retail 零售</li><li>reunite 使..结合</li><li>loophole 弹孔</li></ul><h1 id="每日一话-单词遗忘表2-16"><a href="#每日一话-单词遗忘表2-16" class="headerlink" title="每日一话+单词遗忘表2.16"></a>每日一话+单词遗忘表2.16</h1><p>We soon believe what we desire.</p><ul><li>reveal 揭示</li><li>revenue 税收</li><li>revise 修订</li><li>rhythm 节奏</li><li>riddle 解密</li><li>ridicule 嘲笑</li><li>rifle 步枪</li><li>riot 暴乱</li><li>rival 竞争者</li><li>roar 吼叫</li><li>procliam 宣布占领</li></ul><h1 id="每日一话-单词遗忘表2-17"><a href="#每日一话-单词遗忘表2-17" class="headerlink" title="每日一话+单词遗忘表2.17"></a>每日一话+单词遗忘表2.17</h1><p>Gather sweet blossoms while you may; And not the twig devoid of flowers!</p><ul><li>rob 抢劫</li><li>rod 棒</li><li>rouse 醒来</li><li>route 路线</li><li>rubber 橡胶</li><li>ruin 毁灭</li><li>rumor 谣言</li></ul><h1 id="每日一话-单词遗忘表2-18"><a href="#每日一话-单词遗忘表2-18" class="headerlink" title="每日一话+单词遗忘表2.18"></a>每日一话+单词遗忘表2.18</h1><p>I am no bird; and no net ensnares me: I am a free human being with an independent will.</p><ul><li>sacrifice 牺牲</li><li>saint 圣徒</li><li>sausage 香肠</li><li>scandal 传闻</li></ul><h1 id="每日一话-单词遗忘表2-19"><a href="#每日一话-单词遗忘表2-19" class="headerlink" title="每日一话+单词遗忘表2.19"></a>每日一话+单词遗忘表2.19</h1><p>I cannot teach anybody anything, I can only make them think</p><ul><li>scarce 缺少</li><li>scatter 分散的</li><li>scheme 计划</li><li>scissors 剪刀</li><li>scold 责骂</li><li>scount 侦察机</li><li>scratch 抓痕</li><li>screw 旋</li></ul><h1 id="每日一话-单词遗忘表2-20"><a href="#每日一话-单词遗忘表2-20" class="headerlink" title="每日一话+单词遗忘表2.20"></a>每日一话+单词遗忘表2.20</h1><p>Tenderness and kindness are not signs of weakness and despair, but manifestations of strength and resolution.</p><ul><li>sector 部门</li><li>secure 安全</li><li>seminar 讨论会</li><li>sentence 宣判</li><li>separate 分局</li><li>servant 仆人</li><li>naughty 顽皮的</li></ul><h1 id="每日一话-单词遗忘表2-21"><a href="#每日一话-单词遗忘表2-21" class="headerlink" title="每日一话+单词遗忘表2.21"></a>每日一话+单词遗忘表2.21</h1><p>Morality is not really the doctrine of how to make ourselves happy but of how we are to be worthy of happiness.</p><ul><li>sew 缝上</li><li>sharp 急促的</li><li>shave 剃</li><li>shed 棚子</li><li>sheeer 陡峭的</li><li>shelter 避难所</li></ul><h1 id="每日一话-单词遗忘表2-22"><a href="#每日一话-单词遗忘表2-22" class="headerlink" title="每日一话+单词遗忘表2.22"></a>每日一话+单词遗忘表2.22</h1><p>The best way to find out if you can trust somebody is to trust them.</p><ul><li>shiver 颤抖</li><li>shrimp 虾</li><li>shrug 耸肩</li><li>siege 围攻</li></ul><h1 id="每日一话-单词遗忘表2-23"><a href="#每日一话-单词遗忘表2-23" class="headerlink" title="每日一话+单词遗忘表2.23"></a>每日一话+单词遗忘表2.23</h1><p>Sometimes you have to travel a long way to find what is near.</p><ul><li>script 轨迹</li><li>silk 蚕丝</li><li>sin 过失</li><li>sip 抿</li><li>situation 形式</li><li>skate 滑冰</li><li>skeleton 骨架</li></ul><h1 id="每日一话-单词遗忘表2-24"><a href="#每日一话-单词遗忘表2-24" class="headerlink" title="每日一话+单词遗忘表2.24"></a>每日一话+单词遗忘表2.24</h1><p>The pain of parting is nothing to the joy of meeting again.</p><ul><li>sketch 素描</li><li>skyscraper 摩天大楼</li><li>slap 拍击</li><li>sleeve 袖子</li><li>slender 苗条的</li><li>slide 滑动</li><li>slim 苗条的</li><li>slogan 标语</li><li>smash 打碎</li></ul><h1 id="每日一话-单词遗忘表2-25"><a href="#每日一话-单词遗忘表2-25" class="headerlink" title="每日一话+单词遗忘表2.25"></a>每日一话+单词遗忘表2.25</h1><p>A fool thinks he is clever, the wise man knows himself to be a fool.</p><ul><li>soar 高飞</li><li>soil 土壤</li><li>solemn 庄严的</li><li>sophisticated 老练的</li><li>sorrow 悲伤的</li><li>spacecraft 宇宙飞船</li><li>spade 铁锹</li><li>spare 备用的</li><li>sparkle 发火花</li></ul><h1 id="每日一话-单词遗忘表2-26"><a href="#每日一话-单词遗忘表2-26" class="headerlink" title="每日一话+单词遗忘表2.26"></a>每日一话+单词遗忘表2.26</h1><p>A man’s reading program should be as carefully planned as his diet, for that too is food, without which he cannot grow mentally.</p><p>今天四级出分了，成功的没过。哎下次再考吧。</p><ul><li>species 物种</li><li>specific 特殊的</li><li>specify 指定</li><li>speculate 思索</li><li>sphere 范围</li><li>spill 溢出</li><li>spite 恶意</li><li>splash 溅</li><li>spoil 溺爱</li><li>spot 斑点</li></ul><h1 id="每日一话-单词遗忘表2-27"><a href="#每日一话-单词遗忘表2-27" class="headerlink" title="每日一话+单词遗忘表2.27"></a>每日一话+单词遗忘表2.27</h1><p>A man can fail many times, but he isn’t a failure until he begins to blame somebody else.</p><ul><li><strong>spray</strong> 喷雾</li><li>spur 马刺</li><li>spy 侦察</li><li>squeeze 挤压</li><li>stable 马厩</li><li>stadium 体育场</li><li>stain 玷污</li><li>staple 订书钉</li><li>startle 吓一跳</li></ul><h1 id="每日一话-单词遗忘表2-28"><a href="#每日一话-单词遗忘表2-28" class="headerlink" title="每日一话+单词遗忘表2.28"></a>每日一话+单词遗忘表2.28</h1><p>Many people waste a whole life waiting for the chance to meet their desire.</p><ul><li>stem 茎</li><li>stimulate 刺激</li><li>sting 刺痛</li><li>stir 激起</li><li>stomach 胃</li><li>storey 楼层</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/01/en6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>毛泽东选集阅读体会&amp;杂谈</title>
      <link>https://blog.tokenlen.top/2025/01/26/mao1/</link>
      <guid>https://blog.tokenlen.top/2025/01/26/mao1/</guid>
      <pubDate>Sat, 25 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;2025-1-26&quot;&gt;&lt;a href=&quot;#2025-1-26&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="2025-1-26"><a href="#2025-1-26" class="headerlink" title="2025.1.26"></a>2025.1.26</h1><p>在革命的过程中，我们要注意谁是我们的朋友。谁是我们的敌人，团结我们能所团结的，打到我们的敌人。</p><p>地主阶级是国际资产主义的附庸，特别是大地主阶级和大买办阶级，他们是完全靠着国际资本主义，来压榨底层的百姓的。小地主阶级和小买办阶级是可以团结的，给与他们扩大的实力，他们可以为革命所用。要团结一切可以团结的力量。</p><p>中产阶级代表跟小地主阶级类似，他们是矛盾的，他们是人数较少的。可以对他们进行团结，扩大他们的生产，扩大他们的力量，在革命的大旗下进行扩大化。进行革命化的特色改造。</p><p>小资产阶级或者说是无产阶级是我们革命的主力军，他们的力量是强大的，他们的力量是可以翻天覆地的。他们有很少或者没有生产资料，他们处于社会的最底层，其中有很大一部分人有很强的向上的力量，很强的革命的力量。我们要从他们之中去发展力量，积蓄力量，给大地主阶级和大买办阶级或者说是大官僚阶级沉重的打击。</p><h1 id="2025-1-27"><a href="#2025-1-27" class="headerlink" title="2025.1.27"></a>2025.1.27</h1><p>组织运动，农民是我国力量最大的，人数最多的阶层。这里的农民不单单是指农村户口的农民，而是指的是出生于农村，从农村长大。祖祖辈辈和土地和农村相关联的人。他们是任劳任怨的，不到迫不得已的的时候，是不会反抗的。他们自发的进行革命力量的组织的力量是弱小的，是没有把力量集中到一起的。</p><p>需要的革命的组织进行正确的领导，这就是农会。农会是从农民中来，到农民中去的。农会中的领导者是农民选举出来的，是农民阶级的代言人。他们领导农民的革命方向，代表着广大农民的利益。</p><h1 id="2025-1-29"><a href="#2025-1-29" class="headerlink" title="2025.1.29"></a>2025.1.29</h1><p>资本主义，或者说是资产阶级。他们在很久之前是社会的进步的力量，引导人们从封建主义到了资本主义，这是生产力发展的必然结果。但是资本是逐利的，资本是冒险的。他们很多会不思进取，开源节流，在经济形式不好的时候</p><p>，他们第一想到的就是节流，即降低工人的待遇。降低工人的工资，压榨工人。将工人的剩余价值剥削的更多。工人因为承担着养家糊口的责任，他们不能丢失这个工作，失去了这个工作他们无法生存。只能继续承担着资本的剥削。</p><p>资本在剥削之中会合并资本，大资本跟更大的资本进行结合。阶级实现了固化，普通人向上发展的道路被堵塞了，而资本或者说是特权阶级，一出生就拥有着百分之九十五的人一生都无法获得的生产资料。</p><p>在资本逐利的过程中，他们为了扩大生产，提高自己的影响力。他们会和官员也就是权力勾结起来，形成官商勾结体。官商勾结自古由来已久，大商人或者说是资本有钱，而官员们有权。官商勾结起来，就形成了一个即有权又又钱的利益集团。俗话说有钱有权可以做到世界上的一切事情，如果做不到就是钱还不够多，权还不够大。</p><h1 id="2025-1-31"><a href="#2025-1-31" class="headerlink" title="2025.1.31"></a>2025.1.31</h1><p>特权阶级也就是说的官僚阶级和资本他们一旦联合起来，形成一个利益集团。他们只会看着自己眼前的利益，不会把一分一毫的利益分享给其他的平民。利益集团会侵占国家利益，他们不会以国家利益为基础，将整个国家绑在他们的战车之上。整个国家都会变成他们的私有财产。然后在权力和钱财的追逐之下，政府其实就代表这些利益集团的集合利益。</p><h1 id="2025-2-6"><a href="#2025-2-6" class="headerlink" title="2025.2.6"></a>2025.2.6</h1><p>我们不能忘记民族矛盾，虽然民族矛盾可以算是阶级矛盾在具体方面的一种体现，按照托洛斯基的理念，或者说激进的马克思主义者的观念来说，国家和民族最终都要消亡的。但是这毕竟是千年可能都完不成的目标，可以说在近一百年这是不可能的。我们是中华民族，我们和日本人，是有着血海深仇的。这是绝对不可以忘掉了，一个甲子之前我们刚刚才把日本人赶出了中国。我们现在和日本人的矛盾是不可以忘却的，南京的三十万百姓惨案不可忘掉。不仅仅是日本人，有一个国家或者说是一个民族，对我们的伤害不亚于日本人，那就是俄罗斯。在特殊的历史条件下，大鹅是我们的朋友。但是我们和大鹅的血海深仇是不可以忘的。二战后期借着打击关东军的民意，侵略我国东北，我国东北人民遭受了巨大的灾难，机械等大型产业被掠夺，非常非常多的资源也被掠夺，更不要说侵占了我们那么多的土地，把我们的人民屠杀了许多。这个仇是不可以忘的！</p><h1 id="2025-2-12"><a href="#2025-2-12" class="headerlink" title="2025.2.12"></a>2025.2.12</h1><p>前前后后多少事，还得是将军说的对啊。文化工作者一定要有文化！</p><p>最近刘诗诗主演的电视剧《掌心》正在热播中，这个电视剧拍的怎么样我不敢说，但是以武周时期为蓝本的电视剧，派王子出去和亲实在是太不符合历史了，再说我们着一般说是皇子，一般不说王子。当时武则天他派的是他的一个侄子。根本称不上皇子。而电视剧虽然是里面那个也不是李唐的皇子，但他说的的确是王子和亲。编剧在改编的时候，能不能动点脑子，给抄错了。</p><p>所以说文化工作者要有文化，这句话果然是有大道理的啊。</p><h1 id="2025-2-13"><a href="#2025-2-13" class="headerlink" title="2025.2.13"></a>2025.2.13</h1><p>明天就是情人节，但是这个情人节值得是国外传过来的情人节，而我们中国自己的情人节是在农历的七月七，也就是我们常说的七夕。我们长久以来过的是这个情人节。传说这是牛郎织女相会的日子,鹊桥会出现，然后牛郎织女就可以通过鹊桥来相会。然后人们总是会在这个时候举办灯会，女子男子可以通过看灯会来寻找自己的另一半。但是如今，七夕大家都不过了，反而大家都去过国外传过来的情人节，我们自己的文化传统都丢失了。这就是文化入侵！这就是我们为什么要提高我们的文化自信力，我们的上千年的文化是比他们这些国外的蛮人只有近几百年的文化要强大的，我们要对我们的文化要有自信！</p><h1 id="2025-2-14"><a href="#2025-2-14" class="headerlink" title="2025.2.14"></a>2025.2.14</h1><p>四十年来家国，三千里地山河。凤阁龙楼连霄汉，玉树琼枝作烟萝，几曾识干戈。</p><p>一旦归为臣虏，沈腰潘鬓消磨。最是仓皇辞庙日，教坊犹奏别离歌，垂泪对宫娥。</p><p>最近又学了什么诗词啊~</p><p>不禁潸然泪下，一生转战三千里，流落异乡倍思亲。</p><h1 id="2025-2-15"><a href="#2025-2-15" class="headerlink" title="2025.2.15"></a>2025.2.15</h1><p>不管用什么方法，最终的目的都是社会主义。一个人无论今天穿男装还是女装，并不会影响实际性别。因为性别是由染色体决定的。许多修正主义者就是在这里歪曲了马克思主义道路。宣称的正大光明，实际就是在找借口，篡改和歪曲马克思主义的原则性问题。马克思主义当然需要探索和发展，但绝不是背叛无产阶级革命的探索与发展。如果是为了剥削者而进行发展，那这究竟是马克思主义的探索还是资本主义的探索呢？</p><p>在历史的长河之中，探索道路一定要选择对方向。无论你走的多远，方向错了，那走再多也白费。</p><p>世界上没有不透风的墙，无论在多么封闭的地方，终究最后消息会传出去。可能消息传着传着可能就变了味道。与其被人调侃，不如一开始就处在开放的时候。</p><h1 id="2025-2-16"><a href="#2025-2-16" class="headerlink" title="2025.2.16"></a>2025.2.16</h1><p>观史可以明智，世界上是没有新鲜事的。人类的所有，其实都是一个轮回。所有的事情都可以在历史上找到类似的事情，和与其对应的后果和解决方法。</p><p>所以历史是必须要看的，而且是必须要认真看的。</p><p>韩信自大自以为是汉朝离不开他，最后终究还是落个被杀的下场。哎</p><h1 id="2025-2-18"><a href="#2025-2-18" class="headerlink" title="2025.2.18"></a>2025.2.18</h1><p>普天之下，莫非王土。率土之滨，莫非王臣。我们无论如何都不能放弃自己科技的发展，虽然国外的可能更加好用，更加便宜。但我们自身必须要有可以研究使用的能力。但是，研究研发不是一味的标榜自己是国产。国产不代表这是一个消费的标签。不能用国货的名义来消费消费者。这样可能一段时间内是比较有效的，但是长久来看，这是非常非常不利的。</p><h1 id="2025-2-19"><a href="#2025-2-19" class="headerlink" title="2025.2.19"></a>2025.2.19</h1><p>天行健，君子以自强不息。我们需要在我们的传统文化中，汲取优秀美好的力量，我们上下五千年的历史是悠久的，可以说是文化是没有断绝过的。是非常有利的，我们古人上下总结的文化，是可以实实在运用到我们的生活和实践中的。这就是中国文化的魅力，这就是历史长的好处。我们应该不能放弃我们的文化，不能被外来文化完全入侵了。无论是好的还是坏的，他们都不能改变我们中国的文化！</p><h1 id="2025-2-22"><a href="#2025-2-22" class="headerlink" title="2025.2.22"></a>2025.2.22</h1><p>至此天下唯有大秦，我们中华自打秦朝以来，就有着必须大一统的心念存在我们心中。现在我们的领土并不完整，我们的许多自古以来的土地被他人占据，这些土地是我们必须要拿回来的，要不然我们就算不上大一统。比如虎踞夷州岛，比如我们的藏南地区，比如外西北，外东北，我们的第一大岛库页岛。比如我们的三宣六慰，我们的旧港都是我们自古以来的领土。这些是必须一定要收回的！</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/Marxists/">Marxists</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%AF%9B%E9%80%89/">毛选</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/26/mao1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络-七层体系结构</title>
      <link>https://blog.tokenlen.top/2025/01/13/net1/</link>
      <guid>https://blog.tokenlen.top/2025/01/13/net1/</guid>
      <pubDate>Sun, 12 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础引入&quot;&gt;&lt;a href=&quot;#基础引入&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础引入"><a href="#基础引入" class="headerlink" title="基础引入"></a>基础引入</h1><p>两个计算机设备想要通信，可以用一根线连接起来，两台设备使用电信号传播数据</p><p>如果都是用一根线连接两台设备的话，所需要的线数C等于</p><script type="math/tex; mode=display">C=(n-1)n/2</script><p>但这样不太理想</p><p>所以我们可以使用一个hub就是一个集线器</p><p>比如</p><p>设备1可以通过<strong>hub</strong>然后转发给设备3，但这样的话是群发，不太安全</p><p>而且只能单向的交流，也不太好</p><p>所以使用了<strong>交换机</strong>，使用<strong>mac值</strong>来区分设备</p><p>这个是全球唯一的</p><p>允许两台设备双向交流，也可以两台交换机来交换数据，这叫<strong>桥接网络</strong></p><p>内网这样是可以使用的，但是不能使用很多，因为交换机的存储mac地址的数量是有限的。</p><p><strong>路由器</strong>可以适用于网络的转发</p><p><strong>不同网络连接到路由器的ip叫做默认网关</strong></p><p><strong>ip</strong>只是一个过程使用，最后还是使用<strong>mac地址</strong>来转发数据</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="1-1基本术语"><a href="#1-1基本术语" class="headerlink" title="1.1基本术语"></a>1.1基本术语</h2><p><strong>结点 （node）</strong>：网络中的结点可以是计算机，集线器，交换机或路由器等。</p><p><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</p><p><strong>主机（host）</strong>：连接在因特网上的计算机。</p><p><strong>ISP（Internet Service Provider）</strong>：因特网服务提供者（提供商）。</p><p><img src="https://oss.javaguide.cn/p3-juejin/e77e26123d404d438d0c5943e3c65893~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>IXP（Internet eXchange Point）</strong>：互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。 </p><p><strong>RFC(Request For Comments)</strong>：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</p><p><strong>广域网 WAN（Wide Area Network）</strong>：任务是通过长距离运送主机发送的数据。</p><p><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</p><p><strong>局域网 LAN（Local Area Network）</strong>：学校或企业大多拥有多个互连的局域网。</p><p><img src="https://oss.javaguide.cn/p3-juejin/eb48d21b2e984a63a26250010d7adac4~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>个人区域网 PAN（Personal Area Network）</strong>：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</p><p><strong>分组（packet ）</strong>：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</p><p><strong>存储转发（store and forward ）</strong>：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发 送的输出端口地址，然后将该包发送出去。</p><p><img src="https://oss.javaguide.cn/p3-juejin/addb6b2211444a4da9e0ffc129dd444f~tplv-k3u1fbpfcp-zoom-1.gif" alt=""></p><p><strong>带宽（bandwidth）</strong>：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</p><p><strong>吞吐量（throughput ）</strong>：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。        </p><h2 id="1-2知识点总结"><a href="#1-2知识点总结" class="headerlink" title="1.2知识点总结"></a>1.2知识点总结</h2><p><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></p><p>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</p><p>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据段的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</p><p>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</p><p>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</p><p>这里介绍一下C/S模式和P2P模式：</p><p>C/S 模式是一种计算机网络通信架构，其中通信由客户端（Client）发起，请求服务，服务器（Server）响应并提供服务。</p><p>特点：</p><p><strong>集中管理</strong>：服务器通常拥有强大的计算和存储能力，负责集中管理资源和处理请求。</p><p><strong>固定角色</strong>：客户端负责发送请求，服务器负责响应。角色明确。</p><p><strong>典型应用</strong>：</p><ul><li>Web浏览器和Web服务器（HTTP/HTTPS通信）</li><li>数据库客户端与数据库服务器（如MySQL）</li></ul><p>服务器是里面的重中之重，服务器承担着接发消息和处理消息的功能。如果服务器瘫痪了，这个功能就可以说是完蛋了。</p><p>P2P 模式是一种网络通信架构，其中所有参与者（节点）既是服务的消费者（Client），又是服务的提供者（Server）。</p><p>特点：</p><p><strong>分布式管理</strong>：网络中的每个节点都可以直接通信，无需中央服务器。</p><p><strong>动态角色</strong>：节点既能发送请求，也能响应其他节点的请求。</p><p><strong>典型应用</strong>：</p><ul><li>文件共享系统（如BitTorrent）</li><li>区块链网络（如比特币、以太坊）</li></ul><p>p2p模式可以说是点对点模式，扩展性高，但是不太安全。</p><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>C/S 模式</strong></th><th><strong>P2P 模式</strong></th></tr></thead><tbody><tr><td><strong>架构特点</strong></td><td>集中式架构</td><td>分布式架构</td></tr><tr><td><strong>节点角色</strong></td><td>固定（客户端和服务器）</td><td>动态（节点既是客户端又是服务器）</td></tr><tr><td><strong>适用场景</strong></td><td>Web服务、数据库查询</td><td>文件共享、区块链等分布式服务</td></tr><tr><td><strong>优势</strong></td><td>易管理、高效率</td><td>去中心化、高扩展性</td></tr><tr><td><strong>劣势</strong></td><td>单点故障、扩展性有限</td><td>资源协调和安全性挑战</td></tr></tbody></table></div><p><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></p><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</p><p><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></p><p><img src="https://oss.javaguide.cn/p3-juejin/acec0fa44041449b8088872dcd7c0b3a~tplv-k3u1fbpfcp-zoom-1.gif" alt=""></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="2-1基本术语"><a href="#2-1基本术语" class="headerlink" title="2.1基本术语"></a>2.1基本术语</h2><ol><li><strong>数据（data）</strong>：运送消息的实体。</li><li><strong>信号（signal）</strong>：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li><li><strong>码元（ code）</strong>：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li><li><strong>单工（simplex ）</strong>：只能有一个方向的通信而没有反方向的交互。</li><li><strong>半双工（half duplex ）</strong>：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</li><li><strong>全双工（full duplex）</strong>：通信的双方可以同时发送和接收信息。</li><li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li><li><strong>奈氏准则</strong>：在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li><li><strong>基带信号（baseband signal）</strong>：来自信源的信号。指没有经过调制的数字信号或模拟信号。</li><li><strong>带通（频带）信号（bandpass signal）</strong>：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li><li><strong>调制（modulation ）</strong>：对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li><li><strong>信噪比（signal-to-noise ratio ）</strong>：指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li><li><strong>信道复用（channel multiplexing ）</strong>：指多个用户共享同一个信道。（并不一定是同时）。</li><li><strong>比特率（bit rate ）</strong>：单位时间（每秒）内传送的比特数</li></ol><p><img src="https://oss.javaguide.cn/p3-juejin/5d9bf7b3db324ae7a88fcedcbace45d8~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>波特率（baud rate）</strong>：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</p><p><strong>复用（multiplexing）</strong>：共享信道的方法。</p><p><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong>：非对称数字用户线。</p><p><strong>光纤同轴混合网（HFC 网）</strong>：在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</p><h2 id="2-2知识点总结"><a href="#2-2知识点总结" class="headerlink" title="2.2知识点总结"></a>2.2知识点总结</h2><p> <strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></p><ol><li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li><li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电气或电磁的表现。</strong></li><li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li><li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li><li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li><li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li><li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li><li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li></ol><p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状和尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能的各种可能事件的出现顺序）。</p><p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。   </p><p><strong>常用的信道复用技术</strong></p><ol><li><strong>频分复用(FDM)</strong>：所有用户在同样的时间占用不同的带宽资源。</li><li><strong>时分复用（TDM）</strong>：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li><li><strong>统计时分复用 (Statistic TDM)</strong>：改进的时分复用，能够明显提高信道的利用率。</li><li><strong>码分复用(CDM)</strong>：用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li><strong>波分复用( WDM)</strong>：波分复用就是光的频分复用。</li></ol><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ADSL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="3-1基本术语"><a href="#3-1基本术语" class="headerlink" title="3.1基本术语"></a>3.1基本术语</h2><p><strong>链路（link）</strong>：一个结点到相邻结点的一段物理链路。</p><p><strong>数据链路（data link）</strong>：把实现控制<strong>数据运输的协议</strong>的硬件和软件加到链路上就构成了数据链路。</p><p><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong>：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</p><p><strong>帧（frame）</strong>：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</p><p><strong>MTU（Maximum Transfer Uint ）</strong>：最大传送单元。帧的数据部分的的长度上限。</p><p><strong>误码率 BER（Bit Error Rate ）</strong>：在一段时间内，传输错误的比特占所传输比特总数的比率。</p><p><strong>PPP（Point-to-Point Protocol ）</strong>：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路</p><p><img src="https://oss.javaguide.cn/p3-juejin/6b0310d3103c4149a725a28aaf001899~tplv-k3u1fbpfcp-zoom-1.jpeg" alt=""></p><p><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong>：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。”</p><p><strong>网桥（bridge）</strong>：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</p><p><strong>交换机（switch ）</strong>：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</p><h2 id="3-2重要知识点总结"><a href="#3-2重要知识点总结" class="headerlink" title="3.2重要知识点总结"></a>3.2重要知识点总结</h2><p>链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</p><p>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></p><p><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</p><p><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</p><p>PPPoE 是为宽带上网的主机使用的链路层协议</p><p><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></p><p>计算机与外接局域网通信需要通过<strong>通信适配器</strong>（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</p><p>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</p><p>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上的各站点平等地争用以太网信道</p><p>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</p><p>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</p><hr><h2 id="3-3补充问题"><a href="#3-3补充问题" class="headerlink" title="3.3补充问题"></a>3.3补充问题</h2><p>数据链路层的点对点信道与广播信道的特点</p><ol><li><strong>点对点信道</strong>：<ul><li><strong>特点</strong>：数据在两个设备之间进行直接传输，通常不涉及多设备之间的干扰。信号只在发送端和接收端之间传输。</li><li><strong>协议</strong>：常用协议为<strong>PPP（Point-to-Point Protocol）</strong>。PPP是点对点协议，支持多种网络层协议。它提供了封装数据、认证、压缩以及错误检测功能。</li></ul></li><li><strong>广播信道</strong>：<ul><li><strong>特点</strong>：信号在多个设备间广播，所有连接到该信道的设备都能接收到传输的数据。需要控制如何解决多设备争用信道的问题。</li><li><strong>协议</strong>：常用协议为<strong>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）</strong>。CSMA/CD用于以太网，允许多个设备共享同一信道。它通过侦测信道是否空闲，避免冲突；如果发生冲突，设备会退避一段时间后重试。</li></ul></li></ol><p>数据链路层的三个基本问题</p><ol><li><strong>封装成帧</strong>：<ul><li>数据链路层将网络层传来的数据封装成帧，添加头部和尾部信息，如目标地址、源地址、帧校验序列（FCS）等。</li></ul></li><li><strong>透明传输</strong>：<ul><li>保证数据的传输不会受到链路中可能出现的特殊符号的影响（如数据流中的帧分隔符）。通过位填充等技术确保数据在链路上传输时的完整性和正确性。</li></ul></li><li><strong>差错检测</strong>：<ul><li>数据链路层通过CRC（循环冗余校验）等技术对数据进行差错检测，确保数据传输过程中没有发生错误。如果检测到错误，通常会丢弃该帧并要求重传。</li></ul></li></ol><hr><p>以太网的 MAC 层硬件地址</p><ul><li><strong>MAC地址</strong>（媒体访问控制地址）是网络适配器（如网卡）在局域网中的唯一标识符。它通常是由硬件生产商分配的 48 位地址，表示网络接口设备。MAC地址通常以16进制形式表示，如：<code>00:1A:2B:3C:4D:5E</code>。</li></ul><hr><p>适配器、转发器、集线器、网桥、以太网交换机的作用及适用场</p><ol><li><strong>适配器（网络适配器）</strong>：<ul><li><strong>作用</strong>：网络适配器（如网卡）用于连接计算机与网络，通过物理层传输数据。它提供了与网络进行数据通信的接口。</li></ul></li><li><strong>转发器</strong>：<ul><li><strong>作用</strong>：转发器用于在不同的网络之间进行数据转发，通常用于协议转换或将不同网络技术的设备连接起来。</li></ul></li><li><strong>集线器（Hub）</strong>：<ul><li><strong>作用</strong>：集线器是一个简单的网络设备，能够将信号广播到所有端口，适用于小型网络。但它不具备智能，仅用于物理层的信号传输。</li></ul></li><li><strong>网桥（Bridge）</strong>：<ul><li><strong>作用</strong>：网桥用于连接不同的局域网，能够根据MAC地址转发数据帧，从而分割流量，提高网络效率。网桥工作在数据链路层。</li></ul></li><li><strong>以太网交换机（Switch）</strong>：<ul><li><strong>作用</strong>：以太网交换机可以通过MAC地址来转发数据包，只将数据包发送到目标设备所在的端口，相比集线器，它能有效减少网络冲突并提高网络效率。它工作在数据链路层，具有一定的智能，能动态学习和维护MAC地址表。</li></ul></li></ol><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="4-1基本术语"><a href="#4-1基本术语" class="headerlink" title="4.1基本术语"></a>4.1基本术语</h2><p><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</p><p><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</p><p><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</p><p><strong>ICMP（Internet Control Message Protocol ）</strong>：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</p><p><strong>子网掩码（subnet mask ）</strong>：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p><p><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</p><p><strong>默认路由（default route）</strong>：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</p><p><strong>路由选择算法（Virtual Circuit）</strong>：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</p><h2 id="4-2重要知识总结"><a href="#4-2重要知识总结" class="headerlink" title="4.2重要知识总结"></a>4.2重要知识总结</h2><p><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责</strong></p><p>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</p><p>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</p><p>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</p><p><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组</strong></p><p>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法在 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</p><p>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><p><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</p><p><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></p><p>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="5-1基本术语"><a href="#5-1基本术语" class="headerlink" title="5.1基本术语"></a>5.1基本术语</h2><p><strong>进程（process）</strong>：指计算机中正在运行的程序实体。</p><p><strong>应用进程互相通信</strong>：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</p><p><strong>传输层的复用与分用</strong>：复用指发送方不同的进程都可以通过同一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</p><p><strong>TCP（Transmission Control Protocol）</strong>：传输控制协议。</p><p><strong>UDP（User Datagram Protocol）</strong>：用户数据报协议</p><p><img src="https://oss.javaguide.cn/p3-juejin/b136e69e0b9b426782f77623dcf098bd~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>端口（port）</strong>：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</p><p><strong>停止等待协议（stop-and-wait）</strong>：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</p><p><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p><p><strong>拥塞控制</strong>：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p><h2 id="5-2重要知识点总结"><a href="#5-2重要知识点总结" class="headerlink" title="5.2重要知识点总结"></a>5.2重要知识点总结</h2><p><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></p><p><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></p><p>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供<strong>面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p><p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</p><p>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</p><p>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</p><p><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></p><p><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></p><p><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一地被通信两端的两个端点所确定。</strong></p><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p>TCP 报文段的前 20 个字节是固定的，其后有 40 字节长度的可选字段。如果加入可选字段后首部长度不是 4 的整数倍字节，需要在再在之后用 0 填充。因此，TCP 首部的长度取值为 20+4n 字节,最长为 60 字节。</p><p><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></p><ol><li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li><li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li><li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li><li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li><li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li></ol><h2 id="5-3补充重要知识"><a href="#5-3补充重要知识" class="headerlink" title="5.3补充重要知识"></a>5.3补充重要知识</h2><p>端口和套接字的意义</p><p><strong>端口</strong>：端口是网络协议（如 TCP 或 UDP）中用于标识特定应用进程的数字。端口通常在 0 到 65535 之间，分为不同的范围：</p><p><strong>知名端口（0-1023）</strong>：通常分配给常见的服务（例如 HTTP 用端口 80，HTTPS 用端口 443）。</p><p><strong>注册端口（1024-49151）</strong>：用于不太常见的应用程序和服务。</p><p><strong>动态或私有端口（49152-65535）</strong>：通常由操作系统分配给临时连接。</p><p><strong>套接字</strong>：套接字（Socket）是操作系统提供的一种接口，用于实现进程间的网络通信。它是通过 IP 地址和端口号的组合来唯一标识网络中的一个通信端点。可以通过套接字在应用程序间建立通信，支持 TCP 或 UDP 协议。</p><p>tcp和udp的区别</p><p><strong>TCP（Transmission Control Protocol）</strong>：</p><ul><li><strong>可靠性</strong>：TCP 是面向连接的协议，确保数据按顺序到达，且不会丢失。如果丢包，TCP 会进行重传。</li><li><strong>流量控制</strong>：TCP 使用流量控制（滑动窗口）来避免发送方过快地发送数据，超出了接收方的处理能力。</li><li><strong>拥塞控制</strong>：TCP 会根据网络的负载情况动态调整数据传输速度，以避免网络拥塞。</li><li><strong>连接管理</strong>：需要在通信前建立连接（三次握手），通信结束后需要关闭连接（四次挥手）。</li></ul><p><strong>UDP（User Datagram Protocol）</strong>：</p><ul><li><strong>不可靠性</strong>：UDP 是无连接的协议，不保证数据的可靠到达。数据包可能会丢失、重复或乱序。</li><li><strong>无流量控制和拥塞控制</strong>：UDP 不会进行流量控制或拥塞控制，发送数据时不考虑接收方的处理能力。</li><li><strong>轻量级</strong>：由于其无连接、简单的特性，UDP 的开销较小，适合实时传输等对时延要求高的应用。</li></ul><p>应用场景：</p><p><strong>TCP</strong>：</p><ul><li>适用于需要高可靠性、顺序传输的场景，比如文件传输（FTP）、网页浏览（HTTP/HTTPS）、电子邮件等。</li></ul><p><strong>UDP</strong>：</p><ul><li>适用于对时延要求高、容忍数据丢失的场景，比如视频会议、VoIP（语音通信）、在线游戏等。</li></ul><p>在不可靠网络上实现可靠传输的技术</p><p>在不可靠的网络上实现可靠传输，通常依赖于<strong>自动重传请求（ARQ）协议</strong>和<strong>确认机制</strong>。TCP 就是通过 ARQ 协议来实现数据的可靠传输。</p><ul><li><strong>ARQ 协议</strong>：通过发送方和接收方之间的确认消息（ACK）来确保数据的正确传输。如果接收方未能成功接收到数据，发送方会重新发送数据。</li><li><strong>停止等待协议</strong>：发送方发送一个数据包后，等待接收方的确认消息（ACK）。如果收到确认，则继续发送下一个数据包。如果超时未收到确认，重新发送该数据包。</li><li><strong>滑动窗口协议</strong>：相比停止等待协议，滑动窗口协议允许发送方在等待确认的同时继续发送多个数据包，提高了传输效率。</li></ul><p><strong>tcp的三次握手和三次挥手</strong></p><p><strong>三次握手</strong>：用来建立 TCP 连接，确保双方都准备好进行数据传输：</p><ol><li>客户端发送 SYN 请求，表示希望建立连接。</li><li>服务器回复 SYN-ACK，表示同意建立连接。</li><li>客户端发送 ACK 确认，连接建立成功。</li></ol><p><strong>四次挥手</strong>：用来关闭连接，确保双方都完成数据的传输后才断开连接：</p><ol><li>客户端发送 FIN 请求，表示数据发送完毕，准备关闭连接。</li><li>服务器回复 ACK，确认收到客户端的关闭请求。</li><li>服务器发送 FIN 请求，表示服务器也准备关闭连接。</li><li>客户端回复 ACK，连接正式关闭。</li></ol><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="6-1基本术语"><a href="#6-1基本术语" class="headerlink" title="6.1基本术语"></a>6.1基本术语</h2><p><strong>域名系统（DNS）</strong>：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</p><p>说明白了就是一个解析的过程</p><p><strong>文件传输协议（FTP）</strong>：FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。 “下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p><p><strong>简单文件传输协议（TFTP）</strong>：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</p><p><strong>远程终端协议（TELNET）</strong>：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</p><p><strong>万维网（WWW）</strong>：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“’W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，”环球网”等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</p><p><strong>统一资源定位符（URL）</strong>：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p><strong>超文本传输协议（HTTP）</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</p><p><img src="https://oss.javaguide.cn/p3-juejin/8e3efca026654874bde8be88c96e1783~tplv-k3u1fbpfcp-zoom-1.jpeg" alt=""></p><p><strong>代理服务器（Proxy Server）</strong>：代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</p><p><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</p><p><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</p><p><strong>垂直搜索引擎</strong>：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</p><p><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</p><p><strong>目录索引</strong>：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</p><h2 id="6-2重要知识点总结"><a href="#6-2重要知识点总结" class="headerlink" title="6.2重要知识点总结"></a>6.2重要知识点总结</h2><p>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</p><p>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</p><p>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</p><p>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</p><h2 id="6-3补充重要知识"><a href="#6-3补充重要知识" class="headerlink" title="6.3补充重要知识"></a>6.3补充重要知识</h2><p>常见的http方法</p><p><strong>GET</strong>：请求服务器返回指定的资源（例如网页）。</p><p><strong>POST</strong>：向服务器提交数据（例如表单数据）。</p><p><strong>PUT</strong>：更新资源。</p><p><strong>DELETE</strong>：删除资源。</p><p>http状态码</p><p><strong>2xx</strong>：成功，例如 200 OK 表示请求成功。</p><p><strong>3xx</strong>：重定向，例如 301 Moved Permanently 表示资源已永久移动。</p><p><strong>4xx</strong>：客户端错误，例如 404 Not Found 表示请求的资源不存在。</p><p><strong>5xx</strong>：服务器错误，例如 500 Internal Server Error 表示服务器发生错误。</p><p>https和http的区别</p><p>HTTPS 在 HTTP 上加入了 SSL/TLS 协议，通过加密保护数据的机密性和完整性，防止中间人攻击。</p><p>dns工作流程：</p><p><strong>用户输入网址</strong>：当你在浏览器中输入一个 URL（如 <code>www.example.com</code>）时，浏览器首先需要通过 DNS 查找这个域名对应的 IP 地址。</p><p><strong>查询 DNS 服务器</strong>：</p><ul><li><strong>本地缓存</strong>：浏览器或操作系统首先查看是否缓存了该域名的 IP 地址。如果有缓存且未过期，直接使用缓存的地址。</li><li><strong>递归查询</strong>：如果没有缓存，DNS 客户端向 DNS 服务器发送查询请求。DNS 服务器将从根服务器、顶级域名服务器、权威域名服务器层层查询，直到找到该域名的对应 IP 地址。</li></ul><p><strong>返回 IP 地址</strong>：一旦找到，DNS 服务器将域名对应的 IP 地址返回给浏览器。</p><p><strong>建立连接</strong>：浏览器使用获取到的 IP 地址向目标服务器发起 HTTP 请求，开始页面加载过程。</p><p>访问一个网站的过程：</p><p><strong>输入网址</strong>：用户在浏览器中输入 URL（如 <code>https://www.example.com</code>）。</p><p><strong>DNS 解析</strong>：浏览器通过 DNS 将域名解析为对应的 IP 地址。</p><p><strong>TCP 连接建立</strong>：</p><ul><li>浏览器通过 TCP 协议与服务器建立连接，使用三次握手完成连接建立（对于 HTTPS，还涉及到 TLS 握手以确保数据安全性）。</li></ul><p><strong>发送 HTTP 请求</strong>：浏览器向服务器发送 HTTP 请求，获取网页资源（如 HTML、CSS、JavaScript、图片等）。</p><p><strong>服务器响应</strong>：服务器处理请求后返回 HTTP 响应，包括网页的 HTML 内容和其他相关资源。</p><p><strong>渲染页面</strong>：浏览器接收到响应后，解析并渲染网页，显示给用户。</p><p><strong>关闭连接</strong>：HTTP/1.1 使用持久连接（通过 <code>Connection: keep-alive</code>），但最终浏览器会关闭与服务器的 TCP 连接。 </p><h1 id="其他层次"><a href="#其他层次" class="headerlink" title="其他层次"></a>其他层次</h1><p>除了常见的OSI七层体系结构外，还有tcp/ip四层协议和tcp/ip五层协议</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-7490-20150904094019903-1923900106.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-8668-20150904095142060-1017190812.gif" alt=""></p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/13/net1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown语法</title>
      <link>https://blog.tokenlen.top/2025/01/12/markdown1/</link>
      <guid>https://blog.tokenlen.top/2025/01/12/markdown1/</guid>
      <pubDate>Sat, 11 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;Markdown是啥&quot;&gt;&lt;a href=&quot;#Markdown是啥&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Markdown是啥"><a href="#Markdown是啥" class="headerlink" title="Markdown是啥"></a>Markdown是啥</h1><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>用=和-来标记一级和二级标题</p><p>一级</p><p>二级</p><hr><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><ul><li>可以用&gt; &gt;&gt; &gt;&gt;&gt;或者是- </li><li></li></ul><p>代码快就在每行加上四个空格或者一个制表符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>使用<em>啊</em>  * </p><p>或者是_fff_    -</p><p>·呆呆·  ··使用这个</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>使用-</p><ul><li><p>或者是直接使用符号</p></li></ul><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>直接使用三个—-</p><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>【】（）</p><p>然后图片就是</p><p>！【】（）</p><p>注意是英文的符号好吧</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/Markdown/">Markdown</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/markdown/">markdown</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/12/markdown1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql练习 寒假篇</title>
      <link>https://blog.tokenlen.top/2025/01/10/sqltest3/</link>
      <guid>https://blog.tokenlen.top/2025/01/10/sqltest3/</guid>
      <pubDate>Thu, 09 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础语法回顾&quot;&gt;&lt;a href=&quot;#基础语法回顾&quot; class=&quot;headerlink&quot; title=&quot;基础语法回顾&quot;&gt;&lt;/a&gt;基础语法回顾&lt;/h1&gt;&lt;h2 id=&quot;1-SQL110-插入记录（一）&quot;&gt;&lt;a href=&quot;#1-SQL110-插入记录（一）&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础语法回顾"><a href="#基础语法回顾" class="headerlink" title="基础语法回顾"></a>基础语法回顾</h1><h2 id="1-SQL110-插入记录（一）"><a href="#1-SQL110-插入记录（一）" class="headerlink" title="1.SQL110 插入记录（一）"></a>1.<a href="https://www.nowcoder.com/practice/5d2a42bfaa134479afb9fffd9eee970c?tpId=240&amp;tqId=2221797&amp;ru=/exam/oj&amp;qru=/ta/sql-advanced/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page"><strong>SQL110</strong> <strong>插入记录（一）</strong></a></h2><p>牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下：</p><ul><li>用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分；</li><li>用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。</li></ul><p>试卷作答记录表exam_record中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p><div class="table-container"><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Extra</th><th>Default</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>auto_increment</td><td>(NULL)</td><td>自增ID</td></tr><tr><td>uid</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>用户ID</td></tr><tr><td>exam_id</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>试卷ID</td></tr><tr><td>start_time</td><td>datetime</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>开始时间</td></tr><tr><td>submit_time</td><td>datetime</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>提交时间</td></tr><tr><td>score</td><td>tinyint(4)</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>得分</td></tr></tbody></table></div><p>该题最后会通过执行SELECT uid, exam_id, start_time, submit_time, score FROM exam_record;来对比结果</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into exam_record(uid,exam_id,start_time,submit_time,score) </span><br><span class="line">VALUES (1001,9001,&#x27;2021-09-01 22:11:12&#x27;,&#x27;2021-09-01 23:01:12&#x27; ,90),</span><br><span class="line">(1002,9002,&#x27;2021-09-04 07:01:02&#x27;,null,NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照顺序插入即可，注意一一对应</p><p>2.</p><p>牛客的运营同学想要查看大家在SQL类别中高难度试卷的得分情况。</p><p>请你帮她从exam_record数据表中计算所有用户完成SQL类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p><p>示例数据：examination_info（exam_id试卷ID, tag试卷类别, difficulty试卷难度, duration考试时长, release_time发布时间）</p><div class="table-container"><table><thead><tr><th>id</th><th>exam_id</th><th>tag</th><th>difficulty</th><th>duration</th><th>release_time</th></tr></thead><tbody><tr><td>1</td><td>9001</td><td>SQL</td><td>hard</td><td>60</td><td>2020-01-01 10:00:00</td></tr><tr><td>2</td><td>9002</td><td>算法</td><td>medium</td><td>80</td><td>2020-08-02 10:00:00</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">示例数据：exam_record（uid用户ID, exam_id试卷ID, start_time开始作答时间, submit_time交卷时间, score得分）iduidexam_idstart_timesubmit_time</span><br><span class="line">score1100190012020-01-02 09:01:012020-01-02 09:21:01</span><br><span class="line">8021001</span><br><span class="line">9001</span><br><span class="line">2021-05-02 10:01:012021-05-02 10:30:01</span><br><span class="line">81310019001</span><br><span class="line">2021-06-02 19:01:01</span><br><span class="line">2021-06-02 19:31:01</span><br><span class="line">84</span><br><span class="line">410019002</span><br><span class="line">2021-09-05 19:01:01</span><br><span class="line">2021-09-05 19:40:0189</span><br><span class="line">51001</span><br><span class="line">90012021-09-02 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">61001</span><br><span class="line">9002</span><br><span class="line">2021-09-01 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">710029002</span><br><span class="line">2021-02-02 19:01:01</span><br><span class="line">2021-02-02 19:30:01</span><br><span class="line">87810029001</span><br><span class="line">2021-05-05 18:01:01</span><br><span class="line">2021-05-05 18:59:02909</span><br><span class="line">10039001</span><br><span class="line">2021-09-07 12:01:01</span><br><span class="line">2021-09-07 10:31:01</span><br><span class="line">501010049001</span><br><span class="line">2021-09-06 10:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br></pre></td></tr></table></figure><p>根据输入你的查询结果如下：</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT tag, difficulty,</span><br><span class="line">    ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br><span class="line">FROM exam_record</span><br><span class="line">JOIN examination_info USING(exam_id)</span><br><span class="line">WHERE tag = &#x27;SQL&#x27; AND difficulty = &#x27;hard&#x27;</span><br><span class="line">GROUP BY tag, difficulty;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据sql查询的分别出现的列，然后来根据这些列来写</p><p>主要是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br></pre></td></tr></table></figure><p>这个保留一位小数，计算平均数</p><p>然后使用联合查询</p><p>将examination_info和exam_record连接起来，其主键是exam_id</p><p>然后where条件</p><p>最后可以来个按组排序</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/10/sqltest3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English一月篇</title>
      <link>https://blog.tokenlen.top/2025/01/01/en5/</link>
      <guid>https://blog.tokenlen.top/2025/01/01/en5/</guid>
      <pubDate>Tue, 31 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;每日一话-单词遗忘表1-1&quot;&gt;&lt;a href=&quot;#每日一话-单词遗忘表1-1&quot; class=&quot;headerlink&quot; title=&quot;每日一话+单词遗忘表1.1&quot;&gt;&lt;/a&gt;每日一话+单词遗忘表1.1&lt;/h1&gt;&lt;p&gt;A New Year is like a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="每日一话-单词遗忘表1-1"><a href="#每日一话-单词遗忘表1-1" class="headerlink" title="每日一话+单词遗忘表1.1"></a>每日一话+单词遗忘表1.1</h1><p>A New Year is like a blank book, and the pen is in your hands. Go write yourself a beautiful story.</p><ul><li>masterpiece 杰作</li><li>mate 匹配</li><li>mature 成年人的</li><li>meantime 其间</li><li>measure 措施</li><li>mechanic 技工</li><li>medal 奖章</li></ul><h1 id="每日一话-单词遗忘表1-2"><a href="#每日一话-单词遗忘表1-2" class="headerlink" title="每日一话+单词遗忘表1.2"></a>每日一话+单词遗忘表1.2</h1><p>There is more day to dawn. The sun is but a morning star.</p><ul><li>medicine 药</li><li>melon 瓜</li><li>melt 融化</li><li>memoorandum 信函</li><li>memorial 纪念物</li><li>merchant 商人</li><li>mercy 仁慈</li><li>mere 仅仅</li><li>merit 优点</li><li>microscope 显微镜</li><li>microwave 微波</li><li>marsh 沼泽</li></ul><h1 id="每日一话-单词遗忘表1-3"><a href="#每日一话-单词遗忘表1-3" class="headerlink" title="每日一话+单词遗忘表1.3"></a>每日一话+单词遗忘表1.3</h1><p>Not everything that is faced can be changed, but nothing can be changed until it is faced.</p><ul><li>asset 资产</li><li>migrate 移动</li><li>mild 温和的</li><li>military 军事的</li><li>mill 磨坊</li><li>minor 较小的</li><li>minus 减去</li><li>miracle 奇迹</li><li>miserable 悲惨的</li><li>mist 薄雾</li><li></li></ul><h1 id="每日一话-单词遗忘表1-8"><a href="#每日一话-单词遗忘表1-8" class="headerlink" title="每日一话+单词遗忘表1.8"></a>每日一话+单词遗忘表1.8</h1><p>They always say time changes things, but you actually have to change them yourself.</p><ul><li>mistress 情妇</li><li>misunderstand 误解</li><li>moderate 适当的</li><li>modify 修改</li><li>moist 潮湿的</li><li>monument 纪念碑</li><li>mop 擦干</li><li>mortgage 抵押</li></ul><h1 id="每日一话-单词遗忘表1-10"><a href="#每日一话-单词遗忘表1-10" class="headerlink" title="每日一话+单词遗忘表1.10"></a>每日一话+单词遗忘表1.10</h1><p>Curious things, habits. People themselves never knew they had them.</p><ul><li>motel 汽车旅馆</li><li>motion 动作</li><li>mud 泥浆</li><li>mug 脸</li><li>mule 骡子</li><li>municipal 市政的</li><li>murder 谋杀</li><li>muscle 肌肉</li><li>mushroom 蘑菇</li><li>exterior 外部的</li></ul><h1 id="每日一话-单词遗忘表1-11"><a href="#每日一话-单词遗忘表1-11" class="headerlink" title="每日一话+单词遗忘表1.11"></a>每日一话+单词遗忘表1.11</h1><p>While the blanket is short, learn how to bend.</p><ul><li>nyth 神话</li><li>nail 钉子</li><li>naked 裸体的</li><li>namely 即是</li><li>nap 小睡</li><li>napkin 纸巾</li><li><strong>narrate</strong> 叙述</li><li>nasty 下流的</li><li>naughty 调皮的</li><li>navy 海军</li><li>neat 整洁的</li><li>negate 否定</li><li>neglect 疏忽</li></ul><h1 id="每日一话-单词遗忘表1-13"><a href="#每日一话-单词遗忘表1-13" class="headerlink" title="每日一话+单词遗忘表1.13"></a>每日一话+单词遗忘表1.13</h1><p>The world is little, people are little, human life is little. There is only one big thing – desire.</p><ul><li>nephew 侄子</li><li>nevertheless 仍然</li><li>niece 外甥女</li><li>nonsense 废话</li></ul><h1 id="每日一话-单词遗忘表1-25"><a href="#每日一话-单词遗忘表1-25" class="headerlink" title="每日一话+单词遗忘表1.25"></a>每日一话+单词遗忘表1.25</h1><p>Habit is habit, and not to be flung out of the window by any man, but coaxed downstairs a step a time.</p><ul><li>norm 规范</li><li>massage 按摩</li><li><strong>nourish</strong> 滋养</li><li>nude 裸体的</li><li>nuisance 讨厌的东西</li><li>numerous 许多的</li><li>nurse 看护</li><li>nursery 托儿所</li><li>nut 坚果</li><li>negate 否定的</li></ul><h1 id="每日一话-单词遗忘表1-26"><a href="#每日一话-单词遗忘表1-26" class="headerlink" title="每日一话+单词遗忘表1.26"></a>每日一话+单词遗忘表1.26</h1><p>You cannot find peace by avoiding life.</p><ul><li>nutrition 营养</li><li><strong>obese</strong> 肥胖的</li><li>obey 服从</li><li>oblige 强制的</li><li>obstacle 障碍</li><li>obtain 获得</li><li>municipal 市政的</li><li>obvious 显而易见的</li><li><strong>occasiion</strong> 场合</li><li>occupation 工作</li><li>occupy 占领</li><li><strong>occur</strong> 发生</li><li>odor 气味</li><li><strong>offend</strong> 冒犯</li><li>liable 易患的</li></ul><h1 id="每日一话-单词列表1-27"><a href="#每日一话-单词列表1-27" class="headerlink" title="每日一话+单词列表1.27"></a>每日一话+单词列表1.27</h1><p>Have no fear of perfection —— you’ll never reach it.</p><ul><li>occasion 场合</li><li>omit 省略</li><li>ongoing 前进的</li><li>onward 向前的</li><li>opera 歌剧</li><li>operate 运转</li><li>opposite 相反的</li><li>oral 口头的</li><li>orbit 轨道</li><li>orchestra 管弦乐队</li><li>gamble 赌博</li><li></li></ul><h1 id="每日一话-单词遗忘表1-28"><a href="#每日一话-单词遗忘表1-28" class="headerlink" title="每日一话+单词遗忘表1.28"></a>每日一话+单词遗忘表1.28</h1><p>May your new year be filled with abundance of smiles and happiness!</p><p>新的一年，祝大家新年快乐哈哈哈哈</p><ul><li>geometry 几何学</li><li>ore 矿</li><li>organ 器官</li><li>organic 有机的</li><li>organism 有机体</li><li>orient 确定方向  东方</li><li>ornament 装饰</li><li>orphan 孤儿</li><li>ought to 应该</li><li>ounce 盎司</li><li>outlet 出口</li><li>outline 轮廓</li><li>orchestra 管弦乐队</li><li>giant 巨大的</li></ul><h1 id="每日一话-单词遗忘表1-29"><a href="#每日一话-单词遗忘表1-29" class="headerlink" title="每日一话+单词遗忘表1.29"></a>每日一话+单词遗忘表1.29</h1><p>As the new sun rises in a brand new year may it bring you good luck, prosperity, joy, and contentment.</p><ul><li>outset 开端</li><li>outskirts 郊区</li><li>oval 椭圆的</li><li>oven 烤箱</li><li>overcoat 大衣</li><li>overdue 迟到的</li><li>noun 名词</li><li>overthrow 打到</li><li>overwhelm 淹没</li><li>oxygen 氧气</li><li>ozone 臭氧</li><li>pace 步速</li></ul><h1 id="每日一话-单词遗忘表1-30"><a href="#每日一话-单词遗忘表1-30" class="headerlink" title="每日一话+单词遗忘表1.30"></a>每日一话+单词遗忘表1.30</h1><p>To realize the value of one minute, ask the traveler who has just missed his train.</p><ul><li>pad 护具</li><li>paint 油漆</li><li>palace 宫殿</li><li>pale 苍白的</li><li>palm 手掌</li><li>parade 游行</li><li>paralel 平行线</li><li>parcel 包裹</li><li>pardon 原谅</li><li>particle 颗粒</li></ul><h1 id="每日一话-单词遗忘表1-31"><a href="#每日一话-单词遗忘表1-31" class="headerlink" title="每日一话+单词遗忘表1.31"></a>每日一话+单词遗忘表1.31</h1><p>Children have more need of models than of critics.</p><ul><li>pastime 娱乐</li><li>patch 小片</li><li>patent 专利</li><li>pause 暂停</li><li>pave 铺设</li><li>pea 豌豆</li><li>peanut 花生</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/01/en5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据结构期末复习</title>
      <link>https://blog.tokenlen.top/2024/12/16/data7/</link>
      <guid>https://blog.tokenlen.top/2024/12/16/data7/</guid>
      <pubDate>Sun, 15 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;名词解析&quot;&gt;&lt;a href=&quot;#名词解析&quot; class=&quot;headerlink&quot; title=&quot;名词解析&quot;&gt;&lt;/a&gt;名词解析&lt;/h1&gt;&lt;h3 id=&quot;1、逻辑结构和存储结构&quot;&gt;&lt;a href=&quot;#1、逻辑结构和存储结构&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h1><h3 id="1、逻辑结构和存储结构"><a href="#1、逻辑结构和存储结构" class="headerlink" title="1、逻辑结构和存储结构"></a>1、逻辑结构和存储结构</h3><ul><li><strong>逻辑结构</strong>：指的是<strong>数据元素</strong>之间的<strong>相互关系和组织方式</strong>，描述数据元素之间如何连接、关联。常见的逻辑结构有线性结构（如数组、链表）、树形结构（如二叉树）、图形结构等。</li><li><strong>存储结构</strong>：指的是数据在<strong>计算机内存中具体的存储方式</strong>，是实现逻辑结构的具体方式。常见的存储 结构有顺序存储（如数组）、链式存储（如链表）等。</li></ul><h3 id="2、稳定的排序方法和不稳定的排序方法"><a href="#2、稳定的排序方法和不稳定的排序方法" class="headerlink" title="2、稳定的排序方法和不稳定的排序方法"></a>2、稳定的排序方法和不稳定的排序方法</h3><ul><li><strong>稳定的排序方法</strong>：在排序过程中，相等的元素在排序后相对位置不变。例如，冒泡排序、插入排序、归并排序。</li><li><strong>不稳定的排序方法</strong>：在排序过程中，相等的元素在排序后相对位置可能发生改变。例如，快速排序、选择排序、堆排序。</li></ul><h3 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3.完全二叉树"></a>3.完全二叉树</h3><ul><li><strong>完全二叉树</strong>：是一种特殊的二叉树，除了最底层外，其余每一层的节点数都达到最大，并且最底层的节点从左到右排列。完全二叉树的节点编号是按照从上到下、从左到右的顺序编号的。</li></ul><h3 id="4-什么是关键路径？什么是关键活动？"><a href="#4-什么是关键路径？什么是关键活动？" class="headerlink" title="4.什么是关键路径？什么是关键活动？"></a>4.什么是关键路径？什么是关键活动？</h3><ul><li><strong>关键路径</strong>：在项目管理中，关键路径是指从<strong>项目开始</strong>到<strong>项目结束</strong>的<strong>所有任务所组成的路径</strong>，这条路径上的每个任务都不能延误，否则整个项目的完成时间将延长。关键路径上的活动即为<strong>关键活动</strong>。</li><li><strong>关键活动</strong>：指在项目中，任何延误都将直接影响项目总工期的活动。它们位于关键路径上，是项目中最重要的活动。</li></ul><h3 id="5-什么是前缀编码？哈夫曼编码为什么是前缀编码？"><a href="#5-什么是前缀编码？哈夫曼编码为什么是前缀编码？" class="headerlink" title="5.什么是前缀编码？哈夫曼编码为什么是前缀编码？"></a>5.什么是前缀编码？哈夫曼编码为什么是前缀编码？</h3><ul><li><strong>前缀编码</strong>：是一种编码方式，<strong>任何一个编码都不是另一个编码的前缀。即没有任何一个编码是另一个编码的开头部分</strong>。常见的前缀编码有哈夫曼编码。</li><li><strong>哈夫曼编码是前缀编码</strong>：因为在哈夫曼编码中，编码的构造保证了<strong>任何一个字符的编码都不可能是另一个字符编码的前缀</strong>，因此满足前缀编码的性质。哈夫曼编码通过使用<strong>变长的编码</strong>，使得<strong>频繁出现</strong>的字符用<strong>短的编码表示</strong>，而不常见的字符用长的编码表示，从而提高了编码效率。</li></ul><h3 id="6-什么是数据结构？常见的数据结构类型有哪些？"><a href="#6-什么是数据结构？常见的数据结构类型有哪些？" class="headerlink" title="6.什么是数据结构？常见的数据结构类型有哪些？"></a>6.什么是数据结构？常见的数据结构类型有哪些？</h3><ul><li><strong>数据结构</strong>：是计算机中<strong>存储、组织数据</strong>的方式，它定义了数据元素之间的<strong>关系</strong>以及<strong>存取数据</strong>的方法。数据结构是实现算法的<strong>基础</strong>，它影响程序的执行效率和资源使用。</li><li>常见的数据结构类型:<ol><li><strong>线性数据结构</strong>：如数组、链表、栈、队列。</li><li><strong>树形数据结构</strong>：如二叉树、AVL树、红黑树、B树、堆。</li><li><strong>图形数据结构</strong>：如无向图、有向图、加权图、邻接矩阵、邻接表。</li><li><strong>哈希表</strong>：通过哈希函数实现高效的查找和插入。</li><li><strong>集合与映射</strong>：如集合、字典、集合运算等。</li></ol></li></ul><h3 id="其他基础名词"><a href="#其他基础名词" class="headerlink" title="其他基础名词"></a>其他基础名词</h3><ol><li><strong>线性表</strong>：由若干数据元素构成的<strong>集合</strong>，其中的元素之间存在<strong>一对一</strong>的关系。常见的线性表有数组、链表、栈、队列等。</li><li><strong>栈</strong>：一种<strong>线性数据</strong>结构，遵循<strong>后进先出</strong>（LIFO）原则，只有一个端口可以插入和删除元素。</li><li><strong>队列</strong>：一种<strong>线性数据</strong>结构，遵循<strong>先进先出</strong>（FIFO）原则，元素从队尾插入，从队头删除。</li><li><strong>数组</strong>：一种<strong>线性数据</strong>结构，通过<strong>连续的内存单元存储相同类型的数据元素</strong>，可以通过索引进行访问。</li><li><strong>链表</strong>：一种<strong>线性数据</strong>结构，元素通过指针连接，每个元素包含<strong>数据</strong>和<strong>指向下一个元素的指针</strong>。</li><li><strong>双向链表</strong>：一种<strong>链表结构</strong>，除了每个元素指向下一个元素的指针外，还包含指向前一个元素的指针。</li><li><strong>树</strong>：由<strong>若干个节点</strong>组成的非线性数据结构，节点之间有<strong>父子关系</strong>。</li><li><strong>二叉树</strong>：每个节点最多有两个子节点的树。</li><li><strong>二叉搜索树</strong>：一种特殊的二叉树，<strong>左子树的值小于根节点的值</strong>，<strong>右子树的值大于根节点的值</strong>。</li><li><strong>平衡二叉树</strong>：一种特殊的二叉树，<strong>任何节点的左右子树的高度差不超过1。</strong>时间复杂度为 O(log n)</li><li><strong>哈希表</strong>：通过<strong>哈希函数</strong>将<strong>键值</strong>映射到一个位置，常用于实现高效的查找、插入操作。</li><li><strong>图</strong>：由<strong>顶点</strong>和<strong>边</strong>组成的数据结构，边表示顶点之间的关系。一般用数字表示。</li><li><strong>邻接矩阵</strong>：一种表示图的方式，使用二维数组表示顶点之间的连接关系。</li><li><strong>邻接表</strong>：另一种表示图的方式，使用链表或动态数组表示每个顶点的邻接节点。</li><li><strong>深度优先搜索（DFS）</strong>：一种图的遍历方法，优先访问<strong>深层节点</strong>，直到没有未访问的邻接节点时返回。</li><li><strong>广度优先搜索（BFS）</strong>：一种图的遍历方法，优先访问<strong>浅层节点</strong>，逐层遍历图的节点。</li><li><strong>递归</strong>：一种函数调用<strong>自身</strong>的编程方式，通常用于解决可以分解为更小规模相同问题的任务。</li><li><strong>动态数组</strong>：一种数组类型，具有可变大小的特性，支持动态扩展</li><li><strong>堆</strong>：一种完全二叉树结构，用于实现优先队列。最大堆或最小堆根据优先级决定元素的排列。</li><li><strong>动态规划</strong>：一种将复杂问题分解成<strong>小问题</strong>，<strong>解决小问题并存储其解</strong>，最后合成<strong>大问题解</strong>的算法设计方法。</li><li><strong>迭代</strong>：通过<strong>循环结构</strong>逐步逼近目标结果的方法，适用于不需要递归的场景。</li><li><strong>并查集</strong>：一种用于<strong>处理不相交集合合并</strong>和<strong>查询</strong>的问题的数据结构。支持两种操作：<strong>查找</strong>（判断两个元素是否属于同一集合）和 <strong>合并</strong>（将两个集合合并成一个）。<ul><li><strong>路径压缩</strong>：优化查找操作，减少树的高度。</li><li><strong>按秩合并</strong>：优化合并操作，避免形成过高的树</li></ul></li><li><strong>哈希冲突</strong>：当<strong>两个不同的键值</strong>通过哈希函数映射到<strong>相同的位置时</strong>，称为哈希冲突。常见的解决方法有链式法和开放地址法。<ul><li><strong>链式法</strong>：使用链表来解决冲突，多个元素可以存储在同一个位置。</li><li><strong>开放地址法</strong>：当发生冲突时，寻找下一个空闲位置进行插入。</li></ul></li><li><strong>红黑树</strong>：一种自平衡的二叉搜索树，具有更多的约束条件，能够保证最坏情况下的 O(log n) 查找、插入和删除操作。</li><li><strong>时间复杂度</strong>：衡量<strong>算法执行时间</strong>随输入<strong>规模变化的增长率</strong>。常用的时间复杂度有 O(1)、O(log n)、O(n)、O(n log n)、O(n²) 等。</li><li><strong>空间复杂度</strong>：衡量算法<strong>所需空间随输入规模变化</strong>的增长率</li><li><strong>最小生成树</strong><ul><li><strong>Prim算法</strong>：从一个点开始逐步加入最小的边，直到包含所有点。</li><li><strong>Kruskal算法</strong>：从最小的边开始逐步加入，不形成环，直到生成树完整。</li></ul></li><li>常见排序算法：<ul><li><strong>冒泡排序</strong>：O(n^2)</li><li><strong>选择排序</strong>：O(n^2)</li><li><strong>插入排序</strong>：O(n^2)</li><li><strong>归并排序</strong>：O(n log n)</li><li><strong>快速排序</strong>：O(n log n)（平均）</li><li><strong>堆排序</strong>：O(n log n)</li></ul></li><li>图的存储方式<ul><li><strong>邻接矩阵</strong>：适用于稠密图。</li><li><strong>邻接表</strong>：适用于稀疏图。</li></ul></li><li>线索二叉树是对二叉树的一个改进，用来避免在遍历时使用栈或递归，使用线索指针替代空指针。</li><li></li></ol><h3 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h3><p><img src="https://qcdn.itcharge.cn/images/20220218173007.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20220218174000.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20220221103552.png" alt=""></p><p><img src="https://qcdn.itcharge.cn/images/20240511171423.png" alt=""></p><h1 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h1><h2 id="队列计算"><a href="#队列计算" class="headerlink" title="队列计算"></a>队列计算</h2><p>队列的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length=(r-f+m)%m</span><br></pre></td></tr></table></figure><p>队满的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(r+1)%m == f</span><br></pre></td></tr></table></figure><p>队列不满的时候入队</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r=(r+1)%m</span><br></pre></td></tr></table></figure><p>队空的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f == r</span><br></pre></td></tr></table></figure><p>队列不为空时出队</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = (f+1)%m</span><br></pre></td></tr></table></figure><ul><li>r 是队尾指针</li><li>f 是队头指针</li><li>m 是队列的最大容量</li></ul><h2 id="广义表计算"><a href="#广义表计算" class="headerlink" title="广义表计算"></a>广义表计算</h2><p>广义表的表长是指广义表中<strong>直接包含</strong>的元素个数，而这些元素可以是原子（如 <code>a</code>、<code>b</code>）或者子表。注意是直接包含</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LS = (a, b, c), (d, e, f)</span><br></pre></td></tr></table></figure><p>上面LS的表长即为<strong>2</strong></p><p>广义表的提取：</p><p>下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(tail(tail(head(LS))))</span><br></pre></td></tr></table></figure><p>即结果为元素<strong>c</strong></p><p>就是先分析里面的，然后一层一层的套，<strong>最后只剩下一个了得head取出</strong></p><p>例如：</p><p>取出元素e</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(tail(head(tail(LS)))) = e</span><br></pre></td></tr></table></figure><h2 id="树的计算"><a href="#树的计算" class="headerlink" title="树的计算"></a>树的计算</h2><p>对于完全二叉树来说，<strong>n</strong>为总节点树，[x]为向上取整</p><p>叶子节点的数量L</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L=[n/2]</span><br></pre></td></tr></table></figure><p>对于完全二叉树，除了最后一层外，其他层的结点都是满的，所以大部分叶子结点都在最后一层或倒数第二层。</p><p>树的深度：</p><p>是指从根结点到最深叶子结点的路径长度，对于完全二叉树则<strong>深度d</strong>为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d=⌈log2(n)⌉</span><br></pre></td></tr></table></figure><p>完全二叉树的深度为 <code>d</code>，则结点数 <code>n</code> 满足：</p><script type="math/tex; mode=display">2^{d-1} \leq n \leq 2^d - 1</script><ul><li>一个完全二叉树的最小结点数发生在只有根节点的情况下，深度为 d<em>d</em> 的完全二叉树的最小结点数是 2d−12<em>d</em>−1。</li><li>完全二叉树的最大结点数是满二叉树的结点数，即 2d−12<em>d</em>−1。</li></ul><p>非叶子结点的个数可以通过以下公式计算：</p><script type="math/tex; mode=display">N_{non-leaf} = n - L</script><h2 id="图的计算"><a href="#图的计算" class="headerlink" title="图的计算"></a>图的计算</h2><p>完全图的边和顶点的关系，假设m条边和n个顶点，图的边数为</p><script type="math/tex; mode=display">m= n(n−1)/2</script><p>非连通无向图考虑<strong>至少</strong>顶点数的情况下，该图由两个子图构成，一个是完全图一个是只有一个顶点，所以如果边数为28的话，最后至少<strong>9</strong>个顶点。</p><p>那我们接下来来考虑<strong>至多</strong>的情况</p><p>对于非连通无向图，最多顶点数的情况是图中每个连通分量都为一个孤立的顶点，即每个顶点都没有边。但是题目限定了28条边，那我们就每个连通分量都拥有尽可能少的边数，也就是两个顶点一条边。边数为28的话，那么顶点数就是<strong>56</strong>。所以至多顶点数为<strong>56</strong></p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 0;</span><br><span class="line">for(i = l; i &lt; n; i++)</span><br><span class="line">  for(j = l; j &lt;= n - i; j++)</span><br><span class="line">    x++;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度为<strong>O(n^2)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = -l;</span><br><span class="line">for(j = l; j &lt;= n; j++)</span><br><span class="line">  while(i &lt;= n)</span><br><span class="line">    i = i * 2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度为<strong>O(n *log n)</strong></p><p><strong>在简单for循环中时间复杂度可以为</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外层时间复杂度*内层时间复杂度</span><br></pre></td></tr></table></figure><h2 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h2><p>1、设有一个二维数组 A[m][n]按行优先顺序存储，假设 A[0][0]存放位置在<br>644(10)，A[2][2]存放位置在 676(10)，每个元素占一个字节的空间，问 A[3]<a href="10">3</a><br>存放在什么位置？脚注(10)表示用 10 进制表示。</p><p>元素 A[i][j]<em>A</em>[<em>i</em>][<em>j</em>] 的存储地址可以通过以下公式计算：</p><script type="math/tex; mode=display">地址(A[i][j])=地址(A[0][0])+(i×n+j)</script><ul><li><em>i</em> 是行号，</li><li>j 是列号，</li><li><em>n</em> 是数组的列数，</li><li>地址(A[0][0])地址(<em>A</em>[0][0]) 是数组的起始位置。</li></ul><p>这样解出n=15然后获得a33的位置</p><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>在折半查找中，判定树是根据每次比较将序列分为两部分来进行的</p><p>假设我们有一个长度为 12 的序列，元素的下标从 1 到 12。</p><ul><li><strong>初始查找范围</strong>：整个序列，长度为 12，范围是从 1 到 12。</li><li><p>选择中间的元素。中间元素的下标是 <code>(1 + 12) / 2 = 6</code>，所以在第一次比较时，根结点的值是序列中的第 6 个元素。</p></li><li><p>如果要找的值比根结点的值小，查找范围变为 1 到 5。</p></li><li><p>如果要找的值比根结点的值大，查找范围变为 7 到 12。</p></li><li><p>如果查找范围是 7 到 12，那么新的中间元素下标为 <code>(7 + 12) / 2 = 9</code>。此时，根结点的右孩子的值对应的是序列中的第 9 个元素。</p></li></ul><p><strong>在折半查找中，若得到的中间元素位置是小数，则需要向下取整。</strong></p><p>孩子节点就是子节点</p><h1 id="真题练习"><a href="#真题练习" class="headerlink" title="真题练习"></a>真题练习</h1><h2 id="哈夫曼树的构建"><a href="#哈夫曼树的构建" class="headerlink" title="哈夫曼树的构建"></a>哈夫曼树的构建</h2><p>已知下列字符 A、B、C、D、E、F、G 的权值分别为 3、12、7、4、<br>2、8，11，试填写出其对应哈夫曼树 HT 的存储结构的终态，完成表 1。<br> 表 1 哈夫曼树 HT 的存储结构的终态<br>weight parent lchild rchild<br>1<br>2<br>3<br>4<br>5<br>6<br>7</p><p>因为哈夫曼树是从最小的节点一次累加最后聚合到根节点</p><p>所以把上面权按照大小顺序排列</p><p>【2,3,4,7,8,11,12】</p><p>然后按照大小顺序合并</p><p>第一次：[4,5,7,8,11,12]</p><p>第二次：[7,8,9,11,12]</p><p>第三次：[9,11,12,15]</p><p>第四次：[12,15,20]</p><p>第五次：[20,27]</p><p>第六次：[47]</p><p>所以最后的根节点就是47</p><p>所以最后得到的哈夫曼树就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                  (47)</span><br><span class="line">                /     \</span><br><span class="line">             (20)     (27)</span><br><span class="line">            /   \     /     \</span><br><span class="line">       (9)     (11) (12)   (15)</span><br><span class="line">      /  \           /   \</span><br><span class="line">   (4)    (5) (7)   (8) </span><br><span class="line">   /  \</span><br><span class="line">（2） (3)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>哈夫曼编码就是从根节点开始，往左走是0，往右走是1</p><p>所以权值为2的节点可以表示为0010,3可以表示为0011</p><p>然后分别按照出现的先后顺序填写好编号，再把节点的表填完</p><div class="table-container"><table><thead><tr><th>编号</th><th>weight</th><th>parent</th><th>lchild</th><th>rchild</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>8</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>2</th><th>3</th><th>8</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>3</th><th>4</th><th>9</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>4</th><th>7</th><th>9</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>5</th><th>8</th><th>10</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>6</th><th>11</th><th>10</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>7</th><th>12</th><th>11</th><th>-</th><th>-</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>8</th><th>5</th><th>9</th><th>1</th><th>2</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>9</th><th>9</th><th>12</th><th>3</th><th>4</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>10</th><th>15</th><th>12</th><th>5</th><th>6</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>11</th><th>20</th><th>13</th><th>7</th><th>8</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>12</th><th>27</th><th>13</th><th>9</th><th>10</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>13</th><th>47</th><th>-</th><th>11</th><th>12</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h2 id="图-网"><a href="#图-网" class="headerlink" title="图-网"></a>图-网</h2><p>2、如下图所示的 AOE-网：<br>（1） 求这个工程最早可能在什么时间结束；<br>（2） 求每个活动的最早开始时间和最迟开始时间；<br>（3） 确定哪些活动是关键活动。</p><p>这个主要就是带权图的知识</p><p>设使用每个步骤所用的最早可能开始时间<strong>为e</strong>，所用的最迟可能开始时间<strong>为l</strong></p><p>当l-e=0的时候为关键活动。</p><h2 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h2><p>设哈希函数 H（K）=3 K mod 11，哈希地址空间为 0～10，对关键字<br>序列（32，13，49，24，38，21，4，12），按链地址法（拉链法）构造哈希表，并<br>分别求出等概率下查找成功时和查找失败时的平均查找长度 ASLsucc 和<br>ASLunsucc。</p><p>其中mod11是指取余的意思</p><p>那么根据运算公式h(k)=3kmod11</p><p>h(32)=32*3mod11=8</p><p>h(13)=13*3mod11=6</p><p>h(49)=48*3mod11=4</p><p>h(24)=24*3mod11=6</p><p>h(38)=38*3mod11=3</p><p>h(21)=21*3mod11=8</p><p>h(4)=4*3mod11=1</p><p>h(12)=12*3mod11=3</p><p>所以链表的构造为</p><p>位置 data length</p><p>0 null</p><p>1 4 1</p><p>2 null</p><p>3 38-&gt;12 2</p><p>4 49 1</p><p>5 null</p><p>6 13-&gt;24 2</p><p>7 null</p><p>8 32-&gt;21 2</p><p>9 null</p><p>10 null</p><p>查找成功时的平均查找长度是所有成功查找的查找长度的平均值。每个位置的查找长度等于该位置链表的长度。假设每个位置的链表长度为 <code>L(i)</code>，则查找成功的平均查找长度为：</p><script type="math/tex; mode=display">ASLsucc= 成功查找次数∑L(i)/成功查找次数</script><p><strong>所以Aslsucc=8/8=1</strong></p><p>查找失败时的平均查找长度是所有失败查找的查找长度的平均值。查找失败时的查找长度是从位置 0 到位置 10 的每个位置的查找深度（即链表长度）。如果某个位置没有元素（空），则查找长度为 1。</p><p><strong>Aslunsucc=13/10=1.3</strong></p><p>设一组有序的记录关键字序列为(13，18，24，35，47，50，62，83，90)，查找方法用二分查找，要求计算出查找关键字62时的比较次数并计算出查找成功时的平均查找长度。</p><p>索引是从[0-8]所以中间元素是47，47&lt;62所以范围是[5-8]</p><p>中间元素正好是62</p><p>所以比较次数为<strong>2</strong></p><script type="math/tex; mode=display">ASL= 1×C 1​ +2×C 2​ +⋯+n×C n/n</script><p>最坏情况下，需要 log⁡2n\log_2 nlog2n 次比较（如果是成功查找）。对于这个数组，n=9n = 9n=9，所以最多需要 log⁡2 9≈3.17次比较，四舍五入就是 <strong>4</strong> 次比较。</p><p>对于数组长度 n=9n = 9n=9，各个元素成功查找时的比较次数：这个是需要四舍五入的</p><p>1个是1次，两个三个是2次，四个五个六个是3次，七个八个九个是4次</p><script type="math/tex; mode=display">ASL= （1+4+2+9+6+6+8+4+8）/9 = 9/48​ ≈2.67</script><h2 id="二叉树的遍历和森林转换"><a href="#二叉树的遍历和森林转换" class="headerlink" title="二叉树的遍历和森林转换"></a>二叉树的遍历和森林转换</h2><p>设一棵二叉树的先序序列： A B D F C E G H ，中序序列： B F D A<br>G E H C</p><p>先序遍历的顺序是 根-&gt;左-&gt;右；中序遍历的顺序是 左-&gt;根-&gt;右</p><p>后序遍历是左-&gt;右-&gt;根</p><p>根据先序遍历获得根节点A</p><p>已知先序遍历和后序遍历是不能唯一确定一颗二叉树的，但是其他序列的组合是可以的。也就是确定唯一的二叉树必须要有中序遍历</p><p>根据中序遍历，D在B的右边，所以D是B的右子树。同样的E在C的左边，所以E是C的左子树</p><p>所以还原出来的二叉树是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> /   \</span><br><span class="line">B     C</span><br><span class="line"> \     /</span><br><span class="line">  D   E</span><br><span class="line"> /   / \</span><br><span class="line"> F  G   H</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后他的后序遍历是</p><p>FDBGHECA</p><p>在这部分，我们要将二叉树转换为<strong>树或森林</strong>。要构建森林，我们将树的结构分为多个独立的子树。</p><p>分成两棵树</p><p>只要看这棵二叉树的根结点有没有右孩子，有的话就是森林，没有的话就是一棵树</p><p>第一步，若结点 <code>x</code> 是其双亲 <code>y</code> 的左孩子，则把 <code>x</code> 的右孩子，右孩子的右孩子等等等等，依次都与 <code>y</code> 用连连连接起来。</p><p>第二部，去掉所有双亲到右孩子之间到连线</p><p>然后从森林变成树的话就是这个操作的逆向</p><p>就是先把去掉右孩子的连线</p><p>然后把一棵树上相同深度的节点连起来</p><p>再把根节点连在一起</p><p>整理一下就得到了二叉树</p><p>设一棵树T中边的集合为{(A，B)，(A，C)，(A，D)，(B，E)，(C，F)，(C，G))，要求用孩子兄弟表示法（二叉链表）表示出该树的存储结构并将该树转化成对应的二叉树。</p><p>根据上面的信息，树应该是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">   / | \</span><br><span class="line">  B  C  D</span><br><span class="line"> /   / \</span><br><span class="line">E   F   G</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设有一组初始记录关键字为(45，80，48，40，22，78)，要求构造一棵二又排序树并给出构造过程</p><p>根据插入顺序插入元素，大于根节点的为右子树，小于的则为左子树</p><p>对于每个节点，左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值。通过这种方式保证了树的结构满足二叉排序树的特性。所以二叉搜索树如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     45</span><br><span class="line">    /  \</span><br><span class="line">  40    80</span><br><span class="line"> /     /  \</span><br><span class="line">22    48  78</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>设待排序的关键字序列为{12，6，16，30，10，20，2，18}，试分别写<br>出使用以下排序方法第一趟排序结束后关键字序列的状态，并写出该算法是稳定的<br>还是不稳定的。<br>① 希尔排序（d1=3）<br>② 冒泡排序<br>③ 快速排序<br>④ 二路归并排序</p><p>⑤选择排序</p><p>希尔排序：</p><p><strong>希尔排序</strong>的基本思路是：先将待排序序列按一定增量分组，分别对每组元素进行插入排序，最后逐步缩小增量，直到增量为 1，再进行一次插入排序。</p><p>给定增量序列：d1=3d_1 = 3d1=3，所以分组的方式是每隔 3 个元素一组。</p><p>首先，将序列按增量 3 分成 3 组：</p><ul><li>组 1：{12, 30, 2}</li><li>组 2：{6, 10, 18}</li><li>组 3：{16, 20}</li></ul><p>对每组分别进行插入排序：</p><ul><li>组 1：{12, 30, 2} -&gt; 排序后为 {2, 12, 30}</li><li>组 2：{6, 10, 18} -&gt; 排序后为 {6, 10, 18}</li><li>组 3：{16, 20} -&gt; 排序后为 {16, 20}</li></ul><p>然后重新合并这些组，得到：</p><p><strong>{2,6,16,12,10,20,30,18}</strong></p><p>在这之中，<strong>插入排序是稳定的</strong>。因为在排序过程中，当遇到相同的元素时，它们的相对顺序不会改变。最坏的结果下，时间复杂度是o(n^2)</p><p>希尔排序通常被认为是<strong>不稳定的</strong>，因为它在分组排序过程中可能会改变元素的相对顺序，特别是在增量较大时。</p><p>冒泡排序：</p><p>{12，6，16，30，10，20，2，18}</p><p>直接进行相互比较，后边的小就往前移动，大就不移动</p><p>然后经过第一趟之后是：</p><p><strong>{6，12，16，10，20，2，18，30}</strong></p><p><strong>冒泡排序是稳定的</strong>。即使相同的元素出现，也会保留它们原来的相对顺序。</p><p>快速排序：</p><p><strong>快速排序</strong>的基本思路是：选择一个基准元素，将数组分成两个部分，左边部分小于基准，右边部分大于基准，再递归排序两个部分。</p><p>{12，6，16，30，10，20，2，18}</p><p>以12为基准，小于12的{6,10,2}</p><p>大于12的{16,30,20,18}</p><p>然后合并，把基准12放在合适的位置，得到</p><p><strong>{6,10,2,12,16,30,20,18}</strong></p><p><strong>快速排序是非稳定的</strong>，因为相同的元素在分区过程中可能会改变原有的相对位置。</p><p>二路归并排序:</p><p><strong>二路归并排序</strong>的基本思路是：将序列不断分成两部分，递归地对两部分排序，最后合并排序好的两部分。</p><p>如何根据长度n划分部分</p><p>如果 <strong>n</strong> 是偶数，两个子序列的长度相等。</p><p>如果 <strong>n</strong> 是奇数，前一个子序列的长度是 <strong>n // 2</strong>，后一个子序列的长度是 <strong>n // 2 + 1</strong>。</p><p>{12，6，16，30，10，20，2，18}</p><p>分成两部分，然后每部分进行排序</p><p>{12，6，16，30}-&gt;{6,12,16,30}</p><p>{10，20，2，18}-&gt;{2,10,18,20}</p><p>然后合并两部分</p><p><strong>{6,12,16,30,2,10,18,20}</strong></p><p><strong>归并排序是稳定的</strong>。在合并过程中，如果两个元素相等，它们的顺序会保留。</p><p><strong>选择排序</strong></p><p>简单 <strong>选择排序</strong>通过每一趟选择剩余序列中的最小值并将其放到已排序部分的末尾。</p><p>{12，6，16，30，10，20，2，18}</p><p>第一次找到最小值2与12交换，得到</p><p><strong>{2,6,16,30,10,20,12,18}</strong></p><p><strong>稳定性</strong>：不稳定。因为最小元素可能会被交换，从而改变相等元素的相对顺序。</p><p>然后还有<strong>直接插入排序</strong></p><p>从第二个元素开始，与前面的已排序部分逐一比较，找到合适的位置插入当前元素。</p><h2 id="最小堆和最大堆"><a href="#最小堆和最大堆" class="headerlink" title="最小堆和最大堆"></a>最小堆和最大堆</h2><p>最小堆（即根节点是最小值）。最小堆是一个完全二叉树，它满足每个父节点的值都不大于其子节点的值。每次向堆中插入数据时，都需要通过”上浮”（bubble-up）操作来维持堆的性质。</p><p>画出向小根堆中加入数据4，2，5，8，3时，每加入一个数据后堆的变化。</p><p>首先加入4，4是根节点</p><p>然后加入2，2小于4,所以交换2和4，2为根节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后加入5，因为5比2大，所以不用上浮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后加入8，8大于2，不需要上浮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> /</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>插入3，3小于4交换3和4，然后3大于2，不需要再上浮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br><span class="line"> / \</span><br><span class="line">8   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以这就是最终的堆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br><span class="line"> / \</span><br><span class="line">8   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后大根堆的话就是根节点是最大的值，其他的操作和最小堆一样</p><p>比如加入2, 3, 5, 8, 4 </p><p>先加入2，作为根节点</p><p>然后加入3，3比2大，然后23交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> /</span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加入5，5比2大，25交换，5比3大，53交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加入8，8大于5，85交换，8大于3交换83</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   / \</span><br><span class="line">  5   3</span><br><span class="line"> /  </span><br><span class="line">2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后插入4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   / \</span><br><span class="line">  5   3</span><br><span class="line"> / \  </span><br><span class="line">2   4</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="大根堆和堆排序"><a href="#大根堆和堆排序" class="headerlink" title="大根堆和堆排序"></a>大根堆和堆排序</h2><p><strong>堆排序是一种选择排序</strong></p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong> </p><p>左子节点就是2i+1,右子节点就是2i+2</p><p>父节点在(i-1)/2</p><p>将序列（5，26，77，1，61，11）构造成大根堆并实现排序，请画出<br>初始形态和最终的大根堆，并写出第一趟堆排序的结果。</p><p>在这里构造大根堆的时候，根节点要最大</p><p>从最后一个非叶子节点开始（也就是数组中的 <code>n//2 - 1</code> 位置），依次向前执行”堆化”操作，确保每个子树都满足大根堆的性质。</p><p>堆化节点1 index=2</p><p>左子节点：77，右子节点：11。最大值是 77。<strong>左子节点是2i+1</strong> 右子节点是2i+2</p><p>交换 77 和 5，得到 <code>[77, 26, 5, 1, 61, 11]</code>。</p><p>然后堆化节点0 index=1</p><p>左子节点是26 右子节点是61</p><p>交换26和61</p><p><strong>[77，61，5，1，26，11]</strong></p><p>堆化节点0 index=0</p><p>77是最大不用堆化</p><p>所以大根堆是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    77</span><br><span class="line">   /  \</span><br><span class="line">  61   5</span><br><span class="line"> /  \   \</span><br><span class="line">1   26  11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆排序的方法：</p><p>将堆顶（最大元素）与堆的最后一个元素交换。</p><p>调整堆，重新保证堆的性质。</p><p>重复步骤 1 和 2，直到堆的大小为 1。</p><p>实例：</p><p>最后肯定是堆化排序成[1, 5, 11, 26, 61, 77]</p><p>第一步是交换77和11</p><p>所以其顺序变成了</p><p><strong>[11，61，5，1，26，77]</strong></p><h2 id="迪杰拉斯特算法和prim算法"><a href="#迪杰拉斯特算法和prim算法" class="headerlink" title="迪杰拉斯特算法和prim算法"></a>迪杰拉斯特算法和prim算法</h2><p>迪杰斯特拉（Dijkstra）算法是一种用于解决单源最短路径问题的算法，尤其适用于图的边权重为非负数的情况。它的目标是找到从一个起点（源节点）到图中所有其他节点的最短路径。</p><p><strong>初始化</strong>：给定图的每个节点，设定起点的最短路径为0，其余节点的最短路径为无穷大。</p><p><strong>选择当前节点</strong>：在尚未确定最短路径的节点中，选择一个具有最短路径估计值的节点。</p><p><strong>更新邻居节点的最短路径</strong>：对当前节点的每个邻居节点，通过比较现有的最短路径和通过当前节点到该邻居的路径来更新邻居节点的最短路径。</p><p><strong>标记当前节点为已处理</strong>：一旦确定了当前节点的最短路径，就将其标记为“已处理”。</p><p><strong>重复</strong>：重复步骤2至步骤4，直到所有节点的最短路径都被确定。</p><p>就是找最小的路径，然后访问所有的节点，注意是<strong>无向图</strong>还是<strong>有向图</strong></p><p>在表格中，没有办法直接到达的写无穷，然后能直接俄到达的直接写，然后写出路径，权值。已经到达的不写用\</p><p><strong>prim算法</strong>就是找到最小生成树，方法是通过起点，然后依次出发找到下一个点，使其经过的路程的和最小，<strong>只要是经过的点</strong>，都可以在那里出发去没有经过的点。</p><h2 id="DFS和BFS遍历树"><a href="#DFS和BFS遍历树" class="headerlink" title="DFS和BFS遍历树"></a>DFS和BFS遍历树</h2><div class="table-container"><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>0</strong></th><th>0</th><th>1</th><th>0</th><th>0</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>1</strong></th><th>0</th><th>0</th><th>1</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>2</strong></th><th>1</th><th>0</th><th>0</th><th>0</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>3</strong></th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><strong>4</strong></th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>比如上面的邻接矩阵，0代表图没用相连，1代表相连了。</p><p>然后实现 <strong>深度优先搜索（DFS）</strong></p><p>首先是深度，尽可能的往下扎</p><div class="table-container"><table><thead><tr><th>来源</th><th></th><th>0</th><th>1</th><th>1</th><th>3</th></tr></thead><tbody><tr><td>结点</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table></div><p>实现<strong>广度优先搜索（BFS）</strong></p><div class="table-container"><table><thead><tr><th></th><th>0</th><th>1</th><th>4</th><th>2</th><th>3</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h2 id="线性表的计算（邻接矩阵和邻接表）"><a href="#线性表的计算（邻接矩阵和邻接表）" class="headerlink" title="线性表的计算（邻接矩阵和邻接表）"></a>线性表的计算（邻接矩阵和邻接表）</h2><p>如图下列数组中存储了一个线性表，表头指针是A[0].next那么这个线性表是</p><div class="table-container"><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>data</td><td></td><td>60</td><td>50</td><td>40</td><td>30</td><td>20</td><td>10</td></tr><tr><td>next</td><td>3</td><td>5</td><td>6</td><td>2</td><td>1</td><td></td><td>4</td></tr></tbody></table></div><p>就是看next指针，然后按顺序读取数据就行</p><p>{40,50,10,30,60,20}</p><p>然后画邻接矩阵和邻接表的时候</p><p>邻接矩阵就是图中1和5有连接，那么(1,5)和(5,1)的话就是1，如果是单向的箭头注意分清方向</p><p>然后邻接图的话类似用箭头和方块表示，最后没了的话就在后面的next画上<strong>^</strong></p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h1><h2 id="折半查找-1"><a href="#折半查找-1" class="headerlink" title="折半查找"></a>折半查找</h2><p>试写出折半查找的递归算法。<br>//r 是有序表，查找关键字 k，若查找成功，返回 k 所在位置，查找失败返回 0。<br>int BinSearch（int r[ ]，int k，low，high）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>    <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> k,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r[mid]==k)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r[mid]&gt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> BinSearch(r,k,low,mid<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BinSearch(r,k,mid+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写出折半查找的非递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinSearchNotFor</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> k ,<span class="type">int</span> low ,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(r[mid]==k)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r[mid]&gt;k)&#123;</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            low =mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h2><p>设计算法：统计单链表 HL 中结点的值等于给定值 x 的结点数。<br> int CountX(LNode* HL,ElemType x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"><span class="type">int</span> <span class="title function_">CountX</span><span class="params">(LNode* HL,ElemType x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    LNode* current = HL;</span><br><span class="line">    <span class="keyword">while</span> (current!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;data == x)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>单链表查找最大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MM -1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line">ElemType <span class="title function_">Max</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>||L-&gt;next ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> MM;</span><br><span class="line">    &#125;</span><br><span class="line">    ElemType maxval = MM;</span><br><span class="line">    LNode* current = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(current!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;data&gt;maxval)&#123;</span><br><span class="line">            maxval = current-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>链表中节点的插入：</p><p>设指针变量p指向双向链表中结点A，指针变量g指向被插入结点B，要求给出在结点A的后面插入结点B的操作序列（设双向链表中结点的两个指针域分别为llink和 rlink)。</p><p>插入一个节点的时候，首先两个节点连接起来，然后把两个节点的前驱和后继再连接起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;rlink = B;</span><br><span class="line">B-&gt;llink = A;</span><br><span class="line">B-&gt;rlink = A-&gt;rlink;</span><br><span class="line"><span class="keyword">if</span>(A-&gt;rlink !=null)&#123;</span><br><span class="line">A-&gt;rlink-&gt;llink = B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序实现"><a href="#快速排序实现" class="headerlink" title="快速排序实现"></a>快速排序实现</h2><p>设有一组初始记录关键字序列（K1，K2，，Kn），要求设计一个算法能够　在○(n)的时间复杂度内将线性表划分成两部分，其中左半部分的每个关键字均小于 Ki，右半部分的每个关键字均大于等于Ki。</p><p><strong>快速排序</strong>的基本思路是：选择一个基准元素，将数组分成两个部分，左边部分小于基准，右边部分大于基准，再递归排序两个部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n,<span class="type">int</span> pivoIndex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[pivoIndex];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp = arr[pivoIndex];</span><br><span class="line">    arr[pivoIndex] = arr[right];</span><br><span class="line">    arr[right] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;pivot)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=pivot)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            temp = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[n<span class="number">-1</span>] = arr[left];</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求交集，设有两个集合A和集合B，要求设计生成集合C=AnB的算法，其中集合A 、B和C用链式存储结构表示。 （分析采用何种数据结构表示集合</p><p>使用链表来解决</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Node** head,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        *head = createNode(data);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node* temp = *head;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = createNode(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">existINList</span><span class="params">(Node* head,<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;data == data)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* <span class="title function_">andList</span><span class="params">(Node* A,Node* B)</span>&#123;</span><br><span class="line">    Node* C = <span class="literal">NULL</span>;</span><br><span class="line">    Node* temp = A;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(existINList(B,temp-&gt;data))&#123;</span><br><span class="line">            insertNode(&amp;C,temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/16/data7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>python期末复习</title>
      <link>https://blog.tokenlen.top/2024/12/10/python2/</link>
      <guid>https://blog.tokenlen.top/2024/12/10/python2/</guid>
      <pubDate>Mon, 09 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;Python 的正则表达式通过 &lt;code&gt;re&lt;/code&gt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Python 的正则表达式通过 <code>re</code> 模块实现，用于处理复杂的字符串匹配和提取操作。</p><ul><li>常用函数：<ul><li><code>re.match(pattern, string)</code><br>从字符串的开头匹配，返回匹配对象或 <code>None</code>。</li><li><code>re.search(pattern, string)</code><br>搜索整个字符串，找到第一个匹配。</li><li><code>re.findall(pattern, string)</code><br>返回所有匹配的结果（列表形式）。</li><li><code>re.finditer(pattern, string)</code><br>返回所有匹配结果的迭代器。</li><li><code>re.sub(pattern, repl, string)</code><br>替换匹配的内容。</li><li><code>re.split(pattern, string)</code><br>根据模式分割字符串。</li></ul></li></ul><p><strong>. 常用正则表达式语法</strong></p><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意单个字符（除换行符）。</td></tr><tr><td><code>^</code></td><td>匹配字符串的开头。</td></tr><tr><td><code>$</code></td><td>匹配字符串的结尾。</td></tr><tr><td><code>*</code></td><td>匹配前面的字符 0 次或多次。</td></tr><tr><td><code>+</code></td><td>匹配前面的字符 1 次或多次。</td></tr><tr><td><code>?</code></td><td>匹配前面的字符 0 次或 1 次。</td></tr><tr><td><code>&#123;n&#125;</code></td><td>匹配前面的字符恰好 n 次。</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>匹配前面的字符至少 n 次。</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>匹配前面的字符至少 n 次，至多 m 次。</td></tr><tr><td><code>[]</code></td><td>匹配字符集合中的任意一个，例如 <code>[a-z]</code> 匹配小写字母。</td></tr><tr><td>`</td><td>`</td></tr><tr><td><code>()</code></td><td>分组，用于提取子模式。</td></tr><tr><td><code>\</code></td><td>转义字符，用于匹配特殊字符。</td></tr></tbody></table></div><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">email = &quot;example@domain.com&quot;</span><br><span class="line">pattern = r&quot;^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$&quot;</span><br><span class="line">if re.match(pattern, email):</span><br><span class="line">    print(&quot;有效的邮箱地址&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无效的邮箱地址&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><code>\d</code></th><th>匹配任意数字，等价于 <code>[0-9]</code>。</th></tr></thead><tbody><tr><td><code>\D</code></td><td>匹配任意非数字。</td></tr><tr><td><code>\w</code></td><td>匹配任意字母、数字、下划线，等价于 <code>[a-zA-Z0-9_]</code>。</td></tr><tr><td><code>\W</code></td><td>匹配任意非字母、数字、下划线。</td></tr><tr><td><code>\s</code></td><td>匹配任意空白字符（包括空格、制表符等）。</td></tr><tr><td><code>\S</code></td><td>匹配任意非空白字符。</td></tr></tbody></table></div><p>对于需要多次使用的正则表达式，可以通过 <code>re.compile()</code> 提前编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python复制代码import re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(r&quot;\d+&quot;)</span><br><span class="line">result = pattern.findall(&quot;订单号123，总金额456元&quot;)</span><br><span class="line">print(result)  # 输出 [&#x27;123&#x27;, &#x27;456&#x27;]</span><br></pre></td></tr></table></figure><p>编译时可以指定标志（flags）：</p><ul><li><code>re.IGNORECASE</code> (<code>re.I</code>)：忽略大小写。</li><li><code>re.MULTILINE</code> (<code>re.M</code>)：多行模式。</li><li><code>re.DOTALL</code> (<code>re.S</code>)：使 <code>.</code> 匹配换行符。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&quot;hello&quot;, re.IGNORECASE)</span><br><span class="line">print(pattern.findall(&quot;Hello, hello, HELLO&quot;))  # 输出 [&#x27;Hello&#x27;, &#x27;hello&#x27;, &#x27;HELLO&#x27;]</span><br></pre></td></tr></table></figure><h1 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h1><p>1.编写程序的目的是“使用计算机解决问题”，写出使用计算机解决问题的常见步骤</p><p><strong>问题定义与理解</strong>：明确问题及需求，确定输入输出。</p><p><strong>问题分析</strong>：分析问题细节，识别关键点和约束。</p><p><strong>设计算法</strong>：设计解决问题的算法，选择合适的数据结构。</p><p><strong>选择工具</strong>：选择适合的编程语言和开发环境。</p><p><strong>编写程序</strong>：根据算法编写清晰的代码，确保正确性。</p><p><strong>调试与测试</strong>：检测和修复错误，进行功能和边界测试。</p><p><strong>优化与改进</strong>：提高程序性能和可维护性。</p><p><strong>文档化与维护</strong>：编写使用文档，定期维护和更新程序。</p><p>2.python语言时一种被广泛使用的高级通用脚本编程语言，请结合本学期的学习，列举不少于5个Python语言的特点。</p><p><strong>简洁易读</strong>：代码清晰，使用缩进结构。</p><p><strong>跨平台</strong>：可在不同操作系统上运行。</p><p><strong>动态类型</strong>：变量类型在运行时确定。</p><p><strong>解释型语言</strong>：无需编译，直接运行。</p><p><strong>丰富的库</strong>：大量标准库和第三方库支持。</p><p>3.根据自己的理解，说明为什么应尽量从列表的尾部进行元素的添加与删除操作。</p><p><strong>时间复杂度为O(1)</strong>：在列表尾部添加或删除元素，不需要移动其他元素，操作时间固定。</p><p><strong>避免元素移动</strong>：从头部或中间添加/删除元素时，需要移动大量元素，时间复杂度为O(n)，效率低。</p><p>4.阐述说明Python语言编程时为什么要导入扩展库？导入的途径有哪些？</p><ol><li><strong>功能增强</strong>：扩展库提供了丰富的功能，避免重复造轮子，节省开发时间。</li><li><strong>简化代码</strong>：扩展库封装了复杂的功能，使用者可以直接调用简洁的接口，减少代码量。</li><li><strong>提高效率</strong>：许多扩展库经过优化，能提高程序的性能。</li></ol><p><strong>导入途径</strong>：</p><ol><li><strong><code>import</code></strong>：导入整个模块，使用时需要加模块名，例如 <code>import math</code>。</li><li><strong><code>from ... import ...</code></strong>：只导入模块中的某个部分，例如 <code>from math import sqrt</code>。</li><li><strong><code>import ... as ...</code></strong>：为模块指定别名，简化代码，例如 <code>import numpy as np</code>。</li></ol><p>5.<strong>变量</strong>：用于存储数据的命名位置。Python 是动态类型语言，变量不需要事先声明类型，类型由赋值时自动推导。</p><p><strong>数据类型</strong>：Python 支持多种数据类型，包括 <code>int</code>（整数）、<code>float</code>（浮点数）、<code>str</code>（字符串）、<code>list</code>（列表）、<code>tuple</code>（元组）、<code>dict</code>（字典）、<code>set</code>（集合）等。</p><p><strong>List（列表）</strong>：有序，可变，可以包含重复元素。{}</p><p><strong>Tuple（元组）</strong>：有序，不可变，通常用于表示不希望修改的数据。（）</p><p><strong>Dict（字典）</strong>：无序，由键值对组成，键是唯一的，适用于映射关系。{}</p><p><strong>Set（集合）</strong>：无序，不能包含重复元素，常用于去重或集合运算。{}</p><p>6.<strong>控制结构</strong></p><ul><li><strong>条件语句</strong>：<code>if</code>、<code>elif</code>、<code>else</code> 用于根据条件执行不同的代码块。</li><li><strong>循环语句</strong>：<code>for</code> 和 <code>while</code> 循环用来重复执行代码。<code>for</code> 用于遍历序列（如列表、字典等），<code>while</code> 用于基于条件的循环。</li><li><strong>循环控制</strong>：<code>break</code>、<code>continue</code> 和 <code>pass</code> 用于控制循环的执行。</li></ul><p>7.<strong>定义函数</strong>：通过 <code>def</code> 关键字定义函数，函数可以带参数、返回值。</p><p><strong>内置函数</strong>：Python 提供了许多常用的内置函数，如 <code>len()</code>、<code>max()</code>、<code>min()</code>、<code>range()</code> 等。</p><p>8.面向对象</p><p><strong>类与对象</strong>：Python 是面向对象的语言，可以通过 <code>class</code> 定义类。类是对象的蓝图，而对象是类的实例。</p><p><strong>继承</strong>：子类继承父类的属性和方法，能够扩展和重写父类的功能。</p><p><strong>多态与封装</strong>：多态使得不同的类可以以相同的方式调用，封装则通过访问控制保护数据。</p><p><strong>构造函数 <code>__init__</code></strong>：每次创建对象时调用，用于初始化对象的状态。</p><p>9.异常处理</p><ul><li><strong><code>try</code>、<code>except</code>、<code>else</code>、<code>finally</code></strong>：用于捕获和处理异常，避免程序崩溃。<code>finally</code> 块中的代码会始终执行，通常用于资源清理。</li><li><strong>自定义异常</strong>：可以通过继承 <code>Exception</code> 类自定义异常类型。</li></ul><p>10.字典推导式</p><p><strong>列表推导式</strong>：一种简洁的创建列表的方式，通常包含条件和表达式。</p><p><strong>字典推导式</strong>：类似于列表推导式，用于创建字典。</p><p>11.生成器和迭代器</p><p><strong>生成器</strong>：使用 <code>yield</code> 关键字创建的迭代器。生成器可以按需生成数据，避免一次性生成所有数据，节省内存。</p><p><strong>迭代器</strong>：Python 中的迭代器协议（<code>__iter__()</code> 和 <code>__next__()</code>），用于按序访问容器中的元素。</p><h1 id="真题解析"><a href="#真题解析" class="headerlink" title="真题解析"></a>真题解析</h1><ol><li><p>表达式[3] not in [1，3，4，5]的值为（  <strong>false</strong>    ）。</p></li><li><p>你认为“在编写Python程序时，不管一条语句有多长，都必须写在同一行中，不能换行。”这种观点对吗？（  <strong>不对</strong>    ）。</p></li><li><p>假设已导入模块re，那么表达式re.findall(‘\d{1,3}’,’a12b345ccc567890’)的结果为（ <strong>12,345,567，890</strong>   ）</p></li><li><p>已知vec=[[1，2]，[3，4]]，则表达式[col for row in vec for col in row]的值为（  <strong>[1, 2, 3, 4]</strong>    ）。</p></li><li><p>表达式max（[1，2，3]，[2，3，5]，[5，3，7，6]，[5，1，3，8，9]，key=len）的值为（   <strong>[5，1，3，8，9]</strong>    ）。</p></li><li><p>在导入模块re后，设s=’a s d e’，则re.sub(‘a|s|d|e’,’well’,s)的结果为（<strong>well well well well</strong>     ）。</p></li><li><p>s=’qlu，upc，jlu，pear，qinghua’，则s.split(‘，’)的输出结果是（ [<strong>‘qlu,upc,jlu,pear,qinghua’]</strong>        ）。</p></li><li><p>对于文本文件，使用Python的内置函数open（）以读模式成功打开后返回的文件对象（  <strong>可以</strong>  ）使用for循环直接迭代。</p></li><li><p>设f=lambda x，y，z：x+y<em>z，则print（f（1，2，3））的输出结果为（ <em>*7</em></em>）</p></li><li><p>导入re模块后，若ch=’aaa   bb c d e  fff   ’则执行语句：’ ’.join（ch.split( )）后的输出结果为（ <strong>‘aaa bb c d e fff’</strong>   ）。</p></li></ol><p>11.下面代码的运行后的结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def demo(a, b, c=3, d=100):</span><br><span class="line">    return sum((a, b, c, d))</span><br><span class="line"></span><br><span class="line">print(demo(1, 2, 3, 4))  # (1)</span><br><span class="line">print(demo(1, 2, d=3))   # (2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10，9</span><br></pre></td></tr></table></figure><p>解析：</p><p>因为<strong>如果函数的参数给了值的话，就用给的值。没给的话，就要用默认值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list2 = [5, 6, 7, 8, 9]</span><br><span class="line">print(list2[])       # (1)</span><br><span class="line">print(list2[2:])     # (2)</span><br><span class="line">print(list2[:-2])    # (3)</span><br><span class="line">print(list2[1:3])    # (4)</span><br><span class="line">print(list2[1] &lt;= 3 or list2[3] &gt; 5)  # (5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># (1) 错误：SyntaxError</span><br><span class="line"># (2) [7, 8, 9]</span><br><span class="line"># (3) [5, 6, 7]</span><br><span class="line"># (4) [6, 7]</span><br><span class="line"># (5) True</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解析：</p><p>因为在列表中没有index的话，是输出不了东西的</p><p>然后从前面开始分别是为0123…</p><p>从后面开始分别是-1-2-3….</p><p>然后【1:3】是不包括后面的，和for循环中的range一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import types</span><br><span class="line"></span><br><span class="line">class Car:</span><br><span class="line">    price = 100000                               # 定义类属性</span><br><span class="line">    def __init__(self, c):</span><br><span class="line">        self.color = c                           # 定义实例属性</span><br><span class="line"></span><br><span class="line">car1 = Car(&quot;Red&quot;)                                # 实例化对象</span><br><span class="line">car2 = Car(&quot;Blue&quot;)</span><br><span class="line">print(car1.color, Car.price)                     # 查看实例属性和类属性的值</span><br><span class="line">Car.price = 110000                               # 修改类属性</span><br><span class="line">Car.name = &#x27;QQ&#x27;                                  # 动态增加类属性</span><br><span class="line">car1.color = &quot;Yellow&quot;                            # 修改实例属性</span><br><span class="line">print(car2.color, Car.price, Car.name)</span><br><span class="line">print(car1.color, Car.price, Car.name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Red 100000</span><br><span class="line">Blue 110000 QQ</span><br><span class="line">Yellow 110000 QQ</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就不解释了，直接能看懂哈哈哈☺</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dcountry = &#123;</span><br><span class="line">    &quot;中国&quot;: &quot;北京&quot;,</span><br><span class="line">    &quot;美国&quot;: &quot;华盛顿&quot;,</span><br><span class="line">    &quot;法国&quot;: &quot;巴黎&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(list(Dcountry.values()))  # (1)</span><br><span class="line">print(list(Dcountry.keys()))    # (2)</span><br><span class="line">print(Dcountry.get(&quot;德国&quot;, &quot;伦敦&quot;))  # (3)</span><br><span class="line">print(Dcountry.get(&quot;美国&quot;, &quot;伦敦&quot;))  # (4)</span><br><span class="line"></span><br><span class="line">for key in Dcountry:  # (5)</span><br><span class="line">    print(key)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;北京&#x27;, &#x27;华盛顿&#x27;, &#x27;巴黎&#x27;]  # (1)</span><br><span class="line">[&#x27;中国&#x27;, &#x27;美国&#x27;, &#x27;法国&#x27;]  # (2)</span><br><span class="line">伦敦  # (3)</span><br><span class="line">华盛顿  # (4)</span><br><span class="line">中国</span><br><span class="line">美国</span><br><span class="line">法国  # (5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面的不解释，主要就是键值对，前面的为key 后面的为value</p><p><code>get</code> 方法用于获取字典中指定键的值。如果键不存在，则返回默认值</p><p>so,print(Dcountry.get(“德国”, “伦敦”))找不到key=德国所以return默认值伦敦</p><p>print(Dcountry.get(“美国”, “伦敦”))找到key=美国，返回他的value华盛顿</p><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p>1.在软件设计和实现时，用户登录模块必不可少。请使用python语言编程实现该功能，要求：每次登录提供3次机会，只有账户名和密码完全匹配才“登录成功！”，否则提示“请注意剩余尝试次数为X次”，超过3次，则提示“3次用户名或者密码均有误，请退出程序！”。（提示：用户名和密码可以提前自行设定好。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 设定用户名和密码</span><br><span class="line">username = &quot;admin&quot;</span><br><span class="line">password = &quot;123456&quot;</span><br><span class="line"></span><br><span class="line"># 最大尝试次数</span><br><span class="line">max_attempts = 3</span><br><span class="line"></span><br><span class="line"># 登录验证</span><br><span class="line">for attempt in range(max_attempts):</span><br><span class="line">    input_username = input(&quot;请输入用户名: &quot;)</span><br><span class="line">    input_password = input(&quot;请输入密码: &quot;)</span><br><span class="line"></span><br><span class="line">    if input_username == username and input_password == password:</span><br><span class="line">        print(&quot;登录成功！&quot;)</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        remaining_attempts = max_attempts - attempt - 1</span><br><span class="line">        if remaining_attempts &gt; 0:</span><br><span class="line">            print(f&quot;请注意，剩余尝试次数为&#123;remaining_attempts&#125; 次&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;3次用户名或者密码均有误，请退出程序！&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.编程实现对键盘接受的整数进行奇偶数判断。</p><p>要求：包括主函数和is­_odd()子函数，其中is­_odd（）函数，用于实现数值奇偶数判断，参数为整数，如果参数为奇数，返回true，否则返回false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 判断奇偶数的子函数</span><br><span class="line">def is_odd(num):</span><br><span class="line">    return num % 2 != 0</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    # 从键盘接受整数输入</span><br><span class="line">    try:</span><br><span class="line">        num = int(input(&quot;请输入一个整数: &quot;))</span><br><span class="line">        </span><br><span class="line">        # 判断奇偶数</span><br><span class="line">        if is_odd(num):</span><br><span class="line">            print(f&quot;&#123;num&#125; 是奇数&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;&#123;num&#125; 是偶数&quot;)</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&quot;请输入有效的整数&quot;)</span><br><span class="line"></span><br><span class="line"># 调用主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.中文里,有回文诗句、对联,如:”灵山大佛,佛大山灵”,”客上天然居,居然天上客”等等,都是美妙的符合正念倒念都一样的回文句；设n是一个任意自然数，如果n的各位数字反向排列所得自然数与n相等，则n称为回文数。从键盘输入5位数字，请编写程序判断这个数字是不是回文数（自行设置退出条件）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 判断回文数的函数</span><br><span class="line">def is_palindrome(num):</span><br><span class="line">    return str(num) == str(num)[::-1]</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    while True:</span><br><span class="line">        # 从键盘输入5位数字</span><br><span class="line">        try:</span><br><span class="line">            num = int(input(&quot;请输入一个5位数字（输入0退出程序）: &quot;))</span><br><span class="line">            </span><br><span class="line">            if num == 0:</span><br><span class="line">                print(&quot;程序退出&quot;)</span><br><span class="line">                break</span><br><span class="line">            </span><br><span class="line">            if 10000 &lt;= num &lt;= 99999:  # 判断是否为5位数字</span><br><span class="line">                if is_palindrome(num):</span><br><span class="line">                    print(f&quot;&#123;num&#125; 是回文数&quot;)</span><br><span class="line">                else:</span><br><span class="line">                    print(f&quot;&#123;num&#125; 不是回文数&quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(&quot;请输入一个有效的5位数字！&quot;)</span><br><span class="line">        except ValueError:</span><br><span class="line">            print(&quot;输入无效，请输入一个数字！&quot;)</span><br><span class="line"></span><br><span class="line"># 调用主函数</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.编写程序，在D盘根目录下创建一个文本文件test.txt，并向其中写入字符串“Beautiful is better than ugly.Explicit is better than implicit.”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 文件路径</span><br><span class="line">file_path = &quot;D:/test.txt&quot;</span><br><span class="line"></span><br><span class="line"># 要写入的字符串</span><br><span class="line">text = &quot;Beautiful is better than ugly.\nExplicit is better than implicit.&quot;</span><br><span class="line"></span><br><span class="line"># 打开文件并写入</span><br><span class="line">with open(file_path, &quot;w&quot;) as file:</span><br><span class="line">    file.write(text)</span><br><span class="line"></span><br><span class="line">print(&quot;文件已成功创建并写入内容。&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.\1. IT时代信息安全更为重要，无论是国家安全领域、商业领域还是个人信息都要有一定的保护措施。利用python课程中所学知识，批量产生50个人的信息，每个人的信息内容由以下字段组成：</p><div class="table-container"><table><thead><tr><th>姓名（XM）</th><th>性别（XB）</th><th>身份证号（ID）</th><th>电话号码（TEL)</th><th>家庭住址（ADRESS）</th></tr></thead><tbody><tr><td>XXX</td><td>男</td><td>3709……</td><td>136……</td><td>aaaaaaaaaaaaaaaa</td></tr><tr><td>YYY</td><td>女</td><td>3701……</td><td>184……</td><td>bbbbbbbbbbbbbbbb</td></tr></tbody></table></div><p>身份证号和电话号码长度按实际长度产生，其它字段信息长度自行设定，编写程序完成以下要求：</p><p>（1）按照凯撒加密算法对产生的每项信息进行加密。</p><p>（2）把加密后每个人的信息写入到excel文件中，每一行存储一个人的信息。</p><p>（3）把加密后每个人的信息写入到写入到SQLite数据库中，每条记录存储一个人的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import sqlite3</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># 凯撒加密函数</span><br><span class="line">def caesar_encrypt(text, shift=3):</span><br><span class="line">    return &#x27;&#x27;.join([chr((ord(char) - ord(&#x27;a&#x27;) + shift) % 26 + ord(&#x27;a&#x27;)) if char.isalpha() else char for char in text])</span><br><span class="line"></span><br><span class="line"># 生成随机信息</span><br><span class="line">def generate_info():</span><br><span class="line">    name = random.choice([&#x27;张伟&#x27;, &#x27;李娜&#x27;, &#x27;王磊&#x27;, &#x27;刘敏&#x27;, &#x27;陈静&#x27;])</span><br><span class="line">    gender = random.choice([&#x27;男&#x27;, &#x27;女&#x27;])</span><br><span class="line">    id_number = &#x27;&#x27;.join([str(random.randint(0, 9)) for _ in range(18)])</span><br><span class="line">    tel = &#x27;1&#x27; + str(random.randint(3, 9)) + &#x27;&#x27;.join([str(random.randint(0, 9)) for _ in range(9)])</span><br><span class="line">    address = &#x27;&#x27;.join(random.choices(&#x27;abcdefghijklmnopqrstuvwxyz0123456789&#x27;, k=15))</span><br><span class="line">    return [name, gender, id_number, tel, address]</span><br><span class="line"></span><br><span class="line"># 生成50条数据</span><br><span class="line">people_info = [generate_info() for _ in range(50)]</span><br><span class="line"></span><br><span class="line"># 对数据进行凯撒加密</span><br><span class="line">shift = 3</span><br><span class="line">encrypted_info = [[caesar_encrypt(field, shift) for field in person] for person in people_info]</span><br><span class="line"></span><br><span class="line"># 写入Excel</span><br><span class="line">def write_to_excel(data):</span><br><span class="line">    df = pd.DataFrame(data, columns=[&#x27;姓名&#x27;, &#x27;性别&#x27;, &#x27;身份证号&#x27;, &#x27;电话号码&#x27;, &#x27;家庭住址&#x27;])</span><br><span class="line">    df.to_excel(&#x27;encrypted_people_info.xlsx&#x27;, index=False)</span><br><span class="line"></span><br><span class="line"># 写入SQLite</span><br><span class="line">def write_to_sqlite(data):</span><br><span class="line">    conn = sqlite3.connect(&#x27;people_info.db&#x27;)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(&#x27;&#x27;&#x27;</span><br><span class="line">    CREATE TABLE IF NOT EXISTS people (</span><br><span class="line">        name TEXT, gender TEXT, id_number TEXT, phone_number TEXT, address TEXT)</span><br><span class="line">    &#x27;&#x27;&#x27;)</span><br><span class="line">    cursor.executemany(&#x27;&#x27;&#x27;</span><br><span class="line">    INSERT INTO people (name, gender, id_number, phone_number, address)</span><br><span class="line">    VALUES (?, ?, ?, ?, ?)</span><br><span class="line">    &#x27;&#x27;&#x27;, data)</span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"># 执行写入操作</span><br><span class="line">write_to_excel(encrypted_info)</span><br><span class="line">write_to_sqlite(encrypted_info)</span><br><span class="line"></span><br><span class="line">print(&quot;数据已成功写入 Excel 和 SQLite 数据库。&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.π（圆周率）是一个无理数，即无限不循环小数。精确求解圆周率π是几何学、物理学和很多工程学科的关键。对π的精确求解曾经是数学历史上一直难以解决的问题之一，因为π无法用任何精确公式表示，在电子计算机出现以前，π只能通过一些近似公式的求解得到，如BBP公式。结合自己了解的数学方法和Python编程技术，设计一种近似计算π的程序，并给出设计步骤和主要思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"># 1. 使用莱布尼茨级数法近似计算 π</span><br><span class="line">def leibniz_formula(n_terms):</span><br><span class="line">    pi_approx = 0</span><br><span class="line">    for i in range(n_terms):</span><br><span class="line">        pi_approx += ((-1) ** i) / (2 * i + 1)</span><br><span class="line">    return 4 * pi_approx</span><br><span class="line"></span><br><span class="line"># 2. 使用蒙特卡罗方法近似计算 π</span><br><span class="line">def monte_carlo_pi(n_points):</span><br><span class="line">    inside_circle = 0</span><br><span class="line">    for _ in range(n_points):</span><br><span class="line">        x = random.random()</span><br><span class="line">        y = random.random()</span><br><span class="line">        # 计算点是否在单位圆内</span><br><span class="line">        if x**2 + y**2 &lt;= 1:</span><br><span class="line">            inside_circle += 1</span><br><span class="line">    return 4 * inside_circle / n_points</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    n_terms = 1000000  # 莱布尼茨级数法迭代次数</span><br><span class="line">    n_points = 1000000  # 蒙特卡罗方法随机点数</span><br><span class="line"></span><br><span class="line">    # 使用莱布尼茨级数法计算 π</span><br><span class="line">    pi_leibniz = leibniz_formula(n_terms)</span><br><span class="line">    print(f&quot;莱布尼茨级数法计算 π：&#123;pi_leibniz&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 使用蒙特卡罗方法计算 π</span><br><span class="line">    pi_monte_carlo = monte_carlo_pi(n_points)</span><br><span class="line">    print(f&quot;蒙特卡罗方法计算 π：&#123;pi_monte_carlo&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\pi = 4 \times \left(1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \dots \right)</script><p>7.个滴滴快车是怎么计费的？请你用所学Python语言编写一个计费程序。根据实际情况，回答问题。</p><p>（一）收集、分析数据，运用数理思维建模</p><p>登录滴滴出行官网，得到了如下信息，即“滴滴快车（普通型）计价规则”：</p><p><img src="C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>小萌同学19：33从“济南泉城广场”到“千佛山景区”乘坐滴滴快车（普通车型），里程4.1公里，时长约21分钟，按照表中的计费规则，此次出行应该支付的车费是：车费=8+（4.1-3.3）×1.35+（21-9）×0.2=9.68。</p><p>假设Tot1表示时长费，Tot2表示里程费，S表示实际里程，T表示实际时长，Cost表示应支付费用。运用数学解析式归纳出计费公式。</p><p>答:</p><p>（二）运用算法描述方法将问题解决步骤化</p><p>明晰了滴滴快车车费的计算方法之后，设计求解滴滴快车普通时段车费的算法，并用IPO算法设计法和流程图的方式表述出来。</p><p><img src="C:/Users/ikeife/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"> 1、IPO（输入-处理-输出）算法描述：</p><p>I：             </p><p>P：            </p><p>O：            </p><p>2、流程图描述：如图所示，请添加序号（1）  </p><p>~（5）处的语句。</p><p>（1）：            </p><p>（2）：            </p><p>（3）：            </p><p>（4）：            </p><p>（5）：            </p><p>（三）编写、调试、运行程序解决问题。</p><p>根据滴滴快车计价规则，可以推导出车费计算的公式：</p><ol><li><strong>基本费用</strong>：8 元</li><li><strong>里程费用</strong>：如果实际行驶里程超过 3.3 公里，则超出的部分按每公里 1.35 元计费。即，实际里程 S 大于 3.3 时，超出部分按 <code>(S - 3.3) * 1.35</code> 计算。</li><li><strong>时长费用</strong>：如果实际时长超过 9 分钟，则超出的部分按每分钟 0.2 元计费。即，实际时长 T 大于 9 分钟时，超出部分按 <code>(T - 9) * 0.2</code> 计算。</li></ol><p>根据这些规则，最终的车费可以通过以下公式计算：</p><script type="math/tex; mode=display">Cost=8+(S−3.3)×1.35+(T−9)×0.2\</script><ol><li><p><strong>IPO（输入-处理-输出）算法描述</strong>：</p><ul><li><strong>I（输入）</strong>：输入实际的行驶里程 <code>S</code> 和实际的时长 <code>T</code>。</li><li><strong>P（处理）</strong>：根据上述的计费规则，计算里程费用和时长费用，并求出总车费。</li><li><strong>O（输出）</strong>：输出应支付的车费。</li></ul></li><li><p><strong>流程图描述</strong>：</p><p>以下是步骤化的描述：</p><ul><li><strong>(1)</strong>：输入实际里程 <code>S</code> 和时长 <code>T</code>。</li><li><strong>(2)</strong>：计算里程费用：如果实际里程 <code>S</code> 大于 3.3 公里，则计算 <code>(S - 3.3) * 1.35</code>；否则里程费用为 0。</li><li><strong>(3)</strong>：计算时长费用：如果实际时长 <code>T</code> 大于 9 分钟，则计算 <code>(T - 9) * 0.2</code>；否则时长费用为 0。</li><li><strong>(4)</strong>：计算总费用：<code>Cost = 8 + 里程费用 + 时长费用</code>。</li><li><strong>(5)</strong>：输出车费 <code>Cost</code>。</li></ul></li></ol><p>根据上面的计费公式和流程，下面是一个用 Python 编写的滴滴快车车费计算程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> calculate_fare(distance, duration):</span><br><span class="line">    # 基本费用</span><br><span class="line">    base_fare = 8.0</span><br><span class="line">    </span><br><span class="line">    # 计算里程费用</span><br><span class="line">    if distance &gt; 3.3:</span><br><span class="line">        distance_fare = (distance - 3.3) * 1.35</span><br><span class="line">    else:</span><br><span class="line">        distance_fare = 0</span><br><span class="line">    </span><br><span class="line">    # 计算时长费用</span><br><span class="line">    if duration &gt; 9:</span><br><span class="line">        duration_fare = (duration - 9) * 0.2</span><br><span class="line">    else:</span><br><span class="line">        duration_fare = 0</span><br><span class="line">    </span><br><span class="line">    # 总车费</span><br><span class="line">    total_fare = base_fare + distance_fare + duration_fare</span><br><span class="line">    return total_fare</span><br><span class="line"></span><br><span class="line"># 获取用户输入的实际里程和时长</span><br><span class="line">distance = float(input(&quot;请输入实际行驶里程（公里）：&quot;))</span><br><span class="line">duration = float(input(&quot;请输入实际行驶时长（分钟）：&quot;))</span><br><span class="line"></span><br><span class="line"># 计算车费</span><br><span class="line">fare = calculate_fare(distance, duration)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">print(f&quot;此次出行的车费为：&#123;fare:.2f&#125; 元&quot;)</span><br></pre></td></tr></table></figure><p>假设用户输入：</p><ul><li>实际里程：<code>4.1</code> 公里</li><li>实际时长：<code>21</code> 分钟</li></ul><p>程序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制代码请输入实际行驶里程（公里）：4.1</span><br><span class="line">请输入实际行驶时长（分钟）：21</span><br><span class="line">此次出行的车费为：9.68 元</span><br></pre></td></tr></table></figure><h1 id="基础知识补充"><a href="#基础知识补充" class="headerlink" title="基础知识补充"></a>基础知识补充</h1><p>1.eval()会执行字符串中的表达式</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(500/10)</span><br><span class="line">输出</span><br><span class="line">50.0</span><br></pre></td></tr></table></figure><p>2.在列表中，空格也是占一个字符位置的，然后[3:8]前面的闭口的，后面是开口的，即3-7</p><p>3.Python 提供的一个元素全为字符串的列表写入文件的函数是</p><p><code>writelines()</code> 方法将一个列表的所有字符串写入文件</p><p><code>readlines()</code>是读取的方法，把</p><p>4.字典的键必须是不可变类型（例如，元组、字符串），而列表是可变的</p><p>5.jieba库应用</p><p>利用 Python 内置函数及 jieba 库中已有函数，计算字符串 s 的中文字符个数及中文词语 个数。</p><p>import jieba s = “中国举办冬奥会”</p><p>n = <strong><strong>__</strong></strong></p><p>m = <strong><strong>__</strong></strong></p><p>print(“中文字符数为{}，中文词语数为{}。”.format(n, m))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line">s = &quot;中国举办冬奥会&quot;</span><br><span class="line"></span><br><span class="line">n = len([ch for ch in s if &#x27;\u4e00&#x27; &lt;= ch &lt;= &#x27;\u9fa5&#x27;])  # 统计中文字符数</span><br><span class="line">m = len(list(jieba.cut(s)))  # 统计中文词语数</span><br><span class="line"></span><br><span class="line">print(&quot;中文字符数为&#123;&#125;，中文词语数为&#123;&#125;。&quot;.format(n, m))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jieba.lcut()返回一个列表，而不是生成器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import jieba</span><br><span class="line">text = &quot;我来到北京清华大学&quot;</span><br><span class="line">words = jieba.lcut(text)</span><br><span class="line">print(words)  # 返回列表</span><br></pre></td></tr></table></figure><p>jieba.posseg.cut()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import jieba.posseg as pseg</span><br><span class="line">text = &quot;我来到北京清华大学&quot;</span><br><span class="line">words = pseg.cut(text)</span><br><span class="line">for word, flag in words:</span><br><span class="line">    print(f&quot;&#123;word&#125; &#123;flag&#125;&quot;)</span><br></pre></td></tr></table></figure><p>jieba.analyse.extract_tags()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import jieba.analyse</span><br><span class="line">text = &quot;我爱北京天安门，天安门是北京的标志性建筑。&quot;</span><br><span class="line">keywords = jieba.analyse.extract_tags(text, topK=5, withWeight=False)</span><br><span class="line">print(keywords)  # 返回前5个关键词</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>jieba.cut()</code></strong>: 精确模式分词。</p><p><strong><code>jieba.lcut()</code></strong>: 返回列表形式的精确模式分词。</p><p><strong><code>jieba.cut_for_search()</code></strong>: 搜索引擎模式分词。</p><p><strong><code>jieba.posseg.cut()</code></strong>: 词性标注分词。</p><p><strong><code>jieba.load_userdict()</code></strong>: 加载自定义词典。</p><p><strong><code>jieba.analyse.extract_tags()</code></strong>: 提取关键词。</p><p><strong><code>jieba.add_word()</code></strong>: 动态添加新词。</p><p><strong><code>jieba.del_word()</code></strong>: 删除词典中的词。</p><p>6.type函数</p><p>type函数获取里面数据的类型</p><p><code>val = (3)</code> 定义的是一个包含单一元素 <code>3</code> 的元组，但元组中的单个元素没有使用逗号，Python 会将其视为整数 <code>3</code>，因此它的类型是 <code>int</code>。</p><p>如果是多个元素，Python 会正确地识别为元组。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = (3, 4)</span><br></pre></td></tr></table></figure><p>此时，<code>val</code> 是一个包含两个元素 <code>3</code> 和 <code>4</code> 的元组，类型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(val)  # 输出 &lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：当定义元组时，至少需要一个逗号来表示这是一个元组。即使只有一个元素，但只要加上逗号，它就会被识别为元组。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = (3,)  # 正确的单元素元组</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>val</code> 仍然是一个元组，类型是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(val)  # 输出 &lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure><p>如果没有逗号，<code>val = (3)</code> 会被当作普通的括号表达式，<code>val</code> 只是一个整数 <code>3</code>。</p><p>7.</p><p>对于 <code>ls = list(range(5))</code>，<code>print(ls)</code> 的输出是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>输入列表为xxxx</p><p>8.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for s in &quot;python&quot;:</span><br><span class="line">    if s == &quot;h&quot;:</span><br><span class="line">        continue</span><br><span class="line">    print(s, end=&quot;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码等于在遇到<code>h</code>的时候跳过，然后print</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyhon</span><br></pre></td></tr></table></figure><p>9.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = 1</span><br><span class="line"></span><br><span class="line">def func(a, b):</span><br><span class="line">    n = b</span><br><span class="line">    return a * b</span><br><span class="line"></span><br><span class="line">s = func(&quot;Hello~&quot;, 2)</span><br><span class="line"></span><br><span class="line">print(s, n)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello~Hello~ 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>因为n=2是局部变量，n=1是全局变量</strong></p><p> 10.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def func(s, i, j):</span><br><span class="line">    if i &lt; j:</span><br><span class="line">        func(s, i+1, j-1)  # 递归调用</span><br><span class="line">        s[i], s[j] = s[j], s[i]  # 交换元素</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    a = [10, 6, 23, -90, 0, 3]</span><br><span class="line">    func(a, 0, len(a)-1)  # 调用函数进行交换</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是找到规律</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[3, 0, -90, 23, 6, 10]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>递归</strong>：每次递归将 <code>i</code> 和 <code>j</code> 向中间靠拢，直到 <code>i &gt;= j</code>。</li><li><strong>交换</strong>：在递归返回时，交换 <code>i</code> 和 <code>j</code> 位置的元素，直到列表被反转。</li></ol><ul><li><code>func</code> 函数使用递归和回溯来实现反转。</li><li>最终输出的结果是反转后的列表。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/python/">python</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/python/">python</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/10/python2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>大数据期末复习</title>
      <link>https://blog.tokenlen.top/2024/12/08/bigdata/</link>
      <guid>https://blog.tokenlen.top/2024/12/08/bigdata/</guid>
      <pubDate>Sat, 07 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;大数据的四个特点：数据量大，数据类型繁多，处理速度快和价值密度低。</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>大数据的四个特点：数据量大，数据类型繁多，处理速度快和价值密度低。 </p><p>大数据对科学研究的影响：</p><p>第一种范式：实验科学， 第二种范式：理论科学，第三种范式：计算科学，第 四种范式：数据密集型科学。</p><p>云计算的关键技术包括虚拟化，分布式存储，分布式计算和多租户等</p><p>大数据和云计算物联网之间的关系：</p><p>大数据、云计算和物联网（IoT）紧密相关，互为支撑：</p><ol><li><strong>物联网与大数据</strong>：物联网设备生成海量数据，需要大数据技术进行存储、处理和分析，提取有价值的信息。</li><li><strong>物联网与云计算</strong>：云计算提供弹性计算和存储资源，支持物联网设备的数据存储、实时分析和处理。</li><li><strong>大数据与云计算</strong>：云计算为大数据提供基础设施支持，提供存储、计算能力和弹性扩展，使大数据处理更加高效。</li></ol><h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="1-MapReduce工作流程的描述"><a href="#1-MapReduce工作流程的描述" class="headerlink" title="1. MapReduce工作流程的描述"></a>1. <strong>MapReduce工作流程的描述</strong></h2><p>MapReduce工作流程主要分为两个阶段：Map阶段和Reduce阶段。</p><ul><li><strong>Map阶段</strong>：在Map阶段，输入数据被分为多个片段，每个片段由一个Map任务处理。Map任务将输入数据（键值对）映射为中间结果（也为键值对）。每个Map任务输出的中间结果都会被按键进行分组，分组后的结果会被传递给Reduce阶段。</li><li><strong>Shuffle阶段</strong>：Map阶段完成后，Shuffle阶段会按照键对Map的输出进行排序和分组，确保同一键的值被发送到同一台Reducer机器上。此过程是MapReduce中的一个重要过程，称为Shuffle。</li><li><strong>Reduce阶段</strong>：在Reduce阶段，系统会接收到Map输出的分组结果，并对每个键的所有值进行处理，通常是进行聚合操作，如求和、求平均等，最后输出结果。</li></ul><h2 id="2-Flink核心组件栈的层次及具体内容"><a href="#2-Flink核心组件栈的层次及具体内容" class="headerlink" title="2. Flink核心组件栈的层次及具体内容"></a>2. <strong>Flink核心组件栈的层次及具体内容</strong></h2><ul><li><p><strong>Flink Runtime</strong>：执行任务调度和资源管理。</p></li><li><p><strong>Flink API</strong>：包括流处理的DataStream API和批处理的DataSet API，Table API/SQL支持声明性查询。</p></li><li><p><strong>Connectors</strong>：用于连接外部数据源和数据接收端（如Kafka、HDFS等）。</p></li><li><p><strong>State &amp; Time Layer</strong>：用于处理有状态计算及时间处理（如事件时间和窗口操作）。</p></li><li><p><strong>Fault Tolerance &amp; Checkpointing</strong>：确保作业容错性和状态一致性。</p><ul><li><p>内部容错机制包括：</p><ul><li>at-least-once 至少执行一次</li><li>exactully-once 仅执行一次（跟storm一样）</li></ul><p>还有手动的checkpoint检查机制（spark streaming一样） </p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+     +-------------------+      +-------------------+</span><br><span class="line">|    Client         |----&gt;|    JobManager     |-----&gt;|   TaskManager     |</span><br><span class="line">+-------------------+     +-------------------+      +-------------------+</span><br><span class="line">       |                        |                        |</span><br><span class="line">       v                        v                        v</span><br><span class="line">+-------------------+    +-------------------+     +-------------------+</span><br><span class="line">|   Data Source     |    |    Task Execution  |     |   State &amp; Fault    |</span><br><span class="line">|  (Kafka, HDFS,    |    |   (Map, Reduce)    |     |   Tolerance       |</span><br><span class="line">|    DB, etc.)      |    |                    |     |                   |</span><br><span class="line">+-------------------+    +-------------------+     +-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-YARN架构及MapReduce程序执行过程"><a href="#3-YARN架构及MapReduce程序执行过程" class="headerlink" title="3. YARN架构及MapReduce程序执行过程"></a>3. <strong>YARN架构及MapReduce程序执行过程</strong></h2><ul><li><p><strong>YARN架构</strong>： YARN（Yet Another Resource Negotiator）是<strong>Hadoop的资源管理层</strong>，负责资源调度和管理。YARN的主要组件有：</p><ul><li><strong>ResourceManager</strong>：负责集群资源的管理和调度。</li><li><strong>NodeManager</strong>：每个节点上的代理，负责向ResourceManager汇报节点的资源使用情况，并管理任务的执行。</li><li><strong>ApplicationMaster</strong>：每个应用程序（例如MapReduce）会有一个独立的ApplicationMaster，负责与ResourceManager协作，获取资源并管理作业的生命周期。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+        +-------------------+       +-------------------+</span><br><span class="line">|    Client         |-------&gt;|  ResourceManager  |&lt;-----&gt;|  NodeManager      |</span><br><span class="line">|  (Submit Job)     |        |   (Resource Mgmt) |       |   (Task Execution)|</span><br><span class="line">+-------------------+        +-------------------+       +-------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                          +---------------------+</span><br><span class="line">                          |   ApplicationMaster |</span><br><span class="line">                          |    (App Life Cycle) |</span><br><span class="line">                          +---------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                         +------------------------+</span><br><span class="line">                         |   Task Execution       |</span><br><span class="line">                         |   (Map/Reduce Tasks)   |</span><br><span class="line">                         +------------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                          +---------------------+</span><br><span class="line">                          |    Shuffle &amp; Sort   |</span><br><span class="line">                          +---------------------+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                           +---------------------+</span><br><span class="line">                           |   HDFS Output       |</span><br><span class="line">                           +---------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>MapReduce程序执行过程</strong>：</p><ol><li><p><strong>提交作业</strong>：用户提交MapReduce作业，JobClient与ResourceManager通信，申请资源。</p></li><li><p><strong>资源分配</strong>：ResourceManager分配资源，启动ApplicationMaster。</p></li><li><p><strong>Map阶段</strong>：ApplicationMaster向NodeManager请求启动Map任务，Map任务处理输入数据并生成中间结果。</p></li><li><p><strong>Shuffle阶段</strong>：Map任务完成后，进行数据的shuffle和排序，保证每个Reduce任务处理的数据是同一键的所有值。</p></li><li><p><strong>Reduce阶段</strong>：Reducer处理Map输出的中间结果，完成最终的数据计算。</p></li><li><p><strong>作业完成</strong>：所有任务完成后，ResourceManager会收集任务的状态，标记作业结束。</p></li></ol></li></ul><pre><code>  总结：YARN架构包括ResourceManager、NodeManager、ApplicationMaster三个主要组件。</code></pre><p>  ResourceManager负责资源调度，NodeManager负责管理节点资源，ApplicationMaster负责管理每个应用的生命周期。</p><p>  MapReduce作业执行时，ApplicationMaster请求资源并启动Map、Shuffle、Reduce任务，NodeManager负责执行具体任务。</p><h2 id="4-Hadoop系统要求、安装准备和配置文件介绍"><a href="#4-Hadoop系统要求、安装准备和配置文件介绍" class="headerlink" title="4. Hadoop系统要求、安装准备和配置文件介绍"></a>4. <strong>Hadoop系统要求、安装准备和配置文件介绍</strong></h2><ul><li><strong>系统要求</strong>： Hadoop运行在分布式环境下，通常需要多个节点。每个节点至少需要安装Java（推荐使用JDK 8或更高版本）。节点之间需要通过SSH进行通信。</li><li><strong>安装准备</strong>：<ul><li>下载并解压Hadoop发行包。</li><li>配置Java环境变量。</li><li>配置Hadoop配置文件，如<code>core-site.xml</code>、<code>hdfs-site.xml</code>、<code>mapred-site.xml</code>和<code>yarn-site.xml</code>。</li></ul></li><li><strong>配置文件介绍</strong>：<ul><li><code>core-site.xml</code>：配置Hadoop核心服务，如HDFS文件系统的URI。</li><li><code>hdfs-site.xml</code>：配置HDFS的具体设置，如数据存储路径、副本数等。</li><li><code>mapred-site.xml</code>：配置MapReduce作业的相关设置。</li><li><code>yarn-site.xml</code>：配置YARN的资源管理和任务调度。</li></ul></li></ul><h1 id="大数据概念"><a href="#大数据概念" class="headerlink" title="大数据概念"></a>大数据概念</h1><h3 id="三次信息浪潮及核心问题："><a href="#三次信息浪潮及核心问题：" class="headerlink" title="三次信息浪潮及核心问题："></a>三次信息浪潮及核心问题：</h3><ol><li><strong>第一次浪潮</strong>：计算机引入，解决了自动化数据处理问题。</li><li><strong>第二次浪潮</strong>：互联网普及，解决了信息传递和共享问题。</li><li><strong>第三次浪潮</strong>：大数据、物联网、云计算兴起，解决了数据存储、处理、分析和价值提取问题。</li></ol><h3 id="大数据4V："><a href="#大数据4V：" class="headerlink" title="大数据4V："></a>大数据4V：</h3><ol><li><strong>Volume</strong>：数据量大。</li><li><strong>Velocity</strong>：数据生成速度快。</li><li><strong>Variety</strong>：数据种类多。</li><li><strong>Veracity</strong>：数据真实性。</li></ol><h2 id="大数据特点"><a href="#大数据特点" class="headerlink" title="大数据特点"></a>大数据特点</h2><ol><li><strong>数据量大</strong>：数据规模庞大，通常以TB、PB为单位。</li><li><strong>数据类型繁多</strong>：包括结构化、半结构化和非结构化数据。</li><li><strong>处理速度快</strong>：实时处理或近实时处理数据。</li><li><strong>价值密度低</strong>：数据中的有用信息较少。</li></ol><h3 id="大数据技术层面："><a href="#大数据技术层面：" class="headerlink" title="大数据技术层面："></a>大数据技术层面：</h3><ol><li><strong>数据采集层</strong>：获取原始数据。</li><li><strong>数据存储层</strong>：存储数据，常用HDFS、NoSQL。</li><li><strong>数据处理层</strong>：数据清洗与分析，使用MapReduce、Spark。</li><li><strong>数据分析层</strong>：高级分析与建模，使用机器学习等。</li><li><strong>数据应用层</strong>：业务应用，如推荐系统、预测分析。</li></ol><h3 id="典型计算模式："><a href="#典型计算模式：" class="headerlink" title="典型计算模式："></a>典型计算模式：</h3><ol><li><strong>批处理模式</strong>：Hadoop MapReduce。</li><li><strong>流处理模式</strong>：Kafka、Flink。</li><li><strong>混合处理模式</strong>：Spark。</li></ol><h3 id="三者关系："><a href="#三者关系：" class="headerlink" title="三者关系："></a>三者关系：</h3><ul><li><strong>物联网</strong>生成数据。</li><li><strong>大数据</strong>处理、分析数据。</li><li><strong>云计算</strong>提供存储和计算资源。</li></ul><h2 id="云计算的关键："><a href="#云计算的关键：" class="headerlink" title="云计算的关键："></a>云计算的关键：</h2><p>包括<strong>虚拟化</strong>、<strong>分布式存储</strong>、<strong>分布式计算</strong>和<strong>多租户</strong>技术。</p><h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h3 id="Hadoop项目架构图-（画图）"><a href="#Hadoop项目架构图-（画图）" class="headerlink" title="Hadoop项目架构图 （画图）"></a>Hadoop项目架构图 （画图）</h3><p><strong>这个感觉必考</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------+</span><br><span class="line">|        Client Application  |</span><br><span class="line">+----------------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------------------------+</span><br><span class="line">|      ResourceManager        |  </span><br><span class="line">+----------------------------+</span><br><span class="line">           |</span><br><span class="line">           v</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">|        NodeManager         | &lt;--&gt; |         HDFS            |</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">           |                                 |</span><br><span class="line">           v                                 v</span><br><span class="line">+----------------------------+       +-------------------------+</span><br><span class="line">|     JobHistoryServer       | &lt;--&gt; |       HDFS NameNode      |</span><br><span class="line">+----------------------------+       +-------------------------+</span><br></pre></td></tr></table></figure><h3 id="Hadoop组件功能：-必考"><a href="#Hadoop组件功能：-必考" class="headerlink" title="Hadoop组件功能：(必考)"></a>Hadoop组件功能：(必考)</h3><ol><li><strong>HDFS</strong>：分布式文件系统，存储大数据。</li><li><strong>MapReduce</strong>：处理大规模数据集，基于分布式计算。</li><li><strong>YARN (Yet Another Resource Negotiator)</strong>：资源管理框架，管理集群资源。</li><li><strong>JobHistoryServer</strong>：存储和查看MapReduce任务的历史信息。</li><li><strong>ResourceManager</strong>：负责资源调度和分配。</li><li><strong>NodeManager</strong>：管理单个节点的资源，执行任务。</li><li><strong>Zookeeper</strong>：协调分布式系统中的分布式应用。</li><li><strong>HBase</strong>：一个分布式、可扩展的NoSQL数据库。</li><li><strong>Hive</strong>：基于Hadoop的数据仓库，支持SQL查询。</li><li><strong>Pig</strong>：为大数据处理提供更高层次的抽象，类似SQL。</li><li><strong>Mahout</strong>：机器学习算法库。</li><li><strong>Sqoop</strong>：用于在Hadoop与关系型数据库之间传输数据。</li><li><strong>Flume</strong>：用于数据流的采集、聚合和传输。</li><li><strong>Ambari</strong>：Hadoop集群的管理工具。</li><li><strong>MapReduce</strong>：分布式数据处理框架。</li></ol><h3 id="Hadoop特性："><a href="#Hadoop特性：" class="headerlink" title="Hadoop特性："></a>Hadoop特性：</h3><ol><li><strong>可扩展性</strong>：支持PB级别的数据存储。</li><li><strong>容错性</strong>：数据复制，节点失败时数据不丢失。</li><li><strong>高性能</strong>：支持并行计算，大数据处理效率高。</li><li><strong>经济性</strong>：开源，低成本。</li></ol><h3 id="Hadoop集群节点类型："><a href="#Hadoop集群节点类型：" class="headerlink" title="Hadoop集群节点类型："></a>Hadoop集群节点类型：</h3><ol><li><p><strong>NameNode</strong>：管理HDFS元数据，负责文件系统的命名和目录管理。</p></li><li><p><strong>DataNode</strong>：存储实际数据，执行数据读取和写入操作。</p></li><li><p><strong>ResourceManager</strong>：管理和调度集群资源。</p></li><li><p><strong>NodeManager</strong>：管理每个节点上的资源和任务执行。</p></li><li><p><strong>JobHistoryServer</strong>：保存MapReduce作业的历史信息。</p><h2 id="Hadoop伪分布式安装过程："><a href="#Hadoop伪分布式安装过程：" class="headerlink" title="Hadoop伪分布式安装过程："></a><strong>Hadoop伪分布式安装过程</strong>：</h2></li></ol><ul><li><strong>core-site.xml</strong>：配置Hadoop的核心设置，如文件系统、默认的文件路径等。</li><li><strong>hdfs-site.xml</strong>：配置HDFS的设置，如块大小、复制因子、NameNode和DataNode的地址等。</li></ul><h3 id="SecondaryNameNode："><a href="#SecondaryNameNode：" class="headerlink" title="SecondaryNameNode："></a><strong>SecondaryNameNode</strong>：</h3><ul><li>解决EditLog过大问题，通过定期合并EditLog和FsImage，减少EditLog大小。</li></ul><h3 id="SecondaryNameNode工作原理："><a href="#SecondaryNameNode工作原理：" class="headerlink" title="SecondaryNameNode工作原理："></a>SecondaryNameNode工作原理：</h3><ol><li><strong>合并过程</strong>：SecondaryNameNode定期检查EditLog文件。如果EditLog有新的内容，它会将EditLog与当前的FsImage合并，并生成一个新的FsImage文件。</li><li><strong>更新FsImage</strong>：合并后，新的FsImage会被传回给NameNode，更新HDFS的元数据。</li><li><strong>清空EditLog</strong>：完成合并后，EditLog文件被清空，防止其过大。</li></ol><h1 id="Hdfs"><a href="#Hdfs" class="headerlink" title="Hdfs"></a>Hdfs</h1><h2 id="hdfs结构"><a href="#hdfs结构" class="headerlink" title="hdfs结构"></a>hdfs结构</h2><ul><li><strong>块</strong>：大数据文件被切分为多个固定大小的块。</li><li><strong>名称节点（NameNode）</strong>：管理文件系统的元数据。</li><li><strong>数据节点（DataNode）</strong>：实际存储数据块的节点。</li><li><strong>第二名称节点（SecondaryNameNode）</strong>：帮助减轻NameNode的负担，通过定期合并编辑日志来创建文件系统的检查点。</li></ul><h2 id="HDFS冗余数据保存策略："><a href="#HDFS冗余数据保存策略：" class="headerlink" title="HDFS冗余数据保存策略："></a><strong>HDFS冗余数据保存策略</strong>：</h2><p>默认复制因子为3，确保数据冗余存储，避免丢失。</p><ul><li><strong>数据复制策略</strong>：第一个副本存储在写请求发起的DataNode上，第二个副本存储在<strong>不同机架</strong>的DataNode上，第三个副本存储在<strong>另一个机架</strong>的DataNode上。</li></ul><h2 id="HDFS的写数据流程："><a href="#HDFS的写数据流程：" class="headerlink" title="HDFS的写数据流程："></a><strong>HDFS的写数据流程</strong>：</h2><p>采用流水线方式进行数据写入，数据从客户端开始依次写入多个DataNode，直到所有副本都完成写入。</p><h3 id="HDFS读写过程：（画图）（感觉必考）"><a href="#HDFS读写过程：（画图）（感觉必考）" class="headerlink" title="HDFS读写过程：（画图）（感觉必考）"></a>HDFS读写过程：（画图）（感觉必考）</h3><h4 id="写过程："><a href="#写过程：" class="headerlink" title="写过程："></a>写过程：</h4><ol><li>客户端与NameNode通信，获取文件块的存储位置。</li><li>客户端将数据分块，并发送到DataNode。</li><li>DataNode接收数据并存储，同时向客户端确认。</li></ol><p><strong>写过程示意图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client ----&gt; NameNode ----&gt; DataNode1 ----&gt; DataNode2 ----&gt; DataNode3</span><br><span class="line">       获取存储位置            存储数据块            存储数据块           存储数据块</span><br></pre></td></tr></table></figure><h4 id="读过程："><a href="#读过程：" class="headerlink" title="读过程："></a>读过程：</h4><ol><li>客户端向NameNode请求文件的块位置。</li><li>NameNode返回文件块的位置信息。</li><li>客户端直接从相应的DataNode读取数据。</li></ol><p><strong>读过程示意图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client ----&gt; NameNode ----&gt; DataNode1 ----&gt; DataNode2</span><br><span class="line">        获取块位置              读取数据                读取数据</span><br></pre></td></tr></table></figure><h3 id="判断文件是否存在（HDFS编程实现）：（编程）"><a href="#判断文件是否存在（HDFS编程实现）：（编程）" class="headerlink" title="判断文件是否存在（HDFS编程实现）：（编程）"></a>判断文件是否存在（HDFS编程实现）：（编程）</h3><p><strong>这个感觉也会考</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = new Configuration();</span><br><span class="line">FileSystem fs = FileSystem.get(conf);</span><br><span class="line">Path filePath = new Path(&quot;/user/hadoop/hdfsfle.txt&quot;);</span><br><span class="line"></span><br><span class="line">if (fs.exists(filePath)) &#123;</span><br><span class="line">    System.out.println(&quot;File exists.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;File does not exist.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>fs.exists(filePath)</strong>：检查指定路径的文件是否存在。</li></ul><h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h3 id="HBase-三级寻址与Region个数计算：（计算）（必考）"><a href="#HBase-三级寻址与Region个数计算：（计算）（必考）" class="headerlink" title="HBase 三级寻址与Region个数计算：（计算）（必考）"></a>HBase 三级寻址与Region个数计算：（计算）（必考）</h3><ol><li></li><li>三级寻址<ul><li><strong>RowKey</strong> → <strong>RegionServer</strong> → <strong>HRegion</strong></li></ul></li><li>Region个数计算<ul><li>初始情况下，HBase有一个默认Region，随着数据增长，Region会自动分裂，Region数目与数据量和Region大小有关。</li><li>计算公式：Region数量=数据总量/每个Region的最大大小</li></ul></li></ol><h3 id="HBase系统架构及组件功能："><a href="#HBase系统架构及组件功能：" class="headerlink" title="HBase系统架构及组件功能："></a>HBase系统架构及组件功能：</h3><ol><li><strong>HMaster</strong>：管理RegionServer的调度与分配，负责Region的分裂和负载均衡。</li><li><strong>RegionServer</strong>：处理客户端请求，存储数据。</li><li><strong>Zookeeper</strong>：协调HBase集群的节点，确保一致性和监控。</li><li><strong>HRegion</strong>：存储HBase的数据表分区。</li><li><strong>HBase Client</strong>：与HBase交互的客户端程序，执行读写操作。</li><li><strong>表</strong>：数据存储的基本单元。</li><li><strong>行键</strong>：唯一标识每一行的数据。</li><li><strong>列族</strong>：列的集合。</li><li><strong>列限定符</strong>：列族下的具体列名。</li><li><strong>单元格</strong>：数据存储的位置。</li><li><strong>时间戳</strong>：每个数据的版本标识。</li></ol><h2 id="HBase运行机制："><a href="#HBase运行机制：" class="headerlink" title="HBase运行机制："></a><strong>HBase运行机制</strong>：</h2><ul><li><strong>RegionServe</strong>：处理数据表的分区，负责存储与读写。</li><li><strong>Store</strong>：物理存储的数据结构。</li><li><strong>HLog</strong>：记录所有变更的日志。</li></ul><h3 id="HBase-Shell命令操作："><a href="#HBase-Shell命令操作：" class="headerlink" title="HBase Shell命令操作："></a>HBase Shell命令操作：</h3><ol><li><p>创建表</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create &#x27;my_table&#x27;, &#x27;cf1&#x27;, &#x27;cf2&#x27;</span><br></pre></td></tr></table></figure></li><li><p>添加数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put &#x27;my_table&#x27;, &#x27;row1&#x27;, &#x27;cf1:col1&#x27;, &#x27;value1&#x27;</span><br></pre></td></tr></table></figure></li><li><p>浏览数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan &#x27;my_table&#x27;</span><br></pre></td></tr></table></figure></li><li><p>获得单元格数据</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &#x27;my_table&#x27;, &#x27;row1&#x27;</span><br></pre></td></tr></table></figure></li><li><p>删除表格</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable &#x27;my_table&#x27;</span><br><span class="line">drop &#x27;my_table&#x27;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h1><h3 id="CAP理论的含义："><a href="#CAP理论的含义：" class="headerlink" title="CAP理论的含义："></a>CAP理论的含义：</h3><ol><li><strong>Consistency</strong>（一致性）：所有节点的数据保持一致。</li><li><strong>Availability</strong>（可用性）：每个请求都会收到响应，不管数据是否最新。</li><li><strong>Partition Tolerance</strong>（分区容错性）：系统在网络分区的情况下仍然能够继续工作。</li></ol><h3 id="处理CAP问题的选择："><a href="#处理CAP问题的选择：" class="headerlink" title="处理CAP问题的选择："></a>处理CAP问题的选择：</h3><ul><li><strong>CP</strong>（一致性 + 分区容错）：如HBase。</li><li><strong>AP</strong>（可用性 + 分区容错）：如Cassandra。</li><li><strong>CA</strong>（一致性 + 可用性）：适用于单机系统，无法容忍分区。</li></ul><p>NoSQL数据库提供灵活的数据模型，适用于大数据场景，相较于传统关系数据库，NoSQL在横向扩展和高并发上有优势。</p><h3 id="NoSQL数据库的四大类型："><a href="#NoSQL数据库的四大类型：" class="headerlink" title="NoSQL数据库的四大类型："></a>NoSQL数据库的四大类型：</h3><ol><li><p>键值存储（Key-Value Stores）</p><p>：存储数据以键值对的形式，如Redis。</p><ul><li><strong>特征</strong>：高效查询、可扩展性强，适合存储简单的数据。</li></ul></li><li><p>列族存储（Column-Family Stores）</p><p>：数据按列存储，如HBase、Cassandra。</p><ul><li><strong>特征</strong>：适合高吞吐量、高并发的场景，存储稀疏数据。</li></ul></li><li><p>文档存储（Document Stores）</p><p>：数据以JSON、XML等文档格式存储，如MongoDB。</p><ul><li><strong>特征</strong>：适合存储复杂的结构化数据，灵活性高。</li></ul></li><li><p>图数据库（Graph Databases）</p><p>：用于存储图结构数据，如Neo4j。</p><ul><li><strong>特征</strong>：适合复杂的关系数据，查询效率高。</li></ul></li></ol><h2 id="BASE理论："><a href="#BASE理论：" class="headerlink" title="BASE理论："></a><strong>BASE理论</strong>：</h2><ul><li><strong>基本可用</strong>：部分系统可用。</li><li><strong>软状态</strong>：系统状态可能暂时不一致。</li><li><strong>最终一致性</strong>：系统最终会达到一致状态。</li></ul><h1 id="MyReduce"><a href="#MyReduce" class="headerlink" title="MyReduce"></a>MyReduce</h1><h3 id="MapReduce体系架构图-画图-感觉必考哈"><a href="#MapReduce体系架构图-画图-感觉必考哈" class="headerlink" title="MapReduce体系架构图(画图)感觉必考哈"></a>MapReduce体系架构图(画图)感觉必考哈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       +-------------------+</span><br><span class="line">       |   Client          |</span><br><span class="line">       +-------------------+</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">       +-------------------+</span><br><span class="line">       |   JobTracker      |     (Resource Management)</span><br><span class="line">       +-------------------+</span><br><span class="line">                |</span><br><span class="line">                v</span><br><span class="line">+--------------------------+  +--------------------------+</span><br><span class="line">|   TaskTracker (Map Task)  |  |   TaskTracker (Reduce Task)|</span><br><span class="line">+--------------------------+  +--------------------------+</span><br><span class="line">                |                       |</span><br><span class="line">                v                       v</span><br><span class="line">        +-------------------+    +-------------------+</span><br><span class="line">        |   HDFS Storage    |    |   HDFS Storage    |</span><br><span class="line">        +-------------------+    +-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MapReduce流程："><a href="#MapReduce流程：" class="headerlink" title="MapReduce流程："></a>MapReduce流程：</h3><ol><li><strong>Map端</strong>：输入数据（如文件）被切分成多个块，分配给不同的Map任务处理。</li><li><strong>Shuffle过程</strong>：Map任务的输出会根据键进行分组，并被传输到相应的Reduce任务。</li><li><strong>Reduce端</strong>：根据分组的键，Reduce任务聚合数据，输出最终结果。</li></ol><h3 id="MapReduce实现两个数据库表的自然连接："><a href="#MapReduce实现两个数据库表的自然连接：" class="headerlink" title="MapReduce实现两个数据库表的自然连接："></a>MapReduce实现两个数据库表的自然连接：</h3><ol><li><strong>Map端</strong>：将两个表的数据按主键进行映射。</li><li><strong>Reduce端</strong>：对相同主键的数据进行连接。</li></ol><h3 id="MapReduce实现WordCount：（编程）"><a href="#MapReduce实现WordCount：（编程）" class="headerlink" title="MapReduce实现WordCount：（编程）"></a>MapReduce实现WordCount：（编程）</h3><ol><li><p><strong>Map函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String[] words = value.toString().split(&quot;\\s+&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            context.write(new Text(word), new IntWritable(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Reduce函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">    public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (IntWritable val : values) &#123;</span><br><span class="line">            sum += val.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, new IntWritable(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>简短总结：</p><ul><li><strong>MapReduce架构</strong>：分为Map任务、Shuffle过程、Reduce任务。</li><li><strong>连接过程</strong>：Map端根据主键映射，Reduce端进行连接。</li><li><strong>WordCount</strong>：Map函数分词计数，Reduce函数汇总计数。</li></ul><h1 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h1><h3 id="Storm中的各个组件及功能："><a href="#Storm中的各个组件及功能：" class="headerlink" title="Storm中的各个组件及功能："></a>Storm中的各个组件及功能：</h3><ol><li><strong>Topology</strong>：整个Storm应用，包含所有的spouts和bolts。</li><li><strong>Spout</strong>：数据源，负责向Storm系统发送原始数据。</li><li><strong>Bolt</strong>：处理数据的单元，接收数据并进行处理后输出。</li><li><strong>Nimbus</strong>：集群的主控节点，负责任务调度、分配。</li><li><strong>Supervisors</strong>：工作节点，负责运行bolts和spouts。</li></ol><h3 id="Storm的工作流程："><a href="#Storm的工作流程：" class="headerlink" title="Storm的工作流程："></a>Storm的工作流程：</h3><ol><li>Spout从外部系统读取数据。</li><li>数据经过Bolt处理。</li><li>数据通过Storm集群进行分发和处理。</li></ol><h3 id="Storm的特点："><a href="#Storm的特点：" class="headerlink" title="Storm的特点："></a>Storm的特点：</h3><ul><li><strong>实时性</strong>：低延迟处理。</li><li><strong>可扩展性</strong>：能够处理大规模数据流。</li><li><strong>容错性</strong>：自动处理失败任务，保证数据处理完整。</li></ul><h3 id="编写Storm代码示例（Topology-amp-Bolt）："><a href="#编写Storm代码示例（Topology-amp-Bolt）：" class="headerlink" title="编写Storm代码示例（Topology &amp; Bolt）："></a>编写Storm代码示例（Topology &amp; Bolt）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyBolt extends BaseBasicBolt &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Tuple input, BasicOutputCollector collector) &#123;</span><br><span class="line">        String word = input.getStringByField(&quot;word&quot;);</span><br><span class="line">        collector.emit(new Values(word, 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTopology &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        TopologyBuilder builder = new TopologyBuilder();</span><br><span class="line">        builder.setSpout(&quot;spout&quot;, new MySpout(), 1);</span><br><span class="line">        builder.setBolt(&quot;bolt&quot;, new MyBolt(), 1).shuffleGrouping(&quot;spout&quot;);</span><br><span class="line"></span><br><span class="line">        Config conf = new Config();</span><br><span class="line">        StormSubmitter.submitTopology(&quot;my-topology&quot;, conf, builder.createTopology());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h3 id="Spark-Streaming和Storm的区别：感觉必考哈"><a href="#Spark-Streaming和Storm的区别：感觉必考哈" class="headerlink" title="Spark Streaming和Storm的区别：感觉必考哈"></a>Spark Streaming和Storm的区别：感觉必考哈</h3><ul><li><strong>实时性</strong>：Storm是基于流的实时处理，适合低延迟需求；Spark Streaming是基于微批处理，延迟相对较高。</li><li><strong>容错</strong>：Storm具有内建的容错机制，Spark Streaming通过checkpoint机制。</li><li><strong>架构</strong>：Storm的架构较为简洁，直接处理数据流，Spark Streaming依赖于Spark的批处理架构，支持复杂操作。</li></ul><h3 id="Spark中RDD的理解和运用："><a href="#Spark中RDD的理解和运用：" class="headerlink" title="Spark中RDD的理解和运用："></a>Spark中RDD的理解和运用：</h3><ul><li><p><strong>RDD（Resilient Distributed Dataset）</strong>：分布式数据集，Spark的核心抽象，支持并行计算、容错和分布式存储。</p></li><li><p>RDD的操作</p><p>：</p><ul><li><strong>转换操作</strong>：如<code>map</code>、<code>filter</code>、<code>flatMap</code>，懒执行。</li><li><strong>行动操作</strong>：如<code>collect</code>、<code>count</code>、<code>reduce</code>，触发实际计算。</li></ul><p>区别</p><p>：转换操作会返回新的RDD，行动操作会触发实际的计算和结果返回。</p></li></ul><h3 id="窄依赖和宽依赖的区别："><a href="#窄依赖和宽依赖的区别：" class="headerlink" title="窄依赖和宽依赖的区别："></a>窄依赖和宽依赖的区别：</h3><ul><li><strong>窄依赖</strong>：每个父RDD的分区对应着子RDD的一个分区（如<code>map</code>、<code>filter</code>）。</li><li><strong>宽依赖</strong>：父RDD的一个分区可能会对应子RDD的多个分区（如<code>groupByKey</code>、<code>reduceByKey</code>）。</li></ul><h3 id="如何进行stage划分："><a href="#如何进行stage划分：" class="headerlink" title="如何进行stage划分："></a>如何进行stage划分：</h3><ul><li>根据<strong>宽依赖</strong>进行Stage划分，不同Stage之间的数据需要shuffle操作（如<code>groupByKey</code>）。</li><li>每个Stage的操作会在同一节点内部进行，不需要跨节点的数据传输。</li></ul><h3 id="park-shell命令解读："><a href="#park-shell命令解读：" class="headerlink" title="park shell命令解读："></a>park shell命令解读：</h3><ul><li><code>spark-shell</code>：启动Spark交互式shell。</li><li><code>sc.textFile(&quot;path&quot;)</code>：加载文本文件。</li><li><code>rdd.map(func)</code>：对每个元素应用<code>func</code>。</li><li><code>rdd.collect()</code>：获取RDD的所有数据。</li><li><code>rdd.reduce(func)</code>：对RDD数据进行聚合。</li></ul><h3 id="Spark编程实现统计字符个数："><a href="#Spark编程实现统计字符个数：" class="headerlink" title="Spark编程实现统计字符个数："></a>Spark编程实现统计字符个数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val textFile = sc.textFile(&quot;path/to/file.txt&quot;)</span><br><span class="line">val charCount = textFile.flatMap(line =&gt; line.split(&quot;&quot;)).map(char =&gt; (char, 1)).reduceByKey(_ + _)</span><br><span class="line">charCount.collect().foreach(println)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>RDD</strong>：Spark的核心数据结构，支持转换和行动操作。</li><li><strong>窄/宽依赖</strong>：窄依赖跨分区小，宽依赖跨分区大。</li><li><strong>Stage划分</strong>：宽依赖会引起Stage划分</li></ul><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="可视化的基本概念："><a href="#可视化的基本概念：" class="headerlink" title="可视化的基本概念："></a>可视化的基本概念：</h3><ul><li><strong>数据可视化</strong>：通过图形、图表、地图等方式呈现数据，帮助理解、分析和展示数据。</li><li><strong>目的</strong>：将复杂的数据转化为易于理解的形式，揭示数据中的模式、趋势和关系。</li><li>类型：<ul><li><strong>静态可视化</strong>：如条形图、折线图、饼图等。</li><li><strong>动态可视化</strong>：交互式图表，能够实时更新数据。</li></ul></li><li><strong>常用工具</strong>：如Tableau、Power BI、D3.js等。</li></ul><p>简短总结： 数据可视化通过图形化展示数据，帮助更直观地理解信息。</p><h3 id="基于商品和基于用户的协同过滤算法："><a href="#基于商品和基于用户的协同过滤算法：" class="headerlink" title="基于商品和基于用户的协同过滤算法："></a>基于商品和基于用户的协同过滤算法：</h3><ol><li><p><strong>基于商品的协同过滤（Item-based CF）</strong>：</p><ul><li><p><strong>原理</strong>：根据用户对商品的评分，找到相似商品并推荐给用户。</p></li><li><p>步骤</p><p>：</p><ul><li>计算商品之间的相似度（如余弦相似度）。</li><li>根据用户历史评分，推荐相似商品。</li></ul></li><li><p><strong>优点</strong>：相对稳定，推荐的商品相似度较高。</p></li><li><p><strong>缺点</strong>：冷启动问题（新商品推荐困难）。</p></li></ul></li><li><p><strong>基于用户的协同过滤（User-based CF）</strong>：</p><ul><li><p><strong>原理</strong>：根据用户之间的相似度，推荐其他相似用户喜欢的商品。</p></li><li><p>步骤</p><p>：</p><ul><li>计算用户之间的相似度。</li><li>根据相似用户的评分，推荐商品。</li></ul></li><li><p><strong>优点</strong>：个性化较强，易于理解。</p></li><li><p><strong>缺点</strong>：计算复杂度高，冷启动问题。</p></li></ul></li></ol><h3 id="Pregel求最大值-最小值计算过程：（画图）"><a href="#Pregel求最大值-最小值计算过程：（画图）" class="headerlink" title="Pregel求最大值/最小值计算过程：（画图）"></a>Pregel求最大值/最小值计算过程：（画图）</h3><ol><li><p><strong>基本思想</strong>：Pregel通过“顶点”的消息传递来处理大规模图数据，适用于图计算任务，如最大值/最小值计算。</p></li><li><p><strong>计算过程</strong>：</p><ul><li><strong>初始化</strong>：每个顶点初始化为其自身的值（最大值或最小值）。</li><li><strong>迭代</strong>：每个顶点将其当前值传递给相邻的顶点。每个接收到消息的顶点更新自己的值为当前值和收到的值中的最大值或最小值。</li><li><strong>终止条件</strong>：当图中所有顶点的值不再发生变化时，算法结束。</li></ul><p><strong>图示说明</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C</span><br><span class="line"> /     \</span><br><span class="line">D       E</span><br></pre></td></tr></table></figure><p>初始状态：顶点A、B、C、D、E的值分别为其初始值。通过迭代传递消息，直到最大值或最小值稳定。</p></li></ol><h3 id="迪杰斯特拉算法求解单源最短路径问题："><a href="#迪杰斯特拉算法求解单源最短路径问题：" class="headerlink" title="迪杰斯特拉算法求解单源最短路径问题："></a>迪杰斯特拉算法求解单源最短路径问题：</h3><ol><li><strong>基本思想</strong>：从源顶点出发，逐步更新每个顶点的最短路径值，直到所有顶点的最短路径值确定。</li><li><strong>算法步骤</strong>：<ul><li><strong>初始化</strong>：将源顶点的最短路径值设为0，其余顶点设为无穷大。</li><li><strong>选择最短路径</strong>：选择尚未确定最短路径的顶点中最短的一个，更新其相邻顶点的最短路径。</li><li><strong>迭代</strong>：重复选择顶点并更新路径，直到所有顶点的最短路径确定。</li></ul></li></ol><h3 id="利用Pregel实现单源最短路径计算过程："><a href="#利用Pregel实现单源最短路径计算过程：" class="headerlink" title="利用Pregel实现单源最短路径计算过程："></a>利用Pregel实现单源最短路径计算过程：</h3><ol><li><p><strong>初始化</strong>：</p><ul><li>源顶点的最短路径为0，其他顶点初始化为无穷大。</li></ul></li><li><p><strong>消息传递</strong>：</p><ul><li>每个顶点将其当前最短路径值传递给相邻的顶点。</li><li>接收到消息的顶点更新最短路径值，取当前值和从邻居收到的值的较小值。</li></ul></li><li><p><strong>迭代</strong>：</p><ul><li>继续进行消息传递，直到最短路径值不再变化。</li></ul></li><li><p><strong>计算过程</strong>（表格形式）：</p><p>| 顶点 | 当前最短路径值 | 邻居 | 接收到的消息 | 更新后的最短路径值 |<br>| —— | ——————— | —— | —————— | ————————— |<br>| A    | 0              | B, D | ∞, ∞         | 0                  |<br>| B    | ∞              | A, C | 0, ∞         | 1                  |<br>| C    | ∞              | B, E | 1, ∞         | 2                  |<br>| D    | ∞              | A, E | 0, ∞         | 1                  |<br>| E    | ∞              | C, D | 2, 1         | 2                  |</p></li><li><p><strong>终止条件</strong>：当所有顶点的最短路径值稳定，算法结束。</p></li></ol><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><h3 id="Hive中SQL语句转换成MapReduce的基本原理："><a href="#Hive中SQL语句转换成MapReduce的基本原理：" class="headerlink" title="Hive中SQL语句转换成MapReduce的基本原理："></a>Hive中SQL语句转换成MapReduce的基本原理：</h3><ul><li><p><strong>原理</strong>：Hive使用HiveQL语言查询数据，查询语句会被转换为一系列的MapReduce任务。<strong>Hive的查询处理器将SQL解析为一个逻辑执行计划，然后通过优化转换成物理执行计划（MapReduce作业）。</strong></p></li><li><p>过程</p><p>：</p><ol><li><strong>解析</strong>：HiveQL语句被解析成抽象语法树（AST）。</li><li><strong>优化</strong>：对AST进行优化，去除冗余操作。</li><li><strong>生成MapReduce作业</strong>：根据查询逻辑生成MapReduce作业，并执行。</li></ol></li></ul><h3 id="Hive中SQL查询转换成MapReduce作业的过程："><a href="#Hive中SQL查询转换成MapReduce作业的过程：" class="headerlink" title="Hive中SQL查询转换成MapReduce作业的过程："></a>Hive中SQL查询转换成MapReduce作业的过程：</h3><ol><li><p>SQL查询</p><p>：例如查询表中某字段的总和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT SUM(amount) FROM transactions;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析阶段</strong>：Hive将此SQL语句转换为一个抽象的查询计划。</p></li><li><p><strong>优化阶段</strong>：Hive进行查询优化，合并某些操作。</p></li><li><p><strong>生成MapReduce作业</strong>：Hive将最终的查询计划转化为MapReduce作业。Map任务执行数据扫描，Reduce任务聚合计算结果。</p></li><li><p><strong>执行</strong>：Hive提交MapReduce作业到Hadoop集群执行。</p></li></ol><h3 id="Hive中Shell环境下常用操作代码："><a href="#Hive中Shell环境下常用操作代码：" class="headerlink" title="Hive中Shell环境下常用操作代码："></a>Hive中Shell环境下常用操作代码：</h3><p><strong>就是Mysql的语法</strong></p><ol><li><p><strong>创建数据库</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE DATABASE mydb;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT,</span><br><span class="line">    name STRING,</span><br><span class="line">    salary DOUBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ALTER TABLE employees ADD COLUMNS (address STRING);</span><br></pre></td></tr></table></figure></li><li><p><strong>查看表</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure></li><li><p><strong>描述表结构</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DESCRIBE employees;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入数据</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO TABLE employees VALUES (1, &#x27;John&#x27;, 5000.0);</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/Hadoop/">Hadoop</category>
      
      <category domain="https://blog.tokenlen.top/tags/BigData/">BigData</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/08/bigdata/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English十二月篇</title>
      <link>https://blog.tokenlen.top/2024/12/01/en4/</link>
      <guid>https://blog.tokenlen.top/2024/12/01/en4/</guid>
      <pubDate>Sat, 30 Nov 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;每日一话-单词遗忘表12-1&quot;&gt;&lt;a href=&quot;#每日一话-单词遗忘表12-1&quot; class=&quot;headerlink&quot; title=&quot;每日一话+单词遗忘表12.1&quot;&gt;&lt;/a&gt;每日一话+单词遗忘表12.1&lt;/h1&gt;&lt;p&gt;Working hard is</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="每日一话-单词遗忘表12-1"><a href="#每日一话-单词遗忘表12-1" class="headerlink" title="每日一话+单词遗忘表12.1"></a>每日一话+单词遗忘表12.1</h1><p>Working hard is important, but there is something that matters even more: believing in yourself</p><ul><li>forest 森林</li><li>forge 熔炉</li><li>explore 探寻</li><li>formal 正式的</li><li>former 从前的</li><li><strong>formula</strong> 公式</li><li><strong>formulate</strong> 构想出</li><li>forth 向前</li><li>forthcoming 即将到来的</li><li>fortune 运气</li><li>forum 论坛</li><li>fossil 化石</li><li>fountain 喷泉</li><li>fraction 小部分</li><li>fragment 碎片</li><li>frame 构架</li><li>explicit 详细的</li></ul><h1 id="每日一话-单词遗忘表12-2"><a href="#每日一话-单词遗忘表12-2" class="headerlink" title="每日一话+单词遗忘表12.2"></a>每日一话+单词遗忘表12.2</h1><p>A man may well bring a horse to the water, but he cannot make him drink.</p><ul><li>freight 运送</li><li>contempt 轻蔑</li><li>frog 青蛙</li><li><strong>frontier</strong> 边境</li><li>frost 结霜</li><li><strong>frustrate</strong> 挫败</li><li>fry 油炸</li><li>fuel 燃料</li><li>fulfil 履行</li><li>fulfill 履行实践</li><li>fundamental 基本的</li><li>contrary 相反的</li><li>funeral 葬礼</li><li>fur 皮毛</li><li>furnace 火炉</li></ul><h1 id="每日一话-单词遗忘表12-3"><a href="#每日一话-单词遗忘表12-3" class="headerlink" title="每日一话+单词遗忘表12.3"></a>每日一话+单词遗忘表12.3</h1><p>Mistakes are an essential part of education.</p><ul><li>furnish 提供</li><li>furniture 家具</li><li>furthermore 而且</li><li>fuss 小题大作</li><li>gadget 小玩意</li><li>gallery 走廊</li><li>gamble 赌博</li><li>gang 一伙</li><li>gap 缺口</li><li>garage 车库</li><li>frustrate 阻止</li><li>garden 花园</li><li><strong>garment</strong> 衣服</li><li>gasoline 汽油</li><li>gaze 注视</li><li>gear 齿轮</li><li>gene 基因</li></ul><h1 id="每日一话-单词遗忘表12-4"><a href="#每日一话-单词遗忘表12-4" class="headerlink" title="每日一话+单词遗忘表12.4"></a>每日一话+单词遗忘表12.4</h1><p>A man never discloses his own character so clearly as when he describes another’s.</p><ul><li>generous 慷慨的</li><li>genius 天才</li><li>gentle 温和的</li><li>genuine 真实的</li><li>germ 细菌</li><li>gesture 姿态</li><li>ghost 鬼</li><li><strong>giant</strong> 巨人</li><li>glance 一瞥</li><li><strong>glimpse</strong> 一瞥</li><li>glory 光荣的</li><li>glow 发热</li><li></li></ul><h1 id="每日一话-单词遗忘表12-5"><a href="#每日一话-单词遗忘表12-5" class="headerlink" title="每日一话+单词遗忘表12.5"></a>每日一话+单词遗忘表12.5</h1><p>I think probably kindness is my number one attribute in a human being. I’ll put it before any of the things like courage or bravery or generosity or anything else.</p><ul><li>goodness 善良</li><li>goods商品</li><li><strong>gorgeous</strong> 华丽的</li><li>gossip 随笔</li><li>govern 统治</li><li>gown 长袍</li><li>gradual 逐渐的</li><li><strong>grain</strong> 粮食</li><li>gram 克</li><li>gramme 克</li><li>grant 授予</li><li><strong>grasp</strong> 抓住</li><li>gloom 悲伤的</li></ul><h1 id="每日一话-单词遗忘表12-6"><a href="#每日一话-单词遗忘表12-6" class="headerlink" title="每日一话+单词遗忘表12.6"></a>每日一话+单词遗忘表12.6</h1><p>Snowflakes are one of nature’s most fragile things, but just look what they can do when they stick together.</p><ul><li>grave 严肃的</li><li>gravitation吸引力</li><li>gravity 重力</li><li>gray 灰色的</li><li><strong>greet</strong> 欢迎</li><li><strong>grief</strong> 悲伤</li><li>grin 笑</li><li><strong>grind</strong> 磨碎</li><li>grip 紧握</li><li>gross 总共的</li><li>guarantee 保证</li><li>guard 警戒</li><li><strong>guilt</strong> 内疚</li><li>guitar 吉他</li><li>gulf 海湾</li><li>gum 树胶</li></ul><h1 id="每日一话-单词遗忘表12-7"><a href="#每日一话-单词遗忘表12-7" class="headerlink" title="每日一话+单词遗忘表12.7"></a>每日一话+单词遗忘表12.7</h1><p>When obstacles arise, you change your direction to reach your goal; you do not change your decision to get there.</p><ul><li><strong>gut</strong> 内脏内情</li><li>hack 砍出租</li><li>guy 男人</li><li>gymnasium 健身房</li><li>hail 招呼</li><li>hall 走廊</li><li><strong>halt</strong> 停止</li><li>ham 火腿</li><li>hammer 敲打</li><li>handicap 障碍</li><li>handle 把手</li><li>gum 牙龈</li><li>harbor 海港</li><li>harbour 藏匿</li><li>hardship 困苦的</li></ul><h1 id="每日一话-单词遗忘表12-8"><a href="#每日一话-单词遗忘表12-8" class="headerlink" title="每日一话+单词遗忘表12.8"></a>每日一话+单词遗忘表12.8</h1><p>If one cannot enjoy reading a book over and over again, there is no use in reading it at all.</p><ul><li><strong>hardware</strong> 计算机硬件</li><li>harmony 协调</li><li>harness 马具</li><li>harsh 粗糙</li><li>harvest 收获</li><li>halt 停止</li><li>haste 匆忙</li><li>hatch 孵化</li><li>haul 拖拉</li><li>haunt 经常出没</li><li>hazard 冒险，危险</li><li>haze 疑惑，雾霾</li></ul><h1 id="每日一话-单词遗忘表12-9"><a href="#每日一话-单词遗忘表12-9" class="headerlink" title="每日一话+单词遗忘表12.9"></a>每日一话+单词遗忘表12.9</h1><p>Anyone who conducts an argument by appealing to authority is not using his intelligence; he is just using his memory.</p><ul><li>heaven 天堂</li><li>hectare 公顷</li><li>hedge 避免正面回答</li><li>helicopter 直升机</li><li>hell 地狱</li><li>hence 因此</li><li><strong>heritage</strong> 遗产</li><li>hesitate 犹豫</li><li>hijack 抢劫</li></ul><h1 id="每日一话-单词遗忘表12-10"><a href="#每日一话-单词遗忘表12-10" class="headerlink" title="每日一话+单词遗忘表12.10"></a>每日一话+单词遗忘表12.10</h1><p>The most efficient way to live reasonably is every morning to make a plan of one’s day and every night to examine the results obtained.</p><ul><li>hill 小山丘</li><li>hinder 阻碍</li><li><strong>hint</strong> 暗示</li><li>hip 臀部</li><li>hollow 空的</li><li>holy 神圣的</li><li>homeland 祖国</li><li>homosexual 同性恋的</li><li>honest 诚实的</li><li>horror 惊骇</li></ul><h1 id="每日一话-单词遗忘表12-11"><a href="#每日一话-单词遗忘表12-11" class="headerlink" title="每日一话+单词遗忘表12.11"></a>每日一话+单词遗忘表12.11</h1><p>Heaven has made us talents, we’re not made in vain. A thousand gold coins spent, more will turn up again.</p><ul><li>horsepower 马力</li><li>hospitable 好客的</li><li>hotdog 卖弄</li><li>hammer 敲打</li><li>humble 谦逊的</li><li>humor 幽默的</li><li>hundred 一百</li></ul><p>题目词汇：</p><ul><li>renovate 修复</li><li>deserted 荒芜的</li><li>desperate 绝望的</li><li>interaction 合作活动</li><li>fulfilled 履行</li><li>embrace 拥护</li><li>contradictory 矛盾的</li><li>detailed 详细的</li><li>dipping 蘸</li><li>distinction 区别</li><li>involves 包含</li><li>moderate 中等的</li><li>vigorous 强有力的</li><li>notifiled 通知的</li><li>falling 下降的</li><li>optimum 最佳选择</li><li>constitutes 由..组成</li><li>prisoner 监狱</li></ul><h1 id="每日一话-单词遗忘表12-12"><a href="#每日一话-单词遗忘表12-12" class="headerlink" title="每日一话+单词遗忘表12.12"></a>每日一话+单词遗忘表12.12</h1><p>Regret is an appalling waste of energy. You can’t build on it. It’s only good for wallowing in.</p><ul><li>hyphen 连字号</li><li>ill 坏的</li><li>illusion 幻觉</li><li>illustrate 说明</li><li>imitate 模仿</li><li>immediate 立即的</li><li><strong>immense</strong> 巨大的</li><li>immigrate 移入</li><li>immune 免疫</li><li>impatient 不耐烦的</li><li>imperial 皇帝的</li><li>implement 使生效</li><li><strong>implicit</strong> 盲目的</li></ul><h1 id="每日一话-单词遗忘表12-13"><a href="#每日一话-单词遗忘表12-13" class="headerlink" title="每日一话+单词遗忘表12.13"></a>每日一话+单词遗忘表12.13</h1><ul><li>impose 强加</li><li><strong>impulse</strong> 冲动</li><li>incentive 刺激的</li><li><strong>incidence</strong> 发生率</li><li>incident 事件</li><li>incline 倾斜</li><li>income 收入</li><li>indeed 真正的</li><li>industry 工业</li><li><strong>infant</strong> 未成年的</li></ul><h1 id="四级高频词汇"><a href="#四级高频词汇" class="headerlink" title="四级高频词汇"></a>四级高频词汇</h1><ul><li>resident 居民</li><li>direction 方向</li><li>sheet 床单一张纸</li><li>correspond 符合</li><li>accounted  解释</li><li>counterprouductive 适得其反</li><li>translate 转化</li><li>varous measures 多种举措</li><li>rational nutrition 合理的营养</li><li>vigorous 强有力的</li><li><strong>circumstance</strong> 环境</li><li>resume 简历</li><li>total 总计</li><li>identify 鉴定</li><li>digital 数码的</li><li>rate 速度，价格</li><li>feature 特征</li><li>individual 个人的</li><li>academic 学院的</li><li>obesity 肥胖的</li><li>recession 经济衰退的</li><li>regulation 章程</li><li>relsease 发布</li><li>pose 引起</li><li>compound 合成物</li><li>occasion 场合</li><li>derive 起源</li><li>divorce 离婚</li><li>association 协会</li><li>potential 潜在的</li><li>participate 参加</li><li>motivate 激发</li><li><strong>ingredient</strong> 成分</li><li>previous 先前的</li><li>boost 提高</li><li>emission 排放</li><li>document 文件</li><li>excellent 优秀的</li><li>budget 预算</li><li>commercial 贸易的</li><li>secretary 秘书</li><li>alternative 可供选择的</li><li>ultimately 最终</li><li>tobacco 烟草</li><li>revolution 革命</li><li>appetite 食欲</li><li>princiiple 原则</li><li>suspect 嫌疑犯</li><li>spouse 配偶</li><li>prospect 前景</li><li>pursue 追求</li><li>corporate 团体的</li><li>journal 日志</li><li>contract 合同</li><li>penalty 惩罚</li><li>perception 感知</li><li>vulnerable 脆弱的</li><li>conference 大型会议</li><li>restrict 限制</li><li>portion 部分</li><li>sustain 支撑</li><li>estate 庄园</li><li><strong>grasffti</strong> 涂鸦</li><li><strong>perspective</strong> 观点</li><li><strong>elementary</strong> 初级的</li><li>revenue 税收</li><li>interity 完整</li><li>margin 边缘的</li><li>tunnel 隧道</li><li>nurition 营养</li><li>counterpart 对应的人</li><li>heritage 遗产</li><li>suffcient 足够的</li><li>interpret 口译</li><li>institute 学院</li><li>demonstrate 展示</li><li>dramatic 戏剧性的</li><li>fulfill 履行</li><li>episode 一集</li><li>density 密度</li><li>cognitive 认知的</li><li>disorder 混乱的</li><li>relieve 减轻</li><li>negotiate 谈判</li><li>pediatrician 儿科医生</li><li>gadget 小物件</li><li>marvelous 极好的</li><li><strong>contaminat</strong>e 污染</li><li>restict 限制</li></ul><h1 id="单词遗忘表-每日一话12-14"><a href="#单词遗忘表-每日一话12-14" class="headerlink" title="单词遗忘表+每日一话12.14"></a>单词遗忘表+每日一话12.14</h1><p>Water is a pioneer which the settler follows, taking advantage of its improvements.</p><ul><li>infer 推断</li><li>inferior 下级</li><li>infinite 无线的</li><li><strong>inflate</strong> 使充气</li><li>influenza 流行性感冒</li><li>ingredient 配料</li><li>inherit 继承</li><li>initial 最初的</li><li><strong>ink</strong> 墨水</li><li>impose 欺骗</li><li>innocent 无罪的</li><li><strong>inquiry</strong> 调查</li><li>insane 精神病的</li><li>infant 婴儿</li></ul><h1 id="单词遗忘表-每日一话12-15"><a href="#单词遗忘表-每日一话12-15" class="headerlink" title="单词遗忘表+每日一话12.15"></a>单词遗忘表+每日一话12.15</h1><p>There is no greater agony than bearing an untold story inside you.</p><ul><li>instant 立即的</li><li>instead 反而</li><li>instinct 本能</li><li>institute 建立</li><li>instrument 仪器</li><li><strong>insult</strong> 侮辱</li><li>inferior 下级的</li><li><strong>intact</strong> 原装的</li><li>intangible 难以捉摸的</li><li><strong>integrity</strong> 正直</li><li>intellectual 智力的</li><li>haul 拖拉</li><li>intense 紧张的</li><li>interfere 干预</li><li>interior 内部的</li></ul><h1 id="每日一话-单词遗忘表12-16"><a href="#每日一话-单词遗忘表12-16" class="headerlink" title="每日一话+单词遗忘表12.16"></a>每日一话+单词遗忘表12.16</h1><p>Hope sees the invisible, feels the intangible, and achieves the impossible.</p><ul><li>interpret 解释</li><li>interval 间隔</li><li>intimate 亲密的</li><li>invade 侵略</li><li>invalid 无效的</li><li>invest 投资</li><li>investigate 调查</li><li>deny 否认</li><li>inward 内向的</li><li>iron 铁</li><li><strong>irregular</strong> 不对称的</li><li><strong>irrigate</strong> 冲洗</li><li>isolate 孤立</li><li>idle 懒惰</li></ul><h1 id="每日一话-单词遗忘表12-17"><a href="#每日一话-单词遗忘表12-17" class="headerlink" title="每日一话+单词遗忘表12.17"></a>每日一话+单词遗忘表12.17</h1><p>Sometimes people don’t want to hear the truth, because they don’t want their illusions destroyed.</p><ul><li>incentive 动机</li><li>jail 监狱</li><li>jam 果酱</li><li>jar 震荡</li><li>jaw 下巴</li><li>jazz 爵士舞</li><li><strong>jealous</strong> 嫉妒的</li><li><strong>jet</strong> 喷射</li><li>jetlag 时差综合症</li><li><strong>jewel</strong> 宝石</li><li>jog 慢跑</li><li><strong>joint</strong> 关节</li><li>impulse 脉冲</li></ul><h1 id="每日一话-单词遗忘表12-18"><a href="#每日一话-单词遗忘表12-18" class="headerlink" title="每日一话+单词遗忘表12.18"></a>每日一话+单词遗忘表12.18</h1><ul><li>jungle 丛林</li><li>justify 证明合法</li><li>keen 敏锐的</li><li>kettle 罐</li><li>detect 发现</li><li>kin 亲戚</li><li>kindergarten 幼儿园</li></ul><h1 id="每日一话-单词遗忘表12-22"><a href="#每日一话-单词遗忘表12-22" class="headerlink" title="每日一话+单词遗忘表12.22"></a>每日一话+单词遗忘表12.22</h1><p>One cannot think well, love well, sleep well, if one has not dined well.</p><ul><li>knot 结</li><li>label 标签</li><li>intangible 无形的</li><li>labour 劳动力</li><li>ladder 阶梯</li><li>lag 延后</li><li>lamb 羔羊</li><li><strong>lame</strong> 瘸的</li><li>lamp 灯</li><li>landlord 房东</li><li>lap 膝盖</li><li>knee 脚踝</li><li>laser 激光</li></ul><h1 id="每日一话-单词遗忘表12-23"><a href="#每日一话-单词遗忘表12-23" class="headerlink" title="每日一话+单词遗忘表12.23"></a>每日一话+单词遗忘表12.23</h1><p>A happy life consists in the tranquility of mind.</p><ul><li>lanundry 洗衣店</li><li>lavatory 厕所</li><li>lawn 草坪</li><li>lay 放置</li><li>layoff 失业期</li><li>leaf 叶子</li><li>league 联盟</li><li>leak 漏洞</li><li>leap 跳跃</li><li>lease 租期</li><li>leather 皮革</li><li>irrigate 灌溉</li></ul><h1 id="每日一话-单词遗忘表12-24"><a href="#每日一话-单词遗忘表12-24" class="headerlink" title="每日一话+单词遗忘表12.24"></a>每日一话+单词遗忘表12.24</h1><p>Christmas Eve was a night of song that wrapped itself about you like a shawl.</p><ul><li>legal 合法的</li><li>legend 传奇</li><li>legislate 制定法律</li><li>leisure 闲暇的</li><li>lend 贷</li><li>lest 以免</li><li>liable 有责任的</li><li>liberal 慷慨的</li><li>liberate 解放</li><li>license 执照</li><li>lid 盖子</li><li>lily 百合花</li><li>limb 四肢</li></ul><h1 id="每日一话-单词遗忘表12-25"><a href="#每日一话-单词遗忘表12-25" class="headerlink" title="每日一话+单词遗忘表12.25"></a>每日一话+单词遗忘表12.25</h1><p>Christmas is not a time nor a season, but a state of mind. To cherish peace and goodwill, to be plenteous in mercy, is to have the real spirit of Christmas.</p><ul><li>lip 嘴唇</li><li>liquid 液体的</li><li>liquor 酒</li><li>literal 字面意义上的</li><li>livelihood 生计</li><li>liver肝脏</li><li><strong>loaf</strong> 块</li><li>loan 贷款</li><li>lodge 门房</li><li>log 原木</li><li>logic 逻辑学</li></ul><h1 id="每日一话-单词遗忘表12-26"><a href="#每日一话-单词遗忘表12-26" class="headerlink" title="每日一话+单词遗忘表12.26"></a>每日一话+单词遗忘表12.26</h1><p>I gotta keep breathing because tomorrow the sun will rise. Who knows what the tide could bring?</p><p><strong>今天是伟大领袖毛主席的131年诞辰，几千年来麦子熟了多少次，人民万岁第一次！</strong></p><ul><li>lodge 房间</li><li>loophole 枪眼</li><li>loose 不牢固的</li><li><strong>lord</strong> 上帝</li><li>lorry 卡车</li><li>loyal 忠诚的</li><li>lump 块</li><li>luxury 奢侈的</li><li>mad 疯狂的</li><li>magnet 磁体</li><li>magnificent 壮丽的</li><li>maid 女仆</li></ul><h1 id="每日一话-单词遗忘表12-27"><a href="#每日一话-单词遗忘表12-27" class="headerlink" title="每日一话+单词遗忘表12.27"></a>每日一话+单词遗忘表12.27</h1><p>A man on a thousand-mile walk has to forget his goal and say to himself every morning, “Today I’m going to cover twenty-five miles and then rest up and sleep.”</p><ul><li>mainstream 主流的</li><li>mammal 哺乳动物</li><li><strong>manipulate</strong> 熟练操作</li><li>manual 体力的</li><li>manufacture 制造</li><li>marathon 马拉松</li><li>margin 边缘</li><li>marine 海军</li><li>marshal 元帅</li><li>marvel 奇迹</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2024/12/01/en4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux编程基础期末复习</title>
      <link>https://blog.tokenlen.top/2024/11/25/linux11/</link>
      <guid>https://blog.tokenlen.top/2024/11/25/linux11/</guid>
      <pubDate>Sun, 24 Nov 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;真题在现&quot;&gt;&lt;a href=&quot;#真题在现&quot; class=&quot;headerlink&quot; title=&quot;真题在现&quot;&gt;&lt;/a&gt;真题在现&lt;/h1&gt;&lt;h2 id=&quot;概述题&quot;&gt;&lt;a href=&quot;#概述题&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="真题在现"><a href="#真题在现" class="headerlink" title="真题在现"></a>真题在现</h1><h2 id="概述题"><a href="#概述题" class="headerlink" title="概述题"></a>概述题</h2><p>1、简述 GNU、GPL 的含义，及其对 Linux 的影响。</p><p>GNU 计划开始于 1984 年 1 月。其创始人是理查德•马修•斯托曼（Richard Matthew<br>Stallman）。“GNU”是“GNU’s Not UNIX”的递归首字母缩写词。“GNU”的发音为 g’noo。<br>GNU 计划的目的是开发一个完全类似于 UNIX 的免费操作系统。其内核 Hurd 的开发工作始于<br>1990 年，但是至今尚未成熟。GNU 计划代表性的产品包括 GCC、Emacs、Bash Shell、GLIBC<br>等，这些都在 Linux 中被广泛使用。（3 分）<br>GPL（GNU General Public License，GNU 通用公共许可证）于 1985 年被提出。GPL 试<br>图保证您共享和修改自由软件的自由。GPL 适用于大多数自由软件基金会的软件。GNU 计划<br>一共提出了 3 个协议条款：GPL，LGPL（GNU Lesser General Public License，GNU 较宽松<br>公共许可证），GFDL（GNU Free Documentation License，GNU 自由文档许可证）。（4 分）</p><p><strong>这个题真就是概念的问题，真的很难记</strong></p><p>2.简述进程状态及其转换。</p><p>运行（running）态：进程占有处理器正在运行。<br>就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行。<br>等待（wait）态：又称为阻塞（blocked）态或睡眠（sleep）态，指进程不具备运行条件，正<br>在等待某个事件的完成。（4 分）</p><p>还要画个图</p><p><strong>wait状态可以变成ready状态，然后再变成running状态，或者是由running状态转换成wait或者ready状态</strong></p><p>3、Linux 目录结构与 Windows 有何不同？</p><p>(1). Linux 中文件名是区分大小写的，所有的 UNIX 系列操作系统都遵循这个规则。（2<br>分）<br>(2). Linux 文件通常没有扩展名。给 Linux 文件设置扩展名通常是为了方便用户使用。<br>Linux 文件的扩展名和它的种类没有任何关系。例如，zp.exe 可以是文本文件，而 zp.txt<br>也可以是可执行文件。（2 分）<br>2<br>(3). Linux 中没有盘符的概念（如 Windows 下的 C 盘）。Linux 的目录结构为树状结构，<br>顶级的目录为根目录“/”。其他目录通过挂载可以将它们添加到目录树中。例如，对于文件<br>zp.txt，它在 Linux 中的绝对路径可能是/home/john/zp.txt，而在 Windows 中的绝对路径<br>可能是 E:\document\zp.txt。（3 分）</p><p>4.用户账户的配置文件有哪些？它们各自用途如何？（7 分）<br>参考答案：<br>用户账户管理主要涉及 passwd 和 shadow 两个配置文件（3 分）。<br>passwd 是系统识别用户的一个重要文件，Linux 操作系统中所有的用户都记录在该文件<br>中（2 分）。<br>文件 shadow 是文件 passwd 的影子文件。主要保存用户密码配置情况（2 分）。</p><p>5.若使用 rmdir 命令来删除某个目录，但无法成功，请说明可能的原因。（7 分）</p><p>此目录可能不存在，（2 分）<br>或者目录不为空，（2 分）<br>或者目录中有隐含文件存在，（1 分）<br>或者目录被设置了权限，（1 分）<br>解决方法就是先修改权限，在使用 rm -r 命令删除。（1 分）</p><p><strong>桀桀桀，或者是直接rm -rf直接强制删除，管他啥呢</strong></p><h2 id="实操题"><a href="#实操题" class="headerlink" title="实操题"></a>实操题</h2><p>1、 完成以下进程管理操作（5 分）<br>（1）用 vi 编辑 test.txt 文件，然后使用 ctrl+z 将其挂起。<br>（2）查看当前进程的状态。<br>（3）将 test.txt 进程（假设进程 pid 为 36357）的优先级设置为 8，再终止该进程。<br>（4）查看 CPU 和内存的使用情况和进程状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt ctrl+z</span><br><span class="line">ps -l</span><br><span class="line">renice 8 pid</span><br><span class="line">kill -9 pid</span><br><span class="line">top</span><br></pre></td></tr></table></figure><p>2、当前用户为管理员，且在根目录下，完成以下文件和目录操作（5 分）<br>（1）在/mnt 目录下创建三个文件夹，dir1、dir2、dir3，并查看是否创建成功；<br>（2）在 dir1 文件夹内创建 test.sh 文件，并查看是否创建成功；<br>（3）将/mnt/dir1 下 test.sh 文件复制到 dir2 目录下，复制后的新文件名为 newtest.sh,并查看<br>是否复制成功；<br>（4）给文件 newtest.sh 添加可执行权限。<br>（5）删除文件 newtest.sh。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/dir&#123;1..3&#125;</span><br><span class="line">ls /mnt</span><br><span class="line">touch /mnt/dir1/test.sh</span><br><span class="line">ls /mnt/dir1</span><br><span class="line">cp /mnt/dir1/test.sh /mnt/dir2/newtest.sh</span><br><span class="line">ls /mnt/dir2</span><br><span class="line">chmod 700 /mnt/dir2/newtest.sh</span><br><span class="line">rm -rf /mnt/dir2/newtest.sh</span><br></pre></td></tr></table></figure><p>3、请写出以下操作的完整指令（包括命令选项及参数）：假设你是系统管理员，需要增加一<br>个新的用户账号 Jack，为新用户设置初始密码，锁定用户账号 Jerry，并删除用户账号 Kate。<br>（5 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd Jack</span><br><span class="line">passwd Jack</span><br><span class="line">passwd -1 Jack</span><br><span class="line">usedel Jack</span><br></pre></td></tr></table></figure><p>4 、执行命令 ls -1 时，某行显示如下:<br>-rw-r—r— 1 teacher teacher 744 3 月 18 11:58 studentdata<br>(1)用户 teacher 对该文件具有什么权限?<br>(2)执行命令 useradd student 后，用户 student 对该文件具有什么权限?<br>(3)如何使任何用户都可以读写执行该文件?<br>(4)如何把该文件所有者改为用户 root ?<br>（5 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">读写</span><br><span class="line"></span><br><span class="line">只读</span><br><span class="line">chmod 777 stduentdata</span><br><span class="line">chown root studentdata</span><br></pre></td></tr></table></figure><p>5、叙述 Linux 虚拟机如何增加一块硬盘（设备名为/dev/sdb，文件系统格式 ext4)，如何<br>实现开机自动挂载硬盘。写出详细的步骤和相关命令。（10 分）<br>参考答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先虚拟机新建一块硬盘</span><br><span class="line">分区fdisk /dev/sdb</span><br><span class="line">格式化 mkfs -t ext4 /dev/sdb1</span><br><span class="line">挂载挂载， 先创建一个/home/newdisk,挂载 mount /dev/sdb1 /home/newdisk </span><br><span class="line">然后设置自动挂载</span><br><span class="line">设置自动挂载，打开/etc/fstab 添加一行 </span><br><span class="line">/dev/sdb1 /home/newdisk ext4 defaults 0 0 </span><br></pre></td></tr></table></figure><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>1.创建一个 shell 脚本，它从用户那里接收 20 个数，并显示已输入的最小的数。（10 分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">min=2147483647</span><br><span class="line">for((count=0;count&lt;20;count=count+1))</span><br><span class="line">do</span><br><span class="line">echo -n &quot;输入数字:&quot;</span><br><span class="line">read value</span><br><span class="line">if [ $min -gt $value ]</span><br><span class="line">then</span><br><span class="line">min=$value</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol><li>编写 shell 脚本程序来分析某班某一课程平均成绩，从键盘输入若干个考试分数（分数为<br>整数），计算并输出所有分数的平均值。要求如下：<br>（1）使用 while 或 until 循环实现整数输入，如果输入为字符 q，则退出键盘输入；<br>（2）如果输入分数不在 0—100 范围内，提示用户输入有误；<br>（3）平均值计算不需要考虑小数部分，只需要得到整数部分即可。<br>（10 分）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/zsh</span><br><span class="line">sum=0</span><br><span class="line">count=0</span><br><span class="line">while true;</span><br><span class="line">do</span><br><span class="line">read -p &quot;输入一个整数&quot; score</span><br><span class="line">if [[ $score==&quot;q&quot; ]];then</span><br><span class="line">break</span><br><span class="line">elif [[ !&quot;$score&quot; =~^[0-9]+$ ]];then</span><br><span class="line">echo &quot;输入错误&quot;</span><br><span class="line">elif(( score &lt;0|| score &gt;100 ));then</span><br><span class="line">echo &quot;输入错误&quot;</span><br><span class="line">else</span><br><span class="line">sum=$((sum+score))</span><br><span class="line">count=$((count+1))</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">if((count == 0));then</span><br><span class="line">echo &quot;没有输入&quot;</span><br><span class="line">else</span><br><span class="line">avg=$((sum/count))</span><br><span class="line">echo &quot;平均分为&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h1 id="作业再现复习"><a href="#作业再现复习" class="headerlink" title="作业再现复习"></a>作业再现复习</h1><p>1.什么是shell? 它有什么作用?<br>2.简述管道的用途.<br>3.重定向是什么?有哪些常见类型?<br>4.获取Linux命令行帮助信息的方法有哪些?<br>5.简述命令行命令的语法格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shell是一个用户和操作系统内核之间的一个接口，类似与命令解释器，</span><br><span class="line">输入命令，shell负责解析命令，启动程序和进程等操作</span><br><span class="line">作用：</span><br><span class="line">命令执行</span><br><span class="line">脚本编程</span><br><span class="line">文件操作</span><br><span class="line">进程管理</span><br><span class="line"></span><br><span class="line">|管道符号</span><br><span class="line">将多个命令连接起来，前面命令的输出作为下一个命令的输入，用来连接两个或者更多的命令。也可以用来过滤数据</span><br><span class="line"></span><br><span class="line">重定向是将命令的输入和输出重定向到文件或者设备中，有&gt;&gt; &lt;&lt; &gt; &lt; 2&gt;&gt;</span><br><span class="line">2&gt;这些等</span><br><span class="line"></span><br><span class="line">获取帮助</span><br><span class="line">man ls</span><br><span class="line">ls --help</span><br><span class="line">info ls</span><br><span class="line">whatis ls</span><br><span class="line"></span><br><span class="line">格式是：</span><br><span class="line">命令 选项 参数</span><br></pre></td></tr></table></figure><p>1.常见的Linux文件类型有哪些?<br>2.用户账户的配置文件有哪些?各有什么用途?<br>3.简述用户账户配置文件的记录格式。<br>4.组账户的配置文件有哪些?它们各自有什么用途?<br>5.简述组账户配置文件的记录格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">普通文件，目录，符号连接，字符设备文件，管道文件，块设备文件</span><br><span class="line"></span><br><span class="line">/etc/passwd 基本信息</span><br><span class="line">/etc/shadow 密码等</span><br><span class="line">/etc/group 组的信息</span><br><span class="line"></span><br><span class="line">/etc/passwd</span><br><span class="line">用户名:密码:UID:GID:描述:家目录:默认Shell</span><br><span class="line">/etc/shadow</span><br><span class="line">用户名:密码:最后修改时间:最小密码年龄:最大密码年龄:警告期:不活动期:过期时间</span><br><span class="line">/etc/group</span><br><span class="line">组名:密码:GID:成员列表</span><br><span class="line"></span><br><span class="line">/etc/group：存储组的信息，包括组名、GID 和组成员列表。</span><br><span class="line">/etc/gshadow：存储与组相关的密码信息（通常为空）。</span><br><span class="line"></span><br><span class="line">/etc/group 的记录格式为：</span><br><span class="line">组名:密码:GID:成员列表</span><br><span class="line">/etc/gshadow 的记录格式为：</span><br><span class="line">组名:密码:管理员列表:成员列表</span><br></pre></td></tr></table></figure><p>1.简述Linux软件包管理的发展历史。<br>2.常见的软件包安装方法有哪些?<br>3.简述apt命令的基本用法。<br>4.简述基于源代码的程序安装流程<br>5.使用apt命令安装apache。<br>6.使用apt命令安装vim。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Linux 软件包管理工具相对简单，用户通常需要手动下载并编译源代码。</span><br><span class="line">二进制包管理：随着 Debian 和 Red Hat 的出现，二进制包管理系统（如 .deb 和 .rpm）得到了广泛采用。</span><br><span class="line">现代化管理：如 apt、yum 和 zypper 等工具使得软件包管理更加简化，支持自动更新和依赖关系管理。</span><br><span class="line"></span><br><span class="line">源代码编译</span><br><span class="line">.deb或者是rpm安装</span><br><span class="line">第三方安装工具</span><br><span class="line"></span><br><span class="line">apt install 包名</span><br><span class="line">apt update 更新</span><br><span class="line">apt grade 升级</span><br><span class="line">apt remove 包名</span><br><span class="line"></span><br><span class="line">下载源代码</span><br><span class="line">解压</span><br><span class="line">cd进入</span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br><span class="line">如果少包的话，那就进行安装</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install vim</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.Shell的变量类型有哪几种?<br>2.简述Shel1脚本的常见方式。<br>3.简述She11分支结构的实现方式。<br>4.简述She1l循环结构的实现方式。<br>5.设计一个Shell程序，添加一个新组group1，然后添加个组的50个用户，用户名的形式为stu<strong>，</strong>从01-50。</p><p>6.设计一个Shel1程序，该程序能接收用户从键盘输入的数，然后求出其总和、最大值和最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">位置参数，环境变量，局部变量，特殊变量，只读变量</span><br><span class="line"></span><br><span class="line">直接执行，交互执行，脚本中嵌入命令，解释器执行</span><br><span class="line"></span><br><span class="line">if-elif-else</span><br><span class="line">case</span><br><span class="line"></span><br><span class="line">for,while,until</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">sudo groupadd group1</span><br><span class="line">for i in $(seq -f &quot;%02g&quot; 1 50)</span><br><span class="line">do </span><br><span class="line">sudo useradd stu$i -g group1</span><br><span class="line">sudo passwd -d stu$i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">sum=0</span><br><span class="line">max=-9999999</span><br><span class="line">min=9999999</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">    read -p &quot;请输入数字 (或输入&#x27;q&#x27;退出): &quot; num</span><br><span class="line">    </span><br><span class="line">    if [ &quot;$num&quot; == &quot;q&quot; ]; then</span><br><span class="line">        break</span><br><span class="line">    elif ! [[ &quot;$num&quot; =~ ^[0-9]+$ ]]; then</span><br><span class="line">        echo &quot;无效输入，请输入一个数字！&quot;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    sum=$((sum + num))</span><br><span class="line">    </span><br><span class="line">    if [ $num -gt $max ]; then</span><br><span class="line">        max=$num</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    if [ $num -lt $min ]; then</span><br><span class="line">        min=$num</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;总和: $sum&quot;</span><br><span class="line">echo &quot;最大值: $max&quot;</span><br><span class="line">echo &quot;最小值: $min&quot;</span><br></pre></td></tr></table></figure><p>1.使用mkdir创建一个父目录不存在的目录时，需添加什么参数?<br>2.Linux操作系统中有哪些常见的文件类型?<br>3.使用什么命令可以删除包括子目录的目录?<br>4.Linux目录结构和windows目录结构有何不同?<br>5.简述软链接文件和硬链接文件的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/memgnankk/aaa</span><br><span class="line"></span><br><span class="line">普通文件</span><br><span class="line">块设备文件</span><br><span class="line">目录文件</span><br><span class="line">符号链接</span><br><span class="line">管道文件</span><br><span class="line">字符设备文件</span><br><span class="line">套接字文件</span><br><span class="line"></span><br><span class="line">rm -rf /home/mengnankk/temp</span><br><span class="line"></span><br><span class="line">Linux的根目录/，所有的文件都从/开始</span><br><span class="line">windows有各个驱动器分区，而Linux只有一个跟目录</span><br><span class="line">Linux分隔符是/</span><br><span class="line">windows是\</span><br><span class="line"></span><br><span class="line">软链接是一个指向原文件的链接，删除原文件后失效,ln- s创建</span><br><span class="line">硬链接是指向文件数据块的，相对于另一个名字，删除原文件后不会失效，直到硬数据全部删除</span><br><span class="line">使用ln创建</span><br></pre></td></tr></table></figure><p>1.简述进程的分类。<br>2.PID是什么，如何查看进程的pid?<br>3.如何向进程发送信号?如何结束进程?<br>4.如何调整进程的优先级?<br>5.常见的进程启动方式有哪些?<br>6.如何使用top命令监控进程的运行状态?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">前台进程，后台进程，守护进程</span><br><span class="line"></span><br><span class="line">Pid是操作系统给每个进程分配的唯一进程符号，用ps aus 或者top查看</span><br><span class="line"></span><br><span class="line">kill pid 删除进程 kill -9 强制删除 -15优雅的删除</span><br><span class="line"></span><br><span class="line">renice -n 10 -p pid直接调整</span><br><span class="line">修改正在进行的程序的优先级</span><br><span class="line">nice -n 10 command 命令的优先级</span><br><span class="line"></span><br><span class="line">命令直接启动</span><br><span class="line">命令 &amp;来启动</span><br><span class="line">nohup 命令来启动</span><br><span class="line"></span><br><span class="line">top直接查看包括 CPU 使用率、内存占用等信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.请解释磁盘分区的含义?<br>2.请解释格式化的含义?<br>3.新磁盘在可以进行文件存取之前需要经过哪些操作?<br>4.简述Linux磁盘设备命名方法。<br>5.简述Linux磁盘分区命令方法。<br>6.简述MBR和GPT的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">磁盘分区是指将一个物理硬盘分割成多个逻辑区域，每个区域可以作为一个独立的磁盘来使用。每个分区可以用于存储不同类型的数据（如操作系统、数据文件、备份等），从而提高磁盘的管理效率和数据安全性。分区还可以帮助操作系统更好地管理硬盘资源，如文件系统的创建、文件存取等。</span><br><span class="line"></span><br><span class="line">格式化是对磁盘或者分区进行初始化的的过程，在磁盘上创建一个文件系统，然后情空之前的其他数据</span><br><span class="line"></span><br><span class="line">先虚拟机新建一块硬盘</span><br><span class="line">分区fdisk /dev/sdb</span><br><span class="line">格式化 mkfs -t ext4 /dev/sdb1</span><br><span class="line">挂载挂载， 先创建一个/home/newdisk,挂载 mount /dev/sdb1 /home/newdisk </span><br><span class="line">然后设置自动挂载</span><br><span class="line">设置自动挂载，打开/etc/fstab 添加一行 </span><br><span class="line">/dev/sdb1 /home/newdisk ext4 defaults 0 0 </span><br><span class="line"></span><br><span class="line">dev/sda、/dev/sdb：表示SATA、SCSI或USB等磁盘设备，a、b、c等字母表示磁盘的顺序。</span><br><span class="line">/dev/sda1、/dev/sda2：表示 /dev/sda 磁盘上的第一个和第二个分区。</span><br><span class="line">/dev/nvme0n1：表示 NVMe 固态硬盘（SSD）设备，n1 是该设备的标识符。</span><br><span class="line">/dev/loop0、/dev/loop1：表示环回设备，通常用于挂载ISO文件等。</span><br><span class="line"></span><br><span class="line">fdisk/parted/lsblk</span><br><span class="line"></span><br><span class="line">MBR 主要用于旧版操作系统（如Windows 7之前的版本），且支持的磁盘容量有限（最大2TB）。</span><br><span class="line">GPT 是现代磁盘的标准，支持大容量磁盘，并且支持更多的分区，适用于较新版本的操作系统（如Windows 10、Linux等）。</span><br></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><code>lsof</code>（List Open Files）是一个用于列出进程打开的文件的命令，可以显示哪些文件被哪些进程占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br><span class="line">lsof /path/to/file  # 查看某个文件被哪个进程打开</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Linux系统中，用于将标准输出和标准错误重定向到文件的符号是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&gt;</span><br></pre></td></tr></table></figure><p>Linux系统中，将标准错误重定向到文件里的符号是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2&gt;</span><br></pre></td></tr></table></figure><p><strong>free命令可以显示系统的内存使用情况</strong></p><p><strong>df是查看硬盘的使用情况</strong></p><p><code>diff</code> 是用于比较文件内容差异的命令，它会显示两个文件之间的不同之处。常用于源代码管理、配置文件比较等场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff file1.txt file2.txt  # 比较 file1.txt 和 file2.txt 文件的差异</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ls -i</code> 命令用于显示文件或目录的 inode 信息。它会在文件名旁边显示该文件的 inode 号</p><p>stat令用于显示文件的详细信息，包括文件的大小、权限、时间戳、inode 等，但它并不是专门用于查看 inode 信息的命令。</p><p><code>lscpu</code> 是一个用于显示 CPU 架构信息的命令，它提供了有关 CPU 的简明概览，包括架构类型、核心数、线程数、CPU 架构、时钟速度等信息。</p><h2 id="补充简答"><a href="#补充简答" class="headerlink" title="补充简答"></a>补充简答</h2><p>在 Linux 中查看设备信息，可以通过多种命令来查看不同类型的硬件设备信息，如 CPU、内存、硬盘、网络设备等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lscup</span><br><span class="line">free -h</span><br><span class="line">lsblk</span><br><span class="line">df -h </span><br><span class="line">sudo fdisk -l </span><br><span class="line">ipconfig</span><br><span class="line">ip addr </span><br><span class="line">lspci -v</span><br><span class="line">lsusb</span><br><span class="line">sudo lshw</span><br><span class="line">uname -a</span><br><span class="line">sudo dimidcode</span><br><span class="line">lspci |grep VGA</span><br><span class="line">ls /dev</span><br><span class="line">sudo parted -l</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简述 Linux 中文件系统的卸载选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux 中，卸载文件系统使用 `umount` 命令</span><br><span class="line">其实就是取消挂载</span><br><span class="line">-l是懒卸载，就是自动卸载</span><br><span class="line">-f是强制卸载</span><br><span class="line">-a 是卸载所有</span><br></pre></td></tr></table></figure><p>怎样在 Linux 中为内核模块传递参数?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 Linux 中，可以通过 `modprobe` 命令或在 `/etc/modules-load.d/` 配置文件中为内核模块传递参数。</span><br><span class="line">sudo modprobe my_module param=5</span><br><span class="line">options my_module param=5</span><br><span class="line">也可以将模块参数配置在系统文件中，以便在系统启动时自动传递。将配置写入 /etc/modprobe.d/ 目录下的某个文件，如 my_module.conf。</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Linux/">Linux</category>
      
      
      <comments>https://blog.tokenlen.top/2024/11/25/linux11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>查找算法</title>
      <link>https://blog.tokenlen.top/2024/11/11/data6/</link>
      <guid>https://blog.tokenlen.top/2024/11/11/data6/</guid>
      <pubDate>Sun, 10 Nov 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;查找算法主要用于在集合（如数组、列表、树等）中寻找特定的元素。以下是几种常见的查找算法以及相应的代码示例。&lt;/p&gt;
&lt;h1 id=&quot;线性查找&quot;&gt;&lt;a href=&quot;#线性查找&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>查找算法主要用于在集合（如数组、列表、树等）中寻找特定的元素。以下是几种常见的查找算法以及相应的代码示例。</p><h1 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h1><p>线性查找是一种简单的查找方法，它逐个检查每个元素，直到找到目标元素或遍历完整个集合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class LinearSearch &#123;</span><br><span class="line">    public static int linearSearch(int[] arr, int target) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] == target) &#123;</span><br><span class="line">                return i;  // 返回目标元素的索引</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;  // 如果找不到，返回-1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;2, 5, 8, 3, 6, 9&#125;;</span><br><span class="line">        int target = 3;</span><br><span class="line">        int result = linearSearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h1><p>二分查找是对已经排序的数组进行查找的有效算法。每次通过中间元素来缩小查找范围，直到找到目标元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static int binarysearch(int[] arr,int target)&#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = arr.length - 1;</span><br><span class="line">        while (left&lt;=right)&#123;</span><br><span class="line">            int mid = left + (right - left)/2;</span><br><span class="line">            if (arr[mid] == target)&#123;</span><br><span class="line">                return  mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[mid]&lt;target)&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 3, 5, 7, 9, 11&#125;;</span><br><span class="line">        int target = 7;</span><br><span class="line">        int result = binarysearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h1><p>哈希查找通过使用哈希表来进行查找，时间复杂度通常为 O(1)，是查找速度最快的方法之一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">public class HashSearch &#123;</span><br><span class="line">    public static boolean hashSearch(HashSet&lt;Integer&gt; set,int target)&#123;</span><br><span class="line">        return set.contains(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(1);</span><br><span class="line">        set.add(5);</span><br><span class="line">        set.add(3);</span><br><span class="line">        set.add(6);</span><br><span class="line">        set.add(7);</span><br><span class="line">        int target  = 3;</span><br><span class="line">        if (hashSearch(set,target))&#123;</span><br><span class="line">            System.out.println(target+&quot;yes&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(target+&quot;no&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hash查找主要是看该数据的hash值，hash值一般是不相同的，所以能通过hash值来进行查找</p><h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><p>是一种遍历或查找图、树的算法，常用于图形和树形结构的查找。它通过尽可能深入地访问每个分支来遍历整个结构。</p><p>主要是用递归来解决</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class DFS &#123;</span><br><span class="line">    static class TreeNode &#123;</span><br><span class="line">        int value;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        TreeNode(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean dfs(TreeNode node, int target) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.value == target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 递归地搜索左子树和右子树</span><br><span class="line">        return dfs(node.left, target) || dfs(node.right, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        root.left = new TreeNode(2);</span><br><span class="line">        root.right = new TreeNode(3);</span><br><span class="line">        root.left.left = new TreeNode(4);</span><br><span class="line">        root.left.right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">        int target = 4;</span><br><span class="line">        if (dfs(root, target)) &#123;</span><br><span class="line">            System.out.println(&quot;找到了目标元素 &quot; + target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;未找到目标元素 &quot; + target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><p>用于查找图或树结构中的元素。与深度优先搜索不同，广度优先搜索逐层扫描，首先访问每一层的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class BFS &#123;</span><br><span class="line">    static class TreeNode &#123;</span><br><span class="line">        int value;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        TreeNode(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean bfs(TreeNode root, int target) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.value == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        root.left = new TreeNode(2);</span><br><span class="line">        root.right = new TreeNode(3);</span><br><span class="line">        root.left.left = new TreeNode(4);</span><br><span class="line">        root.left.right = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">        int target = 5;</span><br><span class="line">        if (bfs(root, target)) &#123;</span><br><span class="line">            System.out.println(&quot;找到了目标元素 &quot; + target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;未找到目标元素 &quot; + target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="插入查找"><a href="#插入查找" class="headerlink" title="插入查找"></a>插入查找</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class InterpolationSearch &#123;</span><br><span class="line">    public static int interpolationSearch(int[] arr,int target)&#123;</span><br><span class="line">        int left = 0,right = arr.length - 1;</span><br><span class="line">        while (left&lt;=right&amp;&amp;target&gt;=arr[left]&amp;&amp;target&lt;=arr[right])&#123;</span><br><span class="line">            if (arr[right] == arr[left])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            int mid = left + ((target - arr[left]*(right-left))/(arr[right]-arr[left]));</span><br><span class="line">            if(arr[mid] == target)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[mid]&lt;target)&#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&#125;;</span><br><span class="line">        int target = 70;</span><br><span class="line">        int result = interpolationSearch(arr, target);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            System.out.println(&quot;元素未找到&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;元素 &quot; + target + &quot; 在索引 &quot; + result + &quot; 处&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实现</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>每次在未排序部分选择最小（或最大）元素，然后与未排序部分的第一个元素交换，直到整个数组有序。</p><p>每次只进行一次交换操作。</p><p>时间复杂度：O(n^2)，无论数据是否已经有序。</p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void selectionSort(int[] arr) &#123;</span><br><span class="line">        int comparisons = 0;</span><br><span class="line">        for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                comparisons++;</span><br><span class="line">                if (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;！：&quot; + comparisons);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;5, 2, 9, 1, 5, 6&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        for (int num : arr) &#123;</span><br><span class="line">            System.out.print(num + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h1><p>每次比较相邻的两个元素，如果顺序错误则交换它们，经过一轮比较后，最大（或最小）元素会“浮”到数组的末端。重复这个过程，直到数组有序。</p><p>其实可以也叫做冒泡排序</p><p>时间复杂度：O(n^2)，如果数据已经有序，可以优化为 O(n)。</p><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void bubbleSort(int[] arr)&#123;</span><br><span class="line">        int comparisons =0;</span><br><span class="line">        for (int i =0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            for ( int j = 0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">                comparisons++;</span><br><span class="line">                if (arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                    int temp =  arr[j];</span><br><span class="line">                    arr[j] = arr[j+1];</span><br><span class="line">                    arr[j+1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(comparisons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://blog.tokenlen.top/2024/11/11/data6/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
