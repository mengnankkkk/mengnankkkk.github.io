<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Fri, 01 Aug 2025 09:47:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>面试模拟-202508</title>
      <link>https://blog.tokenlen.top/2025/07/29/towork/woking3/</link>
      <guid>https://blog.tokenlen.top/2025/07/29/towork/woking3/</guid>
      <pubDate>Mon, 28 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;Gemini模拟面试2025-7-29&quot;&gt;&lt;a href=&quot;#Gemini模拟面试2025-7-29&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Gemini模拟面试2025-7-29"><a href="#Gemini模拟面试2025-7-29" class="headerlink" title="Gemini模拟面试2025.7.29"></a>Gemini模拟面试2025.7.29</h1><p>1.Java面向对象的基本特性：</p><p>总：的介绍一下java面向对象</p><p>分：封装，继承，多态</p><p>总：好处</p><p>2.Hashmap的原理</p><p>总：hashmap是个啥</p><p>分：</p><ol><li><p>基本数据结构类型，1.7 or 1.8</p></li><li><p>hash冲突解决</p></li><li><p>核心put过程</p></li><li><p>扩容机制，为什么是2倍</p></li><li><p>线程安全实现</p></li><li><p>concurrenthashmap</p></li><li><p>平时使用场景</p></li></ol><p>3.<strong>ArrayList 和 LinkedList 的区别</strong> </p><ol><li>底层数据结构</li><li>插入删除遍历节点</li><li>扩容</li><li>使用场景：</li></ol><p>4.常用的设计模式</p><ol><li>单例：饿汉式，懒汉式，DCL 枚举 实际应用，RedisClient AppConfig Spring bean</li><li>策略：</li><li>模板</li><li>观察</li><li>工厂</li></ol><p>5.ThreadLocal的实现</p><ol><li>底层数据结构</li></ol><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，key为实例，value是为具体的对象</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><ol><li><p>内存泄漏问题</p></li><li><p>使用场景</p></li></ol><p>6.你如何理解“悲观锁与乐观锁”？分别适用哪些场景？CAS 原理是什么？</p><ol><li>悲观锁，乐观锁代表什么，实例，场景</li><li>CAS原理，OS的cmpxchg</li><li>CAS问题</li><li>使用场景</li></ol><p>7.说一下 Java 中的 <code>synchronized</code> 关键字的实现原理、优化机制，以及它和 <code>ReentrantLock</code> 的区别</p><ol><li>底层原理，对象头中的 monitor 锁，每个对象在 JVM 中都有一个对象头，包含了锁标志位和指向 monitor 的指针。当线程进入 <code>synchronized</code> 块或方法时，会尝试获得这个对象的 monitor。多线程竞争时，会进行 <strong>锁的升级</strong>，这就是 HotSpot 中的锁优化。</li><li>锁的升级过程，无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>和<code>ReentrantLock</code> 对比</li></ol><p>8.说一下 Java 中的 <code>volatile</code> 关键字的作用，它能实现线程安全吗？它和 <code>synchronized</code> 有什么区别？</p><ol><li><p>可见性，禁止重排性</p></li><li><p>不能保证原子下，i++</p></li><li><p>和JMM的关系：JMM规定了主内存和工作内存的交互规则，volatile 会强制线程刷新工作内存和主内存之间的数据。</p><p>写 volatile → 插入一个 Store + StoreBarrier 。读 volatile → 插入一个 LoadBarrier + Load</p></li><li><p>应用场景，标识位，布尔控制变量，DCL</p></li><li><p>和<code>synchronized</code> 对比</p></li></ol><h1 id="MYDB项目"><a href="#MYDB项目" class="headerlink" title="MYDB项目"></a>MYDB项目</h1>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/29/towork/woking3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-1</title>
      <link>https://blog.tokenlen.top/2025/07/25/towork/woking2/</link>
      <guid>https://blog.tokenlen.top/2025/07/25/towork/woking2/</guid>
      <pubDate>Thu, 24 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;他人面经&quot;&gt;&lt;a href=&quot;#他人面经&quot; class=&quot;headerlink&quot; title=&quot;他人面经&quot;&gt;&lt;/a&gt;他人面经&lt;/h1&gt;&lt;h2 id=&quot;1-spring的底层实现-amp-三级缓存原理&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="他人面经"><a href="#他人面经" class="headerlink" title="他人面经"></a>他人面经</h1><h2 id="1-spring的底层实现-amp-三级缓存原理"><a href="#1-spring的底层实现-amp-三级缓存原理" class="headerlink" title="1.spring的底层实现&amp;三级缓存原理"></a>1.spring的底层实现&amp;三级缓存原理</h2><p>我们先来说三级缓存的实现吧</p><p>首先三级缓存是那三个缓存呢？是在DefaultSingletonBeanRegistry类里面定义的三个Map。然后第一第二层都是key是bean的名字，value是bean的实例。第三次key是bean的名字，value是objectfactory.</p><p>第一层缓存是用来存储我们已经完全实例化好的bean,在这里可以直接使用的</p><p>第二层缓存时用来存储我们早期的bean，创建好，但是并没有进行依赖注入的</p><p>第三次缓存是用来存储我们的objectfactory的，用来创建代理对象的</p><p>然后我们缓存的核心方法是我们的getSingleton方法，他定义了我们如何去获取缓存的顺序</p><p>我们首先先去看第一层缓存，如果第一次没有且bean正在创建中的话。我们再去找第二层缓存，第二层也没有的话，允许早期引用。然后从三级缓存中获取objectfactory</p><p>然后使用objectfactory来创建对象，这里可能是代理对象。因为比如AOP，或者使用了其他的代理模式</p><p>然后将其升级到二级缓存，将三级缓存里面的删除。（暂不使用，然后再可以进行依赖注入。然后如果我们的作用域是单例的话，就直接放入一级缓存，不是的话，就根据场景来）</p><p>然后在我们进行依赖注入的时候可能会出现循环依赖的问题，就是A依赖于B，B也依赖于A的问题</p><p>这个时候就需要解决依赖的问题，我们的三层缓存使用的是提前暴露的方法来解决循环依赖的问题</p><p>在AbstractAutowireCapableBeanFactory.doCreateBean的方法里面定义了解决的实现</p><p>首先我们先实例化bean，只是采用<em>构造器，</em>创建，并没有进行属性的注入</p><p>然后我们去判断需不要早期暴露，是不是单例的，因为单例的才会允许循环依赖注入。然后允不允许我们循环依赖。这个是在SpringApplication中设置的，然后这个bean是不是正在被创建中。，</p><p>满足了这个条件，我们才会将objectfactory放入三级缓存的时候，保证二级缓存没有，然后这个会获取一个早期引用，如果我们需要AOP 的话，会获取他的代理对象</p><p>然后对我们需要的依赖进行属性的填充，进行依赖注入</p><p>注入完进行初始化bean</p><p>然后为什么是三级缓存呢？因为<strong>AOP代理对象的延迟创建问题</strong></p><p>在AOP的后置处理器中，获取早期的引用对象的时候，会返回的是我们的代理对象。</p><p>如果我们使用二级缓存的，不知道什么时候创建代理对象，可能会创建多个代理对象，AOP的时机控制会失效。</p><p>so:</p><p>三级缓存通过ObjectFactory实现了：</p><ul><li><strong>按需创建</strong>：只有真正发生循环依赖时才创建代理对象</li><li><strong>唯一性保证</strong>：确保一个Bean只有一个早期引用实例</li><li><strong>时机控制</strong>：代理对象的创建时机由Spring容器精确控制</li></ul><h2 id="2-hashmap为什么扩容要是2的倍数"><a href="#2-hashmap为什么扩容要是2的倍数" class="headerlink" title="2.hashmap为什么扩容要是2的倍数"></a>2.hashmap为什么扩容要是2的倍数</h2><p>HashMap扩容为2的倍数的根本原因是为了实现<strong>高效的哈希计算</strong>和<strong>均匀的元素分布</strong>。</p><p>我们hashmap的tableSizeFor进行容量初始化的时候，通过位运算确保了任何输入都会背转换成<strong>大于等于该数的最小2的幂次方</strong>。确保了容量为2的次方幂。</p><p>然后在put一个元素的时候，我们是通过hash来确定这个值得索引的，使用的是<strong>(n-1) &amp; hash 的按位与运算</strong>来确定位置的。然后hash函数也进行了优化，<em>高16位与低16位异或，增加散列的随机性</em>。</p><p>然后我们的扩容方法里面是这样规定的，是单个元素的话，我们使用位运算重新规划位置，如果是红黑树的话，我们对他的头节点进行位运算，</p><p>如果是链表的话，我们要对链表进行拆分，通过一个位来判断元素的去向，如果与老容量的位运算是0的话，就留在原位置，是1的话就转移到原位置+oldcap的位置，这个算法是非常巧妙的，比如假设hash为21，oldcap=16-1,那么原位置就是5，然后现在我们再进行运算，21&amp;16=0，那么他就是留在原位置。</p><p>然后讲我们拆分的链表加入到我们新的数组之中。这个时候要注意链表的长度，如果超过了8的话，且数组位数大于64，需要转为红黑树。</p><p>然后为什么是2的倍数呢？当我们的数字长度为2的次方幂的时候，我们使用位运算比我们的取模运算高效的多，然后我们不需要重新计算hash值，只需要检查一个位就可以确定新的位置，然后如果是2的幂次方保证了hash值的每一位都能参与到索引计算中，而且对cpu的缓存更加友好</p><h2 id="3-sychronized的底层原理"><a href="#3-sychronized的底层原理" class="headerlink" title="3.sychronized的底层原理"></a>3.sychronized的底层原理</h2><p>sychronized的底层原理，如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>sychronized的字节码层面的实现是基于监视器实现的，进入监视器，然后执行sychronized修饰的代码块，然后退出监视器</p><p>然后在Hotspot JVM中，synchronized基于Monitor对象实现，ObjectMonitor规定了持有锁的线程，重入的次数，等待获取锁的线程的队列，竞争队列，wait方法等待的线程</p><p>然后如果我们成功获得锁，直接返回。如果是线程的id等于锁的id的话，重入锁的计数器+1,然后如果不相等的话，就产生了锁的竞争，将其放入慢路径。然后慢路径里面的线程自旋，继续取尝试获取活，如果超过了重试次数的话，将其加入等待队列。</p><p>然后出现的三个线程的关系是，竞争队列-&gt;唤醒队列-&gt;获取锁</p><p>然后如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>我们可以使用countDownLatch</p><p>分为A，B两个线程，分别重写他们的run方法，然后A线程执行完之后计数器完成，就通知B线程可以进行。</p><p>然后B线程，重修run方法，调用wait等待，计数器为0的时候开始线程的执行</p><p>然后countdownlatch的底层实现是，state等于0的时候允许通过，然后释放锁的通过cas来实现的</p><p>或者是使用Semaphore，将其初始化为0，然后分为线程A和线程B，线程A执行完之后释放许可，然后B线程执行的时候，尝试获取许可执行</p><p>或者是直接使用LockSupport，在A线程完之后，直接唤醒线程B，然后重写B线程的run方法，先是park的等待A线程执行完之后的唤醒</p><p>然后我们最常用的实现方案是synchronized + wait/notify</p><p>我们先初始化lock然后用sychronized去获取lock,和一个静态的标识位设定为A线程是不是完成。</p><p>然后重写A线程run方法，讲标志位设定为true，然后唤醒等待的线程。线程Bwait等待去执行</p><h2 id="4-tcp状态机，java底层怎么实现tcp的"><a href="#4-tcp状态机，java底层怎么实现tcp的" class="headerlink" title="4.tcp状态机，java底层怎么实现tcp的"></a>4.tcp状态机，java底层怎么实现tcp的</h2><p>那我先说TCP状态机的流程吧，分为客户端状态机和服务端状态机</p><p>客户端：</p><p>CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</p><p>服务端：</p><p>CLOSED -&gt; LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED(0),      // 初始状态，无连接</span><br><span class="line">LISTEN(1),      // 服务端监听状态</span><br><span class="line">SYN_SENT(2),    // 客户端发送SYN后的状态</span><br><span class="line">SYN_RCVD(3),    // 服务端收到SYN后的状态</span><br><span class="line">ESTABLISHED(4), // 连接建立状态</span><br><span class="line">FIN_WAIT_1(5),  // 主动关闭方发送FIN后的状态</span><br><span class="line">FIN_WAIT_2(6),  // 主动关闭方收到ACK后的状态</span><br><span class="line">CLOSE_WAIT(7),  // 被动关闭方收到FIN后的状态</span><br><span class="line">CLOSING(8),     // 双方同时关闭的中间状态</span><br><span class="line">LAST_ACK(9),    // 被动关闭方发送FIN后的状态</span><br><span class="line">IME_WAIT(10);  // 主动关闭方的最终等待状态</span><br></pre></td></tr></table></figure><p>那我先说一下TCP三次握手的状态机变化：</p><p>客户端主动连接服务端，首先客户端的状态机位close，然后发送完SYN包之后变为SYN_SENT</p><p>然后收到服务端发来的SYN+ACK包，发送ACK包，然后状态转为 ESTABLISHED </p><p>服务端是监听状态的情况下，接收到客户端的SYN包之后，发送SYN-ACK包，状态变为SYN_RCVD</p><p>然后收到客户端的ACK包，状态转变为ESTABLISHED </p><p>TCP四次挥手状态机变化</p><p>先是主动关闭方，一般是客户端，发送FIN包，然后变为FIN_WAIT_1 状态</p><p>然后收到服务端发来的ACK，状态转变为FIN_WAIT_2</p><p>然后再收到发来的FIN包，向服务端发送ACK，转为 TIME_WAIT 等待2MSL后关闭，变为Close状态</p><p>服务端，收到FIN请求后，发送ACK，请求，变为CLOSE_WAIT，然后应用程序调用close方法，发送FIN包，状态变为LAST_ACK</p><p>然后收到ACK请求后，状态变为CLose,彻底关闭</p><hr><p>后面这个有些难度了，哭</p><h2 id="5-协程和线程的区别是什么？"><a href="#5-协程和线程的区别是什么？" class="headerlink" title="5.协程和线程的区别是什么？"></a>5.协程和线程的区别是什么？</h2><p>线程是由操作系统内核进行抢占式调度，任何时候都可能被强制切换，二协程是由用户态程序进行协作式调度，只在主动让出时才会切换</p><p>然后线程：</p><ul><li>每个线程需要独立的栈空间（通常1MB）</li><li>创建和切换需要用户态和内核态转换，开销较大</li><li>1000个线程大约占用1GB内存</li><li>共享内存模型，需要使用锁、synchronized等机制保证线程安全</li></ul><p>适合：</p><ul><li>CPU密集型任务</li><li>需要真正并行执行的场景</li><li>传统的多线程编程</li></ul><p>协程：</p><ul><li>栈空间很小（通常几KB）</li><li>在用户态完成创建和切换，开销很小</li><li>10万个协程可能只占用几百MB内存</li><li>通常采用消息传递模型（如Channel），天然避免数据竞争</li></ul><p>适合：</p><ul><li>IO密集型任务</li><li>高并发场景（如服务器处理大量连接）</li><li>异步编程，避免回调地狱</li></ul><p>协程是轻量级的用户态线程，更适合高并发的IO密集型场景，而线程更适合CPU密集型的并行计算场景。协程的核心优势是用更少的资源实现更高的并发度。</p><h2 id="6-介绍一下ArrayList扩容机制"><a href="#6-介绍一下ArrayList扩容机制" class="headerlink" title="6.介绍一下ArrayList扩容机制"></a>6.介绍一下ArrayList扩容机制</h2><p>首先先介绍一下ArrayList他的底层是动态的数组，默认的容量为10。但是有一个最大数组的容量，这个主要是考虑JVM的，因为ArrayList给他在JVM里面分配的是一个连续的内存。最大是Integer.MAX_VALUE - 8，为什么呢？JVM在数组对象头中需要存储一些元数据，预留防止出现OOM</p><p>然后ArrayList的扩容是add元素之后，剩余的内存容量还足够，通过数组复制的方法，为新元素腾出空间</p><p>我们首先会进行容量的检查，这里检查的是Size+1，先去查查内部的容量，然后去检查我们所需要的容量，如果是空数组的话，那么至少需要10的容量</p><p>然后去显示的检查容量，计数器+1，如果最小需求容量&gt;当前数组的长度的话，就进行扩容</p><p>然后触发核心的扩容方法，新的容量是<em>新容量 = 旧容量 + 旧容量的一半</em>，是根据oldCapacity + (oldCapacity &gt;&gt; 1)计算来的。这样计算更快</p><p>然后处理边界的情况，先是最小边界，1.5倍如果还不够的话，就用最小需求量，然后是超大的边界处理，将容量设为容量的最大值</p><p>然后检查完之后，进行数组的复制，将元素复制到更大的数组。这里使用<em>Arrays.copyOf然后最终调用System.arraycopy的</em>native方法</p><p>优化的策略：</p><p>我们可以先进行预估一下，然后再确定一开始初始化需要的初始容量，避免频繁扩容。最好的办法是，开了负载因子，然后容量比我们预计的多一点</p><h2 id="7-口述实现非公平与公平的redis分布式锁"><a href="#7-口述实现非公平与公平的redis分布式锁" class="headerlink" title="7.口述实现非公平与公平的redis分布式锁"></a>7.口述实现非公平与公平的redis分布式锁</h2><p>非公平锁：</p><p>获取锁</p><ol><li>使用<code>SET key value NX EX timeout</code>命令尝试获取锁</li><li>如果设置成功，说明获取锁成功，返回true</li><li>如果设置失败，说明锁被占用，可以选择重试或返回失败</li><li>value通常设置为当前线程的唯一标识（如UUID+线程ID）</li></ol><p>释放锁</p><ol><li>使用Lua脚本确保原子性操作</li><li>先检查锁的value是否是当前线程设置的</li><li>如果是，则执行DEL命令删除锁</li><li>如果不是，说明锁已超时被其他线程获取，不能删除</li></ol><p>重试机制</p><ul><li>获取失败后，线程sleep一小段时间再重试</li><li>重试间隔可以是固定时间或采用指数退避策略</li><li>设置最大重试次数或超时时间避免无限等待</li></ul><p>公平锁：</p><p>获取锁</p><ol><li><strong>检查当前锁状态</strong><ul><li>如果锁未被占用，直接尝试获取</li><li>如果被占用，进入排队流程</li></ul></li><li><strong>加入等待队列</strong><ul><li>将当前线程标识和时间戳加入<code>queue:resource_name</code>有序列表</li><li>使用ZADD命令，以时间戳为分数确保顺序</li></ul></li><li><strong>检查队列位置</strong><ul><li>获取队列中的第一个元素（最早等待的线程）</li><li>如果是当前线程，说明轮到自己，尝试获取锁</li><li>如果不是，继续等待</li></ul></li><li><strong>等待通知机制</strong><ul><li>使用Redis的BLPOP或发布订阅机制等待通知</li><li>或者采用轮询方式，定期检查是否轮到自己</li></ul></li><li><strong>获取锁的尝试</strong><ul><li>当轮到自己时，使用SET NX命令尝试获取锁</li><li>获取成功后，从等待队列中移除自己</li><li>获取失败说明锁被其他线程抢占，重新进入等待</li></ul></li></ol><p>释放锁</p><ol><li><strong>释放锁资源</strong><ul><li>使用Lua脚本原子性地检查并删除锁</li></ul></li><li><strong>通知下一个等待者</strong><ul><li>从等待队列中获取下一个等待的线程</li><li>向该线程发送通知信号</li><li>可以使用Redis的发布订阅或设置特定key来通知</li></ul></li><li><strong>清理过期等待者</strong><ul><li>定期清理队列中的过期等待线程</li><li>避免队列无限增长</li></ul></li></ol><h2 id="9-OS的虚拟内存和页面置换算法"><a href="#9-OS的虚拟内存和页面置换算法" class="headerlink" title="9.OS的虚拟内存和页面置换算法"></a>9.OS的虚拟内存和页面置换算法</h2><p>虚拟内存是操作系统的核心抽象，通过MMU和页表机制将进程的虚拟地址空间映射到有限的物理内存，实现内存保护、共享和扩展。</p><p>当物理内存不足时，页面置换算法决定哪些页面被换出到磁盘。<strong>FIFO算法</strong>实现简单但可能出现Belady异常；<strong>LRU算法</strong>基于局部性原理效果最好但实现成本高；<strong>Clock算法</strong>是LRU的高效近似实现，使用访问位模拟时钟指针给页面第二次机会；<strong>Enhanced Clock算法</strong>进一步考虑修改位，优先置换干净页面减少磁盘I/O。</p><p>现代操作系统如Linux采用多层LRU设计，将页面分为active和inactive链表动态管理热度，并结合预取、内存压缩等技术优化性能。<strong>关键是要平衡算法复杂度与性能提升，充分利用程序的时间空间局部性，同时考虑NUMA、SSD等现代硬件特性</strong>。在生产环境中需要根据应用特征选择合适策略，避免内存抖动，并通过监控缺页率等指标持续优化。虚拟内存的设计体现了操作系统在资源管理上的核心思想：通过抽象和调度算法，在有限资源上为应用提供无限且高效的服务体验。</p><h2 id="10-AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写"><a href="#10-AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写" class="headerlink" title="10.AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写"></a>10.AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写</h2><p>AQS是一个设计思想，本质上就是一个同步器框架。主要控制状态管理和线程排队，状态管理交给子类，然后线程排队AQS统一处理</p><p>核心组件就是state变量和CLH队列变种</p><p>state:</p><ul><li>使用volatile int保证可见性</li><li>通过CAS操作保证原子性修改</li><li>语义由子类定义：可以表示锁的持有状态、信号量的许可数量、CountDownLatch的计数等</li></ul><p>CLH队列：</p><ul><li><strong>双向链表</strong>：支持超时和中断处理</li><li><strong>虚拟头节点</strong>：简化边界条件处理</li><li><strong>节点状态</strong>：SIGNAL、CANCELLED、CONDITION等，精确控制唤醒时机</li></ul><p>流程：</p><p>他是先尝试快速获取锁，避免排队。失败后加入队列，但是不会立刻阻塞。在队列中尝试去获得锁，获取前驱释放的锁。实在无法获取的适合才堵塞。</p><p>然后获取锁的时候state+1，线程Id=锁的Id，然后解锁的时候-1。知道为0的时候释放锁。</p><p>然后在CLH中设计了<strong>懒初始化</strong>：只有竞争时才创建队列，减少内存开销。设计了唤醒机制，释放资源的线程负责唤醒后记的节点，被唤醒的线程获取资源后，唤醒下一个。避免了雷鸣群羊”问题，精确控制唤醒数量</p><p>被唤醒的线程，实现CAS自旋尝试去获得锁，失败后会被park，直到再次unpark。</p><p>同步工具，我写了一个基于AQS和令牌桶实现的限流操作</p><p>先是引入桶容量，每秒补充的速率。然后对他们进行初始化，初始化令牌桶，将时间戳和令牌数压缩到一个long变量中。</p><p>然后重要的是实现<em>tryAcquire </em>和tryRelease，但是令牌桶不需要主动的释放资源</p><p>先去解析我们当前的状态，获取时间和需要的令牌数量，然后计算我们需要补充的令牌的数量，然后判断我们是否可以获取。然后使用CAS更新状态，返回剩余令牌数。CAS失败就自旋重试，避免了线程堵塞。</p><h2 id="11-介绍一下动态代理"><a href="#11-介绍一下动态代理" class="headerlink" title="11.介绍一下动态代理"></a>11.介绍一下动态代理</h2><p>动态代理主要有<strong>JDK动态代理</strong>和<strong>CGLIB字节码增强</strong>两种实现方式。<strong>JDK动态代理</strong>基于接口，在运行时通过Proxy.newProxyInstance()创建代理对象，底层使用反射调用InvocationHandler的invoke方法来拦截目标方法；<strong>CGLIB字节码增强</strong>无需接口，通过ASM字节码操作库在运行时生成目标类的子类，重写目标方法并插入拦截逻辑，在方法中通过super调用原始方法或MethodInterceptor进行增强。<strong>核心区别</strong>：JDK代理生成的是接口实现类，性能更好但必须有接口；CGLIB生成的是继承子类，更灵活但不能代理final方法。Spring AOP默认策略是有接口用JDK代理，无接口用CGLIB，都是在运行时动态生成字节码实现方法拦截和功能增强，广泛应用于AOP、事务管理、权限控制等场景。</p><h2 id="12-tomcat底层（TODO）"><a href="#12-tomcat底层（TODO）" class="headerlink" title="12.tomcat底层（TODO）"></a>12.tomcat底层（TODO）</h2><h2 id="13-布隆过滤器的底层实现"><a href="#13-布隆过滤器的底层实现" class="headerlink" title="13.布隆过滤器的底层实现"></a>13.布隆过滤器的底层实现</h2><p>布隆过滤器本质上就是一个大的Bitset+多个独立的hash函数，<em>根据期望元素数和误判率计算最优参数</em>，假设有m个位，k个哈希函数，插入n个元素，最优数组位大小是 -n <em> ln(p) / (ln(2))²</em>，最优hash函数个数是<em>k = (m/n) </em> ln(2)</p><p>然后我们添加元素的时候，对元素进行hash，然后放在对应的hash%bitsetsize的位置上，然后设置为1</p><p>查询元素的时候，遍历hash，获取其index，然后必须所以的hash位都要是1才可能存在</p><p>我们单个使用hash太慢了，我们需要高效生成k个独立的哈希值，就可以使用双hash方法，使用两个不同的哈希函数，比如一个直接调用，一个取16位，让组合生成一个新的hash比如hash1+i+hash2,常用MurmurHash + FNV Hash两个hash组合</p><p>然后其布隆过滤器不是完全准确的，可能布隆过滤器中没有，但是数据库中有的，我们就需要计算准确率，较少的计算出某个位为0的概率，然后计算出k个位都为1但是元素不存在的概率</p><p>然后1-概率1 pow上概率2</p><p>当这个布隆过滤器很大的时候，一般我们都用16位就可以了，k=16时已经能提供足够好的误判率。理论值误判率：(1 - e^(-kn/m))^k</p><p>单个优化策略：</p><ol><li><strong>动态扩容</strong>，<em>创建新的过滤器，容量翻倍，误判率减半</em>，然后只要有一个过滤器返回true就可以</li><li>增加位数组大小，相同的元素数量下，位数组越多，误判率越小。</li><li><strong>Counting Bloom Filter</strong>，使用计数器代替位数组，成功添加之后，计数器+1，避免单一位冲突，可以支持删除操作</li><li>分层布隆过滤器，元素依次通过多层过滤器，在第一个返回的层添加其元素。然后只有所有的层都返回true才表明存在</li></ol><p>关键特性：</p><p>如何判断没有一定没有？</p><ul><li>如果元素真的被添加过，它的所有哈希位置都<strong>必须</strong>为1，发现任何一个位置为0，说明元素<strong>绝对没有</strong>被添加过，所有位置都为1时，可能是其他元素设置的（假阳性）</li></ul><p>然后实际的参数的设计，100万商品的话，误判率设为0.01</p><p>然后位数组大小 ≈ 9,585,058*，然后单击场景我们就放在JVM内存中，分布式的话就存在redis里面</p><h2 id="14-ThreadLocal的底层实现"><a href="#14-ThreadLocal的底层实现" class="headerlink" title="14.ThreadLocal的底层实现"></a>14.ThreadLocal的底层实现</h2><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，其键是 <code>ThreadLocal</code> 实例对象（弱引用），值是线程本地变量的值（强引用）。</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><p>Threadlocal可以用于线程不安全类的线程安全封装，<strong>典型场景</strong>：<code>SimpleDateFormat</code>。<code>SimpleDateFormat</code> 是一个线程不安全的类，可以为每个线程提供一个独立的实例，避免竞争。</p><p>在数据库连接的时候应用，通常为每个线程（每个请求）独立创建一个数据库连接，使用 <code>ThreadLocal</code> 来管理这些连接。</p><p>管理用户的上下文信息，这个最常用</p><p>在分布式事务或者嵌套事务中，通过 <code>ThreadLocal</code> 存储事务信息，使得同一线程的不同方法调用间能共享事务上下文。</p><p><strong>InheritableThreadLocal</strong> 用于子线程继承父线程变量；</p><h2 id="15-详细解析下CAS和原子类"><a href="#15-详细解析下CAS和原子类" class="headerlink" title="15.详细解析下CAS和原子类"></a>15.详细解析下CAS和原子类</h2><p>CAS的英文是compare and swap ，就是比较然后交换的意思，他是一个原子操作，用于在多线程环境下实现同步</p><p>包括三个操作数</p><ul><li><strong>V</strong>：要更新的变量（内存地址）。</li><li><strong>E</strong>：期望值。</li><li><strong>N</strong>：新值。</li></ul><p>CAS 指令会先比较 V 的当前值是否等于 E，如果相等，则将 V 的值原子性地更新为 N；如果不相等，则什么也不做。 整个比较和替换操作是一个原子操作。通常会返回一个布尔值，表示是不是操作成功</p><p>CAS 的实现依赖于 CPU 提供的原子指令。不同的 CPU 架构实现方式有所不同，但基本原理类似</p><p>在java中是使用的是JUC包下的原子类来实现CAS操作的。这些类通过 <code>Unsafe</code> 类来调用底层的 <code>cmpxchg</code> 指令。该指令的操作数与 CAS 的 V、E、N 对应。该指令会 lock 总线，从而实现原子性。</p><p><code>Unsafe</code> 类是 Java 提供的一个后门，可以直接访问底层系统资源，包括内存操作。<code>AtomicInteger</code> 等原子类使用 <code>Unsafe</code> 类的 <code>compareAndSwapInt</code> 等方法来实现 CAS。</p><p>在unsafe类里面静态方法尝试去先获取表示 <code>value</code> 字段在 <code>AtomicInteger</code> 对象中的内存偏移地址。</p><p>然后调用<code>compareAndSwapInt</code>方法去执行调用底层的 <code>cmpxchg</code> 指令</p><p>但是CAS有一个典型的ABA问题</p><p>如果一个变量 V 的值被修改为 A，然后又被修改回 A，CAS 操作会认为 V 的值没有发生变化，从而成功更新。但实际上，V 的值可能已经经过了其他的改变，只是最终又变回了 A。</p><p>我们可以加入版本号或者是时间戳的一个遍历来实现，CAS的时候不仅是要去比较变量的值，还要去比较版本号或者时间戳</p><p>或者是使用<strong><code>AtomicStampedReference</code></strong>，<code>AtomicStampedReference</code> 类维护了一个变量值和一个 Stamp（类似于版本号）。CAS 操作需要同时比较变量值和 Stamp，确保变量没有被修改过。</p><p>CAS应用在ConcurrenthashMap这种类里面，JUC包下的原子类里面，AQS的实现，还有自旋。不适合高冲突的场景</p><h2 id="16-详细说明一下concurrenthashmap的变化"><a href="#16-详细说明一下concurrenthashmap的变化" class="headerlink" title="16.详细说明一下concurrenthashmap的变化"></a>16.详细说明一下concurrenthashmap的变化</h2><p>介绍一下，然后其他的线程安全的实现。</p><p>数据结构：由分段锁变为了数组链表+红黑树然后使用node数组来存储数据</p><p>线程安全的实现：</p><p>初始化的时候使用volatile+CAS来确保node数组的初始化</p><p>然后如果桶为空使用CAS，不为空使用synchronized锁住链表/红黑树的头节点。扩容的时候使用ForwardingNode标记正在迁移的桶</p><p>读操作的时候大部分情况无锁，使用volatile来保证可见性，node节点的next和val都是volatile来修饰的</p><p>效果：</p><p>锁粒度更细：只锁住具体的桶，而不是整个segment</p><p>读操作基本无锁</p><p>使用CAS减少锁竞争</p><p>然后扩容和红黑树变换</p><p>结合实际</p><h2 id="17-熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性"><a href="#17-熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性" class="headerlink" title="17.熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性"></a>17.熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性</h2><p><strong>RocketMQ如何保证消息的幂等性？在您的项目中是如何实现的？</strong></p><p><strong>延迟消息的实现原理是什么？它有什么限制？</strong></p><p><strong>如果消费者处理消息失败，RocketMQ是如何处理的？死信队列的作用是什么？</strong></p><p>1.消息幂等：因为RocketMQ只保证了消息至少发送一次，所以我们要在业务逻辑上实现</p><p>通过业务唯一ID进行检查，然后尽量使用msg的key的操作来保持幂等，在数据库方面，使用唯一索引和去重表</p><p>2.延迟消息：延迟队列定时执行任务，只支持固定的18个延迟级别，可以在broker.conf文件中修改</p><p>3.异常处理：消息是先放入redis设计一个短的过期时间，然后执行业务逻辑，执行成功延长过期时间，失败就过期。然后ACK消息</p><p>然后设置消息为RECONSUME_LATER，执行重试逻辑。到达重试次数，记录日志，发送到死心队列进行人工处理，死信消息默认保留3天</p><h2 id="18-详细解释ZSet在Redis中的底层实现，以及跳表的使用场景"><a href="#18-详细解释ZSet在Redis中的底层实现，以及跳表的使用场景" class="headerlink" title="18.详细解释ZSet在Redis中的底层实现，以及跳表的使用场景"></a>18.<strong>详细解释ZSet在Redis中的底层实现，以及跳表的使用场景</strong></h2><p>ZSet是Redis中一种常用的数据结构，用于存储有序的元素集合，它可以根据元素的分数（score）进行排序，通常用于排行榜等场景。</p><p>他的底层实现是两种数据结构</p><ol><li><p><strong>压缩列表（ziplist）：</strong> 在元素数量较少且元素成员（member）较短时使用。 压缩列表的特点是内存占用小，但插入、删除操作的效率较低，因为它需要进行连续的内存移动。</p><ul><li><strong>结构：</strong> 压缩列表是一种特殊的”连续内存块”构成的数据结构，类似于数组，但可以存储不同长度的数据。 它由多个entry组成，每个entry保存ZSet中的一个元素（member-score）。</li><li><strong>缺点：</strong>当压缩列表中某个entry的长度发生变化时，可能会导致后续entry的offset也需要更新，如果更新的entry数量较多，就会导致连锁更新，影响性能。</li></ul></li><li><p><strong>跳表（skiplist） + 字典（dict）：</strong> 在元素数量较多或元素成员较长时使用。 跳表可以提供较高的插入、删除、查找效率，但会占用更多的内存空间。 字典则用于存储member到score的映射，使得可以通过member快速查找score。</p><ul><li><strong>跳表的定义：</strong> 跳跃表（skiplist）是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳表是一种概率型数据结构，它通过随机算法来决定每个节点拥有多少个指针。 跳表是一种可以实现平均O(log N) 查找，插入，删除的有序数据结构。</li><li><strong>跳表的结构：</strong> 跳表由多层链表组成，每一层链表都包含所有的元素，但元素之间的连接方式不同。 最底层是包含所有元素的有序链表，而上层链表则以一定的概率包含下层链表的元素，从而构成一种类似于索引的结构。 节点会包含一个后退指针（backward pointer），指向位于前一个节点。 在跳表中，节点按照它们的分值大小进行排序。</li><li><strong>字典的定义：</strong> 字典，也称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。</li></ul></li></ol><p>满足这两个条件就会使用跳表</p><ol><li><strong>元素数量超过<code>zset_max_ziplist_entries</code>配置的值（默认128）：</strong> 这个配置限制了使用压缩列表存储的元素数量。</li><li><strong>集合中任一member的长度大于<code>zset_max_ziplist_value</code>配置的值（默认64）：</strong> 这个配置限制了使用压缩列表存储的元素的长度。</li></ol><h2 id="19-ziplist的底层以及改进"><a href="#19-ziplist的底层以及改进" class="headerlink" title="19.ziplist的底层以及改进"></a>19.ziplist的底层以及改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry1&gt;&lt;entry2&gt;...&lt;entryN&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure><p><code>zlbytes</code>：整个压缩列表占用字节数</p><p><code>zltail</code>：表尾节点距离起始地址的偏移量</p><p><code>zllen</code>：节点数量</p><p><code>entry</code>：各个节点</p><p><code>zlend</code>：标记压缩列表末端</p><p>每个entry</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen&gt;&lt;encoding&gt;&lt;entry-data&gt;</span><br></pre></td></tr></table></figure><p>当前一个节点长度从小于254字节变为大于等于254字节时,prevlen字段会从1字节扩展到5字节,可能引发后续节点的连锁扩展</p><p>然后就属于节点数量比较少的时候使用</p><p>在list中会被listpack代替，zset中被skiplist代替在listpack中，取消了prevlen字段，增加了len字段记录当前节点长度，可以从后往前遍历，避免连锁更新</p><h2 id="20-索引下推"><a href="#20-索引下推" class="headerlink" title="20.索引下推"></a>20.索引下推</h2><p>SELECT * FROM users WHERE age &gt; 20 AND name LIKE ‘张%’ AND city = ‘北京’;</p><p>存在复合索引：<code>(age, name, city)</code></p><p>没有索引下推的话，使用索引定位范围测试之后，每一个查询都需要进行回表。然后在MySQL Server层过滤name和city条件</p><p>有索引下推的话，使用索引定位完之后，在索引层直接判断，只有同时满足三个条件的记录才回表。大幅度减少回表查询的次数</p><p>因为他范围查询，会破坏后续字段的有序性。正常无法走索引，但是索引下推可以。</p><p>使用 <code>EXPLAIN</code> 命令查看执行计划，确认是否使用了索引下推优化。ICP，然后进行调试让其走索引下推</p><h2 id="21-JVM垃圾回收器"><a href="#21-JVM垃圾回收器" class="headerlink" title="21.JVM垃圾回收器"></a>21.JVM垃圾回收器</h2><p>分类：</p><p><strong>Serial / Parallel（吞吐优先）</strong></p><p><strong>CMS（低停顿）</strong></p><p><strong>G1（低停顿 + 区域化收集）</strong></p><p><strong>ZGC / Shenandoah（可预测、低延迟、支持大内存）</strong>搜集场景题</p><div class="table-container"><table><thead><tr><th>收集器</th><th>特点</th><th>回收策略</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>CMS</strong></td><td>并发回收，停顿低，已淘汰</td><td>标记-清除/存在内存碎片问题</td><td>老项目，注重响应延迟（已不推荐）</td></tr><tr><td><strong>G1</strong></td><td>分区回收，预测停顿</td><td>Region + 标记-整理</td><td>推荐，适合大内存、对吞吐和延迟平衡</td></tr><tr><td><strong>ZGC</strong></td><td>并发、低延迟、支持 TB 级堆</td><td>可并发标记/重定位</td><td>极低停顿、现代系统（JDK ≥ 17）</td></tr></tbody></table></div><h2 id="Redis-amp-数据库分布式锁"><a href="#Redis-amp-数据库分布式锁" class="headerlink" title="Redis&amp;数据库分布式锁"></a>Redis&amp;数据库分布式锁</h2><p>我们一般就是使用的redisson，Redisson 基于 RedLock；提到了锁的可重入机制；与 AQS 有类比意识；简略提到数据库锁的粒度更大，Redis 粒度更细并发性更好；</p><p>Redisson 提供的是一种 <strong>基于 Redis 的可重入分布式锁实现</strong>，其原理包括：</p><ul><li>使用 Redis 的 <code>SET key value NX PX timeout</code> 命令原子性加锁；</li><li><code>value</code> 为唯一线程标识（如 UUID + ThreadId）；</li><li>可重入：同一个线程再次加锁会对 <code>value</code> 维护一个计数器；</li><li>释放锁时会先比对线程标识，确保只有锁的拥有者可以释放；</li><li>使用 Lua 脚本释放锁，保证原子性；</li><li>提供“看门狗机制（watchdog）”，定时自动续期避免超时释放锁；</li></ul><p>数据库：</p><p>常见方式有两种：</p><ul><li>利用数据库的行级锁（如基于 <code>select ... for update</code>）；</li><li>使用数据库表记录作为“锁资源”，进行 <code>insert/update</code> 加锁；</li></ul><p>特点：</p><ul><li>实现简单，易于理解；</li><li>可靠性高（依赖事务和 ACID）；</li><li><strong>性能差</strong>，阻塞严重，不适合高并发；</li><li>不具备重入机制，不支持超时释放；</li><li>会增加数据库压力，影响主业务。</li></ul><h1 id="场景题目"><a href="#场景题目" class="headerlink" title="场景题目"></a>场景题目</h1><h2 id="1-MySQL自增ID用完了怎么办？"><a href="#1-MySQL自增ID用完了怎么办？" class="headerlink" title="1.MySQL自增ID用完了怎么办？"></a>1.MySQL自增ID用完了怎么办？</h2><p>那么我们先来分析一下，我们的自增ID最多可以多少呢？</p><p>如果是<em>INT类型</em>类型的话，普头的int，差不读能容纳约21的数据，UNSIGNED INT的话，能容纳43亿的数据</p><p>如果我们使用的BIGINT的话，-2^63^ ——2^63的数据，UNSIGNED BIGINT更多了，大约1844万亿的数据</p><p>一般的话，我们有一下几个方案：</p><p>1.INT升级到BIGINT，可以<em>使用pt-online-schema-change安全升级</em>，或者直接使用Mysql的ALTER TABLE your_table MODIFY COLUMN id BIGINT AUTO_INCREMENT;</p><p>这样的话，我们的数据量变大了，但是升级过程中会锁表，建议在维护窗口进行，而且需要同步修改相关的外键应用，而且java里面我们得用long字段而不是int字段了</p><p>2.分库分表，一般的我们可以根据ID的范围来分表，多少到多少为一个。这样分表比较简单。</p><p>3.使用UUID，是由32个十六进制数字组成的，因此一个UUID总共由128（32*4）个bit组成，也是说理论上有2的128次方个值可以使用。作为我们的自增主键，但是普通的UUID性能较差，可以使用OrderedUUID，这个有序的UUID，而且还可以将时间戳嵌入UUID的前缀，确保了有序性</p><p>4.使用雪花算法，利用机器ID和时间戳来生成64位长整型ID。最终生成的ID是会按时间递增的，但是也要考虑时钟回拨的问题，建议使用。</p><p>5.使用ID回收策略，回收被我们删除的ID，然后优先使用回收的ID，没有回收的话，才使用新的ID。一般用于实现假删除的表，但是我们需要去查，哪一些才是假删除的。</p><h2 id="2-如何把一个文件快速下发到100w个服务器"><a href="#2-如何把一个文件快速下发到100w个服务器" class="headerlink" title="2.如何把一个文件快速下发到100w个服务器"></a>2.如何把一个文件快速下发到100w个服务器</h2><p>对于100万台服务器的文件快速下发问题，我感觉可以使用P2P网络来解决</p><p>我们传统的方案是中心化下发，一个传输端发送给很多的接收端，很显然，在这个场景下不合适</p><p>我们可以设计一下</p><p><strong>构建多个独立的生成树同时传输</strong>，将100万节点构建成<strong>3-5个不相交的生成树</strong>，每个节点在不同树中担任不同角色（有时是父节点，有时是子节点），文件分片后通过不同树路径并行传输</p><p><strong>分片策略</strong>，将大文件切分为N个数据块，不同的数据块交给不同的生成树，每个节点收集所有分片之后重组文件</p><p>我们构建三层架构，<strong>种子层</strong>：5-10台高带宽服务器作为初始种子，<strong>中继层</strong>：按地理位置/网络拓扑划分的1000-5000台中继节点，<strong>叶子层</strong>：普通服务器节点</p><p>减少网络的跳数，降低延迟。然后理由网络拓扑特性，避免跨地域传输。</p><p>然后建立容错机制，每个节点连接2-3个父节点并行下载，任一节点故障时子节点自动重新寻找父节点，通过健康检查和动态调整保证传输连续性。<strong>优化策略</strong>包括最稀缺分片优先传输、自适应带宽分配、就近父节点选择等。</p><p>这样的话，我们理论上O(log N)轮传输完成，实际10-15轮即可完成。</p><p>实际上是树状结构升级为容错的多树并行网络，既保持P2P高效性又解决了单点故障和路径瓶颈问题。</p><h2 id="3-服务器上如果有很多time-wait如何解决，以及出现这个问题的场景有哪些"><a href="#3-服务器上如果有很多time-wait如何解决，以及出现这个问题的场景有哪些" class="headerlink" title="3.服务器上如果有很多time wait如何解决，以及出现这个问题的场景有哪些"></a>3.服务器上如果有很多time wait如何解决，以及出现这个问题的场景有哪些</h2><p>首先time_wait是tcp连接中，主动关闭一方的状态，等待2MSL后关闭。然后服务器出现说明是服务器主动断开的连接</p><p>比如：</p><ol><li><strong>并发Web服务</strong>：比如电商大促期间，Nginx反向代理服务器向后端应用服务器发起大量短连接请求，每次请求完成后主动关闭连接，导致Nginx服务器积累大量TIME_WAIT状态。</li><li><strong>微服务架构</strong>：服务A调用服务B的REST API，使用HTTP短连接方式，每次调用后都关闭连接。在高QPS场景下，比如订单服务调用库存服务，会产生大量TIME_WAIT。</li><li><strong>数据库连接池配置不当</strong>：应用服务器连接MySQL时，如果没有使用连接池或连接池配置过小，频繁创建和关闭数据库连接，会在应用服务器上产生大量TIME_WAIT。</li><li><strong>监控和健康检查</strong>：负载均衡器（如F5、ELB）对后端服务器进行健康检查，每次检查都是短连接，高频率的健康检查会导致后端服务器TIME_WAIT堆积。</li></ol><p>timewait过多会导致：</p><p><strong>端口耗尽</strong>：Linux默认可用端口范围是32768-65535，大约3万个端口。当TIME_WAIT状态的连接达到这个数量时，无法创建新的出站连接，出现”Cannot assign requested address”错误。</p><p><strong>内存占用</strong>：每个TIME_WAIT连接都会占用一定的内核内存，大量堆积会消耗系统资源。</p><p>我们可以使用分层解决的办法</p><p>应用层：因为可能是http短连接导致的，我们启用<strong>启用HTTP Keep-Alive</strong>，在nginx里面配置keeplive</p><p>然后可能是数据库的频繁连接导致的，我们使用连接池，HikariCP、Druid。http的连接池，HttpClient的PoolingHttpClientConnectionManager，redis的连接池，Jedis Pool</p><p>系统层：</p><ol><li><strong>开启TIME_WAIT重用</strong>，使用echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse 参数设置为1开启</li><li><strong>TIME_WAIT超时时间</strong>设计减少，尽快让其超时</li><li>扩大端口的可用范围，ip_local_port_range增大</li><li><strong>增加socket buffer</strong>，/etc/sysctl.conf里面设置’net.core.rmem_max = 16777216’</li></ol><h2 id="4-服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置"><a href="#4-服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置" class="headerlink" title="4.服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置"></a>4.服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置</h2><p>我们一般都是部署在linux服务器上，如果安装了监控软件的话，直接从监控软件上看</p><p>没有的话，我们使用top -c找出CPU占用最多的进程，然后top -H -PID 找出占用最多的线程</p><p>然后将线程ID转为16进制之后，jstack PID|grep -A 20 ID 查看其栈堆，对比找出我们具体是什么问题？</p><p>典型场景：</p><ol><li>死循环和无限递归</li><li>频繁的GC，我们可以jstat -gc PID 1000查看GC统计</li><li>正则表达式回溯，复杂的正则表达式出现了回溯</li><li>死锁，我们可以jstack PID|grep -A 5 -B “deadlock”直接显示死锁，或者是用<em>jconsole</em>等图形化工具来检测</li></ol><p>死锁的场景，<strong>数据库事务死锁</strong>，查询Mysql日志，<em>DEADLOCK</em>信息。然后在应用层的表现是，大量的线程阻塞在JDBC操作上</p><p>分布式死锁，主要是redis分布式锁，查找redis-cli keys “<em>lock</em>“，应用层表现是线程一直在等待锁</p><h2 id="5-有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现"><a href="#5-有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现" class="headerlink" title="5.有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现"></a>5.有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现</h2><p>我们可以不主动查询，等用户登录到时候，执行会员过期时间的检测，给用户发送邮件提醒。但是这样用户不登录，我们没有办法提醒了就。而且我们要进行全表扫描，效率较低，数据库压力大。但我们可以将他作为补充的手段。</p><p>我们可以使用ES等搜索引擎，把会员表里的会员id和会员到期时间存储到搜索引擎里面。然后根据范围查询，查询到即将过期的用户，对他们发送消息。但是这样系统复杂度高了，而且我们还是需要进行定时轮询</p><p>可以使用redis，key为用户的id，value为该id的过期时间。然后使用redis的过期提醒功能，监视key的过期事件，检查成功发送邮件提醒。但是这样只能精确到秒，不能提前提醒，而且内存压力较大。</p><p>使用MQ延迟队列，计算该用户的过期事件，然后存储到延迟消息队列里面，轮询执行，一道过期事件发送消息。这是我们最佳的方案。</p><p>流程：</p><p>→ 计算提醒时间点（到期前7天、3天、1天）</p><p>→ 投递延迟消息到RocketMQ</p><p>→ 消息到期自动消费</p><p>→ 验证用户状态后发送邮件</p><p>然后加上补偿机制，定时执行任务，只扫描近期（如15天内）即将到期用户，然后查看是否发送，补偿未发送的。重新发送</p><p>然后这个过程中需要保持消息幂等，不应该多次发送，查询用户当前会员状态，然后检查到期时间，检查是否发送过，发送之后记录日志。消费失败后自动重试三次，发送失败进入死信队列处理。然后多个途径进行提醒。</p><p>RocketMQ作为消息队列，mysql作为主库，redis缓存用户的状态。</p><h2 id="6-假设你们系统有一个下单接口，突然并发量暴增，比如从-1k-QPS-涨到-10w-QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。"><a href="#6-假设你们系统有一个下单接口，突然并发量暴增，比如从-1k-QPS-涨到-10w-QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。" class="headerlink" title="6.假设你们系统有一个下单接口，突然并发量暴增，比如从 1k QPS 涨到 10w QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。"></a>6.假设你们系统有一个下单接口，突然并发量暴增，比如从 1k QPS 涨到 10w QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。</h2><p>第一，限流。我们在网关层加了 Sentinel 做接口限流和熔断，防止系统被打垮。或者是我们使用AOP+bucket令牌桶进行限流</p><p>第二，缓存优化。我们使用了本地 + Redis 两级缓存，热点商品信息预加载，避免高并发直接打到数据库。然后防止缓存击穿，使用互斥锁</p><p>第三，异步削峰。下单写操作进入 MQ，由后台线程异步落库，极大缓解数据库压力。</p><p>第四，数据库层我们做了读写分离，写入走主库，查询走从库，提升吞吐。<br>最后就只能服务熔断了不行的话。</p><h2 id="7-你们系统中-Redis-如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？"><a href="#7-你们系统中-Redis-如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？" class="headerlink" title="7.你们系统中 Redis 如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？"></a>7.你们系统中 Redis 如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？</h2><p>失效的影响：</p><p><strong>请求直打数据库</strong>：热点接口并发高时，数据库容易被压垮。</p><p><strong>响应时间变长</strong>：Redis 是内存级别，数据库响应慢，用户体验下降。</p><p><strong>缓存穿透</strong>：用户请求不存在的数据，Redis 拿不到，数据库压力大。</p><p><strong>缓存不一致</strong>：应用读了 Redis 旧值，可能会造成业务逻辑问题。</p><p>应对策略：</p><p>1）<strong>缓存高可用部署</strong></p><ul><li>Redis 使用主从 + Sentinel 实现自动故障转移；</li><li>或使用 Redis Cluster，提供分布式高可用能力。</li></ul><p>2）<strong>加缓冲 + 限流</strong></p><ul><li>引入线程池 / 信号量等方式限流；</li><li>使用本地缓存（如 Caffeine）做短时间的过渡保护。</li></ul><p>3）<strong>缓存预热 / 冷数据淘汰</strong></p><ul><li>关键数据在启动时预热到 Redis；</li><li>利用定时任务刷热点数据；</li><li>对非热点数据设置较短 TTL。</li></ul><p>4）<strong>避免缓存穿透 / 击穿 / 雪崩</strong></p><ul><li><strong>穿透</strong>：对 null 值做缓存 / 用布隆过滤器拦截；</li><li><strong>击穿</strong>：加互斥锁 / 单飞请求重建缓存；</li><li><strong>雪崩</strong>：设置随机 TTL + 限流 + 降级处理。</li></ul><p>5）<strong>降级与熔断</strong></p><ul><li>如果 Redis 和数据库都失败，降级为静态页 / 弹窗提示；</li><li>监控超时率，自动熔断部分接口，防止服务雪崩。</li></ul><p>热点数据丢失后？AOP的日志自己来恢复</p><p>用户体验如何保证？</p><p>redis的高可用，主从，哨兵，集群</p><p>缓存一致性保证，延迟双删策略</p><h2 id="8-假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？"><a href="#8-假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？" class="headerlink" title="8.假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？"></a>8.假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？</h2><p>技术选型：</p><ol><li>concurrenthashmap+AtomicLong 精确统计，但是占内存较大，不适合大量用户</li><li>Redis HyperLogLog，内存占用小，适合大基数去重，有0.81%的误差，无法获取具体的元素</li></ol><h2 id="9-您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明："><a href="#9-您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：" class="headerlink" title="9.您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明："></a>9.您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：</h2><p>多级缓存的数据一致性如何保证？</p><p>延迟双删+异步补偿</p><p>BCP中间件：</p><p>CDC方案，使用Canal订阅binglog然后通过MQ发送，缓存更新，允许短暂不一致，保证最终一致</p><p><strong>无侵入性</strong>：不需要修改业务代码</p><p><strong>准确性</strong>：只有事务提交后才会写入binlog</p><p><strong>完整性</strong>：捕获所有数据变更</p><p><strong>实时性</strong>：近实时同步</p><h2 id="10-mysql的分页查询优化"><a href="#10-mysql的分页查询优化" class="headerlink" title="10.mysql的分页查询优化"></a>10.mysql的分页查询优化</h2><p>SELECT * FROM products ORDER BY id LIMIT 1000000, 20;</p><p>意识到了大偏移量会导致性能问题,</p><p>需要——</p><p>扫描并排序前1000020条记录</p><p>丢弃前1000000条记录</p><p>返回后20条记录,然后即使走了索引，也要”数”1000000条记录才能定位到起始位置</p><p>我们可以使用子查询来优化，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products p1 </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span></span><br><span class="line">) p2 <span class="keyword">ON</span> p1.id <span class="operator">=</span> p2.id;</span><br></pre></td></tr></table></figure><p>或者是使用游标，假设上页最后一个id是1000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-分库分表的查询如何进行"><a href="#11-分库分表的查询如何进行" class="headerlink" title="11.分库分表的查询如何进行"></a>11.分库分表的查询如何进行</h2><p>如何定位需要查询的分表？</p><p>如何聚合多个分表的结果？</p><p>如何处理分页查询？</p><p>按用户ID分表（user_id % 16）</p><p>可以使用异构索引表来查询，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product_order_index (</span><br><span class="line">    product_id BIGINT,</span><br><span class="line">    user_id BIGINT,</span><br><span class="line">    order_id BIGINT,</span><br><span class="line">    table_suffix INT,  -- 记录在哪个分表</span><br><span class="line">    INDEX(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者是引入ES搜索</p><p>然后我们如何聚合查询呢？使用归并排序</p><p>从每个分表获取足够的数据，每个分表需要取 page * size + size 条数据，然后返回冰柜排序</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/25/towork/woking2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring面试题hot2-源码分析</title>
      <link>https://blog.tokenlen.top/2025/07/19/java-stack/spring3/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/java-stack/spring3/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-IOC？&quot;&gt;&lt;a href=&quot;#1-什么是-IOC？&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-什么是-IOC？"><a href="#1-什么是-IOC？" class="headerlink" title="1.什么是 IOC？"></a>1.什么是 IOC？</h2><p>IOC就是控制反转，反转之前是啥，，，反转之后是啥。。。。实现核心就是反射，设计模式是工厂模式</p><p>然后IOC和核心就是DI，几种实现方式，循环依赖的解决方式。</p><p>@bean的生命周期，@PostConstruct @PreDestroy，bean的作用域，单例，原型，websocket,session,request,application</p><p>bean的单例不一定是线程安全的，这个跟我们的业务逻辑有关，如果bean没有一个可变的成员变量，那么他就是无状态的，也就是线程安全的</p><p>我们为了保证线程安全可以改变作作用域为prototype，或者使用ThreadLocal，或者是用锁</p><p>IOC容器：</p><p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 都是Spring的IoC容器，但后者是前者的超集，提供了更强大的功能。</p><p><code>ApplicationContext</code>继承了<code>BeanFactory</code>，所以它具备<code>BeanFactory</code>的所有能力，同时还提供了更多面向企业应用的功能。它的预加载机制能帮助你在应用启动时就发现配置错误，而不是等到运行时才报错。</p><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>BeanFactory</strong></th><th style="text-align:left"><strong>ApplicationContext (推荐使用)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心定位</strong></td><td style="text-align:left">Spring IoC容器的<strong>基础接口</strong>，是“底层基础设施”。</td><td style="text-align:left">IoC容器的<strong>高级接口</strong>，是<code>BeanFactory</code>的子接口。</td></tr><tr><td style="text-align:left"><strong>Bean加载</strong></td><td style="text-align:left"><strong>懒加载 (Lazy-loading)</strong>：只有当<code>getBean()</code>被调用时，才会去实例化Bean。</td><td style="text-align:left"><strong>预加载 (Eager-loading)</strong>：容器启动时，会一次性实例化所有<code>singleton</code>作用域的Bean。</td></tr><tr><td style="text-align:left"><strong>功能丰富度</strong></td><td style="text-align:left">功能较少，主要提供Bean的注册和获取。</td><td style="text-align:left"><strong>功能非常丰富</strong>，除了<code>BeanFactory</code>的所有功能外，还提供了：</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>国际化支持 (i18n)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>事件发布与传播机制 (ApplicationEvent)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>AOP集成</strong>（自动识别并配置<code>BeanPostProcessor</code>等）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>Web环境支持</strong>（如<code>WebApplicationContext</code>）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>资源访问</strong>（如<code>classpath:</code>、<code>file:</code>前缀的资源加载）</td></tr><tr><td style="text-align:left"><strong>使用场景</strong></td><td style="text-align:left">对内存消耗要求极高的场景（如移动设备）。在现代企业应用开发中<strong>几乎不直接使用</strong>。</td><td style="text-align:left"><strong>绝大多数Spring应用和所有Spring Boot应用</strong>的默认选择。</td></tr></tbody></table></div><h2 id="2-什么是spring-Aop"><a href="#2-什么是spring-Aop" class="headerlink" title="2.什么是spring Aop"></a>2.什么是spring Aop</h2><p>AOP是啥，作用</p><p>实现的原理，动态代理，jdk,cgilb</p><p>几个概念，切面，连接点，通知，切点，织入</p><p>AOP通过<strong>织入(Weaving)</strong>，将<strong>切面(Aspect)</strong>中的<strong>通知(Advice)</strong>，应用到由<strong>切点(Pointcut)</strong>匹配到的<strong>连接点(Join Point)</strong>所对应的<strong>目标对象(Target)</strong>上。</p><p>通知类型，用了代理这个设计模式</p><p>代理对象（Proxy）接管了对目标对象（Target）的访问。所有外部调用都必须先经过代理对象。</p><p>代理对象在将调用请求转发给真正的目标对象<strong>之前</strong>或<strong>之后</strong>，有机会执行额外的操作。这些额外的操作，就是我们之前说的<strong>通知（Advice）</strong>，也就是切面逻辑。</p><p><strong>pring AOP的核心是基于动态代理实现的。它利用代理模式，在运行时为我们的目标Bean动态地创建一个代理对象。这个代理对象拦截了对原始Bean方法的所有调用，并在调用前后织入了我们定义的切面逻辑（比如日志、事务等），从而在不修改源代码的情况下，实现了功能的增强。</strong></p><p>这个只能作用在public方法上，所以非public的方法会失效</p><p>通知注解，@Around<strong>包裹</strong>在目标方法的整个执行过程周围。它是功能最强大、最灵活的通知。</p><p>环绕通知的第一个参数必须是<code>ProceedingJoinPoint</code>，它有一个<code>proceed()</code>方法。</p><ul><li>你可以在<strong>调用<code>proceed()</code>方法之前</strong>执行逻辑（等同于<code>@Before</code>）。</li><li>你可以<strong>决定是否调用<code>proceed()</code>方法</strong>，从而决定是否执行目标方法。</li><li>你可以在<strong>调用<code>proceed()</code>方法之后</strong>执行逻辑（等同于<code>@AfterReturning</code>）。</li><li>你可以<strong>修改目标方法的参数或返回值</strong>。</li><li>你可以<strong>捕获并处理目标方法抛出的异常</strong>（等同于<code>@AfterThrowing</code>）。</li></ul><h2 id="3-spring的常用注解"><a href="#3-spring的常用注解" class="headerlink" title="3.spring的常用注解"></a>3.spring的常用注解</h2><p>组件：</p><p><strong><code>@Component</code></strong>，标记为一个组件，生成一个bean</p><p><strong><code>@Service</code></strong>，业务层的组件注解</p><p><strong><code>@Repository</code></strong>，DTO层的组件注解，但是能让Spring<strong>自动转换特定于平台的数据库异常</strong>为统一的<code>DataAccessException</code>。</p><p><strong><code>@Controller</code></strong>，controller层的组件注解</p><p><strong><code>@Scope</code></strong>，定义Bean的作用域。最常用的两个是：</p><ul><li><code>singleton</code>：（默认值）在整个应用中只有一个实例。</li><li><code>prototype</code>：每次请求（获取）时都会创建一个新的实例。request，websocket,context,session</li></ul><p><strong><code>@PostConstruct</code></strong> 和 <strong><code>@PreDestroy</code></strong>,初始化合销毁</p><p>DI</p><p><strong><code>@Autowired</code></strong>，按<strong>类型（byType）</strong>自动注入依赖。如果找到多个相同类型的Bean，会尝试按<strong>名称（byName）</strong>匹配。如果还找不到就会报错。</p><p><strong><code>@Qualifier(&quot;beanName&quot;)</code></strong>，指定bean的名称注入，多个bean相同的</p><p><strong><code>@Resource(name = &quot;beanName&quot;)</code></strong>，默认按名称注入，找不到就按类型注入</p><p>web</p><p><strong><code>@RestController</code></strong>，专门写API的</p><p><strong><code>@RequestMapping(&quot;/path&quot;)</code></strong>，指定URL</p><p><strong><code>@RequestParam</code></strong>，从请求的URL的？中获取参数</p><p><strong><code>@PathVariable</code></strong>，从URL路径里面获取参数</p><p><strong><code>@RequestBody</code></strong>，把发过来的JSON请求体变成一个Java对象</p><p>配置</p><p><strong><code>@SpringBootApplication</code></strong>=</p><ul><li><code>@SpringBootConfiguration</code>: (就是<code>@Configuration</code>)</li><li><code>@EnableAutoConfiguration</code>: 启用Spring Boot的自动配置机制。内部使用@Import注解是自动装配的核心，每发现一个自动配置类，就Selector使用条件判断来确实是不是满足导入条件，自动创建所选bean</li><li>@AutoConfigurationPackage，将项目src中main包下的所有组件注册到容器中</li><li><code>@ComponentScan</code>: 自动扫描启动类所在包及其子包下的所有组件。</li></ul><p><strong><code>@Value</code></strong>，配置文件读取值</p><p><strong><code>@Bean</code></strong>，作用方法上</p><p><strong><code>@Configuration</code></strong>，表明配置类</p><h2 id="4-Bean"><a href="#4-Bean" class="headerlink" title="4.@Bean"></a>4.@Bean</h2><p>创建-&gt;实例化-&gt;填充属性-&gt;初始化-&gt;可用和销毁</p><p>实例化：当客户端请求一个Bean，或者在容器启动时，Spring容器会查找Bean的定义。利用java的反射机制或者工厂方法创建一个原始的bean</p><p>填充属性，IOC容器识别bean的依赖关系，比如@Autowired@Resource。从容器中查找对应的bean，通过反射将依赖注入到bean的属性中</p><p>初始化，最重要的点，扩展点最多的。</p><p><strong>执行Aware接口的方法</strong>，实现了特定的<code>Aware</code>接口，比如BeanNameAware<code>,</code>BeanFactoryAware<code>,</code>ApplicationContextAware</p><p><strong>执行<code>BeanPostProcessor</code>的前置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法。</p><p><strong>执行<code>@PostConstruct</code>注解的方法</strong>，调用使用了@postConstruct的方法</p><p><strong>执行<code>InitializingBean</code>接口的方法</strong>，实现了<code>InitializingBean</code>接口，Spring会调用它的<code>afterPropertiesSet()</code>方法。</p><p><strong>执行自定义的<code>init-method</code></strong>，如果在XML配置或<code>@Bean</code>注解中指定了<code>init-method</code>，Spring会调用这个自定义的初始化方法。</p><p><strong>执行<code>BeanPostProcessor</code>的后置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法。</p><p>Spring的<strong>AOP（动态代理）</strong>就是在这个阶段通过包装原始Bean实例，并返回一个代理对象来实现的。我们平时拿到的Bean，很多时候其实是这一步处理后的代理对象。</p><p>可用和销毁，当Spring容器关闭时（或者对于非<code>singleton</code>作用域的Bean，当其作用域结束时）。按照顺序执行</p><ul><li><strong>执行<code>@PreDestroy</code>注解的方法</strong>：如果Bean的方法上使用了<code>@PreDestroy</code>注解，Spring会调用这个方法。这也是<strong>推荐</strong>的销毁回调方式。</li><li><strong>执行<code>DisposableBean</code>接口的方法</strong>：如果Bean实现了<code>DisposableBean</code>接口，Spring会调用它的<code>destroy()</code>方法。</li><li><strong>执行自定义的<code>destroy-method</code></strong>：如果在XML配置或<code>@Bean</code>注解中指定了<code>destroy-method</code>，Spring会调用这个方法。</li></ul><p>扩展点</p><p><strong><code>BeanFactoryPostProcessor</code></strong></p><ul><li><strong>作用时机</strong>：在Spring容器<strong>加载了所有Bean的定义信息（BeanDefinition），但尚未创建任何Bean实例之前</strong>。</li><li><strong>能力</strong>：允许你<strong>读取并修改Bean的定义元数据</strong>。例如，你可以动态地修改某个Bean的属性值，甚至更改它的作用域。</li><li><p><strong>通俗理解</strong>：给你一个机会在“蓝图”阶段修改设计图纸，而不是等房子建好了再去敲墙。</p><p>比如是在<code>application.properties</code>中使用占位符 <code>$&#123;...&#125;</code> 的功能(<code>PropertySourcesPlaceholderConfigurer</code>)。MyBatis的<code>MapperScannerConfigurer</code>，它会扫描接口并将其注册为Bean定义。</p></li></ul><p><strong><code>BeanPostProcessor</code></strong></p><ul><li><p><strong>作用时机</strong>：在Bean<strong>实例化和属性填充之后，初始化方法（<code>init-method</code>, <code>@PostConstruct</code>）的前后</strong>。</p></li><li><p>能力</p><p>：包含两个方法：</p><ul><li><code>postProcessBeforeInitialization</code>: 在初始化之前干预。</li><li><code>postProcessAfterInitialization</code>: 在初始化之后干预。<strong>Spring的AOP就是通过它实现的</strong>，在此处返回Bean的代理对象。</li></ul></li><li><p><strong>通俗理解</strong>：在房子建好（实例化）并装修完（填充属性）之后，在主人入住（可用）前后，给你机会对房子进行“精装修”或“改造”（如加装监控系统-AOP）。</p></li></ul><p><strong><code>Aware</code>系列接口</strong>:</p><ul><li><strong>作用时机</strong>：在Bean的初始化阶段，<code>BeanPostProcessor</code>之前。</li><li><strong>能力</strong>：让Bean能“感知”并获取到Spring容器自身的资源，如<code>ApplicationContext</code>、<code>BeanFactory</code>、<code>BeanName</code>等。</li><li><strong>通俗理解</strong>：让Bean知道自己“身在何处”以及“叫什么名字”。</li></ul><p><strong><code>InitializingBean</code>和<code>DisposableBean</code></strong>:</p><ul><li><strong>作用时机</strong>：初始化和销毁阶段的特定回调。</li><li><strong>能力</strong>：提供<code>afterPropertiesSet()</code>和<code>destroy()</code>方法，用于自定义初始化和销毁逻辑。</li><li><strong>通俗理解</strong>：Bean的“出生仪式”和“临终遗言”的固定写法。（现在更推荐使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，因为无代码侵入）</li></ul><h2 id="5-spring事务"><a href="#5-spring事务" class="headerlink" title="5.spring事务"></a>5.spring事务</h2><p>事务分为声明型事务和编程型事务</p><p>声明型事务，通过注解<strong><code>@Transactional</code></strong>来声明，他的底层是基于AOP实现的</p><ul><li><ol><li>Spring容器在启动时，会为标记了<code>@Transactional</code>的Bean创建一个<strong>代理对象 (Proxy)</strong>。</li><li>当外部调用这个代理对象的方法时，代理逻辑会先被触发。</li><li><strong>事务开始</strong>：代理逻辑会负责开启事务（例如，禁用数据库连接的自动提交 <code>connection.setAutoCommit(false)</code>）。</li><li><strong>执行业务</strong>：然后，代理对象再调用你编写的原始业务方法。</li><li>事务提交/回滚：<ul><li>如果业务方法正常执行完毕，代理逻辑会<strong>提交</strong>事务。</li><li>如果业务方法抛出<strong>运行时异常 (RuntimeException)</strong> 或 <strong>Error</strong>，代理逻辑会<strong>回滚</strong>事务。</li></ul></li></ol></li><li><strong>优点</strong>：对业务代码<strong>无侵入</strong>，将事务管理代码与业务逻辑彻底解耦，使得代码非常清晰。</li></ul><p>编程型事务，在业务代码中，通过手动调用<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>的API来精确地控制事务的边界。</p><p>然后调用方法，自己进行手动的提交和手动的回滚</p><p>提供了极高的灵活性，可以实现非常精细的事务控制，比如在一个方法内实现多次提交或回滚。但是高耦合</p><p>事务的隔离级别跟mysql的事务的隔离级别相同。多了一个<strong><code>DEFAULT</code></strong>：这是<code>@Transactional</code>注解的<strong>默认值</strong>。它表示使用数据库本身设置的默认隔离级别。一般数据库的事务的隔离级别就是rr</p><p>或者rc?</p><p>但是事务会失效的，事务失效的场景如下：</p><p>AOP代理有关的</p><ol><li><strong>方法不是<code>public</code>的</strong><ul><li><strong>原因</strong>：Spring AOP的代理机制在为类创建代理时，只会代理其<code>public</code>方法。如果你将<code>@Transactional</code>注解用在<code>protected</code>、<code>private</code>或<code>package-private</code>方法上，事务不会生效，也不会有任何报错。</li><li><strong>一句话总结</strong>：<strong>代理对象无法覆盖非公有方法</strong>。</li></ul></li><li><strong>方法被<code>final</code>修饰</strong><ul><li><strong>原因</strong>：被<code>final</code>修饰的方法无法被子类重写（Override）。Spring的CGLIB动态代理是通过创建目标类的子类来实现的，因此无法代理<code>final</code>方法。</li><li><strong>一句话总结</strong>：<strong>final方法无法被代理</strong>。</li></ul></li><li><strong>同一个类中的方法调用（<code>this</code>调用）</strong><ul><li><strong>原因</strong>：这是最常见也最隐蔽的失效场景。当你在一个Bean的<code>methodA</code>中调用同一个类中的<code>methodB</code>（<code>methodB</code>有<code>@Transactional</code>注解）时，这个调用是通过<code>this</code>指针直接发生的，<strong>绕过了代理对象</strong>。事务增强逻辑是存在于代理对象中的，所以事务会失效。</li></ul></li></ol><p>跟运行时异常有关的</p><ol><li><strong>异常被<code>try-catch</code>捕获了</strong><ul><li><strong>原因</strong>：Spring声明式事务默认只在遇到<strong>RuntimeException或Error</strong>时才会回滚。如果你在事务方法内部用<code>try-catch</code>捕获了异常，并且没有在<code>catch</code>块中重新抛出，那么Spring的事务代理就无法感知到异常的发生，从而会正常提交事务。</li><li><strong>一句话总结</strong>：<strong>异常没有传播到代理层，代理以为一切正常</strong>。</li></ul></li><li><strong>指定了不回滚的异常类型</strong><ul><li><strong>原因</strong>：在<code>@Transactional(noRollbackFor = ...)</code>中指定了某个异常类，那么当这个异常发生时，事务将不会回滚。</li><li><strong>示例</strong>：<code>@Transactional(noRollbackFor = NullPointerException.class)</code></li></ul></li></ol><p>事务有关的</p><ol><li><strong>数据库引擎不支持事务</strong><ul><li><strong>原因</strong>：例如，MySQL的MyISAM引擎就不支持事务。如果表使用了不支持事务的引擎，所有事务相关的操作都会被静默忽略。</li><li><strong>一句话总结</strong>：<strong>底层基础不支持，上层框架无能为力</strong>。</li></ul></li><li>事务的传播类型设置的不对，比如不支持事务never</li></ol><p>事务的传播机制：</p><ol><li><strong><code>REQUIRED</code> (需要)</strong><ul><li><strong>描述</strong>：这是<strong>默认</strong>的传播特性。如果当前存在一个事务，那么新方法就<strong>加入</strong>到这个事务中。如果当前没有事务，就<strong>新建</strong>一个事务。</li><li><strong>场景</strong>：绝大多数情况下的选择。</li></ul></li><li><strong><code>SUPPORTS</code> (支持)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就加入。如果当前没有事务，就以<strong>非事务</strong>的方式执行。</li><li><strong>场景</strong>：用于那些“可有可无”的事务方法，比如一些只读查询操作。</li></ul></li><li><strong><code>MANDATORY</code> (强制)</strong><ul><li><strong>描述</strong>：<strong>强制</strong>要求当前必须存在一个事务。如果当前没有事务，就会抛出异常。它不会自己创建事务。</li><li><strong>场景</strong>：用于那些必须在事务环境下执行的核心操作，起到一种校验作用。</li></ul></li><li><strong><code>REQUIRES_NEW</code> (需要新的)</strong><ul><li><strong>描述</strong>：<strong>总是创建一个全新的、独立的事务</strong>。如果当前已经存在一个事务，会把当前事务<strong>挂起</strong>，然后执行新事务。新事务执行完毕后，再恢复被挂起的事务。</li><li><strong>场景</strong>：希望某些操作的事务结果独立于外部事务，不受其影响。比如，在一个大的下单流程中，记录操作日志，无论下单成功与否，日志都必须成功入库。</li></ul></li><li><strong><code>NOT_SUPPORTED</code> (不支持)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，会把当前事务<strong>挂起</strong>。</li><li><strong>场景</strong>：用于那些明确不希望在事务中运行的方法。</li></ul></li><li><strong><code>NEVER</code> (从不)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，就会抛出异常。</li><li><strong>场景</strong>：用于和<code>MANDATORY</code>相对的校验场景。</li></ul></li><li><strong><code>NESTED</code> (嵌套)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就在这个事务中创建一个<strong>嵌套事务（保存点 Savepoint）</strong>。嵌套事务独立于外部事务进行提交或回滚。如果外部事务回滚，嵌套事务也会回滚。但嵌套事务的回滚不影响外部事务。如果当前没有事务，行为等同于<code>REQUIRED</code>。</li><li><strong>注意</strong>：这是一个部分数据库才支持的特性（如Oracle），需要底层JDBC驱动和数据库的支持。</li></ul></li></ol><h2 id="6-spring-MVC"><a href="#6-spring-MVC" class="headerlink" title="6.spring MVC"></a>6.spring MVC</h2><p>MVC 设计模式：</p><p>model-&gt;view-&gt;controller</p><p>作用：</p><ol><li><strong>实现MVC模式的解耦</strong>：它提供了一套清晰的架构，将处理请求的控制器、业务逻辑的模型和展示用的视图分离开来，极大地提高了代码的可维护性、可扩展性和可测试性。</li><li><strong>简化Web开发</strong>：它基于Servlet API构建，但极大地简化了底层的Servlet、Request、Response等对象的直接操作。开发者可以用简单的注解（如<code>@GetMapping</code>, <code>@PostMapping</code>）来处理复杂的HTTP请求。</li><li><strong>与Spring生态无缝集成</strong>：它可以非常方便地使用Spring核心的IoC和AOP功能，轻松整合Service层、DAO层以及事务管理等。</li><li><strong>提供强大的功能</strong>：内置了强大的参数绑定、数据校验、RESTful风格支持、拦截器、国际化、文件上传等一系列Web开发所需的核心功能。</li></ol><p>springmvc核心组件&amp;&amp;执行过程c</p><p>常用注解，那几个mappring 参数绑定的那几个</p><p>深入知识：</p><p>1.<strong>统一异常处理 (<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>)</strong></p><ul><li><strong>作用</strong>：通过创建一个带有<code>@ControllerAdvice</code>注解的类，可以在其中定义多个<code>@ExceptionHandler</code>方法，来集中处理整个应用中由Controller抛出的特定异常。这避免了在每个Controller中都写<code>try-catch</code>，实现了优雅的全局异常处理。</li><li><strong>示例</strong>：捕获所有<code>NullPointerException</code>，并返回一个自定义的错误JSON。</li></ul><p>2.<strong>拦截器 (<code>HandlerInterceptor</code>)</strong></p><ul><li><p><strong>作用</strong>：提供了在请求处理的生命周期中（<strong>Controller方法执行前后</strong>）织入自定义逻辑的能力。它比Servlet Filter更精细，因为它能访问到即将执行的<code>Handler</code>信息。</p></li><li><p>三大方法</p><p>：</p><ul><li><code>preHandle</code>: 在Controller方法执行<strong>之前</strong>调用。可以进行权限验证、日志记录等。返回<code>false</code>则中断后续流程。</li><li><code>postHandle</code>: 在Controller方法执行<strong>之后</strong>，视图渲染<strong>之前</strong>调用。可以修改<code>ModelAndView</code>中的数据。</li><li><code>afterCompletion</code>: 在整个请求处理完成（包括视图渲染）<strong>之后</strong>调用。主要用于资源清理。</li></ul></li><li><p><strong>与Filter的区别</strong>：Filter是Servlet规范的一部分，作用范围更广，能处理所有HTTP请求；Interceptor是Spring MVC的一部分，只能处理经过<code>DispatcherServlet</code>的请求，但能获取到Spring MVC的上下文信息。</p></li></ul><p>3.<strong>数据绑定与类型转换 (<code>DataBinder</code>, <code>Converter</code>)</strong></p><p>Spring MVC能自动将请求参数（都是字符串）转换为Controller方法参数所需的类型（如<code>Integer</code>, <code>Date</code>）。这个过程就是数据绑定。我们可以通过实现<code>Converter</code>接口，并将其注册到Spring中，来定义自定义的类型转换逻辑（例如，将”2023-01-01”字符串转换为<code>LocalDate</code>对象）。</p><p>4.<strong>跨域请求处理 (<code>@CrossOrigin</code>)</strong></p><ul><li><strong>作用</strong>：简单方便地解决Web开发中常见的跨域资源共享（CORS）问题。可以直接在<code>Controller</code>类或方法上使用<code>@CrossOrigin</code>注解，来允许来自特定域的跨域请求。</li></ul><h2 id="7-springboot"><a href="#7-springboot" class="headerlink" title="7.springboot"></a>7.springboot</h2><p>springboot是啥，四大特性（自动配置，starter，内嵌web服务器，无需xml配置）</p><p>常用的starter，Starter本质上是一个<strong>Maven依赖描述符 (pom)</strong>。它的作用是将实现某一特定功能所需的所有依赖项打包在一起，并触发与该功能相关的自动配置。</p><p>启动springboot，</p><p>spring-boot-devtools热部署工作原理：</p><p>当<code>devtools</code>检测到classpath下的文件发生变化时，它会触发应用<strong>快速重启</strong>（不是完全重启，速度很快）。它通过维护两个类加载器（一个加载不变的第三方库，一个加载你自己的代码）来实现这一点，只重新加载你自己写的代码，从而大大加快了速度。</p><p> <strong>Spring Boot JAR 与 普通JAR的区别</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>普通JAR (Thin JAR)</strong></th><th style="text-align:left"><strong>Spring Boot JAR (Fat JAR / Executable JAR)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>内容</strong></td><td style="text-align:left">只包含你项目自己编译的<code>.class</code>文件和资源文件。</td><td style="text-align:left"><strong>包含所有内容</strong>：你的代码、资源文件，以及项目所需的所有第三方依赖库的JAR包。</td></tr><tr><td style="text-align:left"><strong>大小</strong></td><td style="text-align:left">非常小。</td><td style="text-align:left">非常大，因此也叫“胖JAR”。</td></tr><tr><td style="text-align:left"><strong>运行方式</strong></td><td style="text-align:left">不能直接<code>java -jar</code>运行（除非配置了<code>Main-Class</code>且无外部依赖）。通常是作为其他项目的库被引用。</td><td style="text-align:left">可以通过<code>java -jar</code>命令<strong>直接运行</strong>，因为它内置了所有依赖和启动逻辑。</td></tr><tr><td style="text-align:left"><strong>结构</strong></td><td style="text-align:left">标准JAR结构。</td><td style="text-align:left">特殊的结构。解压后会看到一个<code>BOOT-INF</code>目录，里面包含了<code>classes</code>（你的代码）和<code>lib</code>（所有依赖的JAR包）。还有一个<code>org/springframework/boot/loader</code>目录，这是Spring Boot的启动加载器。</td></tr></tbody></table></div><p>自动装配原理，Spring Boot的自动装配核心在于<code>@SpringBootApplication</code>注解，而这个注解又是一个组合注解，其中最关键的是<code>@EnableAutoConfiguration</code>。</p><ol><li><strong><code>@EnableAutoConfiguration</code></strong>：这个注解是自动配置的开关。</li><li><strong><code>@Import(AutoConfigurationImportSelector.class)</code></strong>：<code>@EnableAutoConfiguration</code>内部通过<code>@Import</code>注解导入了<code>AutoConfigurationImportSelector</code>这个类。</li><li><strong><code>AutoConfigurationImportSelector</code></strong>：这个类的核心作用是去<strong>加载和筛选</strong>需要被激活的自动配置类。</li><li><strong>扫描<code>META-INF/spring.factories</code></strong>：它会扫描项目中所有JAR包的<code>META-INF/spring.factories</code>文件。这个文件中定义了所有可能的自动配置类（key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>）。</li><li><strong>按需加载</strong>：<code>Selector</code>会根据<strong>条件注解 (<code>@ConditionalOnClass</code>, <code>@ConditionalOnBean</code>等)</strong> 来判断这些自动配置类是否满足生效条件（比如<code>DataSourceAutoConfiguration</code>只有在classpath下存在<code>DataSource.class</code>时才会生效）。</li><li><strong>注入Bean</strong>：最终，满足条件的自动配置类被加载到Spring容器中，它们内部定义的各种Bean（如<code>DataSource</code>, <code>RestTemplate</code>）就被创建并注入了。</li></ol><p>@Import注解：</p><p><code>@Import</code>是Spring框架提供的基础注解，它比<code>@Bean</code>更强大，通常用于<strong>批量导入Bean</strong>或者<strong>导入配置类</strong>。它有三种主要使用方式，而Spring Boot的自动配置正是利用了第三种：</p><ol><li><strong>导入普通的类</strong>：<code>@Import(MyService.class)</code>，Spring会将<code>MyService</code>注册为一个Bean。</li><li><strong>导入配置类</strong>：<code>@Import(MyConfig.class)</code>，Spring会加载<code>MyConfig</code>这个配置类以及它内部定义的所有<code>@Bean</code>。</li><li><strong>导入<code>ImportSelector</code>实现类</strong>：<strong>这是最关键的用法</strong>。<code>@Import(MyImportSelector.class)</code>，Spring会实例化<code>MyImportSelector</code>，并调用它的<code>selectImports()</code>方法，该方法返回一个字符串数组，数组里的每一个类名都会被Spring注册为Bean。<strong>Spring Boot的自动配置就是通过这种方式，动态地、可选择地加载了大量的配置类。</strong></li></ol><h1 id="spring源码分析"><a href="#spring源码分析" class="headerlink" title="spring源码分析"></a>spring源码分析</h1><h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><p>凡是可以存放数据的具体数据结构实现，都可以称之为容器，在 Spring Bean 容器的场景下，我们需要一种可以用于存放和名称索引式的数据结构，所以选择 HashMap 是最合适不过的。</p><p>HashMap 是一种基于扰动函数、负载因子、红黑树转换等技术内容，形成的拉链寻址的数据结构，它能让数据更加散列的分布在哈希桶以及碰撞时形成的链表和红黑树上。它的数据结构会尽可能最大限度的让整个数据读取的复杂度在 O(1) ~ O(Logn) ~O(n)之间，当然在极端情况下也会有 O(n) 链表查找数据较多的情况。不过我们经过10万数据的扰动函数再寻址验证测试，数据会均匀的散列在各个哈希桶索引上，所以 HashMap 非常适合用在 Spring Bean 的容器实现上。但是我们实际上应用的是concurrenthashmap，因为他是线程安全的。我们的bean不可能只是单线程进行操作的。他是一个弱一致性迭代器，避免了并发的修改异常。</p><p>一个简单的 Spring Bean 容器实现，还需 Bean 的定义、注册、获取三个基本步骤</p><ul><li>定义：BeanDefinition，可能这是你在查阅 Spring 源码时经常看到的一个类，例如它会包括 singleton、prototype、BeanClassName 等。</li><li>注册：这个过程就相当于我们把数据存放到 HashMap 中，只不过现在 HashMap 。在我们注册阶段Map里面存储的是beanDefintion</li><li>获取：最后就是获取对象，Bean 的名字就是key，Spring 容器初始化好 Bean 以后，就可以直接获取了。</li><li>实例化完成之后里面存储的才是bean实例</li></ul><p>我们解决循环依赖的三级缓存就是这么设计的，key是bean的名字，value是bean的实例。</p><hr><p>Spring Bean 容器的整个实现内容非常简单，也仅仅是包括了一个简单的 BeanFactory 和 BeanDefinition</p><ol><li><p>BeanDefinition，用于定义 Bean 实例化信息，现在的实现是以一个 Object 存放对象，可以继续添加属性，比如:SCOPE_SINGLETON、SCOPE_PROTOTYPE、ROLE_APPLICATION、ROLE_SUPPORT、ROLE_INFRASTRUCTURE 以及 Bean Class 信息。</p></li><li><p>BeanFactory，代表了 Bean 对象的工厂，可以存放 Bean 定义到 Map 中以及获取。</p></li></ol><p>在 Bean 工厂的实现中，包括了 Bean 的注册，这里注册的是 Bean 的定义信息。同时在这个类中还包括了获取 Bean 的操作。</p><p>然后我们使用的时候，是先初始化beanfactory容器，然后通过beanDefinition来创建一个bean。</p><p>然后去通过beanfactory去获取我们注册的bean，然后去使用bean里面封装的方法。这个时候才会实例化</p><p>然后实际我们使用的spring容器比如说是<strong>DefaultListableBeanFactory</strong>，他是继承了AbstractAutowireCapableBeanFactory，然后实现了ConfigurableListableBeanFactory, BeanDefinitionRegistry </p><p>里面包括存储BeanDefinition的容器，存储bean定义名词的列表，一级缓存，已经完成初始化的单例bean,二级缓存，早期bean的引用。三级缓存，单例工厂</p><p>我们注册bean的时候bean并没有实例化，直到获取bean的时候才会实例化，这就是懒加载</p><p>获取的时候先从一级缓存获取，缓存没有才创建bean</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>职责分清，一个接口只关注一个核心的职责，通过组合来实现多种能力。这样的话，方便我们的后续扩展和维护</p><p>比如我们的BeanFactory只负责获取bean,SingletonBeanRegistry只负责单例bean的管理，BeanDefinitionRegistry 只负责定义注册</p><p>模板方法模式，所有子类都遵循相同的Bean获取流程，子类只需实现特定的抽象方法，通用逻辑在父类中实现</p><p>比如一个抽象的基类AbstractBeanFactory定义了获取bean的标准流程，先去看一级缓存中有没有，没有的话，获取一个beandefinition，然后创建实例化这个bean</p><p>然后剩下的方法只是定义完，具体的逻辑留给子类实现</p><p>分层架构，每一层都该干属于自己的事情，比如接口层定义契约和规范，然后抽象类层，实现通用的逻辑和模板方法，实现类层，实现具体的业务逻辑实现</p><p>然后在我们的项目中，比如说实现一个支付的实现的话，我们可以先创建一个支付接口，定义一个执行方法。</p><p>然后创建一个所有的支付类共同的抽象类，实现支付的基本逻辑，先检验参数，然后执行，获取执行结果，返回执行结果</p><p>然后子类具体的去实现这个执行的逻辑，比如支付宝的具体的实现逻辑</p><p>比如说我们在项目中可以根据我们的类型来选择我们要实例化bean的模式，一般就是普通的jdk代理或者是cglib代理，可以在bean属性中class里面设定，然后我们根据属性的设定来选择我们具体是选择哪一种策略。</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>jdk实例化，首先通过 beanDefinition 获取 Class 信息，这个 Class 信息是在 Bean 定义的时候传递进去的。然后看我们获取的class信息是不是空的，空的就是无构造函数实例化，不是空的就是有构造函数实例化。这里我们重点关注有构造函数的实例化，实例化方式为 <code>clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</code>，把入参信息传递给 newInstance 进行实例化。比较简单，适用于简单的pojo对象。</p><p>cglib实例化,先是构建enhancer，设置目标为父类。设置回溯，使用noop就是说明不需要额外的处理。可以设置<code>MethodInterceptor</code>等其他回调来实现AOP功能</p><p>如果class信息为空，就enhacers默认的创建，不为空的话，就创建我们指定的构造器的类型。</p><p>支持动态代理，适用于需要进行增强的对象。运行的时候动态的生成新的class文件，比如需要事务代理，需要缓存代理的</p><div class="table-container"><table><thead><tr><th>特性</th><th>JDK反射</th><th>Cglib动态代理</th></tr></thead><tbody><tr><td><strong>实现原理</strong></td><td>Java原生反射API</td><td>字节码动态生成</td></tr><tr><td><strong>性能表现</strong></td><td>反射调用开销较小</td><td>首次创建开销大，后续调用快</td></tr><tr><td><strong>功能扩展</strong></td><td>仅支持实例化</td><td>支持方法拦截、AOP增强</td></tr><tr><td><strong>依赖要求</strong></td><td>无额外依赖</td><td>需要cglib和asm库</td></tr><tr><td><strong>代理限制</strong></td><td>无法代理final类/方法</td><td>无法代理final类/方法</td></tr></tbody></table></div><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>属性填充的时机，实在对象创建后立刻进行。<strong>. PropertyValue - 属性值载体**</strong>，PropertyValues - 属性集合管理<strong> </strong>BeanReference - 对象依赖标识**</p><ul><li><strong>延迟解析</strong>：不是直接存储Bean对象，而是存储Bean名称</li><li><strong>递归创建</strong>：在属性填充时才真正创建依赖的Bean</li><li><strong>循环依赖预留</strong>：为后续处理循环依赖留下接口</li></ul><p>属性填充方法，内部使用递归，检测到<code>BeanReference</code>类型，调用<code>getBean(beanReference.getBeanName())</code>获取他的依赖的名字</p><p>使用递归获取，被依赖的Bean创建完成后返回，用创建好的Bean对象填充当前Bean的属性</p><p>框架自动处理依赖关系，开发者无需关心创建顺序，只有真正需要这个bean的时候才会创建，提高了性能。然后我们创建后的Bean会被缓存，避免重复创建。这是缓存的思想</p><p>处理循环依赖：使用三级缓存架构来解决，一级缓存，完整的bean。二级缓存，实例化，没有进行属性的填充。三级缓存，bean的工厂对象，用于解决aop代理的问题</p><div class="table-container"><table><thead><tr><th>缓存级别</th><th>存储内容</th><th>作用</th><th>时机</th></tr></thead><tbody><tr><td><strong>一级缓存</strong></td><td>完整的Bean对象</td><td>存放完全初始化好的Bean</td><td>Bean创建完成后</td></tr><tr><td><strong>二级缓存</strong></td><td>早期Bean对象</td><td>存放实例化但未填充属性的Bean</td><td>解决循环依赖时</td></tr><tr><td><strong>三级缓存</strong></td><td>ObjectFactory</td><td>用于创建代理对象</td><td>Bean实例化后立即放入</td></tr></tbody></table></div><p>扩展支持private boolean allowCircularReference = true;</p><p><strong>DefaultSingletonBeanRegistry</strong>：</p><p>一级一级的调用，先去找一次缓存没有，标记为正在创建，然后再找二级缓存，允许早期引用。没有就从三级缓存中获取，还没有的话，<em>通过ObjectFactory创建Bean</em></p><p>然后放入二级缓存，从三级缓存中删除。</p><p>实体类方法：</p><p>实例化后立刻放入三级缓存，然后进行填充属性。然后初始化bean，成功之后放入一级缓存，标记为完成</p><p>流程：</p><p><strong>创建UserService</strong></p><ol><li>doGetBean(“userService”)</li><li>getSingleton(“userService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“userService”) → 标记正在创建</li><li>createBeanInstance() → 实例化UserService对象</li><li>addSingletonFactory(“userService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充orderService属性</li><li>getBean(“orderService”) → 触发OrderService创建</li></ol><p>创建orderService</p><ol><li>doGetBean(“orderService”)  </li><li>getSingleton(“orderService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“orderService”) → 标记正在创建</li><li>createBeanInstance() → 实例化OrderService对象</li><li>addSingletonFactory(“orderService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充userService属性</li><li>getBean(“userService”) → 再次请求UserService</li></ol><p>循环依赖解析</p><ol><li>doGetBean(“userService”)</li><li>getSingleton(“userService”, true) → 执行三级缓存查找<ul><li>一级缓存：null</li><li>isSingletonCurrentlyInCreation(“userService”) → true</li><li>二级缓存：null  </li><li>三级缓存：找到ObjectFactory</li><li>factory.getObject() → 返回早期UserService对象</li><li>放入二级缓存，移除三级缓存</li></ul></li><li>返回早期UserService对象给OrderService</li><li>OrderService属性填充完成</li><li>OrderService初始化完成，添加到一级缓存</li><li>返回OrderService给UserService</li><li>UserService属性填充完成</li><li>UserService初始化完成，添加到一级缓存</li></ol><p>这就是我们所说的提前暴露的问题</p><h2 id="bean管理"><a href="#bean管理" class="headerlink" title="bean管理"></a>bean管理</h2><p>使用配置文件来管理我们的bean,添加一个资源解释器，也就是能读取classpath、本地文件和云文件的配置内容</p><p>里面会包括 Bean 对象的描述和属性信息。在读取配置文件信息后，接下来就是对配置文件中的 Bean 描述信息解析后进行注册操作，把 Bean 对象注册到 Spring 容器中。</p><p>从配置文件层-&gt;资源加载层-&gt;解析注册层-&gt;bean容器层</p><hr><p>资源加载：定义 Resource 接口，提供获取 InputStream 流的方法</p><p>然后策略实现类，多种的实现策略。</p><p><strong>ClassPath资源加载</strong>：</p><p>通过 <code>ClassLoader</code> 读取<code>ClassPath</code> 下的文件信息，具体的读取过程主要是：<code>classLoader.getResourceAsStream(path)</code></p><ul><li><strong>打包后的配置文件</strong>：JAR包内的spring.xml</li><li><strong>测试资源</strong>：src/test/resources下的配置文件</li><li><strong>类路径资源</strong>：与class文件同目录的配置文件</li></ul><p><strong>文件系统资源加载</strong>：</p><p>通过指定文件路径的方式读取文件信息</p><ul><li><strong>外部配置文件</strong>：/etc/app/config.xml</li><li><strong>用户自定义配置</strong>：~/app/custom.properties</li><li><strong>绝对路径资源</strong>：D:/config/spring.xml</li></ul><p><strong>URL资源加载</strong>：</p><p>通过 HTTP 的方式读取云服务的文件，我们也可以把配置文件放到 GitHub 或者 Gitee 上，使用URLConnection</p><ul><li><strong>远程配置中心</strong>：<a href="http://config-server/app.xml">http://config-server/app.xml</a></li><li><strong>云端配置文件</strong>：<a href="https://github.com/user/repo/config.xml">https://github.com/user/repo/config.xml</a></li><li><strong>动态配置</strong>：从配置中心实时拉取</li></ul><hr><p>智能资源定位器，<strong>DefaultResourceLoader</strong></p><p>按照资源加载的不同方式，资源加载器可以把这些方式集中到统一的类服务下进行处理，外部用户只需要传递资源地址即可</p><p>使用的顺序是先去从classpath进行获取，然后再去获取url资源。都没有的话采取获取默认的文件系统资源</p><p>Bean定义读取器，BeanDefinitionReader</p><p>通过这个抽象类的具体实现就可以把解析后的 XML 文件中的 Bean 信息，注册到 Spring 容器去了。<em>以前我们是通过单元测试使用，调用 BeanDefinitionRegistry 完成Bean的注册，现在可以放到 XMl 中操作了</em></p><p>解析xml处理bean注册，<strong>XmlBeanDefinitionReader</strong> 基础自抽象类</p><p>将xml文件映射为我们需要的代码，然后进行在spring容器中的注册</p><h2 id="bean组件的扩展"><a href="#bean组件的扩展" class="headerlink" title="bean组件的扩展"></a>bean组件的扩展</h2><p>在实际工作中，当我们开发基于Spring的技术组件（如中间件、SpringBoot Starter等）时，经常需要：</p><ul><li>修改Bean的信息</li><li>添加日志打印、监控</li><li>处理数据库路由和数据源切换</li><li>给RPC服务连接注册中心</li><li>实现AOP切面功能</li></ul><p>这些都需要在Bean的生命周期中插入自定义逻辑，这就是Spring扩展机制的核心价值。</p><p><strong>BeanFactoryPostProcessor - Bean定义后置处理器</strong></p><p>在beandefinition加载完之后，bean实例化之前，可以去修改beandefinition的属性信息。相当于我们去建筑的蓝图。用于配置属性修改、Bean定义动态调整</p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 场景1：动态修改Bean的属性值</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">userServiceDef</span> <span class="operator">=</span> beanFactory.getBeanDefinition(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">PropertyValues</span> <span class="variable">pv</span> <span class="operator">=</span> userServiceDef.getPropertyValues();</span><br><span class="line">        pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;environment&quot;</span>, <span class="string">&quot;production&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景2：根据环境调整Bean配置</span></span><br><span class="line">        <span class="keyword">if</span> (isProductionEnvironment()) &#123;</span><br><span class="line">            pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;timeout&quot;</span>, <span class="string">&quot;30000&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景3：添加额外的Bean定义</span></span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;dynamicBean&quot;</span>, createDynamicBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanPostProcessor - Bean实例后置处理器</strong></p><p><em>Bean实例化和属性注入后，初始化方法调用前执行</em>,他有前置和后置的类型，我们一般在后置进行增加的更多，比如AOP代理，Bean增强，属性修改。依赖检查，权限校验和监控</p><p>ApplicationContext应用上下文架构</p><p>为了避免繁琐的操作，他是我们最常用的一个IOC容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简洁的上下文操作</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">UserService userService = context.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接口体系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 接口层次结构</span><br><span class="line">BeanFactory                           // 基础Bean工厂</span><br><span class="line">└── ListableBeanFactory              // 可列举Bean的工厂</span><br><span class="line">    └── ApplicationContext           // 应用上下文接口</span><br><span class="line">        └── ConfigurableApplicationContext  // 可配置的应用上下文</span><br><span class="line"></span><br><span class="line">// 实现层次结构  </span><br><span class="line">DefaultResourceLoader                 // 资源加载能力</span><br><span class="line">└── AbstractApplicationContext       // 上下文抽象实现</span><br><span class="line">    └── AbstractRefreshableApplicationContext     // 可刷新的上下文</span><br><span class="line">        └── AbstractXmlApplicationContext         // XML配置支持</span><br><span class="line">            └── ClassPathXmlApplicationContext    // 类路径XML上下文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在applicationcontext里面最重要的方法就是refresh方法</p><p>创建beanfactory然后加载beandefinnition</p><p>然后我们去获取beanfactory，执行<em>BeanFactoryPost</em>processor修改beandefinition</p><p>然后注册beanpostprocessor,为后续的处理进行准备</p><p>然后提前实例化单例的bean。</p><p>完整的生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. BeanDefinition注册</span><br><span class="line">        ↓</span><br><span class="line">2. BeanFactoryPostProcessor执行 ← 修改BeanDefinition</span><br><span class="line">        ↓</span><br><span class="line">3. Bean实例化（Constructor）</span><br><span class="line">        ↓</span><br><span class="line">4. 属性注入（Setter）</span><br><span class="line">        ↓</span><br><span class="line">5. BeanPostProcessor.postProcessBeforeInitialization ← Bean增强</span><br><span class="line">        ↓</span><br><span class="line">6. 初始化方法执行（@PostConstruct, InitializingBean, init-method）</span><br><span class="line">        ↓</span><br><span class="line">7. BeanPostProcessor.postProcessAfterInitialization ← AOP代理创建</span><br><span class="line">        ↓</span><br><span class="line">8. Bean就绪，放入容器</span><br><span class="line">        ↓</span><br><span class="line">9. 应用运行</span><br><span class="line">        ↓</span><br><span class="line">10. 容器关闭时执行销毁方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanFactoryPostProcessor应用场景</strong>：</p><ol><li><strong>配置中心集成</strong>：动态读取远程配置修改Bean属性</li><li><strong>环境相关配置</strong>：根据环境（dev/test/prod）调整Bean配置</li><li><strong>属性占位符解析</strong>：解析${property}占位符</li><li><strong>条件化Bean注册</strong>：根据条件动态注册Bean</li></ol><p><strong>BeanPostProcessor应用场景</strong>：</p><ol><li><strong>AOP实现</strong>：Spring AOP就是通过此接口创建代理对象</li><li><strong>中间件集成</strong>：如MyBatis的MapperScannerConfigurer</li><li><strong>监控和日志</strong>：自动添加监控、日志功能</li><li><strong>依赖注入增强</strong>：如@Autowired注解的实现</li><li><strong>数据源路由</strong>：动态数据源切换</li></ol><p><strong>Spring中哪些功能使用了这些扩展机制</strong></p><p><strong>BeanFactoryPostProcessor的应用</strong>：</p><ul><li><code>PropertyPlaceholderConfigurer</code>：属性占位符解析</li><li><code>PropertySourcesPlaceholderConfigurer</code>：Spring 3.1+的属性解析</li><li><code>ConfigurationClassPostProcessor</code>：@Configuration类处理</li></ul><p><strong>BeanPostProcessor的应用</strong>：</p><ul><li><code>AutowiredAnnotationBeanPostProcessor</code>：@Autowired注解处理</li><li><code>CommonAnnotationBeanPostProcessor</code>：@Resource等注解处理</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>：AOP代理创建</li></ul><h2 id="bean的初始化和销毁"><a href="#bean的初始化和销毁" class="headerlink" title="bean的初始化和销毁"></a>bean的初始化和销毁</h2><p>完整的生命周期：</p><p>Bean定义注册<br>    ↓<br>BeanFactoryPostProcessor执行<br>    ↓<br>Bean实例化（Constructor）<br>    ↓<br>属性注入（Setter/Field）<br>    ↓<br>BeanPostProcessor.postProcessBeforeInitialization<br>    ↓<br>InitializingBean.afterPropertiesSet() ← 接口方式初始化<br>    ↓<br>init-method执行 ← XML配置方式初始化<br>    ↓<br>BeanPostProcessor.postProcessAfterInitialization<br>    ↓<br>Bean就绪状态<br>    ↓<br>容器关闭触发<br>    ↓<br>DisposableBean.destroy() ← 接口方式销毁<br>    ↓<br>destroy-method执行 ← XML配置方式销毁</p><p>在这个里面,init-method和destory-method他们也是要xml配置来进行的。所以也要通过 XmlBeanDefinitionReader 加载 spring.xml 配置信息到 BeanDefinition 中。</p><ul><li>InitializingBean、DisposableBean，两个接口方法还是比较常用的，在一些需要结合 Spring 实现的组件中，经常会使用这两个方法来做一些参数的初始化和销毁操作。比如接口暴漏、数据库数据读取、配置文件加载等等。</li><li>在方法 invokeInitMethods 中，主要分为两块来执行实现了 InitializingBean 接口的操作，处理 afterPropertiesSet 方法。另外一个是判断配置信息 init-method 是否存在，执行反射调用 initMethod.invoke(bean)。这两种方式都可以在 Bean 对象初始化过程中进行处理加载 Bean 对象中的初始化操作，让使用者可以额外新增加自己想要的动作。先执行接口方式，再执行配置方式，通过反射避免重复执行同名方法</li><li>方法destory跟上面的invokeinitMethods差不多，都是先实现接口，然后<em>配置信息 destroy-method {判断是为了避免二次执行销毁}</em></li></ul><p>虚拟机关闭钩子：</p><ul><li>首先我们需要在 ConfigurableApplicationContext 接口中定义注册虚拟机钩子的方法 <code>registerShutdownHook</code> 和手动执行关闭的方法 <code>close</code>。</li><li>在抽象实现类里面进行实现，注册JVM关闭构造的时候，是Runtime.getRuntime().addShutdownHook</li></ul><p>1.<strong>初始化方法和构造函数的区别？</strong></p><p>主要的区别在于执行的实际和功能定位，构造函数执行的时候，依赖注入还没完成，无法进行初始化</p><p>初始化方法执行的时候，所有属性已经完成。可以使用依赖对象进行初始化。比如建立数据库连接池，缓存预热，注册到注册中心</p><p>然后构造函数主要用于对象创建、基本属性设置，初始化方法主要使用依赖就绪后的业务初始化</p><p>2.<strong>为什么需要销毁方法？不能依赖GC吗</strong></p><p>GC只能回收内存，不能处理资源的释放</p><p>比如，socket,http连接，文件流，数据库连接等。比如线程池，定时器。还有注册中心，Mbean</p><p>3.<strong>Spring中哪些组件使用了初始化/销毁机制？</strong></p><p><strong>几乎所有核心组件都有应用</strong>，比如数据源组件，初始化连接池，销毁连接池</p><p>缓存组件，初始化缓存预热，关闭redis连接</p><p><strong>消息队列</strong>，启动监听消息队列，停止监听关闭消息队列</p><p>4.<strong>如何保证初始化方法的执行顺序？</strong></p><p>使用<em>@DependsOn</em>注解，就是一个前置条件，<em>确保configService和cacheService先初始化</em></p><p><strong>@Order注解配合ApplicationListener</strong>，数字越小，约先执行。</p><p><em>实现Ordered接口</em>，然后确定高优先级的初始化</p><p>5.<strong>如何处理初始化方法的异常？</strong></p><ol><li><strong>快速失败</strong>：关键资源初始化失败时立即抛异常</li><li><strong>优雅降级</strong>：非关键失败时使用备用方案</li><li><strong>延迟重试</strong>：网络等临时性失败可以重试</li></ol><h2 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h2><p>Aware是Spring提供的一种<strong>容器感知机制</strong>，让Bean能够获取Spring容器中的各种资源和服务。它是一个<strong>标记接口</strong>，通过实现不同的Aware子接口，Bean可以感知到：</p><ul><li>BeanFactory</li><li>ApplicationContext</li><li>ClassLoader</li><li>Bean名称</li><li>以及其他容器资源</li></ul><p>继承 Aware 的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware</p><p>在具体的接口实现过程中你可以看到，一部分(<em>BeanFactoryAware、BeanClassLoaderAware、BeanNameAware</em>)在 factory 的 support 文件夹下，另外 ApplicationContextAware 是在 context 的 support 中，这是因为不同的内容获取需要在不同的包下提供。所以，在 AbstractApplicationContext 的具体实现中会用到向 beanFactory 添加 BeanPostProcessor 内容的 <code>ApplicationContextAwareProcessor</code> 操作，最后由 AbstractAutowireCapableBeanFactory 创建 createBean 时处理相应的调用操作。</p><p>Aware接口</p><ul><li><p>在 Spring 中有特别多类似这样的标记接口的设计方式，它们的存在就像是一种标签一样，可以方便统一摘取出属于此类接口的实现类，通常会有 instanceof 一起判断使用。</p></li><li><p><strong>标记模式</strong>：类似于<code>Serializable</code>接口，用于标识具有某种特性的类</p></li><li><strong>instanceof判断</strong>：通过<code>bean instanceof Aware</code>统一识别和处理</li><li><strong>统一管理</strong>：将所有感知接口归类到一个体系下</li></ul><p>四大核心感知接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 感知BeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 感知ClassLoader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanClassLoaderAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 感知Bean名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 感知ApplicationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用感知：</p><ul><li>首先在 initializeBean 中，通过判断 <code>bean instanceof Aware</code>，调用了三个接口方法，<code>BeanFactoryAware.setBeanFactory(this)</code>、<code>BeanClassLoaderAware.setBeanClassLoader(getBeanClassLoader())</code>、<code>BeanNameAware.setBeanName(beanName)</code>，这样就能通知到已经实现了此接口的类。</li><li><p>另外我们还向 BeanPostProcessor 中添加了 <code>ApplicationContextAwareProcessor</code>，此时在这个方法中也会被调用到具体的类实现，得到一个 ApplicationContex 属性。</p></li><li><p>确保Bean获得感知能力后再进行业务初始化</p></li></ul><p><strong>ApplicationContext</strong>比较特殊他要单独去执行在refresh方法中进行，ApplicationContext在<code>AbstractAutowireCapableBeanFactory</code>中不可直接获取，需要在容器启动时注册专门的处理器，体现了<strong>分层架构</strong>的设计思想。ApplicationContextAwareProcessor在ApplicationContext，其他的他们在<em>BeanFactory层</em> 。</p><p>实现：</p><ol><li>在ApplicationContext层创建<code>ApplicationContextAwareProcessor</code></li><li>将processor注册到BeanFactory中</li><li>利用BeanPostProcessor机制在Bean初始化时注入ApplicationContext</li></ol><p>题目：</p><p>1.<strong>Aware接口的作用是什么？</strong></p><p><strong>Aware接口提供了Bean获取Spring容器资源的标准机制：</strong></p><ol><li><strong>容器感知</strong>：让Bean能够感知到Spring容器的存在</li><li><strong>资源获取</strong>：提供获取容器内部资源的标准方式</li><li><strong>扩展能力</strong>：为开发中间件和框架提供扩展点</li><li><strong>解耦设计</strong>：通过接口回调而非静态方法获取资源</li></ol><p>比如setApplicationContext方法，可以获取容器中的其他的bean，发布应用事件，可以获取环境配置</p><p>setBeanFactory方法，可以动态获取bean，检查bean是不是存在</p><p>2.<strong>不同Aware接口的执行顺序是什么？</strong></p><p>\1. BeanNameAware.setBeanName()</p><p>\2. BeanClassLoaderAware.setBeanClassLoader()  </p><p>\3. BeanFactoryAware.setBeanFactory()</p><p>\4. EnvironmentAware.setEnvironment() (如果实现)</p><p>\5. EmbeddedValueResolverAware.setEmbeddedValueResolver() (如果实现)</p><p>\6. ResourceLoaderAware.setResourceLoader() (如果在ApplicationContext中)</p><p>\7. ApplicationEventPublisherAware.setApplicationEventPublisher() (如果在ApplicationContext中)</p><p>\8. MessageSourceAware.setMessageSource() (如果在ApplicationContext中)</p><p>\9. ApplicationContextAware.setApplicationContext() (如果在ApplicationContext中)</p><ul><li><strong>Bean自身信息</strong>先设置（Name、ClassLoader、Factory）</li><li><strong>容器环境信息</strong>后设置（Context、Environment等）</li><li><strong>应用层面信息</strong>最后设置（Event、Message等）</li><li>最后是我们的context</li></ul><p>3.<strong>Aware机制与@Autowired的区别？</strong></p><div class="table-container"><table><thead><tr><th>对比维度</th><th>Aware接口</th><th>@Autowired</th></tr></thead><tbody><tr><td><strong>注入对象</strong></td><td>Spring容器内部资源</td><td>业务Bean对象</td></tr><tr><td><strong>执行时机</strong></td><td>Bean初始化阶段</td><td>属性注入阶段</td></tr><tr><td><strong>耦合度</strong></td><td>与Spring框架耦合</td><td>相对解耦</td></tr><tr><td><strong>使用场景</strong></td><td>框架扩展、中间件开发</td><td>业务依赖注入</td></tr><tr><td><strong>灵活性</strong></td><td>可以获取容器的动态能力</td><td>静态依赖关系</td></tr></tbody></table></div><h2 id="FactoryBean-amp-Bean的作用域"><a href="#FactoryBean-amp-Bean的作用域" class="headerlink" title="FactoryBean&amp;Bean的作用域"></a>FactoryBean&amp;Bean的作用域</h2><p>FactoryBean是Spring提供的一种<strong>创建复杂Bean对象的工厂接口</strong>，它允许我们自定义Bean的创建逻辑，特别适用于：</p><ul><li><strong>代理对象创建</strong>（如MyBatis的Mapper代理）</li><li><strong>复杂对象初始化</strong>（需要多步骤构建的对象）</li><li><strong>第三方框架集成</strong>（将外部框架的对象纳入Spring管理）</li></ul><p><strong>Bean作用域（Scope）机制</strong></p><p>Spring支持多种Bean作用域：</p><ul><li><strong>singleton</strong>：单例模式（默认），容器中只有一个实例</li><li><strong>prototype</strong>：原型模式，每次获取都创建新实例</li><li><strong>request/session/application</strong>：Web环境中的作用域</li></ul><p>单例模式和原型模式的区别就在于是否存放到内存中，如果是原型模式那么就不会存放到内存中，每次获取都重新创建对象</p><p>这就是我们常说的五大作用域</p><p>FactoryBean设计：获取对象、对象类型，以及是否是单例对象</p><p>比如我们的<strong>MyBatis Mapper代理创建</strong>就是我们自定义的一个FactoryBean， 使用 <code>MapperFactoryBean</code> 将<strong>接口注册为代理对象</strong>，启动时会把接口方法解析成 <code>MappedStatement</code> 存入 Configuration 中，运行时由 <code>MapperProxy</code> 通过反射动态执行 SQL。</p><p>还有数据源代理等等。</p><p>作用域就是我们定义在BeanDefinition中的一个常量，然后我们通过指定scpore字段来定义</p><p>然后xml解析回去xml里获取作用域，然后设置beandefinition的信息</p><p>1.<strong>FactoryBean和BeanFactory的区别？</strong></p><div class="table-container"><table><thead><tr><th>对比维度</th><th>BeanFactory</th><th>FactoryBean</th></tr></thead><tbody><tr><td><strong>性质</strong></td><td>Spring容器的根接口</td><td>用户可实现的工厂接口</td></tr><tr><td><strong>作用</strong></td><td>管理Bean的生命周期</td><td>创建复杂的Bean对象</td></tr><tr><td><strong>使用者</strong></td><td>Spring框架内部使用</td><td>开发者实现和使用</td></tr><tr><td><strong>获取方式</strong></td><td>通过ApplicationContext</td><td>通过getBean()获取其产品</td></tr></tbody></table></div><p>2.<strong>如何获取FactoryBean本身而不是它创建的对象</strong></p><p>使用&amp;的前缀符表示我们需要的是FactoryBean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyFactoryBean factoryBean = (MyFactoryBean) applicationContext.getBean(&quot;&amp;myFactoryBean&quot;);</span><br></pre></td></tr></table></figure><p>然后内部处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;&amp;&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 去掉&amp;前缀，获取FactoryBean本身</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryBeanName</span> <span class="operator">=</span> name.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getFactoryBean(factoryBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常获取FactoryBean创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> getObjectForBeanInstance(getSingleton(name), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.<strong>FactoryBean在什么场景下使用？</strong></p><p>代理对象的创建，<strong>复杂对象初始化</strong>， <strong>第三方框架集成</strong>（比如redis中设置redis的运行的参数和序列化方式）</p><p>4.<strong>FactoryBean的生命周期是怎样的？</strong></p><p><strong>FactoryBean有双重生命周期</strong>，一个是他本身的生命周期，一个是他产品对象的生命周期</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Event机制</p><p>在复杂的业务系统中，直接调用会导致<strong>紧耦合</strong>问题：</p><ul><li><strong>用户注册</strong> → 直接调用发送邮件、赠送积分、风控检查等服务</li><li><strong>订单支付</strong> → 直接调用库存扣减、物流发货、积分计算等服务</li><li><strong>文章发布</strong> → 直接调用消息推送、索引更新、缓存刷新等服务</li></ul><p>这种方式会导致：</p><ol><li><strong>代码耦合度高</strong>：核心业务逻辑与辅助功能混杂</li><li><strong>扩展性差</strong>：新增功能需要修改核心代码</li><li><strong>维护困难</strong>：一个环节出错影响整个流程</li><li><strong>性能问题</strong>：同步执行所有操作，响应慢</li></ol><p>我们可以通过观察者模式进行解耦</p><p>用户注册成功 → 发布UserRegisteredEvent → 多个监听器异步处理</p><p>├── EmailListener: 发送欢迎邮件</p><p>├── CouponListener: 赠送新人礼包  </p><p>├── RiskListener: 风控分析</p><p>└── StatisticsListener: 数据统计</p><p>spring event</p><p>定义出事件类、事件监听、事件发布 事件广播器</p><p>applicationevent-&gt;applicationlistener-&gt;applicationeventpublisher-&gt;applicaitoneventmulticaster</p><p>我们事件类是构建一个基本的抽象类，然后其他的具体事件继承这个抽象类</p><p>事件广播器定义了添加监听和删除监听的方法，和添加广播的方法。<code>multicastEvent</code> 最终推送时间消息也会经过这个接口方法来处理谁该接收事件。</p><p>那我们怎么处理事件广播的并发处理呢？</p><ul><li><strong>监听器隔离</strong>：一个监听器异常不影响其他监听器</li><li><strong>异步执行</strong>：可配置同步或异步处理</li><li><strong>顺序控制</strong>：支持监听器执行顺序</li></ul><p>然后我们怎么去确定某个事件如何被监听器处理？我们使用泛型参数匹配来实现</p><p>我们先去获取监听的class，然后如果存在GCLIB代理的话，我们处理CGLIB代理。spring中Bean可能被代理，需要获取真实类型，就是他的父类。</p><p>然后获取泛型接口，提取泛型参数，获取事件的类型。</p><p>然后判断事件是否匹配，就是判断ParameterizedType 和eventClassName是不是子类和父类的关系</p><p>事件发布器，初始化事件发布者(initApplicationEventMulticaster)，</p><ul><li><p>主要用于实例化一个 SimpleApplicationEventMulticaster，这是一个事件广播器。</p></li><li><p>注册事件监听器(registerListeners)，通过 getBeansOfType 方法获取到所有从 spring.xml 中加载到的事件配置 Bean 对象。</p></li><li>发布容器刷新完成事件(finishRefresh)，发布了第一个服务器启动完成后的事件，这个事件通过 publishEvent 发布出去，其实也就是调用了 applicationEventMulticaster.multicastEvent(event); 方法。</li></ul><p>问题</p><p>1.spring event事件执行的流程：</p><ol><li><strong>事件定义</strong>：继承<code>ApplicationEvent</code>创建事件类</li><li><strong>监听器注册</strong>：实现<code>ApplicationListener</code>并注册到容器</li><li><strong>事件发布</strong>：通过<code>ApplicationEventPublisher.publishEvent()</code>发布</li><li><strong>事件广播</strong>：<code>ApplicationEventMulticaster</code>接收事件</li><li><strong>监听器匹配</strong>：根据泛型参数匹配感兴趣的监听器</li><li><strong>事件处理</strong>：调用匹配监听器的<code>onApplicationEvent()</code>方法</li></ol><p>2.<strong>如何保证Event处理的事务一致性？</strong></p><p>使用事件同步机制，事务提交后执行事务监听器，发送邮件通知等，然后事务回滚的时候发送清理操作</p><p>通过@TransactionalEventListener的状态来确定</p><p>然后失败之后通过补偿机制。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是我们spring的AOP的</p><p>AOP主要就是解耦，他将跟核心业务没关系的业务比如权限，日志等业务的抽离出来，一般都是以注释的形式。然后方法只执行业务核心方法</p><p>动态代理分为JDK动态代理和CGLIB动态代理</p><p>JDK动态代理基于接口，代理实现了接口的类，在运行时动态生成代理类的字节码。速度较快，不需要生成新的字节码</p><p>JdkDynamicAopProxy实现了AopProxy, InvocationHandler</p><p>获取代理方式，获取当前线程的context类加载器，然后通知通知添加目标接口。然后执行<em>InvocationHandler实现</em></p><p>然后使用Invoke方法，执行代理。检查方法是不是匹配切点表达式，匹配成功后执行方法拦截器，拦截，然后换取我们自己实现的bean。如果不匹配的话，我们就执行原来的方法</p><p>CGLIB动态是基于继承目标类生成子类代理，使用了使用ASM字节码技术。除了final都可以代理，速度较慢，需要生成字节码。但是性能较好</p><p>get方法是通过设置我们的需要代理的类，然后设置接口，设置回调处理器</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring/">spring</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/java-stack/spring3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试总结</title>
      <link>https://blog.tokenlen.top/2025/07/19/leetcode/leetcodetotal2/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/leetcode/leetcodetotal2/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;面试题目类型&quot;&gt;&lt;a href=&quot;#面试题目类型&quot; class=&quot;headerlink&quot; title=&quot;面试题目类型&quot;&gt;&lt;/a&gt;面试题目类型&lt;/h1&gt;&lt;h2 id=&quot;双指针&quot;&gt;&lt;a href=&quot;#双指针&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="面试题目类型"><a href="#面试题目类型" class="headerlink" title="面试题目类型"></a>面试题目类型</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>76题目，最小覆盖字串。</p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p>我们可以用滑动窗口，因为他是只是覆盖，不需要我们要求顺序一样。每个字母的出现次数一样就可以。那么我们可以使用一个数组来统计字母和出现的次数</p><p>然后使用滑动窗口涵盖字串，进-&gt;统计次数-&gt;减少次数</p><p>当最小次数为0的时候，这个时候如果滑动窗口的长度小于结果的长度的时候</p><p>更新节点位置</p><p>然后出左节点，如果需要出现的为0了</p><p>那么最少字母次数++</p><p>然后左端点对应的字母需要次数++，左端点移动</p><p>最后需要的是结果左端点和右端点之间的</p><p>也就是我们常说的right-left+1</p><h2 id="堆-amp-栈"><a href="#堆-amp-栈" class="headerlink" title="堆&amp;栈"></a>堆&amp;栈</h2>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/leetcode/leetcodetotal2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 基础知识</title>
      <link>https://blog.tokenlen.top/2025/07/18/new-stack/springai1/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/new-stack/springai1/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;普通概念&quot;&gt;&lt;a href=&quot;#普通概念&quot; class=&quot;headerlink&quot; title=&quot;普通概念&quot;&gt;&lt;/a&gt;普通概念&lt;/h1&gt;&lt;h2 id=&quot;Model&quot;&gt;&lt;a href=&quot;#Model&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="普通概念"><a href="#普通概念" class="headerlink" title="普通概念"></a>普通概念</h1><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><ul><li><strong>ChatModel</strong>: 基于<strong>自回归语言模型</strong>，其核心是 <strong>Transformer Decoder</strong> 架构。它通过“逐字生成”的方式工作：接收一段文本（Prompt），预测下一个最可能的词（Token），然后将新生成的词加入输入，再次预测下一个，如此循环，直到生成完整的回答。这种机制保证了生成文本的上下文连贯性和逻辑性。</li><li><strong>EmbeddingModel</strong>: <code>EmbeddingModel</code>（如text-embedding-ada-002、text2vec-chinese）基于<strong>双向编码器</strong>，其核心是 <strong>Transformer Encoder</strong> 架构。与ChatModel不同，它会同时分析整个输入文本的上下文，然后将文本的深层语义信息<strong>映射</strong>到一个高维、密集的数字向量（Vector）中。在这个向量空间里，语义上相似的文本在空间距离上会更接近。</li></ul><p>EmbeddingModel负责检索阶段：就是我们常说的嵌入模型</p><p>- 将查询和文档转换为向量表示</p><p>- 通过余弦相似度计算相关性</p><p>- 检索最相关的K个文档片段</p><p>ChatModel负责生成阶段：就是我们常用的聊天的那种模型</p><p>- 接收检索到的上下文+用户查询</p><p>- 基于上下文生成回答</p><p>- 保证回答的连贯性和准确性</p><p>那么我们如何选择模型呢？</p><ol><li><p>维度大小：向量的维度。维度越高，通常能编码更丰富的语义信息，但也会增加存储和计算开销。</p><ul><li><strong>示例</strong>：<code>BERT-base</code> 通常是768维，而OpenAI的 <code>text-embedding-ada-002</code> 是1536维。</li></ul></li><li><p>语言支持：模型是否针对特定语言（如中文）进行过优化。对于中文场景，使用专门的中文Embedding模型（如 <code>text2vec-chinese</code>）效果远超通用模型。</p></li><li><p>领域适配：通用模型在开放域表现良好，但在专业领域（如法律、医疗），使用经过该领域数据微调过的模型能显著提升准确性。</p></li><li><p>性能指标：</p><p>检索准确率 (Recall/Precision)：衡量Embedding模型检索到的相关文档的准确度。</p><p>推理延迟 (Latency)：模型处理一次请求所需的时间，直接影响用户体验。</p></li></ol><p>比如我自定义知识库使用的就是Embedding v2 ada</p><p>重排模型:</p><h2 id="VectorStore"><a href="#VectorStore" class="headerlink" title="VectorStore"></a>VectorStore</h2><p><code>VectorStore</code> 负责存储<code>EmbeddingModel</code>生成的向量，并提供高效的相似度检索能力。</p><div class="table-container"><table><thead><tr><th>特性</th><th>Redis Vector</th><th>Pinecone</th><th>Weaviate</th></tr></thead><tbody><tr><td><strong>架构</strong></td><td>内存+持久化</td><td>云原生分布式</td><td>图数据库+向量</td></tr><tr><td><strong>索引算法</strong></td><td>HNSW/IVF</td><td>专有优化算法</td><td>HNSW</td></tr><tr><td><strong>存储成本</strong></td><td>中等(内存占用高)</td><td>高(按量计费)</td><td>低(开源版免费)</td></tr><tr><td><strong>检索延迟</strong></td><td>&lt;10ms</td><td>10-50ms</td><td>20-100ms</td></tr><tr><td><strong>扩展性</strong></td><td>水平扩展复杂</td><td>自动扩缩容</td><td>手动扩展</td></tr></tbody></table></div><ul><li><strong>小规模验证 (&lt;10万文档)</strong>：<strong>Redis Vector</strong> 是绝佳选择。部署简单，延迟极低，与现有Java生态无缝集成。</li><li><strong>中等规模生产 (10万-1000万)</strong>：<strong>Pinecone</strong> 提供完全托管的服务，免去运维烦恼，让你专注于业务逻辑。</li><li><strong>大规模或定制化场景 (&gt;1000万)</strong>：<strong>Weaviate</strong> 的开源和分布式特性提供了极高的灵活性和成本优势，但需要投入运维资源。</li><li><strong>成本敏感场景</strong>：<strong>Weaviate 开源版</strong> 自建部署是理想选择。</li></ul><h2 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h2><p>RAG就是检索增强，是一种让LLM访问外部知识库以回答问题的框架，极大地减少了模型幻觉，提高了回答的准确性。</p><p>我们使用嵌入模型的时候是需要对我们传入的文档进行切分的</p><p>切分策略：</p><p>一般的切分策略就是按照大小进行切分的，一般就是多少个字就切分。这样的话比较简答，但是可能破坏语句的完整性。适用于API，代码等</p><p>还有就是按照语义进行切分，这样就是按照句子边界，标点符号进行切分。这样保证了语句的完整性，但是我们切分的效率比较慢。适用于文章报告等</p><p>我们切分的时候要去按照场景进行选择</p><ul><li><p><strong>检索准确率</strong>：语义切分通常能确保每个Chunk包含完整的答案片段，从而提升准确率。</p></li><li><p><strong>上下文利用率</strong>：合适的Chunk大小可以最大化利用模型的上下文窗口，不多也不少。</p></li><li><p><strong>重叠比例 (Overlap)</strong>：设置一部分重叠内容（如10%）可以防止重要信息在切分边界处丢失。</p><p>在Spring AI中，通常通过实现<code>DocumentTransformer</code>接口来定义切分逻辑。</p></li></ul><hr><p>检索策略：</p><p>密集检索，就是使用模型调用embed方法，然后调用向量库进行密集搜索。这样的话语义理解强，但是对罕见词汇搜索较差</p><p>bm25检索，传统的关键词匹配算法，对罕见词、专业术语友好，但缺乏语义理解。</p><p>混合检索，就待用密集检索和bm25检索，然后分析文档。结合了两种检索，但是复杂度增加了</p><h2 id="上下文构建"><a href="#上下文构建" class="headerlink" title="上下文构建"></a>上下文构建</h2><p>检索到的文档片段不能直接丢给LLM，需要精心组织成“上下文”（Context），以避免噪声干扰。</p><p> 1.如何避免<strong>上下文噪声干扰</strong>？</p><ul><li><strong>重排序 (Reranking)</strong>：使用更轻量、但更精确的模型（如Cross-Encoder）对初步检索到的Top-K结果进行二次排序，将最相关的文档排在最前面。</li><li><strong>上下文压缩 (Context Compression)</strong>：从检索到的文档中提取与用户问题最相关的句子或摘要，丢弃无关信息，减少噪声。</li><li><strong>分层检索 (Hierarchical Retrieval)</strong>：对于结构化的长文档，可以先检索到相关的章节标题，再在章节内部进行精确检索。</li><li><strong>动态上下文长度 (Dynamic Context Length)</strong>：根据问题的复杂度和模型上下文窗口的限制，动态调整送入模型的文档数量。</li></ul><p>在Spring AI中，这些策略通常在调用<code>ChatModel</code>之前，通过自定义逻辑实现。</p><h2 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h2><p> 函数调用允许LLM将自然语言指令转化为对外部工具（API、数据库查询等）的结构化调用。</p><ul><li><p><strong>参数校验</strong>：这是安全的第一道防线。可以使用<strong>JSON Schema</strong>来定义函数期望的参数格式、类型和范围，在执行前进行严格校验。</p></li><li><p>安全机制</p><ul><li><strong>参数沙箱</strong>：绝不直接将用户输入用于代码执行或数据库查询，进行严格的无害化处理。</li><li><strong>权限控制</strong>：根据用户身份，限制其能调用的函数集合。</li><li><strong>执行隔离/超时</strong>：在独立、受限的环境中执行函数，并设置超时，防止恶意调用消耗系统资源。</li><li><strong>审计日志</strong>：记录所有函数调用，便于追踪和分析。</li></ul></li><li><p><strong>错误处理</strong>：健壮的错误处理至关重要。需要明确处理参数验证失败（<code>ParameterValidationException</code>）、执行超时（<code>ExecutionTimeoutException</code>）、资源超限（<code>ResourceLimitException</code>）等情况，并设计合理的<strong>重试策略</strong>（如使用<code>@Retryable</code>）</p><p>先捕捉ParameterValidationException，参数验证</p><p>再捕捉ExecutionTimeoutException，执行超时</p><p>再捕捉ResourceLimitException，资源限制</p><p>然后再执行重试策略，加上重试注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))</span><br></pre></td></tr></table></figure></li></ul><p>在Spring AI中，你可以定义一个<code>@Bean</code>，通过<code>@Description</code>注解描述其功能，Spring AI会自动将其注册为可供LLM调用的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionParameterValidator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ValidationResult <span class="title function_">validate</span><span class="params">(FunctionCall call)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ValidationResult.builder()</span><br><span class="line">            .typeValidation(validateTypes(call.getParameters()))</span><br><span class="line">            .rangeValidation(validateRanges(call.getParameters()))</span><br><span class="line">            .formatValidation(validateFormats(call.getParameters()))</span><br><span class="line">            .businessValidation(validateBusinessRules(call.getParameters()))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validateTypes</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="comment">// JSON Schema验证</span></span><br><span class="line">        <span class="comment">// 类型强制转换</span></span><br><span class="line">        <span class="comment">// null值处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>Agent是什么，是一个自主决策的智能体</p><p><strong>如何设计多Agent协作的通信机制？</strong></p><p>消息总线模式：</p><p>   - 使用Redis/RabbitMQ作为消息中介</p><p>   - Agent间异步通信</p><p>   - 支持广播和点对点通信</p><p>协调者模式：</p><p>   - 中央协调器管理任务分配</p><p>   - Agent向协调器汇报状态</p><p>   - 协调器负责冲突解决</p><p>契约式协作：</p><p>   - 定义Agent间的服务契约</p><p>   - 使用OpenAPI规范描述接口</p><p>   - 支持版本管理和向后兼容</p><p>状态同步机制：</p><p>   - 共享状态存储(Redis Cluster)</p><p>   - 乐观锁处理并发冲突</p><p>   - 事件溯源记录状态变更</p><p>决策树/状态机实现：</p><ul><li>可以使用<strong>状态机</strong>来定义Agent的行为逻辑。例如，一个Agent的状态可以流转于：<code>IDLE</code> -&gt; <code>PLANNING</code> -&gt; <code>EXECUTING_TOOL</code> -&gt; <code>WAITING_FOR_RESULT</code> -&gt; <code>COMPLETED/ERROR</code>。每个状态转移都由特定的事件触发。这种方式使得Agent的行为清晰、可控、易于调试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentStateMachine</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgentState</span> &#123;</span><br><span class="line">        IDLE, PLANNING, EXECUTING, WAITING_INPUT, COMPLETED, ERROR</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AgentState <span class="title function_">transition</span><span class="params">(AgentState current, AgentEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">            <span class="keyword">case</span> IDLE -&gt; event == START ? PLANNING : IDLE;</span><br><span class="line">            <span class="keyword">case</span> PLANNING -&gt; event == PLAN_READY ? EXECUTING : </span><br><span class="line">                           event == NEED_INPUT ? WAITING_INPUT : PLANNING;</span><br><span class="line">            <span class="keyword">case</span> EXECUTING -&gt; event == SUCCESS ? COMPLETED :</span><br><span class="line">                            event == FAILURE ? ERROR : EXECUTING;</span><br><span class="line">            <span class="keyword">default</span> -&gt; current;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><p>MCP是一个由Anthropic、OpenAI、Google等行业巨头共同支持的<strong>开放标准</strong>。你可以把它理解为<strong>AI世界的JDBC或JMS</strong>——它旨在标准化AI模型与外部工具、数据源进行交互的方式。</p><ul><li><strong>MCP服务器 (MCP Server)</strong>：任何外部工具、API或数据源（比如你的Spring Boot应用提供的服务）都可以通过实现MCP协议，将自己暴露为一个MCP服务器。它会“宣告”自己能提供哪些能力（如<code>查询订单</code>、<code>读取文件</code>）。</li><li><strong>MCP客户端 (MCP Client)</strong>：AI模型或代理（Agent）作为客户端，可以<strong>发现</strong>并<strong>连接</strong>到这些MCP服务器，使用标准化的请求/响应格式与之交互，而无需关心服务器底层的具体实现。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">传统函数调用 (Function Calling)</th><th style="text-align:left">模型上下文协议 (MCP)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>本质</strong></td><td style="text-align:left"><strong>模型特定的API</strong></td><td style="text-align:left"><strong>开放的、通用的通信协议</strong></td></tr><tr><td style="text-align:left"><strong>耦合度</strong></td><td style="text-align:left">高度耦合（与特定LLM提供商绑定）</td><td style="text-align:left"><strong>松耦合</strong>（与任何支持MCP的LLM兼容）</td></tr><tr><td style="text-align:left"><strong>互操作性</strong></td><td style="text-align:left">弱（切换模型成本高）</td><td style="text-align:left"><strong>强</strong>（工具可被不同模型复用）</td></tr><tr><td style="text-align:left"><strong>生态</strong></td><td style="text-align:left">封闭（各厂商各自为政）</td><td style="text-align:left"><strong>开放</strong>（促进工具和服务的生态系统）</td></tr></tbody></table></div><p> <strong>作为MCP客户端（消费工具）</strong></p><ol><li>在<code>application.yml</code>中配置需要连接的外部MCP服务器的地址。</li><li>Spring AI将提供一个统一的<code>McpTemplate</code>或类似的客户端Bean。</li><li>我们的Agent通过这个<code>McpTemplate</code>来发现并调用外部工具。</li><li><code>McpTemplate</code>会将调用转化为标准的MCP请求，并发送给目标服务器。</li></ol><p>我们如何去导入一个mcp呢在我的项目中？</p><p>如果是内部的，我直接写一个mcp工具即可，实现mcptool接口，继承抽象mcp基类</p><p>外部的我先导入依赖，中添加<code>spring-ai-mistralai-spring-boot-starter</code>依赖</p><p>然后配置mcp服务器，在里面指定mcp的json配置</p><p>然后再spring ai中配置我们chatmodel的apikey</p><p>然后我们就可以使用注册好mcp的chatmodel，来完成使用mcp完成</p><h2 id="Dify"><a href="#Dify" class="headerlink" title="Dify"></a>Dify</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>核心能力：</p><ol><li><strong>可视化的提示词编排 (Prompt Studio)</strong>：提供一个图形界面，让开发者可以像填表格一样设计和调试Prompt，管理变量、上下文和模型输出。</li><li><strong>内置的RAG引擎</strong>：允许用户直接上传文档（PDF, TXT, Markdown等），Dify会自动处理数据清洗、分块、向量化和索引，快速构建起一个可供检索的知识库。</li><li><strong>Agent能力</strong>：支持应用集成“工具 (Tools)”，让大模型可以调用外部API（如查询天气、搜索、计算等），完成更复杂的任务，而不仅仅是文本生成。</li><li><strong>统一的API服务</strong>：一旦你在Dify上构建好应用，它会自动生成一套标准的API。你的前端或业务后端可以直接调用这个API，无需关心背后的大模型是哪个、RAG流程如何运作。</li><li><strong>监控与分析</strong>：内置日志和数据分析功能，可以让你监控应用的调用情况、用户反馈、Token消耗等，方便持续运营和优化。</li></ol><p>那么我们怎么构建一个dify，比如n8n工作流</p><p>1.创建新的应用</p><p>2.编排提示词，加入变量</p><p>3.构建RAG知识库，选择嵌入模型</p><p>4.调试程序问题</p><p>5.发布</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/new-stack/springai1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 面试题目</title>
      <link>https://blog.tokenlen.top/2025/07/18/new-stack/springai2/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/new-stack/springai2/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;model类型面试题目&quot;&gt;&lt;a href=&quot;#model类型面试题目&quot; class=&quot;headerlink&quot; title=&quot;model类型面试题目&quot;&gt;&lt;/a&gt;model类型面试题目&lt;/h1&gt;&lt;h2 id=&quot;1-如何实现大模型的连续对话？&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="model类型面试题目"><a href="#model类型面试题目" class="headerlink" title="model类型面试题目"></a>model类型面试题目</h1><h2 id="1-如何实现大模型的连续对话？"><a href="#1-如何实现大模型的连续对话？" class="headerlink" title="1.如何实现大模型的连续对话？"></a>1.如何实现大模型的连续对话？</h2><p>所有的大模型本身是不进行信息存储的，也不提供连续对话功能，<strong>所以想要实现连续对话功能需要开发者自己写代码才能实现</strong></p><p>所以呢我们需要将当前用户的提问与<strong>经过管理的对话历史</strong>一同作为输入，提交给模型。</p><p>我们需要维护一个session，</p><p>通常是<code>List&lt;Message&gt;</code>结构。<code>Message</code>对象至少包含两个关键字段：</p><ul><li><code>role</code>: 角色（<code>system</code>、<code>user</code>、<code>assistant</code>）</li><li><code>content</code>: 消息内容</li></ul><p>然后进入交互循环</p><ul><li><strong>用户输入</strong>：接收用户的新消息（<code>user</code> role）。</li><li><strong>上下文构建</strong>：从存储中获取该会话的历史消息列表，并将新消息追加到列表末尾。</li><li><strong>API调用</strong>：将完整的消息列表提交给大模型。</li><li><strong>获取响应</strong>：接收模型的回复（<code>assistant</code> role）。</li><li><strong>上下文持久化</strong>：将模型的回复也追加到历史消息列表中，并更新存储（如Redis、数据库等），为下一次交互做准备。</li></ul><p>在这里面最重要的就是上下文是有窗口限制的，超出模型的Token限制（如4K, 8K, 32K, 128K）。这不仅会导致API调用失败，还会增加成本和响应延迟。</p><p>1.截断策略：</p><ul><li><strong>简单滑动窗口</strong>：只保留最近的 N 轮对话。实现最简单，但会丢失早期的重要信息。</li><li><strong>保留首轮+滑动窗口</strong>：保留系统提示（<code>system</code> prompt）和第一轮对话，然后截取最近的 N-2 轮对话。适用于需要固定初始设定的场景。</li></ul><p>2.摘要策略：</p><ul><li><strong>滚动摘要</strong>：当对话长度达到一定阈值时，使用另一个LLM调用将较早的对话内容进行总结，用这个摘要替换掉原始的多轮对话。</li><li><strong>优点</strong>：保留了长期记忆的精华。</li><li><strong>缺点</strong>：摘要过程会丢失细节，并产生额外的API开销和延迟。</li></ul><p>3.RAG策略：</p><ol><li><strong>存储</strong>：将每一轮完整的对话历史（或其要点）向量化后存入向量数据库 (VectorDB)。</li><li><strong>检索</strong>：当用户提出新问题时，先将问题向量化，然后去向量数据库中检索最相关的 N 条历史对话记录。</li><li><strong>注入</strong>：将这些检索出的、最相关的历史记录，连同当前问题，一起注入到提示词中，提交给大模型。</li></ol><ul><li><ul><li><strong>突破长度限制</strong>：理论上可以维护无限的对话历史。</li><li><strong>高相关性</strong>：只提供与当前问题最相关的上下文，效率高。</li></ul></li><li><strong>挑战</strong>：需要引入向量数据库（如Milvus, Pinecone）和embedding模型，系统复杂度更高。</li></ul><p>这是我们自己需要配置的，但是Spring AI Alibaba 因为内置了连续对话的多种实现,比如mysql,redis</p><p>只需要简单配置就ok，我们注入注入 RedisChatMemoryRepository 对象。</p><p>然后配置 ChatClient 实现连续对话。</p><p>直接调用先prompt，然后advisors,最好call.context发送给模型</p><h2 id="2-AI项目的执行流程"><a href="#2-AI项目的执行流程" class="headerlink" title="2.AI项目的执行流程"></a>2.AI项目的执行流程</h2><p>我习惯上分为<strong>离线数据处理（Data Preparation）</strong> 和 <strong>在线请求处理（Real-time Inference）</strong></p><p>1.离线数据处理：</p><p>这个阶段的目标是将原始、异构的数据处理成AI模型可以高效检索的结构化知识库。它是一次性的或周期性执行的。</p><ol><li><strong>多源数据抽取 (Extraction)</strong>：<ul><li>首先，需要从多个来源抽取数据，这些数据就是我们常说的“知识”。来源可能包括：<ul><li><strong>结构化数据</strong>：如MySQL, PostgreSQL里的业务数据。</li><li><strong>半结构化数据</strong>：如网页HTML, Markdown文档。</li><li><strong>非结构化数据</strong>：如PDF, Word文档, 纯文本。</li><li><strong>API数据</strong>：通过调用内部或外部API获取的动态信息。</li></ul></li></ul></li><li><strong>数据清洗与分块 (Cleaning &amp; Chunking)</strong>：<ul><li>原始数据是“脏”的，必须清洗。这包括去除无关信息（如HTML标签、广告、页眉页脚）、处理格式错误、统一编码等。</li><li>清洗后，将长文本（如一篇长文档）切分成有意义的、大小适中的“文本块 (Chunks)”。这一步至关重要，因为文本块是后续向量检索的基本单位。分块的好坏直接影响检索质量。</li></ul></li><li><strong>向量化与索引 (Embedding &amp; Indexing)</strong>：<ul><li>这是将文本语言转换为数学语言的核心步骤。</li><li>我们使用一个特定的<strong>Embedding模型</strong>，将每一个“文本块”计算成一个高维向量（Embedding）。这个向量可以被认为是该文本块在语义空间中的“坐标”。</li><li>然后，将这些文本块原文连同它们的向量索引，存入一个或多个<strong>向量数据库</strong>（如Milvus, Pinecone）中。同时，也可能将关键词、元数据等存入传统检索引擎（如Elasticsearch）。</li></ul></li></ol><p>2.在线请求处理：</p><p>这个阶段是用户与系统实时交互的过程，追求低延迟和高精度。</p><ol><li><strong>意图分析 (Intention Analysis)</strong>：<ul><li>请求的入口。当用户输入一句话，系统首先要理解“他想干什么”。</li><li>这不仅仅是关键词识别，更深层次会判断用户意图，例如：是闲聊（Chitchat）？是问答（FAQ）？还是需要执行一个任务（Task-oriented）？</li><li>意图分析的结果会决定后续调用哪些检索路径。比如，闲聊意图可能直接交给大语言模型，而问答意图则会触发后续的召回和排序流程。</li></ul></li><li><strong>多路召回 (Multi-path Recall)</strong>：<ul><li>这是为了“宁可错杀，不可放过”，尽可能多地从不同渠道找回所有相关的候选答案。各路召回并行执行，以保证效率。</li><li><strong>向量召回（语义召回）</strong>：将用户的查询也进行向量化，然后去向量数据库里进行相似度检索，找出语义上最接近的N个文本块。这是您提到的“向量检索”的应用环节。</li><li><strong>关键词召回（词法召回）</strong>：使用传统搜索引擎（如Elasticsearch）根据关键词匹配，找出包含查询词的文本块。这能弥补向量召回在精确匹配上的不足。</li><li><strong>其他召回</strong>：还可能包括基于知识图谱的召回、基于数据库精确查询的召回等。</li></ul></li><li><strong>混合排序 (Hybrid Ranking/Re-ranking)</strong>：<ul><li>多路召回会返回大量候选结果，质量良莠不齐，甚至有重复。排序阶段就是优中选优的过程。</li><li><strong>粗排 (Coarse Ranking)</strong>：首先，通过一些简单的规则和模型，对召回的上百个结果进行快速排序和去重，筛选出Top K（比如Top 50）个候选结果。</li><li><strong>精排 (Fine-grained Ranking / Re-ranking)</strong>：然后，使用一个更复杂、更强大的排序模型（通常是Cross-Encoder或专门的排序大模型），对这Top K个结果进行精准打分。这个模型会综合考虑查询与候选答案的语义相关性、业务重要性、时效性等多种特征，给出最终的、最合理的排序。</li></ul></li><li><strong>答案生成与整合 (Answer Generation &amp; Synthesis)</strong>：<ul><li>最后，系统会将排序最高的一个或几个结果，作为核心上下文，连同用户的原始问题，一起组织成一个精炼的提示词（Prompt）。</li><li>将这个Prompt提交给一个强大的生成式大语言模型（如GPT-4），由它基于给定的上下文，生成最终的、通顺自然的回答，并呈现给用户。</li></ul></li></ol><h2 id="3-Dify是什么？怎么使用？"><a href="#3-Dify是什么？怎么使用？" class="headerlink" title="3.Dify是什么？怎么使用？"></a>3.Dify是什么？怎么使用？</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>1.为什么选择Dify?</p><ul><li><strong>从效率和速度角度看：</strong> 对于需要快速验证原型（MVP）或业务逻辑不那么极端的项目，我会首选Dify。因为它将RAG、多模型支持、API封装等通用能力产品化了，可以让我们在几天甚至几小时内就搭建起一个可用的AI应用，极大地缩短了Time-to-Market（产品上市时间）。</li><li><strong>从维护成本角度看：</strong> Dify提供了一个完整的后台管理界面，包括日志、监控和用户反馈。这意味着运营人员或产品经理也可以参与到应用的优化中来，例如更新知识库、标注数据等。如果自研，这部分工作都需要开发人员投入精力去构建和维护，长期成本更高。</li><li><strong>对于自定义和灵活性：</strong> 当然，如果项目需求非常特殊，比如需要一个高度定制化的RAG策略（例如复杂的混合检索和重排逻辑），或者对系统性能有极致要求，那么基于LangChain或LlamaIndex自研会提供更高的灵活性和控制力。</li></ul><p>2.Dify的Agent和Tool（工具）能力是如何工作的？它与传统的API调用有什么不同？</p><p>Dify的Agent和Tool能力，是实现<strong>Language Model as a Reasoning Engine（将语言模型作为推理引擎）</strong>的关键。它和传统API调用的核心区别在于<strong>‘决策者’不同</strong>。</p><ul><li><strong>传统API调用</strong>：是我们开发者在代码里<strong>提前写好逻辑</strong>。比如，<code>if</code>用户想查天气，<code>then</code>调用天气API。这个决策逻辑是<strong>由人预先编码</strong>的。</li><li><strong>Dify中的Agent/Tool工作流</strong>:</li></ul><ol><li><strong>工具注册</strong>：我们首先向Dify注册一个或多个工具，比如“天气查询API”、“计算器API”。关键在于，我们需要用自然语言<strong>向模型清晰地描述这个工具是做什么的、需要哪些参数</strong>（比如，天气查询API需要一个<code>city</code>参数）。</li><li><strong>模型决策 (Reasoning)</strong>：当用户提出一个模糊的需求，比如“帮我查查明天北京会不会下雨，适合穿什么？”，Agent接收到请求后，大模型会进行“思考”。</li><li><strong>工具选择与调用</strong>：模型会分析用户的意图，并根据我们提供的工具描述，<strong>自主决定</strong>需要使用“天气查询API”。然后，它会从用户问题中<strong>提取出参数</strong><code>city: &quot;北京&quot;</code>，并生成一个调用该API的请求。</li><li><strong>结果整合与响应</strong>：模型获取到API返回的天气数据后（比如“晴天”），会将其作为新的信息，结合它自己的知识（晴天适合穿什么），最终生成一段通顺的、完整的回答给用户。</li></ol><p>Dify的Agent模式，把<strong>‘决定调用哪个API’以及‘如何组织参数’的权力，从开发者交给了大模型</strong>，实现了更高层次的自动化和智能化。”</p><p>3.如果让你来设计一个类似Dify的平台，你会如何规划它的技术架构？</p><p>设计一个类似Dify的平台，我会将其拆分为几个核心模块，并采用微服务的思想来构建，确保可扩展性和可维护性</p><ol><li><strong>前端 (Frontend)</strong>：<ul><li>使用React或Vue等现代前端框架，负责提供所有可视化的操作界面，包括应用管理、Prompt Studio、知识库上传和运营后台等。</li></ul></li><li><strong>API网关 (API Gateway)</strong>：<ul><li>作为所有服务的统一入口，处理用户认证、请求路由、速率限制等。这是外部应用（比如用户的前端）与我们平台交互的门户。</li></ul></li><li><strong>应用编排服务 (Orchestration Service)</strong>：<ul><li>这是平台的大脑。它负责解释在Studio中保存的应用配置。当一个API请求进来时，这个服务会根据应用定义，决定是走简单的LLM对话流程，还是需要执行RAG或Agent流程。它会编排并调用下游的各个服务。</li></ul></li><li><strong>模型管理服务 (Model Management Service)</strong>：<ul><li>用于统一管理和对接不同的大模型提供商（OpenAI, Anthropic, Google Gemini, 以及开源模型）。它会封装好各家API的差异，对上层提供一个统一的调用接口。</li></ul></li><li><strong>RAG服务 (RAG Service)</strong>：<ul><li>这是一个独立的模块，负责知识库的全生命周期管理。</li><li><strong>写入路径</strong>：接收文档 -&gt; 文本解析 -&gt; 分块 (Chunking) -&gt; 调用Embedding模型 -&gt; 存入向量数据库。</li><li><strong>读取路径</strong>：接收查询 -&gt; 向量化 -&gt; 在向量数据库中进行相似性搜索 -&gt; 返回相关文本块。</li><li><strong>技术选型</strong>：会用到向量数据库（如Milvus/Weaviate）和Embedding模型。</li></ul></li><li><strong>日志与监控服务 (Logging &amp; Monitoring Service)</strong>：<ul><li>专门收集所有API调用的日志、Token消耗、用户反馈等数据。</li><li>将数据存入专门的数据库（如ClickHouse或Elasticsearch），并提供数据可视化界面，用于运营分析和应用优化。</li></ul></li></ol><h2 id="4-那么怎么区分使用简单模型还是使用agent呢？"><a href="#4-那么怎么区分使用简单模型还是使用agent呢？" class="headerlink" title="4.那么怎么区分使用简单模型还是使用agent呢？"></a>4.那么怎么区分使用简单模型还是使用agent呢？</h2><p>可以使用前置规则与关键词匹配 ，比如系统会维护一个“触发词”列表。当用户的输入包含这些特定的动词或名词时，系统会<strong>绕过复杂的判断</strong>，直接将其路由到Agent流程。</p><p>或者是利用大语言模型进行意图分类 ，我们设计一个专门用于“路由”的<strong>元提示 (Meta-Prompt)</strong>。这个Prompt会包含以下内容：</p><ol><li><strong>用户的原始问题</strong>。</li><li><strong>一个“选项列表”</strong>，这个列表描述了所有可用的“路径”。每个路径就是一个Agent或工具，外加一个“默认闲聊”的选项。</li><li><strong>一个明确的指令</strong>，要求LLM根据用户问题，从列表中选择一个最合适的路径。</li></ol><p>非常智能和灵活，能理解深层语义。这是目前最主流和最有效的方法。现代LLM的“Function Calling”或“Tool Use”功能，本质上就是这种机制的高度优化和内置实现。</p><p>或者是结合上下文进行动态判断，系统在做意图判断时，不仅考虑当前这一句，还会<strong>附加上下文（最近的几轮对话历史）</strong>。</p><p>我在这个项目中主要用的是，<strong>分层漏斗模型</strong></p><ol><li><strong>首先，通过一个‘快速通道’进行前置判断</strong>。我们会用关键词和规则匹配，快速识别出那些意图非常明确的请求，比如包含‘查询’、‘计算’、‘预订’等词语的指令，直接将它们路由给相应的Agent。这能覆盖掉一部分简单明确的任务，且成本最低。</li><li><strong>其次，对于无法被快速通道处理的请求，我们会启用一个‘智能路由’层</strong>。这一层的核心是利用大语言模型自身的理解能力。我们会设计一个专门的‘路由Prompt’，把用户的请求和所有可用的‘工具’（Agents）以及一个‘闲聊’选项一起发给LLM，让模型来判断用户最可能的意图是什么。比如，模型需要从‘查询天气’、‘检查订单’和‘普通聊天’这几个选项里做出选择。这是目前最主流也最可靠的方式。</li><li><strong>最后，在多轮对话中，我们会引入上下文进行动态判断</strong>。用户的意图可能不会在第一句话就完全暴露。因此，在做意图识别时，系统会结合最近的对话历史。比如用户先说了‘我想去北京’，接着问‘那边天气如何？’，系统就能结合上下文，准确地将这个模糊的问题路由到‘天气查询Agent’。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/new-stack/springai2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>开源项目经历</title>
      <link>https://blog.tokenlen.top/2025/07/15/doc/kaiyuan/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/doc/kaiyuan/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;Github&quot;&gt;&lt;a href=&quot;#Github&quot; class=&quot;headerlink&quot; title=&quot;Github&quot;&gt;&lt;/a&gt;Github&lt;/h1&gt;&lt;h2 id=&quot;close&quot;&gt;&lt;a href=&quot;#close&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>1.</p><p>2025.7.15晚上十点，提交了我人生中的第一个PR，</p><p>是阿里巴巴的<a href="https://github.com/alibaba/fastjson2/项目。">https://github.com/alibaba/fastjson2/项目。</a></p><p>看到一个issue没有人哈哈，我直接在vscode跑了一下，然后发现是</p><p>在 Android 10 的系统中，<br>com.alibaba.fastjson2.util.IOUtils.isNULL(IOUtils.java:2)<br>会产生一个 native 侧的 crash，Signal 7(SIGBUS), Code 1(BUS_ADRALN)出现了问题</p><p>我发现是内存对齐问题: 在 Android 10 ARM 架构上，IOUtils.getLongUnaligned(char[] buf, int offset) 方法直接使用 UNSAFE.getLong() 访问 char 数组内存，ARM 处理器要求 8 字节 long 读取必须在 8 字节对齐的地址上进行，当计算出的内存地址 ARRAY_CHAR_BASE_OFFSET + ((long) offset &lt;&lt; 1) 不是 8 字节对齐时，触发 Signal 7(SIGBUS), Code 1(BUS_ADRALN) 崩溃<br>我已经提交PR<a href="https://github.com/[/pull/3639](https://github.com/alibaba/fastjson2/pull/3639">https://github.com/[/pull/3639](https://github.com/alibaba/fastjson2/pull/3639</a>)</p><p>然后直接进行测试，测试的三个类全部通过。overall</p><p>看看对不对，能不能给我合并了吧哈哈，好了睡觉舒服了，该PR已经解决</p><p>然后后来根据我的代码发布了一个快照，然后我测试完之后发现成功！他采纳了我的建议</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>1.</p><p>2025.7.16八点左右</p><p>提交了我的第三个PR，是rocketMQ的。也是到知名中间件的issue了哈哈</p><p>这个问题是一个时序问题，一个topic被创建的时候，队列为null,最大偏移量为0<br>然后生产者发送第一条消息的时候，最大偏移量为1。<br>消费者启动的时候，查询最大偏移量为-1，然后调用maxoffset(mq),就会返回1.这样我们为0的消息就被跳过了。<br>可以在发送消息前，可以先启动 Consumer 实例，或者在 Consumer 启动后等待一段时间再发送消息。<br>然后在配置的时候，设置从ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET开始消费。<br>也可以在代码方面更改再前面加一层校验，如果maxoffset&lt;=1的话，就返回0L</p><p>然后else就返回maxoffset</p><p>maxoffset=this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</p><p><a href="https://github.com/apache/rocketmq/pull/9552">https://github.com/apache/rocketmq/pull/9552</a></p><p>然后发现这个issue很久没解决了哈哈，看看我的能不能被通过吧</p><p>3.</p><p>2025.7.28</p><p>这次还是springaialibaba</p><p>调用mcp工具，调用了能有全链路的traceid，串联不了链路</p><ul><li>实现了 <code>McpTraceExchangeFilterFunction</code>，用于在 HTTP 请求中自动注入 traceId、spanId 等分布式链路追踪相关 header，支持 Micrometer Tracing。</li><li>通过 Spring Boot 自动配置（<code>McpTracingAutoConfiguration</code>），自动装配 tracing filter，无需手动配置，提升易用性。</li><li><strong>客户端传输层支持 tracing filter 注入</strong></li><li>让 MCP 客户端具备分布式链路追踪能力，方便排查问题和性能分析。</li></ul><p><a href="https://github.com/alibaba/spring-ai-alibaba/pull/1837">https://github.com/alibaba/spring-ai-alibaba/pull/1837</a></p><h2 id="merged"><a href="#merged" class="headerlink" title="merged"></a>merged</h2><p>1.</p><p>2025.7.16中午头，提交了我的第二个PR</p><p>这个PR是<a href="https://github.com/alibaba/spring-ai-alibaba/">https://github.com/alibaba/spring-ai-alibaba/</a> 仓库的， <a href="https://github.com/alibaba/spring-ai-alibaba/pull/1645">https://github.com/alibaba/spring-ai-alibaba/pull/1645</a></p><p>是解决了一个人的issue，node枚举字段里面没有template-transform他非要调用，肯定是失败的啊</p><p>然后我就在枚举类里添加了template-transform节点，然后写了一个NodeData类和一个NodeDataConverter类</p><p>NodeData就设置一下setter和getter，然后Conventer就是一个<strong>模板转换节点数据转换器</strong> 的 Java 类，属于阿里云 AI 服务中工作流 DSL 处理模块</p><p>实现了实现了<code>TemplateTransformNodeDataConverter</code>转换器类</p><ul><li>继承抽象Converter类</li><li><strong>DIFY方言</strong>: 完整的解析和导出逻辑</li><li><strong>CUSTOM方言</strong>: 使用默认自定义方言转换器</li><li><strong>输入处理</strong>: 变量选择器解析</li><li><strong>输出管理</strong>: 固定string类型结果</li><li><strong>变量命名</strong>: <code>templateTransformNode&#123;count&#125;</code>格式</li><li><strong>后处理</strong>: 自动设置输出键名</li></ul><p>然后添加其node节点的具体实现， 实现了完整的模板转换功能:</p><ul><li><strong>占位符模式</strong>: 支持<code>&#123;&#123;key&#125;&#125;</code>语法</li><li><strong>正则引擎</strong>: 使用<code>\\&#123;\\&#123;\\s*(.+?)\\s*\\&#125;\\&#125;</code>匹配</li><li><strong>高效处理</strong>: StringBuffer + Matcher进行字符串替换</li><li><strong>安全机制</strong>: 自动转义特殊字符防止正则注入</li><li><strong>容错设计</strong>: 缺失变量时保留原占位符，不中断执行</li><li><strong>状态管理</strong>: 正确使用<code>state.data().containsKey(key)</code>检查变量存在性</li></ul><p>在代码生成层实现了nodesection</p><ul><li>实现了<code>TemplateTransformNodeSection</code>代码生成器</li><li>完整的Builder模式实现，支持流式配置</li><li>提供了完善的错误处理和SLF4J日志记录</li></ul><p>然后通过了他的CI测试，其中代码格转为spring的格式和头信息,java格式化卡了我一点时间，没注意格式的问题。</p><p>然后通过全部的lint测试</p><p>2.</p><p>2025.7.22完事八点，继续干spring ai alibaba</p><p>这次主要是修复了一个空指针异常，DashScope API返回数据质量问题，ToolCall对象的function.name字段为null。在buildGeneration方法中，Toolcall对象的时候，这里如果toolCall.function().name()返回null，就会导致后续Spring AI框架在DefaultToolCallingManager.executeToolCall中执行toolName.equals()(时出现NPE。导致streaming 和 non-streaming 聊天调用都受影响。可以添加null过滤器，然后记录日志。这是防御性编程的经典模式，添加空值过滤。</p><p>然后我们就添加了两个null的校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ToolCall&gt; validToolCalls = toolCalls.stream()</span><br><span class="line">    .filter(toolCall -&gt; toolCall.function() != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">                        toolCall.function().name() != <span class="literal">null</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>解决了一个issue <a href="https://github.com/alibaba/spring-ai-alibaba/pull/1766">https://github.com/alibaba/spring-ai-alibaba/pull/1766</a></p><p>3.</p><p>2025.7.23 下午</p><p>今天修复了还是我们熟悉的fastjson2的一个小issue</p><p>因为他jsonfactory设定的内存的最大阈值时2048.然后我看他们反馈实际应用的是比这要打的</p><p>那么我们就可以去自己去设定这一个max值。但是这样内存太大的话，又会出现oom问题。不知道怎么处理</p><p><a href="https://github.com/alibaba/fastjson2/pull/3658">https://github.com/alibaba/fastjson2/pull/3658</a></p><p>4.</p><p>fastjson2的一个版本兼容的问题，但是他的checkstyle格式实在是改不过来我吐。我就用的main函数来直接测试了</p><p>添加了判断方法和set方法，<strong>字段默认值类型转换</strong> </p><p>然后默认值的实际类型与目标字段类型不匹配开始，当启用兼容模式时，对于 <code>String → Date</code> 的转换进行特殊处理</p><ul><li><code>isJSONFieldDefaultValueCompatMode()</code>: 检查是否启用 FastJSON 1.x 兼容模式</li><li><code>defaultValue instanceof String</code>: 默认值是字符串类型</li><li><code>Date.class.isAssignableFrom(fieldClass)</code>: 目标字段是 Date 类型或其子类</li></ul><p><a href="https://github.com/alibaba/fastjson2/pull/3661">https://github.com/alibaba/fastjson2/pull/3661</a></p><p>算了，不做了我吐</p><p>5.</p><p>又是一个fastjson2的项目的pr,这次主要是修复了fastjson2在处理set list等集合的解析的问题，他们在反序列化的时候会出现问题。然后不同编码使用不同的读取方式</p><p>让他们在操作的时候直接进行byte的操作，如果是set的化就进行特殊处理+去重</p><p><a href="https://github.com/alibaba/fastjson2/pull/3701">https://github.com/alibaba/fastjson2/pull/3701</a></p><p>7.</p><p>2025.7.28</p><p>这次还是springaialibaba</p><p>调用mcp工具，调用了能有全链路的traceid，串联不了链路</p><ul><li>实现了 <code>McpTraceExchangeFilterFunction</code>，用于在 HTTP 请求中自动注入 traceId、spanId 等分布式链路追踪相关 header，支持 Micrometer Tracing。</li><li>通过 Spring Boot 自动配置（<code>McpTracingAutoConfiguration</code>），自动装配 tracing filter，无需手动配置，提升易用性。</li><li><strong>客户端传输层支持 tracing filter 注入</strong></li><li>让 MCP 客户端具备分布式链路追踪能力，方便排查问题和性能分析。</li></ul><p><a href="https://github.com/alibaba/spring-ai-alibaba/pull/1837">https://github.com/alibaba/spring-ai-alibaba/pull/1837</a></p><p>8.</p><p>还是spring ai alibaba</p><p>Spring AI Alibaba Graph模块中<strong>Tool节点</strong>与<strong>Dify平台</strong>集成时的<strong>属性映射问题</strong>。原有的ToolNodeData只支持基础的tool相关属性，无法完整支持Dify平台的丰富工具配置。</p><p>添加更多的属性的setter 和getter和处理属性的数组，和属性映射之间的关系</p><p><a href="https://github.com/alibaba/spring-ai-alibaba/pull/1948">https://github.com/alibaba/spring-ai-alibaba/pull/1948</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Github/">Github</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/doc/kaiyuan/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis面试hot-高并发/高级玩法部分</title>
      <link>https://blog.tokenlen.top/2025/07/15/java-stack/redis3/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/java-stack/redis3/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;redis的高并发和高可用&quot;&gt;&lt;a href=&quot;#redis的高并发和高可用&quot; class=&quot;headerlink&quot; title=&quot;redis的高并发和高可用&quot;&gt;&lt;/a&gt;redis的高并发和高可用&lt;/h1&gt;&lt;p&gt;如何用 redis 来加多台机器，保证 redis</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="redis的高并发和高可用"><a href="#redis的高并发和高可用" class="headerlink" title="redis的高并发和高可用"></a>redis的高并发和高可用</h1><p>如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。</p><p>redis 实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><p>redis的主从架构就是读写分离，一主多从。</p><p>主节点负责写，其他的从节点负责读</p><p>其中重要的就是数据的一致性的问题，就是数据的replication。我们采用了主从架构的时候，必须开启持久化</p><ul><li>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li><li>slave并不会过期key，master的key过期了，会模拟一条del命令发送给slave</li><li>无磁盘复制，master 在内存中直接创建 <code>RDB</code> ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</li></ul><hr><p>主从复制的核心：就是增量复制和全量复制</p><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。这个就是增量复制。</p><p>那么我们怎么确定是增量复制还是全量复制呢，如果复制的过程中中断了怎么办？</p><p>Redis2.8 开始就支持断点传输了。</p><p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> 。</p><p>那么我们增量复制的时候，主节点的backlog_buffer里面存储我们最近的数据，然后跟从节点的slave_reolica_buffer进行对比，根据差值来进行全量复制还是增量复制。</p><p>但是这个缓冲区默认的是1M，我们可以增大这个缓冲区</p><p>打开 <code>redis.conf</code> 文件，找到repl-backlog-size，然后修改值即可。</p><hr><p>复制的流程：</p><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><p>全量复制：</p><ul><li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li><li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li><li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li><li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure><ul><li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中。注意，在清空旧数据之前，slave node 依然会<strong>基于旧的数据版本</strong>对外提供服务。</li><li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li></ul><p>增量复制：</p><ul><li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li><li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li><li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li></ul><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>一般的我们的持久化机制就是</p><p>RDB，AOF ，RDB-AOF</p><p>持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 Redis 整个挂了，然后 Redis 就不可用了，你要做的事情就是让 Redis 变得可用，尽快变得可用。</p><ul><li>RDB：RDB 持久化机制，是对 Redis 中的数据执行<strong>周期性</strong>的持久化。</li><li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li></ul><p>RDB:</p><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 Redis 中的数据。</li><li>RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis <strong>保持高性能</strong>，因为 Redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 Redis 进程，更加快速。</li><li>如果想要在 Redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟（甚至更长时间）的数据。</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><p>AOF:</p><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 <code>fsync</code> 操作，最多丢失 1 秒钟的数据。</li><li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li><li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li><li>AOF 日志文件的命令通过可读较强的方式进行记录，这个特性非常<strong>适合做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code> ，性能也还是很高的。（如果实时写入，那么 QPS 会大降，Redis 性能会大大降低）</li><li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 <code>merge</code> 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是<strong>基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好很多。</li></ul><p>他们都是有优缺点的，我们可以使用RDB-AOF混合的模式</p><p>当然appendonly yes也是要启动AOF的，然后一般我们选择<strong><code>appendfsync everysec</code></strong> 配置 AOF 的同步策略为每秒一次</p><p> 在 <code>redis.conf</code> 文件中，找到aof-use-rdb-preamble yes</p><p>这意味着当 AOF 进行 <code>rewrite</code> （重写）时，会使用 RDB 格式的数据作为 AOF 文件的前置内容，然后才是增量的 AOF 命令。  这能大大缩短 Redis 重启时加载 AOF 文件的速度。</p><p>然后重启redis，使配置生效</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p></li><li><p>哨兵至少需要 3 个实例，来保证自己的健壮性。按照需求设置配置 <code>quorum=</code></p></li></ul><hr><p>哨兵在让redis node进行主备切换的时候可能会出现数据丢失的问题</p><p>异步复制导致的数据丢失：</p><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p><p>脑裂问题导致的数据丢失:</p><p>脑裂，也就是说，某个 master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会<strong>认为</strong> master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong>。</p><p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p><p>解决：：</p><p>进行如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p><p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。</p><ul><li>减少异步复制数据的丢失</li></ul><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p><ul><li>减少脑裂的数据丢失</li></ul><p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p><hr><p>自动发现机制：</p><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步。</p><p>选举算法：</p><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><p>configuration epoch：</p><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>一般我们使用的使redis原生的集群，Redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><p>介绍：</p><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><p>节点之间的通信：</p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p><p>Redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p><ul><li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code> 。</li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li></ul><hr><p>gossip协议：</p><p>gossip 协议包含多种消息，包含 <code>ping</code> , <code>pong</code> , <code>meet</code> , <code>fail</code> 等等。</p><ul><li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-trib.rb add-node</span><br></pre></td></tr></table></figure><p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</li><li>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。</li><li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</li></ul><p>ping:</p><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p><p>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息。</p><hr><p>分布式寻址算法：</p><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul><p>hash：</p><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><p>一致性hash：</p><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><p>Redis cluster 的 hash slot 算法:</p><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/redis/">redis</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/java-stack/redis3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cache缓存</title>
      <link>https://blog.tokenlen.top/2025/07/14/new-stack/cache1/</link>
      <guid>https://blog.tokenlen.top/2025/07/14/new-stack/cache1/</guid>
      <pubDate>Sun, 13 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>1.为什么要用缓存？</p><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p><p>就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。</p><p>缓存功能简单，说白了就是 <code>key-value</code> 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p><hr><p>如果按照我们存储的位置来分的话，缓存分为：</p><p>本地缓存，访问速度最快的，一般我们查数据的时候，首先查的就是本地缓存，比如Caffeine, Guava Cache, Ehcache </p><p>分布式缓存，容量更大，多个应用之间可以i将那些共享数据，比如Redis, Memcached, Hazelcast</p><p>客户端缓存，缓存数据存储在客户端，比如浏览器缓存，app缓存等等</p><p>CDN缓存，缓存静态资源在离用户较近的 CDN 节点上，常用于加速访问的速度</p><p>数据库缓存，数据库自身提供的缓存机制, 用于缓存查询结果，比如mysql就有缓存机制</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>1.Redis 和 Memcached 有啥区别？</p><ol><li>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， Redis 会是不错的选择。</li><li>在 Redis3.x 版本中，便能支持 cluster 模式，而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li><li>由于 Redis 只使用<strong>单核</strong>，而 Memcached 可以使用<strong>多核</strong>，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li></ol><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">50万写入:耗时:ms</th><th style="text-align:left">50写+50读(读全命中):耗时:ms</th><th style="text-align:left">50万写+50万读(全命中)+50万读(未命中)：耗时:ms</th><th style="text-align:left">50万读+50万未命中</th></tr></thead><tbody><tr><td style="text-align:left">Guava</td><td style="text-align:left">329/340/326/328/328</td><td style="text-align:left">536/518/546/525/558</td><td style="text-align:left">647/646/638/668/641</td><td style="text-align:left">490/501/482/485/492</td></tr><tr><td style="text-align:left">Caffeine</td><td style="text-align:left">292/284/270/279/267</td><td style="text-align:left">414/382/353/385/361</td><td style="text-align:left">479/513/460/487/481</td><td style="text-align:left">343/326/333/336/369</td></tr><tr><td style="text-align:left">Ohc</td><td style="text-align:left">448/433/430/446/442</td><td style="text-align:left">763/748/765/741/705</td><td style="text-align:left">918/947/901/964/903</td><td style="text-align:left">653/676/607/639/704</td></tr><tr><td style="text-align:left">Ohc-Obj</td><td style="text-align:left">1343/1315/1217/1249/1193</td><td style="text-align:left">1910/1830/1849/1803/1786</td><td style="text-align:left">1979/1965/1947/1968/1946</td><td style="text-align:left">1487/1573/1499/1491/1483</td></tr></tbody></table></div><p>我们一般使用的时候就使用Caffeine就足够了</p><p>Caffeine 的核心设计目标是提供具有高命中率和低延迟的缓存。 其架构主要由以下几个关键组件组成：</p><ul><li><strong>ConcurrentMap:</strong>  Caffeine 实现了 <code>ConcurrentMap</code> 接口，这意味着它是线程安全的。 底层使用分段锁或无锁数据结构来支持并发访问。</li><li><strong>CacheLoader (可选):</strong> 用于在缓存未命中时自动加载值。 可以自定义实现 <code>CacheLoader</code> 接口， 定义加载数据的逻辑.</li><li><strong>CacheWriter (可选):</strong>  用于处理缓存的写入和删除操作。 可以自定义实现 <code>CacheWriter</code> 接口，定义写入和移除缓存条目的逻辑。</li><li><strong>驱逐策略 (Eviction Policies):</strong>  Caffeine 采用基于 <em>最逼近最优</em>  (Approaching Optimal) 的驱逐算法，包括TinyLFU 和 Window-TinyLFU。<ul><li><strong>TinyLFU (Tiny Least Frequently Used):</strong> 一个频率sketch， 用于估算每个条目的访问频率。 占用了极小的内存空间，但能提供接近最佳的频率估算。</li><li><strong>Window-TinyLFU:</strong> 一个结合了最近访问（Windowed LFU）和频率信息（TinyLFU）的二级缓存结构。最近访问的数据保存在一个小的”窗口”中，而更长时间内的数据则通过TinyLFU来估算访问频率.</li></ul></li><li><strong>刷新策略 (Refresh):</strong> 支持异步地刷新缓存条目，从而保持缓存数据的新鲜度。</li><li><strong>写入策略 (Write):</strong> 支持同步或异步地将缓存条目写入到持久层（例如数据库）。</li><li><strong>监听器 (Listeners):</strong> 允许注册监听器，以便在缓存条目被添加、更新或移除时执行自定义的逻辑。</li></ul><p>优点：</p><ul><li><strong>接近最优的命中率：</strong> Caffeine 使用了非常先进的驱逐算法，能够更好地保留热点数据，从而提高命中率。</li><li><strong>低延迟：</strong> Caffeine 针对低延迟进行了优化，尽可能减少锁竞争，提高并发访问性能。</li><li><strong>自动加载：</strong> 通过 <code>CacheLoader</code> 可以在缓存未命中时自动加载数据，简化了缓存的使用。</li><li><strong>异步刷新：</strong> 异步刷新能够保持缓存数据的新鲜度，同时避免阻塞主线程。</li><li><strong>灵活的配置：</strong> Caffeine 提供了丰富的配置选项，可以根据不同的需求进行定制。</li><li><strong>轻量级：</strong> Caffeine 依赖少，体积小，易于集成到项目中。</li></ul><hr><p>使用</p><p>手动加载:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; manualCache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>))  <span class="comment">// 10 秒后过期</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)                         <span class="comment">// 最大容量 100</span></span><br><span class="line">                .removalListener((String key, String value, com.github.benmanes.caffeine.cache.RemovalCause cause) -&gt;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause)) <span class="comment">//移除监听器</span></span><br><span class="line">                .build();</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>自动加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; loadingCache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .expireAfterWrite(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">               .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)  <span class="comment">// 定时刷新</span></span><br><span class="line">               .build(key -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 在这里实现加载数据的逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Loading value for key: &quot;</span> + key);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&quot;value for &quot;</span> + key;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>异步加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String,String&gt; asyncLoadingCache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                .expireAfterWrite(<span class="number">5</span>,TimeUnit.MINUTES)</span><br><span class="line">                .buildAsync(key -&gt; &#123;</span><br><span class="line">                    <span class="comment">//在这里实现异步加载数据的逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Async Loading value for key :&quot;</span> + key);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Async value for &quot;</span> + key;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><h1 id="使用缓存会导致的问题"><a href="#使用缓存会导致的问题" class="headerlink" title="使用缓存会导致的问题"></a>使用缓存会导致的问题</h1><h2 id="数据的一致性问题"><a href="#数据的一致性问题" class="headerlink" title="数据的一致性问题"></a>数据的一致性问题</h2><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><p>为什么是删除缓存？</p><p>在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。可能是一个多表查询的运算的结果。其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><p>1.先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><ul><li>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</li><li>延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。</li></ul><p>2.数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><p>设计：</p><ul><li><strong>读请求:</strong> 优先从缓存读取。 如果缓存未命中，则发起缓存更新请求（放入队列），并同步等待一段时间。 如果等待超时，则直接读取数据库（返回旧数据）。</li><li><strong>写请求:</strong> 首先删除缓存，然后更新数据库。 更新数据库的操作也放入队列中串行执行。</li><li><strong>队列:</strong> 每个数据项（例如商品 ID）维护一个专属的 JVM 内部队列。</li><li><strong>工作线程:</strong> 每个队列对应一个工作线程，负责串行执行队列中的更新操作（先更新数据库，后更新缓存）。</li><li><strong>路由:</strong> 基于数据唯一标识（例如商品 ID）进行路由，确保对同一数据项的读写请求都会路由到相同的队列和工作线程。</li></ul><p>问题：</p><p>1.队列积压：<em>务必设置读请求的超时时间，保证请求及时返回。**加队列的数量，将数据分散到不同的队列中，减少每个队列的积压。</em></p><p>或者是如果是热点数据搞得，我们可以拆分热点数据和普通数据</p><p>2.单个热点数据过热，<em>预先识别热点数据，并将其分散到不同的队列中。 可以采用更精细的哈希算法，或者人工配置的方式。</em>，人工限流降级，在服务器内部使用二级缓存。</p><p>3.路由实例间得路由不一致，<em>使用一致性哈希算法，确保对同一数据项的请求始终路由到相同的服务实例。</em>或者使用nginx进行代理</p><p>一看这样我们可以直接引入kafka来解决啊</p><div class="table-container"><table><thead><tr><th>特性</th><th>JVM 内部队列</th><th>Kafka</th></tr></thead><tbody><tr><td>解耦程度</td><td>有限，读写服务在同一 JVM 中</td><td>更彻底，读写服务完全解耦</td></tr><tr><td>扩展性</td><td>受单机 JVM 限制</td><td>高，可以通过增加分区和消费者实例来提高吞吐量</td></tr><tr><td>可靠性</td><td>较低，消息容易丢失</td><td>高，消息持久化和消息重放机制</td></tr><tr><td>容错性</td><td>差，单点故障</td><td>好，集群容错</td></tr><tr><td>复杂度</td><td>低，易于实现</td><td>高，需要配置和维护 Kafka 集群</td></tr><tr><td>延迟</td><td>低，JVM 内部通信</td><td>较高，消息需要经过网络传输</td></tr><tr><td>一致性保证</td><td>容易实现简单的一致性</td><td>需要考虑事务和消息顺序性</td></tr></tbody></table></div><h2 id="缓存三兄弟"><a href="#缓存三兄弟" class="headerlink" title="缓存三兄弟"></a>缓存三兄弟</h2><p>缓存三兄弟就是我们常说的的缓存击穿，缓存穿透，缓存雪崩。</p><hr><p>缓存雪崩，是指短时间内有大量key过期，然后一下子压力全到数据库上面去了。</p><p>预防：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。</p><p>处理：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p><p>事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p><p>在代码上的话，我们可以使用互斥锁，只有获得了锁才能去访问。如果是过期时间的问题，采取热点数据永不过期，设置随机的过期时间等等。</p><p>如果是太多请求的话，我们可以限流，或者降级。</p><p>缓存穿透：</p><p>就是很多个缓存查不到的请求，数据库也查不到的请求发过来了</p><p>我们可以采用空值的方式,每次系统  从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code> 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><p>或者是我们使用布隆过滤器，过滤我们数据库没有的请求。</p><p>缓存击穿:</p><p>就是一瞬间热点key直接失效了，大量的请求就击穿了缓存，直接请求数据库。</p><ul><li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li><li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li><li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li></ul><h2 id="缓存并发竞争"><a href="#缓存并发竞争" class="headerlink" title="缓存并发竞争"></a>缓存并发竞争</h2><p>Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？</p><p>就是<strong>多客户端同时并发写</strong>一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p><p>比如：</p><ul><li><strong>库存扣减：</strong> 多个客户端同时购买同一商品，导致库存超卖。</li><li><strong>计数器更新：</strong> 多个客户端同时增加计数器的值，导致计数器结果不准确。</li><li><strong>排行榜更新：</strong> 多个客户端同时更新排行榜数据，导致排行榜数据不一致。</li></ul><p>1.单线程架构,Redis 本身是单线程架构，这意味着 Redis 命令是顺序执行的，避免了多线程并发问题。 但是，单线程架构并不能完全解决并发竞争问题。 例如，多个客户端同时发送 <code>INCR</code> 命令来增加计数器的值，Redis 仍然可能因为网络延迟等原因导致计数器结果不准确。</p><p>2.原子操作，Redis 提供了许多原子操作，例如 <code>INCR</code>、<code>DECR</code>、<code>SETNX</code> 等。 原子操作可以保证操作的完整性，避免并发竞争问题。 例如，可以使用 <code>INCR</code> 命令来原子地增加计数器的值。</p><p>3.Lua脚本，可以将多个 Redis 命令组合成一个 Lua 脚本，然后使用 <code>EVAL</code> 命令来原子地执行该脚本。 Lua 脚本可以保证多个命令的原子性，避免并发竞争问题。 例如，可以使用 Lua 脚本来实现原子性的库存扣减操作。</p><p>4.CAS，Redis 提供了 <code>WATCH</code> 命令来实现乐观锁。 乐观锁允许多个客户端同时读取同一个 Key 的值，但是在更新 Key 的值之前，需要先检查该 Key 的值是否被其他客户端修改过。 如果被修改过，则更新失败，需要重新尝试。</p><ul><li>如果被 <code>WATCH</code> 监视的 Key 在事务执行期间被其他客户端修改过，那么 <code>EXEC</code> 命令会返回 <code>nil</code>，表示事务执行失败。</li><li>如果被 <code>WATCH</code> 监视的 Key 在事务执行期间没有被其他客户端修改过，那么 <code>EXEC</code> 命令会执行事务中的所有命令，并返回执行结果。</li></ul><p>5.分布式锁，redission?保证同一时间只有一个客户端可以访问共享资源。</p><p>可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p><p>你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。</p><p>每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/Cache/">Cache</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/14/new-stack/cache1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试题目2</title>
      <link>https://blog.tokenlen.top/2025/07/06/leetcode/leetcodehot2/</link>
      <guid>https://blog.tokenlen.top/2025/07/06/leetcode/leetcodehot2/</guid>
      <pubDate>Sat, 05 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;面试二轮&quot;&gt;&lt;a href=&quot;#面试二轮&quot; class=&quot;headerlink&quot; title=&quot;面试二轮&quot;&gt;&lt;/a&gt;面试二轮&lt;/h1&gt;&lt;h2 id=&quot;76-最小覆盖子串-x&quot;&gt;&lt;a href=&quot;#76-最小覆盖子串-x&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="面试二轮"><a href="#面试二轮" class="headerlink" title="面试二轮"></a>面试二轮</h1><h2 id="76-最小覆盖子串-x"><a href="#76-最小覆盖子串-x" class="headerlink" title="76. 最小覆盖子串(x)"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>(x)</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">minWindow</span>(<span class="params"><span class="built_in">String</span> S, <span class="built_in">String</span> t</span>) &#123;</span><br><span class="line">        int[] cnt = <span class="keyword">new</span> int[<span class="number">128</span>];</span><br><span class="line">        int less = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (char <span class="attr">c</span>:t.<span class="title function_">toCharArray</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                less++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] s = S.<span class="title function_">toCharArray</span>();</span><br><span class="line">        int m  = s.<span class="property">length</span>;</span><br><span class="line">        int ansleft  = -<span class="number">1</span>;</span><br><span class="line">        int ansRight = m;</span><br><span class="line">        </span><br><span class="line">        int left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int right = <span class="number">0</span>;right&lt;m;right++)&#123;</span><br><span class="line">            char c =s[right];</span><br><span class="line">            cnt[c]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                less--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (right-left&lt;ansRight-ansleft)&#123;</span><br><span class="line">                    ansleft = left;</span><br><span class="line">                    ansRight = right;</span><br><span class="line">                &#125;</span><br><span class="line">                char x = s[left];</span><br><span class="line">                <span class="keyword">if</span> (cnt[x]==<span class="number">0</span>)&#123;</span><br><span class="line">                    less++;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[x]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansleft&lt;<span class="number">0</span>?<span class="string">&quot;&quot;</span>:S.<span class="title function_">substring</span>(ansleft,ansRight+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码使用了滑动窗口的方法，一看他是个window就是滑动窗口</p><p>解决思路是进-改-出</p><p>先区遍历元素，然后确定要出现的最少的次数</p><p>然后进右端端点，需要的出现次数—</p><p>然后最少字母次数—</p><p>当最小次数为0的时候，这个时候如果滑动窗口的长度小于结果的长度的时候</p><p>更新节点位置</p><p>然后出左节点，如果需要出现的为0了</p><p>那么最少字母次数++</p><p>然后左端点对应的字母需要次数++，左端点移动</p><p>最后需要的是结果左端点和右端点之间的</p><p>也就是我们常说的right-left+1</p><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>就是一个贪心算法，我们每一步都选dfs的最优解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution124A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lval</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rval</span>  <span class="operator">=</span>dfs(root.right);</span><br><span class="line">        ans  = Math.max(ans,lval+rval+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(lval,rval)+ root.val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选左还是选右的问题</p><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><p><strong><a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p>前缀树就是记录字符串用的，一个放孩子孩子节点的字母表，一个放是不是结束的标志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Node[] son = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:word.toCharArray())&#123;</span><br><span class="line">            c -=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.son[c]==<span class="literal">null</span>)&#123;</span><br><span class="line">                cur.son[c] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(word)==<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(prefix)!=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:word.toCharArray())&#123;</span><br><span class="line">            c-=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.son[c]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder()</code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code> 以内的答案将被接受。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-105 &lt;= num &lt;= 105</code></li><li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素</li><li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size()==right.size())&#123;</span><br><span class="line">            right.offer(num);</span><br><span class="line">            left.offer(right.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left.offer(num);</span><br><span class="line">            right.offer(left.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left.size()&gt;right.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> left.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们维护一个最大堆left和一个最小堆right</p><p>加元素的时候，如果当前左右数量相等的话，那么优先加入最小堆，然后把最小堆的栈顶给左堆</p><p>不想等的话，一般是最大堆需要，然后小的栈顶给最小堆</p><p>取中位数的时候，如果是偶数，那么是最大堆和最小堆顶的平均值</p><p>不是的话就是最大堆的顶</p><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>看到这种括号题目，第一个想到就是使用栈来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution32AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> vaild[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;(&#x27;</span>) stack.push(i);</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;)&#x27;</span>&amp;&amp;!stack.isEmpty())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                vaild[i] = <span class="literal">true</span>;</span><br><span class="line">                vaild[index]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;vaild.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vaild[i])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res,count);</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,count);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用栈，记录一个有效值的数字。</p><p>然后遍历字符找到有效括号</p><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution141A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常easy的环形链表</p><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution72A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] t=  text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[] f= <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            f[j+<span class="number">1</span>] = j+<span class="number">1</span>;<span class="comment">//text2 的前 j + 1 个字符所需的操作数为 j + 1 (即插入 j + 1 个字符)。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> f[<span class="number">0</span>];</span><br><span class="line">            f[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span>f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x ==t[j]?pre:Math.min(Math.min(f[j+<span class="number">1</span>],f[j]),pre)+<span class="number">1</span>;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>text1</code> 的当前字符 <code>x</code> 与 <code>text2</code> 的当前字符 <code>t[j]</code> 相同，那么不需要任何操作</p><ul><li></li><li><code>f[j + 1]</code>: 表示删除 <code>text1</code> 的当前字符 <code>x</code>。对应于操作”删除”。</li><li><p><code>f[j]</code>: 表示在 <code>text1</code> 中插入一个字符，使得 <code>text1</code> 的当前字符等于 <code>t[j]</code>。对应于操作”插入”。</p></li><li><p><code>pre</code>: 表示将 <code>text1</code> 的当前字符 <code>x</code> 替换为 <code>t[j]</code>。对应于操作”替换”。 由于需要经过一次编辑(删除/插入/替换)才能让<code>text1</code>前<code>i</code>个字符匹配<code>text2</code>前<code>j+1</code>个字符，所以操作总数要+1。</p></li></ul><h2 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前K个高频单词</a></h2><p>给定一个单词列表 <code>words</code> 和一个整数 <code>k</code> ，返回前 <code>k</code> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p><p>一看到这个题，我就想到用hashmap来做，然后我看又需要顺序，那我直接使用linkedhashmap不久得了。发现并不是的</p><p>可以使用优先队列，或者是规定compare的List，这里直接用优先队列吧</p><p>然后挑出前k个</p><p>放入list即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution692</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (w1,w2)-&gt;map.get(w1).equals(map.get(w2))?w2.compareTo(w1):map.get(w1)-map.get(w2)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String word:map.keySet())&#123;</span><br><span class="line">            queue.offer(word);</span><br><span class="line">            <span class="keyword">if</span> (queue.size()&gt;k)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            res.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p>又是不重复，直接上hashset,一开始想这样做来，但发现不对，这样做的是字符串的数量</p><p>然后就想使用滑动窗口，更新值。如果含有就更新左端点，</p><p>不含有就更新最大值，然后放入右端点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(right))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(right)));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(right), right);</span><br><span class="line">            maxlen = Math.max(maxlen, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution394A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span>  <span class="variable">curSting</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack_multi=  <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character c:s.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.isDigit(c))&#123;</span><br><span class="line">                    num = num*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack_multi.push(num);</span><br><span class="line">                    stack.push(curSting);</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    curSting = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">longnum</span> <span class="operator">=</span> stack_multi.pop();</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack.pop());</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;longnum;i++)&#123;</span><br><span class="line">                        temp.append(curSting);</span><br><span class="line">                    &#125;</span><br><span class="line">                    curSting=  temp.toString();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    curSting +=c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> curSting;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经典的括号和栈的问题</p><p>一个放之前的字符，一个放数字。当变成】结束的时候。将里面的字符遍历数字遍</p><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution82AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next!=<span class="literal">null</span>&amp;&amp;cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.next.val == val)&#123;</span><br><span class="line">                <span class="keyword">while</span> (cur.next!=<span class="literal">null</span>&amp;&amp;cur.next.val == val)&#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是去检测cur.next和cur和cur.next之后的值是不是想到，想到就只留cur，然后其他的跳过</p><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p>可以使用hash表+定长的滑动窗口试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//简单去重</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//最小的都大，直接抛弃</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[n - <span class="number">3</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//最大的都小直接抛弃</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="comment">//简单去重</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="comment">//最小的三个都大，抛弃</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="comment">//最大的三个都小抛弃</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;<span class="comment">//找出左右边界</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution40A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,target,candidates,ans,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> left,<span class="type">int</span>[] candidates,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;candidates.length&amp;&amp;candidates[j]&lt;=left;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;i&amp;&amp;candidates.length==candidates[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[j]);</span><br><span class="line">            dfs(j+<span class="number">1</span>,left-candidates[j],candidates,ans,path);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选与不选的问题，如果j&gt;i且等与j的数都不选</p><p>记得回溯哈</p><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p>就是类似于一个加法的计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStringsA</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        String ans= <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(turn(num1)+turn(num2));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">turn</span><span class="params">(String nums)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=nums.length();i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans +=(i-<span class="number">1</span>)*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        StringBuilder res= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length()-<span class="number">1</span>,j=num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span>  <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            res.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a><a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></h2><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution946</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;stack.peek()==popped[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的模拟栈运行的操作</p><p>当前栈的栈顶的数，如果是pop序列中的第i个的话，就说明这次成功，然后i++;</p><p>最后如果栈为空了，也就是所有的都符合，返回true</p><h2 id="146-LRU-缓存-x"><a href="#146-LRU-缓存-x" class="headerlink" title="146. LRU 缓存(x)"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a>(x)</h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCacheAA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key,vaule;</span><br><span class="line">        Node prev,next;</span><br><span class="line">        Node(<span class="type">int</span> k,<span class="type">int</span> v)&#123;</span><br><span class="line">            key = k;</span><br><span class="line">            vaule = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; keyToNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCacheAA</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        dummy.prev = dummy;</span><br><span class="line">        dummy.next = dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(key);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="literal">null</span>?node.vaule:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(key);</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            node.vaule = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">        keyToNode.put(key,node);</span><br><span class="line">        pushFront(node);</span><br><span class="line">        <span class="keyword">if</span> (keyToNode.size()&gt;capacity)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">backNode</span> <span class="operator">=</span> dummy.prev;</span><br><span class="line">            keyToNode.remove(backNode.key);</span><br><span class="line">            remove(backNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushFront</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        x.prev = dummy;</span><br><span class="line">        x.next = dummy.next;</span><br><span class="line">        x.prev.next = x;</span><br><span class="line">        x.next.prev = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyToNode.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> keyToNode.get(key);</span><br><span class="line">        remove(node);</span><br><span class="line">        pushFront(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是实现了按LRU缓存的策略，主要使用的双向链表和hash表来解决的</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">。</span><br></pre></td></tr></table></figure><p>快速的时候hashmap来进行查询</p><p>如果是更多的话，可以参考固定一个，然后移动另外一个</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution88AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> m-<span class="number">1</span>,len2=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len1&gt;=<span class="number">0</span>&amp;&amp;len2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[len--] = nums1[len1]&gt;nums2[len2]?nums1[len1--]:nums2[len2--];</span><br><span class="line">        &#125;</span><br><span class="line">       System.arraycopy(nums2,<span class="number">0</span>,nums1,<span class="number">0</span>,len2+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的排序，就是从后面开始遍历，看谁大就行了</p><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>这里就用到了反转链表的知识，我们先找到链表的中点，然后将链表一分为二，然后反转后面的链表，然后再合并两个链表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution143B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> middle(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> reverseList(mid);</span><br><span class="line">        <span class="keyword">while</span> (head2.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next2</span> <span class="operator">=</span> head2.next;</span><br><span class="line">            head.next = head2;</span><br><span class="line">            head2.next = next;</span><br><span class="line">            head = next;</span><br><span class="line">            head2 = next2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre=  cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span>head,fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h2><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1&quot; -&gt; &#x27;A&#x27; &quot;2&quot; -&gt; &#x27;B&#x27; ... &quot;25&quot; -&gt; &#x27;Y&#x27; &quot;26&quot; -&gt; &#x27;Z&#x27;</span><br></pre></td></tr></table></figure><p>然而，在 <strong>解码</strong> 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（<code>&quot;2&quot;</code> 和 <code>&quot;5&quot;</code> 与 <code>&quot;25&quot;</code>）。</p><p>例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1, 1, 10, 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11, 10, 6)</code></li><li>消息不能分组为 <code>(1, 11, 06)</code> ，因为 <code>&quot;06&quot;</code> 不是一个合法编码（只有 “6” 是合法的）。</li></ul><p>注意，可能存在无法解码的字符串。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。如果没有合法的方式解码整个字符串，返回 <code>0</code>。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution91AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s=  <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i] = f[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i]+=f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个简单的动态规划</p><p>就只有俩选择，如果是1-9之内的就说明是a,也就是选择前面的一个就够了</p><p>如果是10-26之内，就说明要前面的两个才行</p><p>如果都可以的话，这俩都要。所以是+=f[i-2]</p><p>转移 <code>f[i]</code> 时只依赖 <code>f[i-1]</code> 和 <code>f[i-2]</code> 两个状态。</p><p>可以采用与「滚动数组」类似的思路，只创建长度为 3 的数组，通过取余的方式来复用不再需要的下标。进行一波优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution91AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s=  <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i] = f[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i]+=f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodingsA</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[]f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>]  =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i%<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i%<span class="number">3</span>] = f[(i-<span class="number">1</span>)%<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i%<span class="number">3</span>] +=f[(i-<span class="number">2</span>)%<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution215</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈哈两行直接解决，虽然不是最合适的。</p><h2 id="25-K-个一组翻转链表（x暂时有点懵逼啊）"><a href="#25-K-个一组翻转链表（x暂时有点懵逼啊）" class="headerlink" title="25. K 个一组翻转链表（x暂时有点懵逼啊）"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>（x暂时有点懵逼啊）</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution215</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25AAa</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//统计节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur!=<span class="literal">null</span>;cur = cur.next)&#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span>  <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;n&gt;=k;n-=k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span>cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> p0.next;</span><br><span class="line">            p0.next.next = cur;</span><br><span class="line">            p0.next = pre;</span><br><span class="line">            p0 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先按k个数字分开好几组，然后k个数字的内部就是简单的交换</p><p>然后外部的话，p0=dummy</p><p>ListNode next = p0.next;下一部分的起始节点</p><p>p0.next.next = cur，下一部分的起点。</p><p>p0.next = pre;真起点</p><p>p0 = next往下移动，将 <code>p0</code> 移动到下一组待翻转节点的前面。</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>;k&lt;nums.length-<span class="number">2</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> i=k+<span class="number">1</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k]+nums[i]+nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[++i]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[--j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k],nums[i],nums[j])));</span><br><span class="line">                    i++;j--;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟前面的四个组合是用的一样的方法，就是双指针，从头开始，然后去遍历，确定最大的和最小的，然后在里面去寻找。</p><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution53B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minpresum</span> <span class="operator">=</span> <span class="number">0</span>,presum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            presum +=x;</span><br><span class="line">            ans = Math.max(ans,presum-minpresum);</span><br><span class="line">            minpresum = Math.min(minpresum,presum);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护一个最大值和一个最小值，最大值就是和-小的。</p><p>可以扩展为乘法，最大值可能就是最小值乘出来的</p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution21B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list2==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">           list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁的使用递归直接完成</p><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (s==<span class="literal">null</span>||s.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">strlen</span> <span class="operator">=</span> s.length();</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxStart</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="type">boolean</span>[][] dp  =<span class="keyword">new</span> <span class="title class_">boolean</span>[strlen][strlen];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> r= <span class="number">1</span>;r&lt;strlen;r++)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l&lt;r;l++)&#123;</span><br><span class="line">             <span class="keyword">if</span> (s.charAt(l)==s.charAt(r)&amp;&amp;(r-l&lt;=<span class="number">2</span>||dp[l+<span class="number">1</span>][r-<span class="number">1</span>]))&#123;</span><br><span class="line">                 dp[l][r] = <span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">if</span> (r-l+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                     maxLen = r-l+<span class="number">1</span>;</span><br><span class="line">                     maxStart = l;</span><br><span class="line">                     maxEnd = r;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> s.substring(maxStart,maxEnd+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用 动态规划来完成，</p><p>(r-1&lt;=2||dp l+1 r-1这个很好玩成了这个</p><p>如果r-l&lt;=2的话，就说明就一个数 了，肯定是回文。就是基数的时候</p><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution102B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为他是层序遍历，遍历完这一层才进行下一次遍历。所以我们要把这一层的节点全都放进队列。</p><p>然后一个一个取出来，记录值。然后再左右的去遍历</p><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[n-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span>  <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target&lt;=end&amp;&amp;nums[mid]&gt;end)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target&gt;end&amp;&amp;nums[mid]&lt;=end)&#123;</span><br><span class="line">                right =mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left]!=target?-<span class="number">1</span>:left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一看到这个时间复杂度，我们第一时间想到的就是我们最喜欢的二分查找哈哈。</p><p>然后一看到这个旋转数组，我们肯定要关注最后一个数字，因为就是从他这旋转的</p><p>然后有三种大情况</p><p>目标值小于最后一个数，中位大于最后一个数，也就是说目标值在右边，中位在左。我们移动left指针到mid+1</p><p>然后都在一遍的话，就是普通的二分查找了</p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>看到这个题，一个矩阵，直接进行遍历，就可以了。如果是求最大面积的话，再加上动态规划即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution200B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid ,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=grid.length||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] =<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>看到这种排列的题目，首先想到的就是回溯法+dfs哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution46</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="built_in">this</span>.nums.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span>  <span class="operator">=</span> nums.get(a);</span><br><span class="line">        nums.set(a,nums.get(b));</span><br><span class="line">        nums.set(b,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x== nums.size()-<span class="number">1</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;nums.size();i++)&#123;</span><br><span class="line">            swap(i,x);</span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            swap(i,x);<span class="comment">//这就是回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是固定一位，然后去移动他后面的位置。</p><p>然后移动完，再给他恢复。这就是回溯算法的所在</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution20AB</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>||c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;)&#x27;</span>||c==<span class="string">&#x27;]&#x27;</span>||c==<span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) || (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看到这个题目我就知道要使用栈，之前的哪些题都是差不多的</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution121B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE,profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price:prices)&#123;</span><br><span class="line">            cost = Math.min(cost,price);</span><br><span class="line">            profit = Math.max(profit,price-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较easy的一道题目了</p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution236B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span>lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是比较简单的一道递归题目</p><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp  =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) queue.add(node.right); </span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是一个达到锯齿状层序遍历的目的，普通的层序遍历直接使用一个队列就ok</p><p>现在的如果现在比如我们里面的是奇数的话，就说明当前是偶数层，从右到左开始遍历，就是往前面加，</p><p>如果是偶数的话，就从左往右开始遍历，就是往后面开始加</p><p>一个层一个List<Interger></p><h2 id="手撕快速排序-x"><a href="#手撕快速排序-x" class="headerlink" title="手撕快速排序(x)"></a>手撕快速排序(x)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">OptimizedQuickSort</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] sortArry(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (right-left+<span class="number">1</span>&lt;=INSERTION_SORT_THRESHOLD)&#123;</span><br><span class="line">            insertionSort(nums,left,right);<span class="comment">//小数字使用插入排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pivots = partition3Way(nums,left,right);</span><br><span class="line">        quickSort(nums,left,pivots[<span class="number">0</span>]-<span class="number">1</span>);<span class="comment">//只递归小于的部分</span></span><br><span class="line">        quickSort(nums,pivots[<span class="number">1</span>]+<span class="number">1</span>,right);<span class="comment">//只递归大于的部分</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i!=j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j]  = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span>  <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=left&amp;&amp;nums[j]&gt;key)&#123;</span><br><span class="line">                nums[j+<span class="number">1</span>]  = nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] partition3Way(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left+random.nextInt(right-left+<span class="number">1</span>);</span><br><span class="line">        swap(nums,left,randomIndex);<span class="comment">//一个随机值，交换left和随机值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span>right +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;gt)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;pivot)&#123;<span class="comment">//小于pivot放入左区域</span></span><br><span class="line">                swap(nums,++lt,i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&gt;pivot)&#123;<span class="comment">//放入右区域</span></span><br><span class="line">                swap(nums,--gt,i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;<span class="comment">//只需要移动指针即可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,left,lt);<span class="comment">//最后交换回来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;lt,gt-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p>使用头插法真的得劲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution92B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">g</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;step&lt;left-<span class="number">1</span>;step++)&#123;</span><br><span class="line">            g = g.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">removed</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next  = g.next;</span><br><span class="line">            g.next =removed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先设一个虚拟节点，这样的话，就不用考虑边界值的问题了</p><p>然后g指针式left前面的</p><p>p指针指向left节点</p><p>然后我们这样把指针移动到该有的位置</p><p>然后反转的时候要反转的是right-left个节点</p><p>然后我们从把他们使用头插相继的插入到g节点的后面，因为g节点不动，动的是p节点。头插的话，先插的就在后面了。实现 了反转的效果</p><p>这样的就完成了。</p><h2 id="141-环形链表-1"><a href="#141-环形链表-1" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution141B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span>  <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是经典快慢节点完成哈哈</p><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution54B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        Integer[] ans = <span class="keyword">new</span> <span class="title class_">Integer</span>[(r+<span class="number">1</span>)*(b+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=l;i&lt;=r;i++) ans[x++]  = matrix[t][i];</span><br><span class="line">            <span class="keyword">if</span>(++t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=t;i&lt;=b;i++) ans[x++] = matrix[i][r];</span><br><span class="line">            <span class="keyword">if</span> (l&gt;--r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r;i&gt;=l;i--) ans[x++] = matrix[b][i];</span><br><span class="line">            <span class="keyword">if</span> (t&gt;--b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=b;i&gt;=t;i--) ans[x++]  = matrix[i][l];</span><br><span class="line">            <span class="keyword">if</span> (++l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是设定好边界值只会然后进行遍历即可</p><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution300B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的动态规划，如果相等就+1，然后统计数量</p><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);</span><br><span class="line">        <span class="keyword">for</span> (ListNode head:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(head);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用最小堆，因为每个链表之中的head肯定是最小的</p><p>那我们就一直遍历里面的head，然后放入最小堆，然后将最小堆里面的取出来，放进我们的新的链表</p><p>可以加上dummy哨兵节点</p><h2 id="415-字符串相加-1"><a href="#415-字符串相加-1" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p>经典计算器类型的题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> i=num1.length()-<span class="number">1</span>,j = num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            sb.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) sb.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这种的题目都要使用StringBuilder这一个单线程的</p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution56B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>]-q[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span>ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是按头上第一个排序之后，然后看最后面1的位置的数，是不是小于下一个的头上的数，小于的话，就可以合并</p><p>然后更新新的值</p><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution160B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        ListNode pA= headA;</span><br><span class="line">        ListNode pB=  headB;</span><br><span class="line">        <span class="keyword">while</span> (pA!=pB)&#123;</span><br><span class="line">            pA = (pA==<span class="literal">null</span>)?headB:pA.next;</span><br><span class="line">            pB = (pB==<span class="literal">null</span>) ?headA:pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是有公共部分的，如果我们其中一个遍历完之后，再从另一个链表的起点继续遍历</p><p>等他们相遇的时候，就是我们需要的那个交点</p><h2 id="42-接雨水-x"><a href="#42-接雨水-x" class="headerlink" title="42. 接雨水(x)"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>(x)</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left= <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> <span class="number">0</span>,sufMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(preMax,height[left]);</span><br><span class="line">            sufMax = Math.max(sufMax,height[right]);</span><br><span class="line">            ans +=preMax&lt;sufMax?preMax-height[left++]:sufMax-height[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双指针谁小就移动谁，算是1D接雨水的最优解</p><p>2D接雨水</p><p>转换为了矩阵，但还是之前使用的木桶效应。</p><p>我们可以从这个最矮的方块出发，向其内部（上下左右）相邻的、未访问过的方块进行探索：</p><ul><li>如果相邻的方块 <code>(nr, nc)</code> 比 <code>h</code> 还矮，说明水可以把它淹没。这个方块能接的水量就是 <code>h - height[nr][nc]</code>。然后将这个方块也视为新的海岸线（因为它现在是水能到达的边界了），其有效高度是<code>h</code>（因为水是从<code>h</code>处漫灌过来的），把它加入我们的“海岸线”集合。</li><li>如果相邻的方块比 <code>h</code> 高，它自己就成了一堵新墙，无法积水。但它也成为了新的边界，需要加入“海岸线”集合。</li></ul><p>看到这个我们就要用我们的优先队列，也就是最小堆了，不断更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution407</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] DIRS = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapRainWater</span><span class="params">(<span class="type">int</span>[][] heightMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heightMap==<span class="literal">null</span>||heightMap.length&lt;=<span class="number">2</span>||heightMap[<span class="number">0</span>].length&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> heightMap.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span>  <span class="operator">=</span> heightMap[<span class="number">0</span>].length;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>||i==rows-<span class="number">1</span>||j==<span class="number">0</span>||j==cols-<span class="number">1</span>)&#123;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;heightMap[i][j],i,j&#125;);</span><br><span class="line">                    heightMap[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] t = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span> t[<span class="number">0</span>],i=t[<span class="number">1</span>],j=t[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] d:DIRS)&#123;</span><br><span class="line">                <span class="type">int</span> x= i+d[<span class="number">0</span>],y = j+d[<span class="number">1</span>];<span class="comment">//i,j的邻居</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; rows &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; cols &amp;&amp; heightMap[x][y] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    ans +=Math.max(minHeight-heightMap[x][y],<span class="number">0</span>);</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Math.max(minHeight, heightMap[x][y]), x, y&#125;);</span><br><span class="line">                    heightMap[x][y] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列-x"><a href="#1143-最长公共子序列-x" class="headerlink" title="1143. 最长公共子序列(x)"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a>(x)</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[]f = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x==t[j]?pre+<span class="number">1</span>:Math.max(f[j+<span class="number">1</span>],f[j]);</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用动态规划，这种的题目一般都是使用动态规划或者使用滑动窗口进行解决的</p><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution93B&#123;</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        int n  = s.length();</span><br><span class="line">        List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i =1;i&lt;n&amp;&amp;isvalid(s,0,i);i++)&#123;</span><br><span class="line">            for (int j=i+1;j&lt;n&amp;&amp;isvalid(s,i,j);j++)&#123;</span><br><span class="line">                for (int k =j+1;k&lt;n&amp;&amp;isvalid(s,j,k);k++)&#123;</span><br><span class="line">                    if (isvalid(s,k,n))&#123;</span><br><span class="line">                        ans.add(String.format(&quot;%s.%s.%s.%s&quot;,s.substring(0,i),s.substring(i,j),s.substring(j,k),s.substring(k)</span><br><span class="line">                                ));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isvalid(String s,int i,int j)&#123;</span><br><span class="line">        if (j-i&gt;3||j-i&gt;1&amp;&amp;s.charAt(i)==&#x27;0&#x27;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return Integer.parseInt(s.substring(i,j))&lt;=255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是相当于将这一串数分割成4段，我们需要切三次，然后这里面的每一个都要符合ip的定义就可以</p><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head,slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="literal">null</span>||fast.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是我们第一次循环之后，如果这个适合fast节点空了，就说明是没有环了</p><p>然后我们进行第二次循环，fast从头开始，然后继续遍历。我们下一次fast和slow相遇的节点就是我们需要的环的开始的节点</p><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution19AA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummy,right = dummy;</span><br><span class="line">        <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = left.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法非常的巧妙，就是一把尺子，右节点先走n步，然后两个节点一块走，右节点走到头的适合，左节点就是我们需要的倒数第n个节点的前一个节点。</p><p>然后跳过该节点就Ok</p><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>一看到 这个熟悉的时间复杂度，就知道了我们应该使用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">        <span class="comment">//确保num1是较短的数组</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length&gt;nums2.length)&#123;</span><br><span class="line">            <span class="type">int</span>[] tmp  = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">//哨兵值</span></span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">0</span>] = b[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        a[m+<span class="number">1</span>] = b[n+<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        System.arraycopy(nums1,<span class="number">0</span>,a,<span class="number">1</span>,m);</span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,b,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = m;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m+n+<span class="number">1</span>)/<span class="number">2</span>-i;<span class="comment">//总的</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]&lt;=b[j+<span class="number">1</span>]&amp;&amp;b[j]&lt;=a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> Math.max(a[i],b[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">min2</span> <span class="operator">=</span>Math.min(a[i+<span class="number">1</span>],b[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> (m+n)%<span class="number">2</span>&gt;<span class="number">0</span>?max1:(max1+min2)/<span class="number">2.0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[i]&gt;b[j+<span class="number">1</span>])&#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i是我们变得，j是我们合起来得中间的数</p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution199A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth==ans.size())&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>,ans);</span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右视图就是我们当前的深度等于我们的ans里面的数目的时候就是。</p><p>然后递归即可</p><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution94B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,ans);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        dfs(root.right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归中序遍历</p><h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><p>给你两个 <strong>版本号字符串</strong> <code>version1</code> 和 <code>version2</code> ，请你比较它们。版本号由被点 <code>&#39;.&#39;</code> 分开的修订号组成。<strong>修订号的值</strong> 是它 <strong>转换为整数</strong> 并忽略前导零。</p><p>比较版本号时，请按 <strong>从左到右的顺序</strong> 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 <code>0</code>。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution165A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> version1.length(),m = version2.length();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n||j&lt;m)&#123;</span><br><span class="line">            <span class="type">int</span> num1=<span class="number">0</span>,num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n&amp;&amp;version1.charAt(i)!=<span class="string">&#x27;.&#x27;</span>) num1 = num1*<span class="number">10</span>+version1.charAt(i++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;m&amp;&amp;version2.charAt(j)!=<span class="string">&#x27;.&#x27;</span>) num2 =num2*<span class="number">10</span>+version2.charAt(j++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num1&lt;num2)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            i++;j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把字符串转换为数字然后进行比较。.前面是一部分，后面是一部分</p><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果 <code>target</code> 存在返回下标，否则返回 <code>-1</code>。</p><p>你必须编写一个具有 <code>O(log n)</code> 时间复杂度的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution704B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right  = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意边界的问题</p><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueueAB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueueAB</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> peek();</span><br><span class="line">        B.pop();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.peek();</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            B.push(A.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.isEmpty()&amp;&amp;B.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单的一道题目，就是我们使用两个栈来完成队列的先进先出的实现</p><p>一个栈A，一个栈B</p><p>我们进队列的时候先进入A栈，然后将A栈的元素，逐个放入B栈，我们从B栈里面pop元素，这样的话，就是按照顺序出栈的</p><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution148AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> middle(head);</span><br><span class="line">        head = sortList(head);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line">        <span class="keyword">return</span> mergeTowLists(head,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head )</span>&#123;</span><br><span class="line">        ListNode pre=  head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTowLists</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="literal">null</span>&amp;&amp;list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val&lt;list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1  = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1!=<span class="literal">null</span>?list1:list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个题目类似于第k个反转链表的那个题目。都是先找中点，这个只不过是直接排序了</p><p>那个还有一个反转的操作</p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution22B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] path = <span class="keyword">new</span> <span class="title class_">char</span>[n*<span class="number">2</span>];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,n,path,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n,<span class="type">char</span>[] path,List&lt;String&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right==n)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;n)&#123;</span><br><span class="line">            path[left+right] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(left+<span class="number">1</span>,right,n,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right&lt;left)&#123;</span><br><span class="line">            path[left+right] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(left,right+<span class="number">1</span>,n,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>left代表左括号的，right代表右括号。使用选与不选的方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/06/leetcode/leetcodehot2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MQ面试场景题</title>
      <link>https://blog.tokenlen.top/2025/07/06/new-stack/MQ2/</link>
      <guid>https://blog.tokenlen.top/2025/07/06/new-stack/MQ2/</guid>
      <pubDate>Sat, 05 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;场景题&quot;&gt;&lt;a href=&quot;#场景题&quot; class=&quot;headerlink&quot; title=&quot;场景题&quot;&gt;&lt;/a&gt;场景题&lt;/h1&gt;&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="1-如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#1-如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="1.如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>1.如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h2><p>问题分析：</p><p>1.大量的消息在MQ里积压了</p><p>2.MQ中的消息过期失效了</p><p>3.MQ的队列快满了</p><p>第一个问题：</p><p>消息在MQ大量积压是消费者和生成者生产消费的速度差距过大</p><p>消费者消费的少，生产者生产的多</p><p>那么我们就先修复消费者的问题，确保消费者都能使用</p><p>然后紧急扩容，新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</p><p>写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</p><p>临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</p><p>然后恢复原先的架构</p><p>或者是业务支持批量发送的时候，使用批量发送</p><p>或者是跳过非重要的消息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">            ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> msgs.get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxOffset</span> <span class="operator">=</span></span><br><span class="line">            msgs.get(<span class="number">0</span>).getProperty(Message.PROPERTY_MAX_OFFSET);</span><br><span class="line">    <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> Long.parseLong(maxOffset) - offset;</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="comment">// TODO 消息堆积情况的特殊处理</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 正常消费过程</span></span><br><span class="line">    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者优化消息的处理步骤，比如需要查两次，写两次，可以合并为查/写一次完成</p><p>第二个问题：</p><p>RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。</p><p>我们丢了大量的数据，没办法，我们只能等队列比较少的时候。人工的去找出少了哪些数据，然后人工恢复数据</p><p>我们可以先访问RabbitMQ 自带的管理界面提供队列长度、消息速率等基本监控信息</p><p>默认端口15672，查看目标队列的 “Messages ready” (就绪消息数量) 和 “Messages unacknowledged” (未确认消息数量)。 如果 “Messages ready” 持续增长，说明队列存在积压。</p><p>第三个问题：</p><p>mq快写满了，我们可以直接丢弃，然后再补数据了只能</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/06/new-stack/MQ2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Elasticsearch</title>
      <link>https://blog.tokenlen.top/2025/07/06/new-stack/es1/</link>
      <guid>https://blog.tokenlen.top/2025/07/06/new-stack/es1/</guid>
      <pubDate>Sat, 05 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。&lt;/p&gt;
&lt;p&gt;单个</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p><p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p><p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p><p>下面的命令可以查看当前节点的所有 Index。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://localhost:9200/_cat/indices?v&#x27;</span><br></pre></td></tr></table></figure><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p><p>Document 使用 JSON 格式表示，下面是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">  <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p><p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p><p>下面的命令可以列出每个 Index 所包含的 Type。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/_mapping?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫<code>weather</code>的 Index。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>服务器返回一个 JSON 对象，里面的<code>acknowledged</code>字段表示操作成功。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;shards_acknowledged&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>然后，我们发出 DELETE 请求，删除这个 Index。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>需要指定中文分词器，不能使用默认的英文分词器。</p><p>Elastic 的分词器称为 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html">analyzer</a>。我们对每个字段指定分词器。</p><hr><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>新增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &#x27;localhost:9200/accounts/person/1&#x27; -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;数据库管理&quot;</span><br><span class="line">&#125;&#x27; </span><br></pre></td></tr></table></figure><p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X POST &#x27;localhost:9200/accounts/person&#x27; -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;李四&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;系统管理&quot;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><p>不进行指定的话<code>_id</code>字段就是一个随机字符串。</p><p>查询：</p><p>向<code>/Index/Type/Id</code>发出 GET 请求，就可以查看这条记录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/1?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>删除：</p><p>删除记录就是发出 DELETE 请求。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>这里先不要删除这条记录，后面还要用到。</p><p>更新：</p><p>更新记录就是使用 PUT 请求，重新发送一次数据。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;user&quot; : &quot;张三&quot;,</span></span><br><span class="line"><span class="string">    &quot;title&quot; : &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:2,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:2,<span class="string">&quot;successful&quot;</span>:1,<span class="string">&quot;failed&quot;</span>:0&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>返回所有记录：</p><p>使用 GET 方法，直接请求<code>/Index/Type/_search</code>，就会返回所有记录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>全文搜索：</p><p>Elastic 的查询非常特别，使用自己的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html">查询语法</a>，要求 GET 请求带有数据体。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>指定的匹配条件是<code>desc</code>字段里面包含”软件”这个词。返回结果如下。</p><p>Elastic 默认一次返回10条结果，可以通过<code>size</code>字段改变这个设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>还可以通过<code>from</code>字段，指定位移。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;from&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p><p>如果有多个搜索关键字， Elastic 认为它们是<code>or</code>关系。</p><p>如果要执行多个关键词的<code>and</code>搜索，必须使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-bool-query.html">布尔查询</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;bool&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;must&quot;: [</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;,</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Java中使用"><a href="#Java中使用" class="headerlink" title="Java中使用"></a>Java中使用</h1><p>首先需要在 <code>pom.xml</code> 文件中添加 Elasticsearch 和 Jackson 的依赖：</p><p>创建客户端，在Config类里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient</span><br><span class="line">  .builder(HttpHost.create(<span class="string">&quot;http://localhost:9200&quot;</span>))</span><br><span class="line">  .build();</span><br><span class="line"><span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"><span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>索引文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="string">&quot;Mark Doe&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1471466076564L</span>));</span><br><span class="line"><span class="type">IndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.index(i -&gt; i</span><br><span class="line">  .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">  .id(person.getFullName())</span><br><span class="line">  .document(person));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">searchText</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">SearchResponse&lt;Person&gt; searchResponse = client.search(s -&gt; s</span><br><span class="line">  .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">  .query(q -&gt; q</span><br><span class="line">    .match(t -&gt; t</span><br><span class="line">      .field(<span class="string">&quot;fullName&quot;</span>)</span><br><span class="line">      .query(searchText))), Person.class);</span><br><span class="line"></span><br><span class="line">List&lt;Hit&lt;Person&gt;&gt; hits = searchResponse.hits().hits();</span><br><span class="line">assertEquals(<span class="number">1</span>, hits.size());</span><br><span class="line">assertEquals(<span class="string">&quot;John Doe&quot;</span>, hits.get(<span class="number">0</span>).source().getFullName());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模糊匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">fuzzyQuery</span> <span class="operator">=</span> FuzzyQuery.of(f -&gt; f</span><br><span class="line">    .field(<span class="string">&quot;fullName&quot;</span>)</span><br><span class="line">    .value(searchText)</span><br><span class="line">    .fuzziness(<span class="string">&quot;AUTO&quot;</span>))._toQuery();</span><br><span class="line"></span><br><span class="line">SearchResponse&lt;Person&gt; searchResponse = client.search(s -&gt; s</span><br><span class="line">    .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .query(q -&gt; q.bool(b -&gt; b.must(fuzzyQuery))), Person.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>fuzziness</code> 参数控制允许的编辑距离，可以设置为整数值或者 “AUTO”，后者会根据搜索词的长度自动调整</p><p>布尔查询:组合 <code>match</code> 查询（用于精确匹配）和 <code>fuzzy</code> 查询（用于模糊匹配）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">matchQuery</span> <span class="operator">=</span> MatchQuery.of(m -&gt; m.field(<span class="string">&quot;fullName&quot;</span>).query(searchText))._toQuery();</span><br><span class="line"><span class="type">Query</span> <span class="variable">fuzzyQuery</span> <span class="operator">=</span> FuzzyQuery.of(f -&gt; f</span><br><span class="line">    .field(<span class="string">&quot;fullName&quot;</span>)</span><br><span class="line">    .value(searchText)</span><br><span class="line">    .fuzziness(<span class="string">&quot;AUTO&quot;</span>))._toQuery();</span><br><span class="line"></span><br><span class="line">SearchResponse&lt;Person&gt; searchResponse = client.search(s -&gt; s</span><br><span class="line">    .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .query(q -&gt; q.bool(b -&gt; b.should(matchQuery).should(fuzzyQuery))), Person.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用 N-Grams 提高模糊匹配</strong>，通过索引文本的 n-gram 来提高模糊匹配的性能和准确性的技术</p><p>可以使用 Lucene 查询解析器语法构建更复杂的查询，包括通配符、布尔运算符等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">simpleStringQuery</span> <span class="operator">=</span> SimpleQueryStringQuery.of(q -&gt; q.query(<span class="string">&quot;*Doe&quot;</span>))._toQuery();</span><br><span class="line">SearchResponse&lt;Person&gt; response3 = client.search(s -&gt; s.query(q -&gt; q.bool(b -&gt; b</span><br><span class="line">  .must(simpleStringQuery))), Person.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li><strong>恰当的索引配置</strong>：合理配置分片数量和副本数量是提高查询性能的关键。分片数量应根据数据量和查询负载合理配置，副本数量则可以提高数据的可用性和查询性能。</li><li><strong>合理的分词器选择</strong>：选择合适的分词器和分析器可以显著提高搜索精确度和性能。</li><li><strong>高效的缓存使用</strong>：合理配置和使用不同层级的缓存，可以显著提高查询性能，减少响应时间。定期监控和调优缓存配置，确保缓存的高效利用和系统的健康运行。</li><li><strong>查询语句优化</strong>：根据具体的查询需求，选择合适的分页查询策略，如 from-size、Scroll、Search_after 和 Search_after (PIT)。不同的分页查询策略有各自的优缺点，合理选择可以提高查询性能和用户体验。同时自定义评分函数，可调整搜索结果的相关性评分，确保返回的结果更符合业务需求。</li><li><strong>慢查询瓶颈分析</strong>：需关注的CPU 使用率，内存使用率以及磁盘IO，当其中一项达到瓶颈，查询性能就可能上不去了。</li></ul><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="1-ES-的分布式架构原理能说一下么"><a href="#1-ES-的分布式架构原理能说一下么" class="headerlink" title="1.ES 的分布式架构原理能说一下么"></a>1.ES 的分布式架构原理能说一下么</h2><p>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。核心思想就是在多台机器上启动多个 ES 进程实例，组成了一个 ES 集群。</p><p>ES 中存储数据的<strong>基本单位是索引</strong>，比如说你现在要在 ES 中存储一些订单数据，你就应该在 ES 中创建一个索引 <code>order_idx</code> ，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一个数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index -&gt; type -&gt; mapping -&gt; document -&gt; field</span><br></pre></td></tr></table></figure><p>一个 index 里可以有多个 type，每个 type 的字段都是差不多的</p><p>差不多是这么个对应关系</p><p>index-&gt;一类表</p><p>type-&gt;表</p><p>mapping-&gt;表结构</p><p>ducument-&gt;行</p><p>field-&gt;值</p><p>你搞一个索引，这个索引可以拆分成多个 <code>shard</code> ，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是<strong>支持横向扩展</strong>，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是<strong>提高性能</strong>，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p><p>接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 <code>primary shard</code> ，负责写入数据，但是还有几个 <code>replica shard</code> 。 <code>primary shard</code> 写入数据之后，会将数据同步到其他几个 <code>replica shard</code> 上去。</p><p>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</p><p>ES 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</p><p>如果是非 master 节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p><p>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p><p>其实上述就是 ElasticSearch 作为分布式搜索引擎最基本的一个架构设计。</p><p>其实都是差不多的，这些分布式的构建</p><h2 id="2-ES-写入数据的工作原理是什么啊？ES-查询数据的工作原理是什么啊？底层的-Lucene-介绍一下呗？倒排索引了解吗？"><a href="#2-ES-写入数据的工作原理是什么啊？ES-查询数据的工作原理是什么啊？底层的-Lucene-介绍一下呗？倒排索引了解吗？" class="headerlink" title="2.ES 写入数据的工作原理是什么啊？ES 查询数据的工作原理是什么啊？底层的 Lucene 介绍一下呗？倒排索引了解吗？"></a>2.ES 写入数据的工作原理是什么啊？ES 查询数据的工作原理是什么啊？底层的 Lucene 介绍一下呗？倒排索引了解吗？</h2><p>写数据：</p><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code> （协调节点）。</li><li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code> 。</li><li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li></ul><p>读数据：</p><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code> 。</li><li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 <code>coordinate node</code> 。</li><li><code>coordinate node</code> 返回 document 给客户端。</li></ul><p>搜索数据：</p><p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code> 的 <code>document</code> 给搜索出来。es 就会给你返回：java 真好玩儿啊，java 好难学啊。</p><ul><li>客户端发送请求到一个 <code>coordinate node</code> 。</li><li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code> ，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code> ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li></ul><p>底层lucene:</p><p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p><p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构</p><p>倒叙索引：</p><p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p><p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p><p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p><p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code> ，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p><ul><li>倒排索引中的所有词项对应一个或多个文档；</li><li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li></ul><p>底层实现：</p><h2 id="3-ES-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"><a href="#3-ES-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？" class="headerlink" title="3.ES 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"></a>3.ES 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</h2><ul><li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li><li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li><li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li></ul><h2 id="4-ES-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"><a href="#4-ES-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？" class="headerlink" title="4.ES 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"></a>4.ES 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</h2><p><strong>使用filesystem cache</strong></p><p>往 es 里写的数据，实际上都写到磁盘文件里去了，<strong>查询的时候</strong>，操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去。</p><p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code> ，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code>索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p><p>最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p><p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。</p><p><strong>数据预热</strong></p><p>最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p><p><strong>冷热分离</strong></p><p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让他们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p><p><strong>document模型设计</strong></p><p>最好是先在 <strong>Java 系统里就完成关联，将关联好的数据直接写入 es 中</strong>。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p><p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p><p><strong>分页性能优化</strong></p><p>假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><p>前面的几页速度挺快，后面的就不行了。</p><p>解决办法：</p><p>1.不允许深度分页</p><p>2.类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code></p><p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p><p>但是他<strong>不能随意跳到任何一页的场景</strong>。</p><p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p><p>除了用 <code>scroll api</code> ，你也可以用 <code>search_after</code> 来做， <code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/Elasticsearch/">Elasticsearch</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/06/new-stack/es1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>黑马点评项目逻辑功能分析</title>
      <link>https://blog.tokenlen.top/2025/07/01/workmenu/dianping1/</link>
      <guid>https://blog.tokenlen.top/2025/07/01/workmenu/dianping1/</guid>
      <pubDate>Mon, 30 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;登录功能&quot;&gt;&lt;a href=&quot;#登录功能&quot; class=&quot;headerlink&quot; title=&quot;登录功能&quot;&gt;&lt;/a&gt;登录功能&lt;/h1&gt;&lt;p&gt;架构：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h1><p>架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── com</span><br><span class="line">│   │   │       └── example</span><br><span class="line">│   │   │           └── auth</span><br><span class="line">│   │   │               ├── AuthApplication.java</span><br><span class="line">│   │   │               ├── config</span><br><span class="line">│   │   │               │   ├── AliyunSmsConfig.java</span><br><span class="line">│   │   │               │   ├── BloomFilterConfig.java</span><br><span class="line">│   │   │               │   └── RedisConfig.java</span><br><span class="line">│   │   │               ├── controller</span><br><span class="line">│   │   │               │   ├── AuthController.java</span><br><span class="line">│   │   │               │   └── ProtectedController.java</span><br><span class="line">│   │   │               ├── dto</span><br><span class="line">│   │   │               │   ├── LoginRequest.java</span><br><span class="line">│   │   │               │   ├── RegisterRequest.java</span><br><span class="line">│   │   │               │   ├── SmsCodeRequest.java</span><br><span class="line">│   │   │               │   └── TokenResponse.java</span><br><span class="line">│   │   │               ├── entity</span><br><span class="line">│   │   │               │   ├── Permission.java</span><br><span class="line">│   │   │               │   ├── Role.java</span><br><span class="line">│   │   │               │   └── User.java</span><br><span class="line">│   │   │               ├── exception</span><br><span class="line">│   │   │               │   ├── AuthException.java</span><br><span class="line">│   │   │               │   ├── GlobalExceptionHandler.java</span><br><span class="line">│   │   │               │   └── ResourceNotFoundException.java</span><br><span class="line">│   │   │               ├── interceptor</span><br><span class="line">│   │   │               │   └── JwtAuthInterceptor.java</span><br><span class="line">│   │   │               ├── mapper</span><br><span class="line">│   │   │               │   ├── PermissionMapper.java</span><br><span class="line">│   │   │               │   ├── RoleMapper.java</span><br><span class="line">│   │   │               │   └── UserMapper.java</span><br><span class="line">│   │   │               ├── service</span><br><span class="line">│   │   │               │   ├── AliyunSmsService.java</span><br><span class="line">│   │   │               │   ├── UserService.java</span><br><span class="line">│   │   │               │   └── impl</span><br><span class="line">│   │   │               │       └── UserServiceImpl.java</span><br><span class="line">│   │   │               ├── util</span><br><span class="line">│   │   │               │   ├── AuthContextHolder.java</span><br><span class="line">│   │   │               │   ├── JwtUtils.java</span><br><span class="line">│   │   │               │   └── LogAspect.java</span><br><span class="line">│   │   │               └── validator</span><br><span class="line">│   │   │                   └── MobileValidator.java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   │       ├── application.properties</span><br><span class="line">│   │       ├── mapper</span><br><span class="line">│   │       │   ├── PermissionMapper.xml</span><br><span class="line">│   │       │   ├── RoleMapper.xml</span><br><span class="line">│   │       │   └── UserMapper.xml</span><br><span class="line">│   │       └── schema.sql</span><br></pre></td></tr></table></figure><p>重要类的逻辑分析：</p><p><strong>JwtInterceptor.java token拦截器</strong></p><p>1.accesstoken拦截器：看请求头的accesstoken是不是存在，是不是合法，是不是在黑名单里</p><p>不合法返回401</p><p>2.refreshtoken拦截器：看refreshToken是不是为null,为空返回401</p><p>看是不是在redis里面，匹不匹配，不匹配返回403，不合法</p><p>然后看access倒没到期。到期刷新生成新的token,accesstoken放入请求头</p><p>refreshtoken放入redis</p><p><strong>AliyunSmsService.java</strong>  短信发送 service</p><p>生成一个随机数，然后放入redis，再调用send发送</p><p>send主要是设置sendSmsRequest的信息，电话号，签名，信息等。然后根据resonse的body来看发送成功</p><p><strong>BloomFilterServiceImpl.java </strong>  布隆过滤器service</p><p>主要是put方法和mightContain含有方法直接调用，使用service进行一层封装</p><p><strong>UserServiceImpl.java </strong> 用户service</p><p>注册：检测用户名电话号是否存在，然后新建User，然后set各种信息，之后insert表中。然后检测Role，然后没有就设置默认的角色，插入角色表，将userid put进布隆过滤器</p><p>登出：获取key,然后加入黑名单，把redis中的信息删除</p><p>获取信息：先使用布隆过滤器看存不存在，看user对象存不存在，都存在的话根据id查询</p><p>登录：先去匹配电话号，或者查找用户名。然后验证密码和状态，都成功，获取角色和权限，生成两个token，refreshtoken放入redis中,accesstoken返回resonse放入前端</p><p>加入黑名单：获取一个ttl，没过期的话就给他加入黑名单的redis中。过期就不管了</p><p><strong>AuthContextHolder.java</strong> ThreadLocal类</p><p>使用ThreadLocal保存信息，通过getter和setter来保持，注意clear使用remove方法来清空</p><p><strong>JwtTokenUntils.java JWTtoken生成工具类</strong></p><p>构建accesstoken，claims放需要传递的信息，比如userid。注意构建过期时间。一般比较短</p><p>构建refreshtoken，claims放需要传递的信息，比如userid。注意构建过期时间。一般比较长</p><p>然后从claims中获取信息</p><h1 id="店铺模块"><a href="#店铺模块" class="headerlink" title="店铺模块"></a>店铺模块</h1><p><strong>shopserviceimpl:</strong></p><p>基础功能实现</p><p>根据id查：</p><p>还保证了数据的一致性，先看缓存中有没有，没有就查数据库</p><p>先更新数据库再删缓存</p><p>还解决了缓存三兄弟，缓存穿透防护，空对象，缓存击穿：互斥锁，缓存雪崩：随机过期时间</p><p>还加入了重试机制，自旋等待</p><p>更新数据：</p><p>根据id查出来之后，放入生产者发送消息，提供了批量发，定时发，单个发，然后到消费者后，获取里面的信息，异步线程池写入数据库，在这里先将日放入redis，设置短的过期时间，写入成功后再设置为长期，然后将消息标记为已读。然后发送ACK请求，是啊比之后重试。重试到次数，退出循环，进入死信队列，人工处理。</p><p>为了保证幂等写库时加唯一键或 version 字段，根据这个来保证幂等</p><p>生产者接受到消息后根据成没成功，发送日志记录</p><p>设置热点信息：</p><p>预热，根据id查出来之后，放入redis中</p><p>MQ:</p><p>这里采用了继承，是消费者继承了一个基类，然后进行异步的消费写入。</p><p>然后生产者有批量发，定时发，延迟发，顺序发，单个发。</p><p>补充：</p><ol><li><strong>数据库连接池</strong> 确保使用 HikariCP 或 Druid 等高性能数据库连接池。</li><li><strong>监控和告警</strong> 对整个系统进行监控，包括 MQ 消息堆积情况、线程池状态、Redis 缓存命中率、数据库连接池状态等等。当出现异常情况时，及时发送告警。</li><li><strong>链路追踪</strong> 可以使用 SkyWalking、Zipkin 等链路追踪工具，方便排查分布式系统中的性能瓶颈和错误。</li><li><strong>单元测试和集成测试</strong> 编写单元测试和集成测试，确保各个组件的功能正常。</li></ol><p><strong>额外建议：</strong></p><ul><li><strong>熔断机制</strong> 当某个服务出现故障时，快速失败，避免雪崩 [8]。Hystrix 和 Sentinel 都是常用的熔断器。</li><li><strong>限流</strong> 使用令牌桶或漏桶算法限制请求流量，防止系统被流量压垮 [8]。Guava RateLimiter 和 Sentinel 都可以实现限流。</li></ul><h1 id="优惠劵超卖秒杀"><a href="#优惠劵超卖秒杀" class="headerlink" title="优惠劵超卖秒杀"></a>优惠劵超卖秒杀</h1><p>主要是解决的优惠卷的秒杀和超卖问题</p><p>秒杀主要是采用Redisson分布式锁来实现的，通过redisIDWorkder来根据时间戳和业务来设置一个唯一的lockID。</p><p>然后通过获取锁，解锁来实现并发的问题</p><p>通过设计了秒杀类订单类和优惠劵类，</p><p>秒杀service负责查当前的业务id,然后优惠劵类负责去增加产生任务，进入堵塞队列</p><p>优惠劵下单通过ThreadLocal来获取用户id,通过lua脚本原子的去分发优惠劵，主要是</p><p>判断用户有没有领取过，库存是不是重足，然后扣库存。</p><p>然后将订单的信息加入，然后将订单发送给MQ消费者，消费者消费就是先设置一个短的过期时间，执行下单方法。成功就将ttl改为长期，下单失败进入重试机制，继续下单操作，等到达最大次数的时候，发送到死信队列人工处理，清除redis缓存</p><p>然后下单操作也是要去获取redis锁，然后去再查优惠劵下单redis存不存在，设置id信息。然后使用乐观锁去使用个人的库存优惠劵，成功之际完成任务，记住finally要关掉锁</p><p>补充：</p><ol><li><strong>防缓存穿透</strong> 你需要补充缓存穿透的解决方案 1。可以使用布隆过滤器 1或者缓存空对象来解决缓存穿透问题，防止恶意请求绕过缓存直接打到数据库。</li><li><strong>优惠券状态校验</strong> 需要补充优惠券有效期的判断 3。在秒杀前，需要校验优惠券是否在有效期内 3。服务端需要比对当前时间是否在优惠券有效时间范围内，可以设置定时任务扫描过期的优惠券，并标记为”已过期” 3。</li><li><strong>用户资格校验</strong> 秒杀之前需要先判断用户是否具备秒杀资格，例如是否有黑名单限制等。</li><li><strong>下单失败回滚</strong> 需要补充下单失败情况的处理 3。例如，支付失败、库存不足等情况，需要在事务回滚后将优惠券状态重置为”未使用” 3。为避免并发问题，可以使用分布式事务或 Redis 回滚标记 3。</li><li><strong>安全性</strong> 使用时不仅要校验优惠券ID，还要校验用户是否具备使用该优惠券的资格 3。防止用户伪造优惠券ID，盗用他人优惠券 3。</li><li><strong>更强的原子性</strong> 更强的原子性（两阶段确认）：第一阶段：消费者收到消息后，在本地事务（如果业务和幂等存储在同一个数据库）或分布式事务（如 TCC）中，先进行幂等性判断并记录 ID，然后执行业务逻辑。第二阶段：只有当整个事务提交成功后，才向 RabbitMQ 发送 basicAck。如果事务失败，则不发送 basicAck，让 RabbitMQ 重新投递消息 2。</li></ol><p><strong>技术细节补充：</strong></p><ol><li>Redis 分布式锁的细节<ul><li><strong>可重入性</strong> 考虑 Redisson 分布式锁的可重入性 </li><li><strong>Watchdog 机制</strong> Redisson 的 Watchdog 机制可以自动续期，避免锁提前过期 </li></ul></li><li>Lua 脚本的细节<ul><li><strong>短小精悍</strong> 保持 Lua 脚本的短小精悍，只包含最核心、需要原子性执行的逻辑 6。</li><li><strong>避免昂贵操作</strong> 避免在脚本中执行 KEYS、SMEMBERS、HGETALL 等会遍历大量数据的命令 6。</li><li><strong>超时时间</strong> 注意 Redis 的 <code>lua-time-limit</code> 配置 (默认 5 秒)，超出这个时间脚本会被终止 6。</li></ul></li><li>重试机制<ul><li><strong>重试次数限制</strong> 设置最大重试次数，超过限制则进入死信队列，避免无限重试。</li><li><strong>重试间隔</strong> 考虑使用不同的重试间隔，例如退避策略，避免重试过于频繁。</li></ul></li><li><strong>异步确认</strong> 最终成功后才 ACK 消息 2。</li><li><strong>双检</strong> 线程获取锁后，还需要查询缓存（也就是所谓的双检），这样才能够真正有效保障缓存不被击穿 </li></ol><h1 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h1><p>基础功能：</p><p>基于Elasticsearch 实现搜索功能</p><p>先是初始化SearchRequest然后初始化SearchSourceBuilder</p><p>然后初始化搜索BoolQueryBuilder</p><p>然后使用搜索的策略，MatchQueryBuilder 精准搜索，FuzzyQueryBuilder模糊匹配</p><p>然后把他们加入BoolQueryBuilder，然后再把他query进sourceBuilder。然后再包进searchRequest。完成发送请求。</p><p>然后再新建 SearchResponse使用客户端进行查询</p><p>然后把查询结果转为需要查询的类型</p><p>改进：</p><p>1.排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SortOrder</span> <span class="variable">order</span> <span class="operator">=</span> sortOrder.equalsIgnoreCase(<span class="string">&quot;asc&quot;</span>) ? SortOrder.ASC : SortOrder.DESC;</span><br><span class="line">sourceBuilder.sort(<span class="keyword">new</span> <span class="title class_">FieldSortBuilder</span>(sortField).order(order));</span><br></pre></td></tr></table></figure><p>2.分页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceBuilder.from((pageNum-<span class="number">1</span>)*pageSize).size(pageSize);</span><br></pre></td></tr></table></figure><p>3.高亮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line">            highlightBuilder.field(<span class="string">&quot;name&quot;</span>).preTags(HIGHLIGHT_PRE_TAG).postTags(HIGHLIGHT_POST_TAG);</span><br><span class="line">            sourceBuilder.highlighter(highlightBuilder);</span><br></pre></td></tr></table></figure><p>response:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hit.getHighlightFields()!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">HighlightField</span> <span class="variable">nameField</span> <span class="operator">=</span> hit.getHighlightFields().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (nameField!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    Text[] fragments = nameField.fragments();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">highlightedName</span> <span class="operator">=</span> fragments[<span class="number">0</span>].toString();</span><br><span class="line">                    shop.setName(highlightedName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>4.分页查询优化，使用search_after进行优化</p><p>search_after实现翻页，使用前一页的结果来帮助检索下一页的数据</p><p>需要先指定排序规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SortOrder</span> <span class="variable">order</span> <span class="operator">=</span> sortOrder.equalsIgnoreCase(<span class="string">&quot;asc&quot;</span>) ? SortOrder.ASC : SortOrder.DESC;</span><br><span class="line">            sourceBuilder.sort(<span class="keyword">new</span> <span class="title class_">FieldSortBuilder</span>(sortField).order(order));</span><br></pre></td></tr></table></figure><p>后面需要制定下一页的结果来实现检索下一页的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] nextSearchAfter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (shops.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">SearchHit</span> <span class="variable">lasthit</span> <span class="operator">=</span> searchResponse.getHits().getHits()[shops.size() - <span class="number">1</span>];</span><br><span class="line">                nextSearchAfter = lasthit.getSortValues();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>总代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SearchResult&lt;Shop&gt; <span class="title function_">searchShopsAfter</span><span class="params">(String keywords, <span class="type">int</span> pageSize, Object[] searchAfterSortValues, String sortField, String sortOrder)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(INDEX_NAME);</span><br><span class="line">            <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">            <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoolQueryBuilder</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">MatchQueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, keywords);</span><br><span class="line">            boolQueryBuilder.must(matchQueryBuilder);</span><br><span class="line"></span><br><span class="line">            sourceBuilder.query(boolQueryBuilder);</span><br><span class="line">            sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">            <span class="type">SortOrder</span> <span class="variable">order</span> <span class="operator">=</span> sortOrder.equalsIgnoreCase(<span class="string">&quot;asc&quot;</span>) ? SortOrder.ASC : SortOrder.DESC;</span><br><span class="line">            sourceBuilder.sort(<span class="keyword">new</span> <span class="title class_">FieldSortBuilder</span>(sortField).order(order));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (searchAfterSortValues != <span class="literal">null</span>) &#123;</span><br><span class="line">                sourceBuilder.searchAfter(searchAfterSortValues);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            searchRequest.source(sourceBuilder);</span><br><span class="line">            <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">            List&lt;Shop&gt; shops = convertSearchHitsToShops(searchResponse);</span><br><span class="line"></span><br><span class="line">            Object[] nextSearchAfter = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (shops.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">SearchHit</span> <span class="variable">lasthit</span> <span class="operator">=</span> searchResponse.getHits().getHits()[shops.size() - <span class="number">1</span>];</span><br><span class="line">                nextSearchAfter = lasthit.getSortValues();</span><br><span class="line">            &#125;</span><br><span class="line">            SearchResult&lt;Shop&gt; result = <span class="keyword">new</span> <span class="title class_">SearchResult</span>&lt;&gt;();</span><br><span class="line">            result.setItems(shops);</span><br><span class="line">            result.setNextSearchAfter(nextSearchAfter);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;使用 search_after 搜索店铺时发生IO异常&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>Scroll 上下文</strong>进行分页查询的优化</p><p>首次请求的时候会进行快照生成，然后之后的查询就再使用之前的了</p><p>搜索完成后，要及时清除 scroll 上下文，释放资源</p><p>不适合高实时性的要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后续请求</span></span><br><span class="line">            <span class="type">SearchScrollRequest</span> <span class="variable">scrollRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchScrollRequest</span>(scrollId);</span><br><span class="line">            scrollRequest.scroll(TimeValue.parseTimeValue(scrollTime, <span class="literal">null</span>, <span class="string">&quot;scroll&quot;</span>));</span><br><span class="line">            <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.scroll(scrollRequest, RequestOptions.DEFAULT);</span><br><span class="line">            <span class="keyword">return</span> convertSearchHitsToShops(searchResponse);</span><br></pre></td></tr></table></figure><h1 id="redis功能扩展"><a href="#redis功能扩展" class="headerlink" title="redis功能扩展"></a>redis功能扩展</h1><p>BlogService：</p><p>1.根据id查询blog，使用的数据一致性是先查redis缓存再查数据库</p><p>查缓存主要是先从redis中根据key获取数据，然后又就进行反序列化为实体类，没有就返回日志，去查数据库</p><p>通过mybatis的byid查询，然后更新点赞和用户信息，然后将其存入缓存</p><p>2.点赞功能，主要是通过redis的，这个操作需要是事务的，所以使用Redis <code>SessionCallback</code> 实现事务性操作</p><p>在一次 Redis 会话中实现<strong>查询 + multi + exec</strong>，确保 Redis 操作具备原子性；</p><p>去看用户是不是点赞了，没点赞的话就执行redis的sql，类似lua脚本。然后使用update.setsql使用sql</p><p>然后更新完成之后更新redis缓存，使用score作为时间戳，方面后面的分页查询，比如查前5个点赞的用户。使用zset</p><p>处理，如果数据库更新失败，则终止事务</p><p>3.签到方法，主要是使用redis中的bitmap，设定月份为偏移量，然后设定key，然后setbit那个位置为true</p><p>4.保存探店笔记，先去查用户，然后检测是否保存成功，然后使用CompletableFuture提供的异步线程池来执行操作，先看关注的，然后把这些关注的人放入redis的zset，推送给他们。也可以实现延迟发布，加上时间即可。</p><p>5.分页查询关注者，获取zset村的blog的id,然后提取里面的blogid和mintime，然后更新新的blogid和mintime，然后按照ids的顺序查询blog，给每个blog补充作者信息，然后分页查询返回结果，主要是放在一个hashmap里面</p><p>6.查询所有点赞的用户，先获取用户，然后先查缓存，然后从zset里面获取前5个点赞的用户，然后按id包装成一个list,先查无序的，然后再从数据库中按指定的 <code>ids</code> 查询用户信息，并按照 <code>ids</code> 原有顺序（即点赞顺序）返回 <code>List&lt;UserDTO&gt;</code>。然后将其存入缓存。中间需要转DTO</p><p>7.计算连续签到的天数，</p><p>FollowService:</p><p>1.关注用户，目前是通过一个added变量，然后执行关注的，就是通过getbasemapper来完成insert操作</p><p>然后失败可以加入补偿机制，todo</p><p>2.查询是否关注，就是简单的查询是不是在redis的zset里面</p><p>3.查询共同好友，现在redis查询缓存，缓存存在就反序列话UserDTO</p><p>不存在就在数据库里查询，使用redis的zset的intersect进行交集的运算，然后查询返回DTO 类型。</p><h1 id="spring-AI"><a href="#spring-AI" class="headerlink" title="spring-AI"></a>spring-AI</h1><p>aiconfig。引入我们需要的模型，用的是阿里的dashscope的两个chat模型和嵌入模型</p><p>然后MCP板块，我们分为内部的mcp，和外部引入的mcp，外部引用的mcp，先添加依赖，然后加载我们的json配置文件，然后注册。</p><p>内部的mcp，我们先创建一个接口，一个基类实现这个接口，其他的具体实现继承这个接口。然后到时候直接调用，这就是策略模式</p><p>然后对话服务在，主要是封装session的一系列方法，发送之前的所有对话加上这一次的message给我们的大模型，然后获取大模型的回复，然后将这次的回复再加入我们的会话。</p><p>里面需要我们去写增强的提示词，就是prompt</p><p>然后agent,agnet是一个更加智能的助手，但是我们需要去选择，只是一个简单的聊天，还是要我们执行比较复杂的任务。</p><p>搜索方法，我们分为模型的语义搜索，在我们的向量库里搜索出topk的结果，权重60%</p><p>然后传统的es搜索，占比40%.</p><p>然后把这些信息放在一个线程安全的concurrentmap里面，然后去聚合他们的</p><p>然后聚合之后使用我们重排模型，继续去根据筛选topk，对他们进行打分。综合的再出现我们需要的结果。这里需要我们去构建重排模型的prompt，我们需要的参数，更想去查找的参数</p><p>然后重排完成之后，我们要构建我们的结果list，然后如果失败的化，我们就要降级到传统排序</p><p>然后聊天的话，我们的重点就是要实现我们聊天的持久化，因为大模型他是没有记忆性的，所以一般我们需要去把之前所有的对话都发送给他。</p><p>但是这样的话，容易超出上下文的限制，我们可以使用直接简单粗暴的截断，前面的我们不需要的。这样是不行的</p><p>也可以进行提取总结，要超出的话，我们就将前面的上下文给另一个模型来进行提取，再把这些加上我们的需求来完成</p><p>也可以构建向量库，利用嵌入模型完成。将我们的消息都交给嵌入模型，根据topk搜索，检索出我们需要的数据。</p><h1 id="升级改进"><a href="#升级改进" class="headerlink" title="升级改进"></a>升级改进</h1><p>现有点赞功能使用 Redis 的 Sorted Set 来存储点赞用户，但当某个博客成为热点时，对应的 Redis Key (例如 <code>blog:liked:&#123;id&#125;</code>) 会被频繁访问，导致以下问题：</p><ul><li><strong>单点瓶颈:</strong> 单个 Redis 节点可能无法承受大量的读写请求，成为性能瓶颈。</li><li><strong>缓存击穿风险:</strong> 如果缓存失效，大量请求会直接穿透到数据库，可能导致数据库压力过大。</li><li><strong>网络拥塞:</strong> 大量请求和响应可能导致网络拥塞。</li></ul><p>改进：</p><p>1.<strong>Redis 集群 (分片)</strong>：使用 Redis 集群对点赞 Key 进行分片 (例如基于 Blog ID 的 Hash 算法)，将请求分散到不同的 Redis 节点上。</p><p>需要考虑数据迁移、一致性 Hash 算法的选择等问题。</p><p>2.<strong>本地热点缓存</strong>，在应用服务器本地维护一个热点 Key 的缓存，例如使用 Caffeine、Guava Cache 等，或者使用 ConcurrentHashMap 自己实现简单的本地缓存。</p><p>需要考虑缓存一致性，本地缓存容量有限，如果热点 Key 过多可能导致 OOM。</p><p>3.<strong>二级缓存 + 异步更新</strong>，</p><ul><li><strong>L1 缓存：</strong> 应用本地缓存, 具有更快的访问速度，直接从内存读取，但容量有限。</li><li><strong>L2 缓存：</strong> Redis 缓存，可以存储更多数据，避免频繁访问数据库。</li><li><strong>异步更新：</strong> 当本地缓存失效时，异步从 Redis 加载数据，并在本地缓存中更新。</li></ul><p>最终我们使用的是3方案，构建了一个三层架构</p><p>第一层是本地缓存，我们采用Caffeine</p><p>第二次是redis，第三层是数据库</p><p>我们先查数据的时候，首先会查询本地缓存，然后没有的话，再去查redis，这里面涉及到哦DTO数据的反序列化和序列化</p><p>然后我们从数据库查询的时候调用lambda表达式。将缓存最后都没命中的话，我们返回null，这个时候就会调用数据库查询</p><p>然后呢放入数据的时候，我们使用了一个异步的线程池来放入，先将放入数据库，然后放入redis，最后写入本地缓存。</p><hr><p>基于Zset的排行榜：</p><p>1.分页查询排行榜，去获取key，然后zcard去获取数量。</p><p>然后使用Set<ZSetOperations.TypedTuple<Object>&gt; rawRanking去获取条目，需    要分数就去查询分数</p><p>​    不需要分数就获取成员id集合，然后分数设定位0.0</p><p>然后设置条目，然后去遍历使用builder来设置item的各个属性。</p><p>最后返回我们需要的item</p><p>2.排行榜的分段查询，先去获取key，然后使用arraylist来存储分段所需要查询的结果</p><p>然后去遍历分数上下限，从redis中获取所需要的分数段的member,然后获取count成员的数量</p><p>然后设置分段的最大值最小值等信息，然后返回分段set集合</p><p>3.更新排行榜，使用@Scheduled定时执行这个更新的方法，一般这个方法不能传参</p><p>首先先获取memberid，然后创建一个Arraylist来执行我们的lua脚本，放入id和basescore参数</p><p>然后使用map来遍历每个维度的key和权重。为了构造lua脚本的参数</p><p>然后加载并执行我们的lua脚本，实现原子的更新。</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><h2 id="1-个性化推荐"><a href="#1-个性化推荐" class="headerlink" title="1.个性化推荐"></a>1.个性化推荐</h2><p>基于您的点评项目场景，我理解您需要一个能够根据用户历史行为和偏好，智能推荐相似店铺的系统。这是一个典型的<strong>协同过滤 + 内容推荐</strong>的混合推荐场景。</p><ul><li>提升用户体验，增加用户粘性</li><li>提高店铺曝光率和转化率</li><li>支持实时推荐和离线批量计算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 框架: Spring Boot 2.7.x + Spring Cloud 2021.x</span><br><span class="line">- 数据库: MySQL 8.0 + Redis 6.2 + Elasticsearch 7.17</span><br><span class="line">- 消息队列: Kafka 3.0</span><br><span class="line">- 机器学习: Mahout/自研算法</span><br><span class="line">- 监控: Prometheus + Grafana</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户端 → API Gateway → 推荐服务 → 算法引擎</span><br><span class="line">                    ↓</span><br><span class="line">                特征存储 → 离线计算引擎</span><br><span class="line">                    ↓</span><br><span class="line">                实时计算引擎 ← Kafka</span><br></pre></td></tr></table></figure><p>1.核心架构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.recommendation.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推荐引擎核心接口</span></span><br><span class="line"><span class="comment"> * 支持多种推荐策略的统一入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecommendationEngine</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取个性化推荐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size 推荐数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scene 推荐场景(首页/详情页/搜索后等)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 推荐结果列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;RecommendationResult&gt; <span class="title function_">recommend</span><span class="params">(Long userId, Integer size, String scene)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实时更新用户行为</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userBehavior 用户行为数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUserBehavior</span><span class="params">(UserBehavior userBehavior)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>混合推荐算法实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.recommendation.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 混合推荐引擎实现</span></span><br><span class="line"><span class="comment"> * 结合协同过滤、内容推荐、热门推荐等多种策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HybridRecommendationEngine</span> <span class="keyword">implements</span> <span class="title class_">RecommendationEngine</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CollaborativeFilteringService cfService;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentBasedService contentService;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HotRecommendationService hotService;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserProfileService userProfileService;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor recommendationExecutor;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 推荐策略权重配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, BigDecimal&gt; STRATEGY_WEIGHTS = Map.of(</span><br><span class="line">        <span class="string">&quot;collaborative&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.4&quot;</span>),</span><br><span class="line">        <span class="string">&quot;content&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.4&quot;</span>),</span><br><span class="line">        <span class="string">&quot;hot&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;recommendations&quot;, key = &quot;#userId + &#x27;_&#x27; + #size + &#x27;_&#x27; + #scene&quot;, </span></span><br><span class="line"><span class="meta">               unless = &quot;#result.size() == 0&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;RecommendationResult&gt; <span class="title function_">recommend</span><span class="params">(Long userId, Integer size, String scene)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始为用户 &#123;&#125; 生成推荐，场景: &#123;&#125;, 数量: &#123;&#125;&quot;</span>, userId, scene, size);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取用户画像</span></span><br><span class="line">            <span class="type">UserProfile</span> <span class="variable">userProfile</span> <span class="operator">=</span> userProfileService.getUserProfile(userId);</span><br><span class="line">            <span class="keyword">if</span> (userProfile == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hotService.getHotRecommendations(size, scene);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 并行执行多种推荐策略</span></span><br><span class="line">            CompletableFuture&lt;List&lt;RecommendationItem&gt;&gt; cfFuture = </span><br><span class="line">                CompletableFuture.supplyAsync(() -&gt; </span><br><span class="line">                    cfService.getCollaborativeRecommendations(userId, size * <span class="number">2</span>), </span><br><span class="line">                    recommendationExecutor);</span><br><span class="line">          </span><br><span class="line">            CompletableFuture&lt;List&lt;RecommendationItem&gt;&gt; contentFuture = </span><br><span class="line">                CompletableFuture.supplyAsync(() -&gt; </span><br><span class="line">                    contentService.getContentBasedRecommendations(userProfile, size * <span class="number">2</span>), </span><br><span class="line">                    recommendationExecutor);</span><br><span class="line">          </span><br><span class="line">            CompletableFuture&lt;List&lt;RecommendationItem&gt;&gt; hotFuture = </span><br><span class="line">                CompletableFuture.supplyAsync(() -&gt; </span><br><span class="line">                    hotService.getHotRecommendations(size, scene).stream()</span><br><span class="line">                        .map(r -&gt; <span class="keyword">new</span> <span class="title class_">RecommendationItem</span>(r.getShopId(), r.getScore()))</span><br><span class="line">                        .collect(Collectors.toList()), </span><br><span class="line">                    recommendationExecutor);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 等待所有任务完成</span></span><br><span class="line">            CompletableFuture.allOf(cfFuture, contentFuture, hotFuture).join();</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 融合推荐结果</span></span><br><span class="line">            List&lt;RecommendationItem&gt; hybridResults = mergeRecommendations(</span><br><span class="line">                cfFuture.get(), contentFuture.get(), hotFuture.get()</span><br><span class="line">            );</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 转换为最终结果并应用业务规则</span></span><br><span class="line">            <span class="keyword">return</span> buildFinalResults(hybridResults, userProfile, scene, size);</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;推荐生成失败，用户: &#123;&#125;, 错误: &#123;&#125;&quot;</span>, userId, e.getMessage(), e);</span><br><span class="line">            <span class="comment">// 降级到热门推荐</span></span><br><span class="line">            <span class="keyword">return</span> hotService.getHotRecommendations(size, scene);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 融合多种推荐策略的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RecommendationItem&gt; <span class="title function_">mergeRecommendations</span><span class="params">(</span></span><br><span class="line"><span class="params">            List&lt;RecommendationItem&gt; cfResults,</span></span><br><span class="line"><span class="params">            List&lt;RecommendationItem&gt; contentResults,</span></span><br><span class="line"><span class="params">            List&lt;RecommendationItem&gt; hotResults)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        Map&lt;Long, BigDecimal&gt; scoreMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 协同过滤结果加权</span></span><br><span class="line">        cfResults.forEach(item -&gt; </span><br><span class="line">            scoreMap.merge(item.getShopId(), </span><br><span class="line">                item.getScore().multiply(STRATEGY_WEIGHTS.get(<span class="string">&quot;collaborative&quot;</span>)), </span><br><span class="line">                BigDecimal::add));</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 内容推荐结果加权</span></span><br><span class="line">        contentResults.forEach(item -&gt; </span><br><span class="line">            scoreMap.merge(item.getShopId(), </span><br><span class="line">                item.getScore().multiply(STRATEGY_WEIGHTS.get(<span class="string">&quot;content&quot;</span>)), </span><br><span class="line">                BigDecimal::add));</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 热门推荐结果加权</span></span><br><span class="line">        hotResults.forEach(item -&gt; </span><br><span class="line">            scoreMap.merge(item.getShopId(), </span><br><span class="line">                item.getScore().multiply(STRATEGY_WEIGHTS.get(<span class="string">&quot;hot&quot;</span>)), </span><br><span class="line">                BigDecimal::add));</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> scoreMap.entrySet().stream()</span><br><span class="line">            .map(entry -&gt; <span class="keyword">new</span> <span class="title class_">RecommendationItem</span>(entry.getKey(), entry.getValue()))</span><br><span class="line">            .sorted((a, b) -&gt; b.getScore().compareTo(a.getScore()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserBehavior</span><span class="params">(UserBehavior userBehavior)</span> &#123;</span><br><span class="line">        <span class="comment">// 异步更新用户行为，不阻塞主流程</span></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 更新实时特征</span></span><br><span class="line">                userProfileService.updateRealTimeFeatures(userBehavior);</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 发送到Kafka进行离线处理</span></span><br><span class="line">                kafkaTemplate.send(<span class="string">&quot;user_behavior&quot;</span>, userBehavior);</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 清除相关缓存</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;recommendations:&quot;</span> + userBehavior.getUserId() + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">                redisTemplate.delete(redisTemplate.keys(cacheKey));</span><br><span class="line">              </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;更新用户行为失败: &#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, recommendationExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>协同过滤算法实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.recommendation.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于用户的协同过滤算法</span></span><br><span class="line"><span class="comment"> * 使用改进的余弦相似度计算用户相似性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollaborativeFilteringService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserBehaviorRepository behaviorRepository;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShopRepository shopRepository;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取协同过滤推荐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;RecommendationItem&gt; <span class="title function_">getCollaborativeRecommendations</span><span class="params">(Long userId, Integer size)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 1. 获取用户行为数据</span></span><br><span class="line">        List&lt;UserBehavior&gt; userBehaviors = behaviorRepository.findByUserId(userId);</span><br><span class="line">        <span class="keyword">if</span> (userBehaviors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 2. 构建用户-商店评分矩阵</span></span><br><span class="line">        Map&lt;Long, Map&lt;Long, BigDecimal&gt;&gt; userItemMatrix = buildUserItemMatrix(userId);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 3. 计算用户相似度</span></span><br><span class="line">        Map&lt;Long, BigDecimal&gt; userSimilarities = calculateUserSimilarities(userId, userItemMatrix);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 4. 生成推荐</span></span><br><span class="line">        <span class="keyword">return</span> generateRecommendations(userId, userSimilarities, userItemMatrix, size);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建用户-商店评分矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, Map&lt;Long, BigDecimal&gt;&gt; <span class="title function_">buildUserItemMatrix</span><span class="params">(Long targetUserId)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 获取目标用户喜欢的店铺类型</span></span><br><span class="line">        Set&lt;String&gt; targetUserCategories = getUserPreferredCategories(targetUserId);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 查找有相似偏好的用户（优化：避免计算所有用户）</span></span><br><span class="line">        List&lt;Long&gt; similarUsers = behaviorRepository.findUsersByCategories(</span><br><span class="line">            targetUserCategories, <span class="number">1000</span>); <span class="comment">// 限制计算用户数量</span></span><br><span class="line">      </span><br><span class="line">        Map&lt;Long, Map&lt;Long, BigDecimal&gt;&gt; matrix = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (Long userId : similarUsers) &#123;</span><br><span class="line">            List&lt;UserBehavior&gt; behaviors = behaviorRepository.findByUserId(userId);</span><br><span class="line">            Map&lt;Long, BigDecimal&gt; userRatings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (UserBehavior behavior : behaviors) &#123;</span><br><span class="line">                <span class="comment">// 根据行为类型计算隐式评分</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">score</span> <span class="operator">=</span> calculateImplicitRating(behavior);</span><br><span class="line">                userRatings.merge(behavior.getShopId(), score, BigDecimal::add);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            matrix.put(userId, userRatings);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算隐式评分</span></span><br><span class="line"><span class="comment">     * 浏览=1分，收藏=3分，评论=5分，高评分评论=8分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal <span class="title function_">calculateImplicitRating</span><span class="params">(UserBehavior behavior)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (behavior.getBehaviorType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;VIEW&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> BigDecimal.valueOf(<span class="number">1.0</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;FAVORITE&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> BigDecimal.valueOf(<span class="number">3.0</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;COMMENT&quot;</span>:</span><br><span class="line">                <span class="comment">// 根据评论星级调整分数</span></span><br><span class="line">                <span class="type">Double</span> <span class="variable">rating</span> <span class="operator">=</span> behavior.getRating();</span><br><span class="line">                <span class="keyword">if</span> (rating != <span class="literal">null</span> &amp;&amp; rating &gt;= <span class="number">4.0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BigDecimal.valueOf(<span class="number">8.0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rating != <span class="literal">null</span> &amp;&amp; rating &gt;= <span class="number">3.0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BigDecimal.valueOf(<span class="number">5.0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> BigDecimal.valueOf(<span class="number">2.0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;SHARE&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> BigDecimal.valueOf(<span class="number">6.0</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> BigDecimal.valueOf(<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算用户相似度（改进的余弦相似度）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, BigDecimal&gt; <span class="title function_">calculateUserSimilarities</span><span class="params">(</span></span><br><span class="line"><span class="params">            Long targetUserId, </span></span><br><span class="line"><span class="params">            Map&lt;Long, Map&lt;Long, BigDecimal&gt;&gt; userItemMatrix)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        Map&lt;Long, BigDecimal&gt; targetUserRatings = userItemMatrix.get(targetUserId);</span><br><span class="line">        <span class="keyword">if</span> (targetUserRatings == <span class="literal">null</span> || targetUserRatings.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        Map&lt;Long, BigDecimal&gt; similarities = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, Map&lt;Long, BigDecimal&gt;&gt; entry : userItemMatrix.entrySet()) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="keyword">if</span> (userId.equals(targetUserId)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            Map&lt;Long, BigDecimal&gt; userRatings = entry.getValue();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">similarity</span> <span class="operator">=</span> calculateCosineSimilarity(targetUserRatings, userRatings);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (similarity.compareTo(BigDecimal.valueOf(<span class="number">0.1</span>)) &gt; <span class="number">0</span>) &#123; <span class="comment">// 过滤低相似度用户</span></span><br><span class="line">                similarities.put(userId, similarity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> similarities;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 余弦相似度计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal <span class="title function_">calculateCosineSimilarity</span><span class="params">(</span></span><br><span class="line"><span class="params">            Map&lt;Long, BigDecimal&gt; ratingsA, </span></span><br><span class="line"><span class="params">            Map&lt;Long, BigDecimal&gt; ratingsB)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        Set&lt;Long&gt; commonItems = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(ratingsA.keySet());</span><br><span class="line">        commonItems.retainAll(ratingsB.keySet());</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (commonItems.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> BigDecimal.ZERO;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">dotProduct</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">normA</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">normB</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (Long itemId : commonItems) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">ratingA</span> <span class="operator">=</span> ratingsA.get(itemId);</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">ratingB</span> <span class="operator">=</span> ratingsB.get(itemId);</span><br><span class="line">          </span><br><span class="line">            dotProduct = dotProduct.add(ratingA.multiply(ratingB));</span><br><span class="line">            normA = normA.add(ratingA.multiply(ratingA));</span><br><span class="line">            normB = normB.add(ratingB.multiply(ratingB));</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (normA.equals(BigDecimal.ZERO) || normB.equals(BigDecimal.ZERO)) &#123;</span><br><span class="line">            <span class="keyword">return</span> BigDecimal.ZERO;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">denominator</span> <span class="operator">=</span> sqrt(normA).multiply(sqrt(normB));</span><br><span class="line">        <span class="keyword">return</span> dotProduct.divide(denominator, <span class="number">4</span>, RoundingMode.HALF_UP);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成最终推荐列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RecommendationItem&gt; <span class="title function_">generateRecommendations</span><span class="params">(</span></span><br><span class="line"><span class="params">            Long targetUserId,</span></span><br><span class="line"><span class="params">            Map&lt;Long, BigDecimal&gt; userSimilarities,</span></span><br><span class="line"><span class="params">            Map&lt;Long, Map&lt;Long, BigDecimal&gt;&gt; userItemMatrix,</span></span><br><span class="line"><span class="params">            Integer size)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        Map&lt;Long, BigDecimal&gt; targetUserRatings = userItemMatrix.get(targetUserId);</span><br><span class="line">        Set&lt;Long&gt; targetUserItems = targetUserRatings.keySet();</span><br><span class="line">      </span><br><span class="line">        Map&lt;Long, BigDecimal&gt; itemScores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, BigDecimal&gt; simEntry : userSimilarities.entrySet()) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">similarUserId</span> <span class="operator">=</span> simEntry.getKey();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">similarity</span> <span class="operator">=</span> simEntry.getValue();</span><br><span class="line">          </span><br><span class="line">            Map&lt;Long, BigDecimal&gt; similarUserRatings = userItemMatrix.get(similarUserId);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Long, BigDecimal&gt; ratingEntry : similarUserRatings.entrySet()) &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">shopId</span> <span class="operator">=</span> ratingEntry.getKey();</span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">rating</span> <span class="operator">=</span> ratingEntry.getValue();</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 跳过用户已经交互过的商店</span></span><br><span class="line">                <span class="keyword">if</span> (targetUserItems.contains(shopId)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">score</span> <span class="operator">=</span> similarity.multiply(rating);</span><br><span class="line">                itemScores.merge(shopId, score, BigDecimal::add);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> itemScores.entrySet().stream()</span><br><span class="line">            .sorted((e1, e2) -&gt; e2.getValue().compareTo(e1.getValue()))</span><br><span class="line">            .limit(size)</span><br><span class="line">            .map(entry -&gt; <span class="keyword">new</span> <span class="title class_">RecommendationItem</span>(entry.getKey(), entry.getValue()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 简化的平方根计算</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal <span class="title function_">sqrt</span><span class="params">(BigDecimal value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BigDecimal.valueOf(Math.sqrt(value.doubleValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实时特征更新服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.recommendation.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户画像服务</span></span><br><span class="line"><span class="comment"> * 负责用户特征的实时更新和画像构建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfileService</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserBehaviorRepository behaviorRepository;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_PROFILE_KEY</span> <span class="operator">=</span> <span class="string">&quot;user_profile:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REAL_TIME_FEATURES_KEY</span> <span class="operator">=</span> <span class="string">&quot;rt_features:&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户画像</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> UserProfile <span class="title function_">getUserProfile</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_PROFILE_KEY + userId;</span><br><span class="line">        <span class="type">UserProfile</span> <span class="variable">profile</span> <span class="operator">=</span> (UserProfile) redisTemplate.opsForValue().get(key);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (profile == <span class="literal">null</span>) &#123;</span><br><span class="line">            profile = buildUserProfile(userId);</span><br><span class="line">            <span class="keyword">if</span> (profile != <span class="literal">null</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, profile, <span class="number">24</span>, TimeUnit.HOURS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> profile;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建用户画像</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserProfile <span class="title function_">buildUserProfile</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取用户历史行为</span></span><br><span class="line">            List&lt;UserBehavior&gt; behaviors = behaviorRepository.findRecentBehaviors(</span><br><span class="line">                userId, LocalDateTime.now().minusDays(<span class="number">30</span>));</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (behaviors.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="type">UserProfile</span> <span class="variable">profile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProfile</span>();</span><br><span class="line">            profile.setUserId(userId);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 计算用户偏好类别</span></span><br><span class="line">            Map&lt;String, Long&gt; categoryPreferences = behaviors.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(</span><br><span class="line">                    behavior -&gt; getShopCategory(behavior.getShopId()),</span><br><span class="line">                    Collectors.counting()));</span><br><span class="line">          </span><br><span class="line">            profile.setPreferredCategories(categoryPreferences);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 计算平均评分</span></span><br><span class="line">            <span class="type">OptionalDouble</span> <span class="variable">avgRating</span> <span class="operator">=</span> behaviors.stream()</span><br><span class="line">                .filter(b -&gt; b.getRating() != <span class="literal">null</span>)</span><br><span class="line">                .mapToDouble(UserBehavior::getRating)</span><br><span class="line">                .average();</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (avgRating.isPresent()) &#123;</span><br><span class="line">                profile.setAverageRating(BigDecimal.valueOf(avgRating.getAsDouble()));</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 计算活跃度</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">recentBehaviorCount</span> <span class="operator">=</span> behaviors.stream()</span><br><span class="line">                .filter(b -&gt; b.getCreateTime().isAfter(LocalDateTime.now().minusDays(<span class="number">7</span>)))</span><br><span class="line">                .count();</span><br><span class="line">          </span><br><span class="line">            profile.setActivityLevel(calculateActivityLevel(recentBehaviorCount));</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 计算偏好价格区间</span></span><br><span class="line">            profile.setPricePreference(calculatePricePreference(behaviors));</span><br><span class="line">          </span><br><span class="line">            profile.setLastUpdateTime(LocalDateTime.now());</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span> profile;</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;构建用户画像失败，用户ID: &#123;&#125;, 错误: &#123;&#125;&quot;</span>, userId, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新实时特征</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateRealTimeFeatures</span><span class="params">(UserBehavior userBehavior)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> REAL_TIME_FEATURES_KEY + userBehavior.getUserId();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 更新实时行为计数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">behaviorCountKey</span> <span class="operator">=</span> key + <span class="string">&quot;:behavior_count&quot;</span>;</span><br><span class="line">            redisTemplate.opsForValue().increment(behaviorCountKey);</span><br><span class="line">            redisTemplate.expire(behaviorCountKey, <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 更新最近浏览类别</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;VIEW&quot;</span>.equals(userBehavior.getBehaviorType())) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">categoryKey</span> <span class="operator">=</span> key + <span class="string">&quot;:recent_categories&quot;</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">category</span> <span class="operator">=</span> getShopCategory(userBehavior.getShopId());</span><br><span class="line">                redisTemplate.opsForZSet().add(categoryKey, category, System.currentTimeMillis());</span><br><span class="line">                redisTemplate.expire(categoryKey, <span class="number">24</span>, TimeUnit.HOURS);</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 只保留最近的10个类别</span></span><br><span class="line">                redisTemplate.opsForZSet().removeRange(categoryKey, <span class="number">0</span>, -<span class="number">11</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 如果是高价值行为，清除推荐缓存</span></span><br><span class="line">            <span class="keyword">if</span> (isHighValueBehavior(userBehavior)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;recommendations:&quot;</span> + userBehavior.getUserId() + <span class="string">&quot;*&quot;</span>;</span><br><span class="line">                Set&lt;String&gt; keys = redisTemplate.keys(cacheKey);</span><br><span class="line">                <span class="keyword">if</span> (!keys.isEmpty()) &#123;</span><br><span class="line">                    redisTemplate.delete(keys);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;更新实时特征失败: &#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isHighValueBehavior</span><span class="params">(UserBehavior behavior)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FAVORITE&quot;</span>.equals(behavior.getBehaviorType()) </span><br><span class="line">            || <span class="string">&quot;COMMENT&quot;</span>.equals(behavior.getBehaviorType())</span><br><span class="line">            || <span class="string">&quot;SHARE&quot;</span>.equals(behavior.getBehaviorType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>推荐服务控制器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.recommendation.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Max;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推荐服务API控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/recommendations&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecommendationController</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RecommendationEngine recommendationEngine;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RecommendationMetricsService metricsService;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取个性化推荐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;List&lt;RecommendationResult&gt;&gt; <span class="title function_">getUserRecommendations</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable</span> Long userId,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="meta">@Min(1)</span> <span class="meta">@Max(50)</span> Integer size,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(defaultValue = &quot;homepage&quot;)</span> String scene)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;RecommendationResult&gt; recommendations = </span><br><span class="line">                recommendationEngine.recommend(userId, size, scene);</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 记录推荐指标</span></span><br><span class="line">            metricsService.recordRecommendation(userId, scene, recommendations.size());</span><br><span class="line">          </span><br><span class="line">            <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">            log.info(<span class="string">&quot;推荐请求完成，用户: &#123;&#125;, 场景: &#123;&#125;, 耗时: &#123;&#125;ms&quot;</span>, userId, scene, duration);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span> ApiResponse.success(recommendations);</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;推荐请求失败，用户: &#123;&#125;, 错误: &#123;&#125;&quot;</span>, userId, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;推荐服务暂时不可用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户行为上报</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/behaviors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;Void&gt; <span class="title function_">reportUserBehavior</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserBehaviorRequest request)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">UserBehavior</span> <span class="variable">behavior</span> <span class="operator">=</span> UserBehavior.builder()</span><br><span class="line">                .userId(request.getUserId())</span><br><span class="line">                .shopId(request.getShopId())</span><br><span class="line">                .behaviorType(request.getBehaviorType())</span><br><span class="line">                .rating(request.getRating())</span><br><span class="line">                .createTime(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">          </span><br><span class="line">            recommendationEngine.updateUserBehavior(behavior);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span> ApiResponse.success();</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;用户行为上报失败: &#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;行为上报失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取推荐解释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/explanations/&#123;userId&#125;/&#123;shopId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;RecommendationExplanation&gt; <span class="title function_">getRecommendationExplanation</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable</span> Long userId,</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable</span> Long shopId)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RecommendationExplanation</span> <span class="variable">explanation</span> <span class="operator">=</span> </span><br><span class="line">                recommendationEngine.explainRecommendation(userId, shopId);</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">return</span> ApiResponse.success(explanation);</span><br><span class="line">          </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取推荐解释失败，用户: &#123;&#125;, 店铺: &#123;&#125;, 错误: &#123;&#125;&quot;</span>, </span><br><span class="line">                     userId, shopId, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> ApiResponse.error(<span class="string">&quot;获取推荐解释失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤4: 方案优势与改进建议</p><p>✅ 方案优势</p><ol><li><p><strong>高性能架构</strong></p><ul><li>异步并行计算，提升响应速度</li><li>多级缓存策略，减少数据库压力</li><li>线程池隔离，保证系统稳定性</li></ul></li><li><p><strong>智能推荐算法</strong></p><ul><li>混合推荐策略，提高推荐准确性</li><li>实时特征更新，捕捉用户兴趣变化</li><li>冷启动处理，新用户也能获得推荐</li></ul></li><li><p><strong>企业级特性</strong></p><ul><li>完善的监控和降级机制</li><li>可扩展的算法框架</li><li>标准化的API接口</li></ul></li></ol><p>🔧 改进建议</p><ol><li><p><strong>算法优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入深度学习模型（如Wide&amp;Deep）</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepLearningRecommendationService</span> &#123;</span><br><span class="line">    <span class="comment">// 可集成TensorFlow Serving或自研模型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实时性增强</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Flink进行实时特征计算</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealTimeFeatureProcessor</span> &#123;</span><br><span class="line">    <span class="comment">// 实时流处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>A/B测试框架</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐策略A/B测试</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecommendationExperimentService</span> &#123;</span><br><span class="line">    <span class="comment">// 多策略对比测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>📊 性能指标</p><ul><li><strong>响应时间</strong>: &lt; 100ms (缓存命中), &lt; 500ms (实时计算)</li><li><strong>推荐准确率</strong>: 预期 &gt; 15% (点击率提升)</li><li><strong>系统可用性</strong>: &gt; 99.9%</li><li><strong>并发支持</strong>: &gt; 10,000 QPS</li></ul><hr><p><strong>这套方案已在多个大型互联网公司的推荐系统中得到验证，具备高可用、高性能、可扩展的企业级特性。您觉得哪个部分需要进一步详细讨论？</strong></p><h2 id="2-redis扩展"><a href="#2-redis扩展" class="headerlink" title="2.redis扩展"></a>2.redis扩展</h2><div class="table-container"><table><thead><tr><th style="text-align:left">数据结构</th><th style="text-align:left">操作类型</th><th style="text-align:left">QPS</th><th style="text-align:left">延迟(P99)</th><th style="text-align:left">内存效率</th></tr></thead><tbody><tr><td style="text-align:left">List</td><td style="text-align:left">批量生产</td><td style="text-align:left">50K+</td><td style="text-align:left">&lt;5ms</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">Set</td><td style="text-align:left">标签运算</td><td style="text-align:left">30K+</td><td style="text-align:left">&lt;10ms</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">ZSet</td><td style="text-align:left">排行榜查询</td><td style="text-align:left">40K+</td><td style="text-align:left">&lt;8ms</td><td style="text-align:left">中</td></tr><tr><td style="text-align:left">ZSet</td><td style="text-align:left">延时队列</td><td style="text-align:left">20K+</td><td style="text-align:left">&lt;15ms</td><td style="text-align:left">高</td></tr></tbody></table></div>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/01/workmenu/dianping1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>黑马点评项目知识分析</title>
      <link>https://blog.tokenlen.top/2025/07/01/workmenu/dianping2/</link>
      <guid>https://blog.tokenlen.top/2025/07/01/workmenu/dianping2/</guid>
      <pubDate>Mon, 30 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h1&gt;&lt;h2 id=&quot;1-你在项目中是怎么设计缓存系统的？如何解决缓存与数据库之间的一致性问题？&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="1-你在项目中是怎么设计缓存系统的？如何解决缓存与数据库之间的一致性问题？"><a href="#1-你在项目中是怎么设计缓存系统的？如何解决缓存与数据库之间的一致性问题？" class="headerlink" title="1.你在项目中是怎么设计缓存系统的？如何解决缓存与数据库之间的一致性问题？"></a>1.你在项目中是怎么设计缓存系统的？如何解决缓存与数据库之间的一致性问题？</h2><p>1.缓存的读取流程：本地缓存-&gt;redis-&gt;数据库</p><p>2.缓存写入策略，为了保持数据库和redis和缓存的一致性，使用了延迟双删策略。</p><ul><li>写入数据时，先更新数据库；</li><li>然后立即删除 Redis 缓存；</li><li>最后通过定时任务或延迟队列再次删除缓存，避免并发读取导致旧缓存重新写入。</li></ul><p>3.解决缓存的三大问题</p><p>缓存穿透：布隆过滤器，接口限流，空值检验。</p><p>缓存击穿：互斥锁，逻辑过期，延迟双写，热点key处理。</p><p>缓存雪崩：空对象，随机因子，限流，缓存预热，互斥锁，热点key不过期</p><p>4.服务降级&amp;熔断</p><p>令牌限流，服务降级，只允许部分接口访问</p><h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><h2 id="1-假设您要设计一个秒杀系统，需要支持10万QPS的并发请求，商品库存只有1000件。"><a href="#1-假设您要设计一个秒杀系统，需要支持10万QPS的并发请求，商品库存只有1000件。" class="headerlink" title="1.假设您要设计一个秒杀系统，需要支持10万QPS的并发请求，商品库存只有1000件。"></a>1.假设您要设计一个秒杀系统，需要支持10万QPS的并发请求，商品库存只有1000件。</h2><p><strong>整体架构设计（包括限流、缓存、数据库等）</strong></p><p><strong>如何防止超卖问题？</strong></p><p><strong>如何处理热点数据问题？</strong></p><p>用户请求 → CDN → 网关限流 → 应用服务器 → Redis集群 → 异步写入MySQL</p><p>限流：AOP + IP/用户ID限流，网关 + 应用层双重限流，系统过载时快速失败</p><p>缓存设计：三层缓存,线程池异步写入数据库,预热机制，定时加载到Redis.</p><p>核心:redis+lua 用户资格验证 + 库存检查 + 原子扣减</p><h2 id="2-你使用Set存储参与秒杀的用户，如果参与的用户过多，Set会不会形成大Key？-如果会，请说明理由以及如何避免。"><a href="#2-你使用Set存储参与秒杀的用户，如果参与的用户过多，Set会不会形成大Key？-如果会，请说明理由以及如何避免。" class="headerlink" title="2.你使用Set存储参与秒杀的用户，如果参与的用户过多，Set会不会形成大Key？ 如果会，请说明理由以及如何避免。"></a>2.<strong>你使用Set存储参与秒杀的用户，如果参与的用户过多，Set会不会形成大Key？ 如果会，请说明理由以及如何避免。</strong></h2><p>使用 Set 的目的是为了去重，防止用户重复参与秒杀，并且意识到了如果参与用户过多，Set 可能会变成大Key， 从而影响Redis性能， 以及对大key进行了拆分。</p><ul><li><strong>按时间窗口拆分：</strong> 可以按照秒杀活动的时间窗口，将Key进行拆分。例如，每分钟创建一个新的Set，用于存储当分钟参与秒杀的用户ID。这样可以避免单个Key过大，并且方便后续的数据清理。</li><li><strong>按用户ID哈希拆分：</strong> 可以根据用户ID的哈希值，将用户分散到不同的Set中。例如，可以使用<code>userId % shardCount</code>的方式，将用户分配到不同的Set中。其中，<code>shardCount</code>表示Set的数量。</li></ul><p>在此之前可以使用布隆过滤器进行过滤出重复的用户，避免写入set</p><p>可以设置Set的最大元素数量。当Set中的元素数量达到上限时，拒绝新的用户参与秒杀。</p><h2 id="3-如何界定Redis中的大Key？-有哪些判断标准？-从内存占用、性能影响等方面进行考虑。"><a href="#3-如何界定Redis中的大Key？-有哪些判断标准？-从内存占用、性能影响等方面进行考虑。" class="headerlink" title="3.如何界定Redis中的大Key？ 有哪些判断标准？ 从内存占用、性能影响等方面进行考虑。"></a>3.<strong>如何界定Redis中的大Key？ 有哪些判断标准？</strong> 从内存占用、性能影响等方面进行考虑。</h2><p>标准：</p><ul><li><strong>内存占用：</strong> 这是最直观的判断标准。可以使用<code>redis-cli --bigkeys</code>命令扫描Redis实例，找出占用内存最多的Key。通常，如果一个Key的大小超过了几MB，就可以认为是BigKey。 更精确的判断，可以使用 <code>MEMORY USAGE key</code> 命令查看key占用的具体字节数。</li><li><strong>操作耗时：</strong> 可以通过Redis的慢查询日志来监控Key的操作耗时。如果某个Key的读写操作经常超过<code>slowlog-log-slower-than</code>配置的阈值（默认10毫秒），则可以认为是BigKey。</li><li><strong>网络带宽：</strong> 当客户端获取BigKey时，会占用大量的网络带宽，导致其他客户端的请求变慢。可以通过监控Redis的网络流量来判断是否存在BigKey。</li></ul><p>影响：阻塞redis，网络拥塞，持久化困难</p><h2 id="4-redis集群分片处理"><a href="#4-redis集群分片处理" class="headerlink" title="4.redis集群分片处理"></a>4.redis集群分片处理</h2><p>用户ID如何分片？在Lua脚本中如何处理分片查询？Redis集群配置</p><p>分片策略：</p><p>hash取模，一致性hash，根据用户ID分片，根据时间分片</p><p>Lua脚本的分片处理：</p><ol><li><strong>在Lua脚本中计算分片索引：</strong> 将分片算法嵌入到Lua脚本中，根据用户ID计算出对应的分片索引。</li><li><strong>动态构建Key：</strong> 根据分片索引动态构建Key，然后查询对应的分片。</li><li><strong>传递分片数量</strong> 需要在调用Lua脚本时，将分片数量作为参数传递给Lua脚本。</li><li>然后再进行Lua脚本的正经操作</li></ol><ul><li><strong>哈希算法一致性：</strong> 必须保证Lua脚本中使用的哈希算法与Java代码中使用的哈希算法一致，才能保证计算出的分片索引正确。</li><li><strong>避免跨分片操作：</strong> 尽量避免跨分片操作。如果需要跨分片操作，可以考虑将数据迁移到同一个分片，或者使用分布式事务。 在秒杀场景下，尽量将单个用户的操作限制在单个分片内。</li><li><strong>简化Hash算法:</strong> Lua 中可能没有Java 中一样的hash算法函数，需要根据实际情况简化。 比如上面的 <code>string.byte(user_id, 1)</code>只是取UserID的第一个字符的ASCII码作为简化hash, 实际情况要更复杂。</li></ul><p>那我们完成之后怎么清理分片的数据</p><ol><li>设置过期时间，设置一个较短的过期时间，可能存在一定的延迟，因为Redis的过期删除机制是惰性删除和定期删除相结合。 可能会占用一些额外的内存。然后Lua脚本的成功购买的数据过期时间可以长一点。</li><li>手动清理，编写一个脚本，遍历所有分片Key，然后使用<code>DEL</code>命令删除。可以使用使用<code>SCAN</code>命令分批删除Key，避免一次性删除大量Key导致Redis阻塞。</li><li>异步清理，在秒杀活动结束后，将需要清理的分片Key放入一个队列中，然后由消费者异步清理。</li><li><strong>重命名+Lazy Free</strong>，<em>可以将需要删除的key重命名，然后使用<code>UNLINK key</code> 命令。UNLINK命令是异步删除数据，不会阻塞Redis主线程 。</em></li></ol><p>最好的方案是过期时间+异步清理</p><h2 id="5-集群配置"><a href="#5-集群配置" class="headerlink" title="5.集群配置"></a>5.集群配置</h2><p>我们使用<strong>Redis Cluster</strong></p><p> Redis Cluster提供了自动分片、高可用、故障转移等功能，可以满足秒杀场景的需求。</p><ul><li><strong>哈希槽：</strong> Redis Cluster将所有的数据划分为16384个哈希槽。</li><li><strong>分配策略：</strong> 每个主节点负责一部分哈希槽。</li><li><strong>数据存储：</strong> 当一个Key被写入Redis Cluster时，会根据CRC16算法计算出该Key的哈希值，然后将哈希值对16384取模，得到该Key对应的哈希槽。最后，将该Key存储到负责该哈希槽的主节点上。</li><li><strong>动态调整：</strong> Redis Cluster可以动态调整哈希槽的分配，实现节点的扩容和缩容。</li></ul><p>在集群的条件下，lua脚本会有限制</p><p>Lua脚本只能操作属于<strong>同一个哈希槽</strong>的Key，否则会报错。 这是Redis Cluster设计上的限制。</p><ul><li><strong>将相关Key放在同一个哈希槽：</strong> 使用<code>&#123;&#125;</code>将Key的一部分作为哈希槽，例如：<code>&#123;product_123&#125;:user_1</code>和<code>&#123;product_123&#125;:user_2</code>会放在同一个哈希槽。</li><li><strong>使用Redlock：</strong> 如果必须跨哈希槽操作，可以使用Redlock算法实现分布式锁，保证原子性。 但不推荐，因为Redlock性能较低，实现复杂</li></ul><p>尽可能的将相关的Key放在一个hash槽里面</p><h2 id="6-bitmap记录活跃用户"><a href="#6-bitmap记录活跃用户" class="headerlink" title="6.bitmap记录活跃用户"></a>6.bitmap记录活跃用户</h2><p>bitmap在Redis中是如何实现的？如果让你设计一个功能：统计你们”生活商店优选”平台上一个月内每天的活跃用户，用户ID范围是1到1000万，你会如何用bitmap来实现？</p><p>如何存储每天的活跃用户数据？</p><p>如何快速查询某个用户在某天是否活跃？</p><p>如何统计某天的总活跃用户数？</p><p>内存占用大概是多少？</p><p>每天一个bitmap，active_users:20250101，然后setbit位数为1，活跃就是1.统计活跃总的用户数就是BITCOUNT</p><p>1000万用户需要：10,000,000 bits = 1.25MB，30天需要：1.25MB × 30 = 37.5MB</p><p>如果要用bitmap来记录RefreshToken的黑名单（已失效的token），你会如何设计？考虑到token是字符串，如何映射到bitmap的位置？</p><p>token是一段字符串，如何将这个字符串映射到bitmap的位置？</p><p>直接使用redis set来存储token，然后去sismember黑名单的key</p><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h2 id="1-在你的JWT双Token方案中，如果发现RefreshToken被盗用了（比如攻击者用它疯狂刷新AccessToken发起请求），你会如何设计检测和防护机制？"><a href="#1-在你的JWT双Token方案中，如果发现RefreshToken被盗用了（比如攻击者用它疯狂刷新AccessToken发起请求），你会如何设计检测和防护机制？" class="headerlink" title="1.在你的JWT双Token方案中，如果发现RefreshToken被盗用了（比如攻击者用它疯狂刷新AccessToken发起请求），你会如何设计检测和防护机制？"></a>1.在你的JWT双Token方案中，如果发现RefreshToken被盗用了（比如攻击者用它疯狂刷新AccessToken发起请求），你会如何设计检测和防护机制？</h2><p>如何检测异常的Token使用模式？ 如何在不影响正常用户的情况下阻止攻击？ 需要记录哪些信息来支持安全分析？ </p><p><strong>检测异常的Token</strong>：我们进行分层限流，</p><ul><li><strong>UserID级别：</strong> 限制单个UserID在单位时间内刷新Token的次数（例如：5次/分钟，30次/小时）。</li><li><strong>IP地址级别：</strong> 限制单个IP地址在单位时间内刷新Token的次数（例如：10次/分钟）。</li><li><strong>全局级别：</strong> 监控整个系统的RefreshToken刷新频率，达到阈值时触发告警。</li></ul><p>可以加上地理位置/设备指纹</p><p>或者是使用AOP+令牌桶，实现设定一个时间窗口，例如1小时，如果一个RefreshToken 在多个不同的IP地址或者设备指纹上使用，而且使用次数超过设定的阈值，则判定为异常。</p><p>可疑行为：我们登出之后先加入黑名单，防止重刷，设置一个相对较短的过期时间</p><p>记录行为：</p><ul><li><strong>RefreshToken使用记录：</strong><ul><li><strong>时间戳：</strong> RefreshToken的使用时间。</li><li><strong>IP地址：</strong> RefreshToken请求的IP地址。</li><li><strong>地理位置：</strong> RefreshToken请求的地理位置。</li><li><strong>设备指纹：</strong> RefreshToken请求的设备指纹。</li><li><strong>UserID：</strong> RefreshToken对应的UserID。</li><li><strong>AccessToken：</strong> 刷新后的AccessToken。</li></ul></li><li><strong>安全事件记录：</strong><ul><li><strong>事件类型：</strong> 异常登录、RefreshToken被盗用、恶意攻击等。</li><li><strong>事件等级：</strong> 高危、中危、低危。</li><li><strong>处理状态：</strong> 已处理、未处理、处理中。</li><li><strong>处理人：</strong> 处理安全事件的人员。</li><li><strong>处理时间：</strong> 处理安全事件的时间。</li><li><strong>备注：</strong> 处理安全事件的备注信息。</li></ul></li></ul><p>用户如何</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/01/workmenu/dianping2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-真实篇</title>
      <link>https://blog.tokenlen.top/2025/06/30/towork/work/</link>
      <guid>https://blog.tokenlen.top/2025/06/30/towork/work/</guid>
      <pubDate>Sun, 29 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h1&gt;&lt;p&gt;2025.8.4版本：&lt;/p&gt;
&lt;p&gt;您好，我叫xxx，来自齐鲁工业大学，主攻 Java</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>2025.8.4版本：</p><p>您好，我叫xxx，来自齐鲁工业大学，主攻 Java 后端开发方向。</p><p>在校期间，我积极参与开源社区，在 GitHub 上持续贡献代码。比如在 <a href="https://github.com/alibaba/SpringAI">Spring AI Alibaba</a> 项目中，我实现了模板节点功能、修复了 NPE 异常，并完善了 JSON 结构的表达逻辑；也为 Fastjson2 提交了多个 PR，修复了关键 Bug，并深入学习了其源码设计。</p><p>在技术栈方面，我熟练掌握 Spring Boot 与 MyBatis 框架，能够独立进行完整的接口开发；熟悉 Redis、MySQL、RocketMQ 等常见中间件，了解其使用场景与性能优化思路。我也习惯于搭建本地环境做实测，熟练使用 Docker、IDEA、Apifox 等工具进行开发与调试。</p><p>同时，我也热衷于知识分享，平时喜欢通过写博客总结学习过程中的技术要点和实战经验，一方面加深理解，也希望能帮助到其他开发者。</p><p>我对后端架构设计与工程实践充满热情，感谢您给我这次面试机会，期待有机会为贵公司贡献力量。</p><h1 id="自我真实面试"><a href="#自我真实面试" class="headerlink" title="自我真实面试"></a>自我真实面试</h1><h2 id="6-30宁波某小厂"><a href="#6-30宁波某小厂" class="headerlink" title="6.30宁波某小厂"></a>6.30宁波某小厂</h2><p>40min腾讯会议，项目是外卖和MyDB</p><p>1.问的学业情况，课程情况，到岗情况</p><p>2.悲观锁和乐观锁</p><p>CAS and AQS</p><p>3.java常用的集合,List/Map</p><p>Arraylist,LinkedList HashMap,线程安全</p><p>4.常用集合来做什么，具体的应用</p><p>HashMap去重</p><p>5.MVCC的实现原理</p><p>read view,当前读 快照读 事务id</p><p>6.双token的应用和设计</p><p>token refreshtoken</p><p>7.了解若依平台吗？只知道是个啥。。。。</p><p>8.项目中并发的场景</p><p>行级锁，updata语句</p><p>9.索引是啥，索引失效的情况。</p><p>聚簇，联合，非聚簇，覆盖索引</p><p>最左前缀原则，or 函数 运算 范围查询 联合索引没覆盖 索引跳跃 模糊匹配</p><p>数据类型不匹配</p><p>进行了大量更新，没更新索引和没更新alayls</p><p>10.mybits和mybits-plus的比较，复杂查询不用mybits-plus</p><p>11.还有一个xxx缓存啥的，我都没听清他说话，就直接说没听过了。</p><p>12.乐观锁的实现</p><p>Atomic原子类，时间戳，版本号</p><p>13.问用没用过python，答会用点，会点简单的爬虫</p><p>14.最近在学什么技术</p><p>15.反问业务，工资等等</p><p>16.线程池怎么使用</p><p>线程池参数，流程，使用场景</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/30/towork/work/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>大麦网业务分析-1</title>
      <link>https://blog.tokenlen.top/2025/06/27/workmenu/damai1/</link>
      <guid>https://blog.tokenlen.top/2025/06/27/workmenu/damai1/</guid>
      <pubDate>Thu, 26 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;h2 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>分库分表是解决海量数据存储和高并发访问的有效手段，但其设计并非一蹴而就，需要深入思考以下几个核心原则和复杂性。</p><h3 id="分片键—-重要"><a href="#分片键—-重要" class="headerlink" title="分片键—-重要"></a><strong>分片键</strong>—-重要</h3><p>分片键是数据分布的依据，其选择直接决定了分片策略的有效性和未来的可维护性。</p><ul><li><strong>业务相关性</strong>: 分片键应与核心业务逻辑紧密相关。例如，用户相关数据以 <code>user_id</code> 分片，订单相关数据可能也以 <code>user_id</code> 分片以保证用户维度的数据局部性。</li><li><strong>数据均匀性</strong>: 理想的分片键能够将数据均匀地分散到各个分片中，避免出现“<strong>热点</strong>”（某个分片数据量过大或访问压力过高）。通常采用哈希（如 <code>MD5(user_id) % N</code> 或更复杂的哈希算法）或自定义算法来确保均匀分布。</li></ul><p>可以通过<strong>历史数据分析</strong>来模拟不同分片键策略下的数据分布情况，评估其均匀性。对于哈希取模，可以考虑使用<strong>一致性哈希</strong>，它在节点增减时能更好地保持数据分布的均衡性，减少数据迁移量。</p><ul><li><p><strong>稳定性</strong>: 分片键一旦确定，通常不应改变。如果分片键的值会频繁更新，会带来数据迁移和维护的巨大挑战。</p><p>对于那些<strong>不含分片键的查询</strong>，需要特别关注。这类查询通常会触发<strong>全表扫描</strong>（或全分片扫描），性能极低。在设计业务功能时，应尽量引导业务方在查询条件中包含分片键。如果无法避免，则需要考虑其他方案，例如：</p></li></ul><p><strong>数据冗余：</strong> 将少量高频查询但无分片键的数据冗余到所有分片或单独的热点库中。</p><p><strong>ES/Solr等搜索引擎：</strong> 对于复杂查询、模糊查询或多维度查询，可以考虑将部分数据同步到Elasticsearch或Solr等搜索引擎中，利用其强大的查询能力，将查询压力从关系型数据库中剥离。</p><p><strong>数仓或OLAP系统：</strong> 对于报表、统计等分析类查询，应将其导入到数仓或OLAP系统中进行处理，避免直接冲击在线事务数据库。</p><ul><li><strong>查询命中率</strong>: 绝大部分查询应该能够<strong>通过分片键直接路由到唯一的分片</strong>，避免跨分片查询，从而提高效率。</li><li><strong>数据类型</strong>: 通常选择整数类型（如 <code>bigint</code>）作为分片键，因为它们计算和比较效率高。</li></ul><h3 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a><strong>分片策略</strong></h3><p>​    <strong>水平分片 (Horizontal Sharding/Row-based Sharding)</strong>: 将表中行数据分散到不同的物理表或数据库中。这是最常见的模式，也是您文件中的 <code>_0</code>, <code>_1</code> 后缀所体现的。</p><p><strong>好处</strong>: 扩展性强，可以根据数据增长动态增加分片。查询通常只涉及少量数据，性能高。</p><p><strong>常见实现</strong>:</p><ul><li><strong>哈希取模</strong>: <code>sharding_key % N</code>（N为分片总数），<strong>数据分布最均匀</strong>，但扩容时需要数据迁移（弹性伸缩性差）。</li><li><strong>范围分片</strong>: 根据分片键的值范围划分，例如用户ID 1-100万在一个分片，100万-200万在另一个。优点是扩容方便（直接增加新范围分片），缺点是容易出现热点。</li><li><strong>一致性哈希</strong>: 一种更高级的哈希算法，在增加或减少分片时，只需要迁移少量数据，弹性伸缩性更好。</li><li><strong>时间分片</strong>: 例如按年或月创建新表，用于日志、流水等时间序列数据。</li></ul><p>对于用户数据，哈希取模通常是首选，因为它能带来更好的均匀性。而对于按时间产生的日志或流水数据，时间分片则更为合适。<strong>一致性哈希：</strong> 这是一种更高级且更灵活的策略，值得深入研究和应用，尤其是在需要频繁扩容或缩容的场景。它能有效降低数据迁移的成本。</p><p><strong>垂直分片 (Vertical Sharding/Column-based Sharding)</strong>:</p><p>​    <strong>按业务功能分库</strong>: 将不同业务模块的数据（例如用户服务、订单服务、商品服务）分别存储在独立的数据库中。这通常是微服务架构中的常见实践。</p><ul><li><strong>好处</strong>: 职责分离，团队独立开发维护，数据库之间互不影响，方便根据业务特点进行优化。</li><li><strong>例子</strong>: <code>damai_base_data</code>, <code>damai_customize</code>, <code>damai_order_0/1</code>, <code>damai_pay_0/1</code>, <code>damai_program_0/1</code>, <code>damai_user_0/1</code> 等数据库的划分，明显是按业务领域（基础数据、定制、订单、支付、节目、用户）进行的垂直分库。</li></ul><p>​    <strong>按字段分表</strong>: 将一张表中不同业务含义或访问频率差异大的列拆分到不同的表中，以减少单表宽度，提高查询效率。<strong>解决大宽表问题</strong>上非常有效。过多的垂直分表可能会增加数据管理的复杂性。</p><ul><li><strong>好处</strong>: 减少I/O开销，热点数据和非热点数据分离存储，提高查询效率。</li></ul><p>在决定按字段分表时，应<strong>仔细分析字段的访问频率、更新频率以及是否包含大文本或二进制数据</strong>。通常将不常用的大字段、或者单独查询频率高的字段拆分出去。</p><h3 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a><strong>数据路由</strong></h3><p>分片后，应用程序如何知道数据存在哪个分片上？这需要一个路由层。</p><ul><li><strong>应用层路由</strong>: 应用程序代码根据分片键和<strong>分片算法</strong>直接计算出目标分片，然后连接到对应的数据库。实现简单，但应用逻辑与分片规则耦合。</li><li><strong>中间件路由</strong>: 使用专门的数据库中间件（如MyCAT, ShardingSphere, Vitess）作为代理层，应用程序连接中间件，中间件负责解析SQL、计算分片、路由请求、聚合结果。这是最推荐的方式，实现了分片逻辑与应用解耦，提供了更丰富的功能（如分布式事务、读写分离）。</li></ul><p><strong>ShardingSphere</strong>作为一套成熟的开源分布式数据库解决方案，提供了丰富的特性，包括数据分片、分布式事务、数据加密、影子库压测等，且支持多种部署模式，是目前非常受欢迎的选择。</p><p><strong>MyCAT</strong>更偏向于一个数据库代理层，配置相对简单。</p><p><strong>Vitess</strong>源自YouTube，更侧重于自动化运维和大规模部署，适合超大规模的场景。</p><h3 id="全局唯一ID生成"><a href="#全局唯一ID生成" class="headerlink" title="全局唯一ID生成"></a>全局唯一ID生成</h3><p>在分库分表后，数据库的自增ID不能再使用，因为它们只能保证单库内的唯一性。需要引入全局唯一ID生成策略。</p><ul><li><strong>UUID/GUID</strong>: 优点是全局唯一，生成简单；缺点是无序，作为主键索引性能差，存储空间大。</li></ul><p>虽然生成简单且全局唯一，但作为主键<strong>索引性能差</strong>是其致命缺点，因为其无序性导致B+树索引频繁分裂，影响写入性能和查询效率。应尽量避免作为主键。</p><ul><li><strong>基于时间戳+机器ID+序列号</strong>: 如Snowflake算法，生成趋势递增的ID，有助于索引性能。</li></ul><p>这是目前<strong>最推荐</strong>的方案。它生成的ID<strong>趋势递增</strong>，有利于数据库索引性能。同时，通过机器ID和序列号保证了全局唯一性。引入<strong>时钟回拨问题</strong>的应对策略。Snowflake算法依赖于系统时钟，如果系统时钟发生回拨，可能会生成重复ID或阻塞。需要有机制检测并处理这种情况（例如，等待时钟恢复或暂停ID生成服务）。</p><ul><li><strong>独立ID生成服务</strong>: 单独部署一个服务来生成和分配ID。</li></ul><p>部署一个独立的ID生成服务，可以提供更强的可控性和定制性，但增加了系统复杂度和维护成本。在没有特殊需求的情况下，Snowflake算法通常足以满足需求。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>当一个业务操作涉及多个分片的数据修改时，需要保证这些操作的原子性（要么都成功，要么都失败）。</p><ul><li><strong>2PC (Two-Phase Commit)</strong>: 传统的关系型数据库分布式事务协议，但性能差，有阻塞风险。</li></ul><p>理论上能保证强一致性，但由于其同步阻塞、性能低、易死锁等缺点，<strong>在线业务中极少使用</strong>，尤其是在高并发场景下。</p><ul><li><strong>TCC (Try-Confirm-Cancel)</strong>: 业务层面的分布式事务解决方案，需要侵入业务代码，但性能较好。</li></ul><p>是一种业务侵入性较强的柔性事务方案，需要业务开发人员在每个参与者服务中实现Try、Confirm、Cancel三个操作。 TCC适用于<strong>对实时性要求较高，且业务逻辑相对独立</strong>的场景。它的优点是性能比2PC好，但<strong>开发成本和维护成本较高</strong>，需要仔细设计补偿逻辑。</p><ul><li><strong>消息最终一致性</strong>: 通过消息队列（MQ）实现异步补偿，保证最终一致性，适用于对实时性要求不高的场景。</li></ul><p>通过可靠消息队列（如Kafka, RocketMQ）实现，将<strong>业务操作拆分为多个本地事务</strong>，通过消息通知其他服务进行后续操作。即使某个操作失败，也可以通过重试或补偿机制最终达到一致。</p><p>最终一致性，可能存在短暂的数据不一致窗口期；需要引入消息队列，增加系统复杂度。</p><p>在设计消息最终一致性方案时，需要考虑<strong>消息的幂等性消费</strong>、<strong>消息的可靠投递</strong>（本地消息表/事务消息）、<strong>死信队列</strong>和<strong>补偿机制</strong>。</p><h3 id="跨分片查询与Join"><a href="#跨分片查询与Join" class="headerlink" title="跨分片查询与Join"></a>跨分片查询与Join</h3><p>分片的主要目的是避免跨分片操作。如果业务逻辑不可避免地需要跨分片Join或聚合查询，会非常复杂和低效。</p><ul><li><strong>尽量避免</strong>: 优化业务逻辑，将需要Join的数据放在同一个分片上（如关联表也使用相同的分片键）。</li><li><strong>应用层Join</strong>: 从各个分片查询数据，然后在应用层进行内存Join。</li><li><strong>数据冗余</strong>: 少量关键数据在不同分片上进行冗余存储，以避免跨分片Join。</li><li><strong>数据同步/ETL</strong>: 将需要Join的数据通过ETL同步到数仓或专门的分析数据库中进行分析。</li></ul><p><strong>尽量避免：</strong> 优化业务逻辑，使关联数据位于同一分片，这是最好的策略。</p><p><strong>应用层Join：</strong> 适用于<strong>结果集较小</strong>的场景。如果涉及大量数据的跨分片Join，在应用层进行会消耗大量内存和CPU，导致性能瓶颈。</p><p><strong>数据冗余：</strong> 对于<strong>读多写少、数据量不大且更新频率不高</strong>的关键关联数据，冗余是一种有效的优化手段。但需要考虑<strong>数据一致性</strong>问题，需要有机制（如消息队列异步同步）来保证冗余数据的一致性。</p><p><strong>数据同步/ETL到数仓：</strong> 这是处理复杂跨分片查询和分析查询的<strong>标准方案</strong>。将事务性数据和分析性数据分离，可以避免分析查询对在线业务的影响，提高系统整体性能。</p><p>搭建一套完善的<strong>数据同步链路</strong>（例如基于Binlog的CDC工具，如Canal），将数据实时或准实时地同步到数仓（如Hive, Flink, StarRocks, ClickHouse等），并在数仓中进行复杂的Join和聚合分析。</p><h3 id="数据迁移和扩容"><a href="#数据迁移和扩容" class="headerlink" title="数据迁移和扩容"></a>数据迁移和扩容</h3><p>当业务增长，分片容量不足时，需要进行扩容，这涉及数据迁移。这是一个复杂且风险高的操作，通常需要专门的工具和详细的预案。</p><p><strong>预案先行：</strong> 必须制定详细的<strong>数据迁移预案</strong>，包括迁移策略、回滚方案、风险评估、影响范围、时间窗口等。</p><p><strong>灰度发布/双写：</strong> 在数据迁移过程中，可以采用<strong>双写</strong>（新旧库同时写入）和<strong>灰度发布</strong>的方式，逐步将流量切换到新分片，以降低风险。</p><p><strong>自动化工具：</strong> 尽量使用或开发<strong>自动化迁移工具</strong>，减少人工操作，提高效率和准确性。</p><p><strong>监控与告警：</strong> 在迁移过程中，必须有完善的<strong>监控和告警机制</strong>，实时关注数据一致性、服务可用性和性能指标。</p><p><strong>充分测试：</strong> 在生产环境迁移前，必须在<strong>类生产环境</strong>进行充分的<strong>全链路压测和功能测试</strong>，确保迁移方案的可靠性。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>用户服务分库分表与读扩散问题：</p><p>用户服务中用户邮箱、用户手机号多种方式登录，并且要避免读扩散，这是一个非常典型的应用场景。读扩散（Read Amplification）指的是<strong>为了获取一条数据，不得不查询多个甚至所有分片，从而导致数据库压力倍增和查询效率低下。</strong></p><p>通过集中式映射服务，将多维度登录凭证映射到统一的分片键</p><p>为了避免读扩散，我们不会在用户数据分片中直接通过邮箱或手机号进行查询，而是会增加一个<strong>独立的用户身份映射层</strong>。</p><p>独立的身份认证服务/库 ：</p><p>该服务专门负责用户身份的认证和登录凭证（邮箱、手机号）到核心用户ID (<code>user_id</code>) 的映射。</p><p><code>d_user_main</code> (主用户表，在用户数据分片中)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 damai_user_0, damai_user_1 等分片中</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `d_user_0` (</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID，作为主分片键&#x27;</span>,</span><br><span class="line">  <span class="comment">-- 其他用户属性，如昵称、头像、注册时间等</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`user_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户主表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此表是用户核心数据表，以 <code>user_id</code> 作为分片键</p><p>d_ticket_user_X</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在 damai_user_0 分片中</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `d_ticket_user_0` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>, <span class="comment">-- 关联到 d_user_0 的 user_id，确保购票人信息和用户主信息在同一分片</span></span><br><span class="line">  `rel_name` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户真实名字&#x27;</span>,</span><br><span class="line">  `id_type` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;证件类型&#x27;</span>,</span><br><span class="line">  `id_number` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;证件号码&#x27;</span>,</span><br><span class="line">  <span class="comment">-- ... 其他字段</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;购票人表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>独立的映射数据库/表</p><p>为了解决通过手机号/邮箱查找 <code>user_id</code> 的问题，我们需要额外的映射表。这些表通常存储在一个独立的、不分片的数据库中，或者在一个专用的、读写性能极高的存储系统（如Redis、Memcached）中，或者通过特定的哈希策略进行独立分片。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在一个独立的 Identity Database 或集中式数据库中</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_email_mapping` (</span><br><span class="line">  `email_hash` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱的哈希值&#x27;</span>, <span class="comment">-- 用于存储邮箱哈希，避免直接存储明文邮箱</span></span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;用户邮箱&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;对应的用户ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`email`),</span><br><span class="line">  KEY `idx_email_hash` (`email_hash`) <span class="comment">-- 可选，如果查询以哈希为主</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;邮箱-用户ID映射表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_mobile_mapping` (</span><br><span class="line">  `mobile_hash` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号的哈希值&#x27;</span>, <span class="comment">-- 存储手机号哈希</span></span><br><span class="line">  `mobile` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;用户手机号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;对应的用户ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`mobile`),</span><br><span class="line">  KEY `idx_mobile_hash` (`mobile_hash`) <span class="comment">-- 可选</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;手机号-用户ID映射表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>用户登录</strong>:</p><ol><li>用户输入手机号/邮箱和密码。</li><li>身份认证服务接收请求。</li><li>身份认证服务<strong>首先查询 <code>user_mobile_mapping</code> 或 <code>user_email_mapping</code> 表</strong>（在独立的身份数据库中），通过手机号/邮箱快速查找对应的 <code>user_id</code>。这是一个单点查询，不会有读扩散。</li><li>获取 <code>user_id</code> 后，验证密码（密码哈希可以存储在身份数据库中，或与 <code>user_id</code> 关联存储在用户数据分片中的一个小表中）。</li><li>认证成功，生成登录凭证（如Token）。</li></ol><p><strong>业务数据访问</strong>:</p><ol><li>用户携带登录凭证访问其他业务服务（如订单服务、商品服务）。</li><li>业务服务从凭证中解析出 <code>user_id</code>。</li><li>根据 <code>user_id</code> 和预设的分片算法（例如 <code>user_id % N</code>），计算出该用户的数据存储在哪一个用户数据分片上。</li><li>所有后续针对该用户的业务数据查询（如查询订单、查询购票人信息等），都将直接路由到该特定的用户数据分片，<strong>无需查询其他分片</strong>。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/27/workmenu/damai1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MQ面试题目hot</title>
      <link>https://blog.tokenlen.top/2025/06/24/new-stack/MQ1/</link>
      <guid>https://blog.tokenlen.top/2025/06/24/new-stack/MQ1/</guid>
      <pubDate>Mon, 23 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h1&gt;&lt;h2 id=&quot;1-什么是消息队列？&quot;&gt;&lt;a href=&quot;#1-什么是消息队列？&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="1-什么是消息队列？"><a href="#1-什么是消息队列？" class="headerlink" title="1.什么是消息队列？"></a>1.什么是消息队列？</h2><p>你可以把消息队列理解为一个<strong>使用队列来通信</strong>的组件。它的本质，就是个<strong>转发器</strong>，包含<strong>发消息、存消息、消费消息</strong>的过程。最简单的消息队列模型如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20250407141749839.png" alt="img"></p><p>我们通常说的消息队列，简称<strong>MQ（Message Queue）</strong>，它其实就指<strong>消息中间件</strong>，当前业界比较流行的开源消息中间件包括：<code>RabbitMQ、RocketMQ、Kafka</code>。</p><h2 id="2-消息队列怎么选型？"><a href="#2-消息队列怎么选型？" class="headerlink" title="2.消息队列怎么选型？"></a>2.消息队列怎么选型？</h2><p>Kafka、ActiveMQ、RabbitMQ、RocketMQ来进行不同维度对比。</p><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10 万级</td><td>10 万级</td></tr><tr><td>时效性</td><td>毫秒级</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td></tr><tr><td>可用性</td><td>高（主从）</td><td>高（主从）</td><td>非常高（分布式）</td><td>非常高（分布式）</td></tr><tr><td>消息重复</td><td>至少一次</td><td>至少一次</td><td>至少一次 最多一次</td><td>至少一次最多一次</td></tr><tr><td>消息顺序性</td><td>有序</td><td>有序</td><td>有序</td><td>分区有序</td></tr><tr><td>支持主题数</td><td>千级</td><td>百万级</td><td>千级</td><td>百级，多了性能严重下滑</td></tr><tr><td>消息回溯</td><td>不支持</td><td>不支持</td><td>支持（按时间回溯）</td><td>支持（按offset回溯）</td></tr><tr><td>管理界面</td><td>普通</td><td>普通</td><td>完善</td><td>普通</td></tr></tbody></table></div><p>kafka:</p><ul><li><p>极高吞吐量和并发处理能力，适合海量数据流</p></li><li><p>消息无状态，不支持复杂路由（需应用层实现）</p></li><li><p>消息持久化和多副本机制保证数据不丢失</p></li><li><p>延迟性在高并发下表现不如 RabbitMQ</p></li><li><p>适用于流式数据处理，天生支持大数据生态</p></li><li><p>消费端需要自己管理 Offset，复杂度较高</p></li><li><p>强大的消费者组和分区机制，易于水平扩展</p></li><li><p>不支持 JMS 协议</p></li><li><p>提供了生产者幂等性、事务性（Exactly-Once）</p></li><li><p>维护和配置相对复杂</p></li></ul><p><strong>日志收集与聚合</strong>：作为日志数据生产者和消费者之间的桥梁，高效收集来自各种服务的海量日志数据，并传输到大数据分析平台（如 ELK Stack, Hadoop HDFS）。</p><p><strong>流式数据处理</strong>：与 Flink、Spark Streaming 等流处理框架结合，构建实时数据管道和实时计算平台，用于实时报表、风控、推荐等。</p><p><strong>用户行为追踪</strong>：追踪网站/APP 上的用户点击、浏览、搜索等行为数据，用于用户画像、精准营销和数据分析。</p><p>RabbitMq:</p><ul><li><p>支持 AMQP 协议，功能丰富，如四种交换器</p></li><li><p>吞吐量相较 Kafka 和 RocketMQ 较低</p></li><li><p>路由灵活，满足多种消息分发需求</p></li><li><p>持久化性能一般，对硬盘依赖较重</p></li><li><p>易于上手和管理，有友好的管理界面</p></li><li><p>遇到大量消息堆积时，性能会急剧下降</p></li><li><p>可靠的消息确认机制（ACK/NACK）</p></li><li><p>高可用集群部署相对复杂且对网络要求高</p></li><li><p>支持延迟队列、死信队列、优先级队列等高级特性</p></li><li><p>客户端库多语言支持不如 Kafka 广泛</p></li></ul><p><strong>复杂路由与消息分发</strong>：电商订单系统，订单支付成功后，需要同时通知库存系统、物流系统、积分系统、短信通知系统等多个模块，且可能根据订单类型进行不同路由。</p><p><strong>短任务异步处理</strong>：用户注册后发送激活邮件、生成缩略图、处理小文件等，将这些耗时短但不影响主流程的任务异步化。</p><p><strong>服务间解耦与消息驱动</strong>：微服务架构中，服务之间通过消息进行通信，实现松耦合和事件驱动架构。例如，商品价格更新事件通知给缓存服务、搜索服务和推荐服务。</p><p>RocketMQ:</p><ul><li><p>高吞吐量、低延迟，专为互联网电商场景优化</p></li><li><p>社区生态相比 Kafka 较小，国际化程度不够</p></li><li><p>丰富的功能特性，如顺序消息、分布式事务、回溯</p></li><li><p>部署和运维相对复杂</p></li><li><p>消息可靠性高，支持同步/异步刷盘</p></li><li><p>依赖 Java 生态，客户端语言支持相对局限</p></li><li><p>集群扩展性好，支持多 Master/Slave 模式</p></li><li><p>文档虽然有中文，但不如 RabbitMQ 和 Kafka 详尽</p></li><li><p>针对消息中间件的高级需求（如消息轨迹）支持好</p></li></ul><p><strong>电商交易系统</strong>：处理海量的交易消息，支持分布式事务（如订单创建与支付扣减的事务一致性），保证消息的可靠性和顺序性。</p><p><strong>金融支付系统</strong>：对消息的可靠性、事务一致性、顺序性要求极高，RocketMQ 在这些方面表现优异。</p><p><strong>双十一等高并发场景下的削峰填谷</strong>：在瞬时流量高峰到来时，将大量请求暂存到消息队列，然后后端服务根据自身能力匀速消费，确保系统稳定不崩溃。</p><p>ActiveMQ:</p><ul><li><p>完全支持 JMS 1.1 和 2.0 规范，易于集成</p></li><li><p>性能较差，吞吐量低，不适合高并发场景</p></li><li><p>支持多种传输协议（如 OpenWire, Stomp, MQTT）</p></li><li><p>消息积压时性能急剧下降，可能导致 OutOfMemory</p></li><li><p>易于上手，配置简单，开箱即用</p></li><li><p>长期运行稳定性有待提高</p></li><li><p>社区活跃度不如前三者，但功能稳定成熟</p></li><li><p>持久化方式多但都不突出，可靠性一般</p></li><li><p>提供了 Web 控制台</p></li><li><p>缺乏对大数据和流处理的天然支持</p></li></ul><p><strong>传统企业应用集成（JMS）</strong>：在基于 JMS 标准的老旧或传统企业内部系统之间进行集成，作为消息传递的桥梁。</p><p><strong>小型或中型项目的轻量级消息通信</strong>：对性能要求不高，但需要基本消息队列功能的独立应用，快速启动和部署。</p><p><strong>嵌入式消息队列</strong>：在某些 Java 应用程序中，可能需要将消息队列功能直接嵌入到应用程序内部，ActiveMQ 提供了这样的能力。</p><h2 id="3-消息队列使用场景有哪些？"><a href="#3-消息队列使用场景有哪些？" class="headerlink" title="3.消息队列使用场景有哪些？"></a>3.消息队列使用场景有哪些？</h2><ul><li><strong>解耦</strong>：可以在多个系统之间进行解耦，将原本通过网络之间的调用的方式改为使用MQ进行消息的异步通讯，只要该操作不是需要同步的，就可以改为使用MQ进行不同系统之间的联系，这样项目之间不会存在耦合，系统之间不会产生太大的影响，就算一个系统挂了，也只是消息挤压在MQ里面没人进行消费而已，不会对其他的系统产生影响。</li><li><strong>异步</strong>：加入一个操作设计到好几个步骤，这些步骤之间不需要同步完成，比如客户去创建了一个订单，还要去客户轨迹系统添加一条轨迹、去库存系统更新库存、去客户系统修改客户的状态等等。这样如果这个系统都直接进行调用，那么将会产生大量的时间，这样对于客户是无法接收的；并且像添加客户轨迹这种操作是不需要去同步操作的，如果使用MQ将客户创建订单时，将后面的轨迹、库存、状态等信息的更新全都放到MQ里面然后去异步操作，这样就可加快系统的访问速度，提供更好的客户体验。</li><li><strong>削峰</strong>：一个系统访问流量有高峰时期，也有低峰时期，比如说，中午整点有一个抢购活动等等。比如系统平时流量并不高，一秒钟只有100多个并发请求，系统处理没有任何压力，一切风平浪静，到了某个抢购活动时间，系统并发访问了剧增，比如达到了每秒5000个并发请求，而我们的系统每秒只能处理2000个请求，那么由于流量太大，我们的系统、数据库可能就会崩溃。这时如果使用MQ进行流量削峰，将用户的大量消息直接放到MQ里面，然后我们的系统去按自己的最大消费能力去消费这些消息，就可以保证系统的稳定，只是可能要跟进业务逻辑，给用户返回特定页面或者稍后通过其他方式通知其结果</li></ul><h2 id="4-消息重复消费怎么解决？"><a href="#4-消息重复消费怎么解决？" class="headerlink" title="4.消息重复消费怎么解决？"></a>4.消息重复消费怎么解决？</h2><p>生产端为了保证消息发送成功，可能会重复推送(直到收到成功ACK)，会产生重复消息。但是一个成熟的MQ Server框架一般会想办法解决，避免存储重复消息(比如：空间换时间，存储已处理过的message_id)，给生产端提供一个幂等性的发送消息接口。</p><p>但是消费端却无法根本解决这个问题，在高并发标准要求下，拉取消息+业务处理+提交消费位移需要做事务处理，另外消费端服务可能宕机，很可能会拉取到重复消息。</p><p>所以，只能业务端自己做控制，<strong>对于已经消费成功的消息，本地数据库表或Redis缓存业务标识，每次处理前先进行校验，保证幂等。</strong></p><h2 id="5-消息丢失怎么解决的？"><a href="#5-消息丢失怎么解决的？" class="headerlink" title="5.消息丢失怎么解决的？"></a>5.消息丢失怎么解决的？</h2><p>使用一个消息队列，其实就分为三大块：<strong>生产者、中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719381898719-af6c00bf-8760-4639-bd21-e6d422ef7779.webp" alt="img"></p><ul><li><strong>消息生产阶段</strong>：生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。从消息被生产出来，然后提交给 MQ 的过程中，<strong>只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功</strong>，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。</li><li><strong>消息存储阶段</strong>：Kafka 在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</li><li><strong>消息消费阶段</strong>：消费者<strong>接收消息+消息处理</strong>之后，才回复 ack 的话，那么消息阶段的消息不会丢失。不能收到消息就回 ack，否则可能消息处理中途挂掉了，消息就丢失了。</li></ul><h2 id="6-消息队列的可靠性、顺序性怎么保证？"><a href="#6-消息队列的可靠性、顺序性怎么保证？" class="headerlink" title="6.消息队列的可靠性、顺序性怎么保证？"></a>6.消息队列的可靠性、顺序性怎么保证？</h2><p>消息<strong>可靠性</strong>可以通过下面这些方式来保证</p><ul><li><strong>消息持久化</strong>：确保<strong>消息队列能够持久化消息</strong>是非常关键的。在系统崩溃、重启或者网络故障等情况下，未处理的消息不应丢失。例如，像 RabbitMQ 可以通过配置将<strong>消息持久化到磁盘，通过将队列和消息都设置为持久化的方式</strong>（设置<code>durable = true</code>），这样在服务器重启后，消息依然可以被重新读取和处理。</li><li><strong>消息确认机制</strong>：消费者在成功处理消息后，应该向消息队列发送确认（acknowledgment）。<strong>消息队列只有收到确认后，才会将消息从队列中移除</strong>。如果没有收到确认，消息队列可能会在一定时间后重新发送消息给其他消费者或者再次发送给同一个消费者。以 Kafka 为例，消费者通过<code>commitSync</code>或者<code>commitAsync</code>方法来提交偏移量（offset），从而确认消息的消费。</li><li><strong>消息重试策略</strong>：当消费者处理消息失败时，需要有<strong>合理的重试策略</strong>。可以设置重试次数和重试间隔时间。例如，在第一次处理失败后，等待一段时间（如 5 秒）后进行第二次重试，如果重试多次（如 3 次）后仍然失败，可以将消息发送到死信队列，以便后续人工排查或者采取其他特殊处理。</li></ul><p>消息顺序性保证的方式如下：</p><ul><li><strong>有序消息处理场景识别</strong>：首先需要明确业务场景中哪些消息是<strong>需要保证顺序的</strong>。例如，在金融交易系统中，对于同用户的转账操作顺序是不能打乱的。对于需要顺序处理的消息，要确保消息队列和消费者能够按照特定的顺序进行处理。</li><li><strong>消息队列对顺序性的支持</strong>：部分消息队列本身提供了顺序性保证的功能。比如 Kafka 可以通过将消息划分到<strong>同一个分区</strong>（Partition）来保证消息在分区内是有序的，<strong>消费者按照分区顺序读取消息就可以保证消息顺序</strong>。但这也可能会限制消息的并行处理程度，需要在顺序性和吞吐量之间进行权衡。</li><li><strong>消费者顺序处理策略</strong>：消费者在处理顺序消息时，<strong>应该避免并发处理可能导致顺序打乱的情况</strong>。例如，可以通过<strong>单线程或者使用线程池并对顺序消息进行串行化处理</strong>等方式，确保消息按照正确的顺序被消费。</li></ul><h2 id="7-如何保证幂等写？"><a href="#7-如何保证幂等写？" class="headerlink" title="7.如何保证幂等写？"></a>7.如何保证幂等写？</h2><p>幂等性是指 <strong>同一操作的多次执行对系统状态的影响与一次执行结果一致</strong>。例如，支付接口若因网络重试被多次调用，最终应确保仅扣款一次。实现幂等写的核心方案：</p><ul><li>唯一标识（幂等键）：客户端为每个请求生成全局唯一ID（如 UUID、业务主键），服务端校验该ID是否已处理，适用场景接口调用、消息消费等。</li><li>数据库事务 + 乐观锁：通过版本号或状态字段控制并发更新，确保多次更新等同于单次操作，适用场景数据库记录更新（如余额扣减、订单状态变更）。</li><li>数据库唯一约束：利用数据库唯一索引防止重复数据写入，适用场景数据插入场景（如订单创建）。</li><li>分布式锁：通过锁机制保证同一时刻仅有一个请求执行关键操作，适用场景高并发下的资源抢夺（如秒杀）。</li><li>消息去重：消息队列生产者为每条消息生成唯一的消息 ID，消费者在处理消息前，先检查该消息 ID 是否已经处理过，如果已经处理过则丢弃该消息。</li></ul><h2 id="8-如何处理消息队列的消息积压问题？"><a href="#8-如何处理消息队列的消息积压问题？" class="headerlink" title="8.如何处理消息队列的消息积压问题？"></a>8.如何处理消息队列的消息积压问题？</h2><p>消息积压是因为生产者的生产速度，大于消费者的消费速度。遇到消息积压问题时，我们需要先排查，是不是有bug产生了。</p><p>如果不是bug，我们可以<strong>优化一下消费的逻辑</strong>，比如之前是一条一条消息消费处理的话，我们可以确认是不是可以优为<strong>批量处理消息</strong>。如果还是慢，我们可以考虑水平扩容，增加Topic的队列数，和消费组机器的数量，提升整体消费能力。</p><p>如果是bug导致几百万消息持续积压几小时。有如何处理呢？需要解决bug，<strong>临时紧急扩容</strong>，大概思路如下：</p><blockquote><ol><li>先修复consumer消费者的问题，以确保其恢复消费速度，然后将现有consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先10倍的queue 数量。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ol></blockquote><h2 id="9-如何保证数据一致性，事务消息如何实现？"><a href="#9-如何保证数据一致性，事务消息如何实现？" class="headerlink" title="9.如何保证数据一致性，事务消息如何实现？"></a>9.如何保证数据一致性，事务消息如何实现？</h2><p>一条普通的MQ消息，从产生到被消费，大概流程如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20250407142107477.png" alt="image-20250407142107477"></p><ol><li>生产者产生消息，发送带MQ服务器</li><li>MQ收到消息后，将消息持久化到存储系统。</li><li>MQ服务器返回ACk到生产者。</li><li>MQ服务器把消息push给消费者</li><li>消费者消费完消息，响应ACK</li><li>MQ服务器收到ACK，认为消息消费成功，即在存储中删除消息。</li></ol><p>我们举个<strong>下订单</strong>的例子吧。订单系统创建完订单后，再发送消息给下游系统。如果订单创建成功，然后消息没有成功发送出去，下游系统就无法感知这个事情，出导致数据不一致。</p><p>如何保证数据一致性呢？可以使用<strong>事务消息</strong>。一起来看下事务消息是如何实现的吧。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20250407142122992.png" alt="image-20250407142122992"></p><ol><li>生产者产生消息，发送一条<strong>半事务消息</strong>到MQ服务器</li><li>MQ收到消息后，将消息持久化到存储系统，这条消息的状态是<strong>待发送</strong>状态。</li><li>MQ服务器返回ACK确认到生产者，此时MQ不会触发消息推送事件</li><li>生产者执行本地事务</li><li>如果本地事务执行成功，即commit执行结果到MQ服务器；如果执行失败，发送rollback。</li><li>如果是正常的commit，MQ服务器更新消息状态为<strong>可发送</strong>；如果是rollback，即删除消息。</li><li>如果消息状态更新为可发送，则MQ服务器会push消息给消费者。消费者消费完就回ACK。</li><li>如果MQ服务器长时间没有收到生产者的commit或者rollback，它会反查生产者，然后根据查询到的结果执行最终状态。</li></ol><h2 id="10-消息队列是参考哪种设计模式？"><a href="#10-消息队列是参考哪种设计模式？" class="headerlink" title="10.消息队列是参考哪种设计模式？"></a>10.消息队列是参考哪种设计模式？</h2><p>是参考了观察者模式和发布订阅模式，两种设计模式思路是一样的，举个生活例子：</p><ul><li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li><li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li></ul><p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p><blockquote><p>观察者模式</p></blockquote><p>观察者模式实际上就是<strong>一个一对多的关系</strong>，在观察者模式中存在一个主题和多个观察者，主题也是被观察者，当我们主题发布消息时，会通知各个观察者，观察者将会收到最新消息，图解如下：<strong>每个观察者首先订阅主题，订阅成功后当主题发送消息时会循环整个观察者列表，逐一发送消息通知。</strong> <img src="https://cdn.xiaolincoding.com//picgo/1723798409094-5099fa2a-c72c-4c67-bab7-09bbca9e0834.webp" alt="img"></p><blockquote><p>发布订阅模式</p></blockquote><p>发布订阅模式和观察者模式的区别就是发布者和订阅者完全解耦，通过<strong>中间的发布订阅中心</strong>进行消息通知，发布者并不知道自己发布的消息会通知给谁，因此发布订阅模式有三个重要角色，发布者-&gt;发布订阅中心-&gt;订阅者。</p><p>图解如下：当发布者发布消息到发布订阅中心后，发布订阅中心会将消息通知给所有订阅该发布者的订阅者 <img src="https://cdn.xiaolincoding.com//picgo/1723798423949-97ae81c8-3536-40c6-bcc6-1509a3056a04.webp" alt="img"></p><h2 id="11-让你写一个消息队列，该如何进行架构设计？"><a href="#11-让你写一个消息队列，该如何进行架构设计？" class="headerlink" title="11.让你写一个消息队列，该如何进行架构设计？"></a>11.让你写一个消息队列，该如何进行架构设计？</h2><ol><li>首先是消息队列的整体流程，producer发送消息给broker，broker存储好，broker再发送给consumer消费，consumer回复消费确认等。</li><li>producer发送消息给broker，broker发消息给consumer消费，那就需要两次RPC了，RPC如何设计呢？可以参考开源框架Dubbo，你可以说说服务发现、序列化协议等等</li><li>broker考虑如何持久化呢，是放文件系统还是数据库呢，会不会消息堆积呢，消息堆积如何处理呢。</li><li>消费关系如何保存呢？点对点还是广播方式呢？广播关系又是如何维护呢？zk还是config server</li><li>消息可靠性如何保证呢？如果消息重复了，如何幂等处理呢？</li><li>消息队列的高可用如何设计呢？可以参考Kafka的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li><li>消息事务特性，与本地业务同个事务，本地消息落库;消息投递到服务端，本地才删除；定时任务扫描本地消息库，补偿发送。</li><li>MQ得伸缩性和可扩展性，如果消息积压或者资源不够时，如何支持快速扩容，提高吞吐？可以参照一下 Kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了。</li></ol><h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="1-消息队列为什么选择RocketMQ的？"><a href="#1-消息队列为什么选择RocketMQ的？" class="headerlink" title="1.消息队列为什么选择RocketMQ的？"></a>1.消息队列为什么选择RocketMQ的？</h2><p>项目用的是 RocketMQ 消息队列。选择RocketMQ的原因是：</p><ul><li><strong>开发语言优势</strong>。RocketMQ 使用 Java 语言开发，比起使用 Erlang 开发的 RabbitMQ 来说，有着更容易上手的阅读体验和受众。在遇到 RocketMQ 较为底层的问题时，大部分熟悉 Java 的同学都可以深入阅读其源码，分析、排查问题。</li><li><strong>社区氛围活跃</strong>。RocketMQ 是阿里巴巴开源且内部在大量使用的消息队列，说明 RocketMQ 是的确经得起残酷的生产环境考验的，并且能够针对线上环境复杂的需求场景提供相应的解决方案。</li><li><strong>特性丰富</strong>。根据 RocketMQ 官方文档的列举，其高级特性达到了 <code>12 种</code>，例如顺序消息、事务消息、消息过滤、定时消息等。顺序消息、事务消息、消息过滤、定时消息。RocketMQ 丰富的特性，能够为我们在复杂的业务场景下尽可能多地提供思路及解决方案。</li></ul><h2 id="2-RocketMQ和Kafka的区别是什么？如何做技术选型？"><a href="#2-RocketMQ和Kafka的区别是什么？如何做技术选型？" class="headerlink" title="2.RocketMQ和Kafka的区别是什么？如何做技术选型？"></a>2.RocketMQ和Kafka的区别是什么？如何做技术选型？</h2><p>Kafka的优缺点：</p><ul><li>优点：首先，Kafka的最大优势就在于它的高吞吐量，在普通机器4CPU8G的配置下，一台机器可以抗住十几万的QPS，这一点还是相当优越的。Kafka支持集群部署，如果部分机器宕机不可用，则不影响Kafka的正常使用。</li><li>缺点：Kafka有可能会造成数据丢失，因为它在收到消息的时候，并不是直接写到物理磁盘的，而是先写入到磁盘缓冲区里面的。Kafka功能比较的单一 主要的就是支持收发消息，高级功能基本没有，就会造成适用场景受限。</li></ul><p>RocketMQ是阿里巴巴开源的消息中间件，优缺点</p><ul><li>优点：支持功能比较多，比如延迟队列、消息事务等等，吞吐量也高，单机吞吐量达到 10 万级，支持大规模集群部署，线性扩展方便，Java语言开发，满足了国内绝大部分公司技术栈</li><li>缺点：性能相比 kafka 是弱一点，因为 kafka 用到了 sendfile 的零拷贝技术，而 RocketMQ 主要是用 mmap+write 来实现零拷贝。</li></ul><p>该怎么选择呢？</p><ul><li>如果我们业务只是收发消息这种单一类型的需求，而且可以允许小部分数据丢失的可能性，但是又要求极高的吞吐量和高性能的话，就直接选Kafka就行了，就好比我们公司想要收集和传输用户行为日志以及其他相关日志的处理，就选用的Kafka中间件。</li><li>如果公司的需要通过 mq 来实现一些业务需求，比如延迟队列、消息事务等，公司技术栈主要是Java语言的话，就直接一步到位选择RocketMQ，这样会省很多事情。</li></ul><h2 id="3-RocketMQ延时消息的底层原理"><a href="#3-RocketMQ延时消息的底层原理" class="headerlink" title="3.RocketMQ延时消息的底层原理"></a>3.RocketMQ延时消息的底层原理</h2><p>总体的原理示意图，如下所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1720428795952-bba954e9-c9b6-45c5-aa05-8cc1d49c0e3c.png" alt="img"></p><p>broker 在接收到延时消息的时候，会将延时消息存入到<strong>延时Topic</strong>的队列中，然后ScheduleMessageService中，每个 queue 对应的定时任务会不停地被执行，检查 queue 中哪些消息已到设定时间，然后转发到消息的原始Topic，这些消息就会被各自的 producer 消费了。</p><p>也可以使用这个思路用redis的stream流来实现延时消息</p><h2 id="4-RocektMQ怎么处理分布式事务？"><a href="#4-RocektMQ怎么处理分布式事务？" class="headerlink" title="4.RocektMQ怎么处理分布式事务？"></a>4.RocektMQ怎么处理分布式事务？</h2><p><strong>RocketMQ是一种最终一致性的分布式事务</strong>，就是说它保证的是消息最终一致性，而不是像2PC、3PC、TCC那样强一致分布式事务</p><p>假设 <strong>A</strong> 给 <strong>B</strong> 转 <strong>100块钱</strong>，同时它们不是同一个服务上，现在目标是就是 <strong>A</strong> 减100块钱，<strong>B</strong> 加100块钱。</p><p>实际情况可能有四种：</p><ul><li>1）就是A账户减100 （成功），B账户加100 （成功）</li><li>2）就是A账户减100（失败），B账户加100 （失败）</li><li>3）就是A账户减100（成功），B账户加100 （失败）</li><li>4）就是A账户减100 （失败），B账户加100 （成功）</li></ul><p>这里 <strong>第1和第2</strong> 种情况是能够保证事务的一致性的，但是 <strong>第3和第4</strong> 是无法保证事务的一致性的。</p><p>那我们来看下RocketMQ是如何来保证事务的一致性的。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1714663418978-cb16a341-5eef-4f2a-ac2f-2331f5249c31.png" alt="img"></p><p>分布式事务的流程如上图：</p><ul><li>1、A服务先发送个Half Message（是指暂不能被Consumer消费的消息。Producer 已经把消息成功发送到了Broker 端，但此消息被标记为暂不能投递状态，处于该种状态下的消息称为半消息。需要 Producer对消息的二次确认后，Consumer才能去消费它）给Brock端，消息中携带 B服务 即将要+100元的信息。</li><li>2、当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。</li><li>3、执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应)</li><li>4.1)、如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。</li><li>4.2)、如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。</li><li>4.3)、如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口，来进行事务的回查。</li></ul><p>从上面流程可以得知 只有A服务本地事务执行成功 ，B服务才能消费该message。</p><p><strong>那么</strong> <strong>A账户减100 （成功），B账户加100 （失败），这时候B服务失败怎么办？</strong></p><p>如果B最终执行失败，几乎可以断定就是代码有问题所以才引起的异常，因为消费端RocketMQ有重试机制，如果不是代码问题一般重试几次就能成功。</p><p>如果是代码的原因引起多次重试失败后，也没有关系，将该异常记录下来，由人工处理，人工兜底处理后，就可以让事务达到最终的一致性。</p><h2 id="5-RocketMQ消息顺序怎么保证？"><a href="#5-RocketMQ消息顺序怎么保证？" class="headerlink" title="5.RocketMQ消息顺序怎么保证？"></a>5.RocketMQ消息顺序怎么保证？</h2><p>消息的有序性是指<strong>消息的消费顺序能够严格保存与消息的发送顺序一致</strong>。例如，一个订单产生了3条消息，分别是订单创建、订单付款和订单完成。在消息消费时，同一条订单要严格按照这个顺序进行消费，否则业务会发生混乱。同时，不同订单之间的消息又是可以并发消费的，比如可以先执行第三个订单的付款，再执行第二个订单的创建。</p><p>RocketMQ采用了<strong>局部顺序一致性的机制</strong>，<strong>实现了单个队列中的消息严格有序</strong>。也就是说，如果想要保证顺序消费，必须将一组消息发送到同一个队列中，然后再由消费者进行注意消费。</p><p>RocketMQ推荐的顺序消费解决方案是：安装业务划分不同的队列，然后将需要顺序消费的消息发往同一队列中即可，不同业务之间的消息仍采用并发消费。这种方式在满足顺序消费的同时提高了消息的处理速度，在一定程度上避免了消息堆积问题</p><p>RocketMQ 顺序消息的原理是：</p><ul><li>在 Producer（生产者） 把一批需要保证顺序的消息发送到同一个 MessageQueue</li><li>Consumer（消费者） 则<strong>通过加锁的机制来保证消息消费的顺序性</strong>，Broker 端通过对 MessageQueue 进行加锁，保证同一个 MessageQueue 只能被同一个 Consumer 进行消费。</li></ul><h2 id="6-RocketMQ怎么保证消息不被重复消费"><a href="#6-RocketMQ怎么保证消息不被重复消费" class="headerlink" title="6.RocketMQ怎么保证消息不被重复消费"></a>6.RocketMQ怎么保证消息不被重复消费</h2><p>在业务逻辑中实现<strong>幂等性</strong>，确保即使消息被重复消费，也不会影响业务状态。例如，对于支付或转账类操作，可以<strong>使用唯一订单号或事务ID作为幂等性的标识符</strong>，确保同样的操作只会被执行一次。</p><p>消息投递时，<strong>网络中断</strong>或<strong>消费失败重试</strong>可能会导致 <strong>重复消费</strong></p><p>消息投递给消费者后，<strong>消费者处理异常</strong> 或返回失败，会被 RocketMQ <strong>重新投递</strong></p><ul><li>数据库表加“唯一约束 + 去重表”【最常用】</li><li>使用 Redis 实现幂等控制</li><li>利用 RocketMQ 提供的 <code>msg.getKeys()</code> 做幂等键</li></ul><h2 id="7-RocketMQ消息积压了，怎么办？"><a href="#7-RocketMQ消息积压了，怎么办？" class="headerlink" title="7.RocketMQ消息积压了，怎么办？"></a>7.RocketMQ消息积压了，怎么办？</h2><p>导致消息积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了。</p><p>要解决积压的问题，可以通过<strong>扩容消费端的实例数来提升总体的消费能力</strong>。</p><p>如果短时间内没有足够的服务器资源进行扩容，没办法的办法是，将<strong>系统降级</strong>，通过关闭一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，服务一些重要业务。</p><h2 id="8-什么是零拷贝"><a href="#8-什么是零拷贝" class="headerlink" title="8.什么是零拷贝"></a>8.什么是零拷贝</h2><p>传统的数据传输流程中，用户数据通常会经过如下多次拷贝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘 → 内核缓冲区 → 用户态 → Socket 缓冲区 → 网卡</span><br></pre></td></tr></table></figure><p>一般来说文件拷贝是要拷贝四次的，</p><p>当用户进程调用<code>read()</code>，用户态无法调用内核态的设备，只能触发系统调用（IO）。这时计算机需要从用户态切换为内核态。</p><p>到达内核态之后，计算机通过<code>DMA</code>控制器将数据从磁盘读取出来，放到内核的缓冲区。完成第一次拷贝。</p><p>CPU需要将缓冲区的数据拷贝到用户态的缓冲区，完成第二次拷贝，也是read()函数的返回。这时计算器需要从内核态切换为用户态。</p><p>因为最终的数据需要通过网卡输出，所以用户进程就需要调用<code>write()</code>函数，CPU将用户缓冲区的数据拷贝到<code>Socket</code>缓冲区，完成第三次拷贝。同时需要再次触发系统调用。这时计算机又需要从用户态切换为内核态。</p><p><code>DMA</code>控制器把数据从<code>Socket</code>缓冲区，拷贝到网卡设备输出，至此完成第四不拷贝。同时需要将内核态切换为用户态，<code>write()</code>函数返回。</p><p>而“零拷贝”技术通过内核优化和 API 支持，能<strong>避免数据在用户态与内核态间的多次拷贝</strong>，从而提升性能。常用技术：</p><div class="table-container"><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td><code>mmap</code></td><td>将文件映射到内存地址空间，避免文件拷贝</td></tr><tr><td><code>sendfile</code></td><td>直接将文件从磁盘发送到 Socket，避免数据进入用户态</td></tr><tr><td><code>writev</code></td><td>批量写入多个内存区域，减少系统调用</td></tr><tr><td><code>DirectByteBuffer</code>（Java NIO）</td><td>Java 堆外内存，提高 I/O 性能</td></tr></tbody></table></div><p>RocketMQ使用零拷贝的场景：</p><p>MMAP:</p><p>RocketMQ 使用 <strong>顺序写入磁盘</strong> + <strong><code>MappedByteBuffer</code>（mmap）机制</strong>】</p><p>mmap将用户空间的虚拟地址和内核空间的文件缓冲区映射到同一块物理内存区域。 这样， 用户进程可以直接访问内核空间的文件缓冲区， 避免了 CPU 拷贝。</p><ul><li>CommitLog 文件通过 <code>mmap</code> 映射为<strong>内存地址空间</strong>，写消息时直接写入这段地址</li><li>消息写完之后由 <strong>刷盘线程 flush</strong> 到磁盘（异步或同步）</li></ul><p>➡️ 优点：避免了传统写文件的 <strong>内核缓冲区 → 用户缓冲区 → 文件系统缓存</strong> 的多次复制。</p><p>消息消费（拉取时）</p><p>RocketMQ 使用 <strong>零拷贝 + SendFile 技术</strong> 实现高效消息下发：</p><ul><li>消费者从 Broker 拉取消息时，Broker 会读取 CommitLog 中的内容</li><li>若消息在 OS PageCache 中，可直接使用 <code>FileChannel.transferTo</code>（即 sendfile）将消息直接写入 socket 输出流</li></ul><p>➡️ 相比传统读入用户空间再写出，<code>sendfile</code> 直接 <strong>在内核中完成数据搬运</strong>，性能极高。</p><p>ConsumeQueue 与 IndexFile</p><p>RocketMQ 的 ConsumeQueue（消费队列）和 IndexFile（索引文件）同样是基于 <strong>mmap 方式读写</strong>，提升顺序读性能，避免 GC 干扰。</p><ul><li>ConsumeQueue 中记录了消息的偏移量、大小和 tag hash</li><li>查询或消费时不需要实际读取 CommitLog 内容，而是通过偏移快速定位</li></ul><p><strong>sendfile()</strong></p><p>sendfile() 系统调用允许将数据从一个文件描述符 (例如， 文件)  直接传输到另一个文件描述符 (例如， Socket)。  避免了数据在用户空间和内核空间之间的拷贝。</p><ol><li>用户进程调用 <code>sendfile()</code> 系统调用， 指定输入和输出文件描述符。</li><li>数据通过 DMA 从磁盘读取到内核缓冲区。</li><li>数据直接从内核缓冲区拷贝到 Socket 缓冲区，或者更优的方式是：只有描述符信息从内核缓冲区拷贝到socket缓冲区。</li><li>数据通过 DMA 从 Socket 缓冲区传输到网卡。</li></ol><p>静态文件服务器（例如 Nginx）通常使用 sendfile() 来将静态文件发送给客户端。只能适用于数据从文件传输到Socket的场景，范围有限</p><p> <strong>splice() (管道):</strong></p><p>splice() 系统调用允许在两个文件描述符之间移动数据，而不需要在用户空间和内核空间之间进行复制。</p><ol><li>创建两个管道(pipe)对象</li><li>调用 splice() 系统调用,将数据从输入文件描述符读取到第一个管道.</li><li>调用 splice() 系统调用,将数据从管道数据写到socket 。</li></ol><p>适用于需要数据传输与转换(类似于Linux的管道操作)的场景</p><p><strong>Direct I/O</strong>：</p><p>Direct I/O 允许用户进程绕过内核缓冲区 (Page Cache)， 直接访问磁盘。</p><ol><li>用户进程发起 Direct I/O 请求。</li><li>数据通过 DMA 直接从磁盘传输到用户进程的缓冲区。</li></ol><ul><li>需要用户进程自己管理缓存，增加了开发的复杂性。</li><li>可能影响系统的整体性能， 因为绕过了 Page Cache。 （Page Cache 可以缓存热点数据，提高访问速度）。</li></ul><p>大型数据库（例如 Oracle）通常使用 Direct I/O 来进行数据读写， 因为数据库有自己的缓存管理机制。</p><div class="table-container"><table><thead><tr><th>特性</th><th>优势</th></tr></thead><tbody><tr><td>mmap</td><td>减少内存复制、提高 I/O 吞吐</td></tr><tr><td>sendfile</td><td>内核空间直接完成数据搬运</td></tr><tr><td>writev（部分使用）</td><td>多个 buffer 一次写出</td></tr><tr><td>堆外内存使用（DirectByteBuffer）</td><td>降低 GC 压力，提升 I/O 性能</td></tr></tbody></table></div><h2 id="9-RocketMQ的Consumer两种消费模式"><a href="#9-RocketMQ的Consumer两种消费模式" class="headerlink" title="9.RocketMQ的Consumer两种消费模式"></a>9.RocketMQ的Consumer两种消费模式</h2><p>推模式</p><p>实际上，RocketMQ 的推模式底层仍然是基于<strong>长轮询（Long Polling）的拉模式</strong>来实现的，只是由 RocketMQ SDK 内部管理了拉取消息、维护消费进度（Offset）等复杂逻辑，然后通过回调函数将消息“推”给用户应用。</p><p>消费者启动后，向 Broker 注册自己，并订阅感兴趣的 Topic。</p><p>RocketMQ SDK 内部会启动一个<strong>长轮询线程</strong>。它会定期（或在消息到达时）向 Broker 发送拉取消息的请求。</p><p>如果 Broker 有消息，就立即返回给消费者；如果没有，Broker 会保持连接一段时间（长轮询），直到有新消息到达或超时。</p><p>当 SDK 拉取到消息后，会将其存入<strong>本地的消费队列缓存</strong>。</p><p>然后，SDK 会根据配置的并发度，将缓存中的消息分发给用户注册的<strong>消息监听器（MessageListener）</strong>进行处理。</p><p>用户在消息监听器中完成业务逻辑后，返回消费结果（成功或失败）。</p><p>RocketMQ SDK 会根据消费结果自动提交消费进度（Offset）给 Broker，并处理消息重试、死信队列等。</p><p><strong>自动重试与死信</strong>：内置消息失败重试机制，以及将达到最大重试次数的消息发送到死信队列的功能。</p><p><strong>简单易用</strong>：用户只需关注业务逻辑，实现一个 <code>MessageListener</code> 接口即可，无需处理消息拉取、偏移量管理、流控等底层细节。</p><p><strong>实时性好</strong>：由于长轮询机制，消息到达后能被较快地消费。</p><p><strong>自动负载均衡</strong>：在消费者组模式下，RocketMQ SDK 会自动进行队列的负载均衡，将 Topic 的消息队列分配给组内不同的消费者实例，实现水平扩展。</p><p>拉模式</p><p>拉模式是一种<strong>更原始、更底层</strong>的消费模式。它将消息拉取的主动权完全交给用户。消费者需要<strong>主动</strong>向 Broker 发送请求拉取消息，并<strong>手动管理</strong>消息的消费进度（Offset）。</p><p>消费者启动后，需要自己获取 Topic 下所有消息队列（MessageQueue）的信息。</p><p>消费者选择一个或多个消息队列进行拉取。</p><p>消费者需要维护每个消息队列的<strong>当前消费偏移量 (Offset)</strong>。</p><p>消费者主动调用 <code>pull()</code> 方法向 Broker 发送拉取请求，指定要拉取的队列、当前偏移量和最大拉取数量。</p><p>Broker 返回拉取结果 <code>PullResult</code>，其中包含消息列表、下一个拉取偏移量等。</p><p>消费者处理完消息后，需要<strong>手动更新并提交</strong>新的消费偏移量。</p><p>消费者需要自己处理消息拉取的频率（轮询间隔）、批量处理、消息重试等逻辑。</p><p>RocketMQ 4.x 引入的 <code>DefaultLitePullConsumer</code> 简化了传统的 <code>DefaultMQPullConsumer</code> 的使用，使其在部分场景下更接近推模式的体验，但本质上仍是拉模式，需要用户主动 <code>poll</code>。</p><h2 id="10-RocketMQ的Consumer两种监听方式"><a href="#10-RocketMQ的Consumer两种监听方式" class="headerlink" title="10.RocketMQ的Consumer两种监听方式"></a>10.RocketMQ的Consumer两种监听方式</h2><p>一般在push模式下会经常使用到监听。</p><p>并发消费是 RocketMQ 默认的也是最常用的消费模式。在这种模式下，消费者可以<strong>并发地处理来自同一个队列（MessageQueue）甚至同一个 Topic 的多条消息</strong>。RocketMQ 会为每个消息队列分配一个或多个消费线程，或者从线程池中获取线程来处理消息。</p><p>RocketMQ 消费者从 Broker 拉取到一批消息。</p><p>这些消息会被分发到消费者内部的<strong>多个线程</strong>中并行处理。</p><p>对于同一个消息队列，RocketMQ 可能会同时将多条消息提交给不同的线程进行消费。</p><p><strong>不保证严格顺序</strong>：对于同一个消息队列内的消息，无法保证其被消费的顺序与发送顺序一致。因为消息被分发到不同的线程并行处理，处理完成的顺序是不确定的。</p><p><strong>需要考虑并发问题</strong>：如果业务逻辑涉及到共享资源或状态，需要开发者自行处理并发安全问题（例如加锁、使用原子操作等）。</p><p>顺序消费模式保证了<strong>同一个消息队列（MessageQueue）中的消息，被消费者严格按照发送的顺序进行消费</strong>。这意味着在任何时刻，对于一个特定的消息队列，只会有一个线程在处理其中的消息。</p><p>RocketMQ 消费者从 Broker 拉取到一批消息。</p><p>对于每个消息队列，RocketMQ SDK 会确保<strong>只有一个消费线程</strong>来处理该队列中的消息。</p><p>如果当前消息队列中的某条消息正在被处理，或者处理失败需要重试，那么该队列的后续消息会被<strong>阻塞</strong>，直到当前消息处理完成并成功提交偏移量。</p><ul><li><strong>严格保证顺序性</strong>：确保了同一消息队列内的消息按照生产顺序被消费，这对于某些业务场景至关重要。</li><li><p><strong>简化并发处理</strong>：由于同一队列的消息是单线程处理，开发者无需过多考虑并发安全问题。</p></li><li><p><strong>吞吐量受限</strong>：由于是单线程处理一个消息队列，其消费速度受限于单个线程的处理能力，整体吞吐量会低于并发消费模式。</p></li><li><strong>可能出现消息堆积</strong>：如果某个消息处理失败并持续重试，或者处理时间过长，会导致该队列的后续消息被阻塞，造成消息堆积。</li><li><strong>死锁风险</strong>：如果消息处理逻辑中存在外部依赖的死锁，可能会导致整个队列的消费停滞。</li></ul><h2 id="11-如何顺序的发送消息"><a href="#11-如何顺序的发送消息" class="headerlink" title="11.如何顺序的发送消息"></a>11.如何顺序的发送消息</h2><p>使用<strong>分区顺序（Partial Order）</strong>：这是最常用的方式。它保证同一个 <code>ShardingKey</code> (例如订单ID) 关联的所有消息在生产者端按照发送顺序发送到同一个消息队列，并在消费者端也按照这个顺序消费。不同 <code>ShardingKey</code> 的消息则可以并行处理，不保证顺序。这适用于大部分业务场景，例如一个订单的创建、支付、发货等一系列操作。</p><p>创建 <code>MessageQueueSelector</code></p><p> arg 就是你在发送消息时传入的业务ShardingKey，例如订单ID，使用 ShardingKey 的哈希值或者模运算来选择队列</p><p>需要使用 <code>DefaultMQProducer</code> 的 <code>send(Message msg, MessageQueueSelector selector, Object arg)</code> 方法。</p><ul><li><code>msg</code>: 你要发送的消息对象。</li><li><code>selector</code>: 你前面实现的 <code>MessageQueueSelector</code> 实例。</li><li><code>arg</code>: 你的业务 <code>ShardingKey</code>，例如订单ID。RocketMQ 会把这个 <code>arg</code> 传递给 <code>MessageQueueSelector</code> 的 <code>select</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;OrderProducerGroup&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;OrderTopic&quot;</span>;</span><br><span class="line">        <span class="comment">// 假设有三个订单</span></span><br><span class="line">        <span class="type">int</span>[] orderIds = &#123;<span class="number">101</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">102</span>, <span class="number">101</span>&#125;; <span class="comment">// 订单ID，模拟相同订单ID的消息</span></span><br><span class="line"></span><br><span class="line">        <span class="type">OrderMessageQueueSelector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderMessageQueueSelector</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; orderIds.length; i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">orderId</span> <span class="operator">=</span> orderIds[i];</span><br><span class="line">            <span class="type">String</span> <span class="variable">msgBody</span> <span class="operator">=</span> <span class="string">&quot;Hello RocketMQ Order Message &quot;</span> + i + <span class="string">&quot; for OrderID &quot;</span> + orderId;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;KEY_&quot;</span> + orderId + <span class="string">&quot;_&quot;</span> + i, msgBody.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送顺序消息，关键在于传入selector和orderId</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg, selector, orderId);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单一生产者，单一线程</strong>：RocketMQ 服务端判定消息顺序性是参照单一生产者、单一线程并发下消息发送的时序。如果多个生产者或多个线程并发发送消息，RocketMQ 只能以到达服务端的时序作为顺序依据，这可能与你业务侧的发送顺序不一致。因此，对于需要严格顺序的场景，最好保证<strong>同一个 <code>ShardingKey</code> 的消息由同一个生产者实例的同一个线程发送。</strong></p><p><strong>确保 <code>ShardingKey</code> 的稳定性</strong>：用于决定消息路由的 <code>ShardingKey</code>（例如订单ID）在整个业务流程中必须保持一致，这样相关的所有消息才能被路由到同一个队列。</p><p>消费者端需要确保同一个队列的消息被顺序消费。RocketMQ 的顺序消息消费模式是<strong>推模式（Push Consumer）</strong>，并且默认就提供了顺序消费的保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;OrderConsumerGroup&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;OrderTopic&quot;</span>, <span class="string">&quot;*&quot;</span>); <span class="comment">// 订阅Topic</span></span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                <span class="comment">// 设置为单线程消费，确保顺序</span></span><br><span class="line">                context.setAutoCommit(<span class="literal">true</span>); <span class="comment">// 默认开启自动提交，如果业务逻辑复杂，可以手动提交</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getKeys().split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]; <span class="comment">// 从Key中提取订单ID</span></span><br><span class="line">                        System.out.printf(<span class="string">&quot;Consume Thread: %s, QueueId: %d, OrderId: %s, MsgId: %s, Body: %s %n&quot;</span>,</span><br><span class="line">                                Thread.currentThread().getName(),</span><br><span class="line">                                msg.getQueueId(),</span><br><span class="line">                                orderId,</span><br><span class="line">                                msg.getMsgId(),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                        <span class="comment">// 模拟业务处理耗时</span></span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">// 如果处理失败，返回SUSPEND_CURRENT_QUEUE_A_MOMENT，RocketMQ 会稍后重试</span></span><br><span class="line">                        <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS; <span class="comment">// 成功消费</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>MessageListenerOrderly</code></strong>：这是 RocketMQ 专门为顺序消息设计的监听器。它确保了同一个消息队列中的消息会被一个线程串行地拉取和处理，从而保证了消费顺序。</p><p><strong><code>ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT</code></strong>：如果在消息处理过程中发生异常，返回此状态可以让 RocketMQ 暂停当前队列的消费，并在稍后重试。这可以避免因为一条消息处理失败而导致后续消息无法按序处理的问题。</p><p><strong>幂等性</strong>：即使 RocketMQ 保证了顺序，但由于网络等原因，消息仍可能被重复投递。因此，你的消费者逻辑必须具备<strong>幂等性</strong>，即多次处理同一条消息也能得到一致的结果。</p><p>Topic 配置</p><p>通过 <code>mqadmin</code> 工具更新 Topic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqadmin updateTopic -c DefaultCluster -t YourOrderTopic -n 127.0.0.1:9876 --order true</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>: 集群名称</li><li><code>-t</code>: Topic 名称</li><li><code>-n</code>: NameServer 地址</li><li><code>--order true</code>: 标记此 Topic 为有序 Topic</li></ul><h2 id="12-RocketMQ的批量消息"><a href="#12-RocketMQ的批量消息" class="headerlink" title="12.RocketMQ的批量消息"></a>12.RocketMQ的批量消息</h2><p>使用批量消息的时候，要注意</p><ul><li><strong>同一批次消息的 Topic 必须相同</strong>：这是强制要求，一个批量消息中不能包含不同 Topic 的消息。</li><li><strong>批量消息的总大小不能超过 1MB</strong>：这是 RocketMQ 默认的硬性限制。如果你的批量消息总大小超过 1MB，你需要自行将它们拆分成多个批次进行发送。</li><li><strong>不支持延迟消息和事务消息</strong>：批量消息目前不支持发送延迟消息或事务消息。如果需要这些功能，请使用普通消息或其他消息类型。</li><li><strong>相同的 <code>waitStoreMsgOK</code></strong>：同一批次消息的 <code>waitStoreMsgOK</code>（表示是否等待消息存储成功再返回）属性必须相同。通常情况下，这都是默认值，所以一般不需要特别关注。</li><li><strong>不保证严格顺序</strong>：批量消息通常不保证消息在 Broker 上的存储顺序和消费顺序。如果你需要顺序消息，应该使用上一问中提到的<strong>顺序消息</strong>特性，并确保同一 <code>ShardingKey</code> 的消息发送到同一个队列。即使批量发送，只要你通过 <code>MessageQueueSelector</code> 确保了同一 <code>ShardingKey</code> 的消息发送到同一队列，它们在该队列内仍能保持相对顺序。</li></ul><p><strong>生成者：</strong></p><p>发送批量消息非常简单，只需要将一个 <code>Message</code> 列表作为参数传递给 <code>DefaultMQProducer</code> 的 <code>send</code> 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleBatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;BatchProducerGroup&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;BatchTestTopic&quot;</span>;</span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意：同一批次的消息 Topic 必须相同</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>, <span class="comment">// Tag</span></span><br><span class="line">                    <span class="string">&quot;OrderID&quot;</span> + i, <span class="comment">// Key</span></span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ Batch Message &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">// 消息体</span></span><br><span class="line">            );</span><br><span class="line">            messages.add(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发送批量消息</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(messages);</span><br><span class="line">            System.out.printf(<span class="string">&quot;Batch messages sent successfully: %s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to send batch messages.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息大小：</strong></p><p>如果你的批量消息总大小可能超过 1MB，你需要手动对消息列表进行分割。</p><p>实际中可以直接使用 RocketMQ 客户端库中提供的 <code>ListSplitter</code>。</p><p><strong>消费者端处理：</strong></p><p>消费者端通常不需要为批量消息做特殊处理。无论是单条消息还是批量消息，消费者都会以相同的 <code>MessageExt</code> 列表形式接收到。你只需要像处理普通消息一样遍历 <code>msgs</code> 列表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;BatchConsumerGroup&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;BatchTestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>); <span class="comment">// 订阅批量消息的Topic</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;BatchSplitTestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>); <span class="comment">// 订阅分割后的批量消息的Topic</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置一次拉取消息的最大数量，默认为1。如果设置为大于1，可以实现批量消费。</span></span><br><span class="line">        <span class="comment">// RocketMQ 客户端会尽可能一次性拉取多条消息，并以List&lt;MessageExt&gt;形式传递给监听器。</span></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(<span class="number">32</span>); <span class="comment">// 每次最多消费32条消息</span></span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;Consumer Thread: %s, Received %d messages.%n&quot;</span>,</span><br><span class="line">                        Thread.currentThread().getName(), msgs.size());</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;  MsgId: %s, Key: %s, Body: %s %n&quot;</span>,</span><br><span class="line">                                msg.getMsgId(), msg.getKeys(), <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                        <span class="comment">// 模拟业务处理</span></span><br><span class="line">                        <span class="comment">// TimeUnit.MILLISECONDS.sleep(10);</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">// 如果单个消息处理失败，考虑是重试整个批次还是记录失败消息后继续处理其他消息</span></span><br><span class="line">                        <span class="comment">// 返回RECONSUME_LATER会重试整个批次</span></span><br><span class="line">                        <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.SUCCESS; <span class="comment">// 成功消费整个批次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Batch Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>setConsumeMessageBatchMaxSize(int consumeMessageBatchMaxSize)</code></strong>: 这是消费者端实现批量消费的关键配置。通过设置这个参数，你可以控制消费者每次从 Broker 拉取消息并提交给业务逻辑处理的<strong>最大消息数量</strong>。默认值是 <code>1</code>，即每次只消费一条消息。增大此值可以提高消费的并行度。</p><p><strong>消费幂等性</strong>：即使是批量消费，也需要考虑消息的重复投递问题。确保你的业务逻辑在处理批量消息时具备幂等性。</p><p><strong>异常处理</strong>：如果在批量处理中某条消息处理失败，你可能需要决定是重试整个批次，还是只重试失败的消息并继续处理批次中的其他消息。返回 <code>RECONSUME_LATER</code> 会导致整个批次的消息都被重试。如果业务允许，可以记录失败消息，并返回 <code>SUCCESS</code> 以避免阻塞整个队列。</p><h2 id="13-RocketMQ的延时消息"><a href="#13-RocketMQ的延时消息" class="headerlink" title="13.RocketMQ的延时消息"></a>13.RocketMQ的延时消息</h2><p>允许你指定消息在发送到 Broker 后，不会立即被消费者消费，而是会延迟一段时间后才投递给消费者。这个功能在许多业务场景中非常有用，比如：</p><ul><li><strong>订单超时未支付自动取消</strong>：用户下单后，如果30分钟内未支付，就发送一个延时消息，30分钟后这个消息被消费，触发订单取消操作。</li><li><strong>新用户注册奖励延迟发放</strong>：用户注册成功后，延时1天发放新人奖励，确保用户体验。</li><li><strong>任务定时执行</strong>：例如，每天凌晨统计前一天的销售数据，可以发送一个延时24小时的消息来触发。</li><li><strong>消息在指定时间后发送</strong>：例如，促销短信在某个特定时间点发送。</li></ul><p>RocketMQ 不支持任意精度的时间延时，它预设了18个固定的延时等级（delayLevel）。这些等级是硬编码在 Broker 端的配置中的。</p><p>默认的延时等级字符串如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure><p>原理：</p><p><strong>发送到内部 Topic</strong>：当生产者发送一个延时消息时，Broker 不会将它直接存储到目标 Topic 的队列中。相反，它会将消息存储到一个内部的、名为 <code>SCHEDULE_TOPIC_XXXX</code> 的 Topic 中。</p><p><strong>根据 <code>delayTimeLevel</code> 分发</strong>：这个内部 Topic 实际上有多个队列，每个队列对应一个延时等级。消息会被路由到对应延时等级的队列中。</p><p><strong>定时扫描</strong>：Broker 端有一个后台线程（或者多个线程）会定时扫描这些内部延时队列。</p><p><strong>达到延时时间后重新投递</strong>：当扫描发现某个消息的投递时间已到，它就会被重新存储到<strong>原始目标 Topic 的队列中</strong>，此时消息才对消费者可见，可以被正常消费。</p><p>生产者：</p><p>生产者发送延时消息非常简单，只需要在发送消息前设置 <code>delayTimeLevel</code> 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;DelayProducerGroup&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;DelayTopic&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;OrderID&quot;</span> + i,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ Delay Message &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置延时等级。</span></span><br><span class="line">            <span class="comment">// 例如，这里设置延时等级为 3，对应延时 10 秒。</span></span><br><span class="line">            <span class="comment">// 延时等级列表：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">            msg.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s, Message sent to delay level %d%n&quot;</span>, sendResult, msg.getDelayTimeLevel());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能直接设置延迟等级，需要具体的时间的话，</p><p><strong>选择最近的延时等级</strong>：例如，对于 15 秒的延时，你可以选择 10 秒等级。在消费端，获取消息的生产时间戳和当前时间戳，如果还没到 15 秒，可以进行二次延时投递（重新发送一个延时消息，直到满足条件）。</p><p><strong>业务层二次确认/轮询</strong>：发送一个较短延时的消息，在消费者端收到消息后，检查业务条件是否满足。如果不满足，可以重新投递或者通过其他方式（如数据库轮询）进行补偿。</p><p><strong>自定义延时消息存储</strong>：如果对精度有极高要求，并且预设等级无法满足，可能需要考虑自己实现一个延时消息存储方案（例如，基于 Redis ZSET 或数据库）。</p><p>消费者端是正常处理的</p><p>额外：</p><p><strong>消息积压与延时准确性</strong>：如果 Broker 消息积压严重，或者 Broker 负载过高，延时消息的投递时间可能会有一定偏差。RocketMQ 会尽力在指定延时时间后投递，但不能保证毫秒级的精确。</p><p><strong>修改延时等级配置</strong>：如果你需要自定义延时等级，可以在 Broker 的 <code>broker.conf</code> 配置文件中修改 <code>messageDelayLevel</code> 参数，并重启 Broker。但请注意，修改后会影响所有使用延时消息的 Topic。 <code>messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 3h 4h</code></p><p><strong>不适用于定时任务调度</strong>：尽管延时消息可以实现类似定时任务的功能，但对于复杂的、需要精确控制和管理（如 Quartz）的定时任务，不推荐完全依赖延时消息。延时消息更适合于与业务流相关的“延迟执行”场景。</p><h2 id="14-RocketMQ的过滤消息"><a href="#14-RocketMQ的过滤消息" class="headerlink" title="14.RocketMQ的过滤消息"></a>14.RocketMQ的过滤消息</h2><p>RocketMQ 提供了两种主要的过滤消息方式：</p><ol><li><strong>Tag 过滤（Broker 端过滤）</strong>：这是最常用也是推荐的方式。消息生产者在发送消息时为其设置一个或多个 <strong>Tag（标签）</strong>。消费者在订阅 Topic 时，可以指定只消费某个或某些 Tag 的消息。这种过滤是在 Broker 端完成的，即 Broker 只会将符合消费者订阅 Tag 的消息推送给消费者，大大减少了网络传输量。</li><li><strong>SQL 92 过滤（Broker 端过滤）</strong>：这是一种更高级的过滤方式，允许消费者使用 SQL 92 标准的表达式来过滤消息。消息生产者在发送消息时可以设置<strong>用户属性（User Property）</strong>。消费者可以编写类似 SQL WHERE 子句的表达式，根据这些属性的值进行过滤。这种过滤也是在 Broker 端完成的。</li></ol><p>Tag:</p><p>生产者在发送消息时，通过 <code>setTags()</code> 方法给消息设置标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TagFilterProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TagFilterProducerGroup&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;TagFilterTopic&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 Tag 为 &quot;Order&quot; 的消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;Order&quot;</span>, <span class="string">&quot;OrderID001&quot;</span>,</span><br><span class="line">                <span class="string">&quot;This is an order creation message.&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult1</span> <span class="operator">=</span> producer.send(msg1);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Sent Tag: Order, %s%n&quot;</span>, sendResult1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 Tag 为 &quot;Payment&quot; 的消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;Payment&quot;</span>, <span class="string">&quot;PaymentID001&quot;</span>,</span><br><span class="line">                <span class="string">&quot;This is a payment success message.&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult2</span> <span class="operator">=</span> producer.send(msg2);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Sent Tag: Payment, %s%n&quot;</span>, sendResult2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 Tag 为 &quot;Refund&quot; 的消息</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;Refund&quot;</span>, <span class="string">&quot;RefundID001&quot;</span>,</span><br><span class="line">                <span class="string">&quot;This is a refund request message.&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult3</span> <span class="operator">=</span> producer.send(msg3);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Sent Tag: Refund, %s%n&quot;</span>, sendResult3);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者在订阅 Topic 时，可以在 <code>subscribe()</code> 方法中指定 Tag。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TagFilterConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;TagFilterConsumerGroup&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅 Tag 为 &quot;Order&quot; 的消息</span></span><br><span class="line">        <span class="comment">// 如果想订阅多个 Tag，可以使用 &quot;TagA || TagB || TagC&quot;</span></span><br><span class="line">        <span class="comment">// 如果想订阅所有 Tag，使用 &quot;*&quot;</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TagFilterTopic&quot;</span>, <span class="string">&quot;Order&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Consume Thread: %s, Topic: %s, Tag: %s, MsgId: %s, Body: %s %n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(),</span><br><span class="line">                            msg.getTopic(),</span><br><span class="line">                            msg.getTags(),</span><br><span class="line">                            msg.getMsgId(),</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Tag Filter Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SQL 92 过滤</strong></p><p>在 Broker 的配置文件 <code>broker.conf</code> 中，需要将 <code>enablePropertyFilter</code> 参数设置为 <code>true</code>：</p><p>支持92过滤开启</p><p>生产者在发送消息时，通过 <code>putUserProperty()</code> 方法给消息设置自定义属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlFilterProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;SqlFilterProducerGroup&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;SqlFilterTopic&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;KEY&quot;</span> + i,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ Sql Filter Message &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置用户属性</span></span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;a&quot;</span>, String.valueOf(i)); <span class="comment">// 整数字符串</span></span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;abc&quot;</span> + i);       <span class="comment">// 字符串</span></span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;c&quot;</span>, String.valueOf(i % <span class="number">2</span> == <span class="number">0</span>)); <span class="comment">// 布尔值</span></span><br><span class="line"></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s, Properties: &#123;a=%s, b=%s, c=%s&#125;%n&quot;</span>, sendResult, msg.getProperty(<span class="string">&quot;a&quot;</span>), msg.getProperty(<span class="string">&quot;b&quot;</span>), msg.getProperty(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者端订阅使用 SQL 92 表达式过滤消息</p><p>消费者在订阅 Topic 时，使用 <code>MessageSelector.bySql()</code> 方法传入 SQL 92 表达式。</p><p><strong>支持的 SQL 92 语法：</strong></p><ul><li><strong>数值比较</strong>: <code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>&lt;=</code>,<code>BETWEEN</code>,<code>=</code></li><li><strong>字符比较</strong>: <code>=</code>, <code>&lt;&gt;</code>, <code>IN</code> (支持 <code>NOT IN</code> 但需要 Broker 版本支持)</li><li><strong>逻辑运算</strong>: <code>AND</code>, <code>OR</code>, <code>NOT</code></li><li><strong><code>IS NULL</code> 或者 <code>IS NOT NULL</code></strong>: 检查属性是否存在</li><li><strong>字符串常量</strong>: <code>&#39;abc&#39;</code>, <code>&#39;123&#39;</code></li><li><strong>数值常量</strong>: <code>123</code>, <code>3.14159</code></li><li><strong>布尔常量</strong>: <code>TRUE</code>, <code>FALSE</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.MessageSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlFilterConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;SqlFilterConsumerGroup&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>); <span class="comment">// 替换为你的NameServer地址</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 SQL 92 表达式过滤消息</span></span><br><span class="line">        <span class="comment">// 例如：a &gt; 5 AND (b = &#x27;abc7&#x27; OR c IS TRUE)</span></span><br><span class="line">        <span class="comment">// 注意：属性值会作为字符串处理，进行数值比较时会自动转型</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;SqlFilterTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;a between 3 and 6 and c = true&quot;</span>));</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;Consume Thread: %s, MsgId: %s, Body: %s, Properties: &#123;a=%s, b=%s, c=%s&#125;%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(),</span><br><span class="line">                            msg.getMsgId(),</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()),</span><br><span class="line">                            msg.getProperty(<span class="string">&quot;a&quot;</span>),</span><br><span class="line">                            msg.getProperty(<span class="string">&quot;b&quot;</span>),</span><br><span class="line">                            msg.getProperty(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;SQL Filter Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>单场景（按类型区分）</strong>：<strong>优先使用 Tag 过滤</strong>。它性能更高，配置简单，能满足绝大部分按消息类型过滤的需求。</li><li><strong>复杂场景（按属性值过滤）</strong>：当 Tag 无法满足你的过滤需求，需要根据消息的多个属性值进行复杂的逻辑判断时，可以考虑使用 <strong>SQL 92 过滤</strong>。但需要注意：<ul><li><strong>Broker 端支持</strong>：确保你的 RocketMQ Broker 版本支持 SQL 92 过滤，并且已经开启了 <code>enablePropertyFilter</code>。</li><li><strong>性能考量</strong>：SQL 92 过滤虽然灵活，但其解析和执行会比 Tag 过滤消耗更多的 Broker 资源。在对性能要求极高的场景下，应谨慎使用或进行压测。</li></ul></li></ul><h2 id="15-RocketMQ的事务消息，事务消息的机制了解吗？讲一讲回查机制？"><a href="#15-RocketMQ的事务消息，事务消息的机制了解吗？讲一讲回查机制？" class="headerlink" title="15.RocketMQ的事务消息，事务消息的机制了解吗？讲一讲回查机制？"></a>15.RocketMQ的事务消息，事务消息的机制了解吗？讲一讲回查机制？</h2><p>RocketMQ 的事务消息实现了一个<strong>两阶段提交（Two-Phase Commit）</strong>的简化版本，但它巧妙地规避了传统 XA 事务的性能开销和复杂性，通过引入“半事务消息”和“消息回查”机制来实现最终一致性。</p><p>流程：</p><p><strong>发送半事务消息（Half Message）</strong></p><ul><li>生产者向 RocketMQ Broker 发送一条消息，这条消息被标记为“<strong>半事务消息</strong>”。</li><li><strong>Broker 收到半事务消息后，将其持久化，但并不会立即将它投递给消费者</strong>。它会返回一个 <code>ACK</code> 给生产者，表示消息已收到。此时，消费者是看不到这条消息的。</li></ul><p><strong>执行本地事务</strong></p><ul><li>生产者收到 Broker 的 <code>ACK</code> 后，开始执行自己的<strong>本地事务</strong>（例如，更新数据库、调用其他内部服务等）。</li><li><strong>这一步是事务消息的核心</strong>：你的业务逻辑会在这里完成，决定事务的最终状态。</li></ul><p><strong>提交或回滚半事务消息</strong></p><ul><li>根据本地事务的执行结果，生产者向 Broker 发送<strong>二次确认（Second Confirmation）</strong>：<ul><li>如果本地事务执行<strong>成功</strong>，生产者发送 <code>Commit</code> 命令。Broker 收到 <code>Commit</code> 后，会将之前存储的半事务消息标记为“可投递”，并将其真正投递给消费者。</li><li>如果本地事务执行<strong>失败</strong>（或需要回滚），生产者发送 <code>Rollback</code> 命令。Broker 收到 <code>Rollback</code> 后，会<strong>删除或丢弃</strong>之前存储的半事务消息，消费者永远不会收到这条消息。</li></ul></li></ul><p><strong>消息回查（Transaction Message Check）</strong></p><ul><li>这是 RocketMQ 事务消息的“杀手锏”，用于处理网络异常、生产者宕机等极端情况。</li><li>如果在步骤3中，生产者发送的二次确认（<code>Commit</code> 或 <code>Rollback</code>）因为网络问题丢失，或者生产者在执行本地事务后宕机，导致 Broker <strong>长时间没有收到二次确认</strong>，那么 Broker 会主动向生产者发起<strong>消息回查请求</strong>。</li><li>Broker 会询问生产者：<code>嘿，这条半事务消息的本地事务状态到底是什么？是成功了还是失败了？</code></li><li>生产者需要实现一个<strong>事务回查监听器 (<code>TransactionListener</code>)</strong>，当收到回查请求时，它会<strong>查询本地事务的最终状态</strong>（例如，查询数据库中相关订单的状态），并根据查询结果再次向 Broker 返回 <code>Commit</code> 或 <code>Rollback</code>。</li><li>Broker 收到回查结果后，再次执行步骤3的逻辑（标记为可投递或删除）。</li></ul><p>消息回查流程：</p><ol><li><strong>Broker 监控半事务消息</strong>：Broker 内部有一个定时任务，会不断扫描那些长时间（可配置，例如默认1分钟）处于“半事务”状态的消息。</li><li><strong>发起回查</strong>：当发现有“超时”的半事务消息时，Broker 会向<strong>原始生产者组（Producer Group）</strong>中的任意一个存活的生产者实例发送回查请求。</li><li><strong>生产者执行 <code>checkLocalTransaction</code></strong>：生产者接收到回查请求后，会调用其实现的 <code>TransactionListener</code> 接口中的 <code>checkLocalTransaction()</code> 方法。<ul><li>在这个方法里，生产者需要根据消息的唯一标识（通常是 <code>MsgId</code> 或者业务 <code>Key</code>）去<strong>查询本地事务的真实状态</strong>。</li><li>例如，如果你的业务是“下单后发消息”，那么在这个回查方法里，你就需要根据消息中的订单ID去查询订单表，看看订单状态是否是“已支付”。</li><li>根据查询结果，<code>checkLocalTransaction()</code> 方法会返回三种状态：<ul><li><strong><code>LocalTransactionState.COMMIT_MESSAGE</code></strong>：表示本地事务已经成功，Broker 可以将半事务消息投递给消费者。</li><li><strong><code>LocalTransactionState.ROLLBACK_MESSAGE</code></strong>：表示本地事务已经失败或需要回滚，Broker 会删除半事务消息。</li><li><strong><code>LocalTransactionState.UNKNOW</code></strong>：表示当前无法确定本地事务状态（例如，查询超时、数据库暂时不可用）。此时，RocketMQ 会<strong>过一段时间再次发起回查</strong>，直到获取明确的状态。</li></ul></li></ul></li><li><strong>Broker 处理回查结果</strong>：Broker 根据生产者返回的状态，决定将半事务消息 <code>Commit</code> 或 <code>Rollback</code>。</li></ol><p><strong>回查机制的优点：</strong></p><ul><li><strong>保证最终一致性</strong>：即使在极端情况下（网络闪断、生产者宕机），也能通过回查机制最终确定消息的去向，保证业务数据与消息状态的一致性。</li><li><strong>避免资源浪费</strong>：如果本地事务失败，消息就不会被发送出去，避免了消费者收到无效消息，从而减少了不必要的消费处理。</li><li><strong>低耦合</strong>：生产者和消费者之间不需要直接依赖本地事务状态，而是通过 Broker 进行协调。</li></ul><h2 id="16-Rocketmq的高可用"><a href="#16-Rocketmq的高可用" class="headerlink" title="16.Rocketmq的高可用"></a>16.Rocketmq的高可用</h2><p>主要依赖于其 Broker 集群架构以及 Dledger 组件（在 RocketMQ 4.5.0 之后引入，并逐步推广）。RocketMQ 高可用的核心目标在于，即使部分 Broker 节点发生故障，消息仍然能够可靠地被持久化、生产和消费，保障业务的连续性。</p><p>架构：</p><ul><li><strong>NameServer:</strong> NameServer 是一个轻量级的服务发现和路由中心，用于维护 Broker 的路由信息。NameServer 通常部署为一个集群，保证高可用性。即使部分 NameServer 宕机，客户端仍然可以从其他 NameServer 获取路由信息。</li><li><strong>Broker:</strong> Broker 是 RocketMQ 的消息存储和转发节点。为了实现高可用，Broker 通常部署为一个集群。Broker 集群中的每个 Broker 节点都有一个角色，即 Master 和 Slave。</li></ul><ul><li><strong>Master:</strong> Master Broker 负责接收客户端的消息写入请求，并将消息存储到本地磁盘。</li><li><strong>Slave:</strong> Slave Broker 负责从 Master Broker 复制消息数据，以备 Master 宕机时接管服务。</li></ul><p>会出现的问题：</p><ul><li><strong>数据一致性问题:</strong> 在异步复制模式下，如果 Master 宕机，可能会丢失部分尚未同步到 Slave 的消息。</li><li><strong>切换延迟:</strong> 主备切换需要一定的时间，在切换期间服务不可用。</li><li><strong>脑裂问题:</strong> 在极端情况下，Master 和 Slave 之间可能会出现网络隔离，导致脑裂，数据不一致。</li></ul><p><strong>Dledger 方案</strong>：</p><p>它基于 Raft 一致性算法，提供更强的一致性和更高的可用性，替代了之前的普通主从复制模式。</p><ul><li><strong>Raft 协议：</strong> Dledger 使用 Raft 协议在多个 Broker 节点之间选举出一个 Leader，只有 Leader 节点才能处理客户端的写入请求。 所有的数据变更都必须经过 Leader 的批准，并且复制到 Followers 节点上，确保数据一致性。</li><li><strong>高可用架构：</strong> Dledger 使得 RocketMQ 可以构建一个高可用的 Broker 集群，其中 Leader 节点负责处理读写请求，Follower 节点负责备份数据。 如果 Leader 节点发生故障，Raft 协议会自动选举出一个新的 Leader，保证服务的连续性。</li><li><strong>自动故障转移：</strong> 当 Leader 节点宕机时，Raft 协议会自动选举出一个新的 Leader，无需人工干预。 客户端会自动重连到新的 Leader 节点，继续进行消息的生产和消费。</li><li><strong>数据一致性保证：</strong> Raft 协议保证了所有节点上的数据一致性。 即使在发生故障转移的情况下，也不会出现数据丢失或数据不一致的问题。</li></ul><p>配置要点：</p><ul><li><strong>NameServer 集群：</strong> 部署多个 NameServer 实例，组成 NameServer 集群，并确保客户端配置了所有 NameServer 的地址。</li><li><strong>Broker 集群：</strong> 部署多个 Broker 节点，并配置 Master 和 Slave 关系（在 Dledger 模式下配置 Dledger 集群）。</li><li><strong>同步刷盘（SyncFlush）：</strong> 启用同步刷盘机制，确保消息被可靠地写入磁盘。这会牺牲一定的性能，但可以提高数据的可靠性。</li><li><strong>同步复制（SyncMaster）：</strong> 对于传统 Master-Slave 架构，启用同步复制模式，确保消息被复制到 Slave 节点。 (Dledger模式下，数据同步由Dledger组件保证)</li><li><strong>监控和告警：</strong> 实施全面的监控和告警机制，以便及时发现和处理故障。</li></ul><h2 id="17-RocketMQ的消息可靠性"><a href="#17-RocketMQ的消息可靠性" class="headerlink" title="17.RocketMQ的消息可靠性"></a>17.RocketMQ的消息可靠性</h2><p>生产者：</p><p>使用Rocketmq自带的事务消息，</p><p>事务消息原理：首先生产者会发送一个<strong>half 消息</strong>(对原始消息的封装)，该消息对消费者不可见，MQ 通过 ACK 机制返回消息接受状态， 生产者执行本地事务并且返回给 MQ 一个状态(Commit、RollBack 等)，如果是 Commit 的话 MQ 就会把消息给到下游， RollBack 的话就会丢弃该消息，状态如果为 UnKnow 的话会过一段时间回查本地事务状态，默认回查 15 次，一直是 UnKnow 状态的话就会丢弃此消息。</p><p>为什么先发一个 half 消息，作用就是先判断下 MQ 有没有问题，服务正不正常。</p><p>持久化：<strong>MQ 收到消息后写入硬盘如何保证不丢失？</strong></p><p>数据存盘绕过缓存，改为同步刷盘，这一步需要修改 Broker 的配置文件，将 flushDiskType 改为 SYNC_FLUSH 同步刷盘策略，默认的是 ASYNC_FLUSH 异步刷盘，<strong>一旦同步刷盘返回成功，那么就一定保证消息已经持久化到磁盘中了。</strong></p><p><strong>消息写入硬盘后，硬盘坏了如何保证不丢失？</strong></p><p>为了保证磁盘损坏导致丢失数据，RocketMQ 采用主从机构，集群部署，Leader 中的数据在多个 Follower 中都存有备份，防止单点故障导致数据丢失。</p><p>Master 节点挂了怎么办？Master 节点挂了之后 DLedger 登场</p><ul><li>接管 MQ 的 commitLog</li><li>选举从节点</li><li>文件复制 uncommited 状态 多半从节点收到之后改为 commited</li></ul><p>消费者消费 MQ 如何保证不丢失？</p><ol><li>如果是网络问题导致的消费失败可以进行重试机制，默认每条消息重试 16 次</li><li>多线程异步消费失败，MQ 认为已经消费成功但是实际上对于业务逻辑来说消息是没有落地的，解决方案就是按照 mq 官方推荐的先执行本地事务再返回成功状态。</li></ol><p>整个 MQ 节点挂了如何保证不丢失？</p><p>这种极端情况可以消息发送失败之后先存入本地，例如放到缓存中，另外启动一个线程扫描缓存的消息去重试发送。</p><h2 id="18-RocketMQ为什么这么快，可以借鉴哪些地方"><a href="#18-RocketMQ为什么这么快，可以借鉴哪些地方" class="headerlink" title="18.RocketMQ为什么这么快，可以借鉴哪些地方"></a>18.RocketMQ为什么这么快，可以借鉴哪些地方</h2><p>1.<strong>顺序写入磁盘</strong></p><p>RocketMQ 的速度很大程度上得益于它采用了顺序写磁盘的策略。 磁盘的顺序写性能比随机写高几个数量级。 消息会被顺序地追加到 CommitLog 文件中，这使得写入速度非常快。</p><p>磁盘寻道时间是随机写的主要瓶颈，顺序写避免大量的磁头寻道操作。</p><p>2.<strong>PageCache 高效利用</strong></p><p>RocketMQ 充分利用了操作系统的 PageCache。 Broker 会优先从 PageCache 中读取数据，减少了对磁盘的直接访问，提高了读取性能。</p><p>Broker 从 CommitLog 中读取消息并发送给 Consumer 时，如果 CommitLog 中的数据已经在 PageCache 中，则可以直接从内存中读取，无需进行物理磁盘 IO。 即使数据不在 PageCache 中，由于顺序读取的特性，也可以通过预读机制将数据加载到 PageCache 中。</p><p>3.<strong>零拷贝技术</strong></p><p>RocketMQ通过零拷贝技术，例如<code>sendfile</code>， 减少了数据在内核空间和用户空间之间的复制，从而提升了消息的传输效率。消息可以直接从磁盘发送到网络接口， 减少了 CPU 的开销。</p><p>传统的 IO 操作需要多次数据拷贝。 例如, 通常需要经过 磁盘 -&gt; 内核缓冲区 -&gt; 用户缓冲区 -&gt; Socket缓冲区 -&gt; 网络 这样的路径。 零拷贝技术可以减少甚至避免这些拷贝。</p><p>避免在用户态和内核态的多次拷贝</p><p>4.<strong>避免随机读</strong></p><p>RocketMQ 的消费模型设计避免了大量的随机读。 消息是按照 Offset 顺序消费的， 这样可以充分利用磁盘的顺序读性能。</p><p>5.<strong>轻量的消息结构</strong></p><p>RocketMQ 的消息结构设计得非常轻量级， 只包含必要的元数据和消息体。 这减少了序列化和反序列化的开销， 提高了消息处理的速度。</p><p>轻量级的消息结构如何保证消息的可靠性? 通过 Broker 端的持久化机制和 Consumer 的 ACK 机制来保证。</p><p><strong>6.高效的网络通信</strong></p><p>RocketMQ 基于 Netty 框架构建， 采用了 Reactor 模式， 使用异步非阻塞 IO。 这使得 Broker 可以处理大量的并发连接， 提高了系统的吞吐量</p><p><strong>7.尽可能无锁化操作</strong></p><p>RocketMQ 在设计上尽量避免使用锁， 使用 CAS (Compare and Swap) 操作等无锁技术， 减少了线程上下文切换的开销， 提高了并发性能</p><h2 id="19-RocketMQ-的存储机制"><a href="#19-RocketMQ-的存储机制" class="headerlink" title="19.RocketMQ 的存储机制"></a>19.RocketMQ 的存储机制</h2><p>RocketMQ 的存储采用一种混合型的存储结构，既有类似日志结构的顺序写 CommitLog，又有用于快速索引的 ConsumeQueue。 这种设计使得 RocketMQ 既能保证写入的高吞吐量，又能兼顾消费的效率。</p><p><strong>CommitLog (消息存储)</strong></p><p><strong>顺序写</strong>(Sequential Write) 是 CommitLog 最重要的特性。 消息按照到达 Broker 的顺序，依次追加到 CommitLog 文件末尾。 这使得写入速度非常快， 能够应对高并发的写入场景。</p><ul><li>CommitLog 由多个 CommitLog 文件组成， 每个文件大小固定 (默认1GB)。</li><li>当一个文件写满后，会自动创建新的文件进行写入。</li><li>文件名以偏移量命名，方便查找。</li></ul><p>CommitLog 是 RocketMQ 存储消息的核心文件。 所有的消息都以追加写的方式写入 CommitLog， 保证了写入的高吞吐量。 CommitLog 文件是顺序写的， 这也是 RocketMQ 能够应对高并发写入的关键原因。</p><p>顺序写如何保证？ Broker 接收到 Producer 发送的消息后，直接将消息追加到 CommitLog 文件的末尾， 没有随机 IO 操作。</p><p>高并发的处理策略：</p><ul><li><strong>批量写入：</strong> Broker 可以将多个消息批量写入 CommitLog， 减少 IO 次数。</li><li><strong>PageCache：</strong> 利用操作系统的 PageCache， 将数据缓存在内存中， 减少直接的磁盘 IO。</li><li><strong>异步刷盘：</strong> 可以配置成异步刷盘， 不必每次写入都进行磁盘同步，进一步提升写入性能。 但是， 也需要注意数据可靠性的权衡。</li></ul><p><strong>ConsumeQueue (消息索引)</strong></p><p>存储的是消息在 CommitLog 中的 offset (物理偏移量)、消息长度、Message Tag 的 hashcode。</p><p>相对于 CommitLog 来说， ConsumeQueue 更多的是<strong>随机读</strong>。 (虽然也会顺序追加新的索引，但消费时会根据指定的 queueId 和 offset 查找对应的索引项)</p><ul><li>ConsumeQueue 也是由多个文件组成，每个文件大小固定。</li><li>每个 ConsumeQueue 文件对应一个 Topic 下的某个 QueueId。</li><li>文件名以偏移量命名，方便查找。</li></ul><p>ConsumeQueue 相当于是 CommitLog 的索引文件。 它存储了消息在 CommitLog 中的位置信息， 使得 Consumer 可以快速地定位到消息， 提高了消费效率。 没有ConsumeQueue的话， 消费消息就需要扫描整个 CommitLog。</p><ul><li><strong>加速消费:</strong> Consumer 可以根据 Topic 和 QueueId， 从 ConsumeQueue 中找到消息在 CommitLog 中的位置 (offset)， 然后直接从 CommitLog 中读取消息。 避免了扫描整个 CommitLog 文件。</li><li><strong>过滤消息:</strong> Consumer 可以根据 Message Tag 进行消息过滤。 ConsumeQueue 中存储了 Tag 的 hashcode， Consumer 可以先在 ConsumeQueue 中进行 Tag 过滤， 减少不必要的消息读取。</li></ul><p>联系：</p><ul><li><p>ConsumeQueue 是根据 CommitLog 异步生成的。 Broker 会启动一个后台线程， 定期扫描 CommitLog， 并将消息的索引信息提取出来， 写入 ConsumeQueue</p></li><li><p><strong>对应关系:</strong> 一个 CommitLog 文件对应多个 ConsumeQueue 文件 (每个 Topic 的每个 QueueId 对应一个 ConsumeQueue 文件)。</p></li></ul><ol><li><strong>CommitLog 恢复：</strong> 扫描 CommitLog 文件， 找到最后一个有效的消息 Offset。</li><li><strong>ConsumeQueue 恢复：</strong> 根据 CommitLog 中最后一个有效的消息 Offset， 重新构建 ConsumeQueue。 如果 ConsumeQueue 已经存在， 则需要进行校验和修复。</li></ol><h2 id="20-RocketMQ中Broker的刷盘策略有哪些"><a href="#20-RocketMQ中Broker的刷盘策略有哪些" class="headerlink" title="20.RocketMQ中Broker的刷盘策略有哪些"></a>20.RocketMQ中Broker的刷盘策略有哪些</h2><p>提供了两种刷盘策略：</p><ol><li><strong>同步刷盘 (SYNC_FLUSH)</strong></li><li><strong>异步刷盘 (ASYNC_FLUSH)</strong></li></ol><p>同步刷盘：</p><p>同步刷盘指的是消息写入 CommitLog 后， 必须等待刷盘完成后，才返回 Producer 写入成功。 这种方式数据可靠性最高， 但是性能较低。 适用于对数据可靠性要求极高的场景。</p><p>通过 <code>FileChannel.force()</code> 方法强制将 PageCache 中的数据刷到磁盘。</p><p>异步刷盘：</p><p>异步刷盘指的是消息写入 CommitLog 后，立即返回 Producer 写入成功， 不需要等待刷盘完成。 这种方式性能较高，但是数据可靠性相对较低。 适用于对性能要求较高， 可以容忍少量消息丢失的场景。</p><ul><li><strong>定时刷盘:</strong> 定时将 PageCache 中的数据刷到磁盘。</li><li><strong>积累一定消息后刷盘:</strong> 当 PageCache 中积累的消息达到一定数量时， 将数据刷到磁盘。</li><li><strong>OS 调度刷盘:</strong> 完全由操作系统来决定何时将 PageCache 中的数据刷到磁盘。</li></ul><h2 id="21-RocketMO中的Broker部署方式"><a href="#21-RocketMO中的Broker部署方式" class="headerlink" title="21.RocketMO中的Broker部署方式"></a>21.RocketMO中的Broker部署方式</h2><p>1.单节点</p><p>2.多节点同步双写</p><p>多 Broker 同步双写部署方式，至少需要两个 Broker 节点。 消息同步写入到两个 Broker 节点， 只有两个 Broker 都写入成功，才返回 Producer 写入成功。 这种方式数据可靠性高，但是写入性能较低。</p><p>3.异步复制：</p><p>多 Broker 异步复制部署方式， 至少需要两个 Broker 节点。 消息先写入到 Master Broker， 然后异步复制到 Slave Broker。这种方式写入性能较高，但是数据可靠性相对较低。</p><p>4.<strong>Dledger 模式</strong></p><p>“Dledger 模式是 RocketMQ 提供的基于 Raft 协议的 CommitLog 复制解决方案。 它能够提供更高的可用性和数据一致性。 在 Dledger 模式下，多个 Broker 组成一个 Raft 组， 自动选举 Leader， 实现故障转移。</p><h2 id="22-RocketMQ怎么实现路由注册-amp-路由发现"><a href="#22-RocketMQ怎么实现路由注册-amp-路由发现" class="headerlink" title="22.RocketMQ怎么实现路由注册&amp;路由发现"></a>22.RocketMQ怎么实现路由注册&amp;路由发现</h2><p>路由注册</p><p>在 RocketMQ 中，路由注册主要涉及以下几个核心组件及其交互：</p><ol><li><strong>Producer（生产者）</strong></li><li><strong>Broker（消息服务器）</strong></li><li><strong>NameServer（命名服务）</strong></li><li><strong>Topic（主题）</strong></li><li><strong>Consumer（消费者）</strong></li></ol><p>通过 Broker 定期向 NameServer 注册自身信息与 Topic 信息， NameServer 收集这些信息， Producer/Consumer 从 NameServer 获取 Broker 列表， 并根据配置的负载均衡策略选择 Broker。</p><p>RocketMQ 的路由注册机制通过 Broker 主动注册、心跳保活，NameServer 维护路由表，Producer/Consumer 动态发现 Broker，实现了高度的灵活性和可扩展性。 这种设计使得 RocketMQ 能够很好地适应 Broker 的动态变化， 保证消息的可靠传输。</p><p>详细：</p><p>当 Broker 启动时，它会主动向所有的 NameServer 节点注册自己。 注册的信息包括：</p><ul><li>Broker 的 IP 地址和端口。</li><li>Broker ID（区分 Master 和 Slave）。</li><li><p>Broker 所管理的 Topic 列表。 每个 Broker 会存储多个 Topic 的数据。</p></li><li><p><strong>定期注册：</strong> Broker 会定时（默认 30 秒）向 NameServer 发送心跳包，更新自己的状态和 Topic 信息。 这确保了 NameServer 能够及时感知 Broker 的存活状态和 Topic 信息变化。</p></li><li><p><strong>注册成功后：</strong> NameServer 会保存 Broker 的信息，并更新 Topic 路由表。</p><p>Producer 和 Consumer 启动时，也会连接到 NameServer，获取 Topic 的路由信息。</p></li><li><p>Producer 根据要发送消息的 Topic 从 NameServer 获取路由信息。</p></li><li><p>Consumer 根据要订阅的 Topic 从 NameServer 获取路由信息。</p><p><strong>本地缓存：</strong> Producer 和 Consumer 会将获取到的路由信息缓存在本地， 避免频繁访问 NameServer。</p><p><strong>定期更新：</strong> Producer 和 Consumer 会定期（默认 30 秒）从 NameServer 更新路由信息， 以便及时感知 Broker 的变更。</p><p><strong>异常处理：</strong> 如果 Producer/Consumer 无法连接到 NameServer， 则会尝试连接其他 NameServer 节点。 如果从 NameServer 获取路由失败，则会重试。</p></li></ul><p>NameServer 维护着整个 RocketMQ 集群的路由信息</p><p>包括：</p><ul><li>Key: Topic 名称</li><li>Value: Broker 列表，包含了所有提供该 Topic 服务的 Broker 实例信息，包括IP地址、端口、BrokerId（Master/Slave）等。</li></ul><p>功能：</p><p><strong>Broker 变更感知：</strong> NameServer 通过心跳机制感知 Broker 的状态变化（例如 Broker 宕机）。 如果 Broker 长时间没有发送心跳包， NameServer 会将其从路由表中移除。</p><p><strong>Topic 变更感知：</strong> 当 Topic 的配置发生变化时， Broker 会主动通知 NameServer， NameServer 会更新路由表。</p><p><strong>数据同步：</strong> NameServer 集群之间不进行数据同步， 每个 NameServer 节点都保存着完整的路由信息。 Producer/Consumer 会从多个 NameServer 节点获取路由信息， 从而实现高可用。</p><p>参数：</p><ul><li><code>namesrvAddr</code>: Producer 和 Consumer 配置的 NameServer 地址列表，多个地址用分号分隔。</li><li><code>brokerClusterName</code>: Broker 所属的集群名称。</li><li><code>brokerName</code>: Broker 的名称。</li><li><code>brokerId</code>: Broker 的 ID， 0 表示 Master， 非 0 表示 Slave。</li><li><code>topicName</code>: Topic 的名称。</li></ul><hr><p>路由发现</p><p>RocketMQ 的路由发现是构建在其路由注册机制之上的，它允许 Producer 和 Consumer 动态地找到合适的 Broker 来发送和接收消息。 路由发现过程的核心是 NameServer。</p><p>Producer 和 Consumer 启动时， 会配置 NameServer 地址列表 (多个NameServer地址用分号分隔: <code>namesrvAddr</code>)。  它们会尝试连接列表中的 NameServer 节点。</p><p>Producer 需要发送消息到指定的 Topic， Consumer 需要订阅特定的 Topic， 因此它们会向 NameServer 查询该 Topic 的路由信息。</p><p> NameServer 查找其存储的路由表，找到包含该 Topic 的所有 Broker 信息。</p><ul><li><code>defaultTopicQueueNums</code>: 指定 Topic 默认的 Queue 数量。</li><li><code>topicFilterFlag</code>: Topic 过滤标志。</li><li><code>order</code>: 是否是顺序消息；顺序消息只允许单线程消费， 所以只有一个 MessageQueue, 对应的Broker 只有一个 .</li></ul><p>NameServer 将 Broker 列表（包括 Master 和 Slave 的信息）返回给 Producer/Consumer。 这个Broker 列表包含了每个Broker的IP地址、端口号以及Broker ID。</p><p>本地缓存：</p><ul><li><strong>缓存路由信息：</strong> Producer 和 Consumer 收到 NameServer 返回的路由信息后， 会将这些信息缓存到本地内存中。</li><li><strong>目的：</strong> 这样做可以避免每次发送/接收消息都向 NameServer 发起请求， 提高效率。</li></ul><p>路由定期更新：</p><ul><li><strong>定期更新：</strong> 为了能够感知 Broker 的变化， Producer 和 Consumer 会定期 (默认30s) 向 NameServer 发起路由信息更新请求。</li><li><strong>Broker 变更感知：</strong> 如果 Broker 发生故障、新增或者下线， NameServer 会更新路由表。 Producer/Consumer 在下一次路由信息更新时，就可以感知到这些变化。</li><li><strong>异常处理：</strong> 如果在一段时间内， Producer/Consumer 无法从 NameServer 获取到 Topic 的路由信息， 程序会进行重试。</li></ul><h1 id="Kafak"><a href="#Kafak" class="headerlink" title="Kafak"></a>Kafak</h1><h2 id="1-对Kafka有什么了解吗？"><a href="#1-对Kafka有什么了解吗？" class="headerlink" title="1.对Kafka有什么了解吗？"></a>1.对Kafka有什么了解吗？</h2><p>Kafka特点如下：</p><ul><li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li><li>可扩展性：kafka集群支持热扩展</li><li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li>高并发：支持数千个客户端同时读写</li></ul><h2 id="2-Kafka-为什么这么快？"><a href="#2-Kafka-为什么这么快？" class="headerlink" title="2.Kafka 为什么这么快？"></a>2.Kafka 为什么这么快？</h2><ul><li><strong>顺序写入优化</strong>：Kafka将消息顺序写入磁盘，减少了磁盘的寻道时间。这种方式比随机写入更高效，因为磁盘读写头在顺序写入时只需移动一次。</li><li><strong>批量处理技术</strong>：Kafka支持批量发送消息，这意味着生产者在发送消息时可以等待直到有足够的数据积累到一定量，然后再发送。这种方法减少了网络开销和磁盘I/O操作的次数，从而提高了吞吐量。</li><li><strong>零拷贝技术</strong>：Kafka使用零拷贝技术，可以直接将数据从磁盘发送到网络套接字，避免了在用户空间和内核空间之间的多次数据拷贝。这大幅降低了CPU和内存的负载，提高了数据传输效率。</li><li><strong>压缩技术</strong>：Kafka支持对消息进行压缩，这不仅减少了网络传输的数据量，还提高了整体的吞吐量。</li></ul><h2 id="3-kafka的模型介绍一下，kafka是推送还是拉取？"><a href="#3-kafka的模型介绍一下，kafka是推送还是拉取？" class="headerlink" title="3.kafka的模型介绍一下，kafka是推送还是拉取？"></a>3.kafka的模型介绍一下，kafka是推送还是拉取？</h2><p>消费者通常有两种与 Broker 交互的模型：<strong>推送模型（Push Model）</strong> 和 <strong>拉取模型（Pull Model）</strong>。Kafka 选择了后者，</p><p><strong>推送模型（Push Model)原理</strong></p><p>在推送模型中，消息代理（Broker）主动将消息推送给消费者。当有新消息到达 Broker 时，<strong>Broker 会根据一定的策略（如轮询、最少连接等）将消息发送给订阅的消费者。</strong></p><p>优点</p><ul><li><strong>实时性高</strong>：消息一旦到达 Broker 就能立即被消费者获取并处理，延迟较低。</li><li><strong>开发简单</strong>：消费者只需等待接收消息即可，无需主动请求。</li></ul><p>缺点</p><ul><li><strong>消费者负载控制困难</strong>：Broker 无法得知每个消费者的处理能力。如果推送速度过快，而消费者处理能力跟不上，容易导致消费者过载、崩溃，甚至数据丢失。这就像水龙头一直全开，而水桶可能接不过来。</li><li><strong>流量控制复杂</strong>：需要<strong>复杂的流量控制机制来避免消费者过载</strong>，例如 Broker 维护每个消费者的处理速率，动态调整推送速度，这增加了 Broker 的复杂性。</li><li><strong>不灵活</strong>：消费者被动接收消息，无法根据自身处理能力或特定需求（如批量消费）来调整消息获取节奏。</li></ul><hr><p><strong>拉取模型（Pull Model）</strong></p><p>在拉取模型中，<strong>消费者主动向消息代理（Broker）请求消息</strong>。消费者定期或按需向 Broker 发送拉取请求，Broker 接收到请求后，将可用的消息返回给消费者。</p><p>优点</p><ul><li><strong>消费者自我控制</strong>：消费者可以根据自身的处理能力、网络状况或业务需求来决定何时、以何种速率拉取多少消息。这就像水桶根据自身容量和需要，主动去水龙头接水。</li><li><strong>避免过载</strong>：消费者不会因为 Broker 推送过快而导致过载，因为它只在准备好时才去拉取消息。</li><li><strong>批量消费效率高</strong>：消费者可以一次性拉取一批消息进行批量处理，减少网络往返次数，提高吞吐量，这对于磁盘 I/O 友好的消息系统尤为重要。</li></ul><p>缺点</p><ul><li><strong>实时性可能略低</strong>：如果消费者拉取间隔设置过长，可能会引入额外的消息延迟。</li><li><strong>空轮询问题</strong>：如果 Broker 没有新消息，消费者仍然会发送拉取请求，这会导致“空轮询”，浪费网络资源和 CPU 周期。Kafka 对此有优化措施。</li></ul><hr><p>Kafka 选择拉取模型的原因（重点）</p><p>Kafka 选择拉取模型是基于其<strong>高吞吐量、持久化存储和分布式特性</strong>的考量。以下是主要原因：</p><ol><li><p><strong>适应消费者异构处理能力</strong>：Kafka 的设计目标之一是<strong>支持大量异构的消费者</strong>，它们可能拥有不同的处理能力和速度。<strong>拉取模型允许每个消费者根据自己的节奏消费</strong>，避免了“快生产者-慢消费者”导致的问题。消费者可以在消息量大时快速拉取，在消息量小时或处理繁忙时放缓拉取速度。</p></li><li><p><strong>优化批量消息处理</strong>：<strong>Kafka 的设计理念是基于日志（Log）的</strong>，它将消息追加写入磁盘。批量地从磁盘读取消息远比单条读取效率高。<strong>拉取模型允许消费者一次性拉取一批（或一个批次）消息进行处理，从而最大限度地利用磁盘 I/O，提高整体吞吐量。</strong></p></li><li><p><strong>简化 Broker 设计</strong>：将流控和背压（backpressure）的复杂性从 Broker 转移到消费者端。<strong>Broker 只需关注消息的持久化和按需提供</strong>，无需跟踪每个消费者的消费状态和处理能力，这使得 Broker 的设计更加简单、健壮，更易于扩展。</p></li><li><p><strong>更好的容错性和伸缩性</strong>：消费者故障或新增时，不会对 Broker 造成冲击。新的消费者加入或旧的消费者退出时，只需重新分配分区和调整拉取逻辑即可。</p></li><li><p><strong>消费者主动控制偏移量 (Offset)</strong>：这是拉取模型最重要的优势之一，也是 Kafka 独特且强大的特性。</p><p>消费者如何通过控制偏移量实现灵活的消息消费</p><p>Kafka 的每个分区（Partition）<strong>都是一个有序的、不可变的消息序列</strong>，每条消息都有一个唯一的、递增的<strong>偏移量（Offset）</strong>。消费者在拉取消息时，会记录自己消费到的当前偏移量。Kafka Broker <strong>不负责跟踪消费者的消费状态</strong>，而是由<strong>消费者自己负责管理其消费的偏移量。</strong></p><ul><li><strong>提交偏移量</strong>：消费者成功处理一批消息后，会向 Kafka 提交（commit）它已处理的最新消息的偏移量。这个偏移量通常存储在 Kafka 内部的一个特殊 Topic (<code>__consumer_offsets</code>) 中。</li><li><strong>从指定偏移量开始消费</strong>：当消费者启动或重新平衡（rebalance）时，它会从已提交的偏移量处开始消费。这种机制赋予了消费者极大的灵活性：<ul><li><strong>重置到旧偏移量（Time Travel）</strong>：如果因为业务逻辑错误或需要重新处理历史数据，消费者可以<strong>手动将偏移量重置到更早的时间点或更小的偏移量</strong>。例如，通过 <code>seek()</code> 方法将消费指针移到指定偏移量，甚至可以通过时间戳 (<code>seek(TopicPartition, long timestamp)</code>) 寻找到某个时间点的偏移量。这使得 Kafka 成为一个“时间机器”，可以重复消费数据。</li><li><strong>跳到最新位置（Consume from Latest）</strong>：如果消费者只想处理新生成的消息，或者跳过历史积压，它可以将偏移量直接<strong>设置为分区中的最新偏移量</strong>。这意味着它会从当前写入位置开始消费，忽略所有之前的历史消息。这对于快速启动消费者，只关注实时数据很有用。</li></ul></li></ul><p>这种基于偏移量自主控制的消费模式，使得 Kafka 的消费者非常灵活，能够适应各种复杂的业务场景，包括数据回溯、灾难恢复、实时处理与历史批处理的结合等。</p></li></ol><p><strong>消费者组的概念</strong></p><p>Kafka 引入了<strong>消费者组（Consumer Group）</strong>的概念来实现高伸缩性和高可用性。</p><ul><li><strong>实现水平扩展</strong>：<ul><li><strong>一个 Topic 的一个分区在同一时刻只能被一个消费者组中的一个消费者实例消费。</strong></li><li>当一个消费者组内有多个消费者实例时，Kafka 会将 Topic 的所有分区<strong>均匀地分配</strong>给组内的消费者。例如，如果一个 Topic 有 10 个分区，一个消费者组有 5 个消费者实例，那么每个消费者可能负责消费 2 个分区。</li><li>通过增加消费者组内的消费者实例数量，可以提高整个消费者组的并发处理能力，实现水平扩展。<strong>当消费者数量等于分区数量时，每个分区由一个消费者处理，达到最大并行度。</strong>如果消费者数量超过分区数量，多余的消费者将处于空闲状态。</li></ul></li><li><strong>实现故障转移（高可用性）</strong>：<ul><li>当消费者组中的某个消费者实例发生故障（如崩溃、下线）时，Kafka 会触发<strong>再平衡（Rebalance）</strong>机制。</li><li>Kafka 会将该消费者原来负责消费的分区<strong>自动重新分配</strong>给组内其他活跃的消费者实例。</li><li>这样，即使有消费者实例故障，整个消费者组的消费任务也不会中断，保证了高可用性。新的消费者实例上线也会触发再平衡，将部分分区分配给它。</li></ul></li></ul><p><strong>消费者如何通过拉取模式从 Broker 读取数据</strong></p><p>消费者组中的每个消费者实例，都会对它被分配到的每个分区执行拉取操作：</p><ol><li><strong>初始化</strong>：消费者启动并加入消费者组。通过<strong>心跳机制与 Broker 保持连接</strong>，并参与分区分配（再平衡）。</li><li><strong>获取偏移量</strong>：消费者从 <code>__consumer_offsets</code> Topic 中获取其负责的每个分区的已提交偏移量，作为下一次拉取消息的起始位置。</li><li><strong>发送拉取请求</strong>：消费者向其分配到的分区的 Leader Broker 发送 <code>FetchRequest</code>。请求中包含它想从哪个分区、从哪个偏移量开始、拉取多少字节的消息等信息。</li><li><strong>Broker 响应</strong>：Leader Broker 收到请求后，从其日志文件中读取指定偏移量之后的消息，并以 <code>FetchResponse</code> 返回给消费者。</li><li><strong>消费者处理</strong>：消费者收到消息后，进行业务逻辑处理。</li><li><strong>提交偏移量</strong>：处理成功后，消费者将新的偏移量提交到 <code>__consumer_offsets</code> Topic，更新自己的消费进度。</li><li><strong>循环拉取</strong>：消费者会持续循环执行 3-6 步，不断地拉取并处理消息。</li></ol><p><strong>解决无数据时的循环问题（长轮询）</strong></p><p>为了解决拉取模型可能出现的“空轮询”问题和提高效率，Kafka 的拉取请求通常采用<strong>长轮询（Long Polling）</strong>机制：</p><ul><li>当消费者发送拉取请求时，如果 Broker 上没有立即可用的新消息，Broker 不会立即返回空结果。</li><li>相反，Broker 会<strong>持有（hold）</strong>住这个请求一段时间（由消费者请求中的 <code>max.wait.ms</code> 参数控制，默认 500ms）。</li><li>在这段时间内，<strong>如果新的消息到达了，或者达到了等待时间，Broker 才会将这些新消息返回给消费者。</strong></li><li>如果等待时间内没有新消息，Broker 才会返回一个空的结果。</li><li>这样，就避免了消费者频繁地发送空请求，减少了网络和 CPU 资源的浪费，同时又保证了相对较好的实时性。</li></ul><h2 id="4-Kafka-如何保证顺序读取消息？"><a href="#4-Kafka-如何保证顺序读取消息？" class="headerlink" title="4.Kafka 如何保证顺序读取消息？"></a>4.Kafka 如何保证顺序读取消息？</h2><p>Kafka 可以保证在同一个分区内消息是有序的，生产者写入到同一分区的消息会按照写入顺序追加到分区日志文件中，消费者从分区中读取消息时也会按照这个顺序。这是 Kafka 天然具备的特性。</p><p>要在 Kafka 中保证顺序读取消息，需要结合生产者、消费者的配置以及合适的业务处理逻辑来实现。以下具体说明如何实现顺序读取消息：</p><ul><li>生产者端确保消息顺序：为了保证消息写入同一分区从而确保顺序性，生产者需要将消息发送到指定分区。<strong>可以通过自定义分区器来实现，通过为消息指定相同的Key，保证相同Key的消息发送到同一分区。</strong></li><li>消费者端保证顺序消费：消费者在消费消息时，需要<strong>单线程消费同一分区的消息</strong>，这样才能保证按顺序处理消息。如果使用多线程消费同一分区，就无法保证消息处理的顺序性。</li></ul><p>Kafka 本身不能保证跨分区的消息顺序性，如果需要全局的消息顺序性，通常有以下两种方法：</p><ul><li>只使用一个分区：<strong>将所有消息都写入到同一个分区，消费者也只从这个分区消费消息</strong>。但这种方式会导致 Kafka 的并行处理能力下降，因为 Kafka 的性能优势在于多分区并行处理。</li><li>业务层面保证：在业务代码中对消息进行<strong>编号或添加时间戳等标识</strong>，消费者在消费消息后，根据这些标识对消息进行排序处理。但这种方式会增加业务代码的复杂度。</li></ul><h2 id="5-kafka-消息积压怎么办？"><a href="#5-kafka-消息积压怎么办？" class="headerlink" title="5.kafka 消息积压怎么办？"></a>5.kafka 消息积压怎么办？</h2><p>Kafka 消息积压是一个常见的问题，它可能会导致数据处理延迟，甚至影响业务的正常运行，下面是一些解决 Kafka 消息积压问题的常用方法：</p><ul><li><strong>增加消费者实例可以提高消息的消费速度</strong>，从而缓解积压问题。你需要确保消费者组中的消费者数量<strong>不超过分区数量</strong>，因为一个分区同一时间只能被一个消费者消费。</li><li>增加 Kafka 主题的分区数量可以提高消息的并行处理能力。在创建新分区后，你需要重新平衡消费者组，让更多的消费者可以同时消费消息。</li></ul><h2 id="6-Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？"><a href="#6-Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？" class="headerlink" title="6.Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？"></a>6.Kafka为什么一个分区只能由消费者组的一个消费者消费？这样设计的意义是什么？</h2><p>同一时刻，<strong>一条消息只能被组中的一个消费者实例消费</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1724653429445-22f12b17-9413-4611-9d78-c3599d8c7906.png" alt="img"></p><p>如果两个消费者负责同一个分区，那么就意味着两个消费者同时读取分区的消息，由于消费者自己可以控制读取消息的offset，就有可能C1才读到2，而C1读到1，C1还没处理完，C2已经读到3了，则会造成很多浪费，因为这就相当于多线程读取同一个消息，会造成消息处理的重复，且不能保证消息的顺序。</p><h2 id="7-如果有一个消费主题topic，有一个消费组group，topic有10个分区，消费线程数和分区数的关系是怎么样的？"><a href="#7-如果有一个消费主题topic，有一个消费组group，topic有10个分区，消费线程数和分区数的关系是怎么样的？" class="headerlink" title="7.如果有一个消费主题topic，有一个消费组group，topic有10个分区，消费线程数和分区数的关系是怎么样的？"></a>7.如果有一个消费主题topic，有一个消费组group，topic有10个分区，消费线程数和分区数的关系是怎么样的？</h2><p>topic下的一个分区只能被同一个consumer group下的一个consumer线程来消费，但反之并不成立，即一个consumer线程可以消费多个分区的数据，比如Kafka提供的ConsoleConsumer，默认就只是一个线程来消费所有分区的数据。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1732606891790-bf7cb080-0209-46bc-80b4-5f96ad88453f.webp" alt="img"></p><p>所以，<strong>分区数决定了同组消费者个数的上限</strong>。</p><p><strong>如果你的分区数是N，那么最好线程数也保持为N，这样通常能够达到最大的吞吐量。</strong>超过N的配置只是浪费系统资源，因为多出的线程不会被分配到任何分区。</p><h2 id="8-消息中间件如何做到高可用？"><a href="#8-消息中间件如何做到高可用？" class="headerlink" title="8.消息中间件如何做到高可用？"></a>8.消息中间件如何做到高可用？</h2><p>消息中间件如何保证高可用呢？单机是没有高可用可言的，高可用都是对集群来说的，一起看下kafka的高可用吧。</p><p>Kafka 的基础集群架构，由多个<code>broker</code>组成，每个<code>broker</code>都是一个节点。当你创建一个<code>topic</code>时，它可以划分为多个<code>partition</code>，而每个<code>partition</code>放一部分数据，分别存在于不同的 broker 上。也就是说，<strong>一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</strong></p><p>有些伙伴可能有疑问，每个<code>partition</code>放一部分数据，如果对应的broker挂了，那这部分数据是不是就丢失了？那还谈什么高可用呢？</p><blockquote><p>Kafka 0.8 之后，提供了HA机制，复制品副本机制来保证高可用，即每个 partition 的数据都会同步到其它机器上，形成多个副本。<strong>然后所有的副本会选举一个 leader 出来，让leader去跟生产和消费者打交道，其他副本都是follower。</strong>写数据时，leader 负责把数据同步给所有的follower，读消息时， 直接读 leader 上的数据即可。如何保证高可用的？就是假设某个 broker 宕机，这个broker上的partition 在其他机器上都有副本的。如果挂的是leader的broker呢？其他follower会重新选一个leader出来。</p></blockquote><p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。</p><p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><h2 id="9-Kafka-和-RocketMQ-消息确认机制有什么不同？"><a href="#9-Kafka-和-RocketMQ-消息确认机制有什么不同？" class="headerlink" title="9.Kafka 和 RocketMQ 消息确认机制有什么不同？"></a>9.<strong>Kafka 和 RocketMQ 消息确认机制有什么不同？</strong></h2><p>Kafka的消息确认机制有三种：0，1，-1：</p><ul><li><strong>ACK=0</strong>：这是最不可靠的模式。<strong>生产者在发送消息后不会等待来自服务器的确认</strong>。这意味着消息可能会在发送之后丢失，而生产者将无法知道它是否成功到达服务器。</li><li><strong>ACK=1</strong>：这是默认模式，也是一种折衷方式。在这种模式下，<strong>生产者会在消息发送后等待来自分区领导者（leader）的确认</strong>，但不会等待所有副本（replicas）的确认。这意味着只要消息被写入分区领导者，生产者就会收到确认。如果分区领导者成功写入消息，但在同步到所有副本之前宕机，消息可能会丢失。</li><li><strong>ACK=-1</strong>：这是最可靠的模式。在这种模式下，<strong>生产者会在消息发送后等待所有副本的确认</strong>。只有在所有副本都成功写入消息后，生产者才会收到确认。这确保了消息的可靠性，但会导致更长的延迟。</li></ul><p>RocketMQ 提供了三种消息发送方式：同步发送、异步发送和单向发送：</p><ul><li><strong>同步发送</strong>：是指消息发送方发出一条消息后，会在<strong>收到服务端同步响应之后才发下一条消息的通讯方式</strong>。应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。</li><li><strong>异步发送</strong>：是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式，但是需要<strong>实现异步发送回调接口（SendCallback）</strong>。消息发送方在发送了一条消息后，不需要等待服务端响应即可发送第二条消息。发送方通过回调接口接收服务端响应，并处理响应结果。适用于链路耗时较长，对响应时间较为敏感的业务场景，例如，视频上传后通知启动转码服务，转码完成后通知推送转码结果等。</li><li><strong>单向发送</strong>：发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即<strong>只发送请求不等待应答</strong>。此方式发送消息的过程耗时非常短，一般在微秒级别。适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。</li></ul><h2 id="10-Kafka-和-RocketMQ-的-broker-架构有什么区别"><a href="#10-Kafka-和-RocketMQ-的-broker-架构有什么区别" class="headerlink" title="10.Kafka 和 RocketMQ 的 broker 架构有什么区别"></a>10.<strong>Kafka 和 RocketMQ 的 broker 架构有什么区别</strong></h2><ul><li>Kafka 的 broker 架构：Kafka 的 broker 架构采用了分布式的设计，<strong>每个 Kafka broker 是一个独立的服务实例</strong>，负责存储和处理一部分消息数据。Kafka 的 topic 被分区存储在不同的 broker 上，实现了水平扩展和高可用性。</li><li>RocketMQ 的 broker 架构：RocketMQ 的 broker 架构也是分布式的，但是<strong>每个 RocketMQ broker 有主从之分</strong>，一个主节点和多个从节点组成一个 broker 集群。<strong>主节点负责消息的写入和消费者的拉取，从节点负责消息的复制和消费者的负载均衡，提高了消息的可靠性和可用性。</strong></li></ul><h2 id="11-kafka是怎么解决消息幂等的"><a href="#11-kafka是怎么解决消息幂等的" class="headerlink" title="11.kafka是怎么解决消息幂等的"></a>11.kafka是怎么解决消息幂等的</h2><p><strong>幂等性 (Idempotence)</strong> 指的是，对于同一个操作，无论执行多少次，其结果都是相同的，不会对系统状态造成额外的副作用。在分布式系统中，由于网络抖动、超时重试等原因，<strong>消息生产者可能会重复发送同一条消息。如果不对这些重复消息进行处理，就可能导致数据不一致</strong>（例如，重复扣款、重复插入数据）。</p><p>Kafka 在 <strong>0.11.0 版本</strong> 引入了<strong>生产者幂等性</strong>，以确保消息在<strong>生产者到 Broker</strong> 的传输过程中，即使生产者重试，消息也只会被写入 Kafka <strong>一次且仅一次</strong>。</p><p><strong>原理：</strong></p><p>Kafka 实现生产者幂等性的核心机制是为每个生产者会话分配一个唯一的 <strong>Producer ID (PID)</strong>，并为每条消息分配一个<strong>序列号 (Sequence Number)</strong>。</p><p>当生产者首次连接到 Kafka 集群并启用幂等性时，Broker 会为这个生产者会话分配一个唯一的 <code>PID</code>。</p><p>这个 <code>PID</code> 在生产者会话的生命周期内保持不变。</p><p>每个 <code>PID</code> 都会维护一个针对每个分区递增的<strong>序列号</strong>。</p><p>生产者发送的每条消息都会带上其 <code>PID</code> 和对应的 <code>Sequence Number</code>。</p><p>broker：</p><p>当 Broker 收到消息时，它会检查消息的 <code>(PID, Partition, Sequence Number)</code> 元组。</p><p>对于每个 <code>(PID, Partition)</code>，Broker 会维护一个已接收到的最大序列号。</p><p>如果收到的消息的 <code>Sequence Number</code> <strong>等于</strong> Broker 记录的 <code>max_sequence_number + 1</code>，则表示这是一条新消息，Broker 会将其写入日志，并更新 最大序列号。</p><p>如果收到的消息的 <code>Sequence Number</code> <strong>小于或等于</strong> <code>max_sequence_number</code>，则表示这是一条<strong>重复消息</strong>（因为生产者重试发送了），Broker 会直接<strong>丢弃</strong>这条消息，但仍向生产者发送成功确认。</p><p>如果收到的消息的 <code>Sequence Number</code> <strong>大于</strong> <code>max_sequence_number + 1</code>，则表示消息乱序，这通常是不可恢复的错误，Broker 会抛出异常。</p><p>跟MVCC的read view的活跃事务id差不多</p><p><strong>配置：</strong></p><p>在 Kafka 生产者配置中，只需设置 <code>enable.idempotence=true</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties props <span class="operator">=</span> <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span><br><span class="line">props.put(&quot;enable.idempotence&quot;, &quot;true&quot;); <span class="operator">/</span><span class="operator">/</span> 启用幂等性</span><br><span class="line">props.put(&quot;acks&quot;, &quot;all&quot;); <span class="operator">/</span><span class="operator">/</span> 幂等性要求 acks 必须是 <span class="keyword">all</span></span><br><span class="line">props.put(&quot;retries&quot;, Integer.MAX_VALUE); <span class="operator">/</span><span class="operator">/</span> 启用幂等性后可以安全地重试</span><br></pre></td></tr></table></figure><p><strong>确保数据不重复</strong>：解决了生产者侧由于重试导致的重复消息问题。</p><p><strong>简化生产者逻辑</strong>：开发者无需在应用层手动处理消息去重。</p><p><strong>实现“精确一次语义”(Exactly-Once Semantics)</strong> 的基础：生产者幂等性是实现端到端事务性消息（包括跨多个 Topic/Partition 的事务）的关键组成部分。</p><p><strong>单会话、单分区</strong>：幂等性保证只在<strong>一个生产者会话内，且针对单个分区有效</strong>。如果生产者重启（<code>PID</code> 会变），或者消息发送到不同的分区，则无法保证幂等性。</p><p><strong>不处理消费者端的重复消费</strong>：生产者幂等性只解决了<strong>消息写入到 Kafka 的去重问题</strong>。消费者仍然可能因为重试消费等原因，从 Kafka 中<strong>读取到同一条消息多次</strong>。<strong>消费者端的去重（或保证“精确一次”处理）需要消费者自身结合业务逻辑实现，或者使用 Kafka Streams/Flink 等流处理框架的事务性功能。</strong></p><h2 id="12-kafka持久化的机制"><a href="#12-kafka持久化的机制" class="headerlink" title="12.kafka持久化的机制"></a>12.kafka持久化的机制</h2><p>Kafka 的持久性指的是它能够<strong>可靠地存储消息，即使在 Broker 宕机、网络故障等情况下也不会丢失数据</strong>。Kafka 通过以下几个核心机制来保证消息的持久性：</p><p>1.持久化到硬盘</p><p><strong>追加写入 (Append-Only Log)</strong>：Kafka 的所有数据都以<strong>日志（log）</strong>的形式存储在 Broker 的文件系统上。消息被追加写入到分区对应的日志文件中，是顺序写入，这使得磁盘 I/O 效率极高。</p><p><strong>不可变性 (Immutability)</strong>：一旦消息被写入分区，就是不可变的。它们不会被修改或删除，只能通过日志清理策略（基于时间或大小）来过期。</p><p><strong>文件系统缓存 (Page Cache)</strong>：Kafka 充分利用操作系统的文件系统缓存（Page Cache）。当消息写入磁盘时，它们首先进入操作系统的内存缓存，然后再异步地刷写到物理磁盘。这既提供了高性能写入，又在一定程度上保证了数据在内存中的持久性。</p><p>2.消息复制</p><p><strong>分区副本 (Partition Replicas)</strong>：Kafka 的每个 Topic 都被划分为多个<strong>分区 (Partitions)</strong>，每个分区都可以配置一个<strong>复制因子 (Replication Factor)</strong>。例如，如果 <code>replication.factor=3</code>，则每个分区会有 3 个副本。</p><p><strong>Leader-Follower 模型</strong>：每个分区都有一个<strong>Leader 副本</strong>和若干个<strong>Follower 副本</strong>。</p><ul><li><strong>Leader</strong>：负责处理该分区所有的生产（写入）和消费（读取）请求。</li><li><strong>Follower</strong>：被动地从 Leader 复制消息日志，保持与 Leader 的数据同步。</li></ul><p><strong>In-Sync Replicas (ISR)</strong>：<strong>同步副本集合</strong>。这是一个动态维护的集合，包含 Leader 副本和所有与 Leader 保持同步的 Follower 副本。<strong>判断同步的标准通常是 Follower 副本的日志与 Leader 副本的日志的差距在一个可配置的阈值之内。</strong></p><p><strong>故障转移 (Failover)</strong>：如果 Leader 副本所在的 Broker 宕机，Kafka 控制器（Controller）会从 ISR 中选举一个新的 Leader 副本，从而确保该分区持续可用且数据不丢失。只要 ISR 中至少有一个副本存活，数据就不会丢失。</p><p>3.生产者确认机制：</p><p>生产者在发送消息时，可以通过 <code>acks</code> 参数来配置不同级别的<strong>确认机制</strong>，从而控制消息的持久性保证：</p><ul><li><p><strong><code>acks=0</code> (Lowest Durability)</strong>：</p><ul><li>生产者发送消息后，<strong>不等待</strong> Broker 的任何确认就认为发送成功。</li><li><strong>优点</strong>：吞吐量最高，延迟最低。</li><li><strong>缺点</strong>：可靠性最差， Broker 宕机或消息未成功写入，都可能导致消息丢失。</li></ul></li><li><p><strong><code>acks=1</code> (Default / Moderate Durability)</strong>：</p><ul><li>生产者等待<strong>分区 Leader 副本</strong>确认消息已写入其本地日志（并进入文件系统缓存）。</li><li><strong>优点</strong>：相对高的吞吐量和较低的延迟，同时提供了基本的可靠性保证。</li><li><strong>缺点</strong>：如果 Leader 副本写入成功后，但在 Follower 副本同步之前 Leader 宕机，可能会导致消息丢失。</li></ul></li><li><p><strong><code>acks=all</code> (or <code>-1</code>) (Highest Durability)</strong>：</p><ul><li>生产者等待<strong>所有 ISR 中的副本</strong>都确认消息已写入其本地日志。</li><li><strong>优点</strong>：最高级别的可靠性保证，只要至少 <code>min.insync.replicas</code> 个副本存活，消息就不会丢失。</li><li><strong>缺点</strong>：吞吐量最低，延迟最高。因为需要等待所有同步副本的确认，如果某个 Follower 同步速度慢，就会增加延迟。</li><li><strong>推荐配置</strong>：为了最高的数据持久性，通常会配置 <code>replication.factor &gt;= 3</code>，<code>min.insync.replicas &gt;= 2</code>，并且生产者设置 <code>acks=all</code>。</li></ul></li></ul><p>  4.日志保留策略：</p><p>  Kafka 不会像传统消息队列那样在消息被消费后立即删除。它会根据配置的<strong>保留策略</strong>来持久化消息：</p><ul><li><strong>基于时间</strong>：消息保留多长时间（<code>log.retention.ms</code>，默认 7 天）。</li><li><strong>基于大小</strong>：日志文件达到多大时开始清理（<code>log.retention.bytes</code>）。</li><li><strong>日志压缩 (Log Compaction)</strong>：对于某些特殊的 Topic（如用于存储状态的 Topic），可以配置日志压缩。它会保留每个消息键的最新消息，清除旧的相同键的消息，从而实现按键的持久化。</li></ul><h2 id="13-kafka处理消息丢失"><a href="#13-kafka处理消息丢失" class="headerlink" title="13.kafka处理消息丢失"></a>13.kafka处理消息丢失</h2><p>消费者：关闭offset的自动提交</p><p>就是说，你消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>kafka丢数据：</p><p>就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>配置参数来解决：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code> ：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code> （很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><p>生产者：</p><p><code>acks=all</code> ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-RabbitMQ的特性你知道哪些？"><a href="#1-RabbitMQ的特性你知道哪些？" class="headerlink" title="1.RabbitMQ的特性你知道哪些？"></a>1.RabbitMQ的特性你知道哪些？</h2><p>abbitMQ 以 <strong>可靠性</strong>、<strong>灵活性</strong> 和 <strong>易扩展性</strong> 为核心优势，适合需要稳定消息传递的复杂系统。其丰富的插件和协议支持使其在微服务、IoT、金融等领域广泛应用，比较核心的特性有如下：</p><ul><li><strong>持久化机制</strong>：RabbitMQ 支持消息、队列和交换器的持久化。<strong>当启用持久化时，消息会被写入磁盘</strong>，即使 RabbitMQ 服务器重启，消息也不会丢失。例如，在声明队列时可以设置 <code>durable</code> 参数为 <code>true</code> 来实现队列的持久化：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个持久化队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;durable_queue&#x27;</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>消息确认机制</strong>：提供了生产者确认和消费者确认机制。生产者可以设置 <code>confirm</code> 模式，当消息成功到达 RabbitMQ 服务器时，会收到确认消息；消费者在处理完消息后，可以向 RabbitMQ 发送确认信号，告知服务器该消息已被成功处理，服务器才会将消息从队列中删除。</li><li><strong>镜像队列</strong>：支持创建镜像队列，将队列的内容复制到多个节点上，提高消息的可用性和可靠性。当一个节点出现故障时，其他节点仍然可以提供服务，确保消息不会丢失。</li><li><strong>多种交换器类型</strong>：RabbitMQ 提供了多种类型的交换器，如<strong>直连交换器（Direct Exchange）、扇形交换器（Fanout Exchange）、主题交换器（Topic Exchange）和头部交换器（Headers Exchange）</strong>。不同类型的交换器根据不同的规则将消息路由到队列中。例如，扇形交换器会将接收到的消息广播到所有绑定的队列中；主题交换器则根据消息的路由键和绑定键的匹配规则进行路由。</li></ul><h2 id="2-RabbitMQ的底层架构是什么？"><a href="#2-RabbitMQ的底层架构是什么？" class="headerlink" title="2.RabbitMQ的底层架构是什么？"></a>2.RabbitMQ的底层架构是什么？</h2><p>以下是 RabbitMQ 的一些核心架构组件和特性：</p><ul><li><strong>核心组件</strong>：生产者负责发送消息到 RabbitMQ、消费者负责从 RabbitMQ 接收并处理消息、RabbitMQ 本身负责存储和转发消息。</li><li><strong>交换机</strong>：交换机接收来自生产者的消息，并根据 routing key 和绑定规则将消息路由到一个或多个队列。</li><li><strong>持久化</strong>：RabbitMQ 支持消息的持久化，可以将消息保存在磁盘上，以确保在 RabbitMQ 重启后消息不丢失，队列也可以设置为持久化，以保证其结构在重启后不会丢失。</li><li><strong>确认机制</strong>：为了确保消息可靠送达，RabbitMQ 使用确认机制，费者在处理完消息后发送确认给 RabbitMQ，未确认的消息会重新入队。</li><li><strong>高可用性</strong>：RabbitMQ 提供了集群模式，可以将多个 RabbitMQ 实例组成一个集群，以提高可用性和负载均衡。通过镜像队列，可以在多个节点上复制同一队列的内容，以防止单点故障。</li></ul><h2 id="3-RabbitMQ交换器有哪些"><a href="#3-RabbitMQ交换器有哪些" class="headerlink" title="3.RabbitMQ交换器有哪些"></a>3.RabbitMQ交换器有哪些</h2><p>Direct Exchange（直连交换器）</p><p><strong>路由规则</strong>：Direct Exchange 会将消息路由到那些<strong>绑定键（Binding Key）与消息的路由键（Routing Key）完全匹配</strong>的队列。</p><p><strong>特点</strong>：点对点或一对一的精确路由。</p><p>比如：日志级别分发，私人消息等等。</p><p>Fanout Exchange（扇形交换器）</p><p><strong>路由规则</strong>：Fanout Exchange 会将接收到的所有消息<strong>广播</strong>到所有绑定到它的队列，无视消息的路由键和队列的绑定键。</p><p><strong>特点</strong>：发布/订阅模型，多播。</p><p>比如：系统广播通知，</p><p>Topic Exchange（主题交换器）</p><p><strong>路由规则</strong>：Topic Exchange 会根据消息的路由键和队列的绑定键的<strong>模式匹配</strong>（模糊匹配）将消息路由到队列。</p><ul><li>绑定键使用 <code>.</code> 分隔单词。</li><li><code>*</code> (星号) 匹配一个单词。</li><li><code>#</code> (井号) 匹配零个或多个单词。</li></ul><p><strong>特点</strong>：最强大的路由方式，实现复杂的发布/订阅模式。</p><p>比如：复杂日志订阅，一个大型分布式系统的日志收集与分析。不同的服务（如认证服务 <code>auth</code>、支付服务 <code>payment</code>、数据库服务 <code>db</code>）产生不同级别的日志。消费者可以根据自己感兴趣的日志类型（如所有严重错误、某个服务的所有日志、所有警告）进行订阅。</p><p>商品库存事件通知，电商平台中，针对不同品类商品的库存变动、价格更新、新品上架等事件进行通知。例如，库存部门只关心低库存预警，运营部门关心所有商品更新，而某个特定部门可能只关心电子产品的所有相关事件。</p><p>Headers Exchange（头部交换器）</p><p><strong>路由规则</strong>：Headers Exchange 不依赖于路由键，而是根据消息的<strong>头部属性（Headers）</strong>进行路由。队列与交换器绑定时，除了指定头部键值对，还需要指定一个 <code>x-match</code> 参数：</p><ul><li><code>x-match=all</code>：表示消息的所有头部属性必须与绑定时指定的头部属性完全匹配。</li><li><code>x-match=any</code>：表示消息的任意一个头部属性与绑定时指定的头部属性匹配即可。</li></ul><p><strong>特点</strong>：灵活性最高，但通常性能不如 Topic Exchange，且使用频率较低。</p><p>比如：多条件任务分发，任务调度系统，根据任务的优先级、类型、设备平台等多个维度进行复杂路由。例如，高优先级且关键的报警任务需要进入专门的处理队列，而来自移动设备的任务可以进入移动任务处理队列。</p><h2 id="4-说一说RabbitMQ中的AMQP"><a href="#4-说一说RabbitMQ中的AMQP" class="headerlink" title="4.说一说RabbitMQ中的AMQP"></a>4.说一说RabbitMQ中的AMQP</h2><p><strong>AMQP</strong> 是一种<strong>开放的、通用的消息协议</strong>，它定义了客户端应用程序和消息中间件之间进行消息传递的方式。你可以把它想象成消息通信领域的“HTTP 协议”或“SQL 协议”。就像 HTTP 定义了浏览器和服务器如何通信，SQL 定义了应用程序和数据库如何通信一样，AMQP 定义了<strong>如何发送、存储和接收消息</strong>。</p><p><strong>生产者 (Producer)</strong>：发送消息的应用程序。</p><p><strong>消费者 (Consumer)</strong>：接收并处理消息的应用程序。</p><p><strong>消息 (Message)</strong>：在生产者和消费者之间传递的数据单元。消息包含：</p><ul><li><strong>有效载荷 (Payload)</strong>：实际的数据，例如 JSON、XML 或二进制数据。</li><li><strong>属性 (Properties)</strong>：关于消息的元数据，例如内容类型、编码、优先级、过期时间等。</li></ul><p><strong>连接 (Connection)</strong>：TCP/IP 连接，生产者/消费者通过它与 RabbitMQ 建立连接。</p><p><strong>信道 (Channel)</strong>：在连接内部建立的轻量级逻辑连接。在同一个连接中可以有多个信道，这样可以复用 TCP 连接，减少开销。大部分 AMQP 操作都是在信道上进行的。</p><p><strong>交换器 (Exchange)</strong>：消息的接收者。生产者将消息发送到交换器，而不是直接发送到队列。交换器根据<strong>路由规则</strong>将消息路由到一个或多个队列。这是 AMQP 灵活路由的核心。</p><ul><li>RabbitMQ 支持多种交换器类型：<code>Direct</code>、<code>Fanout</code>、<code>Topic</code>、<code>Headers</code>。</li></ul><p><strong>绑定 (Binding)</strong>：交换器和队列之间的规则，它告诉交换器如何根据消息的<strong>路由键 (Routing Key)</strong> 将消息路由到哪个队列。</p><p><strong>队列 (Queue)</strong>：存储消息的地方。消息在被消费者消费之前会暂时存储在队列中。</p><p><strong>路由键 (Routing Key)</strong>：生产者发送消息时携带的一个字符串，交换器根据它和绑定键进行匹配，决定消息的路由去向。</p><p><strong>绑定键 (Binding Key)</strong>：队列在绑定到交换器时设置的一个字符串，用于与消息的路由键进行匹配。</p><p><strong>确认机制 (Acknowledgements)</strong>：AMQP 支持消费者对消息进行确认（ACK），告知 RabbitMQ 消息已成功处理。如果消费者没有确认，RabbitMQ 会认为消息未被正确处理，可能会重新投递。这保证了消息的<strong>可靠投递</strong>。</p><p>流程：</p><p>生产者连接到 RabbitMQ 服务器，建立一个<strong>连接 (Connection)</strong>。</p><p>在连接上创建一个或多个<strong>信道 (Channel)</strong>。</p><p>声明一个<strong>交换器 (Exchange)</strong>（如果不存在）。</p><p>声明一个<strong>队列 (Queue)</strong>（如果不存在）。</p><p>通过一个<strong>绑定 (Binding)</strong> 将队列绑定到交换器，并指定<strong>绑定键 (Binding Key)</strong>。</p><p>生产者通过信道向交换器发布消息，消息包含<strong>路由键 (Routing Key)</strong> 和有效载荷。</p><p>交换器根据其类型和绑定规则，匹配消息的路由键和队列的绑定键，将消息路由到一个或多个队列。</p><p>消费者连接到 RabbitMQ 服务器，建立连接和信道。</p><p>消费者从队列中拉取或订阅消息。</p><p>消费者处理消息后，向 RabbitMQ 发送<strong>确认 (ACK)</strong>。</p><p>AMQP 的优点：</p><ul><li><strong>开放标准</strong>：不限于特定厂商，提供了互操作性。你可以用 Java 客户端向 RabbitMQ 发送消息，用 Python 客户端接收。</li><li><strong>灵活性</strong>：通过交换器和绑定机制，实现了非常灵活的消息路由。</li><li><strong>可靠性</strong>：支持消息持久化、消息确认、发布者确认等机制，确保消息不丢失。</li><li><strong>跨平台/语言</strong>：由于是协议标准，有多种语言的客户端库支持。</li></ul><h2 id="5-RabbitMQ是怎么解决消息幂等问题的"><a href="#5-RabbitMQ是怎么解决消息幂等问题的" class="headerlink" title="5.RabbitMQ是怎么解决消息幂等问题的"></a>5.RabbitMQ是怎么解决消息幂等问题的</h2><p>实现 RabbitMQ 消息幂等性的核心思想是：为每条消息生成一个<strong>全局唯一标识符（Message ID）</strong>，并在消费者端维护一个<strong>已处理消息 ID 的记录</strong>。</p><p>跟kafka感觉差不多？？</p><p><strong>唯一ID：</strong></p><p>生产者是消息的源头，它有责任为每条消息生成一个全局唯一的 ID，并将其作为消息的元数据（通常是消息头）发送出去。</p><p><strong>UUID (Universally Unique Identifier)</strong>：最简单和常用的方法。生成一个随机的 128 位数字，冲突概率极低。</p><ul><li><strong>示例：</strong> <code>UUID.randomUUID().toString()</code></li></ul><p><strong>时间戳 + 机器/服务 ID + 计数器</strong>：这种方式可以<strong>保证 ID 的单调性</strong>（在一定程度上），方便排查问题，但实现略复杂。</p><ul><li><strong>示例：</strong> <code>System.currentTimeMillis() + &quot;-&quot; + serviceId + &quot;-&quot; + AtomicInteger.incrementAndGet()</code></li></ul><p><strong>业务唯一 ID</strong>：如果业务本身就存在一个唯一 ID（例如订单号、交易流水号），可以直接使用它作为消息 ID。这是最理想的情况，因为它天然与业务关联，易于追溯。</p><ul><li><strong>示例：</strong> 订单创建消息，直接使用 <code>orderId</code> 作为消息 ID。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessagePostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchangeName, String routingKey, String messageBody, String businessId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> <span class="string">&quot;业务唯一ID或UUID或自定义ID&quot;</span> + businessId; <span class="comment">// 例如： UUID.randomUUID().toString() + &quot;_&quot; + businessId;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MessagePostProcessor</span> <span class="variable">messagePostProcessor</span> <span class="operator">=</span> message -&gt; &#123;</span><br><span class="line">            <span class="type">MessageProperties</span> <span class="variable">messageProperties</span> <span class="operator">=</span> message.getMessageProperties();</span><br><span class="line">            messageProperties.setHeader(<span class="string">&quot;x-message-id&quot;</span>, messageId); <span class="comment">// 将唯一 ID 添加到消息头</span></span><br><span class="line">            messageProperties.setCorrelationId(messageId); <span class="comment">// 也可以使用 correlationId 字段</span></span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, routingKey, messageBody, messagePostProcessor);</span><br><span class="line">        <span class="comment">// 生产者发送消息时，记录下 messageId，用于本地审计或后续追踪</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Producer sent message with ID: &quot;</span> + messageId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者处理</strong></p><p>消费者是实现幂等性的核心环节。它需要<strong>维护一个已处理消息的 ID 存储</strong>，并在每次接收消息时进行判断。</p><p>从消息头中取出唯一 ID，并查询本地存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：消费者处理逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> (String) message.getMessageProperties().getHeader(<span class="string">&quot;x-message-id&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (messageId == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果消息没有 ID，可能是非幂等消息，或者处理异常，需要根据业务决定如何处理</span></span><br><span class="line">        System.err.println(<span class="string">&quot;Received message without ID: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isMessageProcessed(messageId)) &#123; <span class="comment">// 检查消息 ID 是否已存在于存储中</span></span><br><span class="line">        <span class="comment">// **如果消息 ID 已存在，直接丢弃该消息** (确认消息，不再重复处理)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Duplicate message received, ID: &quot;</span> + messageId + <span class="string">&quot;. Discarding.&quot;</span>);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>); <span class="comment">// 确认消息，防止 RabbitMQ 重发</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// **如果消息 ID 不存在，则进行消息处理**</span></span><br><span class="line">        processMessageBusinessLogic(message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// **处理成功后，将消息 ID 存入存储**</span></span><br><span class="line">        saveProcessedMessageId(messageId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确认消息已成功处理，RabbitMQ 会将其从队列中移除</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Message ID: &quot;</span> + messageId + <span class="string">&quot; processed successfully.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 消息处理失败，不确认（或进行 NACK），让 RabbitMQ 重新投递或进入死信队列</span></span><br><span class="line">        <span class="comment">// 注意：这里是关键，如果处理失败，不能将 ID 存入幂等存储，否则下次重试时会被当成重复消息</span></span><br><span class="line">        System.err.println(<span class="string">&quot;Message ID: &quot;</span> + messageId + <span class="string">&quot; processing failed: &quot;</span> + e.getMessage());</span><br><span class="line">        <span class="comment">// channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true); // 重新入队</span></span><br><span class="line">        channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="literal">true</span>); <span class="comment">// 拒绝并重新入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟检查消息ID是否已处理的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMessageProcessed</span><span class="params">(String messageId)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际实现会查询 Redis 或数据库</span></span><br><span class="line">    <span class="keyword">return</span> IdempotentStorage.contains(messageId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟保存已处理消息ID的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveProcessedMessageId</span><span class="params">(String messageId)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际实现会将 messageId 存入 Redis 或数据库</span></span><br><span class="line">    IdempotentStorage.add(messageId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟业务处理逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processMessageBusinessLogic</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 执行实际的业务逻辑，例如更新数据库、发送邮件等</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Processing business logic for message: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    <span class="comment">// 模拟业务处理失败</span></span><br><span class="line">    <span class="comment">// if (Math.random() &lt; 0.2) &#123;</span></span><br><span class="line">    <span class="comment">//     throw new RuntimeException(&quot;Simulated business error&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存储：</strong></p><p><strong>Redis</strong>：</p><ul><li><strong>优点</strong>：高性能、低延迟、支持过期时间（TTL）。非常适合作为缓存层，快速判断 ID 是否存在。</li><li><strong>缺点</strong>：内存存储，如果 Redis 宕机或重启，未持久化的数据会丢失（但 Redis 支持 AOF/RDB 持久化）。容量受限于内存。</li><li><strong>适用场景</strong>：绝大多数需要高性能幂等性的场景。</li></ul><p>可以使用 <strong>Set (集合)</strong> 或 <strong>String (字符串)</strong> 类型。</p><ul><li><strong>Set</strong>：<code>SADD processed_message_ids messageId</code>，<code>SISMEMBER processed_message_ids messageId</code>。</li><li><strong>String</strong>：<code>SET processed_message_id_</code><strong><code>messageId</code></strong> <code>1 EX timeout NX</code> （<code>key</code> 是 <code>messageId</code>，<code>value</code> 是任意占位符，<code>EX timeout</code> 设置过期时间，<code>NX</code> 保证原子性）。</li></ul><p><strong>过期时间 (TTL)</strong>：非常重要！消息 ID 不应永久存储，因为磁盘空间有限。设置一个合理的过期时间（例如 7 天、30 天，根据消息的生命周期和重复发送的可能性来定），让 Redis 自动清除过期 ID。</p><p><strong>容量</strong>：评估每天的消息量，确定存储这些 ID 需要的内存。如果 ID 数量巨大，可以考虑按天或按月创建不同的 Set/Key，或者使用 Redis Cluster 分片。</p><p><strong>关系型数据库 (MySQL, PostgreSQL)</strong>：</p><ul><li><strong>优点</strong>：数据持久化能力强，可靠性高，支持事务。</li><li><strong>缺点</strong>：性能相对 Redis 差，存在 I/O 瓶颈，并发能力有限。</li><li><strong>适用场景</strong>：对数据可靠性要求极高，且并发量不是特别巨大的场景，或者业务本身就强依赖数据库事务的场景。</li></ul><p><strong>查询</strong>：<code>SELECT COUNT(*) FROM processed_messages WHERE message_id = ? AND consumer_group = ?;</code></p><p><strong>插入</strong>：<code>INSERT INTO processed_messages (message_id, consumer_group, process_time) VALUES (?, ?, NOW());</code></p><p><strong>索引</strong>：必须在 <code>message_id</code> 或 <code>(message_id, consumer_group)</code> 上建立唯一索引，以保证 ID 的唯一性。</p><p><strong>清理</strong>：需要定期清理过期数据（例如通过定时任务删除 <code>process_time</code> 过早的记录）。</p><p><strong>分布式文件存储 (如 HDFS, S3)</strong>：</p><ul><li><strong>优点</strong>：容量巨大，成本低。</li><li><strong>缺点</strong>：查询延迟高，不适合实时判断。</li><li><strong>适用场景</strong>：极少数离线批处理或审计场景，不适合在线消息处理的幂等性判断。</li></ul><p><strong>异常处理：</strong></p><p>在“检查消息 ID 不存在 -&gt; 处理业务 -&gt; 记录消息 ID”这个流程中，如果业务处理失败，但消息 ID 已经存入存储，那么下次重试时就会被判断为重复消息而丢弃，导致消息丢失。因此，<strong>消息处理和消息 ID 存储必须是原子性的</strong>。</p><p><strong>数据库事务</strong>：</p><ul><li>如果业务处理和幂等性存储都在同一个数据库中，可以直接使用<strong>数据库事务</strong>。</li><li>将查询 ID、处理业务、插入 ID 放在同一个数据库事务中。</li><li>如果业务处理失败，事务回滚，消息 ID 也不会被记录。</li></ul><p><strong>Redis + 业务事务 (TCC/最终一致性)</strong>：</p><p>如果幂等性存储在 Redis，而业务处理涉及数据库或其他服务，则不能简单地用一个本地事务。</p><p><strong>方案一：先处理业务，后记录 ID (不推荐，可能出现业务成功但ID未记录)</strong></p><ul><li><code>try-catch</code> 捕获异常：如果业务处理失败，不记录 ID，不 ACK 消息，让 RabbitMQ 重试。</li><li><strong>问题</strong>：如果在业务处理成功后、记录 ID 之前服务崩溃，下次消息过来仍会被处理。</li></ul><p><strong>方案二：先记录 ID，再处理业务，异常时回滚 ID (复杂，但更可靠)</strong></p><ul><li><strong>两阶段提交 (Two-Phase Commit)</strong> 或 <strong>TCC (Try-Confirm-Cancel)</strong> 思想的简化版。</li><li>在 Redis 中先用 <code>SETNX</code> 尝试“预占”消息 ID，设置一个短的过期时间。</li><li>然后进行业务处理。</li><li>如果业务成功，则将 Redis 中的消息 ID 的过期时间设置为长期，并 ACK 消息。</li><li>如果业务失败，则删除 Redis 中的预占 ID，并 NACK 消息。</li><li><strong>问题</strong>：如果在业务成功后、设置过期时间为长期之前崩溃，这个 ID 可能会在短时间内过期，导致重复消费。</li></ul><p><strong>推荐方案 (结合消息确认机制)</strong>：</p><ul><li><strong>在消费消息后立即将消息 ID 存入 Redis，并设置一个相对短的过期时间（例如几分钟）。</strong></li><li><strong>异步执行实际的业务逻辑。</strong></li><li><strong>如果业务逻辑成功，再将 Redis 中的消息 ID 的过期时间延长至长期（或直接更新）。</strong></li><li><strong>最终成功后才 ACK 消息。</strong></li><li><strong>关键</strong>：如果业务处理失败或超时，消息 ID 在 Redis 中会过期，下次 RabbitMQ 重投消息时，该 ID 不存在，从而再次进入处理流程。</li><li><strong>死信队列</strong>：如果多次重试仍失败，可以将消息路由到死信队列，人工介入。</li></ul><p>更强的原子性：</p><p><strong>更强的原子性（两阶段确认）</strong>：</p><ol><li><strong>第一阶段</strong>：消费者收到消息后，在<strong>本地事务</strong>（如果业务和幂等存储在同一个数据库）或<strong>分布式事务</strong>（如 TCC）中，先进行幂等性判断并记录 ID，然后执行业务逻辑。</li><li><strong>第二阶段</strong>：只有当整个事务提交成功后，才向 RabbitMQ 发送 <code>basicAck</code>。如果事务失败，则不发送 <code>basicAck</code>，让 RabbitMQ 重新投递消息。 这种方式确保了消息处理和幂等性记录的<strong>最终一致性</strong>，因为只要消息 ID 未成功记录，或者业务未成功执行，RabbitMQ 就会重试。</li></ol><h2 id="6-RabbitMQ上的一个queue中存放-message是否有数量限制"><a href="#6-RabbitMQ上的一个queue中存放-message是否有数量限制" class="headerlink" title="6.RabbitMQ上的一个queue中存放 message是否有数量限制"></a>6.RabbitMQ上的一个queue中存放 message是否有数量限制</h2><p>是的有限制，是多种因素构成的</p><p>物理因素：内存和磁盘</p><p><strong>内存</strong></p><p>RabbitMQ 默认会将队列中的一部分消息保存在内存中，以提高消费性能。</p><p>当内存使用达到<strong>高水位阈值 (high water mark)</strong> 时（默认是 RabbitMQ 节点可用 RAM 的 40% 或 0.4 倍，可以通过 <code>vm_memory_high_watermark.relative</code> 或 <code>vm_memory_high_watermark.absolute</code> 配置），RabbitMQ 会触发内存警报，并<strong>阻塞生产者</strong>，阻止其继续发送消息，直到内存使用率下降。</p><p>内存中存储的主要是消息的<strong>元数据和最近发送/未消费的消息体</strong>。</p><p><strong>硬盘</strong></p><p>当队列中的消息数量过多，或者内存压力过大时，RabbitMQ 会将内存中的消息<strong>分页（page out）到磁盘上，以释放内存。这就是所谓的惰性队列 (Lazy Queues)</strong> 的工作原理，或对于经典队列在内存压力下进行的分页。</p><p>磁盘空间是另一个限制因素。如果磁盘空间不足，RabbitMQ 也会触发<strong>磁盘警报</strong>（默认剩余空间低于 5GB 或总容量的 80% 会触发警报），同样会阻塞生产者。</p><p>消息持久化（durable message）会直接写入磁盘，而非持久化消息也会在内存不足时被写到磁盘。</p><p><strong>配置</strong></p><p>多种参数来<strong>主动限制队列中消息的数量或总大小</strong>，可以防止队列溢出，防止单个队列无限增长，导致整个 Broker 资源耗尽</p><p><strong><code>x-max-length</code> (最大消息数量)</strong>：限制队列中可以存储的<strong>最大消息数量</strong>。当达到此限制时，队列会根据其溢出策略丢弃最老的消息（默认行为）。</p><p><strong><code>x-max-length-bytes</code> (最大消息总大小)</strong>：限制队列中可以存储的<strong>消息总字节数</strong>。当达到此限制时，同样会根据溢出策略丢弃最老的消息。</p><p>如果同时设置了 <code>x-max-length</code> 和 <code>x-max-length-bytes</code>，则<strong>两者都适用</strong>，哪个限制先达到就先强制执行。</p><p><strong><code>x-overflow</code> (溢出策略)</strong>：当队列达到 <code>x-max-length</code> 或 <code>x-max-length-bytes</code> 限制时，如何处理新消息：</p><ul><li><strong><code>drop-head</code> (默认)</strong>：丢弃队列头部（最老）的消息。</li><li><strong><code>reject-publish</code></strong>：拒绝生产者发布的新消息。生产者会收到 <code>basic.nack</code> 或通道阻塞。</li><li><strong><code>reject-publish-dlx</code></strong>：拒绝生产者发布的新消息，并将这些被拒绝的消息路由到死信交换器 (DLX)。</li></ul><p><strong><code>message-ttl</code> (消息 TTL / 过期时间)</strong>：可以为队列中的所有消息设置默认的过期时间。超过此时间，消息将自动从队列中删除。这可以间接限制消息的数量，尤其对于时效性强的消息。</p><p><strong>性能</strong></p><p><strong>消费延迟增加</strong>：大量消息堆积在队列中，消费者需要更长时间才能处理到最新的消息。</p><p><strong>内存交换到磁盘 (Paging out) 增加 I/O 负担</strong>：当消息从内存分页到磁盘时，会增加磁盘 I/O，降低整体吞吐量。</p><p><strong>集群同步开销</strong>：在镜像队列（Mirrored Queues）或仲裁队列（Quorum Queues）中，大量消息的同步会增加网络和 CPU 开销。</p><p><strong>管理界面响应变慢</strong>：当队列中有数百万甚至上亿条消息时，管理界面查询队列状态会非常缓慢。</p><p><strong>Broker 重启慢</strong>：如果 RabbitMQ Broker 异常重启，需要从磁盘加载和恢复大量的消息索引，导致启动时间变长。</p><h2 id="7-Rabbitmq的高可用"><a href="#7-Rabbitmq的高可用" class="headerlink" title="7.Rabbitmq的高可用"></a>7.Rabbitmq的高可用</h2><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每台机器启动一个。你<strong>创建的 queue，只会放在一个 RabbitMQ 实例上</strong>，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这个模式是没有高可用的</p><p>镜像集群模式（高可用性）</p><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论是元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong>，就是说，每个 RabbitMQ 节点都有这个 queue 的一个<strong>完整镜像</strong>，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把<strong>消息同步</strong>到多个实例的 queue 上。</p><p>这个策略是<strong>镜像集群模式的策略</strong>，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p><p>好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就<strong>没有扩展性可言</strong>了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并<strong>没有办法线性扩展</strong>你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</p><p>解决办法：</p><p>1.选择合适的同步策略，RabbitMQ允许你配置消息同步的节点数量。你可以选择将消息同步到所有节点（<code>ha-mode: all</code>）以获得最高的可用性，或者同步到指定的节点，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ha-mode: exactly`, `ha-sync-batch-size</span><br></pre></td></tr></table></figure><p>根据性能来选择。</p><p>2.限制单个队列的大小,避免在高可用队列中存储过多的消息。可以设置队列的最大长度或 TTL (time-to-live)，以防止队列无限制增长。 可以考虑将消息归档到外部存储系统。</p><p>3.使用队列分片，对于单个队列数据量过大的情况，可以将队列拆分成多个分片，每个分片分布在不同的节点上。  RabbitMQ 本身并不原生支持队列分片，但你可以通过客户端的逻辑来实现。  例如，可以根据消息的某个属性（如用户ID）进行哈希，然后将消息发送到对应的分片队列。</p><p>实现队列分片：</p><ul><li>生产者根据某种算法（通常是哈希）将消息路由到不同的队列。 例如，使用 <code>messageKey.hashCode() % numOfShards</code> 来决定消息应该发往哪个分片。</li><li><strong>消费者端合并：</strong> 消费者需要同时订阅多个分片队列，并将接收到的消息按照某种规则进行合并和处理。</li><li>可以结合批量发送来解决，但是消息的顺序是不能保证的</li></ul><p>4.<strong>Federation/Shovel 插件：</strong> 这两个插件允许你将消息从一个 RabbitMQ 集群桥接到另一个集群。 这可以用来实现跨数据中心的消息复制和负载均衡。 <code>Federation</code> 适用于更松耦合的场景，而 <code>Shovel</code> 则适用于更紧密耦合的场景。</p><p>5.<strong>Quorum Queues:</strong> RabbitMQ 3.8 引入Quorum Queues，它基于Raft一致性算法，提供了更强的一致性和更高的可靠性，同时也具有比镜像队列更好的性能。 但是它并非完全替代镜像队列，选择哪种方案需要考量具体的应用场景和需求。</p><h2 id="8-rabbit解决消息丢失问题"><a href="#8-rabbit解决消息丢失问题" class="headerlink" title="8.rabbit解决消息丢失问题"></a>8.rabbit解决消息丢失问题</h2><p>生产者：</p><p>RabbitMQ 提供的事务功能，就是生产者<strong>发送数据之前</strong>开启 RabbitMQ 事务 <code>channel.txSelect()</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback()</code> ，然后重试发送消息；如果收到了消息，那么可以提交事务 <code>channel.txCommit()</code> 。</p><p>但是因为rabbitmq是同步的，然后集群备份下来。性能比较低。</p><p>我们可以开启confirm模式：</p><p>在生产者那里设置开启 <code>confirm</code> 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p><p>已经在 transaction 事务模式的 channel 是不能再设置成 confirm 模式的，即这两种模式是不能共存的。</p><p><strong>普通confirm:</strong>每发送一条消息后，调用 <code>waitForConfirms()</code> 方法，等待服务器端 confirm，如果服务端返回 false 或者在一段时间内都没返回，客户端可以进行消息重发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line"><span class="keyword">if</span> (!channel.waitForConfirms()) &#123;</span><br><span class="line">    <span class="comment">// 消息发送失败</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>批量 confirm 模式</strong>：每发送一批消息后，调用 <code>waitForConfirms()</code> 方法，等待服务端 confirm。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; batchCount; ++i) &#123;</span><br><span class="line">    channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!channel.waitForConfirms()) &#123;</span><br><span class="line">    <span class="comment">// 消息发送失败</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异步 confirm 模式</strong>：提供一个回调方法，服务端 confirm 了一条或者多条消息后客户端会回调这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Long&gt;());</span><br><span class="line">channel.confirmSelect();</span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            confirmSet.remove(deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nack, SeqNo: &quot;</span> + deliveryTag + <span class="string">&quot;, multiple: &quot;</span> + multiple);</span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            confirmSet.remove(deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nextSeqNo</span> <span class="operator">=</span> channel.getNextPublishSeqNo();</span><br><span class="line">    channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">    confirmSet.add(nextSeqNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rabbit自己丢了数据：</p><p>这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p><ul><li>创建 queue 的时候将其设置为持久化。这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li><li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2。就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li></ul><p>需要同时设置这两个，才能成功开启</p><p>消费者弄丢了数据：</p><p>主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p><p>这个时候得用 RabbitMQ 提供的 <code>ack</code> 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 <code>ack</code> ，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p><p>为了保证消息从队列中可靠地到达消费者，RabbitMQ 提供了消息确认机制。消费者在声明队列时，<strong>可以指定 noAck 参数，当 noAck=false</strong>，RabbitMQ 会等待消费者显式发回 ack 信号后，才从内存（和磁盘，如果是持久化消息）中移去消息。否则，一旦消息被消费者消费，RabbitMQ 会在队列中立即删除它。</p><h2 id="9-RabbitMQ保证消息的顺序"><a href="#9-RabbitMQ保证消息的顺序" class="headerlink" title="9.RabbitMQ保证消息的顺序"></a>9.RabbitMQ保证消息的顺序</h2><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点，这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。</p><p>或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><p>注意，这里消费者不直接消费消息，而是将消息根据关键值（比如：订单 id）进行哈希，哈希值相同的消息保存到相同的内存队列里。也就是说，需要保证顺序的消息存到了相同的内存队列，然后由一个唯一的 worker 去处理。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/rocketmq/">rocketmq</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/24/new-stack/MQ1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://blog.tokenlen.top/2025/06/24/new-stack/nginx1/</link>
      <guid>https://blog.tokenlen.top/2025/06/24/new-stack/nginx1/</guid>
      <pubDate>Mon, 23 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的<strong>反向代理</strong>和<strong>负载均衡</strong>。</p><p><img src="https://pic1.zhimg.com/v2-e1826bab1d07df8e97d61aa809b94a10_1440w.jpg" alt=""></p><p>上图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。</p><p>正向代理：</p><p><img src="https://picx.zhimg.com/v2-c8ac111c267ae0745f984e326ef0c47f_1440w.jpg" alt=""></p><p>反向代理：</p><p><img src="https://pic2.zhimg.com/v2-4787a512240b238ebf928cd0651e1d99_1440w.jpg" alt=""></p><p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，<strong>正向代理“代理”的是客户</strong>端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</p><p>当我们在外网访问百度的时候，其实会进行一个转发，<strong>代理到内网去，这就是所谓的反向代理</strong>，<strong>即反向代理“代理”的是服务器端</strong>，而且这一个过程对于客户端而言是透明的。</p><ol><li>保障应用服务器的安全（增加一层代理，可以屏蔽危险攻击，更方便的控制权限）</li><li>实现负载均衡（稍等~下面会讲）</li><li>实现跨域（号称是最简单的跨域方式）</li></ol><h2 id="Nginx的Master-Worker模式"><a href="#Nginx的Master-Worker模式" class="headerlink" title="Nginx的Master-Worker模式"></a>Nginx的Master-Worker模式</h2><p>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p><p>Master进程的作用是？</p><p><strong>读取并验证配置文件nginx.conf；管理worker进程；</strong></p><p>Worker进程的作用是？</p><p><strong>每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</strong></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>启动 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx` 或 `sudo brew services start nginx</span><br></pre></td></tr></table></figure><p>停止 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s stop` 或 `sudo brew services stop nginx</span><br></pre></td></tr></table></figure><p>热重启 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>强制停止 Nginx：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pkill -9 nginx</span><br></pre></td></tr></table></figure><p><code>/usr/local/etc/nginx/nginx.conf</code> （nginx配置文件路径）</p><p><code>/usr/local/var/www</code> （nginx服务器默认的根目录）</p><p><code>/usr/local/Cellar/nginx/1.17.9</code> （nginx的安装路径）</p><p><code>/usr/local/var/log/nginx/error.log</code> (nginx默认的日志路径)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 首尾配置暂时忽略</span><br><span class="line">server &#123;  </span><br><span class="line">        # 当nginx接到请求后，会匹配其配置中的service模块</span><br><span class="line">        # 匹配方法就是将请求携带的host和port去跟配置中的server_name和listen相匹配</span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost; # 定义当前虚拟主机（站点）匹配请求的主机名</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # Nginx默认值</span><br><span class="line">            # 设定Nginx服务器返回的文档名</span><br><span class="line">            index  index.html index.htm; # 先找根目录下的index.html，如果没有再找index.htm</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 首尾配置暂时忽略</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server{ } 其实是包含在 http{ } 内部的。每一个 server{ } 是一个虚拟主机（站点）。</p><p>上面代码块的意思是：当一个请求叫做<code>localhost:8080</code>请求nginx服务器时，该请求就会被匹配进该代码块的 server{ } 中执行。</p><p>当然 nginx 的配置非常多，用的时候可以根据文档进行配置。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>动静分离：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/17/171867d175eae45f~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>Nginx 服务器将接收到的请求分为<strong>动态请求</strong>和<strong>静态请求</strong>。</p><p>静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。</p><p>这样做不仅能给应用服务器减轻压力，将后台api接口服务化，还能将前后端代码分开并行开发和部署。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8080</span>;        </span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html; <span class="comment"># Nginx默认值</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$</span> &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/local/var/www/my-project; <span class="comment"># 静态请求所代理到的根目录</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 动态请求匹配到path为&#x27;node&#x27;的就转发到8002端口处理</span></span><br><span class="line">        <span class="section">location</span> /node/ &#123;  </span><br><span class="line">            <span class="attribute">proxy_pass</span> http://localhost:8002; <span class="comment"># 充当服务代理</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html; # Nginx默认值</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        proxy_pass http://localhost:8000; # 反向代理配置，请求会被转发到8000端口</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反向代理的表现很简单。那上面的代码块来说，其实就是向nginx请求<code>localhost:8080</code>跟请求 <code>http://localhost:8000</code> 是一样的效果。（跟代购的原理一样）</p><p>这是一个反向代理最简单的模型，只是为了说明反向代理的配置。但是现实中反向代理多数是用在负载均衡中。</p><p>nginx 就是充当图中的 proxy。左边的3个 client 在请求时向 nginx 获取内容，是感受不到3台 server 存在的。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/16/17183720f7a66978~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>反向代理应用十分广泛，CDN 服务就是反向代理经典的应用场景之一。除此之外，反向代理也是实现负载均衡的基础，很多大公司的架构都应用到了反向代理。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>随着业务的不断增长和用户的不断增多，一台服务已经满足不了系统要求了。这个时候就出现了服务器 集群。</p><p>在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做<strong>负载均衡</strong>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/17/171862efada16376~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p>Nginx还带有<strong>健康检查</strong>（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。</p><p>一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 负载均衡：设置domain</span><br><span class="line">upstream domain &#123;</span><br><span class="line">    server localhost:8000;</span><br><span class="line">    server localhost:8001;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;  </span><br><span class="line">        listen       8080;        </span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # root   html; # Nginx默认值</span><br><span class="line">            # index  index.html index.htm;</span><br><span class="line">            </span><br><span class="line">            proxy_pass http://domain; # 负载均衡配置，请求会被平均分配到8000和8001端口</span><br><span class="line">            proxy_set_header Host $host:$server_port;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8000和8001是我本地用 Node.js 起的两个服务，负载均衡成功后可以看到访问 <code>localhost:8080</code> 有时会访问到8000端口的页面，有时会访问到8001端口的页面。</p><p>受集群单台服务器内存等资源的限制，负载均衡集群的服务器也不能无限增多。但因其良好的容错机制，负载均衡成为了实现<strong>高可用架构</strong>中必不可少的一环。</p><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。刚开始的时候，代理多数是帮助内网client访问外网server用的（比如HTTP代理），从内到外 . 后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网client的请求forward到内网server，从外到内</p><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="1-Nginx-实现负载均衡有哪几种方式？"><a href="#1-Nginx-实现负载均衡有哪几种方式？" class="headerlink" title="1.Nginx 实现负载均衡有哪几种方式？"></a>1.Nginx 实现负载均衡有哪几种方式？</h2><p><strong>轮询（Round Robin）</strong>：默认策略，顺序转发请求；</p><p><strong>加权轮询（Weighted Round Robin）</strong>：给服务器设置权重，权重大就多分配请求；</p><p><strong>IP Hash</strong>：根据客户端 IP 做哈希，把同一个 IP 的请求固定分配给同一台服务器；</p><p><strong>最少连接数（Least Connections）</strong>：优先转发给当前连接数最少的服务器（需要开启 <code>least_conn</code> 模块）；</p><p><strong>健康检查</strong>（可选）：检查服务器是否存活，不可用的服务器不会被请求到。</p><h2 id="2-你项目中用的是什么负载均衡策略？为什么选这个？"><a href="#2-你项目中用的是什么负载均衡策略？为什么选这个？" class="headerlink" title="2.你项目中用的是什么负载均衡策略？为什么选这个？"></a>2.你项目中用的是什么负载均衡策略？为什么选这个？</h2><p>我使用的是默认的轮询（round-robin）策略，因为我们集群内的服务节点配置基本一致，响应时间也相差不大，这样的简单策略就足够满足负载均衡需求。如果后期出现性能差异，再考虑使用加权轮询或 IP Hash 策略来优化。</p><h2 id="3-负载均衡后-session-如何保持？（Sticky-Session）"><a href="#3-负载均衡后-session-如何保持？（Sticky-Session）" class="headerlink" title="3.负载均衡后 session 如何保持？（Sticky Session）"></a>3.负载均衡后 session 如何保持？（Sticky Session）</h2><p>默认情况下，用户的请求会轮流打到不同的服务器，这样可能会导致 session 丢失。解决方案有：</p><ul><li><strong>使用 IP Hash 策略</strong>：让同一 IP 的请求打到同一台服务器；</li><li><strong>使用 cookie 记录和识别客户端，前端转发到固定节点</strong>；</li><li><strong>服务端使用 session 共享机制</strong>，如 Redis 分布式 session；</li><li><strong>客户端使用 token（如 JWT），实现无状态认证</strong>；</li></ul><h2 id="4-Nginx-如何判断服务器挂了？"><a href="#4-Nginx-如何判断服务器挂了？" class="headerlink" title="4.Nginx 如何判断服务器挂了？"></a>4.Nginx 如何判断服务器挂了？</h2><p>Nginx 的 <strong>openresty</strong> 或第三方模块（如 <code>nginx_upstream_check_module</code>）可以启用<strong>主动健康检查机制</strong>，通过定期向后端发送请求，判断其状态。</p><p>如果是默认配置，Nginx 并<strong>不会主动健康检查</strong>，只有当某个请求失败时，才会暂时标记服务器为不可用（被动方式）。</p><h2 id="5-upstream-模块中配置多个服务，如果其中一个挂了怎么办？"><a href="#5-upstream-模块中配置多个服务，如果其中一个挂了怎么办？" class="headerlink" title="5.upstream 模块中配置多个服务，如果其中一个挂了怎么办？"></a>5.upstream 模块中配置多个服务，如果其中一个挂了怎么办？</h2><p>如果使用了<strong>健康检查模块</strong>，Nginx 会主动检测并自动将该节点剔除；如果没开启，用户请求到挂掉的服务会失败一部分。</p><p>可以手动配置 <code>max_fails</code> 和 <code>fail_timeout</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server localhost:8000 max_fails=3 fail_timeout=30s;</span><br><span class="line">    server localhost:8001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示在 30 秒内失败超过 3 次就会暂时踢掉该节点。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Nginx/">Nginx</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/24/new-stack/nginx1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://blog.tokenlen.top/2025/06/22/new-stack/docker/</link>
      <guid>https://blog.tokenlen.top/2025/06/22/new-stack/docker/</guid>
      <pubDate>Sat, 21 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;困难现状&quot;&gt;&lt;a href=&quot;#困难现状&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="困难现状"><a href="#困难现状" class="headerlink" title="困难现状"></a>困难现状</h1><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><hr><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>但是会有以下的问题：</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><hr><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，<strong>一个 image 文件往往通过继承另一个 image 文件</strong>，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 列出本机的所有 image 文件。</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"># 删除 image 文件</span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure></blockquote><p><code>ocker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 列出本机正在运行的容器</span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"># 列出本机所有容器，包括终止运行的容器</span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"># 或者</span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure></blockquote><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，<strong>因此需要定义容器与物理机的端口映射（map）。</strong></p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container <span class="built_in">ls</span> --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container <span class="built_in">rm</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --<span class="built_in">rm</span> -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>cmd:</p><p>容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --<span class="built_in">rm</span> -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong>docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p>stop更像是一个建议，而kill是强制性的</p><p><strong>docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p><strong>docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">cp</span> [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></blockquote><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="自建服务-1"><a href="#自建服务-1" class="headerlink" title="自建服务-1"></a>自建服务-1</h2><p>首先，新建一个工作目录，并进入该目录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> docker-demo &amp;&amp; <span class="built_in">cd</span> docker-demo</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container run \</span><br><span class="line">  --rm \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --volume &quot;$PWD/&quot;:/var/www/html \</span><br><span class="line">  php:5.6-apache</span><br></pre></td></tr></table></figure><p>上面的命令基于<code>php</code>的 image 文件新建一个容器，并且运行该容器。<code>php</code>的标签是<code>5.6-apache</code>，说明装的是 PHP 5.6，并且自带 Apache 服务器。该命令的三个参数含义如下。</p><ul><li><code>--rm</code>：停止运行后，自动删除容器文件。</li><li><code>--name wordpress</code>：容器的名字叫做<code>wordpress</code>。</li><li><code>--volume &quot;$PWD/&quot;:/var/www/html</code>：将当前目录（<code>$PWD</code>）映射到容器的<code>/var/www/html</code>（Apache 对外访问的默认目录）。因此，<strong>当前目录的任何修改，都会反映到容器里面，进而被外部访问到。</strong></li></ul><p>安装mysql:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  --rm \</span><br><span class="line">  --name wordpressdb \</span><br><span class="line">  --env MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  --env MYSQL_DATABASE=wordpress \</span><br><span class="line">  mysql:5.7</span><br></pre></td></tr></table></figure><ul><li><code>-d</code>：容器启动后，在后台运行。</li><li><code>--rm</code>：容器终止运行后，自动删除容器文件。</li><li><code>--name wordpressdb</code>：容器的名字叫做<code>wordpressdb</code></li><li><code>--env MYSQL_ROOT_PASSWORD=123456</code>：向容器进程传入一个环境变量<code>MYSQL_ROOT_PASSWORD</code>，该变量会被用作 MySQL 的根密码。</li><li><code>--env MYSQL_DATABASE=wordpress</code>：向容器进程传入一个环境变量<code>MYSQL_DATABASE</code>，容器里面的 MySQL 会根据该变量创建一个同名数据库（本例是<code>WordPress</code>）。</li></ul><p>这样把mysql和php连接起来：</p><p>在<code>docker-demo</code>目录里面，新建一个<code>Dockerfile</code>文件，写入下面的内容。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM php:5.6-apache</span><br><span class="line">RUN docker-php-ext-install mysqli</span><br><span class="line">CMD apache2-foreground</span><br></pre></td></tr></table></figure></blockquote><p>上面代码的意思，就是在原来 PHP 的 image 基础上，安装<code>mysqli</code>的扩展。然后，启动 Apache。</p><p>基于这个 Dockerfile 文件，新建一个名为<code>phpwithmysql</code>的 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t phpwithmysql .</span><br></pre></td></tr></table></figure></blockquote><p>现在基于 phpwithmysql image，重新新建一个 WordPress 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --volume <span class="string">&quot;<span class="variable">$PWD</span>/&quot;</span>:/var/www/html \</span><br><span class="line">  --<span class="built_in">link</span> wordpressdb:mysql \</span><br><span class="line">  phpwithmysql</span><br></pre></td></tr></table></figure></blockquote><p>跟上一次相比，上面的命令多了一个参数<code>--link wordpressdb:mysql</code>，表示 WordPress 容器要连到<code>wordpressdb</code>容器，冒号表示该容器的别名是<code>mysql</code>。</p><p>这时还要改一下<code>wordpress</code>目录的权限，让容器可以将配置信息写入这个目录（容器内部写入的<code>/var/www/html</code>目录，会映射到这个目录）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> -R 777 wordpress</span><br></pre></td></tr></table></figure></blockquote><p>接着，回到浏览器的<code>http://172.17.0.2/wordpress</code>页面，点击”现在就开始！”按钮，开始安装。</p><p>然后在界面里面输入用户名和密码</p><h2 id="自建服务-2"><a href="#自建服务-2" class="headerlink" title="自建服务-2"></a>自建服务-2</h2><p>首先，新建并启动 MySQL 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  --name wordpressdb \</span><br><span class="line">  --<span class="built_in">env</span> MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  --<span class="built_in">env</span> MYSQL_DATABASE=wordpress \</span><br><span class="line">  mysql:5.7</span><br></pre></td></tr></table></figure></blockquote><p>然后，基于官方的 WordPress image，新建并启动 WordPress 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line">  -d \</span><br><span class="line">  --<span class="built_in">rm</span> \</span><br><span class="line">  --name wordpress \</span><br><span class="line">  --<span class="built_in">env</span> WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line">  --<span class="built_in">link</span> wordpressdb:mysql \</span><br><span class="line">  wordpress</span><br></pre></td></tr></table></figure></blockquote><p>上面命令中，各个参数的含义前面都解释过了，其中环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码。</p><p>上面命令指定<code>wordpress</code>容器在后台运行，导致前台看不见输出，使用下面的命令查出<code>wordpress</code>容器的 IP 地址。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container inspect wordpress</span><br></pre></td></tr></table></figure></blockquote><p>上面命令运行以后，会输出很多内容，找到<code>IPAddress</code>字段即可。我的机器返回的 IP 地址是<code>172.17.0.3</code>。</p><p>浏览器访问<code>172.17.0.3</code>，就会看到 WordPress 的安装提示。</p><p>官方 WordPress 容器的安装就已经成功了。但是，这种方法有两个很不方便的地方。</p><blockquote><ul><li>每次新建容器，返回的 IP 地址不能保证相同，导致要更换 IP 地址访问 WordPress。</li><li>WordPress 安装在容器里面，本地无法修改文件。</li></ul></blockquote><p>使用下面的命令新建并启动 WordPress 容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run \</span><br><span class="line"> -d \</span><br><span class="line"> -p 127.0.0.2:8080:80 \</span><br><span class="line"> --<span class="built_in">rm</span> \</span><br><span class="line"> --name wordpress \</span><br><span class="line"> --<span class="built_in">env</span> WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line"> --<span class="built_in">link</span> wordpressdb:mysql \</span><br><span class="line"> --volume <span class="string">&quot;<span class="variable">$PWD</span>/wordpress&quot;</span>:/var/www/html \</span><br><span class="line"> wordpress</span><br></pre></td></tr></table></figure></blockquote><p>上面的命令跟前面相比，命令行参数只多出了两个。</p><blockquote><ul><li><code>-p 127.0.0.2:8080:80</code>：将容器的 80 端口映射到<code>127.0.0.2</code>的<code>8080</code>端口。</li><li><code>--volume &quot;$PWD/wordpress&quot;:/var/www/html</code>：将容器的<code>/var/www/html</code>目录映射到当前目录的<code>wordpress</code>子目录。</li></ul></blockquote><p>浏览器访问<code>127.0.0.2:8080:80</code>就能看到 WordPress 的安装提示了。而且，你在<code>wordpress</code>子目录下的每次修改，都会反映到容器里面。</p><p>最后，终止这两个容器（容器文件会自动删除）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop wordpress wordpressdb</span><br></pre></td></tr></table></figure></blockquote><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>可以管理多个 Docker 容器组成一个应用。你需要定义一个 <a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML</a> 格式的配置文件<code>docker-compose.yml</code>，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动所有服务</span></span><br><span class="line">$ docker-compose up</span><br><span class="line"><span class="comment"># 关闭所有服务</span></span><br><span class="line">$ docker-compose stop</span><br></pre></td></tr></table></figure></blockquote><p>在<code>docker-demo</code>目录下，新建<code>docker-compose.yml</code>文件，写入下面的内容。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">     - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">     - MYSQL_DATABASE=wordpress</span><br><span class="line">web:</span><br><span class="line">    image: wordpress</span><br><span class="line">    links:</span><br><span class="line">     - mysql</span><br><span class="line">    environment:</span><br><span class="line">     - WORDPRESS_DB_PASSWORD=123456</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;127.0.0.3:8080:80&quot;</span></span><br><span class="line">    working_dir: /var/www/html</span><br><span class="line">    volumes:</span><br><span class="line">     - wordpress:/var/www/html</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，两个顶层标签表示有两个容器<code>mysql</code>和<code>web</code>。每个容器的具体设置，前面都已经讲解过了，还是挺容易理解的。</p><p>启动两个容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure></blockquote><p>浏览器访问 <a href="http://127.0.0.3:8080，应该就能看到">http://127.0.0.3:8080，应该就能看到</a> WordPress 的安装界面。</p><p>现在关闭两个容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose stop</span><br></pre></td></tr></table></figure></blockquote><p>关闭以后，这两个容器文件还是存在的，写在里面的数据不会丢失。下次启动的时候，还可以复用。下面的命令可以把这两个容器文件删除（容器必须已经停止运行）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">rm</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="1-Docker-和虚拟机的区别？"><a href="#1-Docker-和虚拟机的区别？" class="headerlink" title="1.Docker 和虚拟机的区别？"></a>1.Docker 和虚拟机的区别？</h2><p>Docker 是<strong>操作系统级别</strong>的轻量虚拟化，虚拟机是硬件级别的虚拟化。Docker 启动快、资源占用小，适合快速交付和微服务架构部署。docker是一个进程级别的，基于linux容器</p><h2 id="2-Docker-的工作原理？"><a href="#2-Docker-的工作原理？" class="headerlink" title="2.Docker 的工作原理？"></a>2.Docker 的工作原理？</h2><p>基于 Linux 的 <strong>Namespace（命名空间）</strong> 实现进程隔离；</p><p>利用 <strong>Cgroups（控制组）</strong> 限制资源；</p><p>使用 <strong>UnionFS（联合文件系统）</strong> 构建分层的镜像结构；</p><p>容器本质上是运行在宿主机内核上的一个普通进程。</p><h2 id="3-镜像的分层结构理解？"><a href="#3-镜像的分层结构理解？" class="headerlink" title="3.镜像的分层结构理解？"></a>3.镜像的分层结构理解？</h2><p>每个 Docker 镜像由多个<strong>只读层（Read-Only Layer）</strong>构成；</p><p>容器运行时会在镜像最上层添加一层可写层；</p><p>修改只会影响写层，原始镜像不变；</p><p>优点是<strong>节省空间、加速构建、共享层数据</strong>。</p><h2 id="4-Dockerfile-常见优化技巧有哪些？"><a href="#4-Dockerfile-常见优化技巧有哪些？" class="headerlink" title="4.Dockerfile 常见优化技巧有哪些？"></a>4.Dockerfile 常见优化技巧有哪些？</h2><p>使用官方的精简基础镜像，如 <code>alpine</code>；</p><p>合并 RUN 命令，减少中间层数量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure><p>使用 <code>.dockerignore</code> 忽略不必要文件；</p><p>尽量减少镜像大小，加快构建和传输。</p><h2 id="5-CMD-和-ENTRYPOINT-的区别？"><a href="#5-CMD-和-ENTRYPOINT-的区别？" class="headerlink" title="5.CMD 和 ENTRYPOINT 的区别？"></a>5.CMD 和 ENTRYPOINT 的区别？</h2><p><code>CMD</code> 提供默认参数，可被 <code>docker run</code> 的命令参数覆盖；</p><p><code>ENTRYPOINT</code> 提供主命令，不会被覆盖，适合制作“工具型镜像”；</p><p>一般组合使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;python&quot;]</span><br><span class="line">CMD [&quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>比如我们有两个文件，一个main 一个master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">FROM python:3.9-slim</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;python&quot;]</span><br><span class="line">CMD [&quot;main.py&quot;]</span><br></pre></td></tr></table></figure><h2 id="6-容器间通信方式？"><a href="#6-容器间通信方式？" class="headerlink" title="6.容器间通信方式？"></a>6.容器间通信方式？</h2><p><strong>同一个 Docker 网络下，容器可以通过服务名互相访问</strong>；比如link</p><p>例如 Docker Compose 会默认创建一个网络，服务名可作为 hostname；</p><p>跨主机通信需使用 Docker Swarm / Kubernetes 等编排工具。</p><h2 id="7-Docker-的数据持久化方案？"><a href="#7-Docker-的数据持久化方案？" class="headerlink" title="7.Docker 的数据持久化方案？"></a>7.Docker 的数据持久化方案？</h2><p><strong>数据卷（Volume）</strong>：推荐，独立于容器生命周期；</p><p><strong>绑定挂载（Bind Mount）</strong>：挂载宿主机路径，开发测试方便；</p><p><strong>tmpfs 挂载</strong>：内存中临时文件系统，适合敏感数据或缓存。</p><h2 id="8-docker-compose-yml-常用字段详解"><a href="#8-docker-compose-yml-常用字段详解" class="headerlink" title="8.docker-compose.yml 常用字段详解"></a>8.docker-compose.yml 常用字段详解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    environment:</span><br><span class="line">      - ENV=prod</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><p><code>build</code>: 指定构建上下文；</p><p><code>depends_on</code>: 依赖关系，控制容器启动顺序；</p><p><code>volumes</code>: 数据卷，持久化数据；</p><p><code>environment</code>: 设置环境变量；</p><p><code>networks</code>: 自定义网络支持跨服务通信。</p><h2 id="9-Docker-Registry"><a href="#9-Docker-Registry" class="headerlink" title="9.Docker Registry"></a>9.Docker Registry</h2><p>私有镜像仓库搭建（Docker Registry）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --name registry registry:2</span><br></pre></td></tr></table></figure><ul><li>将镜像推送到私有仓库：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag myapp localhost:5000/myapp</span><br><span class="line">docker push localhost:5000/myapp</span><br></pre></td></tr></table></figure><ul><li>为啥需要私有仓库？答：用于公司内部部署，避免依赖公网 DockerHub，提升安全性和私有化能力。</li><li>如何保证私有仓库安全？答：<strong>启用 TLS、身份认证、访问控制策略</strong>。</li></ul><div class="table-container"><table><thead><tr><th>问题</th><th>建议简答</th></tr></thead><tbody><tr><td>容器和镜像的区别？</td><td>镜像是只读模板，容器是镜像运行的实例，有可写层。</td></tr><tr><td>Docker 为什么快？</td><td>因为它是进程级别的隔离，不启动完整 OS。</td></tr><tr><td>你如何优化 Docker 镜像大小？</td><td>使用小镜像、合并 RUN、清理缓存、使用多阶段构建等。</td></tr><tr><td>多容器协作怎么做？</td><td>用 Docker Compose 或 Kubernetes 进行编排和通信。</td></tr><tr><td>镜像构建失败怎么调试？</td><td>使用分层构建+缓存机制逐步调试，也可以手动进入中间镜像。</td></tr></tbody></table></div><h2 id="10-MySQL-为什么不能用-Docker-部署"><a href="#10-MySQL-为什么不能用-Docker-部署" class="headerlink" title="10.MySQL 为什么不能用 Docker 部署"></a>10.MySQL 为什么不能用 Docker 部署</h2><p>Docker 可以轻松地从远程仓库拉取镜像，并快速部署应用，简单高效，极其方便。</p><p>曾经刚接触Docker的时候，一度以为一切皆可容器化，自己在使用Docker的时候，也是直接Docker部署。</p><p>但很多企业在实际生产环境中，<strong>并不会选择将 MySQL 部署在 Docker 容器中，而是更倾向于直接部署在物理机或虚拟机上。</strong></p><hr><p>1.数据库是有状态的应用，扩容十分麻烦</p><p>然后呢我们的mysql是有状态的容器，<strong>扩容、迁移、运维都特别复杂。</strong></p><ul><li>MySQL 是有状态的，需要保证数据持久性、配置文件、日志等。</li><li>Docker 容器之间难以共享数据，导致扩容不是简单的增加容器，而是新建独立的数据库实例，无法形成真正的集群。</li><li>Docker 虽然限制了资源上限，但无法保证 MySQL 能够获得足够的资源，可能受到其他容器的资源竞争影响。</li><li>Docker 会增加磁盘 IO 和网络 IO 的开销，对 MySQL 这种重 IO 应用影响明显，导致性能下降。</li></ul><p>对于大型 MySQL 数据库，更推荐直接部署在物理机或虚拟机上，以获得更稳定、更可控的资源保障和 IO 性能。 例如，可以使用腾讯云TDSQL，阿里云 OceanBase。</p><p>补充：</p><p>1.在 Docker 的世界里，<strong>容器其实分两种：有状态和无状态。</strong></p><p><strong>有状态容器就是：运行过程中必须“记住”数据。</strong> 比如 MySQL、Redis、消息队列等，这些应用必须确保数据持久、可靠，哪怕容器重启、迁移、甚至崩溃，数据也不能丢。</p><p>所以有状态容器通常需要：</p><ul><li>挂载数据卷（Volumes）</li><li>绑定宿主机路径（Bind Mounts）</li><li>使用网络存储（如 NFS、云盘）</li></ul><p>这些操作都是为了：<strong>让数据活得比容器久。</strong></p><p><strong>难点</strong>：扩容复杂，数据一致性、同步、节点状态都需要严密设计，稍有不慎就会出问题。</p><p><strong>无状态容器则完全不同：它从来不关心自己的过去。</strong> 数据不会保存在容器里，处理完请求，事情就结束了，下一次请求，它随时可以从“零”开始。</p><p><strong>典型场景</strong>：前端应用、Web 服务器、API 网关、负载均衡器。</p><p><strong>好处</strong>：横向扩容超级简单，随时加机器，随时销毁，弹性伸缩非常友好。</p><p>无状态容器特别适合用 Kubernetes 这样的编排工具，轻松实现秒级扩缩容。</p><p>2.Docker 的资源隔离并不彻底</p><p>虽然 Docker 在设计上是“隔离”的，但它并没有做到像虚拟机那样的<strong>强隔离</strong>，本质上它是通过 Linux 的 Cgroup 和 Namespace 技术来限制资源。</p><p>但这个限制，其实只是“最大值”的限制，比如你可以告诉 Docker：“这个容器最多只能用 4 核心、4G 内存”。问题来了：</p><ul><li>它<strong>不能保证</strong>这些资源就一定是这个容器的；</li><li>更不能防止其他容器或进程<strong>把资源抢走</strong>。</li></ul><p>Docker 并不能从根本上保证你为 MySQL 留下的资源就一定够用，它依然会受到其他容器的影响。资源可能被其他资源抢占</p><p>3.Docker 不适合部署 IO 密集型的中间件</p><p>虽然 Docker 用起来确实轻便，但在 <strong>磁盘 IO 和网络 IO 性能</strong> 上，它和裸机运行是有差距的，尤其是对像 MySQL 这样的“重度 IO 应用”来说，差距可能非常明显。</p><p>Docker 的容器文件系统是分层的，它不是直接操作宿主机磁盘，而是通过一层“抽象层”去处理读写请求。这个过程就像多了一层“代理”，每次读写数据都要先转一圈，性能自然会受到影响。</p><p>尤其是当 MySQL 进行大量小文件读写、事务操作、大数据导入导出时，这种额外的系统开销就会被放大，最终导致：</p><ul><li>IO 延迟变高</li><li>性能瓶颈明显</li><li>甚至数据库操作变慢、查询卡顿</li></ul><p>Docker 的网络是虚拟出来的，容器之间通信要经过网桥（bridge）、NAT 转换，甚至还要穿越虚拟网络设备。这些过程虽然保证了隔离，但同时也增加了网络延迟。</p><p>总结：</p><p>对于大型 MySQL 数据库，<strong>Docker 并不是最佳选择</strong>，主要因为：</p><ol><li><strong>性能开销大</strong>，特别是在 IO 密集型操作中，Docker 容器会引入额外的性能损耗。</li><li><strong>配置和管理复杂</strong>，特别是容器内部和宿主机之间的协调，以及容器化数据持久化的配置都相对麻烦。</li><li><strong>稳定性和故障排查</strong>的问题，容器环境带来的额外层级和抽象使得排查和解决故障变得更加复杂。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/docker/">docker</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/22/new-stack/docker/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试题目hot2web开发</title>
      <link>https://blog.tokenlen.top/2025/06/21/javase/javaweb1/</link>
      <guid>https://blog.tokenlen.top/2025/06/21/javase/javaweb1/</guid>
      <pubDate>Fri, 20 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;web基础&quot;&gt;&lt;a href=&quot;#web基础&quot; class=&quot;headerlink&quot; title=&quot;web基础&quot;&gt;&lt;/a&gt;web基础&lt;/h1&gt;&lt;h2 id=&quot;1-JavaWeb是什么（静态资源和动态资源）&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="web基础"><a href="#web基础" class="headerlink" title="web基础"></a>web基础</h1><h2 id="1-JavaWeb是什么（静态资源和动态资源）"><a href="#1-JavaWeb是什么（静态资源和动态资源）" class="headerlink" title="1.JavaWeb是什么（静态资源和动态资源）"></a>1.JavaWeb是什么（静态资源和动态资源）</h2><blockquote><p><strong>JavaWeb 是基于 Java 技术的 Web 开发体系，用于构建浏览器/服务器（B/S）架构的动态网站或服务。</strong></p></blockquote><p>核心组成部分：</p><div class="table-container"><table><thead><tr><th>模块</th><th>说明</th></tr></thead><tbody><tr><td>Servlet</td><td>JavaWeb 的核心，用于处理 HTTP 请求</td></tr><tr><td>JSP / Thymeleaf</td><td>页面展示层，用于动态生成 HTML 内容</td></tr><tr><td>Filter / Listener</td><td>过滤器和监听器，提供请求过滤、生命周期监听等功能</td></tr><tr><td>Web.xml</td><td>部署描述文件，用于配置 Servlet、Filter 等组件（Spring Boot 多用注解配置）</td></tr><tr><td>静态资源</td><td>纯前端文件，如 HTML、JS、CSS、图片等</td></tr><tr><td>动态资源</td><td>由 Servlet / Controller 处理、运行时生成的内容</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>类型</th><th>描述</th><th>是否经过服务端处理</th></tr></thead><tbody><tr><td>静态资源</td><td>浏览器请求后直接返回内容（如 HTML/CSS/JS/图片）</td><td>❌ 不经过 Java 代码处理，直接由服务器返回</td></tr><tr><td>动态资源</td><td>运行时由后端生成（如 .jsp、Servlet、Controller 响应 JSON）</td><td>✅ 由 Java 程序处理后动态生成响应</td></tr></tbody></table></div><p>静态资源：</p><ul><li>URL: <code>http://example.com/static/index.html</code></li><li>返回：静态 HTML 页面</li><li>存储位置：<code>/static/</code>、<code>/public/</code>、<code>/resources/</code>（Spring Boot 默认支持）</li></ul><p>动态资源：</p><ul><li>URL: <code>http://example.com/user/list</code></li><li>后端：调用 Controller → Service → Dao → 数据库 → 生成动态 HTML / JSON</li><li>常见技术：Servlet、JSP、Spring MVC、Thymeleaf、FreeMarker</li></ul><p>流程：：：</p><p>浏览器请求 → Tomcat（Servlet 容器）接收 → 判断资源类型：<br>  ├─ 静态资源：直接读取文件返回<br>  └─ 动态资源：交给 Servlet/DispatcherServlet 执行 → 处理请求 → 返回响应</p><p>总结：：：</p><p>JavaWeb 是基于 Java 的 Web 应用开发技术，主要通过 Servlet 处理 HTTP 请求，支持静态与动态资源的服务。<br> 静态资源如 HTML、CSS、JS 不经后端处理直接响应；<br> 动态资源（如 Servlet、JSP、Controller）通过服务器运行 Java 逻辑动态生成响应内容。<br> 在现代开发中，JavaWeb 往往结合 Spring MVC + 前端页面模板或前后端分离架构使用。</p><p>可以使用nginx进行动静的分离</p><h2 id="2-tomcat是什么以及作用"><a href="#2-tomcat是什么以及作用" class="headerlink" title="2.tomcat是什么以及作用"></a>2.tomcat是什么以及作用</h2><p>Tomcat 是一个<strong>开源的、轻量级的 Web 服务器和 Servlet 容器</strong></p><p><strong>Servlet 规范</strong>：Servlet 是 Java 语言的一个接口，它定义了如何响应客户端请求（如浏览器发出的 HTTP 请求）。Tomcat 作为 Servlet 容器，负责加载、初始化和管理 Servlet 的生命周期，并根据请求将它们与对应的 Servlet 实例关联起来。</p><p><strong>JSP (JavaServer Pages) 规范</strong>：JSP 允许开发者在 HTML 页面中嵌入 Java 代码，从而动态生成 Web 内容。Tomcat 能够解析和编译 JSP 文件为 Servlet，然后像处理普通 Servlet 一样执行它们。</p><p>它能理解来自客户端（比如你的浏览器）的 HTTP 请求，将这些请求传递给你的 Java Web 应用程序（比如你写的 Servlet 或 JSP），然后把应用程序处理完的结果（比如一个 HTML 页面）再返回给客户端。</p><h2 id="3-HTTP协议的作用以及组成（请求行：请求头，请求体"><a href="#3-HTTP协议的作用以及组成（请求行：请求头，请求体" class="headerlink" title="3.HTTP协议的作用以及组成（请求行：请求头，请求体)"></a>3.HTTP协议的作用以及组成（请求行：请求头，请求体)</h2><p>HTTP（HyperText Transfer Protocol），<strong>超文本传输协议</strong>，是互联网上应用最为广泛的一种网络协议。它定义了客户端（如浏览器）和服务器之间如何进行通信，是 Web 应用程序能够正常运作的基础。</p><p>HTTP 规范了客户端（如你的浏览器、手机 App）如何向服务器发送请求，以及服务器如何响应这些请求。这包括了请求的格式、响应的格式、如何处理错误等等。</p><p>功能：</p><p>实现连接，传输资源，无状态，可扩展性</p><p>报文组成：</p><p>请求行，请求头，请求体</p><h2 id="4-浏览器输入一个网址后，看到返回结构，都经历了哪些流程"><a href="#4-浏览器输入一个网址后，看到返回结构，都经历了哪些流程" class="headerlink" title="4.浏览器输入一个网址后，看到返回结构，都经历了哪些流程"></a>4.浏览器输入一个网址后，看到返回结构，都经历了哪些流程</h2><p>解析，host检查，dns递归解析，tcp三次握手，发送http请求，响应http请求，浏览器解析</p><h2 id="5-URI和URL的区别"><a href="#5-URI和URL的区别" class="headerlink" title="5.URI和URL的区别"></a>5.URI和URL的区别</h2><p><strong>URI</strong>，全称 <strong>统一资源标识符</strong>，它是一个字符串，用来<strong>唯一标识</strong>互联网上的一个资源。这里的“资源”可以是任何东西，比如一个网页、一张图片、一段视频、一个文件，甚至是一个服务或者一个抽象概念。</p><p><strong>URL</strong>，全称 <strong>统一资源定位符</strong>，它是 URI 的一个子集。URL 不仅能够<strong>标识</strong>一个资源，更重要的是，它还指明了这个资源在互联网上的<strong>位置</strong>。换句话说，URL 告诉我们如何<strong>访问</strong>到这个资源。</p><h2 id="6-MVC架构是什么"><a href="#6-MVC架构是什么" class="headerlink" title="6.MVC架构是什么"></a>6.MVC架构是什么</h2><p>旨在将应用程序的业务逻辑、数据和用户界面进行<strong>分离</strong>，从而提高代码的<strong>可维护性、可扩展性和重用性</strong>。</p><p>Model（模型）</p><ul><li><strong>作用</strong>：模型是应用程序的<strong>核心</strong>，它包含了<strong>数据</strong>和<strong>业务逻辑</strong>。它独立于用户界面，负责数据的存储、检索、处理、验证和管理。当数据发生变化时，模型会通知视图进行更新。</li><li><strong>职责</strong>：<ul><li><strong>数据管理</strong>：负责与数据库或其他数据源的交互，进行数据的增删改查。</li><li><strong>业务规则</strong>：包含应用程序的核心业务逻辑和规则，确保数据的完整性和一致性。</li><li><strong>状态管理</strong>：管理应用程序的状态，并在其状态改变时通知相关的视图或控制器。</li></ul></li><li><strong>示例</strong>：在一个电商应用中，<code>Product</code> 类、<code>Order</code> 类、<code>User</code> 类以及它们对应的数据库操作和业务逻辑（如计算订单总价、库存管理）都属于模型层。</li></ul><ol><li>View（视图）</li></ol><ul><li><strong>作用</strong>：视图是用户与应用程序交互的<strong>界面</strong>。它负责<strong>显示</strong>模型的数据给用户，并接收用户的输入（如点击按钮、填写表单）。视图本身不包含任何业务逻辑，它只负责数据的展示。</li><li><strong>职责</strong>：<ul><li><strong>数据展示</strong>：从模型中获取数据，并以用户友好的方式呈现。</li><li><strong>用户交互</strong>：提供用户界面元素，并捕获用户的输入事件。</li><li><strong>不含业务逻辑</strong>：视图层应该尽可能“哑巴”，不直接处理业务逻辑，而是将用户输入事件传递给控制器。</li></ul></li><li><strong>示例</strong>：网页中的 HTML 页面、Android 或 iOS 应用中的 UI 界面、桌面应用中的窗口和控件，都属于视图层。</li></ul><ol><li>Controller（控制器）</li></ol><ul><li><strong>作用</strong>：控制器是模型和视图之间的<strong>桥梁</strong>或“协调者”。它接收用户的输入（来自视图），根据输入调用相应的模型进行业务逻辑处理，然后选择合适的视图来显示处理结果。</li><li><strong>职责</strong>：<ul><li><strong>处理用户输入</strong>：接收并解析来自视图的用户请求和操作。</li><li><strong>协调模型和视图</strong>：根据用户输入，调用模型层执行相应的业务逻辑操作。</li><li><strong>更新视图</strong>：模型处理完数据后，控制器会选择一个合适的视图来展示更新后的数据或结果。控制器通常不直接修改视图，而是告诉视图去更新自己。</li></ul></li><li><strong>示例</strong>：在 Web 应用中，一个 Servlet 或 Spring MVC 中的 <code>@Controller</code> 类就是控制器。它接收 HTTP 请求，调用服务层（模型的一部分）处理业务，然后将数据传递给 JSP 或 Thymeleaf 模板（视图）进行渲染。</li></ul><h2 id="7-三大组件Servlet、Filter-和-Listener"><a href="#7-三大组件Servlet、Filter-和-Listener" class="headerlink" title="7.三大组件Servlet、Filter 和 Listener"></a>7.三大组件<strong>Servlet、Filter 和 Listener</strong></h2><p><strong>Servlet</strong> 是 Java 语言的一个接口，也是所有 Java Web 应用程序的核心组件。它定义了服务器端程序如何<strong>接收和响应客户端（通常是浏览器）的请求</strong>。</p><p><strong>处理请求</strong>：接收并处理来自客户端的 HTTP 请求（如 GET、POST 等）。</p><p><strong>生成响应</strong>：根据请求执行业务逻辑（如查询数据库、调用服务），然后生成动态内容（如 HTML 页面、JSON 数据）作为 HTTP 响应返回给客户端。</p><p><strong>生命周期管理</strong>：Servlet 容器负责管理 Servlet 的生命周期，包括加载、实例化、初始化 (<code>init()</code>)、处理请求 (<code>service()</code>) 和销毁 (<code>destroy()</code>)。</p><p><strong>多线程处理</strong>：同一个 Servlet 实例可以同时处理多个请求，每个请求都在独立的线程中执行。因此，Servlet 中的共享资源需要考虑线程安全问题。</p><p><code>init(ServletConfig config)</code>：Servlet 初始化时调用，只执行一次。</p><p><code>service(ServletRequest req, ServletResponse res)</code>：每次客户端请求时调用，根据请求类型分发到 <code>doGet()</code>、<code>doPost()</code> 等方法。</p><p><code>doGet(HttpServletRequest req, HttpServletResponse resp)</code>：处理 HTTP GET 请求。</p><p><code>doPost(HttpServletRequest req, HttpServletResponse resp)</code>：处理 HTTP POST 请求。</p><p><code>destroy()</code>：Servlet 销毁时调用，只执行一次，用于释放资源。</p><p><strong>Filter</strong> 也是 Java Web 的一个接口，它允许你在请求到达 Servlet 之前和响应发送回客户端之后<strong>拦截和处理请求/响应</strong>。过滤器就像一个“管道”或“拦截器”，可以在核心业务逻辑（Servlet）执行前后进行预处理和后处理。</p><p><strong>请求/响应拦截</strong>：在请求进入 Servlet 之前进行预处理，或在 Servlet 处理完响应返回客户端之前进行后处理。</p><p><strong>链式调用</strong>：可以配置多个过滤器形成一个过滤链，请求会依次经过这些过滤器。</p><p><strong>不改变核心业务</strong>：过滤器主要用于通用性、非核心的逻辑处理，而不会改变 Servlet 的核心业务功能。</p><p><code>init(FilterConfig filterConfig)</code>：过滤器初始化时调用，只执行一次。</p><p><code>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>：每次请求匹配到过滤器时调用。核心逻辑在此方法中实现，<code>chain.doFilter()</code> 方法用于将请求传递给下一个过滤器或目标 Servlet。</p><p><code>destroy()</code>：过滤器销毁时调用，只执行一次。</p><p><strong>Listener</strong> 也是 Java Web 的一组接口，用于<strong>监听 Web 应用程序中的特定事件</strong>。当这些事件发生时，监听器会收到通知并执行相应的处理逻辑。监听器就像应用程序的“耳目”，能感知到各种生命周期或状态变化。</p><p><strong>事件驱动</strong>：基于事件机制，当某个特定事件（如 ServletContext 创建/销毁、HttpSession 创建/销毁、ServletRequest 创建/销毁等）发生时，自动触发相应的监听器方法。</p><p><strong>无侵入性</strong>：监听器通常与业务逻辑分离，用于处理一些全局性的、非业务相关的任务。</p><p><strong>Web 应用程序范围</strong>：</p><ul><li><code>ServletContextListener</code>：监听 ServletContext（Web 应用上下文）的创建和销毁。<ul><li><code>contextInitialized(ServletContextEvent sce)</code>：Web 应用启动时调用。</li><li><code>contextDestroyed(ServletContextEvent sce)</code>：Web 应用关闭时调用。</li><li><strong>应用场景</strong>：加载配置文件、初始化资源池、启动后台任务。</li></ul></li></ul><p><strong>会话范围</strong>：</p><ul><li><code>HttpSessionListener</code>：监听 HttpSession 的创建和销毁。<ul><li><code>sessionCreated(HttpSessionEvent se)</code>：新会话创建时调用。</li><li><code>sessionDestroyed(HttpSessionEvent se)</code>：会话销毁时调用（如超时、手动失效）。</li><li><strong>应用场景</strong>：统计在线用户数量。</li></ul></li><li><code>HttpSessionAttributeListener</code>：监听 HttpSession 中属性的增删改。</li></ul><p><strong>请求范围</strong>：</p><ul><li><code>ServletRequestListener</code>：监听 ServletRequest 对象的创建和销毁。<ul><li><code>requestInitialized(ServletRequestEvent sre)</code>：请求开始处理时调用。</li><li><code>requestDestroyed(ServletRequestEvent sre)</code>：请求处理结束时调用。</li><li><strong>应用场景</strong>：统计请求次数、记录请求日志。</li></ul></li><li><code>ServletRequestAttributeListener</code>：监听 ServletRequest 中属性的增删改。</li></ul><h2 id="8-什么是JDBC"><a href="#8-什么是JDBC" class="headerlink" title="8.什么是JDBC"></a>8.什么是JDBC</h2><p>它提供了一套<strong>统一的接口和类</strong>，允许 Java 开发者使用相同的 Java 代码来连接、查询和更新不同的关系型数据库，而无需关心底层数据库的具体实现细节。</p><p>JDBC 定义了：</p><ul><li>如何建立与数据库的连接。</li><li>如何发送 SQL 语句给数据库。</li><li>如何处理从数据库返回的结果。</li><li>如何管理数据库事务。</li></ul><p><strong>统一的编程接口</strong>： JDBC 提供了一套标准的 API（位于 <code>java.sql</code> 和 <code>javax.sql</code> 包中），无论底层是 MySQL、Oracle、SQL Server 还是 PostgreSQL，开发者都使用相同的接口来编写数据库操作代码。这大大简化了开发工作。</p><p><strong>可插拔的驱动机制</strong>： 虽然 JDBC 定义了统一的接口，但不同数据库厂商的底层实现是不同的。为了让 Java 程序能够与特定的数据库通信，每个数据库厂商都需要提供一个符合 JDBC 规范的 <strong>JDBC 驱动程序</strong>。这个驱动程序负责将 JDBC API 调用翻译成数据库能理解的特定协议，并进行实际的数据传输。 <strong>开发者只需要在项目中引入对应数据库的 JDBC 驱动 JAR 包</strong>，并在代码中加载该驱动，就可以连接到相应的数据库。</p><p><strong>支持多种数据库</strong>： 由于其驱动机制，JDBC 可以支持几乎所有主流的关系型数据库。这使得 Java 应用具有很强的数据库<strong>无关性</strong>和<strong>可移植性</strong>。如果未来需要更换数据库，通常只需要更换 JDBC 驱动和修改连接配置，而无需大幅改动业务代码。</p><p><strong>提供强大的数据库操作能力</strong>： JDBC 提供了丰富的方法来执行 SQL 语句，包括：</p><ul><li><strong>建立连接</strong>：<code>DriverManager.getConnection()</code></li><li><strong>创建语句</strong>：<code>Connection.createStatement()</code>、<code>Connection.prepareStatement()</code></li><li><strong>执行查询</strong>：<code>Statement.executeQuery()</code>，返回 <code>ResultSet</code>（结果集）</li><li><strong>执行更新</strong>：<code>Statement.executeUpdate()</code>（用于插入、更新、删除）</li><li><strong>处理结果集</strong>：<code>ResultSet</code> 接口提供了遍历结果、获取列值等方法。</li><li><strong>事务管理</strong>：<code>Connection.setAutoCommit()</code>、<code>commit()</code>、<code>rollback()</code> 等。</li></ul><h2 id="9-RESTful-API-RPC的联系和区别"><a href="#9-RESTful-API-RPC的联系和区别" class="headerlink" title="9.RESTful API  RPC的联系和区别"></a>9.RESTful API  RPC的联系和区别</h2><p>RESTful API 和 RPC 是两种广泛使用的架构风格，用于构建 Web 应用程序和分布式系统. 它们在多个方面存在差异，包括通信协议、数据传输、编码方式和服务契约.</p><ul><li><strong>RPC (Remote Procedure Call)</strong>: 侧重于函数或操作，客户端在服务器上进行远程函数调用，就像在本地调用一样. RPC 是一种面向过程的远程调用协议，其目标是使应用程序能够在网络上进行远程调用，类似于本地函数调用.</li><li><strong>REST (Representational State Transfer)</strong>: 侧重于资源或对象. REST 客户端请求服务器针对特定资源执行操作，操作仅限于 CRUD（创建、读取、更新和删除），通过 HTTP 动词传达. REST 是一种面向资源的架构风格，它是一种基于 HTTP 协议的分布式系统架构，主要用于构建 Web 服务和 API.</li></ul><p>区别</p><ul><li><strong>RESTful API</strong>: 使用 HTTP 协议作为通信协议. HTTP 协议是基于文本的，包含请求头、请求体、响应头和响应体等信息. </li><li><strong>RESTful API</strong>: 使用 JSON 或 XML 格式进行编码.</li><li><strong>RESTful API</strong>: 服务契约通常通过 URL、HTTP 方法、HTTP 头和 HTTP 状态码等来定义.</li><li><strong>REST</strong>: 核心在于“表征状态转移”，其六大原则的核心是面向资源的设计理念.</li><li><strong>RESTful API</strong>: 适合构建 Web 服务和 API</li></ul><hr><ul><li><strong>RPC</strong>: 可以使用多种传输协议进行通信，例如 TCP、UDP、HTTP 等</li><li><strong>RPC</strong>: 可以使用多种编码方式进行编码，例如 Protocol Buffers、Thrift、Avro 等.</li><li><strong>RPC</strong>: 服务契约通常通过接口定义语言（IDL）来定义，IDL 可以定义数据类型、服务方法和异常等，然后通过编译器生成客户端和服务器代码.</li><li><strong>RPC</strong>: RPC解决了三个基本问题：如何表示数据、如何传递数据、如何确定方法</li><li><strong>RPC</strong>: 适合构建分布式系统和微服务.</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/21/javase/javaweb1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
