<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Wed, 03 Sep 2025 14:18:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>面试面经-大厂收集</title>
      <link>https://blog.tokenlen.top/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/</link>
      <guid>https://blog.tokenlen.top/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/</guid>
      <pubDate>Tue, 26 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;美团&lt;/h1&gt;
&lt;h2 id=&quot;一面&quot;&gt;一面&lt;/h2&gt;
&lt;h3</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>美团</h1><h2 id="一面">一面</h2><h3 id="题目1">题目1</h3><p>请说明进程和线程的区别与联系。操作系统中的虚拟内存是如何实现的？谈谈乐观锁和悲观锁，以及它们在Java中的具体实现（如CAS、Synchronized）。AQS（AbstractQueuedSynchronizer）的原理是什么？请举例说明（如ReentrantLock）。当向一个线程池提交任务时，它的执行流程是怎样的？（考虑核心线程、队列、最大线程、拒绝策略）</p><p>介绍一下Redis的持久化机制有哪几种，它们各自有什么优缺点？如何保证缓存与数据库双写一致性？谈谈MySQL的事务隔离级别，以及MVCC是如何在可重复读（RR）级别下工作的。什么是覆盖索引和回表？在使用联合索引时，需要注意哪些最左前缀匹配原则？</p><p>请描述一下JVM的类加载过程，以及双亲委派模型。G1垃圾收集器相比于CMS有哪些优势？什么情况下会发生OOM（堆内存溢出），请举例说明几种场景。Java中的强引用、软引用、弱引用、虚引用之间有什么区别？</p><h3 id="题目2">题目2</h3><p>1：自我介绍</p><p>2：HashMap1.8底层数据结构和put流程</p><p>3：jvm底层和OOM发生区域</p><p>4：roc调用流程</p><p>5：慢SQL调查流程</p><p>6：mysql隔离级别和如何实现的，以及MVCC</p><p>7：唯一ID，一致性哈希</p><h3 id="题目3">题目3</h3><p>Bean的生命周期</p><p>Spring怎么解决循环依赖问题</p><p>Spring的IOC、AOP</p><p>Spring的事务传播机制</p><p>事务传播机制的底层实现</p><p>TheadLocal的key为什么要设置成弱引用</p><p>TheadLocal的value为什么要设置成强引用</p><p>TheadLocal怎么防止内存泄漏</p><p>TCP的三次握手和四次挥手</p><p>TIME_WAIT发生在哪里，以及为什么需要TIME_WAIT</p><p>UDP怎么设置成可靠的</p><p>votaile 关键字的作用，以及votaile 禁止指令重排的底层实现</p><p>解释一下SYN的泛洪攻击</p><p>怎么防御泛洪攻击</p><h3 id="题目4">题目4</h3><p>1. ThreadLocal在什么情况下会导致out of memory？</p><p>2. 阿里规范中为什么要求用static来修饰ThreadLocal变量？</p><p>3. 存储100万数据时，选HashMap还是ConcurrentHashMap？</p><p>4. 多线程情况下使用HashMap会导致什么问题？</p><p>5. HashMap扩容时需要注意什么？</p><p>6. 仿大众点评项目中缓存空值具体是怎么实现的？</p><p>7. 布隆过滤器的误判率大概是多少？</p><p>8. 仿大众点评项目中，类似微博大V发博客的场景，使用推模式还是拉模式？大粉丝量时推模式会有什么问题？</p><p>9. Redis分布式锁为什么要使用Lua脚本？纯Java代码为什么不可以？</p><p>10. 为什么选用Websocket？除了Websocket，是否考虑过其他协议（如谷歌的相关协议）？</p><p>11. 分布式环境下用schedule的关单会有什么问题？</p><p>12. 若系统扩大为分布式且单量增大，解决定时任务问题的思路有哪些？</p><p>13. 日志框架用的是log4j还是log4j2？日志应在哪些地方重点打印？</p><p>14. 碰到老应用、老系统日志不全时，如何最快地加上基础日志打点？</p><p>15. 为什么选用Mybatis plus而不选用JPA？</p><p>16. 线程池在系统里用在哪些位置？</p><p>17. 线程池的核心参数有哪些？从核心线程数达到最大线程数需要什么条件？</p><p>18. 在优惠券秒杀场景下，阻塞队列应设置多大？</p><p>19. RabbitMQ与Redis stream的推流最大区别是什么？</p><p>20. 仿大众点评项目中，最重要的几张表是哪几张？订单表应加什么索引？</p><p>21. MySQL的日志指的是哪些？集群模式最主要依赖的日志是什么？</p><p>22. 生产环境中如何避免主从同步延迟带来的故障？</p><p>23. JDK 11、17有哪些新特性？</p><h3 id="题目5">题目5</h3><p>说一下 JVM 的内存结构（运行时数据区）有哪些？每一块的作用是什么？</p><p>Java 中对象的内存分配过程是怎样的？对象分配在堆还是栈？</p><p>什么是栈上分配、逃逸分析？是否可以让对象不分配在堆上？</p><p>什么情况下对象会进入老年代？如何判断对象“是否存活”？</p><p>直接内存（Direct Memory）是什么？你在什么场景下用过它？</p><p>JVM 中常见的垃圾回收器有哪些？它们的适用场景？</p><p>Serial、ParNew、CMS、G1、ZGC 有什么区别？你项目中用的哪一个？为什么？</p><p>Minor GC 和 Full GC 有什么区别？分别在什么情况下发生？</p><p>如何避免或减少 Full GC？有哪些排查方法？</p><p>GC Roots 有哪些？JVM 是怎么判断一个对象是否需要回收的？</p><h3 id="题目6">题目6</h3><p>ArrayList和hashmap扩容机制</p><p>Java并发容器和锁</p><p>jvm参数设置 — 堆内存和垃圾回收器</p><p>如果新生代的垃圾回收一直清不到0，怎么解决？</p><p>full GC</p><p>垃圾回收机制</p><p>类加载机制和双亲委派机制</p><p>IOC —  还有IOC相关的，忘记是什么了</p><p>Bean生命周期</p><p>MySQL索引的注意事项、事务</p><p>MVCC</p><p>当前读和快照读</p><p>Redis数据结构</p><p>RocketMQ与kafka</p><p>rocketmq有哪些主要部分</p><p>消息重试</p><p>消费者的消费模式</p><p>消费者如何保证幂等</p><p>RocketMQ消息有序吗？</p><p>http状态码，对应着是哪个环节出现问题</p><p>TCP三次握手和四次挥手 为什么挥手是四次？</p><p>lInux查最近的日志 — tail -f | grep XXX</p><p>linux其他命令 查看进程 ps</p><h3 id="题目7">题目7</h3><p>1.自我介绍</p><p>2.实习拷打</p><p>3.讲讲javac过程，结合编译原理的东西详细分析</p><p>4.讲讲你写的一个java代码跑起来的过程，例如编译运行和解释运行</p><p>5.面向对象的几个特性和举例子说明</p><p>6.springboot容器启动过程</p><p>7.讲讲list，map，set几种基本数据结构和使用场景</p><p>8.假如你用一个arraylist，你已经知道里面会存1w条数据了，那该怎么办</p><p>9.collections下的加锁和数据结构本身例如chw的加锁操作有什么区别</p><p>10.手撕SQL:</p><p>员工编号-id，部门-dep，薪酬-salary</p><p>求找到所有薪酬大于部门平均工资的员工</p><p>要求多种解法</p><p>不知道想要哪种，除了常规的，还写了一种 avg（salary）over（partation by dep）as avgSalary这种</p><p>11.手撕链表中删除重复元素</p><p>12.讲讲大模型中的知识蒸馏是怎么做的</p><p>13.整体介绍介绍你对于agent，work flow，rag，mcp，a2a的理解</p><h3 id="题目8">题目8</h3><ol><li><p>看你简历上写了几个项目，可以挑一个你觉得最有代表性的介绍一下吗？</p></li><li><p>我看你提到了mcp，能解释下它是什么吗？主要起什么作用，在什么地方起作用？</p></li><li><p>我们来聊聊基础吧，HashMap是线程安全的吗？为什么？</p></li><li><p>StringBuffer和StringBuilder，它俩有什么区别？</p></li><li><p>TCP和UDP，能分别说说它们的特点和常见的应用场景吗？</p></li><li><p>来一道概率题吧：现在你只有一个能生成1到5随机数的<code>rand5()</code>函数，怎么用它来实现一个能生成1到7随机数的<code>rand7()</code>函数？（讲了大体思路没讲具体思路 估计死了)</p></li><li><p>你之前有做过全栈开发吗？</p></li><li><p>我们来深入聊聊MySQL索引。能介绍一下吗？为什么它通常用B+树来实现？B+树的每个节点里都存了些什么？另外，一张表里可以有几个聚簇索引？（把我问死了）</p></li><li><p>来个系统设计题。假设我们要搞一个秒杀活动：晚上八点开抢1000台手机。你会怎么设计这个秒杀系统？</p></li><li><p>你觉得，一个好的Prompt通常需要包含哪些要素？</p></li><li><p>在我们平台里，Agent模式和Ask模式，它俩有什么区别？</p></li></ol><h3 id="题目9">题目9</h3><p>hashcode equal什么时候需要重写</p><p>hashmap原理</p><p>hashmap是线程安全的吗</p><p>不安全的话用什么？他的原理是什么样的</p><p>线程池使用过吗？怎么用的？什么场景？</p><p>spring事务怎么做到的</p><p>spring事务传播机制</p><p>mysql使用</p><p>mysql怎么建索引？怎么判断是否要建索引</p><p>mysql索引失效？</p><p>mysql慢查询排查</p><h3 id="题目10">题目10</h3><p>1.自我介绍</p><p>2.项目难点有什么</p><p>3.Redis常用数据结构有哪些</p><p>4.Redis缓存击穿、缓存雪崩是什么，解决方案</p><p>5.equals和hashcode</p><p>6.TCP三次握手</p><p>7.MySQL索引类型有什么，索引失效场景</p><p>8.一个主线程正在进行，现在有个子线程，怎样才能让主线程停止，等到子线程执行结束之后再恢复运行</p><p>9.创建线程的方式有哪些</p><p>10.平时怎么用AI学习的</p><h3 id="题目10-2">题目10</h3><p>1.hashmap如何解决哈希冲突，红黑树化为何阈值为8</p><p>2.cglib和jdk代理区别，哪个性能好</p><p>3.联合索引失效 如何改进</p><p>4.synchonized reentrantlock区别</p><p><a href="http://5.mq/">5.mq</a>如何保证可靠性，顺序性</p><p>6.ArrayList LinkedList区别</p><p>7.OOM怎么排查</p><p>8.线程池核心参数 原理 四种拒绝策略 举个例子</p><p>9.缓存穿透 雪崩</p><p>10.分库分表 附属表 基因法  优缺点</p><p>11.mysql隔离级别 可重复读怎么避免幻读</p><p>12.G1怎么避免内存碎片</p><p>13.Mysql oracle区别</p><p>13.用过哪些AI，用途，工作中遇到别人代码bug怎么办</p><p>14.手撕 二叉树层序 最长重复子数组</p><h3 id="题目11">题目11</h3><p>1、项目、实习拷打<br>2、violate关键字作用<br>3、如何保证线程安全<br>4、支持原子性操作的方法<br>5、简述Spring的ioc和aop的核心思想<br>6、mysql的acid特性<br>7、慢sql如何优化<br>8、explain关键字解释<br>9、Redis常用数据结构以及应用场景<br>10、WebSocket的工作原理<br>11、如何优化你项目中使用的WebSocket的业务<br>12、FTP中的keep-alive<br>13、TCP特性<br>14、UDP和TCP应用场景，如何使得UDP可靠<br>15、对前端的了解，对vue的认识<br>16、java中Sort的原理</p><h3 id="题目12">题目12</h3><p>1.问实习内容<br>2.并发工具类<br>3.介绍项目背景<br>4.项目框架设计<br>5.项目如何面对高并发场景<br>6.线程池八股<br>7.项目接口和高并发<br>8.手撕：合并两个有序数组<br>9.Mysql日志<br>10.MVCC</p><h3 id="题目13">题目13</h3><ol><li>自我介绍，过往项目经历、实习经历</li><li>日常怎么运用 ai 大模型</li><li>讲一下 java 8 lambda 表达式</li><li>osi 7 层结构模型，每层的作用是什么</li><li>tcp 和 udp 的区别，tcp 超时重传、流量控制机制</li><li>怎么运用大模型，为探店博主或者商家提供服务，包括根据用户上传的图片或关键字，生成一个基础的探店笔记（追问 prompt 工程、怎么解决幻觉）</li><li>讲实习遇到的困难</li></ol><h3 id="题目14">题目14</h3><ol><li>自我介绍，特别问了AI大模型在你学习过程中给你的帮助</li><li>栈和队列的区别；生活中站和队列分别有什么应用场景？</li><li>Lambda表达式的作用和使用场景？Lambda表达式和匿名内部类相比有什么优势？</li><li>解释消息队列的消息投递机制，比如“至少一次”、“至多一次”、“恰好一次”？“至少一次”投递机制会出现什么问题，怎么解决？</li><li>设计一个考勤管理系统，如何保证考勤记录的真实性？如何防止考勤过程中用户信息被人篡改？</li><li>利用AI大模型，为新入驻的商家提供一个“7×24小时的AI导师”，可以回答商家提供的各类问题？<br>追问：如果线上发现模型返回的JSON经常缺字段或格式错乱，导致下游服务解析失败，如何从Prompt设计、模型参数或后处理等方面系统性解决这个问题？<br>追问：后处理阶段发现模型生成的内容与预期字段不匹配，你会如何设计检测机制来发现和解决这些问题？</li><li>描述一次你成功识别并解决了一次潜在的、尚未显形的问题，你是如何预见并采取行动的？</li></ol><h3 id="题目15">题目15</h3><p>1、自我介绍+项目拷打<br>2、对于分库分表，是按照什么分的<br>3、为什么要把数据分开存储，不能都存到分布式数据库里吗？分布式数据库和普通数据库区别是什么<br>4、当数据库表超过2千万之后，处理方案是什么？<br>5、有学过计算机相关的课程吗，对哪一门比较熟悉（这里我说网络）<br>6、说一下滑动窗口的原理<br>7、讲一下三次握手和四次挥手<br>8、提到close_wait 和 time_wait，说一下这两个状态过多的影响，以及哪个危害更大。<br>9、阐述一下类加载的过程，包括具体加载到什么地方<br>10、元空间和方法区会存放哪些信息<br>11、有使用过AI吗？现在大模型的幻觉问题比较大，平时处理方法是什么？<br>12、知道RAG吗？阐述一下Rag原理，以及它是如何处理大模型幻觉问题的<br>13、说一下未来的职业规划？如果工作内容不符合你的规划呢？<br>14、知道大模型的生成数据流推送的方案吗？就是如何逐字输出的？<br>15、WebSocket 和 SSE 的区别是什么？<br>16、单工一定比全双工性能要好吗？<br>17、对于分表后的主键ID是怎么处理的</p><h3 id="题目16">题目16</h3><p>15min<br>实习业务介绍及问答<br>聊聊 RAG 和 Embedding？它们是啥，有啥用？<br>你是怎么学大模型的？<br>你觉得大模型能在哪些地方实际用起来？</p><p>10min<br>讲讲悲观锁和乐观锁？<br>消息队列有啥用？<br>RocketMQ 和 Kafka 有啥区别？底层实现上有什么不一样？<br>Kafka 消费消息比 RocketMQ 快吗？为啥？<br>顺序消费有啥要注意的？</p><p>15min<br>布隆过滤器一般用在哪？原理是啥？<br>MySQL 的索引是啥原理？有啥用？<br>B+ 树和 B 树有啥区别？<br>MySQL 的隔离级别有哪几种？分别怎么实现的？<br>设计一个外卖流程：用户下单、商家接单、骑手派单，大概是个啥过程？会用到哪些数据结构和算法？</p><h3 id="题目17">题目17</h3><ol><li>redis为什么快，性能为什么高？</li><li>redis里面基本的数据类型有哪些？</li><li>一些数据类型也是redis优化之后导致redis快的原因，能够就其中一个redis数据结构的优化来举出一个实际的例子吗？</li><li>你能先描述一下跳表的数据结构长什么样子？</li><li>跳表空间复杂度是多少？</li><li>说说对redis事务的理解？</li><li>说说对mysql事务的理解？</li><li>说一下redis的持久化方案把？</li><li>redis主从同步主要采取哪种形式？</li><li>redis有几种部署模式？</li><li>你觉得集群模式和哨兵模式的主要区别是？</li><li>集群模式中如何出现一个redis热点key的情况，怎么做防止节点单点压力过大？（我回答是业务层面解决，每个节点都缓存热点key，用一个哈希集合存储热点key，直接快速判断是否走本地查询，而不是哈希索引节点）</li><li>说一下mysql的隔离级别以及每种隔离级别下可能出现的问题？</li><li>说一下可重复读是怎么解决不可重复读的问题？</li><li>说一下什么是聚簇索引？</li><li>聚簇索引和聚簇索引有什么区别？</li><li>数据结构的区别在哪里？都用的是B+数吗？</li><li>B+数的结构原理是什么？</li><li>什么是覆盖索引？</li><li>覆盖索引有什么好处？</li><li>最近的话，AI大模型比较火，你有没有学习AI大模型相关的原理，大模型微调了解过吗？</li></ol><h3 id="题目18">题目18</h3><p>1.介绍多态，重载、重写底层如何实现<br>2.野指针和悬挂指针出现场景，产生什么后果，如何解决<br>3.介绍智能指针，什么操作会导致共享指针引用计数加1、减1<br>4.如果想把一个智能指针的释放控制在某一个线程内应该怎么做？这个我不会，面试官说要让指定线程一直持有着它，然后再释放，我还是没太懂<br>5.对堆和栈的理解<br>6.申请堆空间的方式，两种方式的区别<br>7.STL库有了解吗？vector有了解吗？<br>8.除了添加元素时容量不够会扩容，还有什么时候会扩容？这个我不知道，面试官说还有一个用来动态扩容的容器阈值，当前申请的内存超过阈值时会提前申请。<br>9.vector底层数组在内存分配上是什么特性<br>10.还有其他内存分配方式吗<br>11.为什么有epoll，epoll的水平触发和边缘触发<br>12.tcp三次握手<br>13.对于客户端和服务器而言，是怎么认出这个tcp连接的？我当时一直没get到面试官的意思，现在想想应该是想让我回答四元组标识一条连接吧？<br>14.客户端和服务器的fd都是什么时候生成的<br>15.连接队列满了会给客户端返回什么？不清楚，面试官说reset<br>16.进程和线程。我当时有点昏头了，说进程不能很好的利用多核cpu，面试官说多进程也可以用多核<br>17.进程间通信<br>18.linux排查问题的相关命令：查网络连接、查网络连接个数、grep反向查找</p><h3 id="题目19">题目19</h3><p>说一下java并发编程<br>多个线程访问同一个资源 怎么设计<br>多个线程访问同一个资源 用sycoenized锁性能如何 如果优化的话怎么优化<br>分布式事务<br>缓存击穿<br>缓存击穿和缓存穿透的区别<br>设计一个新闻推送<br>如果用ai进行新闻推送分类的话 提示词怎么写<br>如果让你用ai生成营销策略的话怎么设计提示词<br>如果大模型出现产地硬信息描述不符怎么办<br>如果大模型回答缺一个点 怎么办<br>你项目中最有难度的一个问题 如何排查的</p><h3 id="题目20">题目20</h3><p>2min</p><p>自我介绍</p><p>15min</p><p>实习业务介绍及问答</p><p>Q: RAG和embedding了解吗，是什么有什么作用</p><p>RAG检索增强生成，可以拓展模型上下文，缓解模型幻觉和时效问题。</p><p>embedding可以将非结构化数据（文本图片视频）转化为结构化数值向量，向量每个数值代表某个维度上的特征，以此让机器也能理解分类和检索数据。</p><p>Q: 你是怎么学习大模型的</p><p>论文、博客</p><p>Q: 大模型你觉得有哪些可以落地应用的地方</p><p>AI coding、豆包形式AI应用、行业定制agent和传统互联网业务赋能。</p><p>​</p><p>10min</p><p>Q: 悲观锁和乐观锁概念</p><p>是否强制加锁，区别于在进入共享资源区之前是否允许其他请求修改共享资源。</p><p>Q:  消息队列的作用</p><p>削峰填谷、异步化、服务解耦。</p><p>Q:  RocketMq跟Kafka区别，底层实现有什么不同</p><p>架构相似，功能RocketMq更丰富，吞吐量KafKa更大，底层零拷贝策略不同。</p><p>Q:  kafka消息消费比RocketMq快吗，为什么</p><p>Kafka sendfile零拷贝(没有用户态和内核态之间的拷贝)，RocketMq mmap零拷贝(比sendfile多一次拷贝)。</p><p>Kafka 分区消息顺序写磁盘且可以通过分区偏移量直接从日志文件中读到数据，RocketMq队列消息都存在全局CommitLog中，只是同一队列消息有序，但在磁盘上位置可能分散，且定位消息位置需要两次寻址。</p><p>Q:  顺序消费要注意什么</p><p>生产者生产的消息要发送到同一个队列，指定单个消费者单线程或多线程加锁消费该队列。</p><p>​</p><p>15min</p><p>Q:  布隆过滤器使用场景及原理</p><p>缓存穿透+ 哈希函数 + bitMap。</p><p>Q:  mysql的索引原理，作用</p><p>多叉自平衡树B+树，将数据按索引字段顺序编排，查询效率更高。</p><p>Q:  B+树跟B树的区别</p><p>B+树仅叶子节点存储数据，树高度更低减少磁盘IO且查询效率稳定，叶子节点双向连接方便范围查询。</p><p>Q:  mysql的隔离性有哪些，怎么实现的</p><p>读未提交、读已提交、可重复读和串行化，其中读已提交和可重复读通过MVCC和undo log配合实现。</p><p>Q:   用户下单，商家接单，骑手派单中间大致是个什么样的过程，涉及什么数据结构和算法上的考量</p><p>​</p><p>7min</p><p>括号匹配</p><p>​</p><p>8min</p><p>反问</p><p>消息队列没回答好，因为我不了解kafka，但最近被问到好几次，最后一道场景题更是懵逼。</p><h3 id="题目21">题目21</h3><p>1.redis的事务和mysql的事务区别</p><p>2.redis事务在命令入队期间出错了会不会回滚</p><p>3.redis事务底层是如何实现的？（没看过，随便说的应该是放到一个事务队列依次执行的</p><p>4.redis线程模型</p><p>5.redis持久化方式，只用aof行不行</p><p>6.redis哨兵模式，如何判断挂没挂（心跳+Gossip</p><p>7.redis集群模式，如何判断节点挂了和后续的选举动作</p><p>8.redis缓存淘汰策略</p><p>9.mysql的delete、truncate、drop的区别（当时脑子懵了，以为问的都是删除行的操作，后两个删除行没听说过啊。。。）</p><p>10.mysql持久化怎么实现的？</p><p>11.什么是MVCC以及MVCC怎么实现的？可重复读和读已提交怎么实现的</p><p>12.innodb引擎层的查询优化（解释了索引下推和select多的时候不走索引</p><p>13.慢sql排查优化</p><p>14.项目分库分表，数据多大需要考虑分表</p><p>15.手撕：接雨水好久没复习了不会，换了道层序遍历+单例模式（我哭死</p><p>16.volatile解释</p><p>17.synchronized底层实现原理，具体说Monitor的结构和c++的objectMonitor</p><p>18.synchronized和reentrantlock，怎么实现非公平锁。说下juc包下你说过的类有什么</p><p>19.线程池参数（7个，一段时间没复习了说了5个），核心线程数怎么设置，队列设多大（给了个响应速度要求高的场景，当时没敢说队列设为0，只说了尽量小，后面看了个美团的博客一模一样的场景。。。）</p><p>20.阻塞队列有哪些（原来有这么多BlockingQueue。。。）</p><h3 id="题目22">题目22</h3><p>1.一上来自我介绍都没有，自己问</p><p>2.java线程池，从参数到流程</p><p>3.线程池是怎么把任务给线程执行的？<br>（我前面已经讲过线程池的流程，阻塞队列啥的，我说不就是还没到核心线程数就新建线程执行吗，面试官说不不不，就是线程池怎么把任务给线程执行的，我又说了线程池提交任务的execute和submit，面试官又重复不不不，到这里我没招了，然后问我没看源码吗）<br>刚下来查了会ai，源码是有一个worker对象对应线程，然后有run方法和runwork方法。怪我没看源码。</p><p>4.看过spring源码吗（看八股的时候或多或少看过，愣了几秒回没看过）</p><p>5.jdk和cglib动态代理，为什么jdk要目标类实现接口的（我说jdk是反射，通过代理类实现相同接口，覆盖，起到代理效果。面试官还问为什么要接口，又一次不知道怎么开口。ai说：JDK动态代理依赖于接口的多态性。如果没有接口，代理类无法确定需要生成哪些方法）</p><p>6.mysql慢查询，深分页怎么优化</p><p>7.mysql索引失效情况</p><p>8.mysql优化</p><p>9.redis你一般用来干什么，讲讲项目怎么用的</p><p>10.redis5种数据结构</p><p>11.跳表结构，跳表查询时间复杂度</p><p>12.跳表的索引高度是怎么确认的（又一个不知道的，我结结巴巴说他自动生成的。ai说：在跳表中，每个节点的索引高度（即该节点有多少个指针）是通过随机化方法确定的。具体来说，通常使用一个随机数生成器来决定每个节点的索引高度。这种方法的优点是简单且高效，同时能够保证跳表的平均性能。）</p><h3 id="题目23">题目23</h3><p>\1. 自我介绍。</p><p>\2. 拷打项目。</p><p>\3. HashMap 是怎么解决哈希冲突的？</p><p>\4. 红黑树和 AVL 树有啥区别？</p><p>\5. 排序算法有哪些？哪些是稳定的？</p><p>\6. TCP 是怎么保证可靠传输的？</p><p>\7. 讲讲拥塞控制？</p><p>\8. MySQL 是怎么做到事务隔离的？隔离级别有哪几种？</p><p>\9. Spring Boot 里用到了哪些设计模式？</p><p>\10. 你还知道哪些设计模式？</p><p>\11. 面向对象有哪些特性？</p><p>\12. 聊聊设计模式的六大原则，挑两个讲讲？</p><h3 id="题目24">题目24</h3><p>你的学习路线是啥？</p><p>为啥用 Spring Cloud？</p><p>啥是自动装配？</p><p>聊聊 AOP 和 IOC？</p><p>IOC 有啥用？和单例模式有啥区别？它具体是怎么解耦的？</p><p>为啥用 B+ 树？</p><p>MySQL 的事务隔离级别有哪几种？</p><p>MVCC 为啥解决不了幻读？</p><p>讲讲 RabbitMQ？</p><p>如果让你来设计 RabbitMQ，你会怎么做？</p><p>Redis 有哪些数据类型？</p><p>Sorted Set 是怎么实现的？</p><p>为啥用跳表？</p><p>JMM 模型是啥？</p><p>进程和线程有啥区别？</p><p><code>volatile</code> 关键字底层是怎么保证可见性的？</p><p>TCP 和 UDP 有啥区别？</p><h3 id="题目25">题目25</h3><p>\1. 在日常学习工作中如何使用大模型？举一个具体场景案例</p><p>\2. HTTP 和 HTTPS 的区别？HTTPS 对称加密和非对称加密如何应用？</p><p>\3. 消息队列消息发送方式？</p><p>\4. 缓存穿透成因及解决方案？布隆过滤器局限性？</p><p>\5. 帮助商家回复用户评价的大模型方案设计？面对用户评价中恶意评价、prompt 攻击之类的如何解决？</p><p>\6. 项目遇到的难题？如何找出难题的具体原因？详细说明白</p><h3 id="题目26">题目26</h3><p>HTTP 和 RPC 有啥区别？</p><p>数组和链表有啥区别？</p><p>哈希表的实现和底层是啥？具体怎么查找？Redis 的哈希底层结构是啥？</p><p><code>VARCHAR</code> 和 <code>CHAR</code> 有啥区别？</p><p>事务四大特性是啥？怎么实现的？</p><p>从输入网址到页面显示，发生了啥？</p><p>Redis 有啥优点？</p><p>聚簇索引和非聚簇索引是啥？</p><p>联合索引，面试官举了个例子问会不会失效。</p><p>啥是回表？啥是覆盖索引？</p><p>大 Key 问题怎么解决？</p><p>熟悉哪些设计模式？</p><h3 id="题目27">题目27</h3><p>1.redis的提前缓存的同步链路怎么实现？</p><p>2.rabbitMQ的幂等性怎么实现？</p><p>3.你在开发时怎么提高接口性能？</p><p>4.java的常用集合介绍一下？</p><p>5.哪些集合是线程安全的哪些是线程不安全的？</p><p>6.HashMap和concurrentHashMap的对比？</p><p>7.ConcurrentHashMap线程安全怎么实现？</p><p>8.java的锁机制介绍一下？</p><p>9.ReentrantLock的实现原理介绍一下</p><p>10.volatile关键字介绍下</p><p>11.java创建线程池怎么实现？</p><p>12.线程池的工作原理？</p><p>13.拒绝策略都有什么？</p><p>14.你项目中使用到了两个线程池，他们的拒绝策略不一致是怎么考虑的？</p><p>15.jvm调参怎么实现？</p><p>16.什么是GC？</p><p>17.知道哪些垃圾回收器？</p><p>18.jvm怎么分析线上进程线程对象的信息？</p><p>19.性能分析工具有了解过吗？</p><p>20.你的工具是怎么使用的？</p><p>21.springboot的启动流程讲一下？</p><p>22.在 Spring 启动过程中，若要在其生命周期的特定阶段执行自定义操作，怎么实现？</p><p>23.mysql的底层索引的数据结构是什么？</p><p>24.你都知道哪些索引？</p><p>25.怎么分析建立的索引有没有生效？</p><p>26.什么是索引失效？</p><p>27.联合索引建立之后，使用了两个字段做过滤，那么有没有可能不走索引？</p><p>28.mysql基于成本的优化考量通过什么算法来实现的？</p><p>29.mysql怎么分库分表？什么情况下分库，什么情况下分表？</p><p>30.redis的数据结构有什么？</p><p>31.解释一下缓存穿透、缓存击穿和缓存雪崩？怎么解决？</p><p>32.高并发系统中怎么保证数据一致性？</p><p>33.加锁如何保证数据一致性？</p><p>34.rabbitmq介绍下底层原理？</p><p>35.当一条消息被发送到 RabbitMQ 集群后，这条消息去哪了？</p><h2 id="二面">二面</h2><h3 id="题目1-2">题目1</h3><p>1.问了两句学校的项目，不是后端的，面试官肉眼可见没有兴趣</p><p>2.问了问实习做的rag项目的情况，不拷打纯聊天15分钟</p><p>3.RAG技术发展历史</p><p>4.java项目相关细节问题，比较常规：雪花算法，基因法分表，redis和db的一致性，缓存击穿</p><p>5.手撕</p><p>6.聊天室系统设计20min，业务实现orm设计、数据库设计、分库分表、restful接口设计</p><p>7.平时怎么学习，职业定位规划</p><h3 id="题目2-2">题目2</h3><p>主要聊了实习，还有 JDK 8 升 21 碰到的问题。</p><p>问了 UDP 广播。</p><p>场景题：微博大 V 发帖，用户量巨大，怎么优化？</p><p>问项目是不是自己写的，还问了分布式事务。</p><p>计网方面问了拥塞控制。</p><p>问了 JVM，怎么把元空间塞满？</p><p>问了些 Docker 的细节。</p><p>问了 Redis 的 Bitmap。</p><p>问了垃圾回收器。</p><p>问了怎么用大模型。</p><h1>米哈游</h1><h2 id="一面-2">一面</h2><h3 id="题目1-3">题目1</h3><ol><li>自我介绍</li><li>实习经历</li><li>MongoDB和MySQL选型上有过考量吗</li><li>Redis分布式锁</li><li>Redis怎么做消息队列，可以使用什么数据结构</li><li>怎么用Redis的数据结构实现一个延迟消息队列</li><li>项目经历，页面查询优化怎么做</li><li>游标和offset limit</li><li>订单数据同步的数据一致性怎么体现</li><li>Redis在这里的作用</li><li>MySQL的事务隔离级别</li><li>MySQL三种日志</li><li>二阶段提交</li></ol><h1>饿了么</h1><h2 id="一面-3">一面</h2><h3 id="题目1-4">题目1</h3><p>你用了优先队列（Priority Queue），这种做法本质上属于哪类排序？</p><p>该算法的时间复杂度和空间复杂度各是多少？</p><p>除了优先队列＋虚拟节点方案，你有没有想到其他更优解？</p><p>对“基本有序”数组，哪种排序最优？为什么？</p><p>请讲解快速排序的核心思想与流程。</p><p>如何快速从无序数组中找出第K大的元素？（如第3大、第10000大等）</p><p>最优解可否用堆？可否用快速选择（Quickselect）？</p><p>用3–5分钟重点介绍一个你参与度高、技术含量突出的项目。</p><p>你了解哪些开源RPC框架？</p><p>请详细讲一下阿里Dubbo的注册／发现机制、核心功能及优缺点。</p><p>令牌桶限流原理是什么？关键点在哪里？</p><p>你还知道哪些限流策略（固定窗口、滑动窗口、漏桶等），它们各自优缺点是什么？</p><p>你对Spring源码做过哪些研读？关注了哪些模块？</p><p>在Spring MVC中，IOC容器的两个最核心职责是什么？</p><p>能否详细讲解Spring容器的启动、类加载、Bean定义解析、依赖注入全过程？</p><p>JVM类加载双亲委派流程是怎样的？如何打破它？</p><p>请描述Java内存区域：堆、栈、方法区（永久代/元空间）、本地方法栈等。</p><p>哪些区域可能抛出OutOfMemoryError？</p><p>为什么Java 8将永久代改为元空间？它们在内存上的区别与优劣？</p><p>为什么要把String设计为不可变？</p><p>StringBuilder与StringBuffer有何区别？</p><p>反射的优点和缺点有哪些？</p><h1>携程</h1><h2 id="一面-4">一面</h2><h3 id="题目1-5">题目1</h3><p>2.项目拷打</p><p>a.把项目部署在服务器上你会怎么做？</p><p>b.把项目进行打包要打包成哪几个部分？怎么进行打包？前端后端分哪几个部分？</p><p>c.跨域问题怎么解决？</p><p>d.实时私聊功能怎么做的？</p><p>e.假如一下子有大量消息的话，服务端要怎么保证消息转发的实时性和完整性？</p><p>3. MySQL索引的原理？</p><p>4. B+树和B树的区别？</p><p>5. Redis怎么实现分布式锁？</p><p>6. Redis在应对高并发请求场景下有什么应对策略？（一开始说了搭建集群来做分流，后面面试官提示说要从令牌桶技术限流角度出发）</p><h1>小米</h1><h2 id="一面-5">一面</h2><h3 id="题目1-6">题目1</h3><ol><li><p>开场做了自我介绍，并详细介绍了项目经历</p></li><li><p>聊聊你对Java集合框架的理解吧。ConcurrentHashMap在1.7和1.8里有啥不一样的地方？</p></li><li><p>Java内存模型（JMM）能介绍一下吗？GC这块呢，讲讲内存回收？对了，逃逸分析了解不？</p></li><li><p>Java并发编程里的锁，你是怎么理解的？CAS底层是怎么实现的，能说说吗？</p></li><li><p>拦截器（Interceptor）和过滤器（Filter），它俩有啥主要区别？</p></li><li><p>SQL里 COUNT(*)、COUNT(1) 和 COUNT(具体列名)，它们之间有什么区别？</p></li><li><p>用Redis做延时消息，有什么实现方案吗？</p></li><li><p>HTTPS的加密和认证流程，还能想起来吗？能详细讲讲这个过程不？</p></li><li><p>假如有个特别大的日志文件，在Linux环境下，你会用什么命令去看它的内容？</p></li></ol><h1>阿里</h1><h2 id="一面-6">一面</h2><h3 id="题目1-7">题目1</h3><p>1.优惠卷秒杀模块的技术亮点</p><p>2.处理线程安全问题的锁分为哪几类，一般是怎么使用的</p><p>3.介绍一下偏向锁和自旋锁</p><p>4.说一说你了解的加密算法</p><p>5.聊一聊你所了解的缓存</p><p>6.缓存一致性问题</p><p>7.在读取缓存时可能出现的相关问题</p><p>8.讲一下布隆过滤器的特点</p><p>9.布隆过滤器存在的假阳性的问题怎么进行优化</p><p>10.分布式系统的设计考量</p><p>11.分布式锁的大概原理</p><p>12.微服务的工作流程</p><p>13.微服务的服务数量很多的情况下如果某一个服务突然挂掉了可能引发微服务的雪崩，该怎么解决</p><p>14.限流算法的了解</p><p>15.CAS和AQS的原理</p><h3 id="题目2-3">题目2</h3><p>\1. 聊聊 Java 线程池的参数？线程池是怎么执行任务的？</p><p>\2. 建 MySQL 索引时要考虑啥？用 MySQL 的时候，要关注哪些指标？</p><p>\3. Redis 是怎么做持久化的？</p><p>\4. 对 AI 了解多少？了解 Milvus 吗？(这块我讲了一堆理论，但面试官没怎么追问)</p><p>\5. JVM 垃圾回收有哪些算法？CMS 和 G1 有啥区别？</p><p>\6. 为啥要用分布式锁？什么场景下会用？</p><p>\7. 讲一个项目里解决问题的经历？</p><p>\8. 你平时是怎么学新东西的？</p><h3 id="题目3-2">题目3</h3><p>1.自我介绍<br>先问的八股<br>2.简单描述一下常用集合类的适用场景及线程安全性<br>3.ArrayList 和 HashMap的增删改查复杂度<br>4.ReentrantLock 和 synchronized的区别<br>reentrantLock 的尝试机制忘了说了<br>5.mysql 事务<br>6.举个幻读的例子<br>7.mysql中建索引要注意什么<br>8.举个例子说明下什么是回表<br>9.如何避免回表<br>10.分库分表问题<br>面试官提示 : 尽量打散 结合业务需求分表<br>11.缓存雪崩击穿穿透问题</p><h3 id="题目4-2">题目4</h3><p>自我介绍</p><p>讲实习 35min<br>toc场景如何确保DB和REDIS尽量实时？<br>怎么避免缓存雪崩和击穿？<br>假如列表查询时数据量极大需要分页怎么办？</p><p>八股 10分钟<br>hashset讲一下<br>threadlocal讲一下</p><p>场景15分钟<br>设计一个智能会议总结系统<br>大致流程是前端把语音发到后端，调用工具转文字，调用大模型进行总结，再发回前端</p><h3 id="题目5-2">题目5</h3><p>\1. 为什么要使用CompletableFuture<br>\2. 线程池是怎么管理的<br>\3. 实习经历<br>\4. 本地缓存相关<br>\5. ThreadLocal内存泄漏<br>\6. HashSet为什么能去重<br>\7. Redis怎么保证原子性<br>\8. 缓存击穿和缓存雪崩<br>\9. 慢SQL优化<br>\10. 场景题：1. 前端录音 → 后端接收录音 → 后端调用阿里云API转文字 → 利用文字调用大模型API总结 → 文字落库</p><ol start="2"><li>前端调用后端接口输出文字</li></ol><h3 id="题目6-2">题目6</h3><p>1、自我介绍</p><p>2、实习询问（5min）</p><p>3、项目拷打（20min）</p><p>4、谈谈 Java 的 HashMap</p><p>5、线程池的核心参数</p><p>6、线程池从没有任务到繁忙起来，再到空闲这个过程中，参数是如何变化的？</p><p>7、谈谈浅拷贝和深拷贝的区别</p><p>8、谈谈 Java 的 String 是怎样的结构？内部怎么设计的？</p><p>9、String 类在加载后会存在什么区域？</p><p>10、谈谈 JVM 的内存模型</p><p>11、GC 算法有哪些？每种算法应用在什么场景？</p><p>12、谈谈 CMS 垃圾回收器的回收过程</p><p>13、CMS 在哪些阶段会 Stop The World？</p><p>14、谈谈 G1 和 CMS 的区别</p><p>15、如何排查 OOM 问题？</p><p>16、如何排查 CPU 100% 问题？</p><p>17、日常开发过程中对于类冲突或者 jar 包冲突，如何去解决？（加载第三方包，和自己的环境不适配）</p><p>18、MySQL 怎么去排查慢 SQL？</p><p>19、谈谈 MySQL 的 InnoDB 存储引擎的索引结构</p><p>20、为什么 InnoDB 不选择 B 树或者红黑树？</p><p>21、MySQL 的排序 order by，对于大数据的排序，是怎么实现的？</p><p>22、目前对于 AI相关的一些前沿的技术自己有去了解过吗？</p><p>23、你认为对于数据标注类工作，比如判断一张图片有无水印，能否用 AI 去代替人工？</p><h1>腾讯</h1><h2 id="WXG一面">WXG一面</h2><h3 id="题目1-8">题目1</h3><p>1. 实习干的东西</p><p>2. 权限管控怎么做的</p><p>3. 权限管控是怎么标识的用户</p><p>4. 怎么保证用户信息不会被传输过程篡改</p><p>5. https怎么保证的加密传输</p><p>6. 线程和进程的区别 进程能访问其他应用的内存吗 为什么</p><p>7. 线程和协程的区别</p><p>8. 项目里为什么要使用登录 qq登录怎么做的 过程是怎样的 qq是怎么加密的中间数据</p><h3 id="题目2-4">题目2</h3><p>Canal 和 Kafka 之间是怎么交互的？用的什么协议？<br>Kafka 的实现原理是啥？<br>ES 为什么这么快？讲讲倒排索引，还有文档列表是啥意思？<br>资源隔离是怎么实现的？<br>K8s 的部署和滚动更新流程是怎样的？怎么在更新的时候保证服务不中断？<br>有个下载文件的问题（具体忘了）<br>操作系统启动时都干了些啥？<br>聊聊操作系统的内存管理和进程管理？<br>给你一大堆 IP 地址，怎么找出哪个网段下的 IP 最多？<br>我答了个 O(n) 的方案，面试官追问怎么避免哈希冲突，有没有更好的方法，还问了哈希冲突最极端的情况怎么办。<br>又追问，如果想找 Top 3 怎么办？要是内存不够，又该怎么找 Top 10？</p><h3 id="题目3-3">题目3</h3><ol><li>自我介绍</li><li>开篇面试官介绍了一下这次面试的流程</li><li>HashMap和HashTable的区别？</li><li>接T3，针对HashTable的问题，有没有解决方案？（ConcurrentHashMap）</li><li>线程和进程的区别？</li><li>接T5，通信方式上有什么区别？</li><li>MySQL索引结构？</li><li>接T7，B树和B+树的区别是什么？</li><li>接T8，为什么说B+树更好做范围查询？</li><li>MySQL事务隔离级别？</li><li>MVCC</li><li>索引失效的情况都有哪些？</li><li>Redis持久化方案？</li><li>缓存雪崩、缓存穿透、缓存击穿</li><li>讲讲TCP的三次握手和四次挥手</li><li>说说Linux的常用命令？</li><li>有没有用过Docker？说说Docker的常用命令？有自己构建过Docker镜像吗？</li></ol><h3 id="题目4-3">题目4</h3><p>你对腾讯云智的产品有哪些了解？有没有使用过相关的服务？<br>Java 中的集合框架有哪些？HashMap 和 ConcurrentHashMap 的区别是什么？<br>谈谈 Java 中的多线程，线程池的核心参数有哪些？如何设置合理的线程池参数？<br>Spring IoC 和 AOP 的原理是什么？在项目中是如何使用 AOP 的？<br>Spring 事务的传播机制有哪些？你在实际开发中遇到过哪些事务相关的问题<br>Java 中 synchronized 和 Lock 的底层实现原理有何区别？谈谈你对偏向锁、轻量级锁、重量级锁的理解<br>深入分析 ThreadLocal 的内存泄漏问题，如何避免？在分布式场景下如何实现类似 ThreadLocal 的功能？<br>Redis 的持久化机制有哪些？RDB 和 AOF 的优缺点及适用场景是什么？如何解决 AOF 重写时的性能问题？<br>Redis 的集群方案有哪些？哨兵模式和 Cluster 模式的区别是什么？Cluster 模式下槽位迁移的过程是怎样的？<br>RabbitMQ 的交换机类型有哪些？详细说明 Topic 交换机的路由规则，如何保证消息的可靠性投递（从生产者到交换机、交换机到队列、消费者消费三个环节分析）<br>单例模式的实现方式有哪些？哪种方式是线程安全的？<br>在项目开发中，你是如何进行代码调试和排错的？有什么技巧吗？<br>工厂模式和抽象工厂模式的区别是什么？在什么场景下会使用抽象工厂模式？<br>工厂模式在实际项目中有哪些应用？你觉得使用工厂模式有什么好处？<br>Java 中的异常处理机制是怎样的？try-catch-finally 块的执行顺序是什么？<br>谈谈你对 Java 内存模型的理解，volatile 关键字的作用是什么？<br>数据库的分库分表有哪些方案？各自的优缺点是什么？<br>在进行 Java 开发时，你是如何保证代码质量的？会使用哪些工具？</p><h3 id="题目5-3">题目5</h3><p>1.自我介绍<br>2.5层网络分别是什么，讲讲每层什么协议，有什么东西<br>3.MTU包含哪些层的数据，大小一般多大怎么计算<br>4.MTU和MSS区别<br>5.TCP怎么保证可靠的<br>6.建连和断连是怎么样<br>7.为什么挥手四次要比握手多一次<br>8.挥手并不是一定得四次，能在更少次数内实现，请分析可能怎么做的<br>9.既然能挥手次数更少，但是为什么现在主流还是四次<br>10.我假设是一个客户端，我在和服务端通信，我怎么知道发送窗口数据量是多大呢<br>11.现在已经有了一个滑动窗口了，这个滑动窗口大小变化的时候是怎么变化的<br>12.我丢包了，那这个窗口大小是不是就有问题了，有什么处理方案<br>13.你作为一个一端的程序，是怎么知道是网络拥塞还是是链路丢包的<br>14.TCP的拥塞控制是怎么做的<br>15.假设要让你设计一个完整的判断网络拥塞还是链路丢包的协议，你会怎么设计<br>16.现在假设你打开腾讯视频，突然某些（不是所有）视频你看不了了，你会怎么分析+排查+定位+解决这个问题，从app端上的问题-》网络的问题-》服务端的问题各个角度尽量全面的分析<br>17.wireshark你了解吗，怎么在手机上抓包呢<br>18.算了你假设你能在手机上抓包，你怎么从二进制数据排查定位分析这个场景的问题原因呢<br>19.抓包的底层原理是怎么样的，这个包是怎么从操作系统的内核态数据取到的<br>20.HTTP1-3对比，讲讲多路复用在内核是怎么实现的<br>21.QUIC保证udp可靠传输和tcp自身可靠传输的对比<br>22.HTTP和HTTPS区别<br>23.你讲讲HTTPS的完整的方案<br>24.你这种方案的RTT是多少<br>25.有1RTT的HTTPS方案，你了解吗<br>26.你对网络安全了解多少，像DDOS攻击，中间人攻击这些了解吗，有没有一些解决</p><h2 id="二面-2">二面</h2><h3 id="题目1-9">题目1</h3><ol><li><p>自我介绍</p></li><li><p>有用过MQ对吧，那你说说怎么解决消息重传的？</p></li><li><p>你是怎么做消息幂等性处理的？</p></li><li><p>接T3，如果说Redis的key已经存入了，但是刚好消费者宕机了，怎么办？</p></li><li><p>建立索引的SQL语句是？</p></li><li><p>TLS握手过程</p></li><li><p>手撕1：单链表有一个指针指向任意一个节点，怎么删除这个指针指向的节点，如1→2→3→4，传入2，删除2，没有头指针（回答了更改节点值，next设置为next.next，追问怎么删除最后一个节点，不会，换了道题）</p></li></ol><h2 id="三面">三面</h2><h3 id="题目1-10">题目1</h3><ol><li>自我介绍</li><li>拷打项目</li><li>拷打实习</li><li>我现在有一个student表，我要对name简历索引，sql语句怎么写？</li><li>主键索引和普通索引有什么区别？</li><li>为什么非聚簇索引要回表？</li><li>MySQL隔离级别？</li><li>MySQL主从同步原理？</li><li>binlog日志存的是什么？</li><li>Redis缓存雪崩是个什么概念？怎么解决？</li><li>Redis持久化方式？</li><li>HTTP报文格式？</li><li>HTTP和HTTPS有什么不同？</li><li>TLS握手过程？</li><li>为什么是非对称加密和对称加密结合使用？能不能只使用一种？</li><li>面向对象三大特性</li><li>我现在有一个Java源代码，比如说叫xxx.java，他是如何变成一个二进制文件的能够让机器运行他的？这个中间的过程是怎么样的？</li><li>JVM的作用是什么？</li><li>进程和线程的区别？</li><li>有没有了解过协程？跟线程的区别是什么？</li><li>为什么说协程为什么更轻量？</li><li>二进制文件加载进内存，他的分布是怎么样的？</li><li>Linux上怎么看机器的负载？</li><li>top命令哪些参数表示负载？</li><li>Linux怎么看cpu的核数？</li><li>Linux怎么查看当前目录占用了多少空间？</li><li>查看当前服务器建立的tcp连接，用什么命令？</li><li>tcp滑动窗口机制是怎么样的？</li><li>time_wait状态是什么意思？</li><li>为什么是四次挥手？</li><li>三次握手是怎么实现的？中间的ACK和SYN是怎么合并的？</li><li>用过docker吗？怎么做到容器间隔离的？</li><li>怎么构建docker镜像？</li><li>有了解AI吗？大模型训练过程是怎么样的？</li><li>有没有了解过MCP？</li><li>使用过什么AI工具？</li></ol><h1>中兴通讯</h1><h2 id="题目1-11">题目1</h2><p>1、两段实习拷打，没手撕；</p><p>2、如果你想做出海业务你会想怎么去因地制宜设计架构；</p><p>3、redis大key对于cpu和网络流量的影响；</p><p>4、redis跳表结构；</p><p>5、mysql的b+树结构，mysql的FULLTEXT索引是否能帮助进行模糊查询，这个索引和es直接查询区别在哪；</p><p>6、sql语句执行顺序；</p><p>7、线程池原理；</p><p>8、Hashmap结构和扩容机制；</p><p>9、Java开发中用到的同步机制；</p><p>10、rpc调用链路中怎么保证分布式事务的最终一致性；</p><p>11、谈谈kafka怎么保证消费的一致性和顺序性还有可靠性；</p><p>12、说说gc收集器，说说怎么排查gc日志；</p><p>13、说说Java开发过程你用到的设计模式；</p><p>14、说说你简历写的慢sql排查思路；</p><p>15、死锁检查，银行家算法；</p><p>16、jvm结构；</p><p>17、JNA怎么保证不内存泄漏；</p><p>18、OOM常见情况；</p><p>19、linux大页；</p><p>20、拦截器和过滤器；</p><p>21、一致性协议还有相关的选举机制；</p><p>22、redis缓存雪崩穿透击穿场景和解决方法；</p><p>23、常见的哈希冲突，ThreadLocal怎么解决哈希冲突；</p><p>24、怎么优化提示词生成效果；</p><p>25、怎么写规则引擎；</p><p>26、你常用的设计模式；</p><p>27、类加载机制和双亲委派；</p><p>28、数据库三大范式；</p><p>29、2pc，3pc，tcc，seata；</p><p>30、最大堆最小堆是啥样子的，红黑树原理，堆排序过程。</p><h1>科大讯飞</h1><h2 id="题目1-12">题目1</h2><p>.自我介绍</p><p>2.问了一下实习的东西</p><p>3.问了一下Java中那些组件和技术学的好(我回答了Nacos,Sentinel,RocketMQ,Zookpper,Dubbo,Redis,Caffein这类的)</p><p>4.Java中的封装和反射的区别(这里建议回答为什么有封装了还需要使用反射,要更了解底层,比如要回答反射的一些作用,依赖注入这类的,要回答反射使用的一些例子(比如反射是用于动态代理,为什么是动态的?举例子),后面还问到了设计模式,我说到了代理模式(AOP),但是面试官说没有这种设计模式,最后说了一下工厂模式,但是没了解过工厂模式底层怎么使用到反射)</p><p>5.反射运行时灵活,怎么体现的?(最好说依据,举例子)</p><p>6.工厂模式底层怎么使用到反射,为什么这么使用</p><p>7.说一下Mysql的事务怎么实现的(我回答了锁)</p><p>8.Java里面有哪些锁</p><p>9.事务的特效(ACID)</p><p>10.说一下ACID是什么</p><p>11.你知道Redis也有事务,redis的事务跟Mysql的事务有什么区别(我不会)</p><p>12.问了一下毕业时间,有没有考研打算,说一下自己的职业规划,往什么方向发展,感兴趣什么,想从事什么职业</p><h1>影石</h1><h2 id="题目1-13">题目1</h2><p>1.自我介绍<br>2.介绍一下学校情况和学的语言和框架</p><ol start="3"><li>线程池的四种类型 ， 核心参数<br>4.单线程池的应用场景<br>5.同步的一些方式<br>6.reentranLock和synchronized的区别<br>7.各自怎么来进行同步过程，contional的sign()和await()；<br>8.correntHashMap , copyonWrite<br>9.ArrayList的扩容过程，复制过程是底层的system.copy();<br>10.容器快速失败过程和原理（就是遍历的时候被修改）<br>11.TCP和UDP的区别和各自应用场景</li></ol><h1>SOUL</h1><h2 id="一面-7">一面</h2><h3 id="题目1-14">题目1</h3><p>自我介绍<br>实习拷打：为什么用线程池，用了什么线程池？有什么指标吗？提升了多少？为什么用策略模式和工厂模式？还有哪些难点？<br>spring 的模块有哪些？<br>IOC， AOP，DI分别指什么？<br>spring bean生命周期<br>线程池有哪些优点，池化<br>mysql事务有哪些隔离级别<br>一条sql语句如何执行的<br>redis有哪些数据结构，使用场景<br>redis哨兵如何选举，<br>redis持久化机制</p><h1>得物</h1><h2 id="一面-8">一面</h2><h3 id="题目1-15">题目1</h3><p>1.简历上后端经历偏多，为什么来投递我们IOS端？<br>2.实习经历简单介绍一下<br>3.面向对象的设计原理？<br>4.设计模式了解哪些？<br>5.进程和线程的区别？<br>6.为什么会产生死锁？<br>7.讲一下优先级反转？<br>8.多线程操作非原子的数据的安全性怎么保障？<br>9.自旋锁是什么？<br>10.想要复用别人开发的方法但其只能满足自己一部分需求，可以怎么做？<br>11.怎么设计一个易复用的代码结构？<br>12.如果定义成纯虚函数，原有的功能逻辑怎么办？</p><h3 id="题目2-5">题目2</h3><p>自我介绍</p><p>1.dubbo的spi和java的spi有什么区别</p><p>2.分布式系统中的trace链路跟踪</p><p>3.线上的java服务cpu负载高怎么排查<br>怎么定位是哪块的代码出了问题</p><p>4.分布式系统调用下游服务怎么保证成功<br>怎么去设计重试机制 异步线程池不会爆满吗</p><p>5.java里的类加载机制<br>双亲委派怎么打破<br>spi 是怎么打破的</p><p>6.jvm内存溢出怎么排查(堆内与堆外怎么排查)</p><h3 id="题目3-4">题目3</h3><p>1、跳表原理</p><p>2、跳表相对于平衡树在并发场景下有优势</p><p>3、CAS 三大问题，以及怎么解决</p><p>4、版本号AtomicStampedReference的怎么解决</p><p>5、线程池使用无界队列的问题</p><p>6、线程线程怎么结束的</p><p>7、事务的@Transtional 注解，A事务调用B事务抛出异常之后，在默认事务传播机制下，会提交异常，因为 rollback 异常标志位已经被设置有值</p><p>8、如果一个Trace 调用耗时比较长，怎么去进行排查</p><p>9、Redisson 的看门狗机制</p><p>10、Spring 是如何解决循环依赖的11、Kafka 落盘如何建立索引</p><h3 id="题目4-4">题目4</h3><p>\1. 讲一下redis zset底层数据结构，讲讲跳表、压缩列表、listpack？</p><p>\2. 从浏览器地址栏输入网址按下回车，发生了什么？</p><p>\3. 浏览器怎么知道你按下了回车？</p><p>\4. 应用程序怎么知道客户端向其发送了请求？</p><p>\5. 影响MySQL B+树高度的因素</p><p>\6. 讲一下MySQL执行查询语句的流程</p><p>\7. [项目] 如果别人拿到了sessionId，就可以冒名登录，如何解决这个问题？</p><p>\8. [项目]每次进行判题都创建容器，是否会有性能问题？</p><p>\9. [项目]用户规模大后怎么解决QPS高的问题？</p><h1>滴滴</h1><h2 id="题目1-16">题目1</h2><ol><li>自我介绍。</li><li>(项目) 聊聊你们是怎么防止单点故障的？</li><li>(项目) 具体讲讲那 10 万条数据是怎么处理的？</li><li>线程池有哪些核心参数？它具体是怎么跑的？</li><li>线程池的核心参数，你一般都怎么设？特别是核心线程数和最大线程数。</li><li><code>synchronized</code> 和 <code>Lock</code> 有啥区别？要是碰到异常，它俩分别会怎么样？</li><li>JVM 的运行时数据区都包含啥？分别介绍一下？</li><li>MQ 一般都用来干嘛？除了削峰填谷还能干啥？为啥要用 MQ？</li><li>MySQL 优化，除了加索引还有别的招吗？</li><li>介绍下数据库的隔离级别？</li><li>讲讲缓存穿透？怎么解决？布隆过滤器具体怎么实现的？有啥特点？</li><li>手撕算法：10 万个数里找出最小的 10 个（用小顶堆）。</li><li>以后有什么规划？</li></ol><h1>猿辅导</h1><h2 id="一面-9">一面</h2><h3 id="题目1-17">题目1</h3><p>八股</p><ul><li>进程之间的通信的方式？</li><li>线程同步的方式？</li><li>阻塞&amp;非阻塞 和 同步&amp;异步 都是什么？</li><li>数据库事务的 ACID 都是怎么实现的？</li><li>使用事务的时候都要注意什么？如何做死锁避免？</li><li>分布式保证一致性的 CAP 和 BASE 理论</li></ul><p>项目</p><ul><li>为什么要用 RAG？</li><li>有做过 prompt 攻击的防范吗？</li></ul><h3 id="题目2-6">题目2</h3><p>自我介绍<br>项目询问<br>百度实习的qps、流量大小<br>怎么保证服务可用<br>怎么处理慢查询<br>介绍一下百度实习的技术难点<br>腾讯实习的一个core单子是怎么排查的<br>MIT6.824Lab里，如果切片迁移期间程序崩溃会怎么样<br>Lab怎么做的切片分配<br>怎么理解redis所谓的“单线程”<br>Redis作为缓存怎么保证一致性<br>Redis怎么持久化<br>场景题<br>一个超出内存限制的大文件怎么排序<br>了解过mapreduce吗<br>八股<br>介绍下golang的goroutine调度<br>goroutine遇到网络IO等阻塞事件会怎么样<br>介绍下golang的gc机制<br>你说gc需要stw，什么时候会暂停程序</p><h1>百度</h1><h2 id="一面-10">一面</h2><h3 id="题目1-18">题目1</h3><p>1. Redis如何实现高可用</p><p>2. 跳表查找，删除时间复杂度</p><p>3. wal log断电如何解决</p><p>4. wg.Add() 和 wg.Add(1)区别是什么</p><p>5. wg里面，一个协程挂了，如何操作： 捕获panic，recover，发送错误，结束</p><p>6. 线程新建，切换的开销体现在哪里</p><h3 id="题目2-7">题目2</h3><p>反射是啥，那些地方使用了</p><p>equals和==的区别</p><p>重写equals要注意什么</p><p>ThreadLocal、数据结构、内存泄露</p><p>B树和B+有什么区别</p><p>联合索引是什么？什么情况下会失效</p><p>手撕SQL：我记得不难，一个group+order</p><p>线程池参数有哪些？平时怎么使用的？</p><p>线程池的submit和excute有什么区别</p><p>spring声明式事务如何用？什么时候失效？</p><p>死锁是什么？怎么避免</p><p>我们要缓存一个接口的结果，key要有方法名和参数，太大了怎么办</p><p>布隆过滤器是什么，数据结构、原理</p><p>缓存穿透和缓存雪崩</p><p>垃圾回收有哪些方法</p><p>JVM的分代收集介绍一下</p><p>快排的原理？是稳定排序吗？</p><p>git怎么使用？</p><p>Stream会用吗？</p><h3 id="题目3-5">题目3</h3><p>JMM Java内存模型</p><p>mysql 索引 有哪些</p><p>排序算法有哪些</p><p>linux命令 查看进程信息命令，查看端口命令</p><p>你知道哪些设计模式，分别举例说明</p><p>三次握手</p><p>生产者消费者</p><p>垃圾回收算法</p><p>抽象类，接口，普通类的区别</p><p>重载和重写</p><p>生产者消费者的原理和过程</p><h3 id="题目4-5">题目4</h3><p>进程和线程的区别</p><p>进程间的通讯方式</p><p>线程间的通讯方式，多个服务，单服务</p><p>Linux常见命令 ，搜索等</p><p>Linux通讯命令，通讯原理是什么</p><p>tcp三次握手，为什么必须要三次</p><p>hashmap底层原理，有哪些线程安全的map</p><p>答concurrenthashmap，问底层原理，怎么加锁的</p><p>springboot启动注解是什么，内部的四个实际注解讲一下</p><p>MySQL事务，事务特性。</p><p>深挖索引，联合索引，ABC  BC  AC 怎么走索引，索引下推是什么，索引优化查询命令各个字段讲一下</p><p>拷打实习，怎么加的索引，什么情况下索引失效，举例子，做什么业务，代码库是什么，怎么上线打包部署的，全程拷打真实性和个人收获，实习做的东西也都用上了，能和面试官聊起来，感觉加分挺多的。</p><p>做题 一道sql多表联合查询，一道算法</p><h3 id="题目5-4">题目5</h3><p>自我介绍<br>介绍一下实习项目<br>如何使用乐观锁解决超卖问题的<br>乐观锁和悲观锁的区别，介绍一下<br>redis缓存穿透、缓存击穿、缓存雪崩问题及解决方案<br>在高并发场景下设计一个点赞系统<br>使用redis存储点赞数据，数据库怎么存？何时落库，落库的时候是不是也要考虑分批<br>redis数据持久化方式及区别<br>介绍单例模式的两种实现及区别<br>简单工厂模式和工厂方法模式</p><h3 id="题目6-3">题目6</h3><ol><li>自我介绍</li><li>实习拷打</li><li>怎么对mysql进行优化</li><li>怎么对十亿级别的线程和进程数据进行管理</li><li>现在都是分布式系统，怎么保证我们获取的数据是最新的</li></ol><h3 id="题目7-2">题目7</h3><ol><li>自我介绍</li><li>知道这是测开不就投？-知道，不管了</li><li>说一下你实习中的Redis缓存优化怎么做的</li><li>你怎么去测试这个</li><li>订单数据同步说一下</li><li>数据一致性怎么说</li><li>怎么测试，测试有哪些思路</li><li>策略模式取消订单，对于这个功能你会怎么测试</li><li>Redis的数据结构你知道多少，分别对应哪些场景可以使用</li><li>MySQL的事务特性</li><li>MySQL并发事务问题，隔离级别</li><li>做一道算法题–股票的最佳购买时间</li><li>写一个SQL–给定订单表（用户id、订单id、产品id，产品对应金额，购买时间），查询在今天每个用户购买每个产品的金额</li></ol><h3 id="题目8-2">题目8</h3><p>自我介绍</p><p>1.用过哪些有关并发编程以及JUC的组件</p><p>2.用过线程池吗</p><p>3.ThreadLocal的作用 项目中咋用的 不回收的后果</p><p>4.mysql索引数据结构</p><p>5.b+树叶子节点存的什么</p><p>6.回表查询</p><p>7.用过的redis数据结构</p><p>8.zset底层数据结构 除了排行榜其他的使用场景</p><p>9.项目中乐观锁的应用与实现</p><p>10.rabbitmq的消息分发</p><p>11.项目中如何用的rabbitmq</p><p>12.微服务拆分的优点</p><p>13.模板模式的用法与好处 项目中如何用的</p><p>14.用docker部署的步骤</p><h2 id="二面-3">二面</h2><p>你们用dubbo是吧？你知道netty吧？</p><p>接口幂等</p><p>kafka和RocketMQ的区别？</p><p>分布式链路追踪的原理：</p><p>Mybatis的原理、如何和mysq交互的？</p><p>count(*)和count(字段)的区别、效率</p><p>linux信号是什么：我举例kill命令</p><p>kill命令具体是干什么的</p><p>讲解一下这个题目：</p><p>用户在搜索框的时候搜索，会有提示词条，如何实现：我说前缀树等</p><p>反正就一直讨论这个搜索问题</p><h3 id="题目2-8">题目2</h3><p>mq如何防止丢失</p><p>mq如何防止重复消费</p><p>消费端如何保证消息不重复消费</p><p>redis实现分布式锁需要注意哪些？</p><p>redis 会删除错锁吗？</p><p>注解是如何实现的，原理</p><p>反射原理？在什么阶段？</p><p>lombok注解的实现原理？什么机制？在什么时候运行的？</p><p>java 数值上下界的越界，你怎么理解？long类型的上界赋值给int类型，会怎么样？</p><p>你怎么理解幂等？</p><p>你开发了一个接口，如何保证幂等</p><p>数据库的一条数据，多个线程并发修改，用canal如何保证写到es是对的呢？</p><p>加密，签名，摘要分别是什么？使用场景？摘要用的私钥还是公钥验签？</p><h3 id="题目3-6">题目3</h3><p>自我介绍<br>介绍一下最近的项目，做了什么？解决的问题，如何解决的，<br>大模型的上下文长度是有限的，如何解决的<br>大型项目还是会有很多的上下文，这种情况怎么解决<br>可不可以分步骤做？一步一步压缩上下文，<br>MCP了解多少<br>MCP server，client有没有开发过<br>AI还了解多少？还参与过什么ai项目<br>文本相似度怎么计算的？<br>POI搜索是如何实现的，可不可以使用大模型来优化一下<br>可不可以通过意图识别，找相关数据，在数据层面做好<br>计算机网络了解吗？websocket底层是怎么做的<br>广播和单播分别指什么<br>设计一个生产者消费者模型，生产者生产不同类型的消息，消费者消费自己订阅的类型的消息</p><h1>快手</h1><h2 id="一面-11">一面</h2><h3 id="题目1-19">题目1</h3><p>消息队列如何实现功能解耦和压力分散？</p><p>延迟队列是如何处理未完成任务的？</p><p>整个流程的QPS或容量预估是多少？是否有进行性能测试？</p><p>缓存与数据库的一致性如何保证（同步策略、定时任务间隔等）</p><p>JVM垃圾回收 简述JVM的垃圾回收机制（分代回收、可达性分析）？</p><p>有哪些垃圾回收算法（标记清除、标记整理等）？</p><p>不同垃圾回收器（如CMS、G1）的特点和区别？</p><p>多线程与锁 synchronized和volatile的区别？</p><p>ReentrantLock的公平锁与非公平锁实现原理？</p><p>CAS机制在锁中的应用？</p><p>集合框架 HashMap和ConcurrentHashMap的区别？</p><p>ConcurrentHashMap的分段锁机制（JDK 1.8前后变化）？</p><p>MySQL MySQL索引的底层数据结构（B+树 vs B树）？为什么选择B+树？</p><p>默认的事务隔离级别是什么？如何解决幻读问题（间隙锁）？</p><p>Redis Redis为什么比数据库快（内存操作、IO多路复用）？</p><p>Redis高可用方案（集群、哨兵模式）？</p><p>数据分片（Sharding）如何实现？节点间如何通信？</p><p>操作系统/网络</p><p>HTTP请求处理流程 从客户端发起HTTP请求到服务端响应的完整过程（DNS解析、TCP连接、报文拆解等）？</p><p>服务端架构中如何接收和处理请求（Web容器、业务逻辑分层）？</p><p>消息队列</p><p>RabbitMQ vs Kafka 为什么选择RabbitMQ而不是Kafka？两者在高并发场景下的差异？</p><h3 id="题目2-9">题目2</h3><p>1、Kafka，raft一致性协议，选举过程；</p><p>2、慢sql优化方式；</p><p>3、mysql的bufferpoll；</p><p>4、优化器按照什么指标决定走不走索引；</p><p>5、你怎么去解决深分页，其实这个感觉无法避免回表的，只是回表数据大小的问题(回id肯定比回整行数据拷贝开销低)，业务性避免吧；</p><h3 id="题目3-7">题目3</h3><p>1. 介绍仿大众点评项目的主要模块。</p><p>2. 项目难点。</p><p>3. 用户登录模块中，Redis 缓存是同步过程还是异步过程，同步过程会有什么问题，用户量大时发得慢该怎么办。</p><p>4. 若用消息队列存储验证码相关信息，消息队列的架构是什么，出现消息堆积该怎么办。</p><p>5. 增加消费者数量能否随意增加，有什么其他考虑。</p><p>6. 双重拦截器的作用，是否能在一个拦截器中实现相关逻辑，双重拦截器有什么好处。</p><p>7. 优惠券秒杀中，扣减的是数据库还是 Redis 中的数据，扣减后使用分布式锁和写入消息队列的顺序是怎样的。</p><p>8. 若写入数据库时发生异常，Redis 中已扣减的数据是否需要恢复，如何恢复，恢复操作是否会对线上产生影响。</p><p>9. 为什么在优惠券秒杀中使用 Lua 脚本，不能用 Redis 的其他数据类型（如 increment 或 decrement 计数器）的原因。</p><p>10. 预检信息包含哪些操作，能否在外部完成。</p><p>11. 若不在 Lua 脚本中实现预检资格、查询是否一人一单和扣减库存等操作，而在代码中实现，会有什么问题。</p><p>12. 一人一单的限制能否保证，若快速点击或用脚本点击两次，是否会突破限制。</p><p>13. 一人一单的限制应该在哪个环节实现。</p><p>14. 写入消息队列之前应该完成哪些操作。</p><p>15. 讲解 JVM 的相关知识，包括类加载器、运行时数据区、执行引擎等。</p><p>16. 垃圾回收算法在年轻代或老年代是如何应用的，年轻代的结构是怎样的。</p><p>17. 对 AI 有哪些了解，如何使用大模型。</p><h3 id="题目4-6">题目4</h3><p>Java的锁介绍一下</p><p>aqs原理</p><p>有哪些锁用到了aqs</p><p>cms和g1垃圾回收器有什么区别</p><p>有进行过jvm调参嘛？为什么要进行这样的调参</p><p>介绍一下spring boot的启动过程（完全不知道啊）</p><p>tcp粘包说一下，如何解决？</p><p>tcp4次挥手</p><p>数据处理</p><p>有100亿个url，怎么找到相同的url</p><h3 id="题目5-5">题目5</h3><p>1、kafka和rabbitmq 相比有哪些优缺点<br>2、kafka的延迟情况和数据丢失情况 应该怎么查看<br>3、redis的hash数据结构是什么样的？那么使用String和使用Hash的区别是什么呢？他们各自的优缺点是什么呢？<br>4、redis的缓存穿透、击穿、雪崩是什么问题，如何解决？<br>5、redis 缓存一致性，如何在大量数据的情况下做一致性处理？<br>6、CompletableFuture的底层原理（还是有点不太熟悉）<br>7、CompletableFuture内存泄漏的问题（这一块 又吃了没看源码的亏）<br>8、ThreadLocal的内存泄漏的问题<br>9、mysql的持久性是如何实现的<br>10、mysql中undolog redolog中的区别有哪些<br>11、常见的OOM情况，如何解决（这里说的是读取大量Excel数据的情况）</p><h3 id="题目6-4">题目6</h3><p>JAVA</p><p>1、反射的原理，应用场景，哪些场景不能使用反射？自定义一个注解需要定义哪些方面的信息</p><p>2、线程的生命周期，各个状态之间的转变通过哪些语句？保证线程安全的方式及优缺点？ThreadLocal会导致什么问题？</p><p>3、JAVA中的锁有几种方式？同步锁原理及申请流程、可重入锁原理及申请流程</p><p>4、MYSQL事务的隔离级别，分别会导致什么问题？如何在MYSQL中查询隔离级别</p><p>5、MYSQL主从同步机制</p><p>6、Redis持久化机制、AOF文件重写、Redis宕机重启后，什么机制保证其快速恢复？</p><p>SPRING</p><p>1、IOC、AOP、bean的实例化流程。IOC中如何解决循环依赖</p><p>1、使用过什么消息队列？怎么确保一个消息发送成功？</p><p>2、介绍实习项目的背景、技术架构、负责的内容。使用了哪些中间件？</p><p>3、怎么使用分布式锁？怎么设置锁的key，拿锁成功和拿锁失败对于下游业务的影响，怎么保证幂等性</p><p>4、怎么设置限流参数，阈值等？</p><p>5、在项目中做了什么优化手段，最终拿到了什么结果？</p><h3 id="题目7-3">题目7</h3><p>mysql索引结构，b+树查询的时间复杂度，建立索引的原则？<br>什么是AOP？什么是动态代理？<br>什么是注解？注解是怎么起作用的？<br>什么是反射？什么时候会用到反射？<br>java的内存模型是什么样的？栈是用来干什么的？<br>什么是设计模式？你了解哪些？<br>实现单例模式的时候有什么需要注意的？为什么要做双重校验？什么时候会用到单例模式？</p><h3 id="题目8-3">题目8</h3><p>1、自我介绍</p><p>2、项目一拷打（10min）</p><p>3、Java中线程池任务提交的流程是怎样的？</p><p>4、线程池的拒绝策略有哪些？</p><p>5、提交到任务队列的任务，它的消费策略是怎样的？</p><p>6、如果是无界队列，还需要非核心线程吗？</p><p>7、无界队列存在什么问题？一般在什么场景下使用无界队列？</p><p>8、谈谈 Java 里面锁消除和锁升级</p><p>9、synchronized 可重入吗？能保证可见性吗？</p><p>10、某个服务 CPU 利用率到 100% 了，如何排查？</p><p>11、如果是 OOM 了怎么排查？</p><p>12、自己有用过 jmap 和一些工具去排查过错误吗？</p><p>13、MySQL 有几种事务隔离级别？从低到高说</p><p>14、什么是幻读？</p><p>15、MySQL 是怎么去解决幻读问题的？</p><p>16、谈谈 Kafka</p><p>17、为什么项目中技术选型用的是 RabbitMQ？</p><p>18、RabbitMQ 的数据持久化是怎么做的？</p><p>19、线程和进程的区别？</p><p>20、线程的安全怎么保证？</p><p>21、进程通信的方式有哪些？</p><p>22、进程间通信，它的数据传输大概是怎样的流程？怎么能让数据从一个进程传递到另一个进程去？</p><p>23、Redis 常用的数据结构有哪些？</p><p>24、谈谈 ZSet 的具体实现？为什么数据规模大的时候采用跳表而不是压缩列表？</p><p>25、查一个有序集合里面元素的个数，复杂度是多少？命令是什么？</p><p>26、取有序集合某个元素的分数，命令是什么？复杂度是多少？</p><h2 id="二面-4">二面</h2><h3 id="题目1-20">题目1</h3><p>1. 介绍仿大众点评项目的详细内容，包括学到的东西、难点、重点。</p><p>2. 详细描述一次C端用户登录行为在系统背后的完整数据链路，每一步系统要做什么、存储在什么地方。</p><p>3. 验证码存储在Redis中的key是什么。</p><p>4. 用户再次登录时，前端是否做防刷或重复登录验证，还是依赖短信验证码。</p><p>5. 验证码发送在系统后台的操作流程。</p><p>6. 用户登录态如何维持。</p><p>7. 为什么要返回TOKEN，能否返回手机号。</p><p>8. TOKEN在浏览器端存储在什么地方。</p><p>9. 将TOKEN存到authorization字段的原因。</p><p>10. authorization是header还是body字段。</p><p>11. 双重拦截器拦截的内容，以及从什么地方取TOKEN。</p><p>12. 从Redis中取TOKEN的key是什么。</p><p>13. ThreadLocal中存储的是什么。</p><p>14. ThreadLocal的定义是什么。</p><p>15. ThreadLocal的生命周期是什么。</p><p>16. 用户发起HTTP请求时线程是创建还是复用。</p><p>17. 在post handler中remove ThreadLocal的原因。</p><p>18. 已登录用户后续操作是否需要更新ThreadLocal。</p><p>19. 拦截器拦截的请求类型及作用。</p><p>20. 分布式系统中，用户请求路由到不同机器时是否需要重新登录。</p><p>21. ThreadLocal存在的必要性，能否用其他东西替代。</p><p>22. ThreadLocal的优点是什么。</p><p>23. ThreadLocal设置的生命周期或服务的生命周期是什么。</p><p>24. postHandler的调用时机。</p><p>25. 声明线程的方法有哪些。</p><p>26. 线程池的核心参数及各自作用。</p><p>27. 等待队列是否越长越好。</p><p>28. MySQL事务的隔离级别及各自举例。</p><p>29. Redis的数据结构及各自特性和适用场景。</p><p>30. 最近在学习的内容及大模型相关学习情况。</p><h2 id="三面-2">三面</h2><h3 id="题目1-21">题目1</h3><p>索引构建有什么用，底层是怎么做的</p><p>httpclient 如何设置连接池，设置参数后 httpclient 底层是怎么做的，用了什么数据结构</p><p>为什么操作系统需要虚拟内存，一个 32 位系统里有物理内存 2G，对应的虚拟内存应该有多大？为什么一共就 2G 物理内存，通过虚拟内存技术之后，可以给应用程序提供 4G 内存，多出来的 2G 哪里来的，</p><p>假设要写一个网络爬虫，这个爬虫里面有一个功能，想快速的判断一个 URL 地址它之前有没有被爬过。用什么样的数据结构会比较合适？</p><h1>拼多多</h1><h2 id="一面-12">一面</h2><h3 id="题目1-22">题目1</h3><p>一、Java基础与JVM（6题）</p><p>HashMap扩容时链表转红黑树的阈值为什么是8？退化为6的原因？</p><p>synchronized锁升级过程？</p><p>G1垃圾回收器如何预测停顿时间？Region大小如何设置？</p><p>volatile能否保证数组元素的可见性？如何解决？</p><p>ThreadLocal内存泄漏的根本原因？JDK改进方案？</p><p>Java 8中Stream的并行处理原理？ForkJoinPool工作窃取机制？</p><p>二、并发编程（5题）</p><p>AQS中为什么用CLH队列而不用普通链表？</p><p>线程池核心参数设置规则？美团动态调整方案？</p><p>ConcurrentHashMap的size()方法为何不精确？替代方案？</p><p>如何用CAS实现一个无锁栈？ABA问题如何规避？</p><p>CompletableFuture如何实现多个异步任务依赖执行？</p><p>三、数据库与Redis</p><p>MySQL索引失效的10种场景？最左前缀原则的底层原理？</p><p>十亿级订单表如何优化分页查询？</p><p>Redis大Key删除导致集群崩溃，如何避免？</p><p>Redis事务与MySQL事务的ACID区别？</p><p>缓存与数据库一致性方案对比？拼多多秒杀采用哪种？</p><p>Redis Cluster的slot迁移过程会阻塞请求吗？</p><p>MySQL死锁排查步骤？如何用gap锁解决幻读？</p><p>四、分布式与微服务（6题）</p><p>TCC事务的Confirm阶段失败怎么办？</p><p>如何设计一个支撑百万QPS的分布式ID生成器？</p><p>Nacos如何实现配置动态推送？长轮询原理？</p><p>RocketMQ如何保证消息不丢失？</p><p>Dubbo的泛化调用使用场景？如何实现服务降级？</p><p>CAP理论在拼多多购物车中的取舍？</p><p>五、系统设计（4题）</p><p>设计拼多多砍价系统，如何防止刷单？</p><p>订单超时未支付自动关闭，如何实现？</p><p>如何设计一个实时热卖排行榜？</p><p>分布式锁在库存扣减中的应用，Redisson实现原理？</p><h3 id="题目2-10">题目2</h3><p>\1. 自我介绍<br>\2. 实习亮点<br>\3. Java线程池类型，应用场景<br>\4. 线程池怎么进行线程回收的<br>\5. 为什么要用线程池<br>\6. 说说RPC是什么<br>\7. 设计RPC框架有哪些要点<br>\8. 常用的序列化方式<br>\9. 为什么要进行序列化<br>\10. 写题：二叉树后序遍历（非递归）<br>\11. List<Integer> list = new ArrayList&lt;&gt;()发生了哪些内存分配<br>\12. 操作系统是怎么进行递归的<br>\13. 为什么要有多态<br>\14. 多态父类表现出子类的行为，运行时是如何实现的呢<br>\15. Java泛型是怎么实现的<br>\16. Java为什么要用泛型擦除，为什么不像c++一样<br>\17. <code>sout( &quot;Hello World!”)</code> 运行过程。字符串是怎么打印到屏幕上的<br>\18. 为什么要有内核态<br>\19. 从操作系统层面分析<code>java -jar xxx.jar</code> 是怎么运行的，在操作系统层面的可执行文件是什么<br>\20. Java和JVM的关系<br>\21. Java和Python有什么区别（答了JIT）<br>\22. 算法：找到一个具有最大和的连续子数组<br>\23. 介绍一下AOP<br>\24. 怎么指定AOP生效的地方<br>\25. Java中注解是怎么生效的<br>\26. 谁去扫描注解的<br>\27. 介绍一下IOC<br>\28. 介绍一下MQ<br>\29. MQ有什么特性</p><h1>京东</h1><h2 id="一面-13">一面</h2><h3 id="题目1-23">题目1</h3><p>1.项目介绍</p><p>2.spingboot做了什么事情</p><p>3.sql怎么优化，mysql怎么优化</p><p>4.bean注入有哪些方式</p><p>5.auto wire注解的原理，spring怎么做到加载有这个注解的对象</p><p>6.mybatis能不能直接new一个dao 接口的对象，怎么做？拦截器功能原理，使用场景</p><p>7.接口性能问题怎么看，怎么分析哪个阶段有问题</p><p>8.mysql的三种日志介绍一下</p><p>9.发生宕机redolog和binlog怎么协调作用的</p><p>10.宕机后怎么恢复数据，一条数据怎么确定回滚还是恢复</p><p>11.生产问题定位，平时怎么做的</p><p>12.线程池执行过程</p><p>13.g1回收器跟cms 相比，各自适合什么场景</p><p>14.使用的什么检验的框架，原理是什么</p><p>15.mysql索引为什么快</p><h3 id="题目2-11">题目2</h3><p>做项目遇到的问题和解决方法</p><p>有没有用到多线程的东西，ThreadLocal</p><p>线程池参数怎么设置的</p><p>如何保证线程安全</p><p>synchronized 和 ReentrantLock 区别</p><p>Java 并发类有哪些</p><p>ConcurrentHashMap原理</p><p>redis 常用数据结构及底层实现</p><p>zset 跳表</p><p>缓存击穿、穿透、雪崩</p><p>击穿、穿透区别在哪</p><h3 id="题目3-8">题目3</h3><p>1、自我介绍+实习项目</p><p>2、Spring AOP原理是什么，Java的反射和代理有哪几种</p><p>3、BeanFactory和FactoryBean的区别是什么</p><p>4、ES的倒排索引是如何实现的</p><p>5、除了简历上的项目，还有其他项目可以介绍一下吗？</p><p>6、Mysql的间隙锁是什么</p><p>7、了解哈希索引吗？为什么innoDB不采用哈希索引</p><p>8、了解哈希冲突吗？ 处理哈希冲突的方法有哪些？</p><p>9、 为什么HashMap 不采用ThreadLocalMap解决哈希冲突的方法（开放寻址法）</p><p>10、如果要想实现可以按put的顺序遍历HashMap，要怎么实现呢？那如果要想改变其中的顺序呢？</p><p>11、 java的可重入锁是如何实现的？</p><p>12、 如果想实现可重入的分布式锁要如何实现呢？</p><p>13、对于树的三种遍历方式，分别有什么用途？</p><p>14、了解JVM的内存模型，大概介绍一下？</p><p>15、实例对象都是在堆上分配吗？（我提到了可以在栈上分配）</p><p>16、那有哪些对象是可以直接在栈上分配呢？—</p><h3 id="题目4-7">题目4</h3><p>1、自我介绍</p><p>2、电脑上有没有生产环境</p><p>3、项目的难点和解决思路以及你的收获</p><p>4、ES的原理（这个没有很理解问的意思</p><p>5、分布式锁、redisson的实现</p><p>6、Redis数据结构</p><p>7、JUC的syn和可重入锁</p><p>8、JVM+GC</p><p>9、MySQL的使用场景，MySQL的使用经验，</p><p>10、聚集索引和非聚集索引</p><p>11、B+树</p><p>12、事务ACID和隔离级别</p><p>13、乐观锁、悲观锁</p><p>14、为什么有spring，springboot的优势，用了spring全家桶的哪些</p><p>15、spring的AOP、spring其他的设计模式</p><h3 id="题目5-6">题目5</h3><p>查一张学生表，表里有学生名字，如何查出学生名字中哪些是重复的？<br>缓存的过期策略有哪些？<br>后端一直更新数据，前端一直查缓存，在更新的间隙，缓存是空的，导致缓存穿透，怎么解决？<br>有没有别的思路可以解？比如通过全局的乐观锁？<br>创建多线程会用哪些方法创建？<br>了解completable future 吗？</p><h3 id="题目6-5">题目6</h3><ol><li>面试官介绍了下岗位</li><li>自我介绍</li><li>现在实习的地方，有留用机会吗？</li><li>拷打项目一（10分钟）</li><li>本科不是计算机，怎么跨考上的？当时怎么准备的？</li><li>考研学专业课时，碰到过什么困难吗？怎么解决的？</li><li>用户登录为啥用 Spring Session 来管状态？它内部是怎么跑的？</li><li>密码用 MD5+盐值 来校验，有啥风险吗？</li><li>现在让你重新设计密码加密存储，你会怎么做？</li><li>数据万象服务是干嘛的？项目里怎么用的？</li><li>如果要实现图片搜索，比如搜“小狗”，就能找出所有带小狗的图片，你会怎么设计？</li><li>什么场景下需要用多级缓存？</li><li>怎么保证多级缓存和数据库的一致性？项目里是怎么做的？</li><li>用 WebSocket 做多人协作编辑，假如有 100 个人同时改一张图，怎么设计才能避免操作互相覆盖？</li><li>你提到加锁，具体怎么加？用 Redis 还是别的？锁什么？锁的粒度多大？</li><li>加锁会让其他用户干等着，没法操作，这块怎么优化？</li><li>平时除了项目，还学了啥新技术吗？</li><li>你觉得用什么锁来控制虚拟线程比较好？</li><li>最近一年用过哪些 AI 编程工具？</li><li>看你一直在一个地方生活学习，以后想去哪工作？</li></ol><h3 id="题目7-4">题目7</h3><p>. 实习期间学到了什么，结合项目介绍一下<br>\2. mysql和redis的一致性如何做<br>\3. 如果不订阅binlog，还能保证一致性吗？<br>\4. 什么场景会出现数据库和缓存不一致<br>\5. zset的底层是怎样的<br>\6. 跳表为什么快<br>\7. redis原生的锁是用什么命令，流程是怎样的，如何释放锁，里面参数都是什么<br>\8. 什么时候会出现当前线程的锁被其他线程解锁？ （不会）<br>\9. redis持久化<br>\10. 需要实现百万qps的系统，功能是实时排行榜，查询量很大，实时更新，可以理解为微博排行榜，怎么实现？<br>\11. DDD架构讲解一下<br>\12. kafka的topic和partition的关系<br>\13. partition越多越好吗<br>\14. 想实现顺序的消费，生产者发出来的消息是顺序的，一个partition，多个消费者，怎么实现？<br>\15. kafka怎么保证消息不丢失？<br>\16. 如何解决java浮点数丢失的问题<br>\17. 多线程的场景题：主线程执行到一半的是要开始10个子线程，子线程执行完之后主线程在执行，怎么实现<br>\18. completableFuture的实现原理<br>\19. countdownlatch的原理<br>\20. 自己实现一个线程安全的计数器，怎么实现？<br>\21. 场景题：电商大促，负责秒杀，通过线程池实现，怎么设置核心参数<br>\22. 实现功能：写个sql，给一张订单表，至少有订单id，userId，createTime，筛选出昨天下单的用户是近一年第一次下单的用户，怎么实现<br>\23. 索引相关，联合索引A，B，C，where a &gt; ? and b = ? c != ?，怎么走</p><h1>虾皮</h1><h2 id="一面-14">一面</h2><h3 id="题目1-24">题目1</h3><p>2. 讲一下xxl-job的架构与实现原理(实习有xxljob)</p><p>3. xxl-job怎么保证每一个实例的任务只调用一次</p><p>4. 算法题:用栈实现队列，说思路</p><p>思路:用两个栈，判断第一个栈是否为空，为空将第一个栈的所有元素转移到第二个栈，否则弹出最上层的元素</p><p>5. 算法题:一篇文章找出使用频率最高的k个单词</p><p>思路:使用一个HashMap存储每个单词出现的频率，转换成结构体，然后再建堆，再堆排序</p><p>6. topk拓展:建堆的时间复杂度是多少？</p><p>7. topk拓展:堆排序的时间复杂度是多少?</p><p>8. topk拓展:你这样不会有点慢嘛，还有更优解嘛？</p><p>9. 数组和链表在数据结构上的区别是什么？</p><p>10. 数组和链表的使用场景有什么区别？</p><p>11. 了解哪些MySQL存储引擎</p><p>12. InnoDB引擎有什么特性</p><p>13. 索引是数据结构是什么，有什么特点？</p><p>14. MySQL有哪些锁</p><p>15. MySQL的事务四大特性是什么</p><p>16. MySQL的隔离级别是有哪些</p><p>17. MySQL默认隔离级别是？</p><p>18. RR和RC的区别是什么？</p><p>19. 可重复读什么时候能解决幻读，什么时候不能？</p><p>20. TCP协议怎么保证可靠性？ 三次握手四次挥手、流量控制、拥塞控制</p><p>21. 讲讲流量控制怎么做的</p><p>22. 拥塞控制算法有哪些？</p><p>23. TCP粘包是什么</p><p>24. 怎么解决TCP粘包？</p><p>25. 如果我的TCP里面就有换行符该怎么解决</p><p>26. 进程之间的通信机制有哪些</p><p>27. 进程、线程、协程之间的区别</p><p>28. 线程有独立的内存空间嘛？</p><p>29. Redis有哪些数据结构</p><p>30. ZSet的底层实现是什么数据结构</p><p>31. 跳表的实现原理是什么？</p><p>32. 跳表插入一条数据的具体实现是什么</p><h3 id="题目2-12">题目2</h3><p>1. java的内存模型</p><p>2. 数据库优化，sql优化</p><p>3. 消息队列有什么作用，kafka在项目中有什么作用</p><p>4. 2个topic， 一个group消费者组，一个topic 异常rebalance， 另一个会受影响吗？</p><p>5. 讲一下mysql的redo log、binlog、undo log，</p><p>6. mysql崩溃以后恢复流程？mysql崩溃之后未提交的事务怎么办？</p><p>7. B+数主键索引和非主键区别</p><p>8. inplace DDL(不会)</p><p>9. RPC框架中，怎么做链路追踪</p><p>10. 网页中输入网址的流程变化</p><p>11. tcp与udp区别</p><p>12. go 的协程和java的线程区别</p><p>13. go多协程和java多线程 同时读写，共享资源 处理 方式一样吗</p><p>14. java 的线程与内核线程， go的协程与线程的 映射方式一样吗？（1:1，n:m）</p><h3 id="题目3-9">题目3</h3><p>1.可以讲讲用户从发送请求url之后会发生什么吗 ✘</p><p>介绍了一下SpringMVC的流程，从url到DispatcherServlet再到各个处理器部件等</p><p>实际上面试官是想问从网络通信层面上它们发生了什么</p><p>回复不太清楚，只介绍了一下域名通过DNS解析成IP然后请求到后端服务器</p><p>2.了解cookie和session吗 ✘</p><p>答的很不好，因为自己只学了JWT和token完全没想到会问这块，只答出前者存储在客户端后者存储在服务端</p><p>3.了解MySQL中的事务隔离级别吗，它们分别解决哪些问题，具体讲 ✔</p><p>4.学过哪些排序算法？✔</p><p>冒泡，二分，快排</p><p>5.MySQL中索引的数据结构？讲讲优势和为什么✔</p><p>6.Redis常见架构✔</p><p>7.了解正排索引和倒排索引吗✘</p><p>答不太清楚只知道es库中通过倒排索引建表实现较高的搜索效率</p><p>8.手撕，反转链表✔</p><p>9.延迟队列是什么，了解底层实现吗✘</p><p>回答了xdelayed延迟队列的基本应用场景和概念，底层实现不知道</p><p>10.AMQP中消息可靠性原理✔</p><p>11.你项目中的推荐功能是怎么实现的</p><p>简单讲了一下调用了分词器和向量模型的API将库中视频基于标题分到我给出的聚类中</p><h3 id="题目4-8">题目4</h3><p>1. 自我介绍<br>2. 你常用哪个 JDK 版本？<br>3. 选一个你熟悉的项目，说说它配了什么垃圾回收器？<br>4. 描述一下 CMS 的回收流程及每个阶段的作用。<br>5. CMS 有哪些阶段会 Stop-The-World？<br>6. 新生代和老年代的划分机制是什么？<br>7. 对象从新生代晋升到老年代的条件有哪些？<br>8. 说说 AOP 的最基本实现方式。<br>9. Spring AOP 生成代理的两种场景/方式分别是什么？<br>10. 你在项目里用过微服务吗？用的什么技术栈？<br>11. 有做过哪些 MySQL 调优？举一个具体例子。<br>12. 当时如何定位到这条慢 SQL？用了哪些工具或命令？<br>13. 解释 Explain 结果中哪些字段说明索引未生效。<br>14. Redis 持久化有哪些可选策略？<br>15. RDB 与 AOF 各自有哪些刷盘/触发方式？<br>16. 如果要求“不丢数据”或“高性能”分别怎样配置？<br>17. TCP 四次挥手中 TIME_WAIT 状态的含义是什么？<br>18. 为什么需要等待 2MSL 才能进入 CLOSED？<br>19. 你在项目里用过 CompletableFuture 吗？<br>20. 它与 Future / Task 组合相比有什么优势？<br>21. 如果异步链路里包含数据库事务，事务回滚会不会有问题？为什么？<br>22. 线上 Linux 服务器常用命令熟悉吗？<br>23. 如何在文件里查找关键字？<br>24. 如何查找某个文件？</p><h3 id="题目5-7">题目5</h3><p>上来先写两句SQL</p><p>给了一个学生表</p><p>1.两个字段不重复，重复的话就无法插入，建立合适的索引</p><p>2.获取表中录取学生人数第二多的公司，要求公司录取学生的人数至少大于3</p><p>表设计的一些考量、索引建立的一些考量</p><p>sql优化在工作中遇到的一些实例。</p><p>一道题：</p><p>尽快实现亿级别数据的求和。</p><p>八股：</p><p>redis为什么快？</p><p>Java的一些设计原则</p><h3 id="题目6-6">题目6</h3><p>消息队列如何实现功能解耦和压力分散？</p><p>延迟队列是如何处理未完成任务的？</p><p>整个流程的QPS或容量预估是多少？是否有进行性能测试？</p><p>缓存与数据库的一致性如何保证（同步策略、定时任务间隔等）</p><p>​</p><p>JVM垃圾回收 简述JVM的垃圾回收机制（分代回收、可达性分析）？</p><p>有哪些垃圾回收算法（标记清除、标记整理等）？</p><p>不同垃圾回收器（如CMS、G1）的特点和区别？</p><p>多线程与锁 synchronized和volatile的区别？</p><p>ReentrantLock的公平锁与非公平锁实现原理？</p><p>CAS机制在锁中的应用？</p><p>集合框架 HashMap和ConcurrentHashMap的区别？</p><p>ConcurrentHashMap的分段锁机制（JDK 1.8前后变化）？</p><p>​</p><p>MySQL MySQL索引的底层数据结构（B+树 vs B树）？为什么选择B+树？</p><p>默认的事务隔离级别是什么？如何解决幻读问题（间隙锁）？</p><p>Redis Redis为什么比数据库快（内存操作、IO多路复用）？</p><p>Redis高可用方案（集群、哨兵模式）？</p><p>数据分片（Sharding）如何实现？节点间如何通信？</p><p>操作系统/网络</p><p>HTTP请求处理流程 从客户端发起HTTP请求到服务端响应的完整过程（DNS解析、TCP连接、报文拆解等）？</p><p>服务端架构中如何接收和处理请求（Web容器、业务逻辑分层）？</p><p>消息队列</p><p>RabbitMQ vs Kafka 为什么选择RabbitMQ而不是Kafka？两者在高并发场景下的差异？</p><p>​</p><h2 id="二面-5">二面</h2><h3 id="题目1-25">题目1</h3><p>1. 自我介绍</p><p>2. 优惠券平台项目是怎么做的</p><p>3. 牛券项目拷打:秒杀是怎么做的？</p><p>4. 秒杀接口如果Redis都扛不住了怎么办  限流</p><p>5. 怎么限流？ Sentinel或者使用Redis</p><p>6. 讲讲这两种限流是怎么实现的</p><p>7. Sentinel限流是全局维度还是单机的</p><p>8. Sentinel限流的原理是什么</p><p>9. 优惠券平台优惠券分发过程是怎么样的</p><p>10. 实习中主要做了哪些工作</p><p>11. 实习中遇到哪些技术难点</p><p>12. 实习还有什么收获</p><p>13. 讲讲对MySQL分库分表的理解  讲了为啥要分表、为啥要分库、垂直分和水平分等等</p><p>14. 垂直分表主要是解决什么问题？为什么要进行垂直分表</p><p>15. 为什么一张表有好几个字段要垂直分表呢，除了业务上的解耦？</p><p>16. 水平分表主要是解决什么问题？为啥要进行水平分表</p><p>17. 水平分表有哪些方式</p><p>18. 哈希法和范围法的优劣</p><p>19. 如果对优惠券表进行分库分表，用户要查询自己的订单，怎么办</p><p>题目2</p><p>定量的分析我的项目系统的极限处理能力（没弄过，根本不会）。我说没弄过不知道，又问现在就是要分析它的承受能力，你应该怎么做（还是不会…）</p><p>3.项目组件选型考量，用了哪些东西为什么要用这些（最后焦点放在消息队列的选型上，问rocketmq和kafka相较RocketMQ有什么优点，这些优点底层怎么实现的）</p><p>4.Redis缓存穿透（缓存空对象+布隆过滤器，还有没有优化手段（不知道…））</p><p>5.Redis持久化（设计一套兼顾AOF完整和RDB快的持久化方案）</p><p>6.Java垃圾回收机制</p><h1>字节</h1><h2 id="一面-15">一面</h2><h3 id="题目1-26">题目1</h3><p>3. redis相关</p><p>3.1 redis有什么数据结构</p><p>3.2 GEO的原理</p><p>3.3 排行榜用什么数据结构</p><p>3.4 朋友圈共同好友用什么数据结构</p><p>3.5 实现数字的原子+1用什么方式</p><p>4. mysql相关</p><p>4.1 mysql有哪些锁</p><p>4.2 分布式锁还有哪些实现方案</p><p>4.3 很多多余的索引有什么缺点</p><p>4.4 怎么利用索引做查询优化</p><p>4.5 大表统计多少条数据行满足筛选条件怎么优化</p><p>4.6 亿级数据大表怎么做查询优化</p><p>4.7 分表要怎么做</p><p>4.8 分区表有听说过吗</p><p>5. ThreadLocal是什么，内存泄漏是怎么回事</p><p>6. 并发访问资源怎么防止冲突</p><p>7. 场景题：一个守护进程负责对工作进程重启，但是现在工作进程一直没拉起来，怎么去定位问题</p><h3 id="题目2-13">题目2</h3><p>进程间的通信方式</p><p>http属于哪一层分层模型：应用层</p><p>访问网页的全过程</p><p>丢包、粘包问题</p><p>创建子进程的方法：fork</p><p>PgSQL和MySQL的区别，选型时的考虑</p><p>建立索引选择字段的原则，最左匹配原则的底层原理是什么</p><p>数据库范式</p><p>Zset的底层原理，查询和增删改的时间复杂度</p><h3 id="题目3-10">题目3</h3><ul><li>预计能实习多久？</li><li>能简单介绍一下实习期间做了什么吗？</li><li>能介绍一下什么是 Websocket 吗？</li><li>Websocket 和 SOCKET 有什么区别？</li><li>Websocket 怎么保证连接是保活的？</li><li>你了解大模型的一些相关的技术概念吗？</li><li>实习项目中除了聊过的内容，还有什么比较有技术深度或挑战性的事吗？</li><li>刚才提到的选择算法（雪花算法）有哪些潜在的问题？</li><li>雪花算法的时钟回拨问题怎么解决？</li><li>能介绍一下项目解决什么问题，或者主要有哪些产品功能吗？</li><li>秒杀模块遇到的核心问题是什么？</li><li>用 Redis 扣减库存时，怎么保证 Redis 和 MySQL 数据一致性？</li><li>Redis 库存数量是什么时候初始化的？</li><li>一道字节的算法题：小于n的最大数（网上能搜到原题）</li><li>先讲思路再写代码，面试官对思路里面有问题的地方会做一些提示</li><li>Redis 是单线程的，单线程会引入什么问题吗？</li><li>MySQL 的 Innodb 存储引擎默认的事务隔离级别是什么？</li><li>Innodb 的默认事务隔离级别能解决幻读问题吗？</li><li>你还在面试其他的实习吗？</li><li>有拿到 offer 吗？</li><li>如果通过面试，你最早什么时候能来实习？</li></ul><h3 id="题目4-9">题目4</h3><p>1. 麻烦你先简单自我介绍一下。</p><p>2. 这个搜索优化里边你做了什么工作？有什么结果？</p><p>3. 机票场景我理解可能有很多这种目的地、价格这种不同的因素，尤其是价格非常敏感，那这个缓存会缓存价格吗？</p><p>4. 那如果你的9天拉到30天，会不会缓存命中率的确提高了，会不会造成后续到下单环节实际库存不匹配？</p><p>5. 影响多大？</p><p>6. 我们扩展一下，假如说你的最终下单环节没有这个下单环节在，实际查询服务商的价格给你兜底了，你的缓存需要精准，怎么做？</p><p>7. 你刚提到这个主动缓存，这个“主动”怎么理解？</p><p>8. 你能描述一下一个简单的搜索系统主要包含哪些环节吗？</p><p>9. 就比如说召回、快速分析、召回、精排这些。</p><p>10. 你刚提到多个供应商的同一个航班线的这种合并会比较耗时，为什么它耗时？</p><p>11. merge为什么耗时？</p><p>12. 那就必须得等最慢的规则才能返回吗？</p><p>13. 那进一步的能不能回来一个就处理一个？</p><p>14. 耗时和CPU哪个更重要？</p><p>15. 你们线上CPU利用率是多少？</p><p>16. 这个 MCP 项目的难点在哪？</p><p>17. 动态工具加载和自动注册在 MyBatis-Plus 里底层是怎么实现 MCP 服务动态注册和热更新的？</p><p>18. 你这边主要熟悉的开发语言是什么？</p><p>19. synchronized 的底层原理是什么？</p><p>20. synchronized 是可重入的吗？</p><p>21. 什么叫可重入？</p><p>22. 它是怎么实现可重入的？</p><p>23. 关于线程池：核心线程数10，最大线程数20，任务队列容量100，不断提交任务时，线程和队列状态会怎样变化？</p><p>24. Redis 里 zset 是怎么实现的？</p><p>25. 压缩列表和跳表什么时候用压缩列表，什么时候用跳表？</p><p>26. 跳表的结构是怎么样的？</p><p>27. MySQL 查询：成绩表中分数在80到90之间，排名前五的学生姓名及分数，SQL 怎么写？</p><p>28. 操作系统中线程和进程的区别？</p><p>29. 在 Linux 系统上，怎么查当前系统负载较高的进程及其实时负载？</p><p>30. 定位某个 Java 业务进程 CPU 很高，该怎么进一步定位问题？</p><p>31. 大模型里“温度”参数的作用是什么？</p><p>32. MCP 和 Function Call 有什么区别？</p><p>33. SSE 和流式 HTTP 有什么区别？</p><p>34. SSE 断开了怎么办？</p><h3 id="题目5-8">题目5</h3><p>1. Http请求中有哪些请求方式？</p><p>2. 说一下Https是如何保证链接安全的？</p><p>3. Https的加密方式是怎样的？对称还是非对称？</p><p>4. Http的状态码都有哪些，代表什么意思？</p><p>5. TCP是如何实现可靠传输的呢？</p><p>6. 在浏览器中输入url后会发生哪些事情？</p><p>7. C++指针和引用的差别是什么？</p><p>8. 说一下动态链接和静态链接是什么，以及各自的优缺点</p><p>9. 说一下深拷贝和浅拷贝的区别</p><p>10. 进程通信的解耦机制？</p><p>11. linux进程通信的几种方式以及各自的应用场景</p><p>12. 说一下数据库的范式</p><p>13. 说一下多线程死锁的原因吧</p><p>14. 如何避免死锁呢？</p><p>15. java是如何保证线程安全的呢？</p><p>16. 说一下java里面的容器是如何保证线程安全的？</p><p>17. AOP在Spring中是怎么实现的呢？</p><p>18. 说一下缓存穿透、击穿、雪崩</p><p>19. 写的项目有没有上线过，有没有用户大规模使用，缓存穿透这些问题是怎么遇到的？(答：模拟这些问题)</p><p>20. 你是怎么模拟这些过程的呢？</p><p>21. 你的linux主要是用来干嘛的呢？</p><h3 id="题目6-7">题目6</h3><p>1.实习 拷打 主要db</p><p>2.分表的设计</p><p><a href="http://3.mq/">3.MQ</a>的使用</p><p>4.索引 联合索引</p><p>5.缓存三剑客</p><p>6.缓存一致性</p><p>7.分布式锁</p><p>8.浏览器输入域名到响应返回</p><h3 id="题目7-5">题目7</h3><p>缓存里存什么数据？<br>Redis 的什么特性使它可以胜任缓存工作？<br>Redis单线程是什么意思，为什么单线程就会快？<br>IO多路复用是什么？单线程和多线程在IO多路复用里的区别？<br>在实习过程中，用的HTTP版本是多少？<br>HTTP2.0和3.0相比1.1的优化方式？</p><h3 id="题目8-4">题目8</h3><p>1.实习项目，问了20分钟左右<br>2.你多线程是怎么用的<br>3.线程进程区别，怎么创建线程<br>4.线程池原理，拒绝策略<br>5.数据库索引数据结构、优点，你们部门项目是怎么加索引的<br>6.springboot用到了什么设计模式<br>7.spring的循环依赖<br>8.项目里用过什么注解<br>9.数据库事务的隔离级别和原理<br>树的z型遍历，但是是英文题</p><h3 id="题目9-2">题目9</h3><p>实习中有什么挑战性的东西<br>有用到什么中间件吗<br>八股/场景<br>一条sql语句的执行顺序（内部流程，解析器执行器）<br>一条sql语句的执行计划（计划，先联表还是先分组）<br>innodb事务隔离级别<br>MySQL索引结构<br>为什么选择B＋树<br>什么时候会索引失效？<br>说一下联合索引<br>对(a,b,c)这样的索引，where b &gt; 10 and a = 1可以利用索引吗<br>业务中发现数据库机器CPU和内存都很高怎么办<br>怎么处理慢查询<br>redis常见数据类型<br>redis为什么适合缓存<br>redis cluster的读写 分片等</p><h3 id="题目10-3">题目10</h3><p>1.自我介绍<br>2.项目拷打(20min)<br>a. 介绍一下视频上传功能<br>b.介绍一下私聊功能<br>3.手撕K个一组反转链表(最后不够K个也要反转没注意)[15min]<br>4.介绍一下MVCC？<br>5.介绍一下间隙锁？</p><h3 id="题目11-2">题目11</h3><ol><li><p>详细介绍一下你那个海洋物联网平台都干了些啥？</p></li><li><p>那么多不同设备的数据，是怎么接到系统里的？它们的数据结构有啥不一样？</p></li><li><p>刚提到了反射，Java 里有几种方式能实现反射？</p></li><li><p>CGLIB 和 JDK 动态代理，主要区别是啥？</p></li><li><p>数据是怎么存的？如果按半年存，要查 6 月到 8 月的数据该怎么做？</p></li><li><p>怎么监控和优化慢 SQL？</p></li><li><p>索引在什么情况下会失效？MySQL 有哪些索引类型？聚簇索引和非聚簇索引有啥区别？</p></li><li><p>Spring 的事务传播行为有哪几种？它们有啥用？</p></li><li><p>消息队列在项目里一般都用在哪些地方？</p></li><li><p>聊聊你对 Kafka 的理解？它的核心组件和 broker 都是干嘛的？怎么保证消息不丢？</p></li></ol><p>后45分钟进入编程环节:</p><p>核心代码模式算法题&quot;求前缀和&quot;</p><p>附加问题:</p><ol><li>用 Shell 写个脚本，统计日志里出现次数 Top 10 的 IP。</li><li>用 Java 实现同样的功能（要求自己手写堆）。</li><li>给你一些日志（每条包含 ip、start、end），算一下一天中同时在线人数的峰值是多少。</li></ol><h3 id="题目12-2">题目12</h3><p>\1. 自我介绍<br>\2. 讲一个实习或项目的亮点<br>\2. go协程和c协程区别？栈溢出会崩溃吗？<br>\3. read系统调用会发生几次用户态到内核态的切换？零拷贝会发生几次？<br>\4. 浏览器输入url，客户端发包过程？，在数据链路层用到什么协议，是怎么路由到目标服务器的？<br>\5. mysql的mvcc版本链存在什么位置？<br>\6. mysql日志没落盘突然断电了怎么办？<br>\7. 两阶段提交涉及哪些日志？</p><h3 id="题目13-2">题目13</h3><p>自我介绍<br>详细介绍第一个项目 （我的项目放的比较多）<br>面试官了解项目的基本情况（使用场景和一些简单的细节）<br>数据量级比较大的时候如何解决（详细答了解决的算法设计思路，这块项目里详细做过）<br>关于项目中网络传输和数据存储的一些问题<br>数据传输中用到的协议<br>介绍另一个项目（做了个web服务框架）<br>安全认证的方式<br>链表和数组的区别<br>一个场景题，数组取数据相关的<br>线程和进程的区别<br>详细说明适用场景<br>多线程的CPU底层处理方式<br>介绍一下设计模式的一些情况</p><h3 id="题目14-2">题目14</h3><p>1.自我介绍<br>2.实习<br>微服务，怎么交互<br>http是一种序列化协议吗 （答错了，更高级一些）<br>RPC<br>socket<br>Kafka写内存可以吗<br>3.项目 （项目做的太简单了<br>表的设计<br>聊天有历史记录吗<br>为什么压测</p><p>redis<br>缓存一致性</p><h3 id="题目15-2">题目15</h3><p># 你觉得go和Java有什么区别，这俩本质上语言这方面有没有什么区别</p><p>​</p><p># 讲一下 Java的反射原理和机制是什么，怎么获取具体实现，反射的话说是不是它里面所有的属性都可以获取到，私有属性可以吗</p><p>​</p><p># 对象创建的哪个阶段去调用的，编译值还是运行值，你说一下反射的优点和缺点都是什么，它的性能怎么样？它运行的时候是怎么获取的</p><p>​</p><p># Java里边常用的数据结构有哪些?也就是集合数据结构,集合 list和数组的区别,常见的list有哪些类型，我new一个ArrayList的时候是预分配内存还是插入的时候再分配内存</p><p>​</p><p># 现在我们假设有一个数组也好，map也好，我们想保证一个数据操作它的读写是现场安全的，请问有几种办法,ReetrantLock实现原理是什么，锁的话说会有性能问题除此之外还有什么保证现场安全的办法</p><p>​</p><p># 跑程序的容器里边，它有两个比较核心的指标对吧？这两个核心指标分别是什么，那么我们加锁的方式是用什么换什么</p><p>​</p><p># 解释一下https的原理行吧，说一下https的原理实现方式以及加密方式，还有它是如何保证安全的，那个证书有没有可能被劫持</p><p>​</p><p># Redis在哪些场景下用的多，或者说什么场景需要用到Redis，你用之前知道它大约能抗多少QPS，它为什么快</p><h3 id="题目16-2">题目16</h3><p>\1. 自我介绍<br>\2. 简单问了实习<br>\3. 事务的ACID特性是如何保证的，没有redolog的引擎怎么实现持久化<br>\4. mysql主从同步的过程<br>5.主从同步延迟长的原因<br>\6. 数据库和缓存如何保证一致性<br>7.项目拷打</p><h3 id="题目17-2">题目17</h3><p>pringBoot的IOC的基本原理和底层实现？<br>出现循环依赖怎么解决？有没有遇到过三级缓存也解决不了的循环依赖<br>OOM是什么，什么情况会出现OOM？<br>如果出现了栈溢出的情况，程序会直接终止吗？<br>进程和线程的区别？<br>Java线程有哪些状态？Java的线程和操作系统的线程是一一对应的吗？<br>数据库在什么情况下会出现索引失效？为什么左模糊查询会导致索引失效？<br>数据库的第一第二第三范式都是什么？<br>RPC是个什么样的概念？有哪些常见的RPC框架？RPC是怎么实现的？</p><h3 id="题目18-2">题目18</h3><p>1.问实习二十五分钟 后开始基础知识拷打</p><p>2.讲讲Java的锁 synchroniz</p><p>3.说说锁升级的过程</p><p>4.为什么会有这个过程  主要是避免什么</p><p>5.reentranlock 和synchronize 的区别 生产上一般用哪个</p><p>6.AQS的实现原理</p><p>7.有哪些实现类 以及怎么实现的</p><p>8.类加载机制</p><p>9.双亲委派是什么</p><p>10.索引失效是由什么导致的</p><p>11.慢sql排查优化</p><p>12.联合索引 最左前缀匹配原则</p><p>13.redolog binlog如何写入磁盘 两阶段提交</p><p>14.如果没有两阶段提交会怎么样</p><p>15.MySQL 的原子性是怎么保证的</p><p>16.数据更新日志的写入顺序</p><p>17.redis的网络模型是怎么样的 （为什么这么快）</p><p>18.什么是分布式 以及会带来什么问题</p><p>19.分布式数据一致性怎么保证</p><p>20.消息队列的推拉模式了解么</p><p>21.如何保证消息幂等</p><p>22.如何保证消息不丢失</p><p>23.kafka为什么那么快</p><p>24.零拷贝是什么 讲一下流程 减少哪些地方的拷贝 是完全没有拷贝么</p><p>25.一个消息队列的好坏有哪些评价指标  有什么作用</p><p>26.rocketmq和kafak的区别</p><p>27.设计模式 应用场景</p><h3 id="题目19-2">题目19</h3><p>SpringBoot 是怎么加载 Bean 的？</p><p>反射为啥会影响性能？</p><p>线程安全的工作原理是啥？</p><p>线程安全里，主内存和工作内存分别指啥？</p><p>进程和线程有啥联系和区别？</p><p>HashMap 和 TreeMap 有啥区别？</p><p>红黑树查询效率为啥高？</p><p>红黑树是怎么实现自平衡的？</p><p>网络编程里，你知道哪些 IO 模型？</p><p>BIO、NIO、AIO 里的 N 指的是啥？</p><p>TCP 是怎么保证可靠传输的？</p><h2 id="二面-6">二面</h2><h3 id="题目1-27">题目1</h3><ul><li>跟电影售票有什么区别？剧院跟电影的区别是啥？为什么不能放在现有平台上呢？</li><li>项目有什么关键的设计？</li><li>如果我们要做一个登录态的保持，比如说七天免登录，那这个应该怎么做？</li><li>access TOKEN 的过期时间是怎么保证的？</li><li>这个（TOKEN 过期时间）会被篡改吗？怎么做的非法校验？</li><li>为什么要两个 TOKEN 呢？</li><li>存在 cookie 里了，为什么没有暴露呢？（回答设置HTTP-only）设置这个是能做什么？（被拷打了，没有答明白两个token应该存放在哪）</li><li>token控制 7 天有效期这个怎么控制？</li><li>那假设我们再把这个问题升级一下，就是如果 7 天内有登录，那这个 key 就不过期。那你怎么实现？</li><li>就是如果我连续登录，那理论上不是固定的过期时间，是超过多长时间不登录才过期？</li><li>只要你 7 天内有登录，那我们这个就不过期；如果超过 7 天没登录，那就过期重新登，那你应该怎么做？</li><li>那比如说我中间有登录，只要我中间打开 APP，这个就不过期，这个怎么做的？</li><li>会生成新的 TOKEN 刷新了，怎么刷？</li></ul><h3 id="题目2-14">题目2</h3><p>1.自我介绍<br>2.为什么选用websocket<br>3.谁来敲定使用websocket的<br>4.websocket和sse区别<br>5.为什么sse原生只支持文本格式<br>6.sse是怎么做限制的<br>7.什么是双全工协议<br>8.使用websocket有什么要注意的地方<br>9.讲一下组件的原理 如何实现交互的<br>10.websocket能复用长连接吗<br>11.这个组件肯定是多机部署的 怎么知道你要选用的是哪个连接<br>12.你觉得这个组件设计的收益在哪里<br>13.假如让你实现一个websocket 如何实现<br>14.rocketmq和kafka区别<br>15.为什么kafka吞吐量大<br>16分布式锁的key和过期时间怎么设置的<br>17.为什么要用分布式锁 有别的方法吗<br>18.讲一下故障降级的机制</p><h3 id="题目3-11">题目3</h3><p>自我介绍<br>堆区栈区相关内容<br>静态变量<br>这些都问的比较深入<br>代码编译的过程<br>死锁相关<br>做的项目代码量<br>Nginx反向代理介绍一下<br>项目算法介绍<br>TCP流量控制的方法<br>具体介绍滑动窗口<br>http协议相关<br>设计模式</p><h2 id="三面-3">三面</h2><h3 id="题目1-28">题目1</h3><p>1.简单寒暄了几句</p><p>2.自我介绍</p><p>3.项目拷打</p><p>a.项目里Nginx负载均衡怎么做的？</p><p>b.Nginx配置集群怎么做？[以为问的是后端集群在Nginx怎么配置，结果是Nginx服务器集群怎么配置，没做过Nginx服务器集群根本不知道]</p><p>c.你的多后端服务配置在哪？[追问：为什么在Linux不在Docker上？]</p><p>d.从键入请求到你的服务返回响应中间发生了什么?</p><p>e.那你得到IP地址和MAC地址去请求集群中哪台Nginx服务器？</p><p>f.域名挂靠怎么挂靠的[没听懂这里想问什么，可能是请求的后端服务器的域名或者其他的，有牛友可以解答一下吗]</p><p>g.Linux命令了解吗？</p><p>h.我如果把Nginx的配置文件的所属目录更改了，那我要做哪些操作</p><p>这里面试官看出来我没什么实战经验了，直接问我你刚才说的是不是都是背的？（好想钻地缝里去）</p><p>开始拷打操作系统：</p><p>1.删除一个文件在操作系统里面是什么流程？</p><p>2.进程线程区别？</p><p>3.你刚才提到说进程独立分配资源，具体有哪些资源？</p><p>4.硬链接软链接了解吗？区别在哪？</p><p>接着拷打数据库：</p><p>1.做过数据库备份吗？对应SQL语句是什么？[忘光光]</p><p>2.来个SQL查询，分别找出学生表中姓李的男生女生个数（我的答案是group by 性别 having name like “李%”，面试官说为什么不where name like “李%” group by 性别，汗流浃背了）</p><p>3.来写一个反射的实例以及方法的调用（几百年没写过反射了，直接蒙了）</p><p>手撕在数组中出现次数超过一半的数字</p><p>面试官可能看我好多答不上来有点尴尬，接着问我消息队列：</p><p>1.kafka的原理？</p><p>2.kafka部署在几台机器上，一个分区几个副本？</p><h3 id="题目2-15">题目2</h3><p>自我介绍（面试官恭喜进入第三面 ┭┮﹏┭┮）<br>项目上介绍最能代表个人技术特点的项目<br>补充：项目这块因为是从0到1做的实现，本身项目做的很多，属于是项目业务型选手，所以面试官老师问的项目相关的内容<br>没有卡壳的基本，各种衍生优化场景当时做的时候也都基本有考虑到过，所以答得很顺畅，还跟面试官老师交流了一<br>些优化设计思路</p><p>然后就是基本的八股<br>面试官老师对网络通信和安全协议这块问的很多也比较细，绝大部分答得还可以</p><h1>小红书</h1><h2 id="一面-16">一面</h2><h3 id="题目1-29">题目1</h3><p>1.介绍自己。讲一下项目</p><p>2.讲一下你用的这个reactor网络模型</p><p>3.你说把耗时操作push到线程池，那返回的结果是如何回到reactor的回调里的呢。我不会，胡扯了一通，还是对项目不够了解</p><p>4.讲一下epoll处理的过程</p><p>5.send返回以后数据是已经从机器发出去了吗</p><p>6.缓冲区满了以后阻塞模式的send会是什么表现？非阻塞模式呢</p><p>7.什么时候触发send缓冲区的清理。面试官提到tcp之后我说是ack以后</p><p>8.在reactor回调里不小心写了一个sleep会怎么样？影响的是一个连接还是一个线程？其实是想问线程切换相关</p><p>9.你提到nginx，有没有看过nginx的实现，我说没有，面试官说因为你之前提到用epoll实现reactor网络模型，其实应该先看一下nginx和redis的实现，因为他们就是标准的。而且redis还是跨平台的，不仅是epoll，会根据操作系统的不同选择不同的方案</p><p>10.你提到io_uring，是使用过吗？内核版本多少？是要解决什么问题？只是处理网络io还是包括文件？</p><p>11.你提到的这个用户态轻量级线程协程是什么？具体的切栈的逻辑你有看过吗？操作寄存器如果不用内联汇编的话你觉得c和c++可以实现吗？面试官意思是c/c++没有提供直接操作寄存器的接口</p><p>12.你这边还提到了使用过dpdk，dpdk和标准的内核网络栈有什么区别？是如何绕过内核的？驱动是用户态的还是内核态的？工作原理可以描述一下吗？它是主动去pull还是一个中断触发</p><p>13.read系统调用读本地文件一直到磁盘设备大概经历那些流程。我说我不太了解</p><h3 id="题目2-16">题目2</h3><p>实习里面这个监听binlog怎么保证一致性</p><p>mq有了解过吗</p><p>es有了解过吗</p><p>es和mysql的区别</p><p>mysql的索引结构</p><p>垃圾回收算法</p><p>jvm各区域</p><p>一次younggc的过程</p><p>synchronized锁底层</p><p>synchronized锁升级</p><p>mq有了解过吗（只说会kafka 讲了一下kafka的架构 以及一些机制</p><p>分布式一致性（说了raft，说了分布式事务</p><p>分布式事务实现的技术有了解过吗？这个不会</p><p>怎么看待ai</p><h3 id="题目3-12">题目3</h3><p>1. 自我介绍<br>2. 项目里面提到的一些内容<br>3. Redis使用场景、Redis数据结构、部署方式（单机/集群/哨兵）、Redis哨兵模式原理<br>4. MySQL与ES的核心差异、搜索索引优化内容、压测工具、项目核心难点<br>5. MQ使用场景、MQ原理（核心组成）<br>6. JVM运行时数据区域有哪些？<br>7. 常见垃圾回收算法及各自区别与优点<br>8. Java线程池核心参数<br>9. 线程池拒绝策略有哪些？<br>10. Java内置锁（synchronized）原理<br>11. 如何避免死锁？<br>12. 分布式一致性了解吗？分布式锁或分布式事务？</p><h3 id="题目4-10">题目4</h3><p>\1. 自我介绍<br>\2. 介绍一下第一个需求的背景<br>\3. 为什么使用CompletableFuture<br>\4. 线程池的参数以及你的设置<br>\5. 那如何设计一个阻塞队列呢<br>\6. 第二个需求的背景<br>\7. 插件是怎么实现的<br>\8. 什么是AOP<br>\9. Caffeine的内存淘汰策略，及其优势<br>\10. 第三个需求的背景<br>\11. 为什么选择使用工厂+策略进行优化<br>\12. 第四个需求的背景<br>\13. 有没有遇到什么问题</p><h3 id="题目5-9">题目5</h3><p>1、自我介绍</p><p>2、挑一个项目来介绍一下</p><p>3、Java 的 GC 过程会有 Stop the World，谈谈为什么要有 STW 的机制？</p><p>4、谈谈 Java 的SGC、G1、ZGC 垃圾回收器</p><p>5、G1 已经很不错了，为什么还要有 ZGC 这样的垃圾回收器，为了解决什么问题？</p><p>6、比如一个订机票的场景，涉及多个外部系统，首先要去看有没有票，然后第二个是支付要调支付宝或者微信去做付款，定完票可能过了半个小时才告诉我订票有没有成功。对于这种场景下的分布式事务，你认为怎么去处理和设计来保证一致性比较好？</p><p>7、基于消息传递的方案，消息可能传递失败，如何解决？</p><p>8、如果用消息队列，这种场景，怎么做技术选型？</p><p>9、做题：新兵报到，指导员命令所有人按身高大小，从低到高，依次站好，每次从头这边开始调整，但是要求，每次一次只能进行一次交换。输入 N(N &lt;=  20)，输出 N 个士兵最终的排列结果。示例：N = 5，heights = [170, 167, 180, 175, 168]，输出：[167, 168, 170, 175, 180]</p><p>10、谈谈基于数据库的方式如何实现分布式锁？</p><p>11、谈谈基于 Redis 如何实现分布式锁？</p><p>12、为什么基于 Redis 实现分布式锁时，Set 命令要加 PX 参数？</p><p>13、基于数据库方式实现和基于 Redis 实现的区别？应用场景？</p><h3 id="题目6-8">题目6</h3><p>创建线程有几种方式？</p><p>聊聊线程池的设计和参数配置？拒绝策略和阻塞队列怎么选？</p><p>Spring AOP 的原理是啥？都用在哪些地方？</p><p>聊聊 Spring 的事务管理和隔离级别？</p><p>Redis 数据结构，随便挑一个讲讲底层原理？</p><p>项目里 Redis 具体用在哪了？</p><p>Redis 还有别的用法吗？它的分布式锁支持可重入吗？</p><p>怎么保证 Redis 和 MySQL 的数据一致性？</p><p>聊聊项目里防超卖的方案？为啥用库存扣减，而不是直接改库存数？数据库锁为啥没法完全解决超卖？</p><p>为啥要把行业映射配置放 Diamond 里？</p><p>阿里云 OpenSearch 全量和增量同步冲突了咋办？</p><p>实习时碰到过啥技术难题？</p><p>核心代码模式算法题：连续子数组的最大和。</p><p>电商的基础设施（比如库存、订单系统），你觉得有啥技术挑战？</p><h3 id="题目7-6">题目7</h3><p>1、自我介绍几分钟</p><p>2、实习的提效工具怎么工程化落地，混合了对Agent、MCP、RAG的工具性理解</p><p>3、Redis为什么高效</p><p>4、Redis的缓存雪崩、缓存击穿、缓存穿透及解决方案</p><p>5、TCP为什么是可靠传输</p><p>6、连不上服务（time_wait）怎么排查</p><p>7、多线程的锁机制</p><p>8、并发、并行及其应用场景</p><p>9、乐观锁和悲观锁</p><p>10、浅拷贝和深拷贝及其应用场景</p><p>11、假设有一个超大文件，以最省内存（并非空间复杂度）的方法输出前十个最大的数</p><p>12、有null值的两表联查</p><h3 id="题目8-5">题目8</h3><p>介绍实习业务<br>实习里面这个监听binlog怎么保证一致性<br>mq有了解过吗<br>es有了解过吗<br>es和mysql的区别<br>mysql的索引结构<br>垃圾回收算法<br>jvm各区域<br>一次younggc的过程<br>synchronized锁底层<br>synchronized锁升级<br>mq有了解过吗（只说会kafka 讲了一下kafka的架构 以及一些机制<br>分布式一致性（说了raft，说了分布式事务<br>分布式事务实现的技术有了解过吗？这个不会<br>怎么看待ai</p><h3 id="题目9-3">题目9</h3><p>八股文：<br>mysql执行一条update语句，全流程是怎么样的，假设存储引擎是innodb。（问了很久，包括加锁啥的面试官也引导着要求说一下，忘完了，这块说的不够详细）<a href="">#牛客AI配图神器#</a></p><p>加一个联合索引后，在存储引擎内存储结构是怎么样的。就假如说加了（a,b）联合索引。</p><p>假如加了（a,b）联合索引，查询的时候还有个非索引字段c，最终查询流程是什么样的。</p><p>mysql redolog和undolog干啥的。</p><p>假如说mysql宕机了，redolog写入成功了，binlog还没写进去。mysql重启后会怎样。</p><p>redis String底层结构，为啥要这么设计</p><p>redis expire的工作原理</p><p>redis 除了基于内存以外，还有哪些点导致他性能这么高的。</p><p>你说io多路复用，为啥io多路复用性能高，说一下select poll，epoll原理。</p><p>redis分片集群，集群某个节点容量不够了怎么扩容。扩容后数据迁移怎么做。扩容后hash变化是怎样的。</p><p>go语言slice append流程</p><p>go语言垃圾回收机制，写屏障是为了解决什么问题的。</p><p>你对go转Java是什么看法，部门内主要还是Java</p><h3 id="题目10-4">题目10</h3><p>全程八股</p><p>TCP三次握手 四次挥手</p><p>TCP如何保证数据传输可靠性(滑动窗口</p><p>TCP UDP区别</p><p>http和websocket</p><p>http和https区别，是对称加密吗，为什么</p><p>类加载流程</p><p>双亲委派流程，如何打破</p><p>启动类加载器和扩展类加载器加载什么样的类</p><p>为什么要打破，有什么好处</p><p>垃圾回收算法，哪些算ROOT</p><p>如何触发full gc，cms和g1流程以及区别，三色标记</p><p>类什么时候回收，怎么回收</p><p>mysql三大范式，你设计一张表会从哪些角度考虑</p><p>mysql索引，聚簇，二级，哈希，联合，覆盖，前缀</p><p>mysql事务如何保证，acid如何实现</p><p>redolog和undolog在哪层，分别怎么实现</p><p>幻读是什么，如何解决</p><p>readview版本链读取规则</p><p>解释一下BIO，AIO，NIO，以及多路复用</p><p>详细说一下select，poll，epoll，如何做</p><p>线程池相关，如何预热，工作流程，如何手写拒绝策略</p><p>字节码如何增强</p><p>ThreadLocal为什么会导致内存泄露，反射原理，注解原理，用过吗，举个例子</p><p>细说Spring解决循环依赖的三级缓存</p><h2 id="二面-7">二面</h2><ul><li>redis 常用数据结构, 实现, big key,</li><li>业务处理时间超过了分布式锁的过期时间, 如何处理</li><li>mq 如何实现订单超时处理</li></ul><h3 id="题目1-30">题目1</h3><p>几乎都答出来了<br>简单问了一下实习<br>Java 的hash函数是怎样的<br>hash函数有什么降低hash冲突的方法吗<br>垃圾回收算法<br>标记复制的缺点是什么？<br>标记复制为什么是8:1:1<br>jvm的软引用和弱引用的区别<br>为什么jvm会有这几种引用的区分<br>讲一下协程<br>线程和协程区别，哪个上下文切换开销大<br>协程的上下文切换开销主要在哪里？<br>协程栈大小是多大，线程呢？<br>springboot的优势<br>除了约定俗成的配置，你知道springboot在初期是怎样发展起来的吗，有什么优势<br>spring是如何解决循环依赖的？<br>三级缓存为什么能解决循环依赖</p><h1>网易</h1><h2 id="一面-17">一面</h2><h3 id="题目1-31">题目1</h3><p>开局一个sql题：<br>登录记录表record，有字段记录id（id），用户id（user_id），登录时间（login_time），怎么查询用户A（user_id=10000）的最近3次登录记录？<br>写了个select * from record where user_id = 10000 order by login_time desc，忘记最近3次怎么写了（加个limit 3就行）<br>接下来全是场景题，感受一下：<br>1、服务器被入侵了如何处理？（随便答了个拉黑ip，但是换一个ip怎么办，不会）<br>2、发现某个接口速度很慢，如何排查？（一脸懵）<br>3、mysql某条语句查询速度很慢，如何排查？（说了explain查看执行计划）<br>4、1000w条数据找目标值，几分查找比较合适？（没懂这题想考什么，是想考B+树索引吗）</p><h3 id="题目2-17">题目2</h3><p>\1. 自我介绍<br>\2. 实习经历中的接口优化怎么做的<br>\3. 你是怎么检测接口速度和页面响应快慢的<br>\4. 合同流程优化细节<br>\5. 合同生成是同步还是异步调度的<br>\6. 防重提交怎么做的<br>\7. Redis分布式锁相关问题<br>\8. 为什么要做这样的功能<br>\9. 简历上面有个策略模式，你还知道哪些设计模式<br>\10. 讲一下单例和工厂模式<br>\11. 看了你的github源码，这里面为什么会有这么多文件夹–微服务，工具类打成jar包，直接用接口<br>\12. 是不是可以试试多模块？<br>\13. 各个模块之间是不是有很多关联操作<br>\14. 怎么创建线程<br>\15. 线程的拒绝策略有哪些，分别在什么场景下面能用到<br>\16. 你之前怎么进行项目部署的<br>\17. 你知道dockerfile是什么作用不<br>\18. 来做道题–单词拆分（leetcode 139）–大概7min<br>\19. 说思路–动态规划<br>\20. 什么时候到岗，能实习多久</p><h1>新浪</h1><h2 id="一面-18">一面</h2><h3 id="题目1-32">题目1</h3><p>1.自我介绍</p><p>2.秒杀场景下redis的分布式锁和lua脚本分别起什么作用</p><p>3.缓存空对象可以解决缓存穿透，但是高并发场景下压力大怎么办</p><p>4.了解大模型吗，用大模型协助开发吗，平时用什么大模型协助开发，大模型的token是什么，怎么定义一个token</p><p>5.项目中怎么解决mq消息的重复消费和消息丢失</p><p>6.rocketmq底层怎么保证消息的可靠性（记不清问的啥了）</p><p>7.mysql的隔离级别有哪些</p><p>8.rr下一个事务能读到其他事务的提交吗</p><p>9.优化慢查询有哪些思路</p><p>10.索引分类有哪些，怎么建索引，哪些场景索引会失效</p><h1>大疆</h1><h2 id="一面-19">一面</h2><h3 id="题目1-33">题目1</h3><p>1.自我介绍+项目介绍</p><p>2.ThreadLocal咱们平时用的时候，都说要注意内存泄漏，具体是怎么避免的呢?</p><p>3.聊聊Nacos吧，它的选举机制是怎么样的?跟 Raft算法有什么关系，能讲讲Raft的原理吗?</p><p>4.分库分表这个话题，你了解哪些实现方案?分了之后，分布式ID一般是怎么生成的?</p><p>5.如果我想在线程池的父子线程之间传递 ThreadLocal里的值，有什么办法吗?</p><p>6.MySQL性能调优，你一般会从哪些方面入手?有什么方法和思路?</p><p>7.布隆过滤器，能讲讲它的原理吗?在什么场景会用到它?</p><p>8.Dubbo在做RPC调用的时候，如果调用失败了，它都有哪些处理机制?比如重试、降级这些。</p><p>9.你是怎么理解线程安全这个概念的?平时在代码里是怎么处理线程安全问题的?</p><p>10.我们常说Redis单线程快，而且是线程安全的。它的线程安全具体是怎么保证的?</p><p>\11. MySQL主从同步如果出现延迟了，一般是什么原因造成的?有什么解决方案?</p><p>12.MySQL的binlog有哪几种格式?它们之间有什么区别?</p><p>13.实现分布式锁，都有哪些方案?能讲讲它们的3/4原理吗?</p><p>14.如果要你来设计一个全链路压测平台，你的设计思路是怎样的?</p><p>15.系统升级的时候，经常涉及到数据迁移，怎么才能做到平滑迁移，不影响线上业务?</p><p>16.线上服务JVM频繁Full GC，你会怎么去排查和解决?</p><p>17.数据库如果发生死锁了，一般的排查步骤是怎样的?</p><p>18.做了分库分表之后，如果某个库或表出现数据倾斜，有什么解决办法?</p><p>19.用分布式锁的时候，如果第一次加锁失败了，4/4</p><p>后续的重试机制一般怎么设计比较合理?</p><p>20.有没有遇到过MySQL执行计划选错了索引的情况?碰到了怎么处理?</p><p>21.Spring的核心是IOC，你觉得要实现一个IOC容器，关键点有哪些?</p><p>22.Spring的声明式事务很方便，它的底层原理是什么?</p><p>23.设计一个订单超时自动取消的功能，你会怎么实现?</p><p>24.在并发编程里，线程的同步</p><p>(Synchronization)和协作(Coordination)，它俩有什么区别?</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/27/%E5%B7%A5%E4%BD%9C/towork/mianjing/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>压测实际经验</title>
      <link>https://blog.tokenlen.top/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/</link>
      <guid>https://blog.tokenlen.top/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/</guid>
      <pubDate>Wed, 20 Aug 2025 16:00:00 GMT</pubDate>
      
      
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E5%8E%8B%E6%B5%8B/">压测</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/21/%E5%B7%A5%E4%BD%9C/towork/test1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC-源码分析</title>
      <link>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/</link>
      <guid>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/</guid>
      <pubDate>Thu, 14 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;线程&lt;/h1&gt;
&lt;h2 id=&quot;1-从-JVM-的角度来说一下线程和进程之间的关系&quot;&gt;1.从 JVM 的角度来说一下线程和进程之间的关系&lt;/h2&gt;
&lt;p&gt;一个进程中可以有多个线程，多个线程共享进程的&lt;strong&gt;堆&lt;/strong&gt;和**方法区 (JDK1.8</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>线程</h1><h2 id="1-从-JVM-的角度来说一下线程和进程之间的关系">1.从 JVM 的角度来说一下线程和进程之间的关系</h2><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和**方法区 (JDK1.8 之后的元空间)*<em>资源，但是每个线程有自己的*<em>程序计数器</em></em>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p>那么？为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><ol><li>程序计数器：</li></ol><p>主要作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>so,程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><ol start="2"><li>虚拟机栈和本地方法栈</li></ol><p><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><p>那么我们怎么创建线程呢？</p><p>一般来说，创建线程有很多种方式，例如继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口、使用线程池、使用<code>CompletableFuture</code>类等等。</p><p>严格来说，Java 就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><p>然后我们的run方法是直接启动线程，start方法是新建一个线程然后使用run方法来启动线程</p><h2 id="2-说一下线程的生命周期">2.说一下线程的生命周期</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕</li></ul><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p><p>当线程进入 <code>synchronized</code> 方法/块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="3-多线程">3.多线程</h2><p>为什么我们要使用多线程？</p><p>总体上呢：</p><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p><p><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><p>底层来看：</p><p><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p><p><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p><p>单核CPU实现多线程：</p><p>单核 CPU 是支持 Java 多线程的。操作系统通过时间片轮转的方式，将 CPU 的时间分配给不同的线程。尽管单核 CPU 一次只能执行一个任务，但通过快速在多个线程之间切换，可以让用户感觉多个任务是同时进行的</p><p>操作系统主要通过两种线程调度方式来管理多线程的执行：</p><ul><li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I/O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li><li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li></ul><h2 id="4-死锁">4.死锁</h2><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>四个条件：</p><p><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</p><p><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</p><p>如何判断死锁呢？</p><p>使用<code>jmap</code>、<code>jstack</code>等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，<code>jstack</code> 的输出中通常会有 <code>Found one Java-level deadlock:</code>的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用<code>top</code>、<code>df</code>、<code>free</code>等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取Java进程PID</span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"># 生成线程堆栈信息</span><br><span class="line">jstack &lt;pid&gt; &gt; thread_dump.txt</span><br><span class="line"></span><br><span class="line"># 实时监控（每3秒输出一次）</span><br><span class="line">while true; do jstack &lt;pid&gt;; sleep 3; done</span><br></pre></td></tr></table></figure><p>然后我们可以在程序中去检查死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDetector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">detectDeadlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="type">long</span>[] deadlockedThreads = threadBean.findDeadlockedThreads();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadInfo[] threadInfos = threadBean.getThreadInfo(deadlockedThreads);</span><br><span class="line">            <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;检测到死锁线程: &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mysql的话，我们可以去查看日志，找deadlock字段记录的，然后看他选择的哪一个事务进行了回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看最近的死锁信息</span><br><span class="line">SHOW ENGINE INNODB STATUS;</span><br><span class="line"></span><br><span class="line">-- 开启死锁日志记录</span><br><span class="line">SET GLOBAL innodb_print_all_deadlocks = ON;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何避免死锁呢？</p><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><ol><li>按照顺序获取锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderedLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock1) &#123; <span class="comment">// 同样先获取lock1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>超时锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeoutLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">acquired1</span> <span class="operator">=</span> <span class="literal">false</span>, acquired2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acquired1 = lock1.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!acquired1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            acquired2 = lock2.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!acquired2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行转账逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acquired2) lock2.unlock();</span><br><span class="line">            <span class="keyword">if</span> (acquired1) lock1.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去给这个锁设置一个超时的时间</p><ol start="3"><li>使用并发工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Semaphore避免死锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">// 业务逻辑，同时最多2个线程执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>锁&amp;关键字</h1><h2 id="1-Synchonized">1.Synchonized</h2><ol><li><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。在 JDK18 中，偏向锁已经被彻底废弃</li></ol><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><ol start="2"><li>monitor和对象头</li></ol><p>在HotSpot JVM中，每个Java对象都有对象头，主要包含：Markword这里记录的是锁信息的状态，GC标记，hashcode等，然后是一个Class Pointer指向Class对象的指针</p><p>Markword是根据锁的状态是变化的，根据锁的升级是进行变化的</p><p>锁的升级：</p><ul><li>无锁状态：Mark Word存储hashCode、GC年龄等，头是unused</li><li>首次进入：尝试偏向锁，Mark Word存储: 线程ID + epoch + age + 01，头是threadID:54</li><li>重入：recursions++，仍是偏向锁</li><li>如果有其他线程竞争，升级为轻量级锁，Mark Word存储: Lock Record指针 + 00，JVM在当前线程栈中创建Lock Record，markOop就是原始的markword,oop被指向的锁对象。头是ptr_to_lock_record</li><li>竞争激烈时，升级为重量级锁 ，Mark Word存储: Monitor对象指针 + 10，当升级到重量级锁时，创建Monitor对象，Mark Word指向它。头是ptr_to_monitor</li></ul><p>然后我们的线程是要去竞争锁的，首先我们会使用快速路径：尝试CAS获取锁，如果失败了就自旋等待，然后超过重试的次数的话，加入EntryList，阻塞等待。</p><p>然后我们如果阻塞了的话，这个时候需要去notify，需要从WaitSet移到EntryList，然后等待的话，需要先释放锁，然后加入等待Set，然后阻塞等待notify</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking          // 开启偏向锁（默认开启）</span><br><span class="line">-XX:BiasedLockingStartupDelay=0 // 立即启用偏向锁</span><br><span class="line">-XX:+UseHeavyMonitors          // 强制使用重量级锁（调试用）</span><br></pre></td></tr></table></figure><p>实际应用问题：</p><p>​hashCode调用**会导致偏向锁失效</p><p>​**System.identityHashCode()**会强制升级锁</p><p>​<strong>大量短期锁竞争</strong>时，禁用偏向锁可能更好</p><p>​Monitor对象**在锁释放后不会立即回收，可能影响GC</p><ol start="3"><li>偏向锁的撤销（好难哭）,JDK18已经废弃</li></ol><p>条件：</p><p>比如说线程1获取了偏向锁，然后线程2去尝试获取偏向锁，然后这个时候就会触发偏向撤销，升级为轻量级锁</p><p>调用Object.hashCode()或System.identityHashCode()，此时obj处于偏向锁状态，Mark Word存储线程ID等信息</p><p>调用hashcode就会立刻撤销偏向锁，因为偏向锁的Mark Word无法存储hashCode</p><p>然后调用wait方法，让obj等待了，立即撤销偏向锁，升级为重量级锁，因为wait需要Monitor对象支持</p><p>流程：</p><p>​检测撤销条件：检查是否为偏向锁模式，在markword获取偏向的线程ID,判断撤销类型,如果是匿名偏向直接撤销，有具体偏向线程，需要更复杂的处理</p><p>​安全点操作：在安全点执行撤销操作，</p><h2 id="2-volatile">2.volatile</h2><p>Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>他能保证可见性，禁止重排，但是不能保证原子性，比如i++</p><p>指令重排是编译器和 CPU 的优化手段，通过改变代码执行顺序来提升性能。然而，重排序可能会破坏多线程中的正确性。<br>通过插入 <strong>内存屏障</strong>（Memory Barrier），<code>volatile</code> 保证了对该变量的操作的顺序不会被重排，确保了对共享变量的写操作在前，读操作在后。这种内存屏障的插入通常是 <code>StoreLoad</code> 指令，它确保写操作的数据先写入主内存，后续的读操作必须从主内存中获取最新值</p><p>插入的是StoreLoad指令，先将cpu缓存刷新到主内存之前，不会将主内存的缓存，加载到cpu中</p><p>使用场景：</p><p><strong>停止标志位</strong>：多线程间通过共享的 <code>volatile</code> 变量来通知其他线程是否停止工作。</p><p>DCL的单例模式</p><p>AQS中的state变量，用来计数</p><h2 id="3-乐悲观锁">3.乐悲观锁</h2><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</p><p>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变</p><p>量类）。</p><h2 id="4-ReentranLock">4.ReentranLock</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。<code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁</p><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说当前线程在等待获取锁的过程中，如果其他线程中断当前线程「 <code>interrupt()</code> 」，当前线程就会抛出 <code>InterruptedException</code> 异常，可以捕捉该异常进行相应处理。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li><li><strong>支持超时</strong> ：<code>ReentrantLock</code> 提供了 <code>tryLock(timeout)</code> 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li></ul><p>总结：</p><p>ReentrantLock是Java中的显式可重入互斥锁，提供灵活的线程同步功能。它支持公平和非公平模式，允许同一线程多次获取锁而不会发生死锁。其核心特性包括：可中断的锁获取（lockInterruptibly()）、超时尝试锁（tryLock()）、以及支持多个Condition条件变量。与synchronized相比，ReentrantLock需要手动管理锁的获取和释放，适用于复杂的多线程场景。</p><p>voliate修饰变量的实现</p><ul><li>当同一个线程再次请求锁时，如果它已经持有该锁，计数器会增加，以允许多次获取而不会阻塞。</li><li>ReentrantLock维护一个等待队列，当线程无法获取锁时，会被放入该队列。每当持有锁的线程释放锁时，计数器会减少，直到归零，其他线程才能获取锁。</li></ul><h2 id="5-Semaphore">5.Semaphore</h2><p><code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始共享资源数量</span><br><span class="line">final Semaphore semaphore = new Semaphore(5);</span><br><span class="line">// 获取1个许可</span><br><span class="line">semaphore.acquire();</span><br><span class="line">// 释放1个许可</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p><p><code>Semaphore</code> 有两种模式：。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的，默认是非公平的</li></ul><p>可以使用Redis+Lua来做限流的处理</p><p>它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><h2 id="6-CountDownLatch">6.CountDownLatch</h2><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行</p><p>比如多次处理六个没有顺序关系的文件，全都处理完之后，返回给用户</p><h2 id="7-CyclicBarrier-有什么用？">7.CyclicBarrier 有什么用？</h2><p>它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CyclicBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><p>比如我们去好几个任务完成之后，给他们综合起来</p><h2 id="8-Java中的CAS">8.Java中的CAS</h2><p>CAS（Compare-And-Swap）是一种无锁的原子操作机制，广泛应用于Java的并发编程中。它通过比较内存中的实际值与预期值，决定是否将该值更新为新值。CAS的操作依赖于三个参数：当前值、预期值和新值。如果当前值等于预期值，则更新为新值；否则不做任何操作。CAS的优势是能够避免传统锁带来的性能开销，但也存在ABA问题，可以通过引入版本号或时间戳来解决。典型应用包括AtomicInteger等原子类的实现。</p><p>底层是Unsafe的CAS操作，是调用的操作系统的</p><p>在unsafe类里面静态方法尝试去先获取表示 <code>value</code> 字段在 <code>AtomicInteger</code> 对象中的内存偏移地址。</p><p>然后调用<code>compareAndSwapInt</code>方法去执行调用底层的 <code>cmpxchg</code> 指令</p><h2 id="9-ReentrantReadWriteLock">9.ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 适用于读多写少的高并发场景，特别是在需要频繁读取但较少修改的数据同步需求。它的读锁允许多个线程并行访问，而写锁则保证写操作的独占性和数据一致性。常见的应用场景包括缓存系统、配置管理和统计数据管理等。</p><h1>线程池</h1><h2 id="1-线程池的处理任务的流程">1.线程池的处理任务的流程</h2><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p><p>答案是可以的！<code>ThreadPoolExecutor</code> 提供了两个方法帮助我们在提交任务之前，完成核心线程的创建，从而实现线程池预热的效果：</p><ul><li><code>prestartCoreThread()</code>:启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；</li><li><code>prestartAllCoreThreads()</code>:启动所有的核心线程，并返回启动成功的核心线程数。</li></ul><h2 id="2-设计一个能根据任务优先级执行的线程池">2.设计一个能根据任务优先级执行的线程池</h2><p>不同的线程池会选用不同的阻塞队列作为任务队列，比如<code>FixedThreadPool</code> 使用的是<code>LinkedBlockingQueue</code>（有界队列），默认构造器初始的队列长度为 <code>Integer.MAX_VALUE</code> ，由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</p><p><code>PriorityBlockingQueue</code> （优先级阻塞队列）作为任务队列（<code>ThreadPoolExecutor</code> 的构造函数有一个 <code>workQueue</code> 参数可以传入任务队列）。</p><p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：</p><ol><li>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li><li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li></ol><p>不过会遇见以下的问题</p><p><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。</p><p>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。</p><p>由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 <code>ReentrantLock</code>），因此会降低性能。</p><p>对于 OOM 这个问题的解决比较简单粗暴，就是继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。</p><p>饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</p><h1>Future</h1><h2 id="1-一个任务需要依赖另外两个任务执行完之后再执行，怎么设计">1.一个任务需要依赖另外两个任务执行完之后再执行，怎么设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1</span></span><br><span class="line">CompletableFuture&lt;Void&gt; futureT1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T1 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// T2</span></span><br><span class="line">CompletableFuture&lt;Void&gt; futureT2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T2 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class="line">    ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用allOf()方法合并T1和T2的CompletableFuture，等待它们都完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; bothCompleted = CompletableFuture.allOf(futureT1, futureT2);</span><br><span class="line"><span class="comment">// 当T1和T2都完成后，执行T3</span></span><br><span class="line">bothCompleted.thenRunAsync(() -&gt; System.out.println(<span class="string">&quot;T3 is executing after T1 and T2 have completed.Current time：&quot;</span> + DateUtil.now()));</span><br><span class="line"><span class="comment">// 等待所有任务完成，验证效果</span></span><br><span class="line">ThreadUtil.sleep(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过 <code>CompletableFuture</code> 的 <code>allOf()</code> 这个静态方法来并行运行 T1 和 T2，当 T1 和 T2 都完成后，再执行 T3。</p><h2 id="2-使用-CompletableFuture，有一个任务失败，如何处理异常？">2.使用 CompletableFuture，有一个任务失败，如何处理异常？</h2><p>使用 <code>CompletableFuture</code>的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。</p><p>下面是一些建议：</p><ul><li>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li><li>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li><li>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li><li>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复</li></ul><h2 id="3-在使用-CompletableFuture-的时候为什么要自定义线程池？">3.在使用 CompletableFuture 的时候为什么要自定义线程池？</h2><p><code>CompletableFuture</code> 默认使用全局共享的 <code>ForkJoinPool.commonPool()</code> 作为执行器，所有未指定执行器的异步任务都会使用该线程池。这意味着应用程序、多个库或框架（如 Spring、第三方库）若都依赖 <code>CompletableFuture</code>，默认情况下它们都会共享同一个线程池。</p><p>虽然 <code>ForkJoinPool</code> 效率很高，但当同时提交大量任务时，可能会导致资源竞争和线程饥饿，进而影响系统性能。</p><p>为避免这些问题，建议为 <code>CompletableFuture</code> 提供自定义线程池，带来以下优势：</p><ul><li>隔离性：为不同任务分配独立的线程池，避免全局线程池资源争夺。</li><li>资源控制：根据任务特性调整线程池大小和队列类型，优化性能表现。</li><li>异常处理：通过自定义 <code>ThreadFactory</code> 更好地处理线程中的异常情况。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql底层分析</title>
      <link>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/</link>
      <guid>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/</guid>
      <pubDate>Thu, 14 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;索引&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>索引</h1><h2 id="1-索引的分类">1.索引的分类</h2><p>从数据结构上分类，B+树索引，hash索引，倒排索引，R树索引</p><p>从InoDB的B+树的索引分类，分为聚簇索引和非聚簇索引</p><p>从索引的性质进行分类，普通索引，主键索引，唯一索引，联合索引，全文索引，空间索引</p><h1>锁&amp;隔离级别</h1><h2 id="1-表级锁与行级锁的区别？">1.表级锁与行级锁的区别？</h2><p>MySQL 常见的两种锁是表级锁和行级锁。</p><p>表级锁锁定整个表，所有对该表的读写操作都会被阻塞，适用于低并发场景；而行级锁锁定特定行，允许其他行的操作并发进行，适用于高并发场景。</p><p>表级锁粒度大，加锁快、开销小，但并发性能差，典型代表是 MyISAM。<br>行级锁粒度小，允许多个事务并发操作不同的行，并发性高，但锁的开销大，容易出现死锁，典型代表是 InnoDB。<br>因此实际使用时，MyISAM 适合读多写少的分析场景，而 InnoDB 的行级锁更适合高并发的 OLTP 系统。</p><h2 id="2-MySQL-默认隔离级别？为何选择它？">2.MySQL 默认隔离级别？为何选择它？</h2><p>MySQL 的默认隔离级别是可重复读（REPEATABLE READ）。选择这一隔离级别是因为它能够提供较高的数据一致性，防止不可重复读，并通过 MVCC（多版本并发控制）技术支持高效的并发性能。同时，通过间隙锁（Gap Lock）解决了幻读问题，使得在一个事务中多次读取结果一致，尽管它并不能完全消除幻读的可能性。</p><p>如果选择 <strong>Serializable</strong>，虽然隔离性最强，但会强制事务串行化执行，性能开销过大。</p><p>如果选择 <strong>Read Committed</strong>，虽然性能更高，但会出现不可重复读，影响数据一致性。但是某些大厂的事务隔离级别就是RC，数据的一致性可以由MQ等组件来完成，为了提高并发量</p><h1>日志</h1><h2 id="1-MySQL-的-buffer-pool-与缓存命中率如何监控？">1.MySQL 的 buffer pool 与缓存命中率如何监控？</h2><p>MySQL 的 buffer pool 是 InnoDB 存储引擎中用于缓存数据和索引的内存区域。监控 buffer pool 和缓存命中率可以通过 <code>SHOW ENGINE INNODB STATUS</code> 查看状态变量，关键指标包括 buffer pool 的总大小、当前缓存的数据页数量等。或者是直接SHOW GLOBAL STATUS，SHOW GLOBAL STATUS LIKE ‘Innodb_buffer_pool_read%’;</p><p>视图更加友好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看 Buffer Pool 状态的摘要信息</span><br><span class="line">SELECT * FROM sys.innodb_buffer_stats_by_schema;</span><br><span class="line"></span><br><span class="line">-- 按表查看 Buffer Pool 的使用情况，用于定位热点数据</span><br><span class="line">SELECT * FROM sys.innodb_buffer_stats_by_table ORDER BY pages DESC LIMIT 10;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缓存命中率的计算方法是：命中率 = (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) × 100%。使用性能监控工具如 MySQL Enterprise Monitor 或 Percona Monitoring and Management （<strong>PMM</strong>）可以实时监控这些指标，从而优化数据库性能。</p><h1>SQL语句</h1><h2 id="1-Order-by是怎么实现的">1.Order by是怎么实现的</h2><p>在 MySQL 中，<code>ORDER BY</code> 的实现主要有三种方式：</p><ul><li><p><strong>索引有序扫描</strong>：如果 <code>ORDER BY</code> 字段能和索引顺序匹配，直接按索引返回，最优。</p></li><li><p><strong>Filesort 文件排序</strong>：无法利用索引时，MySQL 会将结果放入 sort buffer 排序，小数据在内存，大数据写磁盘；它有单路和双路两种实现方式。</p><ul><li>双路：扫描符合条件的行 → 将排序字段和主键 ID 放到 sort buffer → 排序 → 再根据主键 ID 回表取数据。需要两次数据访问，性能差。</li><li>单路：直接将排序字段和要返回的所有列一起放入 sort buffer → 排序 → 直接返回。回表减少了，需要更大内存，sort buffer 容量不够时会写磁盘临时文件。</li></ul></li><li><p><strong>优先队列排序</strong>：当 <code>ORDER BY</code> 搭配 <code>LIMIT N</code> 时，可能只维护一个 N 大小的堆，提高效率。结果集很大，但只取前 N 条。</p></li></ul><p>调优：</p><p>尽量让 <code>ORDER BY</code> 和索引顺序匹配，避免 filesort。</p><p>如果必须 filesort，调大 <code>sort_buffer_size</code>、<code>tmp_table_size</code>，减少磁盘落盘。</p><p>避免 <code>SELECT *</code>，减少 sort buffer 内存占用。</p><p>大数据排序时考虑加索引或改写 SQL。</p><h2 id="2-MySQL-如何存储-IP-地址？">2.MySQL 如何存储 IP 地址？</h2><p>因为我们的IP地址是有两种的IPV4 IPV6</p><ul><li><p><strong>VARCHAR</strong>：直接存 <code>'192.168.0.1'</code>，简单直观，但存储和查询效率差。</p></li><li><p><strong>UNSIGNED INT</strong>：用 <code>INET_ATON/INET_NTOA</code> 把 IPv4 转整数（4B），空间小、查询快，但只支持 IPv4。使用Mysql提供的两个函数，</p></li><li><pre><code>INET_ATON('192.168.0.1')` → `3232235521INET_NTOA(3232235521)` → `'192.168.0.1'</code></pre></li><li><p><strong>VARBINARY(16)</strong>：用 <code>INET6_ATON/INET6_NTOA</code> 存二进制，既支持 IPv4 又支持 IPv6（推荐做法）。使用函数</p></li><li><p><code>INET6_ATON('2001:db8::1')</code> → 二进制（16B）</p><p><code>INET6_NTOA(binary_value)</code> → 字符串 IP</p></li></ul><p>如果只考虑 IPv4，<code>INT</code> 最优；如果要兼容 IPv6，推荐 <code>VARBINARY(16)</code>。</p><h2 id="3-MySQL-一行记录是怎么存储的？">3.MySQL 一行记录是怎么存储的？</h2><p><strong>InnoDB</strong> 是最常用的存储引擎，数据以 <strong>页（Page，16KB）</strong> 为最小单位。</p><p>一个页中包含多个行记录。页内部有 <strong>页头、页目录、行数据</strong> 等。</p><p>一行记录的结构主要包括：行头信息（删除标记、指针）、事务信息（事务 ID、回滚指针）、NULL 标记位、变长字段长度列表以及实际字段值。<br>如果某行太大（例如包含 TEXT/BLOB），就会发生行溢出，行内只存前 768 字节和指针，其余内容存放在溢出页。<br>InnoDB 还支持 Compact、Dynamic、Compressed 等多种行格式，Compact 是默认的。</p><h2 id="事务">事务</h2><h2 id="1-Mysql长事务可能带来哪些问题？">1.Mysql长事务可能带来哪些问题？</h2><p>首先，它会长时间持有锁，阻塞其他事务，影响并发性能；<br>其次，InnoDB 的 MVCC 机制需要依赖 undo log 保存历史版本，长事务不提交会导致 undo log 膨胀，版本链变长，阻止 purge 线程清理，造成表膨胀和性能下降；<br>同时也会增加死锁概率和主从延迟。<br>因此在开发中我们要控制事务范围，及时提交，并通过监控和超时机制避免长事务。</p><p>比如：</p><ul><li><strong>及时提交事务</strong>：避免在事务中执行不必要的逻辑，比如用户交互、网络请求。</li><li><strong>控制事务大小</strong>：大批量操作要拆分成多个小事务。</li><li>SELECT * FROM information_schema.INNODB_TRX \G;监控长事务</li><li><strong>设置超时</strong>：<ul><li><code>innodb_lock_wait_timeout</code>：控制锁等待时间。</li><li><code>wait_timeout</code> / <code>interactive_timeout</code>：控制会话空闲超时。</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经优化回答</title>
      <link>https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/</link>
      <guid>https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/</guid>
      <pubDate>Wed, 13 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;Spring框架&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>Spring框架</h1><h2 id="1-SpringBoot的配置加载优先级">1.SpringBoot的配置加载优先级</h2><p>首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：</p><ol><li><p>先是<strong>命令行参数</strong>（<code>--server.port=9000</code> 或 <code>java -jar app.jar --spring.config.location=...</code>）</p></li><li><p>然后是我们的系统的环境变量和JVM系统属性，比如设置端口为8080，比如我们在这里设置API的KEY</p></li><li><p>然后**<code>RandomValuePropertySource</code>**（<code>random.*</code> 占位符，用于生成随机数/字符串，可在配置中引用）</p></li><li><p>接着是<strong>外部配置文件</strong>（properties / yml）</p><ul><li><p>JAR 包外部的 <code>./config/</code></p></li><li><p>JAR 包外部的 <code>./</code></p></li><li><p>JAR 包内部的 <code>classpath:/config/</code></p></li><li><p>JAR 包内部的 <code>classpath:/</code></p></li></ul></li><li><p>接着是我们@PropertySource注解指定的配置</p></li><li><p>最后是我们Springboot默认的配置</p></li></ol><p>然后在配置文件中，properties的配置大于yml，因为springboot是按加载顺序来的，后加载的properties把yml的值给覆盖了</p><p>对于外部配置文件，查找路径的优先级为：</p><ol><li><code>./config/</code>（当前目录下的config目录）</li><li><code>./</code>（当前目录）</li><li><code>classpath:/config/</code></li><li><code>classpath:/</code></li></ol><p>实际应用:</p><p><strong>基础配置</strong>：放在 <code>classpath:/application.yml</code></p><p><strong>环境特定配置</strong>：使用 <code>application-&#123;profile&#125;.yml</code>（如 <code>application-prod.yml</code>），通过 <code>--spring.profiles.active=prod</code> 激活</p><p><strong>敏感信息</strong>：放在环境变量或外部化配置文件（避免入库）</p><p><strong>临时调试/测试</strong>：使用命令行参数临时覆盖</p><p><strong>多环境冲突处理</strong>：利用 profile 合并特性，公共配置放在 <code>application.yml</code>，环境差异放在对应 profile 文件</p><h2 id="2-Springboot是如何解决跨域问题的？">2.Springboot是如何解决跨域问题的？</h2><p>基本都是基于CORS（跨域资源共享）通过设置响应头（如 <code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>）告诉浏览器允许访问。</p><p>对于复杂跨域请求（非 GET/POST/HEAD 或自定义头），浏览器会先发 <strong>OPTIONS 预检请求</strong>。</p><ol><li>局部注解，用@CrossOrigin标记单个接口，秒开跨域权限，适合快速测试。简单高效，优先级高于全局配置</li><li>全局配置，使用WebMvcConfigurer接口，统一设定允许的域名，请求方法，头信息。统一配置，但是不适合动态的控制</li><li>用CorsFilter手动处理跨域逻辑处理，适合需要动态校验权限等特殊场景，比如不同权限开放不同接口，在过滤器中动态判断，但是实现成本较高</li><li>在微服务架构中，也可以在<strong>网关层</strong>（如 Spring Cloud Gateway、Nginx）统一处理跨域，减少业务服务配置。</li></ol><p>优先级：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin` &gt; `WebMvcConfigurer` &gt; `CorsFilter</span><br></pre></td></tr></table></figure><h2 id="3-Spring-解决循环依赖">3.<strong>Spring 解决循环依赖</strong></h2><p><strong>既然Spring能解决循环依赖，那为什么我们还经常听说‘构造器注入无法解决循环依赖’？三级缓存对构造器注入为什么无效？</strong></p><p>您问到了Spring循环依赖解决方案的一个核心<strong>前提</strong>。三级缓存之所以能工作，其根本在于它将<strong>Bean的实例化（Instantiation）**和**属性填充（Population）**这两个阶段**分离开来</strong>了。</p><ul><li><strong>第一步：实例化</strong>。Spring首先通过<strong>无参构造函数</strong>创建了Bean A的一个“空壳”实例。这个实例已经有了自己的内存地址。</li><li><strong>第二步：暴露早期引用</strong>。紧接着，Spring立即将这个“空壳”实例的工厂（ObjectFactory）放入三级缓存，从而<strong>提前暴露</strong>了A的引用。</li><li><strong>第三步：属性填充</strong>。然后Spring才开始尝试为A注入属性，此时发现需要B，就去创建B。当B需要A时，可以从三级缓存中获取到A的早期引用，从而打破循环。</li></ul><p><strong>构造器注入的工作流程</strong>:</p><ul><li>对于构造器注入，<strong>Bean的实例化和属性填充这两个阶段是合并在一起的，是原子性的</strong>。</li><li>当Spring尝试创建Bean A时，它必须调用A的构造函数。而A的构造函数需要一个Bean B的实例作为参数。</li><li>为了满足这个参数，Spring必须先去创建Bean B。</li><li>而当Spring尝试创建Bean B时，又发现B的构造函数需要一个Bean A的实例作为参数。</li><li>此时，<strong>Bean A的实例根本还没有被创建出来</strong>（它还卡在等待B的阶段），内存中不存在任何A的“空壳”实例，三级缓存中自然也就不可能有任何关于A的引用。</li><li>这就形成了一个无法解开的死结：A的创建依赖B的创建，B的创建又依赖A的创建。因此，Spring会直接抛出<code>BeanCurrentlyInCreationException</code>。</li></ul><h2 id="4-Bean的生命周期">4.Bean的生命周期</h2><p>依赖注入，三级缓存</p><p>流程：</p><ul><li><strong>实例化 (Instantiation):</strong> Spring 通过反射创建 Bean 的实例。</li><li><strong>填充属性 (Populate Properties):</strong> Spring 注入 Bean 的依赖（DI）。</li><li>初始化 (Initialization):<ul><li>调用各种 Aware 接口（如 <code>BeanNameAware</code>, <code>BeanFactoryAware</code>）。</li><li>调用 <strong><code>BeanPostProcessor</code> 的前置处理</strong>方法 (<code>postProcessBeforeInitialization</code>)。</li><li>调用 <code>@PostConstruct</code> 注解的方法或 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法。</li><li>调用自定义的 <code>init-method</code>。</li><li>调用 <strong><code>BeanPostProcessor</code> 的后置处理</strong>方法 (<code>postProcessAfterInitialization</code>)。<strong>&lt;- AOP 代理发生在这里</strong></li></ul></li><li><strong>使用 (In Use):</strong> Bean 处于可用状态。</li><li>销毁 (Destruction):<ul><li>调用 <code>@PreDestroy</code> 注解的方法或 <code>DisposableBean</code> 的 <code>destroy</code> 方法。</li><li>调用自定义的 <code>destroy-method</code>。</li></ul></li></ul><h1>JUC</h1><h2 id="1-线程池常见的坑">1.线程池常见的坑</h2><ol><li><p>线程池的参数配置：核心线程的数量，和最大线程的数量是业务场景来的，CPU密集型，比如数据的计算业务，就是CPU的数量+1。</p><p>IO密集型根据业务压测的值来决定的，最佳线程数=（（线程等待时间+线程CPU时间）/线程CPU时间）*CPU数量</p></li></ol><p>比如，我们服务器CPU核数为8核，任务线程CPU耗时20ms,线程等待等等耗时80ms，那么最佳线程数=（80+20）/20*8=40线程，那我们最大线程数就是80个</p><ol start="2"><li>共享线程池，次要的逻辑拖垮主要的逻辑。避免所有的业务都共享一个线程池，防止一个次要的业务一直在执行业务，占用线程池。而主要的业务并没有足够的线程数来执行，影响到了我们主要的服务。这样做是不合理的。我们应该要做线程池的隔离，使用Future.get方法的时候，使用带超时时间的，因为他是阻塞的，防止被其他抢占。</li><li>@Async是Spring中一个注解，他不是线程池，他其实是SimpleAsyncTaskExecutor，不会复用线程，适合执行大量短时间的线程。还是尽量自己定义一个异步的线程池，然后使用@EnableAsync来注册</li><li>使用线程池的时候，不使用threadfactory参数来自定义命名，这样导致后期不好排查问题和回溯问题</li><li>使用submit提交任务，不会把异常直接抛出来。最好我们在submit之中进行try-catch进行捕获，或者是在 <code>Future.get()</code> 时捕获并记录异常。</li><li>线程池使用完之后，记得关闭，防止内存泄漏的问题。最好线程池设计成单例的模式。长期运行的全局线程池（如 Spring 管理的）不需手动关闭，临时线程池需在 finally 中调用 <code>shutdown()</code>。</li><li>线程池不要和事务一起使用，使用@Transtation的时候，依赖于当前线程的线程上下文，而线程池的线程和当前事务的线程不是一个线程，事务的上下文不会传递，导致线程池中的业务代码不在事务中执行，事务就失效了。我们可以将事务放在线程池之外进行，这是最好的方法，或者是使用支持事务上下文传递的机制（如 <code>TransactionAwareDataSourceProxy</code>、消息队列保证一致性）</li><li>我们要负责监控线程池状态，比如当前活跃的线程池的数量，队列的长度，拒绝的次数</li><li>要配置合理的拒绝策略，比如一个需要快速获取结果的线程，就需要胚子和callerrunpolicy，这样的话，谁提交谁执行，回退给调用的线程。</li><li>执行过程：</li></ol><ul><li>Step 1: 判断核心线程数是否已满？<ul><li>当前运行的线程数 &lt; <code>corePoolSize</code>？</li><li><strong>是：</strong> 则<strong>直接创建一个新的核心线程</strong>来执行任务，即使其他核心线程现在是空闲的。</li><li><strong>否：</strong> 进入 Step 2。</li></ul></li><li>Step 2: 判断任务队列是否已满？<ul><li><code>workQueue.offer(task)</code> 是否成功？</li><li><strong>是：</strong> 任务入队成功，等待空闲线程来处理。</li><li><strong>否：</strong> 进入 Step 3。</li></ul></li><li>Step 3: 判断最大线程数是否已满？<ul><li>当前运行的线程数 &lt; <code>maximumPoolSize</code>？</li><li><strong>是：</strong> 则<strong>创建一个新的非核心线程</strong>来执行任务。</li><li><strong>否：</strong> 进入 Step 4。</li></ul></li><li>Step 4: 执行拒绝策略。<ul><li>调用 <code>rejectedExecutionHandler.rejectedExecution(task, this)</code>。</li></ul></li></ul><h2 id="2-AQS的大局解析">2.AQS的大局解析</h2><p>AQS是JUC里面的一个抽象同步框架，核心的作用就是统一分装了线程的等待唤醒排队机制。</p><p>底层通过一个volatile的state变量+FIFO的队列来实现线程安全的资源性抢夺</p><p>state表示资源的状态，独占锁里面0没人占，1就是已经上锁。可重入锁里面数字代表可重入的次数</p><p>线程要抢不到锁，就会被挂到队列里面进行排队，队列是双向链表实现的CLH队列，节点记录了等待状态，信息等</p><p>他只是一个框架，真正的锁逻辑交给实现类自己决定</p><p>AQS获取锁和解锁的过程：</p><ul><li>获取锁 (acquire)：<ol><li>尝试用 <strong>CAS</strong> 修改 <code>state</code> 从 0 到 1。</li><li>如果成功，则获取锁成功，将锁持有者设为当前线程。</li><li>如果失败，说明锁被占用。则将当前线程包装成一个 Node 节点，<strong>加入到 CLH 队列的尾部</strong>。</li><li>加入队列后，线程会<strong>自旋</strong>一小会儿，再次尝试获取锁。如果还是失败，则调用 <code>LockSupport.park()</code> <strong>挂起</strong>当前线程，等待被唤醒。</li></ol></li><li>释放锁 (release)：<ol><li>修改 <code>state</code> 的值（比如减1）。</li><li>如果 <code>state</code> 变为 0，说明锁已完全释放。</li><li>则找到 CLH 队列头节点的<strong>下一个节点</strong>，调用 <code>LockSupport.unpark()</code> <strong>唤醒</strong>它，让它去竞争锁。</li></ol></li></ul><h2 id="3-wait和sleep的区别">3.wait和sleep的区别</h2><p>wait()和sleep()的主要区别在于：1. 所属类不同，wait()是Object类的方法，sleep()是Thread类的静态方法；2. wait()会释放对象锁，而sleep()保持锁不释放；3. wait()必须在同步代码块中调用，sleep()没有此限制；4. wait()需要notify()或notifyAll()来唤醒，而sleep()在超时或被中断时自动恢复；5. 使用场景上，wait()用于线程间的协作，sleep()用于简单的延时操作。</p><p>wait()方法使当前线程进入等待状态，将其从运行状态转变为等待状态，并将其加入到等待池中。</p><h2 id="4-异步编排">4.<strong>异步编排</strong></h2><p>在我看来，<strong>异步编排的核心思想是，将多个独立的、耗时的异步任务（尤其是I/O密集型任务）组合、编排起来，让它们尽可能地并行执行，最终汇总结果，从而极大地缩短整体的响应时间。</strong> 这在微服务架构中尤其重要。</p><p>在现代Java开发中，实现异步编排最核心的工具就是 <strong><code>CompletableFuture</code></strong></p><p>举一个我们项目中非常典型的例子：<strong>获取‘商品详情页’数据</strong>。一个商品详情页通常需要展示多种信息，而这些信息可能来自不同的微服务或数据库表：</p><ul><li><strong>任务A</strong>：调用商品服务，获取商品基本信息。</li><li><strong>任务B</strong>：调用用户服务，获取当前用户的优惠券信息。</li><li><strong>任务C</strong>：调用评论服务，获取商品的热门评论。</li><li><strong>任务D</strong>：调用推荐服务，获取相关商品推荐。</li></ul><p>如果采用传统的同步调用方式，总耗时将是 <code>A + B + C + D</code> 的累加。但实际上，这四个任务<strong>没有任何依赖关系，完全可以并行执行</strong>。通过异步编排，理想情况下的总耗时将仅仅取决于<strong>耗时最长的那一个任务</strong>，即 <code>Max(A, B, C, D)</code>，性能会得到指数级的提升。</p><p>实现：</p><ol><li><strong>任务并行化</strong>：为每一个独立的调用任务创建一个<code>CompletableFuture</code>实例。关键是使用<code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code>方法，并为其<strong>提供一个自定义的线程池</strong>。这可以避免耗尽Web服务器（如Tomcat）的业务线程池。</li><li><strong>结果编排与组合</strong>：当所有并行的任务都完成后，我需要将它们的结果组合成一个最终的<code>ProductDetailPageDTO</code>。我会使用<code>CompletableFuture.allOf()</code>来等待所有任务完成。</li><li><strong>最终结果处理</strong>：在<code>allOf()</code>完成后，通过<code>thenApply()</code>或<code>thenAccept()</code>来执行最终的组装逻辑。</li><li><strong>异常处理与超时控制</strong>：在生产环境中，还需要考虑健壮性。我会使用<code>exceptionally()</code>来处理任何一个异步任务的失败，返回一个默认值或降级数据。同时，使用<code>orTimeout()</code>为整个编排流程设置一个最大等待时间，防止因为某个下游服务缓慢而导致整个请求长时间阻塞。</li></ol><h2 id="5-synchronized-锁升级的“细节追问">5.<strong><code>synchronized</code> 锁升级的“细节追问</strong></h2><p>1.<strong>线程是如何从‘偏向锁’升级到‘轻量级锁’的？JVM是如何判断‘偏向’失效的</strong></p><p>“偏向锁的核心思想是，它‘偏向’于第一个获取它的线程，认为在接下来的执行中，锁将一直被这个线程持有。</p><ol><li><strong>偏向状态</strong>：当一个线程第一次获取锁时，JVM会通过<strong>CAS操作</strong>，尝试将锁对象头（Mark Word）中的<strong>线程ID</strong>指向当前线程。如果成功，就获取了偏向锁。</li><li><strong>升级触发点</strong>：当<strong>另一个线程</strong>（线程B）尝试获取这个已经被线程A持有的偏向锁时，升级过程就被触发了。</li><li><strong>偏向锁的撤销</strong>：<ul><li>首先，线程B的CAS操作会失败。JVM会检查Mark Word中记录的线程ID是否是线程A。</li><li>JVM会暂停线程A（在一个<strong>全局安全点</strong>），然后检查线程A是否还存活。</li><li>如果线程A<strong>已经执行完毕</strong>，那么锁对象恢复到无锁状态，线程B可以重新尝试获取。</li><li>如果线程A<strong>仍然存活且还在同步块内</strong>，说明发生了真正的竞争。此时，偏向锁就会被<strong>撤销（Revoke）</strong>。锁对象头的Mark Word会被修改，清除偏向锁标志，并升级为<strong>轻量级锁</strong>的状态。同时，线程A的栈帧中会创建锁记录（Lock Record），指向锁对象。</li><li>之后，线程A和线程B都会在轻量级锁的状态下进行竞争（通过自旋）。</li></ul></li><li>只不过目前在<strong>JDK 15</strong> 中被 <strong>默认禁用</strong>，并在 <strong>JDK 18</strong> 被 <strong>完全移除</strong>。因为偏向锁的撤销消耗的性能是比较大的</li></ol><p>2.<strong>那轻量级锁又是如何升级到重量级锁的？‘自旋’失败后发生了什么？</strong></p><p>轻量级锁的核心思想是，它认为锁的竞争时间会非常短，线程只需要‘稍等一下’（自旋），就可以拿到锁，从而避免了线程阻塞和唤醒带来的内核态切换开销。</p><ol><li><strong>轻量级锁的获取</strong>：线程在自己的栈帧中创建锁记录（Lock Record），然后通过<strong>CAS操作</strong>尝试将锁对象的Mark Word指向这个锁记录。如果成功，就获取了轻量级锁。</li><li><strong>自旋等待</strong>：如果CAS失败，说明锁已被其他线程持有。当前线程并不会立即阻塞，而是会进行<strong>自旋</strong>，即执行一个空循环，不断地重试CAS操作。</li><li><strong>升级触发点</strong>：升级到重量级锁主要有两种情况：<ul><li><strong>自旋失败</strong>：自旋的次数是有限的（JVM会动态调整，比如10次）。如果一个线程自旋了指定次数后，仍然没有获取到锁，JVM就认为竞争已经非常激烈了，不适合再空耗CPU。</li><li><strong>竞争者过多</strong>：如果在自旋过程中，又有<strong>第三个线程</strong>也来竞争这把锁，那么也会立即触发升级。</li></ul></li><li><strong>锁膨胀（Inflation）</strong>：<ul><li>一旦触发升级，锁就会<strong>膨胀</strong>为重量级锁。</li><li>锁对象的Mark Word会被修改，指向一个重量级锁的监视器对象（Monitor）。</li><li>所有等待锁的线程（包括正在自旋的线程和后来者）都<strong>不再自旋</strong>，而是会被<strong>阻塞</strong>，并放入Monitor的等待队列中。</li><li>当持有锁的线程释放锁时，会唤醒等待队列中的一个线程，进行新一轮的锁竞争。这个过程就涉及到了操作系统的互斥量（Mutex）和线程的上下文切换。</li></ul></li></ol><p>锁的升级是<strong>单向的</strong>，只能从低级别到高级别，不能降级（在HotSpot JVM的实现中）。</p><h2 id="6-ThreadLocal">6.ThreadLocal</h2><p><strong>既然<code>key</code>用弱引用会导致内存泄漏，那为什么<code>ThreadLocalMap</code>的设计者不把<code>key</code>也设计成强引用呢？或者，为什么不把<code>value</code>也设计成弱引用</strong></p><p>1.<strong>为什么Key不能是强引用？</strong></p><ul><li>假设Key是强引用。那么<code>Thread</code>对象会通过<code>threadLocals</code>这个Map强引用着<code>ThreadLocal</code>对象（Key）。只要线程本身不消亡，这个强引用链（<code>Thread</code> -&gt; <code>ThreadLocalMap</code> -&gt; <code>Entry</code> -&gt; <code>ThreadLocal</code>对象）就一直存在。</li><li>这意味着，即使我们在业务代码中已经不再使用某个<code>ThreadLocal</code>对象了（比如，<code>myThreadLocal = null;</code>），只要这个线程还在线程池中被复用，这个<code>ThreadLocal</code>对象本身就<strong>永远无法被GC回收</strong>。这会导致<code>ThreadLocal</code>对象本身的泄漏，比现在的情况更糟糕。”</li></ul><p>2.<strong>为什么Value不能是弱引用？</strong></p><ul><li><code>ThreadLocal</code>的核心目的就是让我们存放一些与线程绑定的<strong>数据（Value）</strong>。这些数据通常是我们业务逻辑中需要用到的对象，比如用户信息对象、数据库连接等。</li><li>如果我们把Value也设计成弱引用，那么当一次GC发生时，<strong>只要这个Value对象在其他地方没有被强引用，它就可能被意外地回收掉</strong>。</li><li>这会导致我们调用<code>threadLocal.get()</code>时，突然得到一个<code>null</code>值，这完全违背了<code>ThreadLocal</code>的设计初衷，会引发严重的业务逻辑错误。我们存放进去的对象，必须保证在<code>remove()</code>之前是可靠存在的。所以，<strong>Value必须是强引用</strong>。”</li></ul><p>因此只能做出了个权衡：</p><ul><li><strong>Key使用弱引用</strong>：是为了当<code>ThreadLocal</code>对象本身在外部不再被使用时，GC能够回收它，从而让Map中的Entry的key变为<code>null</code>，为后续的清理（expungeStaleEntry）提供了可能性。</li><li><strong>Value使用强引用</strong>：是为了保证我们存放的数据的生命周期是可控的，不会被GC意外回收。</li></ul><h2 id="7-谈谈怎么理解线程安全的">7.谈谈怎么理解线程安全的</h2><p><strong>线程安全</strong>指的是当多个线程同时访问一个对象或方法时，无论操作系统如何调度这些线程，也无需调用方在代码中去做额外的同步处理，都能保证程序的正确性，不会出现数据损坏或不一致的情况。</p><p>线程不安全的问题通常会表现在三个方面</p><ol><li>原子性：一个或多个操作作为一个不可分割的整体来进行，要去这个操作序列，必须由一个线程独占完整的去执行，不能被其他线程所干扰，调不可被中断。i++</li><li>可见性：一个线程修改了一个共享变量的值，这个修改的值能够被其他线程看到。但是实际在CPU的高速缓存下，对指令做出的重排序操作，导致共享变量的值，对其他线程不是立即课件的。缓存读的旧值</li><li>有序性：写的代码的顺序和实际代码的顺序不一致，是由于编译器和处理器层面对指令重排优化导致的，可能会导致可见性问题</li></ol><p>我们可以使用voliate或者是直接加synchronized，或者是直接加锁</p><p>或者使用原子类的CAS，或者是线程安全的ThreadLocal</p><h2 id="8-ConditionalOnClass-设计内涵">8.**<code>@ConditionalOnClass</code>**设计内涵</h2><p>面试官提出了一个非常精妙的问题：“<code>@ConditionalOnClass(User.class)</code>这行代码能编译通过，说明<code>User.class</code>肯定存在于classpath中，那为什么还需要这个注解呢？</p><p>未能理解<code>@Conditional</code>系列注解是为了解决<strong>通用starter模块在不同应用环境下的适配性</strong>问题，而不是为了解决当前项目中的类是否存在的问题。</p><p>确实，如果在我当前的项目中写<code>@ConditionalOnClass(User.class)</code>，这个条件判断看起来是多余的。因为<code>User.class</code>如果不存在，我的项目根本无法编译通过。</p><p>这个注解的真正威力体现在<strong>开发通用的starter模块</strong>时。想象一下，我们正在开发一个<code>my-sms-spring-boot-starter</code>，这个starter希望能够同时支持<strong>阿里云短信</strong>和<strong>腾讯云短信</strong>。</p><ul><li><p>我们的starter会提供两个自动配置类：<code>AliyunSmsAutoConfiguration</code> 和 <code>TencentSmsAutoConfiguration</code>。</p></li><li><p><code>AliyunSmsAutoConfiguration</code>负责创建阿里云短信服务的Bean。</p></li><li><p><code>TencentSmsAutoConfiguration</code>负责创建腾讯云短信服务的Bean。</p></li><li><p>一个**使用者（应用项目）*<em>在他的项目中引入了我们的starter。他可能只想使用阿里云短信，所以他只会在他的<code>pom.xml</code>中添加*<em>阿里云的SDK依赖</em></em>，而不会添加腾讯云的。</p></li><li><p>这时，我们的starter如何智能地判断只加载阿里云的Bean，而不去加载腾讯云的Bean呢？（如果去加载腾讯云的Bean，会因为缺少腾讯云SDK的jar包而直接抛出<code>ClassNotFoundException</code>，导致应用启动失败）</p></li><li><p>我们就是使用@ConditionalOnClass</p></li></ul><p>在<code>AliyunSmsAutoConfiguration</code>上，我们会这样写,@ConditionalOnClass(com.aliyun.sms.sdk.SmsClient.class)</p><ul><li>当使用者的应用启动时，Spring Boot会解析我们starter中的这两个自动配置类。</li><li>在解析<code>AliyunSmsAutoConfiguration</code>时，它会检查<strong>当前应用的classpath</strong>中是否存在<code>com.aliyun.sms.sdk.SmsClient.class</code>。因为使用者添加了阿里云的SDK依赖，所以这个类存在，条件满足，这个配置类就会被加载，阿里云的Bean就会被创建。</li><li>在解析<code>TencentSmsAutoConfiguration</code>时，它会检查classpath中是否存在<code>com.tencent.cloud.sms.sdk.SmsSender.class</code>。因为使用者<strong>没有</strong>添加腾讯云的SDK依赖，所以这个类不存在，条件不满足，<strong>这个配置类就会被优雅地跳过，不会被加载</strong>，从而避免了<code>ClassNotFoundException</code>。</li></ul><p><code>@ConditionalOnClass</code>并不是为了判断我们自己项目里的类是否存在，而是为了让我们开发的**通用模块（starter）*<em>能够*<em>智能地感知和适配它所运行的应用环境</em></em>，根据应用环境中引入了哪些依赖，来动态地决定哪些功能应该被激活。这是Spring Boot实现‘约定大于配置’和‘开箱即用’的关键魔法之一</p><h2 id="9-ThreadLocal-在线程池中的失效问题">9.<strong><code>ThreadLocal</code> 在线程池中的失效问题</strong></h2><ul><li><code>InheritableThreadLocal</code>之所以能够实现父子线程间的数据传递，是因为在<code>new Thread()</code>创建子线程时，子线程的构造函数会检查父线程的<code>inheritableThreadLocals</code>这个Map。如果它不为空，子线程就会将父线程Map中的所有值<strong>拷贝</strong>一份到自己的<code>inheritableThreadLocals</code>中。</li><li><strong>关键在于</strong>：这个值的拷贝动作，<strong>只发生在子线程被创建的那一瞬间</strong>。</li><li>在线程池的场景下，工作线程通常在系统启动时就已经被<strong>预先创建</strong>好了，并存放在池中。当我们提交一个任务时，线程池只是从池中<strong>取出一个已经存在的线程</strong>来执行我们的任务，并<strong>没有<code>new Thread()</code>这个动作</strong>。</li></ul><p>为了解决这个问题，阿里巴巴开源了一个非常强大的工具——<strong><code>TransmittableThreadLocal</code>（TTL）</strong>。它专门用于解决在使用线程池等会池化线程的组件时，实现父子线程、任务提交者与任务执行者之间的上下文传递问题。</p><p>TTL的优点在于它通过<strong>Java Agent</strong>或<strong>手动包装</strong>的方式，对线程池的<code>submit</code>/<code>execute</code>等方法以及<code>Runnable</code>/<code>Callable</code>任务进行了<strong>装饰（Decorate）</strong>。”</p><ol><li><strong>任务提交时（<code>submit</code>）</strong>：当我们调用被装饰过的<code>threadPool.submit(myRunnable)</code>时，TTL会<strong>捕获</strong>当前线程（父线程）的<code>ThreadLocal</code>值，并将其**‘打包’**进一个<code>TtlRunnable</code>或<code>TtlCallable</code>对象中。</li><li><strong>任务执行前（<code>run</code>）</strong>：当线程池中的某个工作线程开始执行这个被包装过的<code>TtlRunnable</code>时，在其<code>run</code>方法的<code>try</code>块开始处，TTL会将被‘打包’的父线程<code>ThreadLocal</code>值，**‘回放’（replay）**到当前工作线程的<code>ThreadLocal</code>中。</li><li><strong>任务执行后（<code>finally</code>）</strong>：在<code>finally</code>块中，TTL会<strong>清理</strong>当前工作线程的<code>ThreadLocal</code>，将其恢复到执行任务之前的状态，从而避免了数据串扰。</li></ol><h2 id="10-如何保证三个线程有序执行任务">10.如何保证三个线程有序执行任务</h2><p>方案1：使用**<code>wait/notify</code> 方案**</p><p>你需要自己管理锁（<code>synchronized</code>）、状态变量（<code>volatile int state</code>）、<code>while</code>循环（防止伪唤醒）、<code>try-finally</code>（保证锁释放），代码量大且极易出错。</p><p>使用<code>notifyAll()</code>会唤醒所有等待的线程，造成不必要的CPU竞争。而使用<code>notify()</code>又存在风险：如果错误地唤醒了不该被唤醒的线程（比如T1唤醒了T3而不是T2），信号就可能丢失，导致程序死锁。</p><p>方案2：<strong>升级版 <code>wait/notify</code> - <code>ReentrantLock</code> + <code>Condition</code></strong></p><p><code>ReentrantLock</code>提供了比<code>synchronized</code>更强大的功能。<code>Condition</code>对象则将<code>wait/notify</code>机制从“一个锁只有一个等待队列”升级为“<strong>一个锁可以有多个独立的等待队列</strong>”，我们可以为每个线程的“等待室”创建一个<code>Condition</code>，实现精准的“点对点”唤醒，彻底避免了<code>notify()</code>的信号丢失问题。</p><ol><li>创建一个<code>ReentrantLock</code>实例。</li><li>创建一个<code>volatile</code>状态变量，例如<code>volatile int state = 1;</code>，用于标识当前应该哪个线程执行。</li><li>为<strong>每个线程</strong>创建一个<code>Condition</code>对象：<code>Condition c1 = lock.newCondition(); Condition c2 = lock.newCondition(); Condition c3 = lock.newCondition();</code></li><li>线程T1的逻辑：<ul><li>获取锁 <code>lock.lock()</code>。</li><li>在<code>try...finally</code>中执行，<code>finally</code>块中<code>lock.unlock()</code>。</li><li><code>while (state != 1)</code>，<code>c1.await()</code>。</li><li>执行任务1。</li><li>更新状态 <code>state = 2</code>。</li><li><strong>精准唤醒</strong>线程T2：<code>c2.signal()</code>。</li></ul></li><li><strong>线程T2和T3的逻辑</strong>与T1类似，分别在自己的<code>Condition</code>上<code>await</code>，并在执行完任务后，更新<code>state</code>并<code>signal</code>下一个线程的<code>Condition</code>。</li></ol><p>实现了有序执行，通过<code>signal()</code>实现了精准唤醒，比<code>notifyAll()</code>更高效，比<code>notify()</code>更安全。但还是比较复杂</p><p>方案3：<strong>信号量接力 - <code>Semaphore</code></strong></p><p><code>Semaphore</code>（信号量）是控制同时访问特定资源的线程数量的工具。我们可以创建两个初始许可为0的信号量，作为两个线程之间的“接力棒”。</p><ol><li>创建两个信号量：<code>Semaphore sem2 = new Semaphore(0);</code> 和 <code>Semaphore sem3 = new Semaphore(0);</code>。</li><li>线程T1的逻辑：<ul><li>执行任务1。</li><li>执行完毕后，释放一个“给T2的许可”：<code>sem2.release()</code>。</li></ul></li><li>线程T2的逻辑：<ul><li>首先尝试获取“来自T1的许可”，如果许可未被释放，T2将在此阻塞：<code>sem2.acquire()</code>。</li><li>获取到许可后，执行任务2。</li><li>执行完毕后，释放一个“给T3的许可”：<code>sem3.release()</code>。</li></ul></li><li>线程T3的逻辑：<ul><li>首先尝试获取“来自T2的许可”：<code>sem3.acquire()</code>。</li><li>获取到许可后，执行任务3。</li></ul></li></ol><p>代码清晰简单，但需要创建N-1个<code>Semaphore</code>对象，如果线程数量很多，会增加一些对象管理的开销。</p><p>方案4：<strong><code>SingleThreadExecutor</code></strong></p><p><code>Executors.newSingleThreadExecutor()</code>会创建一个<strong>单线程的线程池</strong>。这个线程池的核心特性是：它内部有一个<strong>无界的<code>LinkedBlockingQueue</code>**来存放任务，并且**永远只有一个工作线程</strong>来从队列中取出并执行任务。这就天然地保证了所有提交给它的任务，都会<strong>严格按照提交的顺序（FIFO）来串行执行</strong>。</p><ol><li><p>创建一个单线程执行器：<code>ExecutorService executor = Executors.newSingleThreadExecutor();</code></p></li><li><p>定义三个任务（<code>Runnable</code>或<code>Callable</code>）：<code>task1</code>, <code>task2</code>, <code>task3</code>。</p></li><li><p>按顺序提交任务：java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br></pre></td></tr></table></figure></li><li><p>关闭线程池：<code>executor.shutdown()</code>。</p></li></ol><ul><li><strong>严格来说，这是“三个任务有序执行”，而不是“三个不同的线程有序执行”</strong>。因为所有任务都是由<strong>同一个</strong>工作线程来执行的。如果面试官的题目严格要求必须是三个<strong>不同的、预先创建好</strong>的线程，那么这个方案就不完全符合字面要求。</li></ul><h2 id="11-ReentrantLock-和-synchronized-在性能上到底差异在哪？">11.<strong><code>ReentrantLock</code> 和 <code>synchronized</code> 在性能上到底差异在哪？</strong></h2><ul><li><p><code>synchronized</code>：</p><ul><li><strong>实现</strong>：它是Java的<strong>关键字</strong>，由JVM层面直接实现。其核心依赖于操作系统底层的**<code>Mutex Lock</code>（互斥量）**。</li><li><strong>开销</strong>：获取和释放<code>Mutex Lock</code>需要进行<strong>用户态到内核态的切换</strong>，这是一个非常昂贵的操作，涉及到线程上下文的切换和调度，会消耗大量的CPU时间。</li></ul></li><li><p><strong><code>ReentrantLock</code></strong>：</p><ul><li><strong>实现</strong>：它是一个<strong>Java类</strong>，位于<code>java.util.concurrent.locks</code>包下。其核心是基于**AQS（AbstractQueuedSynchronizer）**框架实现的。</li><li><strong>开销</strong>：AQS在底层利用了<strong>CAS（Compare-And-Swap）*<em>这一CPU原子指令和*</em><code>volatile</code>**关键字。在**无竞争或低竞争</strong>的情况下，<code>ReentrantLock</code>可以通过CAS操作直接在用户态完成锁的获取，<strong>完全避免了内核态的切换</strong>，因此性能极高。</li></ul></li></ul><p><code>ReentrantLock</code>性能一定优于<code>synchronized</code>”这个说法，在JDK 1.6之前是成立的。但在1.6之后，JVM对<code>synchronized</code>进行了翻天覆地的优化，引入了**锁升级（Lock Escalation）**机制，使其性能在很多场景下已经不输甚至优于<code>ReentrantLock</code>。</p><ul><li><strong>偏向锁</strong>：在只有一个线程访问同步块的场景下，<code>synchronized</code>几乎没有同步开销，性能极高。</li><li><strong>轻量级锁</strong>：当出现少量线程交替竞争时，<code>synchronized</code>会使用**自旋（Spinning）**的方式尝试获取锁。自旋也是在用户态完成的，避免了线程阻塞和内核态切换，性能同样很高。</li><li><strong>重量级锁</strong>：只有当竞争非常激烈，自旋多次仍无法获取锁时，<code>synchronized</code>才会升级为重量级锁，退化到依赖操作系统的<code>Mutex Lock</code>。</li></ul><p>只不过ReetrantLock有更多的功能，</p><ul><li><strong>可中断等待</strong>：<code>lockInterruptibly()</code>允许线程在等待锁的过程中响应中断。</li><li><strong>可超时等待</strong>：<code>tryLock(long timeout, TimeUnit unit)</code>可以避免死等。</li><li><strong>多条件变量</strong>：一个<code>ReentrantLock</code>可以创建多个<code>Condition</code>对象，实现更精细的线程通信。</li></ul><h1>Mybatis</h1><h2 id="1-UserMappe这个类为啥要是接口呢？">1.UserMappe这个类为啥要是接口呢？</h2><p>MyBatis的Mapper之所以必须定义为接口，其根本原因在于MyBatis框架在底层使用了**JDK动态代理（JDK Dynamic Proxy）**技术，来为我们自动地生成这个接口的实现类。</p><p>只定义了<code>UserMapper</code>接口，并在XML文件中写了SQL，但我们<strong>从来没有手动编写过一个<code>class UserMapperImpl implements UserMapper</code></strong>。然而，在Service层，我们却可以直接<code>@Autowired</code>注入一个<code>UserMapper</code>的实例并调用它的方法。</p><ol><li><strong>启动时扫描</strong>：当Spring容器启动时，MyBatis的<code>MapperScannerConfigurer</code>会扫描指定的包路径（如<code>com.example.mapper</code>），找到所有被<code>@Mapper</code>注解标记的接口，或者所有继承了特定标记接口的接口。</li><li><strong>注册Bean定义</strong>：对于找到的每一个Mapper接口（比如<code>UserMapper.class</code>），MyBatis并不会去创建一个真实的实现类，而是在Spring容器中注册一个特殊类型的Bean定义——<code>MapperFactoryBean</code>。</li><li><strong>创建代理对象</strong>：当Service层需要注入<code>UserMapper</code>时，Spring会向<code>MapperFactoryBean</code>请求获取Bean实例。此时，<code>MapperFactoryBean</code>就会调用JDK动态代理，<strong>在内存中动态地生成一个<code>UserMapper</code>接口的代理实现对象</strong>。</li></ol><ul><li><p>“这个动态生成的代理对象，它的内部有一个<code>InvocationHandler</code>。当我们调用代理对象的任何方法时（比如<code>userMapper.selectById(1)</code>），这个调用都会被<code>InvocationHandler</code>拦截。”</p></li><li><p>InvocationHandler的逻辑大致是：”</p><ol><li>它会获取到我们调用的<strong>方法名</strong>（<code>selectById</code>）和<strong>参数</strong>（<code>1</code>）。</li><li>它会将方法名与Mapper XML文件中配置的SQL语句的<code>id</code>进行<strong>映射和绑定</strong>。</li><li>它会从连接池获取一个数据库连接，将参数设置到SQL语句中，然后通过JDBC执行这条SQL。</li><li>最后，它会将查询结果封装成我们方法签名中定义好的返回类型（如<code>User</code>对象），并返回。</li></ol><p>正是因为MyBatis依赖于<strong>JDK动态代理</strong>，而JDK动态代理技术本身就<strong>要求被代理的目标必须是一个接口</strong>。它无法为一个具体的类或抽象类创建代理。这就是为什么Mapper必须是接口的根本技术原因。</p></li></ul><h1>JVM</h1><h2 id="1-那有哪些对象是可以直接在栈上分配呢？">1.那有哪些对象是可以直接在栈上分配呢？</h2><p>在Java中，并不是特定<strong>类型</strong>的对象能够直接在栈上分配，而是取决于该对象的<strong>作用域</strong>。JVM通过一种叫做**“逃逸分析”（Escape Analysis）**的技术来判断一个对象是否可以安全地在栈上分配。</p><p>如果一个对象的引用没有“逃逸”出它被创建的方法之外，那么它就可能被优化为在栈上分配。这样做的好处是，当方法执行结束时，栈帧被弹出，对象的内存会立即被回收，无需等待垃圾回收（GC），从而提高性能。</p><ul><li><strong>逃逸分析是JIT（即时编译器）的一项优化技术，默认在现代JVM中是开启的。<strong>只有那些</strong>生命周期完全局限于单个方法调用</strong>内、<strong>体积较小</strong>且<strong>线程安全</strong>的对象，才最有可能被优化到栈上进行分配。</li></ul><p>未逃逸的定义：</p><ol><li><strong>仅在方法内部使用</strong>：对象的引用完全封装在方法体内，没有被方法返回。</li><li><strong>未赋值给外部变量</strong>：没有将该对象的引用赋值给任何类变量（<code>static</code>字段）或实例变量。</li><li><strong>未传递给可能逃逸的方法</strong>：没有将该对象的引用作为参数传递给其他方法，或者传递给了但能确定其他方法也不会让它“逃逸”。</li></ol><p>逃逸的例子：</p><p>比如对象作为方法的返回值，他就是逃离了这个方法的作用域</p><p>对象引用赋值给实例变量，也是逃离这个方法的作用域</p><h2 id="2-JMM和一个对象的生命周期">2.JMM和一个对象的生命周期</h2><p>JMM划分：</p><p>​线程共享：方法区 堆</p><p>​线程私有：程序计数器，虚拟机栈，本地方法栈</p><p>生命周期：</p><p>​创建： 类加载检查 -&gt; 堆内存分配（指针碰撞/空闲列表）-&gt; 初始化零值 -&gt; 设置对象头 -&gt; 执行 <code>init</code> 方法。</p><p>​进行使用</p><p>​回收：可达性分析 -&gt; 垃圾回收算法 -&gt; 分代回收(Minor GC, Full GC)</p><p>优化手段:</p><p>逃逸分析、栈上分配、TLAB（线程本地分配缓冲）等优化手段</p><p>逃逸分析、栈上分配和TLAB是JVM为了<strong>自动化地提升对象分配效率、降低GC压力</strong>而设计的一套<strong>协同工作的优化组合拳</strong></p><p>逃逸分析是决策入口，它决定了一个不逃逸的对象是否有资格享受<strong>栈上分配</strong>这一‘特权’，从而完全避免GC。对于必须在堆上分配的逃逸对象，<strong>TLAB</strong>则为它们提供了线程私有的‘VIP通道’，避免了并发分配时的锁竞争。</p><ol><li>当我们在代码中写下 <code>new User()</code> 时，这个<code>User</code>对象在JVM中并不是“无脑地”直接被分配到堆上。它会经历一个由JVM JIT（即时编译器）主导的、充满优化的“审批流程”</li><li><strong>逃逸分析</strong>：逃逸分析是一种<strong>编译期优化技术</strong>，它不是直接的优化手段，而是一种<strong>分析手段</strong>。JIT编译器会分析一个<strong>对象的动态作用域</strong>，判断这个对象是否有可能“逃逸”出它的创建方法或当前线程。</li><li>如果逃逸分析的结果是：<strong>“这个对象完全不逃逸！”</strong>，那么JVM就会启用一个颠覆性的优化。<strong>栈上分配</strong>是指将那些<strong>不逃逸的小对象</strong>，直接在**当前线程的虚拟机栈（Stack）<strong>上进行分配，而不是在</strong>堆（Heap）**上。</li><li>如果逃逸分析的结果是：<strong>“这个对象逃逸了，必须在堆上分配”</strong>，那么JVM并不会立刻去抢占全局的堆内存，而是会尝试一个更高效的策略。</li><li><strong>TLAB（线程本地分配缓冲）**是JVM为了**提升对象在堆上分配的效率</strong>而设计的一种机制。JVM会在堆的<strong>新生代（Eden区）**为**每个线程</strong>预先分配一小块<strong>私有的内存区域</strong>，这个区域就叫TLAB。<strong>避免并发冲突</strong>：堆是所有线程共享的。如果没有TLAB，那么每次<code>new</code>一个对象，多个线程都需要去<strong>竞争同一块Eden区的内存</strong>。这个过程需要<strong>加锁</strong>（比如CAS）来保证分配的原子性，在高并发下会成为性能瓶颈。</li><li>当一个线程需要分配一个新对象时，它会<strong>首先尝试在自己的TLAB中进行分配</strong>。</li><li>因为TLAB是线程私有的，所以在这个区域内分配对象<strong>完全不需要加锁</strong>，速度极快，这是一个简单的**指针碰撞（Bump the Pointer）**操作。</li><li>只有当<strong>TLAB的空间用完了</strong>，或者要分配的<strong>对象太大TLAB放不下</strong>时，线程才会去申请一个新的TLAB，或者在全局的Eden区（此时需要加锁）进行分配。</li><li>然后在堆中是如何分配的呢？</li></ol><p>内存分配方式：**主要有两种——**指针碰撞（Bump the Pointer）**和**空闲列表（Free List）。如果堆内存是规整的，就用指针碰撞（简单高效）；如果是不规整的（比如使用 CMS 收集器后），就用空闲列表。</p><p>并发处理：在多线程并发创建对象时，如何保证堆上分配的线程安全？除了你提到的 <strong>TLAB</strong>（每个线程预先在 Eden 区申请一小块私有区域），另一种方式是对<strong>整个堆的分配动作进行 CAS 加锁</strong>。TLAB 是为了避免频繁的 CAS 加锁，是一种更高效的优化。</p><p>除了这些JMM内还有一个优化的策略就是堆外内存，它是一种<strong>手动管理</strong>的内存区域，不属于JVM GC的管理范畴。</p><p>通过NIO的<code>ByteBuffer.allocateDirect()</code>方法分配的内存。这块内存并不在Java堆上，而是直接向操作系统申请的本地内存。</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">堆内存 (Heap)</th><th style="text-align:left">堆外内存 (Off-Heap)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>管理者</strong></td><td style="text-align:left">JVM (GC自动管理)</td><td style="text-align:left">开发者 (手动管理) / <code>Cleaner</code>机制</td></tr><tr><td style="text-align:left"><strong>分配速度</strong></td><td style="text-align:left">快 (TLAB)</td><td style="text-align:left">慢 (系统调用)</td></tr><tr><td style="text-align:left"><strong>访问速度</strong></td><td style="text-align:left">快</td><td style="text-align:left">极快 (与I/O交互时)</td></tr><tr><td style="text-align:left"><strong>GC影响</strong></td><td style="text-align:left">受GC影响，可能STW</td><td style="text-align:left"><strong>不受GC影响</strong></td></tr><tr><td style="text-align:left"><strong>大小限制</strong></td><td style="text-align:left">受<code>-Xmx</code>参数限制</td><td style="text-align:left">受物理内存限制</td></tr></tbody></table><p>我们可以使用他来完成零拷贝的操作</p><ul><li>当进行网络或文件I/O操作时，如果数据在堆内存中，需要先从<strong>堆内存拷贝到内核缓冲区</strong>，再由操作系统发送出去。</li><li>如果数据直接在堆外内存中，JVM可以直接将这块内存的地址交给操作系统，省去了从用户态到内核态的这次数据拷贝，实现了**“零拷贝”**，极大地提升了I/O性能。</li></ul><p>使用：</p><ul><li><strong>Netty</strong>、<strong>RocketMQ</strong>等高性能网络/消息框架，大量使用堆外内存作为网络通信的缓冲区。</li><li>需要缓存大量数据，且不希望对GC造成巨大压力的场景（例如，本地缓存框架）。</li><li>但是,容易出现内存泄漏和排查困难的问题</li></ul><p><strong>如何定位和分析</strong>内存问题的?</p><p>通过监控工具如 Arthas, VisualVM, 或者日志,通过 <code>jmap</code> dump 堆内存，再用 MAT 等工具分析,是优化了数据结构减少内存占用，还是调整了 JVM 参数，比如 <code>-Xmx</code>, <code>-Xms</code></p><p>回收：</p><p>每个对象从诞生之初，JVM就在它的**对象头（Object Header）**里，为它设置了一个‘年龄计数器’（Age），占4个bit。这个‘年龄’是对象晋升老年代的主要依据</p><ul><li>绝大多数新创建的对象，首先会被分配在新生代的<strong>Eden区</strong>。此时，它们的<strong>年龄为0</strong>。</li><li>当Eden区满了之后，会触发第一次<strong>Minor GC</strong>。</li><li>GC会扫描Eden区，将所有<strong>存活的对象</strong>复制到新生代的<strong>Survivor区中的一个（我们称之为To-Survivor区）</strong>。</li><li>在这个复制的过程中，这些幸存对象的<strong>年龄会加1</strong>。</li><li>Eden区中所有未被复制的（被判定为垃圾的）对象，都会被一次性清空。</li><li>新生代有两个Survivor区，我们通常称之为<code>S0</code>和<code>S1</code>。在任何时刻，总有一个是空的（To-Survivor），另一个是有数据的（From-Survivor）。</li><li>当<strong>下一次Minor GC</strong>发生时，GC会同时扫描<strong>Eden区</strong>和<strong>From-Survivor区</strong>（即上次存放幸存对象的那个区）。</li><li>所有存活的对象，都会被<strong>再次复制</strong>到那个空的<strong>To-Survivor区</strong>。</li><li>同样，在复制过程中，这些对象的<strong>年龄会再次加1</strong>。</li><li>清空Eden区和From-Survivor区。然后，<code>S0</code>和<code>S1</code>的角色互换，为下一次GC做准备。</li><li>这个过程会一直重复。对象就在<code>S0</code>和<code>S1</code>之间来回“倒腾”，每经历一次Minor GC，只要它还活着，年龄就会加1。</li><li>当一个对象在Survivor区中不断地“倒腾”，其年龄<strong>达到一个设定的阈值</strong>时，在下一次Minor GC中，它将不再被复制到另一个Survivor区，而是被<strong>直接晋升（Promote）到老年代</strong>。</li><li>这个年龄阈值可以通过JVM参数<code>-XX:MaxTenuringThreshold</code>来设置。默认是15，因为对象头中的年龄计数器只有4个bit，最大能表示的数字就是15（二进制<code>1111</code>）。</li></ul><p>一个新生代的晋升流程Eden -&gt; S0 -&gt; S1 -&gt; … -&gt; Old，年龄为15的时候进入老年代</p><p>除了年龄达到阈值，还有一种情况会触发晋升：如果在 Survivor 区中，<strong>相同年龄的所有对象大小的总和，大于 Survivor 空间的一半</strong>，那么<strong>年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无需等到 <code>MaxTenuringThreshold</code>。这个规则是为了<strong>防止Survivor区被过度填充</strong>。如果大量同龄的对象在某次GC后集中幸存，可能会导致Survivor区空间不足，进而触发更复杂的分配担保机制。动态年龄判断可以在这种情况发生前，提前将一些“年长”的对象送到老年代，为更“年轻”的对象腾出空间。</p><p>大对象直接晋升，这个对象的大小超过了由<code>-XX:PretenureSizeThreshold</code>参数设定的阈值，那么这个大对象将<strong>不会</strong>被分配在新生代的Eden区，而是会被<strong>直接分配到老年代</strong>。</p><p>在执行Minor GC之前，JVM会检查<strong>老年代的连续可用空间</strong>是否<strong>大于新生代所有对象的总大小</strong>（或者大于历次晋升到老年代的对象的平均大小）。</p><ul><li>如果<strong>是</strong>，那么这次Minor GC是安全的。如果<strong>否</strong>，JVM会进行一次<strong>Full GC</strong>来清理老年代，以腾出更多空间。</li><li>如果在Minor GC过程中，Survivor区确实无法容纳所有存活对象，那么多余的对象就会通过这个<strong>分配担保机制，被直接移入老年代</strong>。</li></ul><h2 id="3-GC">3.GC</h2><p>对象死亡的三个方法，引用计数器，可达性分析，finalize方法，可达性分析需要两次标记，第一次看是不是没用跟引用链相连，第二次看队列中的是不是还没有相连</p><p>CMS 选择标记-清除的核心原因是，它是一个**并发（Concurrent）**收集器，在垃圾收集的大部分阶段，<strong>用户线程（Mutator）和 GC 线程是可以同时运行的</strong>。而标记-整理算法需要移动对象，这个过程非常复杂，很难与用户线程并发执行，所以 CMS 只能选择实现相对简单的标记-清除。这也正是 CMS 产生内存碎片的根本原因。</p><p>CMS 的核心优势恰恰在于它的<strong>并发标记（Concurrent Mark）**和**并发清除（Concurrent Sweep）*<em>阶段，是*<em>可以和用户线程一起运行的</em></em>，从而大大缩短了 STW 时间。CMS 的 STW 主要发生在</strong>初始标记（Initial Mark）**和**重新标记（Remark）*<em>这两个非常短暂的阶段。你应该强调 CMS 的 STW **总时长很短**，但*<em>不可预测</em></em>；</p><p>而 G1 的 STW 虽然也是分阶段的，但其<strong>总时长可以在一个目标范围内被预测和控制</strong>。</p><h1>JavaSE</h1><h2 id="1-流式输出和非流式输出">1.流式输出和非流式输出</h2><table><thead><tr><th>对比点</th><th>流式输出</th><th>非流式输出</th></tr></thead><tbody><tr><td><strong>数据传输</strong></td><td>边生产边传输</td><td>生成完后一次传输</td></tr><tr><td><strong>响应延迟</strong></td><td>首字节快，用户能尽快看到结果</td><td>必须等所有数据生成后才能看到</td></tr><tr><td><strong>内存占用</strong></td><td>占用更少内存（分段处理）</td><td>可能占用大量内存（一次性加载）</td></tr><tr><td><strong>实现复杂度</strong></td><td>较高（需要支持分段协议/推送机制）</td><td>较低（一次性返回）</td></tr><tr><td><strong>应用场景</strong></td><td>视频流、日志实时消费、AI Chat逐字打印</td><td>小文件下载、查询一次性返回结果</td></tr></tbody></table><p>非流式输出是等数据全部生成后一次性返回，而流式输出则是边生成边返回，能降低延迟和内存占用，更适合大数据量和实时场景。</p><h2 id="2-HashMap-remove-方法的实现细节">2.<strong>HashMap <code>remove</code> 方法的实现细节</strong></h2><ol><li>首先，<code>remove(key)</code>方法会计算<code>key</code>的<code>hash</code>值。</li><li>根据<code>hash</code>值定位到它在底层<code>table</code>数组中的索引位置（即bucket）。</li><li>如果该bucket为空，直接返回<code>null</code>。</li><li>如果bucket不为空，则遍历该位置的链表或红黑树，逐个节点使用<code>hash</code>值和<code>equals()</code>方法进行比较，直到找到要删除的目标节点。如果遍历完没找到，也返回<code>null</code>。</li></ol><p><strong>如果当前是链表结构</strong>,是头节点的话，即让头节点的下一个节点成为新的头节点。</p><p><strong><code>p</code>是中间节点或尾节点</strong>。那么就跳过这个节点，GC将自动回收这个不再被引用的节点</p><ul><li>红黑树的删除操作要复杂得多，因为它必须在删除节点后，通过一系列的**旋转（Rotation）和重新着色（Recoloring）*<em>操作，来*<em>维持红黑树的5条性质</em></em>（例如，根是黑的、不能有连续的红节点、任何节点到其每个叶子节点的所有路径都包含相同数目的黑色节点等），从而保证树的平衡性。</li><li><code>HashMap</code>会调用内部的<code>removeTreeNode</code>方法来执行这个复杂的过程。</li><li>在红黑树中删除了一个节点后，<code>HashMap</code>还会检查该bucket的节点数量。如果数量减少到了一个<strong>阈值（UNTREEIFY_THRESHOLD，默认为6）</strong>，为了节省内存和在节点数少时提升性能，这棵红黑树会**退化（untreeify）**变回普通的链表结构。</li><li>删除成功后，<code>HashMap</code>的<code>size</code>会减1。</li><li>方法会返回被删除节点的<code>value</code>值。</li></ul><h2 id="3-说说-ArrayList、LinkedList、CopyOnWriteArrayList-这三者的适用场景与关键差异">3.说说 <strong>ArrayList、LinkedList、CopyOnWriteArrayList</strong> 这三者的适用场景与关键差异</h2><p><strong>1. ArrayList:</strong></p><ul><li><strong>底层结构:</strong> 基于<strong>动态数组</strong>实现，内存是连续的。它实现了 <code>RandomAccess</code> 标记接口。</li><li>关键差异:<ul><li><strong>读性能:</strong> 支持高效的随机访问，<code>get(index)</code> 操作的时间复杂度是 O(1)。</li><li><strong>写性能:</strong> 尾部添加（<code>add(e)</code>）均摊复杂度是 O(1)，但<strong>在中间插入或删除元素，需要移动后续所有元素，时间复杂度是 O(n)</strong>，开销很大。</li></ul></li><li><strong>迭代一致性:</strong> 它的迭代器是**快速失败（Fail-fast）**的。如果在迭代过程中，集合结构被其他线程修改，会立刻抛出 <code>ConcurrentModificationException</code>。</li></ul><p><strong>2. LinkedList:</strong></p><ul><li><strong>底层结构:</strong> 基于<strong>双向链表</strong>实现。</li><li>关键差异:<ul><li><strong>读性能:</strong> 不支持高效的随机访问，访问一个元素需要从头或尾遍历，时间复杂度是 O(n)。</li><li><strong>写性能:</strong> <strong>在头部或尾部进行增删操作，时间复杂度是 O(1)</strong>，效率极高。但在中间位置操作，需要先遍历定位，所以复杂度也是 O(n)。</li></ul></li><li><strong>迭代一致性:</strong> 和 ArrayList 一样，是**快速失败（Fail-fast）**的。</li></ul><p><strong>3. CopyOnWriteArrayList (COWArrayList):</strong></p><ul><li><strong>底层结构:</strong> 同样基于<strong>数组</strong>。</li><li>关键差异:<ul><li><strong>并发安全:</strong> 它是<strong>线程安全</strong>的，核心思想是“<strong>写时复制</strong>”。</li><li><strong>读性能:</strong> 读操作<strong>完全不加锁</strong>，直接访问底层数组，性能和 ArrayList 相当，非常高效。</li><li><strong>写性能:</strong> 写操作（增删改）<strong>开销巨大</strong>。它需要先加锁，然后<strong>完整地拷贝一份新数组</strong>，在新数组上修改，最后再将引用指向新数组。</li></ul></li><li><strong>迭代一致性:</strong> 它的迭代器是**快照（Snapshot）**模式。迭代器创建时会引用当时的底层数组快照，后续的修改对该迭代器不可见，<strong>不会抛出异常</strong>，保证了迭代的绝对安全，但牺牲了数据的实时性。</li></ul><h2 id="4-反射的原理-应用">4.反射的原理&amp;&amp;应用</h2><p>反射机制允许程序在<strong>运行时</strong>动态地获取任意一个类的信息（如属性、方法、构造器）并进行操作。它的优点是极大地增加了程序的灵活性，是很多框架（如 Spring IoC）的实现基石。</p><p>在 <strong>JDK 动态代理</strong>中，反射主要用在最关键的一步——<strong>创建代理对象实例</strong>。</p><p>整个流程是：我们调用 <code>Proxy.newProxyInstance()</code> 方法来创建代理对象。在这个方法内部，它会：</p><ol><li>在运行时动态地创建一个新的代理类（<code>.class</code> 文件）。</li><li>然后，它会使用<strong>反射</strong>，通过 <code>proxyClass.getConstructor(InvocationHandler.class)</code> 获取到这个新代理类的构造器。</li><li>最后，再通过<strong>反射</strong>调用 <code>constructor.newInstance(invocationHandler)</code>，传入我们自己实现的 <code>InvocationHandler</code>，来<strong>实例化</strong>这个代理对象。</li><li>比如代理模式的实现就是在对象进行初始化的时候，在bootpostproffer的后置处理的时候，将原先的bean换成我们代理的bean</li></ol><p>所以，反射是用在了<strong>获取代理类的构造器并创建其实例</strong>这最核心的一步。</p><h1>Mysql</h1><h2 id="1-多表join的时候，小表驱动大表">1.多表join的时候，小表驱动大表</h2><p>在Mysql的 Nested Loop Join 中</p><p><strong>驱动表（outer table）</strong>：首先被扫描的表。</p><p><strong>被驱动表（inner table）</strong>：对驱动表每一行，根据 Join 条件去查找匹配行的表。</p><p><strong>核心原则</strong>：过滤后剩余行数少的表，应该作为驱动表，这样可以减少被驱动表的访问次数。这就是小表</p><p>执行过程：</p><p>扫描驱动表（全表扫描或索引扫描）。</p><p>对驱动表的每一行，根据连接条件在被驱动表中查找（通常用索引 B+Tree 查找）。</p><p>如果被驱动表使用二级索引且需要回表，则访问主键索引。</p><p>小表驱动大表，大表负责命中索引。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A straight_join B on A.a = B.a;</span><br></pre></td></tr></table></figure><p>数据库会全表扫A，然后每拿到一行就去比较条件 A.a=B.a，去B表里面查，B表命中索引的查询。实际上就是一个搜索树，查询的时间复杂度近似log2^B^，然后加上一次回表，可能就是2Log2 ^B^,所以总体的时间复杂度为A+2log2^B^*A，如果是覆盖索引的话，复杂度可降为 O(A + log₂(B) × A)</p><p>所以我的们A越小越好，join的本质就是查驱动表，然后扫被驱动表，当然是查的越少越好了</p><h2 id="2-一条-UPDATE-语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理">2.一条 <code>UPDATE</code> 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理</h2><p>Mysql是一个分层的，核心模块包括网络层、SQL层和存储引擎层。</p><p>如果以一条 <code>UPDATE t SET c = 2 WHERE id = 1;</code> 语句为例，它的生命周期是这样的：</p><p>网络层：</p><p>首先，客户端通过TCP连接发送这条SQL。我的网络模块基于Java NIO实现，会接收这个请求，并将其传递给SQL层。</p><p>SQL层 - 解析与执行：</p><ul><li><strong>SQL解析器</strong>：SQL层会解析这条字符串，生成一个抽象语法树（AST）。</li><li><strong>执行器</strong>：然后，执行器会解释这棵树。对于这条<code>UPDATE</code>语句，它知道要去表<code>t</code>中找到<code>id=1</code>的行，并更新<code>c</code>列。</li></ul><p>存储引擎层 - 事务与数据处理：这是最核心的部分。</p><ul><li><strong>事务管理器</strong>：执行器会向事务管理器申请开启一个事务。</li><li><strong>访问数据</strong>：执行器请求存储引擎去获取<code>id=1</code>的行。存储引擎会先去 <strong>Buffer Pool</strong>（内存缓冲池）里查找，如果数据页不在内存，会通过 <strong>IO模块</strong> 从磁盘加载。</li><li><strong>并发控制</strong>：在读取和修改数据时，为了保证隔离性，这里会涉及到 <strong>MVCC</strong> 和 <strong>锁管理器</strong>。<code>UPDATE</code> 是一种“当前读”，所以它会读取最新的已提交版本，并在这行数据上加一个 <strong>排他锁（X Lock）</strong>，防止其他事务同时修改。</li><li><strong>执行修改</strong>：获取到锁之后，执行器会在 Buffer Pool 中修改对应的数据页。但它不是直接覆盖旧数据，而是会生成一个 <strong>undo日志</strong>，记录下修改前的样子，用于回滚和支持MVCC。</li><li><strong>记录日志</strong>：在修改内存数据页之前，必须先将这次操作的详细信息写入 <strong>redo日志（WAL）</strong> 的内存缓冲区。这是为了保证持久性。</li><li><strong>提交事务</strong>：当客户端发起 <code>COMMIT</code> 时，<strong>日志管理器</strong> 会确保对应的 redo 日志被刷入磁盘。只要 redo 日志落盘了，即使此时宕机，数据也能恢复，所以我们就可以认为事务提交成功了。</li><li><strong>数据落盘</strong>：至于 Buffer Pool 里的脏数据页，则由一个后台线程根据一定的策略（比如LRU）异步地刷回磁盘，这个过程不影响事务的提交响应。</li></ul><h2 id="3-为什么选择-WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？">3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？</h2><p>选择 WAL 的核心优势在于<strong>将随机IO转换为了顺序IO，极大地提升了写入性能并保证了数据不丢失</strong>。</p><ul><li><strong>性能提升</strong>：数据库的数据页在磁盘上是离散存储的，修改它们需要大量的随机磁盘寻址，非常慢。而日志文件是追加写入的，是顺序IO，速度比随机IO快几个数量级。通过 WAL，事务提交时只需要保证日志落盘即可，脏数据页可以异步、批量地刷回磁盘，大大降低了事务提交的延迟。</li><li>顺序保证：这个顺序是绝对不能颠倒的，必须是先写日志（Log），再更新内存页（Buffer Pool）。这就是“Write-Ahead Logging”（预写日志）这个名字的由来。<ul><li><strong>原因</strong>：如果反过来，先修改了内存中的数据页，然后系统在写日志之前宕机了。那么当系统重启时，内存中的修改会全部丢失，而日志里又没有记录这次操作，这个更新就永远地丢失了，这违反了事务的<strong>持久性（Durability）</strong>。而只要保证日志先写入，即使系统在数据页刷盘前宕机，重启后也可以通过扫描 redo 日志来恢复数据，保证了数据的完整性。”</li></ul></li></ul><h2 id="4-当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？">4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？</h2><p>当向一个叶子节点插入数据，发现它已经满了的时候，会触发分裂操作，逻辑如下：</p><ol><li><strong>叶子节点分裂：</strong> 找到中间位置的 key，将节点平分成两个。将这个中间 key <strong>连同指向新节点的指针</strong>一起“上提”到父节点中。</li><li><strong>内部节点分裂：</strong> 如果因为子节点的“上提”导致父节点也满了，那么父节点（内部节点）也需要分裂。找到中间位置的 key，将该 key <strong>单独</strong>“上提”到它的父节点中，而该 key 左右两侧的 key 和指针则分别构成两个新的内部节点。这个过程可能会一直递归到根节点。</li><li><strong>根节点分裂：</strong> 如果根节点也需要分裂，那么分裂后会产生一个新的根节点，此时 B+ 树的<strong>高度加一</strong>。</li></ol><p>关于并发问题，这是一个非常关键的点。对B+树的这种结构性修改（如分裂或合并）必须是原子的，否则可能导致树的结构被破坏。</p><ul><li>当一个线程需要修改一个B+树节点时，它会先获取这个节点的 Latch。在分裂过程中，它会同时持有父节点和要分裂的子节点的 Latch，操作完成后再释放。这种方式只锁定了必要的节点，允许其他不相关的读写操作继续进行。</li></ul><p>Lock 和 Latch 区别</p><ul><li><strong>保护对象</strong>：<strong>Lock（锁）</strong> 是在<strong>事务层面</strong>，用来保护<strong>逻辑数据</strong>，比如表中的一行记录。它的目的是保证事务的隔离性。<strong>Latch（闩锁）</strong> 是在<strong>线程层面</strong>，用来保护<strong>内存中的物理数据结构</strong>，比如 Buffer Pool 中的一个数据页、B+树的一个节点或者一个共享的内存链表。它的目的是保证多线程访问共享内存结构时的线程安全。</li><li><strong>持有时间</strong>：<strong>Lock</strong> 的持有时间很长，可能会贯穿整个事务，直到事务提交或回滚才释放。<strong>Latch</strong> 的持有时间非常短，通常只在一次原子操作的临界区内持有，比如修改一个 B+ 树节点，操作一完成马上就释放。</li><li><strong>死锁</strong>：<strong>Lock</strong> 会涉及到死锁问题，需要数据库有专门的死锁检测机制。而 <strong>Latch</strong> 通常通过规定获取顺序（比如在B+树中总是从父节点到子节点获取）来避免死锁，所以一般认为 Latch 是无死锁的。</li></ul><p>简单来说，Lock 是给数据库用户（事务）用的，保证业务逻辑的正确性；Latch 是给数据库内核开发者用的，保证内核数据结构的正确性。”</p><p>为什么选择B+树？在IO上看</p><ol><li><ul><li><strong>关键在于“高扇出” (High Fan-out)：</strong> 数据库的数据是存储在磁盘上的，I/O 操作非常昂贵。我们需要一种“矮胖”的数据结构，而不是“瘦高”的。</li><li><strong>平衡二叉树为什么不行？</strong> 因为它是二叉的，每个节点最多两个子节点。一棵存储百万数据的 AVL 树，深度会非常高（约 log₂(n)），导致需要进行很多次磁盘 I/O 才能找到数据。</li><li><strong>B+ 树为什么行？</strong> B+ 树的<strong>非叶子节点只存储索引（key）而不存储数据（data）</strong>。这意味着在同样大小的磁盘页（比如 16KB）中，B+ 树的非叶子节点可以存放<strong>成百上千个索引指针</strong>，这就是“高扇出”。因此，一棵三到四层的 B+ 树就能存储上千万甚至上亿的数据，查询时只需要 3-4 次磁盘 I/O。</li><li><strong>B 树相比 B+ 树的劣势：</strong> B 树的非叶子节点也存数据，导致其“扇出”没有 B+ 树那么高，树的高度会相对更高，I/O 次数更多。</li></ul></li><li><strong>哈希表的另一个致命缺点：</strong> 除了哈希冲突，哈希索引<strong>不支持范围查询</strong>。而数据库中 <code>WHERE age &gt; 20</code> 这样的范围查询非常普遍，这是 B+ 树的叶子节点通过双向链表连接起来所能高效支持的。</li></ol><h2 id="5-慢查询的的过程">5.慢查询的的过程</h2><ul><li><strong>第一步：开启慢查询日志。</strong> 在 MySQL 中配置 <code>slow_query_log</code> 和 <code>long_query_time</code>，让数据库自动记录超过阈值的慢 SQL。</li><li><strong>第二步：分析慢查询日志。</strong> 使用 <code>mysqldumpslow</code> 等工具，对日志文件进行分析，找出出现频率最高、查询时间最长的 SQL。</li><li><strong>第三步：使用 <code>EXPLAIN</code> 分析执行计划。</strong> 针对找到的慢 SQL，使用 <code>EXPLAIN</code> 查看其执行计划，重点关注 <code>type</code>（是否为 <code>ALL</code> 全表扫描）、<code>key</code>（是否用上了索引）、<code>Extra</code>（是否出现了 <code>Using filesort</code>, <code>Using temporary</code>）等关键字段。</li></ul><p>通过在 xxx 字段上增加联合索引，并利用索引覆盖，我们将这条 SQL 的查询时间从 2 秒优化到了 50 毫秒，接口的 P99 响应时间也从 2.2 秒降低到了 200 毫秒。</p><h2 id="6-SQL">6.SQL</h2><p>1.查询前xxx</p><ul><li>使用limit</li><li>使用rank函数，<code>ROW_NUMBER()</code>: 不考虑并列，给出连续排名 (1, 2, 3, 4)。<code>RANK()</code>: 考虑并列，但会跳过排名。比如两个第二名，下一个就是第四名 (1, 2, 2, 4)。<code>DENSE_RANK()</code>: 考虑并列，且不跳过排名 (1, 2, 2, 3)。 在“取 Top N”的场景下，<code>RANK()</code> 或 <code>DENSE_RANK()</code> 通常是更合适的选择。</li></ul><h1>Redis</h1><h2 id="1-多级缓存数据一致性与失败回滚">1.<strong>多级缓存数据一致性与失败回滚</strong></h2><p>当被问及如何保证Redis和本地缓存更新的原子性，以及在更新失败时如何回滚，你的回答提到了不甚准确的“编程式事务”，并最终倾向于人工处理。</p><p>方案1：<strong>引入消息队列（MQ）进行可靠的异步处理</strong></p><ol><li>修改架构：Canal不再直接调用消费逻辑，而是将解析后的binlog事件作为消息发送到MQ的一个Topic中。</li><li>消费者逻辑：消费者服务从MQ拉取消息。其处理逻辑是：先失效Redis缓存，再发布一个广播消息（如通过Redis Pub/Sub）通知所有应用实例失效本地Caffeine缓存。</li><li>失败处理：只有当所有步骤成功后，消费者才向MQ发送ACK。如果处理过程中任何一步失败（如Redis连接超时），消费者不发送ACK。MQ会在超时后将该消息重新投递给其他消费者，实现自动重试。</li></ol><p>方案2 死信队列</p><ol><li>在Canal的消费者逻辑中，使用<code>Spring Retry</code>等框架对缓存失效操作进行封装。</li><li>配置重试策略，例如重试3次，每次间隔采用指数退避（如1s, 2s, 4s），避免在故障期间频繁冲击下游服务。</li><li>配置一个<code>RecoveryCallback</code>。当所有重试都失败后，将这条失败的binlog事件（包含表名、主键、操作类型等信息）发送到一个专门的**死信队列（Dead Letter Queue）**或记录到数据库的失败任务表中。</li><li>部署一个独立的监控程序或定时任务，消费DLQ中的消息，并发送告警（邮件、短信、钉钉）。</li></ol><p>如果重试逻辑设计不当，可能会在短时间内放大故障。死信队列需要有完善的监控，否则会成为被遗忘的角落。</p><p>方案3 <strong>先更新缓存，再更新数据库”的策略</strong></p><ol><li>写请求：先更新（或失效）Redis缓存，然后更新数据库。</li><li>为了解决并发更新导致的不一致问题，可以引入“延时双删”：先删缓存 -&gt; 更新数据库 -&gt; 延迟一段时间（如500ms）后再次删除缓存。</li><li>本地Caffeine缓存仍然可以通过监听Redis的key失效事件（Keyspace Notifications）或消息广播来同步失效。</li></ol><p><strong>非常不推荐</strong>。延时双删的延迟时间很难确定，无法100%保证一致性。代码侵入性强，业务逻辑与缓存逻辑耦合严重，维护困难。</p><h2 id="2-什么情况下，就是两个线程会持有同一把锁">2.什么情况下，就是两个线程会持有同一把锁</h2><p><strong>两个不同的线程在同一时刻是不可能持有同一把锁的</strong>，这是锁的<strong>互斥性</strong>基本原则所保证的。如果出现了这种情况，那一定是锁的实现出了严重的问题。</p><p>您这个问题可能是在考察一个非常重要的特性——<strong>锁的可重入性</strong>。可重入性指的是<strong>同一个线程</strong>可以多次成功获取同一把锁，而不会自己把自己锁死。在释放锁时，也需要释放相应次数后，锁才会被真正释放。”</p><p>比如：在一个复杂的业务方法A中，它获取了锁。然后它又调用了另一个方法B，而方法B也需要获取同一个锁。如果没有可重入性，那么在方法B中，当前线程会因为无法获取一个已经被自己持有的锁而陷入死锁。</p><p>实现：Redisson巧妙地使用了Redis的<strong>Hash数据结构</strong>来实现。</p><ul><li>当一个线程第一次获取锁时，它会在Redis中创建一个Hash。这个Hash的Key是锁的名称（例如<code>myLock</code>）。</li><li>这个Hash结构内部会存储两个关键信息：<ul><li>一个field存储<strong>持有锁的线程标识</strong>（例如，UUID + ThreadId）。</li><li>另一个field存储一个<strong>计数器</strong>，表示该线程重入的次数，初始值为1。</li></ul></li><li>当同一个线程<strong>再次</strong>尝试获取这把锁时，Redisson会检查Hash中存储的线程标识。如果与当前线程标识匹配，它就不会阻塞，而是直接将计数器的值加1，表示又重入了一次。</li><li>当线程<strong>释放锁</strong>时，它会去将计数器减1。只有当计数器的值减到0时，Redisson才会真正地从Redis中删除这个Hash（即释放锁），这样其他线程才有机会获取。</li></ul><h2 id="3-如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？">3.<strong>如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？</strong></h2><p>您提的这个问题非常关键，它涉及到整个数据同步链路的<strong>高可用性</strong>。</p><ol><li><strong>Canal自身的高可用</strong>：首先，Canal自身是可以部署成<strong>高可用集群</strong>的。通过Zookeeper进行集群管理和主备选举，当主节点宕机时，备用节点可以自动接管，从而保证了数据订阅服务的连续性。</li><li><strong>链路中断的影响</strong>：如果Canal到消费端的链路中断，确实会导致缓存与数据库在中断期间的<strong>数据不一致窗口期变长</strong>。新写入的数据无法触发缓存失效，用户可能会在一段时间内读到旧的缓存数据。</li><li><strong>我们的容灾与补偿策略</strong>：<ul><li><strong>监控与告警</strong>：我们必须对Canal的消费位点（Position）与MySQL主库的最新binlog位点之间的<strong>延迟</strong>做严格的监控。一旦延迟超过阈值（比如1分钟），就立即触发高级别告警，通知SRE和开发团队介入。</li><li><strong>设置合理的缓存TTL</strong>：即使同步链路中断，我们缓存中的数据也不是永久有效的。通过为所有缓存设置一个合理的<strong>兜底过期时间（TTL）</strong>，比如1小时，可以保证即使在最坏的情况下，数据不一致的时间也不会无限延长。这是一种<strong>自愈机制</strong>。</li><li><strong>手动全量/增量校准</strong>：对于极端重要的数据，我们会准备一个<strong>手动触发的数据校准脚本</strong>。当链路长时间中断并恢复后，可以运行这个脚本，根据时间戳或版本号，主动查询数据库，强制刷新Redis中的核心数据，确保最终一致性。”</li></ul></li></ol><h2 id="4-你提到用Redis的Pub-Sub来广播失效Caffeine本地缓存。">4.<strong>你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。</strong></h2><p><strong>Pub/Sub是‘fire-and-forget’（即发即忘）模式，不保证消息必达。如果某个应用实例因为网络抖动没收到失效消息，怎么办？</strong></p><p>您观察得非常仔细，Pub/Sub确实存在消息丢失的风险。对于这个问题，我们有分层级的解决方案</p><ol><li><strong>接受短暂不一致</strong>：对于大部分业务场景，单台服务器上短暂的本地缓存不一致是可以接受的。因为流量通常会通过负载均衡打到多台服务器上，只有一小部分用户请求会命中这台机器的旧缓存，且Caffeine本身也有过期机制，影响是可控的。</li><li><strong>引入更可靠的消息总线</strong>：如果业务对一致性要求极高，我们会放弃轻量级的Pub/Sub，转而使用<strong>更可靠的消息中间件（如RocketMQ）的广播消费模式</strong>。每个应用实例都作为一个消费者组内的广播消费者，订阅失效通知。MQ的ACK机制可以保证每个实例都可靠地收到失效消息。</li><li><strong>版本号机制</strong>：我们可以在缓存的对象中增加一个<strong>版本号或时间戳字段</strong>。当应用从缓存中获取到数据后，可以（在某些关键操作前）与数据库中的版本号进行一次快速比对。如果发现缓存版本落后，就主动失效本地缓存并重新加载。这是一种<strong>主动校验</strong>的补偿机制。”</li></ol><h2 id="5-缓存三问题">5.缓存三问题</h2><p><strong>布隆过滤器和缓存空值，这两种方案在你的项目中，你会如何选择？它们各自有什么优缺点和需要注意的地方？</strong></p><p><strong>方案一：缓存空值（Cache Null Values）</strong></p><ul><li><p>优点：</p><ul><li><strong>实现简单</strong>：逻辑清晰，开发和维护成本极低。</li><li><strong>效果直接</strong>：能100%拦截住对同一个不存在的key的重复攻击。</li></ul></li><li><p>缺点与注意事项：</p><ul><li><strong>消耗额外的缓存空间</strong>：如果被恶意攻击，攻击者不断变换不存在的key来查询，会导致Redis中存储大量的空值key，造成内存浪费。</li><li><strong>数据一致性问题</strong>：如果这个之前不存在的数据，后来又在数据库中被创建了（例如，一个新用户注册了），缓存中的空值需要有一种机制被及时地更新或失效，否则会导致用户刚注册完却查不到自己的信息。</li></ul><p>适用于<strong>不存在的key的集合相对固定，或者重复查询率高</strong>的场景。例如，查询一个已经下架的商品</p></li></ul><p><strong>方案二：布隆过滤器（Bloom Filter）</strong></p><ul><li>优点：<ul><li><strong>空间效率极高</strong>：它使用位图（bitmap）来存储数据，占用的内存空间远小于缓存空值方案，非常适合处理海量数据。</li></ul></li><li>缺点与注意事项：<ul><li><strong>存在误判率（False Positive）</strong>：布隆过滤器判断“不存在”是100%准确的，但判断“存在”时，有一定概率会把一个不存在的key误判为存在。这意味着它无法完全拦截所有穿透请求，会有一小部分漏网之鱼打到数据库。</li><li><strong>无法删除元素</strong>：标准的布隆过滤器不支持删除操作。如果数据需要频繁地增删，就需要使用Counting Bloom Filter等变种，实现更复杂。</li><li><strong>初始化和重建成本</strong>：需要在系统启动时，将全量数据加载到布隆过滤器中，这个过程可能比较耗时。当数据发生变化时，也需要有机制来同步更新过滤器。</li></ul></li><li><strong>适用场景</strong>：适用于<strong>数据量巨大，但数据相对稳定，且对误判率有一定容忍度</strong>的场景。例如，防止恶意用户用随机生成的ID来攻击用户查询接口。</li></ul><h2 id="6-用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用-Redis，你会选择哪种数据结构来实现">6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现</h2><p>方案1：使用String</p><p>Redis的<code>INCR</code>命令是原子性的，可以保证在并发环境下计数的准确性。<code>EXPIRE</code>命令可以为一个key设置生存时间（TTL），完美地契合了“10分钟之内”这个时间窗口的需求。</p><ol><li><strong>定义Key</strong>：为每个用户的登录失败计数定义一个清晰的Key，例如：<code>login:fail:count:&#123;userId&#125;</code>。</li><li>登录失败逻辑：当用户登录失败时，执行以下操作：<ul><li>对该用户的Key执行<code>INCR</code>命令，获取增长后的计数值：<code>count = redis.incr(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>。</li><li><strong>判断是否是第一次失败</strong>：如果<code>count</code>等于1，说明这是10分钟窗口内的第一次失败。此时，必须为这个Key设置过期时间：<code>redis.expire(&quot;login:fail:count:&#123;userId&#125;&quot;, 600)</code> (600秒 = 10分钟)。</li><li><strong>检查是否达到阈值</strong>：判断<code>count</code>是否大于等于3。如果是，则触发锁定用户的逻辑（例如，在数据库中更新用户状态，或在另一个Redis Key中设置一个锁定标记）。</li></ul></li><li><strong>登录成功逻辑</strong>：当用户登录成功时，应该<strong>立即删除</strong>这个计数Key：<code>redis.del(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>，以清除之前的失败记录。</li></ol><p>问题：</p><ul><li>存在一个微小的<strong>竞态条件（Race Condition）</strong>：在<code>INCR</code>和<code>EXPIRE</code>两个命令之间，如果服务器恰好宕机或重启，可能会导致一个计数Key被创建但<strong>没有设置过期时间</strong>，从而变成一个永久的计数器。虽然概率极低，但在高并发系统中仍需考虑。</li><li><strong>解决方案</strong>：可以使用<strong>Lua脚本</strong>将<code>INCR</code>和<code>EXPIRE</code>两个操作打包成一个原子操作，或者使用一条Redis命令完成</li></ul><p>方案2：<strong>灵活精确 - List 作为失败记录队列</strong></p><p>Redis的<code>List</code>是一个双向链表，可以作为队列使用。通过<code>LPUSH</code>在队头插入元素，<code>LTRIM</code>修剪队列长度，可以非常高效地维护一个固定大小的事件窗口。</p><ol><li><strong>定义Key</strong>：<code>login:fail:log:&#123;userId&#125;</code>。</li><li>登录失败逻辑：<ul><li>获取当前时间戳（秒或毫秒），并将其作为元素<code>LPUSH</code>到List的头部：<code>redis.lpush(&quot;login:fail:log:&#123;userId&#125;&quot;, System.currentTimeMillis())</code>。</li><li><strong>检查当前失败次数</strong>：获取List的长度<code>llen</code>。</li><li>如果<code>llen</code>大于等于3，说明已经发生了至少3次失败。此时，获取List中<strong>第3个元素</strong>（即最早的那次失败记录，索引为2）：<code>third_attempt_time = redis.lindex(&quot;login:fail:log:&#123;userId&#125;&quot;, 2)</code>。</li><li><strong>判断时间窗口</strong>：计算当前时间与<code>third_attempt_time</code>的时间差。如果差值小于10分钟，则说明在10分钟内发生了3次失败，触发锁定逻辑。</li></ul></li><li><strong>队列维护</strong>：为了防止List无限增长，可以在每次<code>LPUSH</code>后，使用<code>LTRIM</code>命令只保留最近的3条记录：<code>redis.ltrim(&quot;login:fail:log:&#123;userId&#125;&quot;, 0, 2)</code>。同时，为整个Key设置一个比10分钟稍长的过期时间，如11分钟，用于自动清理冷数据。</li><li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li></ol><ul><li>实现了精确的时间窗口判断。</li><li>内存占用非常小，因为每个用户的Key最多只存储3个时间戳。</li></ul><p><strong>方案三：功能强大 - ZSET (Sorted Set) 实现滑动时间窗口</strong></p><p>Redis的<code>ZSET</code>是一个有序集合，每个成员都关联一个<code>score</code>。我们可以用<code>score</code>来存储事件发生的时间戳，利用<code>ZSET</code>按分数范围查询和删除的特性，完美地实现<strong>滑动时间窗口</strong>。</p><ol><li><strong>定义Key</strong>：<code>login:fail:zset:&#123;userId&#125;</code>。</li><li>登录失败逻辑：<ul><li>获取当前时间戳<code>now</code>。</li><li>为了防止成员重复，可以给每个成员一个唯一的值，例如<code>now + &quot;:&quot; + Math.random()</code>。</li><li>将新的失败记录添加到ZSET中，<code>score</code>和<code>member</code>都使用时间戳（或<code>score</code>是时间戳，<code>member</code>是唯一ID）：<code>redis.zadd(&quot;login:fail:zset:&#123;userId&#125;&quot;, now, now)</code>。</li><li><strong>清理过期记录</strong>：移除所有10分钟之前的记录，这是一个非常关键的步骤，保证了窗口的滑动：<code>redis.zremrangebyscore(&quot;login:fail:zset:&#123;userId&#125;&quot;, 0, now - 600000)</code> (假设<code>now</code>是毫秒)。</li><li><strong>统计窗口内次数</strong>：获取当前ZSET中的成员数量：<code>count = redis.zcard(&quot;login:fail:zset:&#123;userId&#125;&quot;)</code>。</li><li><strong>检查阈值</strong>：如果<code>count</code>大于等于3，触发锁定逻辑。</li></ul></li><li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li></ol><h2 id="7-Redis持久化">7.Redis持久化</h2><p>RDB 是“快照”模式，AOF 是“指令日志”模式，并理解了它们都是为了解决 Redis 宕机后的数据恢复问题。</p><p>你提到了 RDB 文件小、恢复快，但可能丢失数据；AOF 文件大、恢复慢，但数据更完整。</p><p>这是一个非常关键的知识点。当 RDB 和 AOF 文件<strong>同时存在</strong>时，Redis <strong>会优先选择 AOF 文件</strong>来恢复数据。</p><ul><li><strong>为什么？</strong> 因为 AOF 文件通常记录的数据比 RDB 文件<strong>更完整、更新</strong>。AOF 的默认策略是每秒写一次盘，而 RDB 默认是几分钟甚至更久才生成一次快照。为了尽可能少地丢失数据，Redis 的设计者选择了优先使用数据更全的 AOF。</li></ul><p><strong>AOF 重写（AOF Rewrite）：</strong> 你提到了 AOF 文件会很大，这是一个很重要的缺点。但你没有提到解决这个问题的关键机制——<strong>AOF 重写</strong>。Redis 会在后台定期地对 AOF 文件进行重写，将多条冗余的命令（比如对一个 key 多次 <code>set</code>）合并成一条最终的命令，从而大大压缩 AOF 文件的大小。这个机制是 AOF 能够被长期使用的重要保障。</p><p>RDB 的触发方式： RDB 是“一段时间触发一次”，可以更具体地说明其触发方式，主要有：</p><ul><li><strong><code>save</code> 命令：</strong> 同步阻塞式保存，会阻塞主线程，生产环境禁用。</li><li><strong><code>bgsave</code> 命令：</strong> 异步非阻塞式保存，Redis 会 <code>fork</code> 一个子进程来执行快照，这是我们手动执行或配置自动执行的主要方式。</li><li><strong>配置文件自动触发：</strong> 比如 <code>save 900 1</code> (900秒内有1次写入)、<code>save 300 10</code> (300秒内有10次写入)等。</li></ul><p>“RDB-AOF 模式”，这个概念是对的，它叫<strong>混合持久化 (Mixed Persistence)</strong>。但它的工作方式可以描述得更清晰：当触发 AOF 重写时，Redis 不再简单地写入指令，而是将<strong>重写那一刻的内存数据，以 RDB 的格式写入到新的 AOF 文件的开头</strong>，然后再将重写期间产生的增量命令，以 AOF 格式追加到文件末尾。这样做的好处是，重启恢复时，可以先像 RDB 一样快速加载内存快照，然后再重放增量命令，<strong>兼顾了 RDB 的恢复速度和 AOF 的数据完整性</strong>。</p><h2 id="8-Redis底层数据结构">8.Redis底层数据结构</h2><p>ziplist:</p><p>它不是一个真正的列表，而是一块<strong>连续的内存区域</strong>。这块内存中，将多个数据项（entry）紧凑地排列在一起，从而极大地节省内存。每个entry包含三个部分：<code>previous_entry_length</code>（前一个节点的长度）、<code>encoding</code>（当前节点内容的编码方式和长度）、<code>content</code>（实际内容）。</p><ul><li><strong>极致的内存效率</strong>：由于是连续内存，没有指针开销，内存利用率极高。</li><li>但是有连锁更新的问题，由于每个节点都记录了<strong>前一个节点</strong>的长度，当我们在一个<code>ziplist</code>的<strong>中间</strong>插入或删除了一个元素，如果这个元素的<strong>大小发生了变化</strong>（比如从一个小整数变成一个长字符串），就可能导致<strong>其后所有节点</strong>的<code>previous_entry_length</code>字段都需要被级联修改。</li></ul><p>listpack：</p><p>与<code>ziplist</code>类似，也是一块<strong>连续的内存区域</strong>，用于紧凑地存储数据项。<code>listpack</code>的每个entry<strong>不再记录前一个节点的长度</strong>。取而代之的是，它记录了<strong>当前节点的总长度</strong>（<code>encoding</code>字段中包含了长度信息）。当需要从后向前遍历时，它会先读取当前节点的<strong>前一个节点</strong>的<strong>尾部</strong>，那里记录了那个节点的总长度，然后再跳到那个节点的起始位置。</p><p>依然是连续内存，内存利用率很高，但解决了连锁更新的问题。成为小数据量<code>Hash</code>和<code>Zset</code>的底层实现。</p><p>skiplist:</p><p><code>Zset</code>（有序集合）需要一种既能高效查找又能高效增删的数据结构。平衡树（如红黑树）实现复杂，而<code>skiplist</code>是一种概率性的、实现相对简单且性能媲美平衡树的数据结构。</p><p>从最高层的链表开始，向右查找，直到找到一个大于等于目标值的节点的前驱。然后从这个前驱节点<strong>下降一层</strong>，继续向右查找。重复此过程，直到到达最底层的链表，最终找到目标元素。</p><p>底层是链表，可以方便地进行范围遍历。增删改查效率都是O(log N)。</p><h1>MQ</h1><h2 id="1-消息队列（MQ）消息积压处理">1.<strong>消息队列（MQ）消息积压处理</strong></h2><p>当被问及线上Topic消息积压如何处理时，你的第一反应是“清空队列，然后恢复”，这在线上环境中是绝对禁止的操作。在引导下，你提到了扩容消费者。</p><p>方案1 <strong>紧急扩容消费者并监控下游依赖</strong></p><ol><li><strong>监控分析</strong>：在扩容前，必须先快速查看消费者应用的CPU、内存、GC情况，以及其下游依赖（如数据库、外部API）的负载情况。<strong>确认瓶颈在于消费者本身，而不是下游</strong>。</li><li><strong>水平扩容</strong>：如果瓶颈在消费者，立即增加消费者实例数量。在Kubernetes等云原生环境中，可以通过调整Deployment的replica数量快速实现。</li><li><strong>注意Partition数量</strong>：确保消费者实例数<strong>不超过</strong>Topic的Partition数量，因为多余的消费者将处于空闲状态。</li></ol><p>方案2 <strong>消息转储与异步回补</strong></p><ol><li><strong>编写转储程序</strong>：快速开发一个简单的程序，它的唯一作用就是消费积压Topic中的消息，然后原封不动地存储到另一个临时Topic或一个临时存储（如文件、数据库）中。</li><li><strong>启动转储</strong>：启动该程序，快速将积压消息“搬空”。</li><li><strong>修复与回补</strong>：在修复了原始消费者的Bug或性能问题后，再编写一个回补程序，以一个受控的速率，从临时Topic或存储中读取消息，重新发送回原始Topic进行处理。</li></ol><p>以空间换时间，快速恢复线上新消息的处理能力，为修复问题和处理积压数据赢得时间。</p><p>方案3 <strong>优化消费逻辑并临时提升处理能力</strong></p><ol><li>代码审查：快速排查消费逻辑，寻找性能瓶颈。常见的优化点包括：<ul><li>将单条处理改为<strong>批量处理</strong>。</li><li>将同步调用外部API改为<strong>异步并行</strong>调用。</li><li>优化SQL查询，减少不必要的数据库交互。</li></ul></li><li><strong>紧急上线</strong>：快速修复并上线优化后的代码。</li></ol><p>比如说：</p><p><strong>你提到扩容消费者来解决积压。假设现在是双十一零点，流量洪峰导致了严重积压，而下游的数据库集群负载也已经很高了。此时你作为负责人，应该如何决策？直接扩容消费者吗？</strong></p><p>面试官，这是一个非常经典的**‘雪崩前兆’<strong>场景，决策的核心是</strong>‘止损和降级’**，而不是盲目地增加压力。我的决策流程会是这样的</p><ol><li><strong>立即止损，保护核心系统</strong>，绝对不能直接扩容消费者！ 因为监控显示下游数据库已经高负载，扩容消费者只会变成压垮数据库的最后一根稻草，导致核心系统崩溃，造成更大的故障。 <em>立即对消费者进行限流甚至暂停</em>*。我会立即调整消费者的消费速率，甚至在极端情况下，通过配置中心或运维指令，**暂停非核心业务的消费，优先保住数据库的稳定。</li><li><strong>业务降级，保障核心链路</strong> * 我会立即与产品和业务方沟通，启动<strong>业务降级预案</strong>。例如： * <strong>关闭非核心功能</strong>：暂时关闭‘实时用户积分更新’、‘推荐商品刷新’等非核心功能的消费，将MQ资源和数据库资源全部让给<strong>核心交易链路</strong>（如下单、支付）。 * <strong>异步转同步</strong>：对于某些可以接受延迟的业务，可以暂时将消息积-压在MQ中，等高峰期过后，系统负载降低了再慢慢处理。</li><li><strong>流量削峰与后续处理</strong> * <strong>利用MQ的积压能力</strong>：此时，MQ本身就扮演了一个<strong>天然的流量削峰器</strong>的角色。大量的请求被积压在队列中，而不是直接冲击后端系统，这正是我们使用MQ的一个重要原因。 * <strong>高峰后恢复</strong>：等到流量洪峰过去，数据库负载下降后，我们再<strong>逐步、分批地</strong>恢复被暂停的消费者，并可以适当地<strong>增加消费者实例</strong>，以一个受控的速率，慢慢地将积压的消息消费完毕。</li><li><strong>复盘与改进</strong> * 事后，我们会进行深入复盘。分析是数据库容量预估不足，还是SQL存在性能问题，或者是消费者逻辑有待优化。并根据分析结果，进行数据库扩容、SQL优化、或引入更精细化的流量控制策略，为下一次大促做好准备。</li></ol><p>我的核心决策原则是：<strong>牺牲非核心业务的实时性，来换取核心系统的稳定性和可用性。</strong></p><h2 id="2-消费者组的对应">2.消费者组的对应</h2><p>你刚刚说的就是一个消费者端，然后去对应一个相当于一个partition，然后为什么要一一对应呢？</p><p><strong>核心原因：保证分区内的消息顺序性（Message Ordering Guarantee）</strong></p><p>‘一个Partition在同一个消费者组内，同一时间只能被一个Consumer消费</p><ul><li><strong>理论依据</strong>：Kafka只在<strong>单个Partition内部</strong>保证消息的有序性。也就是说，生产者以1, 2, 3的顺序发送到同一个Partition的消息，消费者也必须以1, 2, 3的顺序来消费它们。</li><li><strong>机制实现</strong>：为了实现这个保证，Kafka必须规定，一个Partition在任意时刻，只能被一个消费者实例“锁定”并消费。<strong>如果允许多个消费者同时消费同一个Partition，那么消息的消费顺序将无法得到保证</strong>，因为无法协调哪个消费者先处理哪条消息，这将彻底破坏Kafka的顺序性承诺。</li></ul><p><strong>实现高并发：以Partition为并行处理的最小单元</strong></p><ul><li><strong>理论依据</strong>：虽然单个Partition是顺序处理的，但Kafka通过<strong>将一个Topic划分为多个Partition</strong>来实F现整体的高并发。</li><li><strong>机制实现</strong>：整个Topic的吞吐量等于所有Partition吞吐量的总和。我们可以通过增加Partition的数量，来水平扩展Topic的处理能力。</li><li><strong>消费者协同</strong>：消费者组（Consumer Group）内的多个消费者实例会通过**Rebalance（再均衡）*<em>机制，自动协调分配它们各自负责消费的Partition。例如，一个有10个Partition的Topic，如果消费者组有10个消费者，理想情况下就是每个消费者负责一个Partition，此时*<em>并行度达到最大</em></em>。</li></ul><h2 id="3-消息不丢失-消息幂等">3.消息不丢失&amp;&amp;消息幂等</h2><p>不丢失：</p><p><strong>生产者端  -&gt; Broker：如何确保消息成功发出并被Broker接收？</strong></p><p><strong>同步发送 + 有限次重试</strong></p><ul><li>我们会采用**同步发送（Sync Send）**的方式。这意味着，生产者线程在发送一条消息后，会阻塞等待，直到收到Broker返回的成功确认（ACK）。如果等待超时或收到错误响应，就证明发送失败</li><li>一旦发送失败，我们会配置一个<strong>有限次的重试机制</strong>（例如，重试3次，每次间隔1秒）。通过这种‘<strong>确认+重试</strong>’的闭环，可以极大地提高消息发送到Broker的成功率。</li><li>RocketMQ的同步发送<code>send()</code>方法本身就是阻塞等待Broker确认的。对于可靠性要求极高的场景，我们还会配合Broker端的<strong>同步刷盘</strong>策略，确保消息在持久化到磁盘后才返回ACK。</li><li>对于需要<strong>本地事务与消息发送保持原子性</strong>的场景（例如，下单成功后发送扣减库存消息），我们会使用RocketMQ独有的<strong>事务消息</strong>。它通过两阶段提交（发送Half消息 -&gt; 执行本地事务 -&gt; 提交/回滚Half消息）的机制，从根本上保证了本地操作成功，消息就一定能成功发送。</li></ul><p>Broker端<strong>如何确保持久化，防止自身宕机导致消息丢失？</strong></p><p><strong>持久化刷盘 + 多副本冗余</strong></p><ul><li><strong>同步刷盘（Sync Flush）</strong>：这是最可靠的方式。Broker接收到消息后，必须将其写入磁盘文件，才向生产者返回ACK。即使Broker进程或服务器瞬间宕机，消息也不会丢失。</li><li><strong>异步刷盘（Async Flush）</strong>：Broker将消息写入操作系统的Page Cache后，就立即返回ACK，由操作系统异步地将数据刷到磁盘。性能最高，但如果服务器在刷盘前掉电，Page Cache中的数据会丢失。</li><li>我们会为每个Topic或Partition配置<strong>多个副本（通常是3个）</strong>，分布在不同的物理机架上。消息会同时写入主副本（Leader）和备用副本（Follower）。当主副本宕机时，系统可以从备用副本中选举出新的主副本，继续提供服务，保证了数据的高可用和冗余。</li><li>RocketMQ也支持Master-Slave的多副本架构，以及基于Raft协议的Dledger模式，都能实现类似的高可用保障。</li></ul><p><strong>Broker -&gt; 消费者端 (Consumer)：如何确保消息被消费者成功处理？</strong></p><p><strong>手动确认（ACK）/提交消费位点（Offset）</strong></p><ol><li>消费者从Broker拉取一批消息。</li><li><strong>先执行我们自己的业务逻辑</strong>（例如，更新数据库、调用外部API等）。</li><li><strong>当且仅当业务逻辑全部成功执行完毕后</strong>，我们才向Broker发送ACK，或者提交这批消息的Offset。</li></ol><p>这样，如果消费者在处理业务的途中宕机，由于没有提交Offset，它重启后会从上一次已提交的Offset处重新拉取消息，保证了宕机期间正在处理的消息不会丢失。</p><p>在RocketMQ中，消费者的监听器<code>MessageListener</code>会返回一个消费状态。我们只有在业务处理成功后，才返回<code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code>，RocketMQ才会认为消息消费成功并更新Offset。如果返回<code>RECONSUME_LATER</code>或抛出异常，消息会在稍后被重试。</p><p>幂等：</p><p><strong>对于同一个业务操作，无论执行多少次，其产生的结果和影响都和执行一次是相同的</strong>。我们的实现方案是基于唯一ID + 状态判断</p><ol><li><strong>为消息赋予全局唯一ID</strong>： * “我们要求生产者在发送每一条具有业务含义的消息时，都在消息体或Header中附带一个<strong>全局唯一的业务ID</strong>。例如，支付成功的消息，就用‘支付流水号’；创建订单的消息，就用‘订单号’。”</li><li><strong>消费者端实现幂等判断</strong>： * “消费者在处理消息时，不会立即执行业务逻辑，而是会先根据这个<strong>唯一ID</strong>，去查询一个<strong>持久化的存储</strong>（如Redis或数据库），来判断这个操作是否已经被执行过。</li><li><strong>方案一：数据库唯一索引</strong>：对于插入操作，我们可以直接利用数据库的**唯一键（Unique Key）**约束。例如，在处理‘用户注册’消息时，将用户名或手机号作为唯一索引。如果消息重复，尝试插入时会直接触发<code>DuplicateKeyException</code>，我们捕获这个异常就知道是重复操作，直接ACK消息即可。</li><li>方案二：Redis <code>SETNX</code>**：对于一些通用的操作，我们可以利用Redis的<code>SETNX</code>命令。将消息的唯一ID作为Key，尝试写入Redis。如果写入成功（返回1），说明是第一次处理，就执行业务逻辑，并在成功后保留这个Key（可以设置一个过期时间）。如果写入失败（返回0），说明这个ID已经被处理过，直接跳过并ACK。</li><li>方案三：状态机与版本号：对于更新操作，我们可以在业务表中引入状态字段<strong>或</strong>版本号。例如，处理订单状态流转的消息。消费者会先查询订单的当前状态，只有当订单状态符合前置条件时（例如，只有‘待支付’状态的订单才能被更新为‘已支付’），才执行更新。如果状态不匹配，说明已经被其他操作处理过，直接忽略。</li></ol><h2 id="4-RocketMQ半事务消息">4.RocketMQ半事务消息</h2><ul><li><p><strong>第一阶段 (发送半消息):</strong> <strong>生产者（订单服务）**先发送一条**半消息（Half Message）**到 Broker。这条消息对消费者是**不可见</strong>的。</p></li><li><p><strong>执行本地事务：</strong> 生产者发送半消息成功后，<strong>立即开始执行自己的本地事务</strong>（比如创建订单并写入数据库）。</p></li><li><p>第二阶段 (提交/回滚):</p><ul><li>如果本地事务<strong>执行成功</strong>，生产者就向 Broker 发送一个 <strong>Commit</strong> 命令，Broker 收到后，才将这条半消息<strong>对消费者可见</strong>。</li><li>如果本地事务<strong>执行失败</strong>，生产者就向 Broker 发送一个 <strong>Rollback</strong> 命令，Broker 就会<strong>删除</strong>这条半消息。</li></ul></li><li><p><strong>回查机制：</strong> 如果生产者在执行完本地事务后宕机，没能发送 Commit/Rollback，Broker 会<strong>定期地回调</strong>生产者的一个<strong>回查接口</strong>，询问：“我这里有一条半消息，你对应的本地事务到底成功了没有？” 生产者根据本地事务的状态，告诉 Broker 应该 Commit 还是 Rollback。</p></li></ul><h1>分布式</h1><h2 id="1-分布式事务">1.分布式事务</h2><p><strong>TCC、Saga、本地消息表、事务消息</strong></p><h1>设计模式</h1><h2 id="1-当被问及如何在多个接口中统一管理以避免代码重复时">1.当被问及如何在多个接口中统一管理以避免代码重复时</h2><p>你的初步想法是提取一个公共方法。面试官进一步引导你思考过滤器和拦截器。</p><p>方案1：<strong>使用Spring MVC的<code>HandlerInterceptor</code>（拦截器）</strong></p><p><code>HandlerInterceptor</code>是Spring MVC提供的AOP实现，专门用于在Controller方法执行前后进行预处理和后处理。它与请求生命周期紧密耦合，是处理用户认证、日志记录、上下文设置等横切关注点的标准方式。</p><ol><li>创建一个类实现<code>HandlerInterceptor</code>接口。</li><li>在<code>preHandle</code>方法中，从请求（如Header）中获取Token，解析出用户信息，然后调用工具类的<code>set()</code>方法将用户信息存入<code>ThreadLocal</code>。</li><li>在<code>afterCompletion</code>方法中，无论Controller方法执行成功还是失败，都调用工具类的<code>remove()</code>方法清理<code>ThreadLocal</code>，通常放在<code>finally</code>块中以确保执行。</li><li>创建一个配置类实现<code>WebMvcConfigurer</code>，重写<code>addInterceptors</code>方法，将你的拦截器注册到Spring容器中，并配置其拦截路径（如<code>/api/**</code>）。</li></ol><p>方案2：<strong>使用Servlet的<code>Filter</code>（过滤器）</strong></p><ol><li>创建一个类实现<code>javax.servlet.Filter</code>接口。</li><li>在<code>doFilter</code>方法中，在调用<code>chain.doFilter(request, response)</code>之前，执行<code>ThreadLocal</code>的<code>set()</code>操作。</li><li>使用<code>try...finally</code>结构，在<code>finally</code>块中执行<code>ThreadLocal</code>的<code>remove()</code>操作，确保无论后续处理是否异常，都能清理资源。</li><li>使用<code>@Component</code>和<code>@Order</code>注解（或通过<code>FilterRegistrationBean</code>）将Filter注册为Spring Bean。</li></ol><p>与<code>Interceptor</code>类似，实现了解耦和统一管理。由于作用范围更广，可以拦截静态资源等非Spring MVC处理的请求。</p><p>方案3：<strong>使用自定义AOP切面（<code>@Aspect</code>）</strong></p><ol><li>创建一个类，并使用<code>@Aspect</code>和<code>@Component</code>注解。</li><li>定义一个切点（Pointcut），例如<code>@Pointcut(&quot;within(@org.springframework.web.bind.annotation.RestController *)&quot;)</code>，用于匹配所有RestController类中的方法。</li><li>创建一个<code>@Around</code>环绕通知。在通知方法的<code>try</code>块中，执行<code>ThreadLocal</code>的<code>set()</code>操作，然后调用<code>proceedingJoinPoint.proceed()</code>执行目标方法。在<code>finally</code>块中，执行<code>remove()</code>操作。</li></ol><p>功能上与前两者类似，但提供了最大的灵活性，可以切入到Service层甚至任意Bean的方法。<code>@Around</code>通知需要手动调用<code>proceed()</code>，如果忘记调用，目标方法将不会被执行。</p><h2 id="2-策略方法怎么去解决具体调用哪一个策略">2.策略方法怎么去解决具体调用哪一个策略</h2><ul><li>为了避免在业务代码中使用大量的<code>if-else</code>或<code>switch</code>来选择策略，我们创建了一个<strong>策略工厂（Strategy Factory）</strong>。</li></ul><ol><li>在项目启动时，Spring容器会扫描并加载所有<code>CouponStrategy</code>的实现类。</li><li>我们创建一个<code>CouponStrategyFactory</code>类，它在构造时注入一个<code>Map&lt;String, CouponStrategy&gt;</code>。Spring会自动将所有策略实现类注入到这个Map中，其中Key是Bean的名称（例如<code>&quot;fullDiscountStrategy&quot;</code>），Value是Bean实例。</li><li>我们约定优惠券类型（例如<code>&quot;FULL_DISCOUNT&quot;</code>, <code>&quot;PERCENTAGE_DISCOUNT&quot;</code>）与Bean名称有映射关系。</li><li>工厂类提供一个<code>getStrategy(String couponType)</code>方法。当业务代码需要使用某个策略时，它只需要传入优惠券类型字符串，工厂就会从Map中返回对应的策略对象。</li><li>我们完全消除了业务代码中的<code>if-else</code>判断。当未来需要增加一种新的优惠券时，我们只需要新增一个策略实现类，而不需要修改任何现有的业务逻辑代码，这完全符合<strong>开闭原则</strong>，使得系</li><li>统非常易于扩展和维护。”</li></ol><h2 id="3-100个有序文件，如何拼接保证整体有序？">3.<strong>100个有序文件，如何拼接保证整体有序？</strong></h2><p>我们有100个已经内部有序的数据源（文件），需要将它们合并成一个单一的、全局有序的输出。这正是<strong>归并排序</strong>中“归并（Merge）”这一步的经典应用。由于文件可能很大，无法一次性全部读入内存，所以这是一个<strong>外部排序</strong>问题。</p><p>我们可以使用最小堆来解决</p><ul><li>创建一个大小为100的<strong>最小堆</strong>。</li><li>为100个文件，每个文件都打开一个文件读取流（Reader）。</li><li>从<strong>每个文件</strong>中读取<strong>第一个数字</strong>，并将这个数字连同它<strong>所属的文件源信息</strong>（例如，文件索引）一起，封装成一个对象（如<code>Node(value, fileIndex)</code>），放入最小堆中。此时，堆中有100个元素。</li><li><strong>循环执行</strong>以下操作，直到堆为空： a. <strong>取出最小元素</strong>：从最小堆的堆顶取出一个<code>Node</code>。这个<code>Node</code>的<code>value</code>就是<strong>当前全局最小的数字</strong>。 b. <strong>写入输出文件</strong>：将这个<code>value</code>写入到最终的输出文件中。 c. <strong>补充新元素</strong>：根据取出的<code>Node</code>中的<code>fileIndex</code>，我们知道这个数字来自哪个文件。我们立即从那个文件中<strong>读取下一个数字</strong>。 d. <strong>处理文件结束</strong>：如果那个文件已经读完，则什么也不做。如果还能读到新数字，就将这个新数字和它的<code>fileIndex</code>再次封装成一个新的<code>Node</code>，<strong>插入到最小堆中</strong>。</li><li>当最小堆为空时，意味着所有文件都已被读取完毕，输出文件也就包含了所有数字，并且是全局有序的。</li></ul><p>这个问题本质上是一个典型的<strong>多路归并排序</strong>问题，特别是在处理无法完全加载到内存的大文件时，属于<strong>外部排序</strong>的范畴</p><h2 id="4-设计一个高并发的系统">4.设计一个高并发的系统</h2><p>面试官您好，设计一个高并发秒杀系统，核心挑战在于如何在瞬时巨大流量下，保证<strong>库存扣减的绝对正确性</strong>和<strong>系统的整体高可用</strong>。我的设计方案将围绕**“层层过滤、异步处理、最终一致”**的核心思想展开，严格遵循题目要求的几个方面进行阐述。</p><p>整体架构：</p><p>首先我会将整个秒杀流程进行<strong>动静分离</strong>和<strong>垂直分层</strong>，构建一个清晰的数据流。</p><ul><li><strong>前端层</strong>：商品详情页静态化，通过CDN分发，降低服务器压力。秒杀按钮在倒计时结束前置灰，并通过定时器从服务端获取最新时间，防止客户端时间不准导致提前请求。</li><li>接入层：<ul><li><strong>Nginx/网关</strong>：负责反向代理、初步限流、过滤恶意请求。</li><li><strong>秒杀服务（独立部署）</strong>：这是核心业务逻辑所在，与普通商品服务物理隔离，避免秒杀流量冲垮主站。</li></ul></li><li>数据处理流：<ol><li>用户请求首先到达Nginx/网管。</li><li>通过限流后，请求进入秒杀服务。</li><li>秒杀服务在Redis中完成<strong>资格校验</strong>和<strong>库存预扣减</strong>。</li><li>预扣减成功后，立即向用户返回“排队中”或“抢购成功”的提示，并将订单信息<strong>异步发送到RocketMQ</strong>。</li><li><strong>订单服务</strong>作为消费者，从MQ拉取消息，进行数据库层面的<strong>订单创建</strong>和<strong>库存真实扣减</strong>。</li><li>后续的支付、履约流程由订单服务驱动。</li></ol></li></ul><p>数据模型：</p><p>在Mysql中会有一个<code>promo_stock</code> (秒杀库存表)，<code>promo_id</code> (秒杀活动ID, 索引)，<code>item_id</code> (商品ID, 索引)，<code>version</code> (int, <strong>乐观锁版本号</strong>)</p><p>Redis换成设计：</p><ul><li><p><code>promo:stock:&#123;promo_id&#125;</code> (String): 存储秒杀活动的<strong>总库存数量</strong>。用于快速判断库存是否售罄。</p></li><li><p><code>promo:soldout:&#123;promo_id&#125;</code> (String/Bitmap): 一个<strong>售罄标记</strong>。一旦库存为0，设置此标记，后续请求可以直接在接入层拦截，无需再访问Redis。</p></li><li><p><code>promo:user:history:&#123;promo_id&#125;</code> (Set/HyperLogLog): 存储已成功抢购的<code>userId</code>，用于<strong>防止用户重复下单</strong>。</p></li></ul><p>数据一致性：</p><p>在秒杀场景下，我们采用‘<strong>缓存预扣减，数据库异步更新</strong>’的策略，追求的是<strong>最终一致性</strong></p><ol><li><strong>库存预热</strong>：秒杀活动开始前，通过定时任务将MySQL中的库存数量加载到Redis的<code>promo:stock:&#123;promo_id&#125;</code>中。</li><li><strong>缓存预扣减</strong>：用户的抢购请求直接在Redis中通过<code>DECR</code>原子操作进行库存扣减。</li><li><strong>异步更新数据库</strong>：Redis扣减成功后，将订单信息发送到MQ。订单服务消费消息后，再对MySQL中的<code>stock_count</code>进行<code>UPDATE ... SET stock_count = stock_count - 1</code>操作。</li><li>数据不一致的风险与兜底：<ul><li><strong>风险</strong>：如果消息丢失或订单服务消费失败，会导致Redis库存减少，而MySQL库存未变。</li><li><strong>兜底</strong>：我们会有一个<strong>定时对账任务</strong>，定期（如每5分钟）比对Redis中的已售数量和MySQL中的已创建订单数量，如果不一致，则进行修复或告警。</li></ul></li></ol><p>限流和短融：</p><p>限流是保护系统的第一道防线，必须在<strong>多层级</strong>部署</p><ol><li><strong>前端层限流</strong>：通过JS控制，用户在点击秒杀按钮后，按钮会置灰一段时间，防止用户疯狂点击，造成不必要的请求。</li><li>Nginx/网关层限流：<ul><li><strong><code>limit_req_zone</code></strong>：基于漏桶算法，对用户的IP或UID进行<strong>请求速率限制</strong>，例如，限制单个用户每秒只能请求1次。</li><li><strong><code>limit_conn_zone</code></strong>：限制单个IP的最大连接数，防止恶意攻击。</li></ul></li><li>业务服务层限流：<ul><li>使用<strong>Sentinel</strong>或<strong>Guava RateLimiter</strong>，对秒杀接口本身进行<strong>QPS限制</strong>。这个值应该根据压测结果设定，略高于系统的最大处理能力，作为最后的保险丝。</li></ul></li><li>熔断：<ul><li>同样使用<strong>Sentinel</strong>，我们会对秒杀服务依赖的下游服务（如订单服务、用户服务）的调用进行熔断配置。</li><li><strong>策略</strong>：当在指定时间窗口内，对订单服务的调用<strong>错误率</strong>或<strong>平均响应时间</strong>超过阈值时，熔断器会打开。在接下来的一个时间窗口内，所有对订单服务的调用都会被<strong>直接拒绝</strong>，并快速失败（返回“系统繁忙”），避免因下游故障导致的秒杀服务线程池耗尽和雪崩。</li></ul></li></ol><p>热点和超卖的数据处理：</p><p>这是秒杀系统的核心，我采用了**‘Redis原子操作 + 分布式锁 + 数据库乐观锁’**的三重保障来彻底杜绝超卖。</p><ol><li>热点数据处理：<ul><li><strong>库存预热</strong>：已在一致性策略中提及，将MySQL的热点库存数据提前加载到Redis中，所有读写操作都在Redis完成，避免直接冲击数据库。</li></ul></li><li>防超卖机制（核心流程）：<ul><li>第一重防护：Redis原子操作：<ul><li>在用户请求到达时，首先检查Redis中的售罄标记<code>promo:soldout:&#123;promo_id&#125;</code>。如果存在，直接返回“已售罄”。</li><li>然后，使用<code>DECR promo:stock:&#123;promo_id&#125;</code>进行库存预扣减。这是一个<strong>原子操作</strong>，天然地避免了多线程下的并发问题。如果<code>DECR</code>后的返回值小于0，说明库存已不足，我们将库存<code>INCR</code>加回去，并返回“已售罄”。</li></ul></li><li>第二重防护：分布式锁（可选，用于更复杂逻辑）：<ul><li>如果扣减库存的逻辑不仅仅是<code>DECR</code>，还包含了<strong>用户资格校验</strong>（如检查是否重复购买），那么“校验+扣减”这两个操作就不是原子的。</li><li>此时，我们会使用<strong>Redisson分布式锁 + Lua脚本</strong>。将“检查用户是否在<code>promo:user:history</code>集合中”和“<code>DECR</code>库存”这两个逻辑封装在一个<strong>Lua脚本</strong>中，然后在获取到分布式锁后，原子化地执行这个脚本。</li></ul></li><li>第三重防护（最终兜底）：数据库乐观锁：<ul><li>订单服务在消费MQ消息，准备真实扣减MySQL库存时，会使用乐观锁。</li><li>SQL语句为：<code>UPDATE promo_stock SET stock_count = stock_count - 1, version = version + 1 WHERE promo_id = ? AND stock_count &gt; 0 AND version = ?</code>。</li><li>如果这条SQL执行后返回的影响行数为0，说明在并发情况下，库存已被其他事务修改（<code>stock_count</code>变为0或<code>version</code>不匹配）。此时，我们会认为这是一个<strong>无效的订单</strong>，进行记录并丢弃，<strong>不会创建订单</strong>。这确保了数据库层面的最终正确性。</li></ul></li></ul></li></ol><p>异步队列+补偿处理：</p><ol><li>异步队列（RocketMQ）的作用：<ul><li><strong>流量削峰</strong>：秒杀的瞬时流量是巨大的，但后端数据库的处理能力是有限的。MQ像一个蓄水池，将瞬时的写请求缓冲起来，让下游的订单服务可以按照自己的节奏平稳地进行消费，保护了数据库。</li><li><strong>业务解耦</strong>：秒杀服务只负责最核心的库存预扣减，成功后即可返回。创建订单、发送通知等非核心、耗时的操作被解耦到下游服务，大大降低了秒杀接口的响应时间。</li></ul></li><li>补偿机制：<ul><li><strong>消息可靠性</strong>：我们会使用RocketMQ的<strong>事务消息</strong>或<strong>生产者发送确认+重试</strong>机制，确保库存预扣减成功的消息一定能被发送到MQ。</li><li><strong>消费失败处理</strong>：如果订单服务消费消息失败（例如，数据库暂时不可用），我们会让消息进入<strong>重试队列</strong>。</li><li><strong>死信队列（DLQ）</strong>：如果经过多次重试后仍然失败，消息会被投递到<strong>死信队列</strong>。我们会有一个专门的<strong>后台任务</strong>或<strong>告警系统</strong>来监控死信队列，一旦有消息进入，就立即通知开发人员进行<strong>人工介入和补偿</strong>。</li></ul></li></ol><p>压测：</p><ol><li><strong>工具</strong>：使用<strong>JMeter</strong>或<strong>nGrinder</strong>等分布式压测工具。</li><li><strong>压测目标</strong>：模拟秒杀开始瞬间，在极短时间内（如1秒内）发起远超系统处理能力的并发请求（例如，模拟10万用户同时抢购1000件商品）。</li><li>监控指标：<ul><li><strong>业务指标</strong>：下单成功率、最终创建的订单数是否与库存数严格相等（<strong>验证正确性</strong>）。</li><li><strong>性能指标</strong>：系统的<strong>QPS/TPS</strong>、接口的<strong>平均响应时间</strong>和<strong>99%分位线</strong>。</li><li><strong>资源指标</strong>：压测过程中，密切监控所有组件（Nginx, Redis, 秒杀服务, 数据库）的CPU、内存、网络、磁盘I/O等资源使用率。</li></ul></li><li><strong>瓶颈定位</strong>：通过观察各个环节的监控指标，找出最先达到瓶颈的组件，然后针对性地进行优化（例如，升级Redis集群、优化SQL、增加秒杀服务实例等），再进行下一轮压测，如此循环，直到系统达到预期的性能目标。</li></ol><h2 id="5-模板方法的回答">5.模板方法的回答</h2><p>模板方法模式定义了一个操作中的<strong>算法骨架</strong>，而将一些可变的步骤延迟到子类中去实现。</p><p>在一个抽象的父类中，会有一个 <code>final</code> 的模板方法，它定义了整个流程的执行顺序。这个模板方法会调用一系列的抽象方法（由子类实现）和具体方法（父类实现）。</p><p><strong>优点是复用了算法的公共部分，并将变化的部分进行隔离</strong>。比如，<code>AbstractList</code> 中的 <code>addAll</code> 方法就是一个模板方法，它定义了批量添加的流程，而具体的 <code>add(index, element)</code> 则由子类 <code>ArrayList</code> 或 <code>LinkedList</code> 去实现。</p><h2 id="6-30分钟自动关闭">6.30分钟自动关闭</h2><ol><li><strong>下单时：</strong> 用户下单成功后，除了创建订单，我们还会向 RocketMQ 发送一条<strong>延时等级为 30 分钟</strong>的延时消息，消息内容包含订单号。</li><li><strong>消费者：</strong> 我们有一个专门的消费者来消费这些延时消息。</li><li><strong>30分钟后：</strong> Broker 会将这条消息投递给消费者。</li><li>处理逻辑：消费者收到消息后，会根据订单号去查询数据库中该订单的支付状态。<ul><li>如果订单状态<strong>仍是“未支付”</strong>，则执行<strong>关单操作</strong>。</li><li>如果订单状态<strong>已经是“已支付”</strong>，则<strong>直接忽略</strong>这条消息。</li></ul></li></ol><h1>网络编程</h1><p>1.<strong>Netty 如何封装 NIO</strong></p><p>Netty 是对Java原生NIO的一个<strong>高度封装和增强</strong>的框架，它解决了原生NIO在使用上非常复杂、功能有限、且容易出错的痛点。</p><ul><li>封装Selector与事件循环：<ul><li>原生NIO需要我们手动编写一个死循环，不断地调用<code>selector.select()</code>，然后遍历<code>selectedKeys</code>，再根据<code>key</code>的类型（<code>OP_ACCEPT</code>, <code>OP_READ</code>等）进行<code>if-else</code>判断，代码繁琐且容易出错。</li><li><strong>Netty</strong>将其封装成了**<code>EventLoop</code>**。每个<code>EventLoop</code>内部都包含一个<code>Selector</code>和一个线程。这个<code>EventLoop</code>线程会自动地、高效地执行事件轮询和分发，我们开发者完全不需要关心底层的<code>Selector</code>操作。</li></ul></li><li>封装Channel与Buffer：<ul><li>原生NIO的<code>Buffer</code>使用起来非常反直觉，需要我们手动<code>flip()</code>、<code>clear()</code>、<code>rewind()</code>，很容易出错。</li><li><strong>Netty</strong>提供了自己的<code>ByteBuf</code>，它通过<strong>读写指针分离</strong>的设计，彻底告别了<code>flip()</code>操作，使用起来非常方便。它还提供了<strong>零拷贝（Zero-Copy）</strong>、<strong>池化（Pooling）**和**堆外内存</strong>等高级功能，性能远超原生<code>Buffer</code>。</li><li>Netty的<code>Channel</code>接口也比原生的更统一、更易用。</li></ul></li><li>封装责任链与业务逻辑解耦：<ul><li>原生NIO的所有I/O处理逻辑都混杂在一起。</li><li><strong>Netty</strong>引入了**<code>ChannelPipeline</code><strong>和</strong><code>ChannelHandler</code><strong>的设计，这是一个经典的</strong>责任链模式**。我们可以将网络处理逻辑（如解码、编码、业务处理）拆分成一个个独立的<code>Handler</code>，然后像“搭积木”一样将它们组织在<code>Pipeline</code>中。这使得代码结构清晰、高度解耦、易于扩展和复用。</li></ul></li></ul><p>多<strong>Reactor 模型</strong></p><p>Netty的线程模型正是经典<strong>多Reactor模型</strong>的实现，通常是<strong>主从Reactor模式（Master-Slave Reactor</strong></p><ul><li>主Reactor（Boss Group）：<ul><li>通常只配置<strong>一个线程</strong>（<code>EventLoop</code>）。</li><li>它的<strong>唯一职责</strong>就是监听服务端的<strong>连接请求（<code>OP_ACCEPT</code>事件）</strong>。</li><li>当接收到一个新的客户端连接后，主Reactor会<strong>将这个新建立的<code>SocketChannel</code>注册到从Reactor</strong>上，然后继续回去监听新的连接。它<strong>不处理任何I/O读写</strong>。</li></ul></li><li>从Reactor（Worker Group）：<ul><li>通常配置<strong>多个线程</strong>（<code>EventLoop</code>），数量一般是CPU核心数的1倍或2倍。</li><li>它的职责是处理所有<strong>已连接<code>Channel</code>的I/O读写事件（<code>OP_READ</code>, <code>OP_WRITE</code>）</strong>。</li><li>一个<code>Channel</code>的整个生命周期内的所有I/O操作，都会被绑定在<strong>同一个</strong>从Reactor线程上执行，这避免了多线程并发处理同一个连接时需要加锁的问题。</li></ul></li></ul><h1>计网</h1><h2 id="1-对比一下-HTTP-1-0-HTTP-1-1-和-HTTP-2-0-这三个版本的主要区别。">1.对比一下 <strong>HTTP/1.0, HTTP/1.1, 和 HTTP/2.0</strong> 这三个版本的主要区别。</h2><p>请从<strong>连接管理、性能优化、头部处理</strong>等角度展开，并说明每一个版本的演进分别解决了上一代的什么核心痛点？</p><p>1.0-&gt;1.1</p><ul><li><strong>长链接 (Keep-Alive):</strong> 是 <strong>HTTP/1.1</strong> 相对于 HTTP/1.0 最核心的改进之一。HTTP/1.0 默认是短连接，每个请求/响应对都需要一次 TCP 连接。而 HTTP/1.1 默认开启了长链接，允许在一个 TCP 连接上发送多个 HTTP 请求，<strong>极大地减少了 TCP 连接建立和关闭的开销</strong>。</li><li>HTTP/1.1 还引入了<strong>管道机制 (Pipelining)</strong>，允许客户端在收到上一个响应之前就发送下一个请求。但这只是部分解决了队头阻塞（Head-of-Line Blocking）问题，因为服务端的响应仍然必须按顺序返回。</li></ul><p>2.0</p><ul><li><p><strong>多路复用 (Multiplexing):</strong> 这是 HTTP/2.0 <strong>最核心</strong>的优势。它允许在一个 TCP 连接上，<strong>同时、并行地</strong>收发多个请求和响应，并且不按顺序。这彻底解决了 HTTP/1.1 的队头阻塞问题。</p></li><li><p><strong>头部压缩 (Header Compression):</strong> HTTP/2.0 使用 HPACK 算法来压缩请求和响应的头部。对于多个请求，很多头部字段是重复的，HPACK 可以极大地减少这部分的数据传输量。</p></li><li><p><strong>服务器推送 (Server Push):</strong> 服务器可以主动地将客户端未来可能会用到的资源（如 CSS, JS 文件）提前推送到客户端缓存中，减少了请求的 RTT（往返时间）。</p></li><li><p><strong>二进制分帧 (Binary Framing):</strong> 这是 <strong>HTTP/2.0</strong> 的革命性变化。HTTP/1.0 和 1.1 都是基于文本的协议，而 HTTP/2.0 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。这解决了 1.x 时代基于文本的协议解析效率低的问题。</p></li><li><p><strong>HTTP/1.0 -&gt; HTTP/1.1:</strong> 解决了什么？<strong>连接无法复用的问题</strong>。通过什么解决？<strong>默认开启长链接 (Keep-Alive)</strong>。</p></li><li><p><strong>HTTP/1.1 -&gt; HTTP/2.0:</strong> 解决了什么？<strong>队头阻塞和头部冗余的问题</strong>。通过什么解决？<strong>二进制分帧、多路复用、头部压缩</strong>。</p></li></ul><h2 id="2-从用户在浏览器输入-URL-到页面渲染完成，请按网络与系统角度分层讲解关键路径。">2.从用户在浏览器输入 URL 到页面渲染完成，请按<strong>网络与系统角度</strong>分层讲解关键路径。</h2><p>我将其分为<strong>请求准备阶段</strong>、<strong>网络通信阶段</strong>、和<strong>浏览器渲染阶段</strong></p><p>当我在URL栏输入地址的话，首先要知道这个域名对应的IP地址是啥</p><p>请求准备：</p><ol><li>浏览器首先会解析URL，判断协议（HTTPS）、<a href="http://xn--www-q33er8o.google.com">域名www.google.com</a>）、端口（默认为443）等信息。接着，它会查询自己的<strong>浏览器缓存</strong>，看之前是否已经解析过这个域名并且缓存还未过期。如果命中，就直接使用缓存的IP地址，跳过后续的DNS查询。</li><li>如果浏览器缓存未命中，操作系统会启动一个DNS查询流程，这是一个从近到远、层层递归的查询过程，核心目标是将域名转换为IP地址。先是操作系统&amp;host文件，然后是本地DNS服务器，再是根域名服务器，顶级域名服务器，权威域名服务器。依次类推</li><li>LDNS拿到IP地址后，会将其缓存起来，并返回给操作系统，操作系统再返回给浏览器。至此，DNS解析完成。</li></ol><p>网络通信：</p><p>这个过程涉及到TCP、TLS和HTTP三个核心协议</p><p>TCP三次握手</p><ol><li><strong>第一次握手 (SYN)</strong>：客户端随机选择一个初始序列号<code>client_isn</code>，将TCP报文段的<code>SYN</code>标志位置为1，然后发送给服务器。此时客户端进入<code>SYN_SENT</code>状态。</li><li><strong>第二次握手 (SYN+ACK)</strong>：服务器收到SYN包后，必须确认客户端的<code>SYN</code>。它将报文段的<code>SYN</code>和<code>ACK</code>标志位都置为1，确认号<code>ack</code>设为<code>client_isn + 1</code>，同时自己也选择一个初始序列号<code>server_isn</code>，然后发送给客户端。此时服务器进入<code>SYN_RCVD</code>状态。</li><li><strong>第三次握手 (ACK)</strong>：客户端收到服务器的SYN+ACK包后，检查确认号是否正确。如果正确，它会将<code>ACK</code>标志位置为1，确认号<code>ack</code>设为<code>server_isn + 1</code>，然后发送给服务器。这个ACK包可以携带数据。发送后，客户端和服务器都进入<code>ESTABLISHED</code>状态，连接建立成功。</li></ol><p>TLS四次挥手：</p><ol><li><strong>Client Hello</strong>：客户端发送支持的TLS版本、加密套件列表、以及一个随机数<code>client_random</code>。</li><li><strong>Server Hello &amp; Certificate</strong>：服务器选择一个加密套件，返回自己的数字证书、以及一个随机数<code>server_random</code>。</li><li><strong>客户端验证与密钥交换</strong>：客户端验证服务器证书的有效性。验证通过后，生成一个预主密钥<code>pre-master secret</code>，用服务器证书中的公钥加密后发送给服务器。</li><li><strong>服务器解密与会话密钥生成</strong>：服务器用自己的私钥解密，得到<code>pre-master secret</code>。至此，<strong>客户端和服务器双方都拥有了<code>client_random</code>、<code>server_random</code>和<code>pre-master secret</code></strong>，它们使用相同的算法，各自独立地生成一个<strong>对称的会话密钥</strong>。</li><li><strong>Finished</strong>：双方互发<code>Finished</code>消息，用生成的会话密钥加密，验证握手过程是否成功。握手结束后，后续所有的HTTP数据都将使用这个对称的会话密钥进行加密传输。</li></ol><p>Http请求和相应：</p><ol><li><strong>发送HTTP请求</strong>：浏览器构建一个HTTP请求报文，包含请求行（<code>GET / HTTP/1.1</code>）、请求头（<code>Host</code>, <code>User-Agent</code>, <code>Cookie</code>等）和请求体（GET请求通常为空），然后通过建立好的TCP/TLS通道发送给服务器。</li><li>请求到达服务器后，可能会先经过<strong>负载均衡器（如Nginx/SLB）</strong>，它会将请求转发到后端的某一台应用服务器。</li><li>应用服务器（如Tomcat）接收到请求后，Web容器会解析HTTP报文，将其封装成<code>HttpServletRequest</code>对象。</li><li>业务代码（如Spring MVC的Controller）被调用，它可能会查询<strong>缓存（Redis）</strong>、<strong>数据库（MySQL）</strong>，执行业务逻辑，最终生成数据。</li><li>服务器将数据渲染进HTML模板，构建一个HTTP响应报文，包含状态行（<code>HTTP/1.1 200 OK</code>）、响应头（<code>Content-Type</code>, <code>Set-Cookie</code>等）和响应体（HTML内容）。</li><li><strong>接收HTTP响应</strong>：浏览器接收到服务器的响应报文。</li></ol><p>浏览器渲染：</p><ul><li>浏览器自上而下解析HTML文档，生成<strong>DOM树（Document Object Model）</strong>。</li><li>在解析过程中，如果遇到<code>&lt;link&gt;</code>标签引用的CSS文件，会异步下载并解析，生成<strong>CSSOM树（CSS Object Model）</strong>。</li><li>如果遇到<code>&lt;script&gt;</code>标签，会阻塞DOM的解析，立即下载并执行JavaScript代码（除非<code>script</code>标签有<code>async</code>或<code>defer</code>属性）。</li><li><strong>构建渲染树（Render Tree）</strong>：将DOM树和CSSOM树结合起来，生成渲染树。渲染树只包含需要被显示的节点及其样式信息（例如，<code>display:none</code>的节点就不会在渲染树中）。</li><li><strong>布局（Layout/Reflow）</strong>：浏览器根据渲染树，计算出每个节点在屏幕上的精确位置和大小。</li><li><strong>绘制（Paint/Rasterizing）</strong>：浏览器调用GPU，根据布局信息，将每个节点绘制成屏幕上的实际像素。</li><li><strong>合成（Composite）</strong>：对于复杂的页面（如使用了<code>transform</code>或<code>opacity</code>），浏览器会将页面分层，独立绘制，最后再合成到一起，以提升性能。</li></ul><p>所有资源加载完成，或者是空闲超时了之后，就会开始断开请求TCP的四次挥手</p><ul><li><strong>第一次挥手 (FIN)</strong>：主动关闭方（如客户端）发送一个<code>FIN</code>报文，表示自己的数据已发送完毕。进入<code>FIN_WAIT_1</code>状态。</li><li><strong>第二次挥手 (ACK)</strong>：被动关闭方（服务器）收到<code>FIN</code>后，回复一个<code>ACK</code>报文。此时，连接处于<strong>半关闭</strong>状态，服务器仍然可以向客户端发送数据。</li><li><strong>第三次挥手 (FIN)</strong>：服务器也准备好关闭连接时，发送一个<code>FIN</code>报文给客户端。进入<code>LAST_ACK</code>状态。</li><li><strong>第四次挥手 (ACK)</strong>：客户端收到服务器的<code>FIN</code>后，回复一个<code>ACK</code>报文。发送后，客户端进入**<code>TIME_WAIT</code>**状态。服务器收到这个ACK后，立即关闭连接。</li></ul><p><code>TIME_WAIT</code>状态？</p><ol><li><strong>可靠地终止TCP连接</strong>：这是最主要的原因。四次挥手中的<strong>最后一个ACK报文是由主动关闭方（客户端）发出的</strong>。这个ACK报文有可能会在网络中丢失。如果丢失，被动关闭方（服务器）就收不到确认，它会<strong>超时重传它的FIN报文</strong>。如果此时客户端已经彻底关闭连接，它将无法响应这个重传的FIN，导致服务器永远无法正常关闭。而处于<code>TIME_WAIT</code>状态的客户端，仍然能接收到这个重传的FIN，并<strong>重新发送一次ACK</strong>，从而确保服务器能够正常关闭。</li><li><strong>防止已失效的报文段被新连接误接收</strong>：考虑一个场景：一个TCP连接（由<code>源IP:源端口, 目的IP:目的端口</code>这个四元组唯一标识）关闭后，马上又用<strong>完全相同的四元组</strong>建立了一个新的连接。此时，网络中可能还存在上一个旧连接中延迟到达的报文段。如果没有<code>TIME_WAIT</code>状态，这些“迷路”的旧报文段就可能会被这个新连接误认为是合法数据并接收，造成数据错乱。</li></ol><p><strong>为什么等待时间是 <code>2MSL</code>？</strong></p><ul><li>**MSL（Maximum Segment Lifetime）*<em>是指一个TCP报文段在网络中可能存活的*<em>最长时间</em></em>。任何报文在超过MSL后，都会被网络丢弃。</li></ul><p><strong><code>2MSL</code>的时间足以保证在一个连接的一去一回两个方向上，所有的报文段都能在网络中自然消失</strong>。当<code>TIME_WAIT</code>状态结束后，可以保证网络中不再有任何与旧连接相关的“幽灵”报文段，此时再建立新的连接就是完全安全的。</p><h2 id="3-在-TCP-三次握手过程中，如果第三次握手的-ACK-报文丢失了，会发生什么？">3.在 TCP 三次握手过程中，如果<strong>第三次握手的 ACK 报文丢失</strong>了，会发生什么？</h2><p>三次握手分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYN` -&gt; `SYN+ACK` -&gt; `ACK</span><br></pre></td></tr></table></figure><ul><li><strong>服务端状态：</strong> 当服务端发送完 <code>SYN+ACK</code> 之后，它会进入 <strong><code>SYN_RCVD</code></strong> 状态，并<strong>启动一个定时器</strong>，等待客户端的第三次 <code>ACK</code>。</li><li><strong>客户端状态：</strong> 当客户端发送完第三次 <code>ACK</code> 之后，它<strong>单方面认为连接已经建立</strong>，状态会变为 <strong><code>ESTABLISHED</code></strong>。</li></ul><p>因为是<strong>服务端</strong>在 <code>SYN_RCVD</code> 状态下等待第三次 <code>ACK</code> 超时了。当定时器超时后，服务端会<strong>重新发送 <code>SYN+ACK</code> 包</strong>给客户端。重传的次数由系统参数（如 <code>net.ipv4.tcp_synack_retries</code>）控制。</p><p>在 <code>SYN_RCVD</code> 状态下，连接并未完全建立。对于服务端应用层来说，它通过 <code>accept()</code> 拿到的连接还处于一个“半连接队列”中，<strong>应用层是无法使用这个连接的</strong>，所以服务端应用层<strong>无感知</strong>。</p><p>因为客户端在发送完第三次 <code>ACK</code> 后，其内核协议栈就认为连接已建立（<code>ESTABLISHED</code> 状态），所以对于客户端应用层来说，<code>connect()</code> 系统调用<strong>会立即返回成功</strong>。此时，客户端应用层<strong>会认为连接已经建立成功，并开始发送数据</strong>。</p><p>处理：</p><ul><li>客户端应用层发送的数据，会和因为第三次 ACK 丢失而重传的 <code>SYN+ACK</code> 在网络中交汇。</li><li>当客户端收到服务端重传的 <code>SYN+ACK</code> 后，它的内核会意识到自己之前发送的 <code>ACK</code> 可能丢失了，于是会<strong>再次发送一个 <code>ACK</code></strong> 给服务端。</li><li>当服务端收到了这个新的 <code>ACK</code> 后（无论是客户端重发的，还是伴随着数据包一起过来的），服务端状态才会变为 <code>ESTABLISHED</code>，连接才真正建立，之前客户端发送的数据才会被服务端应用层接收。</li></ul><p>TCP状态机转变：CLOSED<code>-&gt;</code>SYN_SENT<code>-&gt;</code>SYN_RCVD<code>-&gt;</code>ESTABLISHE</p><h1>异常解决</h1><h2 id="1-就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢">1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢</h2><p>线上出现异常，我会遵循一套<strong>从宏观到微观、由表及里</strong>的排查SOP（标准作业程序）来定位和解决问题。</p><p><strong>第一步：信息收集与初步判断</strong></p><ol><li><p><strong>确认影响范围</strong>：首先，快速判断这个异常的影响面有多大。是影响了所有用户，还是部分用户？是核心功能还是边缘功能？这决定了问题的紧急程度。</p></li><li><p>查看监控告警：立即查看监控系统（如Prometheus/Grafana, Zabbix）的告警信息。检查应用的</p><p>关键指标，如：</p><ul><li><strong>应用层面</strong>：QPS、响应时间（RT）、错误率（Error Rate）是否突增？</li><li><strong>JVM层面</strong>：CPU使用率、内存占用、GC活动是否异常？</li><li><strong>主机层面</strong>：服务器的CPU、内存、磁盘I/O、网络流量是否正常？</li><li><strong>依赖服务</strong>：数据库、Redis、MQ等中间件的健康状况如何？</li><li>这一步的目标是快速定位问题是出在<strong>应用本身</strong>，还是<strong>外部依赖</strong>。</li></ul></li></ol><p><strong>第二步：日志分析与精准定位</strong></p><ol><li><strong>聚合日志平台检索</strong>：登录ELK（Elasticsearch, Logstash, Kibana）或类似日志平台，根据告警信息中的时间点、错误信息关键字（如<code>RuntimeException</code>）进行检索。</li><li><strong>利用Trace ID进行链路追踪</strong>：如果系统接入了分布式追踪系统（如SkyWalking, Zipkin），这是最强大的工具。我会根据报错信息找到一个<strong>Trace ID</strong>，然后用这个ID查询完整的请求调用链。这可以清晰地看到请求经过了哪些服务，在哪一个环节耗时最长，又是在哪个服务的具体代码行抛出了异常。</li><li>Linux服务器手动排查（作为补充）：如果日志平台不完善，我会登录到具体的服务器上进行排查。<ul><li>使用<code>grep</code>命令根据关键字快速过滤日志：<code>grep -C 10 'ExceptionNameToFind' /path/to/app.log</code>。<code>-C 10</code>可以显示异常上下文的10行，帮助理解问题背景。</li><li>如果需要根据Trace ID查，我会用：<code>grep 'your-trace-id' /path/to/app.log</code>。</li><li>对于实时滚动的日志，我会用<code>tail -f /path/to/app.log | grep 'ERROR'</code>来实时监控错误输出。</li></ul></li></ol><p>第三步：<strong>根因分析与问题复现</strong></p><ol><li><strong>代码分析</strong>：定位到具体的异常代码后，分析代码逻辑，判断是业务逻辑错误、空指针、并发问题还是资源未释放等。</li><li><strong>环境复现</strong>：如果可能，尝试在测试环境或预发环境，构造相同的参数和条件，复现这个问题，以便于调试和验证修复方案。</li></ol><p>第四步：<strong>问题解决与复盘</strong></p><ol><li><strong>紧急修复</strong>：如果是严重Bug，立即进行Hotfix修复并上线。如果是资源问题，进行扩容或配置调整。</li><li><strong>复盘总结</strong>：问题解决后，必须进行复盘。分析问题发生的根本原因，是代码缺陷、设计不合理、还是容量预估不足？并制定改进措施，例如增加单元测试、完善监控告警、优化架构等，防止同类问题再次发生。</li></ol><h2 id="2-考察线上问题排查">2.考察线上问题排查</h2><ul><li><p><strong>第一步：紧急止血（恢复服务优先）。</strong></p></li><li><p><strong>第二步：定位根因（Root Cause）。</strong></p></li><li><p><strong>第三步：复盘总结（避免再犯）。</strong></p></li><li><p>\1. 看监控，定范围：</p><ul><li><strong>看应用自身监控：</strong> 接口的 QPS、P99 响应时间、JVM（GC次数/时间、线程数）、线程池监控（队列长度、活跃线程数）。首先确认是自身应用的问题还是外部问题。</li><li><strong>看主机监控：</strong> CPU 使用率、内存占用、网络 I/O、磁盘 I/O。确认是不是机器资源被打满了。</li></ul></li><li><p>\2. 分析线程，找瓶颈：</p><ul><li>使用 <code>jstack</code> 命令 dump 线程堆栈。分析是否有大量线程处于 <code>BLOCKED</code> 状态（锁竞争）、<code>WAITING</code> 状态（等待外部资源，如 HTTP 调用、数据库连接）。这是定位问题的<strong>最核心手段</strong>。</li></ul></li><li><p>\3. 查GC，判影响：</p><ul><li>使用 <code>jstat -gcutil</code> 查看 GC 情况。确认是否发生了频繁的 Full GC，导致 STW（Stop-The-World），从而影响接口响应。</li></ul></li><li><p>\4. 查依赖，判外部：</p><ul><li>检查所有**下游服务（RPC 调用）**的响应时间。是不是某个下游服务变慢，拖垮了你。</li><li>检查**数据库和缓存（Redis）**的慢查询日志和响应时间。是不是因为慢 SQL 或 Redis 大 Key 导致的阻塞。</li></ul></li><li><p>\5. 看网络，做补充：</p><ul><li>如果以上都正常，再考虑网络问题，比如丢包、重传等。</li></ul></li></ul><p>恢复手段：</p><ul><li><strong>重启大法：</strong> 最简单粗暴但有效。</li><li><strong>服务降级：</strong> 通过配置中心，暂时关闭一些非核心功能。</li><li><strong>服务限流：</strong> 立即调低接口的 QPS 阈值，避免被流量打垮。</li><li><strong>扩容：</strong> 如果是资源不足，立即进行水平扩容。</li></ul><h2 id="3-线上问题卡顿">3.线上问题卡顿</h2><p>提出了一个“自顶向下”的排查思路：先通过监控工具（宝塔）看服务器资源（CPU、内存），定位到具体程序，再通过程序的日志（Docker日志）定位到具体组件和代码异常。</p><p>Linux 命令行工具（如 <code>top</code>, <code>jstack</code>, <code>jmap</code>）的提及。对于一个硬核的技术面试，面试官更希望听到你如何使用这些底层工具进行排查。此外，排查的维度不够全面，没有考虑到<strong>网络问题、数据库慢查询、下游服务拖累</strong>等常见原因。</p><h2 id="AI">AI</h2><h2 id="1-设计一个可扩展的架构，并说明如何实现-1-2-秒-P95-的延迟指标。">1.设计一个可扩展的架构，并说明如何实现 <strong>1-2 秒 P95 的延迟指标</strong>。</h2><p><strong>召回、重排、向量库更新、上下文窗口管理、长对话状态持久化</strong>，以及<strong>延迟预算分配</strong>几个维度，</p><p>RAG 的核心流程：文档切分 -&gt; 向量化入库 -&gt; 用户问题向量化 -&gt; Top K 相似度检索 -&gt; 结果送入 LLM 生成答案。RAG 是为了解决 LLM 没有“记忆”和无法利用私有知识的问题。</p><ul><li><strong>召回（Recall）：</strong> 你只提到了向量相似度检索。但一个生产级的 RAG 系统，召回层通常是<strong>混合检索</strong>，比如 <strong>向量检索 + 关键词检索（如 BM25）</strong>，以应对不同类型的问题。</li><li><strong>重排（Rerank）：</strong> 你提到了重排模型，但没有说明它的作用。Rerank 模型（如 Cohere Rerank）通常是一个轻量级的交叉编码器模型，它会对召回的 Top N（比如 N=50）个文档，进行更精细化的相关性打分，再选出最终的 Top K（比如 K=5）送给 LLM，能<strong>显著提升最终答案的质量</strong>。</li><li><strong>向量库更新：</strong> 这是一个工程难题，你完全没有提及。如何处理知识的<strong>增量更新、修改和删除</strong>？是定期全量重建索引，还是采用支持实时更新的向量数据库？</li></ul><p>时间分配：</p><ul><li>用户问题预处理：50ms</li><li>向量化（Embedding）: 100ms</li><li>向量检索（Recall）: 150ms</li><li>重排（Rerank）: 200ms</li><li>LLM 生成（Generation）: 1000ms (这是大头)</li><li>网络开销等：500ms 然后你需要思考如何优化每个环节。比如，Embedding 模型和 Rerank 模型需要<strong>选择轻量级、高性能</strong>的版本；向量检索需要对索引进行<strong>优化</strong>（如 HNSW 索引的参数调优）；LLM 需要采用<strong>流式输出（Streaming）</strong>，让用户能更快地看到第一个 Token。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试-深入源码</title>
      <link>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/</link>
      <guid>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/</guid>
      <pubDate>Mon, 11 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;javase源码详解&lt;/h1&gt;
&lt;h2 id=&quot;1-和equal-和hashcode&quot;&gt;1.==和equal()和hashcode&lt;/h2&gt;
&lt;p&gt;==和equals函数对于基本类型来说， = =</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>javase源码详解</h1><h2 id="1-和equal-和hashcode">1.==和equal()和hashcode</h2><p>==和equals函数对于基本类型来说， = = 比较是值，equals不能比较基本类型</p><p>对于包装类型来说，== 比较的是对象的引用，就是对象的内存地址。而<code>equals()</code>通常被重写以比较对象的值。</p><p>需要注意的是，像Interger这种包装类具有缓存机制，如果在缓存的范围，==的结果可能就是true，因为他们都是指向常量池的同一个对象</p><p>对于引用类型来说，==比较的是其对象的内存地址，equals要分为两个情况，看这个类型到底重写了equals函数了没，重写了就按重写的比较，比如String类型，他的equals就是比较的对象的值。然后没有重写的话，equals内部还是使用 ==来比较。没有什么区别。还是比较的对象的内存地址</p><p>hashcode函数的作用是获取哈希码，然后确定该对象再hash表中的位置，比如hashmap,hashset,布隆过滤器等都用到了hashcode</p><p>hasecode分为好几种哈希函数，有取模的，有进行位运算的。我们在布隆过滤器中使用最好是使用两种hash函数来确定位的位置。</p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的</p><p>然后hashcode相同，equals不一定相同。hashcode不相同，这个对象一定不相同。这样的话，我们可以将hashcode和equals函数相结合。我们先用hash函数来判断，然后再用equals判断</p><p>如果这个对象真的不相同的话，那我们就可以用运行速度快的hash函数早判断。然后出现hash碰撞的时候我们再用equals函数来确定是不是真的相同。这样大大提高了效率，因为hash函数的运算是比equals快的。这也是hashmap,hashset，布隆过滤器的设计原理。</p><p>因此，我们在重写equals的时候，hashcode也必须重写，否则就会出现equals相等，但是hash不相同。就会出现重复值的问题</p><h2 id="2-BigDecimial处理精度丢失的问题">2.BigDecimial处理精度丢失的问题</h2><p><code>BigDecimal</code>是Java中用于处理高精度数值计算的类，尤其适用于金融、科学计算等对精度要求极高的场景。</p><p>最关键的就是两个字段：</p><ul><li><code>intVal</code>: 一个<code>BigInteger</code>对象，用于存储数值的<strong>非标度值 (unscaled value)</strong>。简单来说，就是去掉小数点后的整数值。</li><li><code>scale</code>: 一个<code>int</code>类型的整数，表示<strong>标度 (scale)</strong>。标度指的是小数点后的位数。例如，对于数值 123.45，<code>intVal</code>是12345，<code>scale</code>是2。</li></ul><p><code>BigDecimal</code> <strong>使用整数来表示数值，避免了浮点数的二进制表示法引入的精度问题。</strong> 它通过<code>scale</code>来记录小数点的位置，从而实现对小数的精确表示。</p><p>BigDecimal的运算都是基于BigInterger来实现的</p><ul><li><p>加减法的时候，调整两个数的sacle，对齐标度，然后将intval相加减，最好创建一个新的BigDecial对象，intval为相加减的结果，scale为调整后的标度</p></li><li><p>乘法，将两个数的intval想乘，然后scale为两个BigDecimal的scale的和</p></li><li><p>除法是最复杂的操作，因为可能产生无限循环小数，<code>BigDecimal</code>需要提供多种舍入模式 (RoundingMode) 来控制精度，比如</p><ul><li><p><code>ROUND_UP</code>: 向上舍入</p></li><li><p><code>ROUND_DOWN</code>: 向下舍入</p></li><li><p><code>ROUND_CEILING</code>: 向正无穷方向舍入</p></li><li><p><code>ROUND_FLOOR</code>: 向负无穷方向舍入</p></li><li><p><code>ROUND_HALF_UP</code>: 四舍五入 (大于等于0.5向上舍入)</p></li><li><p><code>ROUND_HALF_DOWN</code>: 五舍六入 (大于0.5向上舍入)</p></li><li><p><code>ROUND_HALF_EVEN</code>: 银行家舍入 (四舍六入，五看奇偶，偶舍奇入)<code>BigDecimal</code>会根据指定的舍入模式，计算出精确的结果，并截断到指定的精度。</p></li></ul></li></ul><p>但是会出现很多个BigDecimal对象：Bigdecimal 是一个immutable类，每次计算都会new一个新的对象。如果在一个循环内多次使用bigdecimal，会生成很多对象，影响性能，建议如果在循化内不要使用string 构造出bigdecimal, 否则生成大量的string对象和bigdecimal对象</p><h2 id="3-变量">3.变量</h2><p>成员变量&amp;&amp;局部变量对比–变量存储的内存地址对应的任意随机值</p><ul><li>定义：成员变量是属于类的，局部变量是在代码块或者方法之中的</li><li>存储：成员变量如果是使用static的话，那这个成员变量属于类，没有的话，在堆。局部变量在栈，栈之中维护了一个局部变量表</li><li>生存时间：成员变量是对象的一部分，跟对象的生命周期一样，局部变量跟他的方法的生命周期一样</li><li>默认值：成员变量没有被赋值的话，一般都会是类型的默认值，除非是final修饰的，必须显示的赋值，局部变量不赋值会报错。</li></ul><table><thead><tr><th>特性</th><th>成员变量 (Instance Variable)</th><th>成员变量 (Static Variable)</th><th>局部变量 (Local Variable)</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>属于类的属性，在类中方法外定义。</td><td>属于类的静态属性，在类中方法外定义，用<code>static</code>修饰。</td><td>在方法、代码块（如<code>if</code>、<code>for</code>语句内部）中定义的变量。</td></tr><tr><td><strong>存储</strong></td><td>存储在堆内存（Heap）中，作为对象的一部分。</td><td>存储在方法区（Method Area）或元空间(Metaspace)中。（JDK8+之后静态变量从方法区移动到了堆中，但逻辑概念上仍与类相关联）</td><td>存储在Java虚拟机栈（Java Virtual Machine Stack）的栈帧（Stack Frame）的局部变量表中。</td></tr><tr><td><strong>生命周期</strong></td><td>随着对象的创建而创建，随着对象的销毁而销毁。</td><td>随着类的加载而创建，随着类的卸载而销毁。（实际上与类的 Class 对象关联）</td><td>随着方法的调用而创建，随着方法的执行结束而销毁。</td></tr><tr><td><strong>默认值</strong></td><td>存在默认值。如果没有显式赋值，会赋予类型的默认值（如<code>int</code>为0，<code>boolean</code>为<code>false</code>，<code>Object</code>为<code>null</code>）。</td><td>static 变量在类加载的准备阶段就会赋默认值. 如果没有显式赋值，会赋予类型的默认值（如<code>int</code>为0，<code>boolean</code>为<code>false</code>，<code>Object</code>为<code>null</code>）。</td><td>不存在默认值。<strong>必须显式赋值</strong>后才能使用，否则编译报错。</td></tr><tr><td><strong>final修饰</strong></td><td><code>final</code>修饰的成员变量必须在对象创建前（构造器或声明时）显式赋值，之后不能修改。</td><td><code>final static</code>修饰的成员变量必须在类加载完成前（静态代码块或声明时）显式赋值，之后不能修改。</td><td><code>final</code>修饰的局部变量必须在使用前显式赋值，之后不能修改。</td></tr><tr><td><strong>线程安全</strong></td><td>线程不安全，每个对象都有一份独立的成员变量副本，如果多个线程修改同一个对象的成员变量，可能导致数据不一致。</td><td>线程安全，所有该类的对象共享同一个静态变量，需要进行同步处理才能保证线程安全。</td><td>线程安全，局部变量只在当前线程的栈帧中有效，不同线程之间互不影响。</td></tr></tbody></table><h2 id="4-String家族三位">4.String家族三位</h2><p>String家族的三位分别是String StringBuffer StringBulider，除去String,剩下的两个都是继承自AbstractStringBuilder</p><p>其中String是不可变的，StringBuffer和StringBulider是可变的，他们都有append等方法来操作字符串</p><p>不同的是StringBuffer是线程安全的，通过同步锁加到方法上，可以多线程操作，而StringBulider是线程不安全的，一般单线程操作。因此StringBulider的性能是最高的</p><p>那么为什么String是不可变的呢？</p><p>String类中使用final来修饰字符串数组来，导致他的引用类型不能再指向其他的对象，并且数组的私有的。并且没有提供暴露这个字符串的方法</p><p>final导致String不能被继承，进而避免了子类破坏String</p><p>字符串拼接使用什么？变量少的时候使用+，然后变量多的时候使用StringBulider，防止在循环中使用，建立多个StringBulider对象</p><p>在我们JVM的堆中，存在一个字符串常量池，主要就是为了避免字符串的重复的问题</p><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>我们去new一个新的字符串的时候，会看字符串常量池有没有这个字符串，有的话，直接返回该字符串的引用。没有的话，JVM会在常量池中创建该字符，然后返回他的引用，也就是说我们新建了两个对象</p><h2 id="5-常见的IO-拷贝">5.常见的IO&amp;&amp;拷贝</h2><p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p><p>我们的用户进程想要进行IO操作的话，必须通过系统调用来访问内核空间，也就是拷贝，从用户态转变为内核态进行拷贝</p><p>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</p><p>常见的IO模型：</p><p><strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><p>在我们的java中，有三种常见的IO</p><p>BIO：属于同步堵塞的IO，同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。在客户端连接数量不高的情况下，是没问题的。但是高了就没办法了</p><p>NIO：Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>同步非阻塞 IO，发起一个 read 调用，如果数据没有准备好，这个时候应用程序可以不阻塞等待，而是切换去做一些小的计算任务，然后很快回来继续发起 read 调用，也就是轮询。这个<br>轮询不是持续不断发起的，会有间隙, 这个间隙的利用就是同步非阻塞 IO 比同步阻塞 IO 高效的地方。</p><p>但是这样有问题的，程序需要不断进行IO系统轮询来判断是不是准备好了,然后就出现了我的IO多路复用</p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><p>线程通过<code>select</code>、<code>poll</code>或<code>epoll</code>等系统调用，<strong>监听多个文件描述符（File Descriptor, FD）</strong>，一旦某个FD就绪（可读、可写），就通知应用程序。</p></li><li><p><strong>select 调用</strong>：最大连接数有限制（通常是1024），由<code>FD_SETSIZE</code>决定。每次调用都需要将FD集合从用户空间拷贝到内核空间，开销大。内核采用轮询方式检查FD是否就绪，效率低。</p></li><li><p>poll调用：取消了最大连接数的限制。同样需要将FD集合拷贝到内核空间。</p></li><li><p><strong>epoll 调用</strong>：基于事件驱动，只关注就绪的FD，避免了无意义的轮询。采用红黑树存储FD，查找效率高。使用<code>mmap</code>技术，减少了用户空间和内核空间之间的数据拷贝。</p></li></ul><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>而我们java中的NIO,最重要的三个组件，<strong>Selector</strong> ，Buffer，Channel</p><p>通过<strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。然后数据通过Channel让客户端将数据写入到Buffer中去</p><ul><li><code>Channel</code>: <strong>代表一个连接通道，负责数据的读写。</strong> <code>Channel</code> 类似于传统 I/O 中的流 (Stream)，但更加灵活，可以进行双向数据传输。</li><li><code>Buffer</code>: <strong>缓冲区，用于存储数据。</strong> NIO 使用缓冲区来读写数据，而不是直接操作流。 Java NIO 支持多种类型的缓冲区，例如 <code>ByteBuffer</code>、<code>CharBuffer</code>、<code>IntBuffer</code> 等。</li><li><code>Selector</code>: <strong>多路复用器，用于监听多个<code>Channel</code>的事件。</strong> 一个 <code>Selector</code> 可以同时监听多个 <code>Channel</code> 的连接、读、写等事件。 通过 Selector， 只需要一个线程即可管理多个 Channel，实现高效的 I/O 多路复用。</li><li><strong>Reactor模式和Proactor模式：</strong> 是两种常用的并发编程模式，分别对应I/O多路复用和异步I/O。 Netty 采用了 Reactor模式。</li></ul><p>AIO：</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>然后我们需要数据进行传输的时候，就需要对数据进行拷贝。比如用户进程在从硬盘里传输数据的时候，需要从用户态转为内核态然后才能进行拷贝。这样的话，效率比较慢，然后我们就出现了零拷贝技术</p><p>传统的数据传输流程中，用户数据通常会经过如下多次拷贝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘 → 内核缓冲区 → 用户态 → Socket 缓冲区 → 网卡</span><br></pre></td></tr></table></figure><p>一般来说文件拷贝是要拷贝四次的，</p><p>当用户进程调用<code>read()</code>，用户态无法调用内核态的设备，只能触发系统调用（IO）。这时计算机需要从用户态切换为内核态。</p><p>到达内核态之后，计算机通过<code>DMA</code>控制器将数据从磁盘读取出来，放到内核的缓冲区。完成第一次拷贝。</p><p>CPU需要将缓冲区的数据拷贝到用户态的缓冲区，完成第二次拷贝，也是read()函数的返回。这时计算器需要从内核态切换为用户态。</p><p>因为最终的数据需要通过网卡输出，所以用户进程就需要调用<code>write()</code>函数，CPU将用户缓冲区的数据拷贝到<code>Socket</code>缓冲区，完成第三次拷贝。同时需要再次触发系统调用。这时计算机又需要从用户态切换为内核态。</p><p><code>DMA</code>控制器把数据从<code>Socket</code>缓冲区，拷贝到网卡设备输出，至此完成第四次拷贝。同时需要将内核态切换为用户态，<code>write()</code>函数返回。</p><p>而“零拷贝”技术通过内核优化和 API 支持，能<strong>避免数据在用户态与内核态间的多次拷贝</strong>，从而提升性能。常用技术：</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td><code>mmap</code></td><td>将文件映射到内存地址空间，避免文件拷贝</td></tr><tr><td><code>sendfile</code></td><td>直接将文件从磁盘发送到 Socket，避免数据进入用户态</td></tr><tr><td><code>writev</code></td><td>批量写入多个内存区域，减少系统调用</td></tr><tr><td><code>DirectByteBuffer</code>（Java NIO）</td><td>Java 堆外内存，提高 I/O 性能</td></tr></tbody></table><p>mmap</p><ul><li><code>mmap</code>将一个文件或者其他对象映射到进程的地址空间，实现<strong>文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一映射关系</strong>。应用程序可以直接读写映射的内存区域，而<strong>不需要进行显式的<code>read</code>和<code>write</code>系统调用</strong>。</li><li><strong>原理：</strong> <code>mmap</code> 减少了数据在内核空间和用户空间之间的拷贝。 只需要从磁盘拷贝到内核缓冲区，然后用户进程直接从内核缓冲区读取数据，而无需再拷贝到用户空间。</li><li><strong>适用场景：</strong> 适用于需要频繁读写同一文件的场景，例如大型数据库、共享内存等。</li><li>存在的问题：<ul><li><code>mmap</code> 对文件读写仍然需要两次上下文切换。</li><li>如果多个进程同时对同一文件进行<code>mmap</code>映射，可能会导致数据不一致的问题。</li></ul></li><li><strong>使用场景:</strong> 常用于读取静态资源。</li></ul><p><strong>sendfile()</strong></p><p>sendfile() 系统调用允许将数据从一个文件描述符 (例如， 文件)  直接传输到另一个文件描述符 (例如， Socket)。  避免了数据在用户空间和内核空间之间的拷贝。</p><ol><li>用户进程调用 <code>sendfile()</code> 系统调用， 指定输入和输出文件描述符。</li><li>数据通过 DMA 从磁盘读取到内核缓冲区。</li><li>数据直接从内核缓冲区拷贝到 Socket 缓冲区，或者更优的方式是：只有描述符信息从内核缓冲区拷贝到socket缓冲区。</li><li>数据通过 DMA 从 Socket 缓冲区传输到网卡。</li></ol><p>静态文件服务器（例如 Nginx）通常使用 sendfile() 来将静态文件发送给客户端。只能适用于数据从文件传输到Socket的场景，范围有限</p><p><strong>splice() (管道):</strong></p><p>splice() 系统调用允许在两个文件描述符之间移动数据，而不需要在用户空间和内核空间之间进行复制。</p><ol><li>创建两个管道(pipe)对象</li><li>调用 splice() 系统调用,将数据从输入文件描述符读取到第一个管道.</li><li>调用 splice() 系统调用,将数据从管道数据写到socket 。</li></ol><p>适用于需要数据传输与转换(类似于Linux的管道操作)的场景</p><p><strong>Direct I/O</strong>：</p><p>Direct I/O 允许用户进程绕过内核缓冲区 (Page Cache)， 直接访问磁盘。</p><ol><li>用户进程发起 Direct I/O 请求。</li><li>数据通过 DMA 直接从磁盘传输到用户进程的缓冲区。</li></ol><ul><li>需要用户进程自己管理缓存，增加了开发的复杂性。</li><li>可能影响系统的整体性能， 因为绕过了 Page Cache。 （Page Cache 可以缓存热点数据，提高访问速度）。</li></ul><p>大型数据库（例如 Oracle）通常使用 Direct I/O 来进行数据读写， 因为数据库有自己的缓存管理机制。</p><p><strong><code>DirectByteBuffer</code> (Java NIO)：</strong></p><ul><li>是Java NIO 提供的一种堆外内存分配方式，它<strong>允许JVM直接在操作系统本地内存（堆外内存）中分配缓冲区，而不是在JVM堆中分配。</strong></li><li><strong>避免了数据从JVM堆内存拷贝到直接内存 (Native memory) 的过程。</strong></li><li><strong>适用场景：</strong> 适用于需要高效I/O的场景，例如网络服务器、大数据处理等。</li><li><strong>原理：</strong> <code>DirectByteBuffer</code>并不是真正意义上的零拷贝，因为它仍然需要在用户空间和内核空间之间进行数据拷贝。 但是，它可以减少一次数据拷贝，从而提高I/O性能。 通过调用操作系统的<code>read</code>方法，将数据从IO端口读取到这个直接内存。</li></ul><p>好处：</p><ul><li><strong>减少数据拷贝次数：</strong> 降低CPU的开销， 提高I/O效率。</li><li><strong>减少上下文切换次数：</strong> 降低系统开销， 提高并发能力。</li><li><strong>提高数据传输速度：</strong> 缩短响应时间， 提供更好的用户体验。</li></ul><h2 id="6-Java中的值传递">6.Java中的值传递</h2><ul><li><strong>值传递</strong>：方法接收的是实参值的拷贝，会创建副本。</li><li><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li></ul><p>但是在java中只有值传递</p><p>比如我们设定一个简单的swap方法，交换值得方法，num1=a num2=b</p><p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p>再比如</p><p>我们设定一个swap方法，交换两个Person参数</p><p>然后我们发现<code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p><p>java值传参：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h2 id="7-序列化-反序列化">7.序列化&amp;&amp;反序列化</h2><ul><li><strong>序列化</strong>：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程</li></ul><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化</li></ul><p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。</p><p>然后我们有好几种序列化的方式,jdk自带的效率低且有安全问题，比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><ul><li><p>jdk自带的序列化方式，只需要实现Serializable接口即可，我们一般会加上一个私有静态final的变量，serialVersionUID。是类似于版本控制的效果，如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。<code>serialVersionUID</code> 是一个特例，<code>serialVersionUID</code> 的序列化做了特殊处理。关键在于，<code>serialVersionUID</code> 不是作为对象状态的一部分被序列化的，而是被序列化机制本身用作一个特殊的“指纹”或“版本号”</p></li><li><p>对于我们不想进行序列化的变量，可以使用<code>transient</code> 关键字修饰。阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。<code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。除了serialVersionUID以外。</p></li><li><p>Kryo ，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。使用的时候也是需要实现Serializer接口，然后分别去重写serialize方法和deserialize方法</p></li><li><p>Protobuf，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p></li><li><p>Protostuff，protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p></li></ul><p>这些反序列化的话，会有漏洞</p><p>许多序列化协议都存在反序列化漏洞，攻击者可以通过构造恶意的序列化数据，在反序列化过程中执行任意代码，从而控制目标系统。比如kryo</p><ul><li>防止反序列化漏洞的措施：<ul><li>避免使用存在已知漏洞的序列化协议。</li><li>对序列化数据进行签名或加密，防止篡改。</li><li>使用白名单机制，只允许反序列化特定类型的对象。</li><li>限制反序列化的深度和复杂度，防止资源耗尽。</li></ul></li></ul><h2 id="8-Unsafe解析">8.Unsafe解析</h2><p><code>Unsafe</code> 是位于 <code>sun.misc</code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等</p><p><code>Unsafe</code> 提供的这些功能的实现需要依赖本地方法（Native Method），本地方法使用 <strong><code>native</code></strong> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 <strong>本地代码</strong>。</p><p><code>Unsafe</code> 类为一单例实现，提供静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code>实例。这个看上去貌似可以用来获取 <code>Unsafe</code> 实例。但是，当我们直接调用这个静态方法的时候，会抛出 <code>SecurityException</code> 异常</p><p>这是因为在<code>getUnsafe</code>方法中，会对调用者的<code>classLoader</code>进行检查，判断当前类是否由<code>Bootstrap classLoader</code>加载，如果不是的话那么就会抛出一个<code>SecurityException</code>异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。</p><p>为什么这个类这么严格？<code>Unsafe</code> 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。</p><p>那我们该怎么去获取unsafe的实例呢？</p><ol><li>利用反射获得 Unsafe 类中已经实例化完成的单例对象 <code>theUnsafe</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>从<code>getUnsafe</code>方法的使用限制条件出发，通过 Java 命令行命令<code>-Xbootclasspath/a</code>把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取 Unsafe 实例。</li></ol><p>Unsafe的功能多种多样，比如内存操作，内存屏障，对象操作，数据操作，CAS 操作，线程调度，Class 操作，系统信息</p><ol><li>内存操作：</li></ol><p>在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure><p>通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p><p>那我们为什么要使用堆外内存？</p><p>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</p><p>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</p><p>比如：<code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。类似实现了零拷贝的功能，但是其实他并没有实现零拷贝。创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放</p><ol start="2"><li>内存屏障：</li></ol><p>编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p><p>比如我们的voliate关键词就是通过内存屏障，来保证了禁止重排。主要是就是保证读写的屏障</p><p>内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能</p><p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p><p>应用：</p><p><code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p><p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p><ol start="3"><li>对象操作：</li></ol><p>对象成员属性的内存偏移量获取，以及字段属性值的修改</p><p>Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。</p><p>基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）</p><p><code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。</p><p><code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p><p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。</p><p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型。</p><p>其中：</p><ul><li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li><li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li></ul><p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p><ol start="4"><li>对象实例化：</li></ol><p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p><p><code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但<code>allocateInstance</code>方法仍然有效。</p><p>比如：</p><p>new 机制有个特点就是当类只提供有参的构造函数且无显式声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</p><p>Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用</p><p>5.数组操作：</p><p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回数组中第一个元素的偏移地址</span><br><span class="line">public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);</span><br><span class="line">//返回数组中一个元素占用的大小</span><br><span class="line">public native int arrayIndexScale(Class&lt;?&gt; arrayClass);</span><br></pre></td></tr></table></figure><p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code>、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作</p><ol start="6"><li>CAS</li></ol><p>CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p><p>在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p><p>如果 CAS 操作成功（返回 true），则打印 <code>targetValue</code> 并退出循环。</p><p>如果 CAS 操作失败，或者 <code>currentValue</code> 不满足条件，则当前线程会继续循环（自旋），并通过 <code>Thread.yield()</code> 尝试让出 CPU，直到成功更新并打印或者条件满足。</p><p>这样我们就可以通过CAS来实现多个线程1-9的顺序输出,a=0</p><p>线程1是 i&lt;5的情况，线程2是i&lt;10的情况</p><p>我们的CAS加的是(a,i-1,i);所以的话，线程一就是0-4的输出，线程2就是5-9.然后使用之前，我们要把获取unsafe实例和获取a字段的内存偏移量给静态加载进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 获取 a 字段的内存偏移量</span></span><br><span class="line">        fieldOffset = unsafe.objectFieldOffset(CasTest.class.getDeclaredField(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>线程调度</li></ol><p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure><p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常</p><p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code>、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code>、<code>unpark</code> 方式实现的</p><p>就是通过这个实现了CLH队列,减少了在等待队列里面消耗等待的时间</p><ol start="8"><li>Class操作</li></ol><p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取静态属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取静态属性的对象指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断类是否需要初始化（用于获取类的静态属性前进行检测）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure><p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code></p><h2 id="9-SPI机制">9.SPI机制</h2><h2 id="10-语法糖">10.语法糖</h2><h2 id="11-新特性（Java17-Java21）">11.新特性（Java17&amp;&amp;Java21）</h2><h3 id="1-虚拟线程-JDK21">1.虚拟线程 JDK21</h3><p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p><p>优点：</p><p><strong>非常轻量级</strong>：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</p><p><strong>简化异步编程</strong>： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。</p><p><strong>减少资源开销</strong>： 由于虚拟线程是由 JVM 实现的，它能够更高效地利用底层资源，例如 CPU 和内存。虚拟线程的上下文切换比平台线程更轻量，因此能够更好地支持高并发场景。</p><p>缺点：</p><p><strong>不适用于计算密集型任务</strong>： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。</p><p><strong>与某些第三方库不兼容</strong>： 虽然虚拟线程设计时考虑了与现有代码的兼容性，但某些依赖平台线程特性的第三方库可能不完全兼容虚拟线程。</p><p>创建方法：</p><ol><li><strong>使用 <code>Thread.startVirtualThread()</code> 创建</strong></li><li><strong>使用 <code>Thread.ofVirtual()</code> 创建</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CustomThread</span> <span class="variable">customThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomThread</span>();</span><br><span class="line">    <span class="comment">// 创建不启动</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">unStarted</span> <span class="operator">=</span> Thread.ofVirtual().unstarted(customThread);</span><br><span class="line">    unStarted.start();</span><br><span class="line">    <span class="comment">// 创建直接启动</span></span><br><span class="line">    Thread.ofVirtual().start(customThread);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用 <code>ThreadFactory</code> 创建</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustomThread customThread = new CustomThread();</span><br><span class="line">    ThreadFactory factory = Thread.ofVirtual().factory();</span><br><span class="line">    Thread thread = factory.newThread(customThread);</span><br><span class="line">    thread.start();</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>使用<code>Executors.newVirtualThreadPerTaskExecutor()</code>创建</strong></li></ol><h2 id="12-源码详解ArrayList">12.源码详解ArrayList</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。一开始先分配一个空间，然后后面快满了再进行扩容。list 列表的结尾会预留一定的容量空间</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><p><code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。</p><p>扩容机制的分析：</p><ul><li><p>默认的初始容量大小就是10，一般采用默认构造函数，创造一个空列表，<strong>实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p></li><li><p>带初始容量的构造参数，就使用用户指定的初始容量。&gt;0就用指定的，=0就创建空数组，&lt;0抛出异常</p></li><li><p>构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</p></li></ul><p>扩容的参数是**<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>**所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><h2 id="13-TreeMap">13.TreeMap</h2><p><code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</p><ul><li><p><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于等于、小于等于、严格大于、严格小于给定键的最接近的键值对。</p></li><li><p><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</p></li><li><p><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</p></li><li><p><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素</p></li></ul><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p>指定排序的比较器，重写compare方法</p><h2 id="14-HashMap底层分析-问题解析">14.HashMap底层分析&amp;问题解析</h2><ol><li>源码分析</li></ol><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p>通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置，使用位运算的计算速度快，而且HashMap的的容量都是2的次幂，然后这样我们就可以使用位运算，最高位的一个标志。根据这个来确定是否在原位置，0不动，1+当前的长度</p><p>负载因子：一般都是0.75，这是一个经验值，**loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。**长度的默认为16</p><ol start="2"><li>HashMap 的长度为什么是 2 的幂次方？</li></ol><p>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</p><p>可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</p><p>扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</p><ol start="3"><li>HashMap 多线程操作导致死循环问题</li></ol><p>JDK1.7 之前的版本，在多线程下，使用头插法容易形成环形链表。JDK1.8 版本的 HashMap 采用了尾插法，避免了环形问题，但多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题</p><ol start="4"><li>ConcurrentHashMap1.7 <strong>Segment 数组 + HashEntry 数组 + 链表</strong></li></ol><p>初始化逻辑：</p><ul><li><p>必要参数校验。</p></li><li><p>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></p></li><li><p>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</p></li><li><p>记录 <code>segmentShift</code> 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</p></li><li><p>记录 <code>segmentMask</code>，默认是 ssize - 1 = 16 -1 = 15.</p></li><li><p><strong>初始化 <code>segments[0]</code></strong>，<strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩</p></li></ul><p>根据put计算到key的位置，获取指定的Segment,如果为空那么初始化Segment</p><ol><li><p>检查计算得到的位置的 <code>Segment</code> 是否为 null.</p><p>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</p><p>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null.</p><p>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</p><p>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code></p></li><li><p><code>Segment.put</code> 插入 key,value 值。</p></li></ol><p>ConcurrentHashMap1.8 <strong>Node 数组 + 链表 / 红黑树</strong></p><p>的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化，其他线程需要自旋等待</li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>&gt;0 表示 table 扩容的阈值，如果 table 已经初始化</li></ol><p>put方法：</p><p>根据 key 计算出 hashcode 。</p><p>判断是否需要进行初始化。</p><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p><p>如果都不满足，则利用 synchronized 锁写入数据。</p><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务论坛设计方案</title>
      <link>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/</link>
      <guid>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/</guid>
      <pubDate>Sat, 09 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;技术栈应用&lt;/h1&gt;
&lt;p&gt;Nacos—服务注册&lt;/p&gt;
&lt;p&gt;OpenFeign—RPC&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seata&lt;/strong&gt; —分布式事务&lt;/p&gt;
&lt;h1&gt;真正内容设计亮点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于 Sa-Token</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>技术栈应用</h1><p>Nacos—服务注册</p><p>OpenFeign—RPC</p><p><strong>Seata</strong> —分布式事务</p><h1>真正内容设计亮点</h1><ul><li><strong>基于 Sa-Token 构建统一 OAuth2 认证中心</strong>，实现账号密码、短信验证码、第三方平台（微信/支付宝/GitHub 等）等多种登录方式；通过自定义 Token 生成与权限控制，实现细粒度角色/权限管理；集成 Redis 实现分布式会话共享，支持多微服务统一认证与单点登录（SSO）；结合注解与全局拦截器完成接口级鉴权，有效提升系统安全性与扩展性。</li><li>基于 <strong>Seata 分布式事务框架</strong> 实现跨微服务数据一致性保障，支持 AT/Saga/TCC 多事务模式；通过 Feign 拦截器实现全局事务上下文透传，结合异常分类回滚策略提升稳定性；引入事务监控与告警系统，支持事务状态实时追踪与自动补偿，显著降低人工介入成本。</li><li>设计并实现 <strong>基于 Spring Cloud Gateway 的全局认证过滤器</strong>，支持 JWT 多端统一认证、白名单动态管理、用户上下文透传；集成 Redis 实现 Token 黑名单与防重放攻击机制，提升系统安全性；引入链路追踪 ID 与异常告警体系，支持全链路请求跟踪与安全事件快速响应。</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务论坛问题收集</title>
      <link>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/</link>
      <guid>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/</guid>
      <pubDate>Sat, 09 Aug 2025 16:00:00 GMT</pubDate>
      
      
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringCloud-组件介绍</title>
      <link>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/</link>
      <guid>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/</guid>
      <pubDate>Fri, 08 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;p&gt;Spring Cloud 是一系列框架的有序集合。&lt;/p&gt;
&lt;p&gt;Spring Cloud 利用 Spring Boot</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本概念</h1><p>Spring Cloud 是一系列框架的有序集合。</p><p>Spring Cloud 利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>它将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><ul><li><p><strong>Spring Cloud Netflix</strong>：重要组件之一，与各种Netflix OSS组件集成，组成微服务的核心。</p></li><li><p><strong>Netflix Eureka</strong>：服务注册中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</p></li><li><p><strong>Netflix Hystrix</strong>：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p></li><li><p><strong>Spring Cloud Config</strong>：配置中心，配置管理工具包，可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Svn。</p></li><li><p><strong>Spring Cloud Bus</strong>：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</p></li><li><p><strong>Spring Cloud for Cloud Foundry</strong>：Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</p></li><li><p><strong>Spring Cloud Cluster</strong>:Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。</p></li><li><p><strong>Spring Cloud Zookeeper</strong>:操作Zookeeper的工具包，用于使用zookeeper方式进行服务发现和配置管理。</p></li><li><p><strong>Spring Cloud Starters</strong>:为Spring Cloud提供开箱即用的依赖管理。</p></li><li><p>Dubbo:基于RPC调⽤，对于⽬前使⽤率较⾼的Spring Cloud Netflix来说，它是基于HTTP的，所以效率上没有Dubbo⾼，但问题在于Dubbo体系的组件不全，不能够提供⼀站式解决⽅案。</p></li><li><p>Nocas:注册中⼼ + 配置中⼼的组合，帮助我们解决微服务开发必会涉及到的服务注册与发现，服务配置，服务管理等问题。<a href="https://zhida.zhihu.com/search?content_id=169091361&amp;content_type=Article&amp;match_order=1&amp;q=Nacos&amp;zhida_source=entity">Nacos</a> 是Spring Cloud Alibaba 核⼼组件之⼀，负责服务注册与发现，还有配置。</p></li><li><p>Zookeeper:Zookeeper ⽤来做服务注册中⼼，主要是因为它具有节点变更通知功能，只要客户端监听相关服务节点，服务节点的所有变更，都能及时的通知到监听客户端，这样作为调⽤⽅只要使⽤ Zookeeper 的客户端就能实现服务节点的订阅和 变更通知功能了，zookeeper遵循半数集群可用原则。</p></li><li><p>Ribbon负载均衡</p></li></ul><h1>开发组件选择</h1><h2 id="Eureka注册服务中心">Eureka注册服务中心</h2><p>在微服务项目中，我们一般会对一个项目，以业务的维度拆分至多个服务，比如用户服务、账务服务、订单服务、仓储服务等，这些服务在生产环境部署，<br>至少是2个服务实例，如果业务量大几十个都是有可能的。</p><p>订单服务实例部署了4个，仓库服务部署了5个，仓库服务要调用订单服务，如果没有注册中心，他会怎么做，那只有把对应的ip和端口写死在代码中，如果新增了一个订单服务怎么办？或者下线了订单服务怎么办？</p><p>另外，在云环境中，服务实例随时都有可能启动和关闭，随之IP也会发生变化，没法把IP写死在代码中。</p><p>基于以上问题就有了服务注册中心<code>Eureka</code></p><p><code>Eureka</code>能实现服务自动的注册和发现，在每次服务调用的时候根据服务名称会获取到目标服务的IP和端口，在进行调用。</p><p>如果服务下线或者上线，对应的服务的地址信息也会进行更新，这样就保证了，随时可以调用到有效的服务。</p><p>同时为了提高性能，这个服务地址信息会在每个服务本地缓存一份地址信息表，定时更新，这样每次请求服务时，不用每次去<code>Eureka</code>查询来降低服务调用耗时。</p><p>我们部署一个<code>Eureka Server</code>，并将我们的微服务（部门服务和用户服务）作为 Eureka 客户端，注册到<code>Eureka Server</code>，同时使用用户服务调用根据部门服务的<code>Service ID</code> 来调用部门服务相关接口。</p><p>在项目中添加组件Eureka Server，pom文件中进行导入</p><p>主方法上我们需要添加<code>@EnableEurekaServer</code>注解，使我们应用程序成为服务注册中心。</p><p>默认情况下，每个<code>Eureka Server</code> 也是一个<code>Eureka</code>客户端。由于我们只想让他做好服务注册中心，不想让他做客户端，因此我们将通过在<code>application.properties</code>文件中配置以下属性来禁用此客户端行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=Eureka Server</span><br><span class="line">server.port=8761</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8761</code>，会显示以下界面</p><p>然后将一个服务注册到Eureka Server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;spring-cloud.version&gt;2021.0.4&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>在application.properties中配置<code>eureka.client.service-url.defaultZone</code> 属性 即可自动注册到 Eureka Server。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.application.name=DEPARTMENT-SERVICE</span></span><br><span class="line"><span class="string">eureka.instance.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>当服务注册到 Eureka Server 时，它会在一定的时间间隔内不断发送心跳。如果 Eureka 服务器没有收到来自任何服务实例的心跳，它将假定该服务实例已关闭并将其从池中取出</p><p>然后目标服务添加注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;DEPARTMENT-SERVICE&quot;)</span><br></pre></td></tr></table></figure><h2 id="Open-Feign服务调用">Open Feign服务调用</h2><p>声明式 HTTP RPC 调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;forum-auth&quot;, path = &quot;/api/auth&quot;)</span><br></pre></td></tr></table></figure><p>表示这是一个 <strong>Feign 客户端接口</strong>，要去调用 <strong>名为 <code>forum-auth</code></strong> 的微服务。</p><ul><li><strong><code>name</code></strong>：对应 Spring Cloud 服务注册中心（如 Nacos、Eureka）里的服务名</li><li><strong><code>path</code></strong>：接口调用时统一加上的路径前缀</li></ul><p>你在别的模块里注入这个接口（<code>@Autowired AuthFeignClient client;</code>），就能直接<strong>像调用本地方法一样发起远程 HTTP 请求</strong>。</p><p>那么什么是RPC呢？</p><p>你写一个 Java 接口并打上 Feign 注解（不需要写实现类）。</p><p>Spring Cloud OpenFeign 会在运行时为这个接口创建 <strong>动态代理对象</strong>。</p><p>当你调用方法时，代理会根据注解信息拼接成 HTTP 请求（<code>GET /api/auth/...</code>），<br>并通过负载均衡（Ribbon/Spring Cloud LoadBalancer）调用到 <code>forum-auth</code> 服务的对应接口。</p><p>返回 JSON 会被自动反序列化成 <code>Result&lt;T&gt;</code> 类型。</p><h2 id="Nacos服务注册">Nacos服务注册</h2><p>config配置类：</p><p>@postconstruct的init方法，设置本地地址和元数据，重写run方法</p><p>然后写NacosShutdownHook类，关闭nacos，防止解决DefaultHttpClientFactory无法加载的问题。</p><p>然后再application文件中加入配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cloud:</span><br><span class="line">  nacos:</span><br><span class="line">    discovery:</span><br><span class="line">      server-addr: $&#123;NACOS_SERVER_ADDR:localhost:8848&#125;</span><br><span class="line">      namespace: $&#123;NACOS_NAMESPACE:&#125;</span><br><span class="line">      group: $&#123;NACOS_GROUP:DEFAULT_GROUP&#125;</span><br><span class="line">      enabled: true</span><br><span class="line">    config:</span><br><span class="line">      server-addr: $&#123;NACOS_SERVER_ADDR:localhost:8848&#125;</span><br><span class="line">      file-extension: yaml</span><br><span class="line">      namespace: $&#123;NACOS_NAMESPACE:&#125;</span><br><span class="line">      group: $&#123;NACOS_GROUP:DEFAULT_GROUP&#125;</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure><p>填写组别，发现端口，name名字，然后记录服务端的端口，组别等</p><h2 id="Seata-分布式事务">Seata 分布式事务</h2><p>​Config配置文件：</p><p>根据 <strong>环境</strong>（dev/test/prod）和 <strong>服务名</strong> 动态生成事务组名，避免不同环境污染。</p><p>使用配置中心（Nacos / Apollo）动态管理事务组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GlobalTransactionScanner <span class="title function_">globalTransactionScanner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">txServiceGroup</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s-%s-tx-group&quot;</span>,</span><br><span class="line">        System.getenv(<span class="string">&quot;SPRING_APPLICATION_NAME&quot;</span>),</span><br><span class="line">        System.getenv(<span class="string">&quot;ENV&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GlobalTransactionScanner</span>(<span class="string">&quot;forum-seata-group&quot;</span>, txServiceGroup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​不同的模式：</p><p>当前是 <strong>AT 模式</strong>（自动 SQL 拦截 + 全局锁），性能不错但会加大数据库锁粒度。</p><p>可以升级为：</p><p>对<strong>长事务/跨多服务耗时操作</strong>改用 <strong>Saga 模式</strong>（状态机驱动 + 补偿动作）。</p><p>对<strong>高并发热点写</strong>改用 <strong>TCC 模式</strong>（Try-Confirm-Cancel）避免全局锁。</p><p>​回滚策略：</p><p>然后对不同类型的异常，设定不同的回滚的策略</p><p>区分 <strong>业务异常</strong>（不回滚，如参数错误）和 <strong>系统异常</strong>（回滚，如数据库/网络错误）。</p><p>可自定义 <code>BusinessException</code> 并在 <code>@GlobalTransactional</code> 里排除。</p><p>​告警：</p><p>接入 <strong>Seata 控制台</strong>，实时查看全局事务状态。</p><p>通过 Prometheus + Grafana 做事务失败率/超时监控。</p><p>超时自动告警（钉钉/企业微信）。</p><p>集成 SkyWalking/Zipkin，将 XID 作为 TraceId 的一部分，方便跨服务链路分析。</p><p>在全局事务开始、提交、回滚时打业务日志。</p><h2 id="Gateway网关认证">Gateway网关认证</h2><p>安全性升级</p><ul><li><p>现在 JWT 一旦签发，在过期时间内无法撤销（除非改密钥）。升级建议：引入 Redis 存储<strong>黑名单 Token</strong>，用户登出或被封禁时将 Token 加入黑名单，网关在过滤器里校验。</p></li><li><p>目前 <code>JwtUtil</code> 应该是固定签名密钥，建议使用 <strong>定期轮换</strong>（Key Rotation），减少泄漏风险。可以用 <code>kid</code>（key id）标记密钥版本，JWT 验证时先取 <code>kid</code>，再用对应密钥解密。</p></li><li><p>给 Token 增加 <code>jti</code>（唯一 ID），在 Redis 里做一次性校验，防止别人抓包重放。</p></li></ul><p>扩展性升级</p><ul><li>白名单配置化，现在白名单是写死在代码里的，可以改成 Nacos / Apollo 配置动态加载：</li><li>现在你用 <code>X-User-Id</code>、<code>X-Username</code>，但可以考虑：全量透传 <code>claims</code>（JSON 压缩后放 header 或 Gateway Request Attribute）。或者只传一个 <code>User-Context</code> Base64，后端统一解码。</li></ul><p>性能优化</p><ul><li>Gateway 是 Reactor 模型，要确保 <code>JwtUtil</code> 验证不会有阻塞 IO（如 Redis、文件操作）。如果 JWT 公钥存 Redis，可提前加载到内存，用 <code>Cache</code> 缓存，减少每次请求访问 Redis。</li><li>白名单频繁变动时，用单个 <code>volatile</code> 变量指向 <code>Set&lt;String&gt;</code>，避免并发锁开销。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.forum.gateway.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.forum.common.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.ExpiredJwtException;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureException;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;AuthGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析缓存（避免每次都重复解析 JWT）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Claims&gt; tokenCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;gateway.auth.tokenHeader:Authorization&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthGatewayFilterFactory</span><span class="params">(JwtUtil jwtUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">        <span class="built_in">this</span>.jwtUtil = jwtUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 白名单放行</span></span><br><span class="line">            <span class="keyword">if</span> (isWhiteListed(path, config.getWhiteList())) &#123;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 Token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(request);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;缺少认证信息&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> tokenCache.computeIfAbsent(token, t -&gt; jwtUtil.getClaimsFromToken(t));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 校验 Token 是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (jwtUtil.isTokenExpired(token)) &#123;</span><br><span class="line">                    tokenCache.remove(token);</span><br><span class="line">                    <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;Token 已过期&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 提取用户信息并添加到请求头</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> StringUtils.defaultString(claims.getSubject(), <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">mutatedRequest</span> <span class="operator">=</span> request.mutate()</span><br><span class="line">                        .header(<span class="string">&quot;X-User-Id&quot;</span>, String.valueOf(userId))</span><br><span class="line">                        .header(<span class="string">&quot;X-Username&quot;</span>, username)</span><br><span class="line">                        .header(<span class="string">&quot;X-Trace-Id&quot;</span>, UUID.randomUUID().toString())</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange.mutate().request(mutatedRequest).build());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Token 已过期: &#123;&#125;&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;Token 已过期&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SignatureException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Token 签名无效: &#123;&#125;&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;无效的认证信息&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Token 验证失败&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isWhiteListed</span><span class="params">(String path, List&lt;String&gt; whiteList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> whiteList.stream().anyMatch(pattern -&gt;</span><br><span class="line">                path.equals(pattern) || path.startsWith(pattern) || pathMatcher.match(pattern, path)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getToken</span><span class="params">(ServerHttpRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeaders().getFirst(tokenHeader);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(authorization) &amp;&amp; authorization.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorization.substring(<span class="number">7</span>).trim();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">unauthorizedResponse</span><span class="params">(ServerWebExchange exchange, String message)</span> &#123;</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        response.getHeaders().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> String.format(<span class="string">&quot;&#123;\&quot;code\&quot;:401,\&quot;message\&quot;:\&quot;%s\&quot;,\&quot;timestamp\&quot;:%d&#125;&quot;</span>,</span><br><span class="line">                message, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; whiteList = Arrays.asList(</span><br><span class="line">                <span class="string">&quot;/auth/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/auth/register&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/auth/captcha&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/doc.html&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/swagger-ui/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/v3/api-docs/**&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-2</title>
      <link>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/</link>
      <guid>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/</guid>
      <pubDate>Mon, 28 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;面试回答优化&lt;/p&gt;
&lt;h1&gt;Gemini模拟面试2025.7.29&lt;/h1&gt;
&lt;p&gt;1.Java面向对象的基本特性：&lt;/p&gt;
&lt;p&gt;总：的介绍一下java面向对象&lt;/p&gt;
&lt;p&gt;分：封装，继承，多态&lt;/p&gt;
&lt;p&gt;总：好处&lt;/p&gt;
&lt;p&gt;2.Hashmap的原理&lt;/p&gt;
</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>面试回答优化</p><h1>Gemini模拟面试2025.7.29</h1><p>1.Java面向对象的基本特性：</p><p>总：的介绍一下java面向对象</p><p>分：封装，继承，多态</p><p>总：好处</p><p>2.Hashmap的原理</p><p>总：hashmap是个啥</p><p>分：</p><ol><li><p>基本数据结构类型，1.7 or 1.8</p></li><li><p>hash冲突解决</p></li><li><p>核心put过程</p></li><li><p>扩容机制，为什么是2倍</p></li><li><p>线程安全实现</p></li><li><p>concurrenthashmap</p></li><li><p>平时使用场景</p></li></ol><p>3.<strong>ArrayList 和 LinkedList 的区别</strong></p><ol><li>底层数据结构</li><li>插入删除遍历节点</li><li>扩容</li><li>使用场景：</li></ol><p>4.常用的设计模式</p><ol><li>单例：饿汉式，懒汉式，DCL 枚举 实际应用，RedisClient AppConfig Spring bean</li><li>策略：</li><li>模板</li><li>观察</li><li>工厂</li></ol><p>5.ThreadLocal的实现</p><ol><li>底层数据结构</li></ol><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，key为实例，value是为具体的对象</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><ol start="2"><li><p>内存泄漏问题</p></li><li><p>使用场景</p></li></ol><p>6.你如何理解“悲观锁与乐观锁”？分别适用哪些场景？CAS 原理是什么？</p><ol><li>悲观锁，乐观锁代表什么，实例，场景</li><li>CAS原理，OS的cmpxchg</li><li>CAS问题</li><li>使用场景</li></ol><p>7.说一下 Java 中的 <code>synchronized</code> 关键字的实现原理、优化机制，以及它和 <code>ReentrantLock</code> 的区别</p><ol><li>底层原理，对象头中的 monitor 锁，每个对象在 JVM 中都有一个对象头，包含了锁标志位和指向 monitor 的指针。当线程进入 <code>synchronized</code> 块或方法时，会尝试获得这个对象的 monitor。多线程竞争时，会进行 <strong>锁的升级</strong>，这就是 HotSpot 中的锁优化。</li><li>锁的升级过程，无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>和<code>ReentrantLock</code> 对比</li></ol><p>8.说一下 Java 中的 <code>volatile</code> 关键字的作用，它能实现线程安全吗？它和 <code>synchronized</code> 有什么区别？</p><ol><li><p>可见性，禁止重排性</p></li><li><p>不能保证原子下，i++</p></li><li><p>和JMM的关系：JMM规定了主内存和工作内存的交互规则，volatile 会强制线程刷新工作内存和主内存之间的数据。</p><p>写 volatile → 插入一个 Store + StoreBarrier 。读 volatile → 插入一个 LoadBarrier + Load</p></li><li><p>应用场景，标识位，布尔控制变量，DCL</p></li><li><p>和<code>synchronized</code> 对比</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-1</title>
      <link>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/</link>
      <guid>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/</guid>
      <pubDate>Thu, 24 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;他人面经&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>他人面经</h1><h2 id="1-spring的底层实现-三级缓存原理">1.spring的底层实现&amp;三级缓存原理</h2><p>我们先来说三级缓存的实现吧</p><p>首先三级缓存是那三个缓存呢？是在DefaultSingletonBeanRegistry类里面定义的三个Map。然后第一第二层都是key是bean的名字，value是bean的实例。第三次key是bean的名字，value是objectfactory.</p><p>第一层缓存是用来存储我们已经完全实例化好的bean,在这里可以直接使用的</p><p>第二层缓存时用来存储我们早期的bean，创建好，但是并没有进行依赖注入的</p><p>第三次缓存是用来存储我们的objectfactory的，用来创建代理对象的</p><p>然后我们缓存的核心方法是我们的getSingleton方法，他定义了我们如何去获取缓存的顺序</p><p>我们首先先去看第一层缓存，如果第一次没有且bean正在创建中的话。我们再去找第二层缓存，第二层也没有的话，允许早期引用。然后从三级缓存中获取objectfactory</p><p>然后使用objectfactory来创建对象，这里可能是代理对象。因为比如AOP，或者使用了其他的代理模式</p><p>然后将其升级到二级缓存，将三级缓存里面的删除。（暂不使用，然后再可以进行依赖注入。然后如果我们的作用域是单例的话，就直接放入一级缓存，不是的话，就根据场景来）</p><p>然后在我们进行依赖注入的时候可能会出现循环依赖的问题，就是A依赖于B，B也依赖于A的问题</p><p>这个时候就需要解决依赖的问题，我们的三层缓存使用的是提前暴露的方法来解决循环依赖的问题</p><p>在AbstractAutowireCapableBeanFactory.doCreateBean的方法里面定义了解决的实现</p><p>首先我们先实例化bean，只是采用*构造器，*创建，并没有进行属性的注入</p><p>然后我们去判断需不要早期暴露，是不是单例的，因为单例的才会允许循环依赖注入。然后允不允许我们循环依赖。这个是在SpringApplication中设置的，然后这个bean是不是正在被创建中。，</p><p>满足了这个条件，我们才会将objectfactory放入三级缓存的时候，保证二级缓存没有，然后这个会获取一个早期引用，如果我们需要AOP 的话，会获取他的代理对象</p><p>然后对我们需要的依赖进行属性的填充，进行依赖注入</p><p>注入完进行初始化bean</p><p>然后为什么是三级缓存呢？因为<strong>AOP代理对象的延迟创建问题</strong></p><p>在AOP的后置处理器中，获取早期的引用对象的时候，会返回的是我们的代理对象。</p><p>如果我们使用二级缓存的，不知道什么时候创建代理对象，可能会创建多个代理对象，AOP的时机控制会失效。</p><p>so:</p><p>三级缓存通过ObjectFactory实现了：</p><ul><li><strong>按需创建</strong>：只有真正发生循环依赖时才创建代理对象</li><li><strong>唯一性保证</strong>：确保一个Bean只有一个早期引用实例</li><li><strong>时机控制</strong>：代理对象的创建时机由Spring容器精确控制</li></ul><h2 id="2-hashmap为什么扩容要是2的倍数">2.hashmap为什么扩容要是2的倍数</h2><p>HashMap扩容为2的倍数的根本原因是为了实现<strong>高效的哈希计算</strong>和<strong>均匀的元素分布</strong>。</p><p>我们hashmap的tableSizeFor进行容量初始化的时候，通过位运算确保了任何输入都会背转换成<strong>大于等于该数的最小2的幂次方</strong>。确保了容量为2的次方幂。</p><p>然后在put一个元素的时候，我们是通过hash来确定这个值得索引的，使用的是**(n-1) &amp; hash 的按位与运算**来确定位置的。然后hash函数也进行了优化，<em>高16位与低16位异或，增加散列的随机性</em>。</p><p>然后我们的扩容方法里面是这样规定的，是单个元素的话，我们使用位运算重新规划位置，如果是红黑树的话，我们对他的头节点进行位运算，</p><p>如果是链表的话，我们要对链表进行拆分，通过一个位来判断元素的去向，如果与老容量的位运算是0的话，就留在原位置，是1的话就转移到原位置+oldcap的位置，这个算法是非常巧妙的，比如假设hash为21，oldcap=16-1,那么原位置就是5，然后现在我们再进行运算，21&amp;16=0，那么他就是留在原位置。</p><p>然后讲我们拆分的链表加入到我们新的数组之中。这个时候要注意链表的长度，如果超过了8的话，且数组位数大于64，需要转为红黑树。</p><p>然后为什么是2的倍数呢？当我们的数字长度为2的次方幂的时候，我们使用位运算比我们的取模运算高效的多，然后我们不需要重新计算hash值，只需要检查一个位就可以确定新的位置，然后如果是2的幂次方保证了hash值的每一位都能参与到索引计算中，而且对cpu的缓存更加友好</p><h2 id="3-sychronized的底层原理">3.sychronized的底层原理</h2><p>sychronized的底层原理，如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>sychronized的字节码层面的实现是基于监视器实现的，进入监视器，然后执行sychronized修饰的代码块，然后退出监视器</p><p>然后在Hotspot JVM中，synchronized基于Monitor对象实现，ObjectMonitor规定了持有锁的线程，重入的次数，等待获取锁的线程的队列，竞争队列，wait方法等待的线程</p><p>然后如果我们成功获得锁，直接返回。如果是线程的id等于锁的id的话，重入锁的计数器+1,然后如果不相等的话，就产生了锁的竞争，将其放入慢路径。然后慢路径里面的线程自旋，继续取尝试获取活，如果超过了重试次数的话，将其加入等待队列。</p><p>然后出现的三个线程的关系是，竞争队列-&gt;唤醒队列-&gt;获取锁</p><p>然后如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>我们可以使用countDownLatch</p><p>分为A，B两个线程，分别重写他们的run方法，然后A线程执行完之后计数器完成，就通知B线程可以进行。</p><p>然后B线程，重修run方法，调用wait等待，计数器为0的时候开始线程的执行</p><p>然后countdownlatch的底层实现是，state等于0的时候允许通过，然后释放锁的通过cas来实现的</p><p>或者是使用Semaphore，将其初始化为0，然后分为线程A和线程B，线程A执行完之后释放许可，然后B线程执行的时候，尝试获取许可执行</p><p>或者是直接使用LockSupport，在A线程完之后，直接唤醒线程B，然后重写B线程的run方法，先是park的等待A线程执行完之后的唤醒</p><p>然后我们最常用的实现方案是synchronized + wait/notify</p><p>我们先初始化lock然后用sychronized去获取lock,和一个静态的标识位设定为A线程是不是完成。</p><p>然后重写A线程run方法，讲标志位设定为true，然后唤醒等待的线程。线程Bwait等待去执行</p><h2 id="4-tcp状态机，java底层怎么实现tcp的">4.tcp状态机，java底层怎么实现tcp的</h2><p>那我先说TCP状态机的流程吧，分为客户端状态机和服务端状态机</p><p>客户端：</p><p>CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</p><p>服务端：</p><p>CLOSED -&gt; LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED(0),      // 初始状态，无连接</span><br><span class="line">LISTEN(1),      // 服务端监听状态</span><br><span class="line">SYN_SENT(2),    // 客户端发送SYN后的状态</span><br><span class="line">SYN_RCVD(3),    // 服务端收到SYN后的状态</span><br><span class="line">ESTABLISHED(4), // 连接建立状态</span><br><span class="line">FIN_WAIT_1(5),  // 主动关闭方发送FIN后的状态</span><br><span class="line">FIN_WAIT_2(6),  // 主动关闭方收到ACK后的状态</span><br><span class="line">CLOSE_WAIT(7),  // 被动关闭方收到FIN后的状态</span><br><span class="line">CLOSING(8),     // 双方同时关闭的中间状态</span><br><span class="line">LAST_ACK(9),    // 被动关闭方发送FIN后的状态</span><br><span class="line">IME_WAIT(10);  // 主动关闭方的最终等待状态</span><br></pre></td></tr></table></figure><p>那我先说一下TCP三次握手的状态机变化：</p><p>客户端主动连接服务端，首先客户端的状态机位close，然后发送完SYN包之后变为SYN_SENT</p><p>然后收到服务端发来的SYN+ACK包，发送ACK包，然后状态转为 ESTABLISHED</p><p>服务端是监听状态的情况下，接收到客户端的SYN包之后，发送SYN-ACK包，状态变为SYN_RCVD</p><p>然后收到客户端的ACK包，状态转变为ESTABLISHED</p><p>TCP四次挥手状态机变化</p><p>先是主动关闭方，一般是客户端，发送FIN包，然后变为FIN_WAIT_1 状态</p><p>然后收到服务端发来的ACK，状态转变为FIN_WAIT_2</p><p>然后再收到发来的FIN包，向服务端发送ACK，转为 TIME_WAIT 等待2MSL后关闭，变为Close状态</p><p>服务端，收到FIN请求后，发送ACK，请求，变为CLOSE_WAIT，然后应用程序调用close方法，发送FIN包，状态变为LAST_ACK</p><p>然后收到ACK请求后，状态变为CLose,彻底关闭</p><hr><p>后面这个有些难度了，哭</p><h2 id="5-协程和线程的区别是什么？">5.协程和线程的区别是什么？</h2><p>线程是由操作系统内核进行抢占式调度，任何时候都可能被强制切换，协程是由用户态程序进行协作式调度，只在主动让出时才会切换</p><p>然后线程：</p><ul><li>每个线程需要独立的栈空间（通常1MB）</li><li>创建和切换需要用户态和内核态转换，开销较大</li><li>1000个线程大约占用1GB内存</li><li>共享内存模型，需要使用锁、synchronized等机制保证线程安全</li></ul><p>适合：</p><ul><li>CPU密集型任务</li><li>需要真正并行执行的场景</li><li>传统的多线程编程</li></ul><p>协程：</p><ul><li>栈空间很小（通常几KB）</li><li>在用户态完成创建和切换，开销很小</li><li>10万个协程可能只占用几百MB内存</li><li>通常采用消息传递模型（如Channel），天然避免数据竞争</li></ul><p>适合：</p><ul><li>IO密集型任务</li><li>高并发场景（如服务器处理大量连接）</li><li>异步编程，避免回调地狱</li></ul><p>协程是轻量级的用户态线程，更适合高并发的IO密集型场景，而线程更适合CPU密集型的并行计算场景。协程的核心优势是用更少的资源实现更高的并发度。</p><h2 id="6-介绍一下ArrayList扩容机制">6.介绍一下ArrayList扩容机制</h2><p>首先先介绍一下ArrayList他的底层是动态的数组，默认的容量为10。但是有一个最大数组的容量，这个主要是考虑JVM的，因为ArrayList给他在JVM里面分配的是一个连续的内存。最大是Integer.MAX_VALUE - 8，为什么呢？JVM在数组对象头中需要存储一些元数据，预留防止出现OOM</p><p>然后ArrayList的扩容是add元素之后，剩余的内存容量还足够，通过数组复制的方法，为新元素腾出空间</p><p>我们首先会进行容量的检查，这里检查的是Size+1，先去查查内部的容量，然后去检查我们所需要的容量，如果是空数组的话，那么至少需要10的容量</p><p>然后去显示的检查容量，计数器+1，如果最小需求容量&gt;当前数组的长度的话，就进行扩容</p><p>然后触发核心的扩容方法，新的容量是<em>新容量 = 旧容量 + 旧容量的一半</em>，是根据oldCapacity + (oldCapacity &gt;&gt; 1)计算来的。这样计算更快</p><p>然后处理边界的情况，先是最小边界，1.5倍如果还不够的话，就用最小需求量，然后是超大的边界处理，将容量设为容量的最大值</p><p>然后检查完之后，进行数组的复制，将元素复制到更大的数组。这里使用<em>Arrays.copyOf然后最终调用System.arraycopy的</em>native方法</p><p>优化的策略：</p><p>我们可以先进行预估一下，然后再确定一开始初始化需要的初始容量，避免频繁扩容。最好的办法是，开了负载因子，然后容量比我们预计的多一点</p><h2 id="7-口述实现非公平与公平的redis分布式锁">7.口述实现非公平与公平的redis分布式锁</h2><p>非公平锁：</p><p>获取锁</p><ol><li>使用<code>SET key value NX EX timeout</code>命令尝试获取锁</li><li>如果设置成功，说明获取锁成功，返回true</li><li>如果设置失败，说明锁被占用，可以选择重试或返回失败</li><li>value通常设置为当前线程的唯一标识（如UUID+线程ID）</li></ol><p>释放锁</p><ol><li>使用Lua脚本确保原子性操作</li><li>先检查锁的value是否是当前线程设置的</li><li>如果是，则执行DEL命令删除锁</li><li>如果不是，说明锁已超时被其他线程获取，不能删除</li></ol><p>重试机制</p><ul><li>获取失败后，线程sleep一小段时间再重试</li><li>重试间隔可以是固定时间或采用指数退避策略</li><li>设置最大重试次数或超时时间避免无限等待</li></ul><p>公平锁：</p><p>获取锁</p><ol><li><strong>检查当前锁状态</strong><ul><li>如果锁未被占用，直接尝试获取</li><li>如果被占用，进入排队流程</li></ul></li><li><strong>加入等待队列</strong><ul><li>将当前线程标识和时间戳加入<code>queue:resource_name</code>有序列表</li><li>使用ZADD命令，以时间戳为分数确保顺序</li></ul></li><li><strong>检查队列位置</strong><ul><li>获取队列中的第一个元素（最早等待的线程）</li><li>如果是当前线程，说明轮到自己，尝试获取锁</li><li>如果不是，继续等待</li></ul></li><li><strong>等待通知机制</strong><ul><li>使用Redis的BLPOP或发布订阅机制等待通知</li><li>或者采用轮询方式，定期检查是否轮到自己</li></ul></li><li><strong>获取锁的尝试</strong><ul><li>当轮到自己时，使用SET NX命令尝试获取锁</li><li>获取成功后，从等待队列中移除自己</li><li>获取失败说明锁被其他线程抢占，重新进入等待</li></ul></li></ol><p>释放锁</p><ol><li><strong>释放锁资源</strong><ul><li>使用Lua脚本原子性地检查并删除锁</li></ul></li><li><strong>通知下一个等待者</strong><ul><li>从等待队列中获取下一个等待的线程</li><li>向该线程发送通知信号</li><li>可以使用Redis的发布订阅或设置特定key来通知</li></ul></li><li><strong>清理过期等待者</strong><ul><li>定期清理队列中的过期等待线程</li><li>避免队列无限增长</li></ul></li></ol><h2 id="9-OS的虚拟内存和页面置换算法">9.OS的虚拟内存和页面置换算法</h2><p>虚拟内存是操作系统的核心抽象，通过MMU和页表机制将进程的虚拟地址空间映射到有限的物理内存，实现内存保护、共享和扩展。</p><p>当物理内存不足时，页面置换算法决定哪些页面被换出到磁盘。<strong>FIFO算法</strong>实现简单但可能出现Belady异常；<strong>LRU算法</strong>基于局部性原理效果最好但实现成本高；<strong>Clock算法</strong>是LRU的高效近似实现，使用访问位模拟时钟指针给页面第二次机会；<strong>Enhanced Clock算法</strong>进一步考虑修改位，优先置换干净页面减少磁盘I/O。</p><p>现代操作系统如Linux采用多层LRU设计，将页面分为active和inactive链表动态管理热度，并结合预取、内存压缩等技术优化性能。<strong>关键是要平衡算法复杂度与性能提升，充分利用程序的时间空间局部性，同时考虑NUMA、SSD等现代硬件特性</strong>。在生产环境中需要根据应用特征选择合适策略，避免内存抖动，并通过监控缺页率等指标持续优化。虚拟内存的设计体现了操作系统在资源管理上的核心思想：通过抽象和调度算法，在有限资源上为应用提供无限且高效的服务体验。</p><h2 id="10-AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写">10.AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写</h2><p>AQS是一个设计思想，本质上就是一个同步器框架。主要控制状态管理和线程排队，状态管理交给子类，然后线程排队AQS统一处理</p><p>核心组件就是state变量和CLH队列变种</p><p>state:</p><ul><li>使用volatile int保证可见性</li><li>通过CAS操作保证原子性修改</li><li>语义由子类定义：可以表示锁的持有状态、信号量的许可数量、CountDownLatch的计数等</li></ul><p>CLH队列：</p><ul><li><strong>双向链表</strong>：支持超时和中断处理</li><li><strong>虚拟头节点</strong>：简化边界条件处理</li><li><strong>节点状态</strong>：SIGNAL、CANCELLED、CONDITION等，精确控制唤醒时机</li></ul><p>流程：</p><p>他是先尝试快速获取锁，避免排队。失败后加入队列，但是不会立刻阻塞。在队列中尝试去获得锁，获取前驱释放的锁。实在无法获取的适合才堵塞。</p><p>然后获取锁的时候state+1，线程Id=锁的Id，然后解锁的时候-1。知道为0的时候释放锁。</p><p>然后在CLH中设计了<strong>懒初始化</strong>：只有竞争时才创建队列，减少内存开销。设计了唤醒机制，释放资源的线程负责唤醒后记的节点，被唤醒的线程获取资源后，唤醒下一个。避免了雷鸣群羊&quot;问题，精确控制唤醒数量</p><p>被唤醒的线程，实现CAS自旋尝试去获得锁，失败后会被park，直到再次unpark。</p><p>同步工具，我写了一个基于AQS和令牌桶实现的限流操作</p><p>先是引入桶容量，每秒补充的速率。然后对他们进行初始化，初始化令牌桶，将时间戳和令牌数压缩到一个long变量中。</p><p>然后重要的是实现*tryAcquire *和tryRelease，但是令牌桶不需要主动的释放资源</p><p>先去解析我们当前的状态，获取时间和需要的令牌数量，然后计算我们需要补充的令牌的数量，然后判断我们是否可以获取。然后使用CAS更新状态，返回剩余令牌数。CAS失败就自旋重试，避免了线程堵塞。</p><h2 id="11-介绍一下动态代理">11.介绍一下动态代理</h2><p>动态代理主要有<strong>JDK动态代理</strong>和<strong>CGLIB字节码增强</strong>两种实现方式。<strong>JDK动态代理</strong>基于接口，在运行时通过Proxy.newProxyInstance()创建代理对象，底层使用反射调用InvocationHandler的invoke方法来拦截目标方法；<strong>CGLIB字节码增强</strong>无需接口，通过ASM字节码操作库在运行时生成目标类的子类，重写目标方法并插入拦截逻辑，在方法中通过super调用原始方法或MethodInterceptor进行增强。<strong>核心区别</strong>：JDK代理生成的是接口实现类，性能更好但必须有接口；CGLIB生成的是继承子类，更灵活但不能代理final方法。Spring AOP默认策略是有接口用JDK代理，无接口用CGLIB，都是在运行时动态生成字节码实现方法拦截和功能增强，广泛应用于AOP、事务管理、权限控制等场景。</p><h2 id="12-tomcat底层（TODO）">12.tomcat底层（TODO）</h2><h2 id="13-布隆过滤器的底层实现">13.布隆过滤器的底层实现</h2><p>布隆过滤器本质上就是一个大的Bitset+多个独立的hash函数，<em>根据期望元素数和误判率计算最优参数</em>，假设有m个位，k个哈希函数，插入n个元素，最优数组位大小是 -n * ln(p) / (ln(2))²*，最优hash函数个数是*k = (m/n) * ln(2)</p><p>然后我们添加元素的时候，对元素进行hash，然后放在对应的hash%bitsetsize的位置上，然后设置为1</p><p>查询元素的时候，遍历hash，获取其index，然后必须所以的hash位都要是1才可能存在</p><p>我们单个使用hash太慢了，我们需要高效生成k个独立的哈希值，就可以使用双hash方法，使用两个不同的哈希函数，比如一个直接调用，一个取16位，让组合生成一个新的hash比如hash1+i+hash2,常用MurmurHash + FNV Hash两个hash组合</p><p>然后其布隆过滤器不是完全准确的，可能布隆过滤器中没有，但是数据库中有的，我们就需要计算准确率，较少的计算出某个位为0的概率，然后计算出k个位都为1但是元素不存在的概率</p><p>然后1-概率1 pow上概率2</p><p>当这个布隆过滤器很大的时候，一般我们都用16位就可以了，k=16时已经能提供足够好的误判率。理论值误判率：(1 - e^(-kn/m))^k</p><p>单个优化策略：</p><ol><li><strong>动态扩容</strong>，<em>创建新的过滤器，容量翻倍，误判率减半</em>，然后只要有一个过滤器返回true就可以</li><li>增加位数组大小，相同的元素数量下，位数组越多，误判率越小。</li><li><strong>Counting Bloom Filter</strong>，使用计数器代替位数组，成功添加之后，计数器+1，避免单一位冲突，可以支持删除操作</li><li>分层布隆过滤器，元素依次通过多层过滤器，在第一个返回的层添加其元素。然后只有所有的层都返回true才表明存在</li></ol><p>关键特性：</p><p>如何判断没有一定没有？</p><ul><li>如果元素真的被添加过，它的所有哈希位置都<strong>必须</strong>为1，发现任何一个位置为0，说明元素<strong>绝对没有</strong>被添加过，所有位置都为1时，可能是其他元素设置的（假阳性）</li></ul><p>然后实际的参数的设计，100万商品的话，误判率设为0.01</p><p>然后位数组大小 ≈ 9,585,058*，然后单击场景我们就放在JVM内存中，分布式的话就存在redis里面</p><h2 id="14-ThreadLocal的底层实现">14.ThreadLocal的底层实现</h2><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，其键是 <code>ThreadLocal</code> 实例对象（弱引用），值是线程本地变量的值（强引用）。</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><p>Threadlocal可以用于线程不安全类的线程安全封装，<strong>典型场景</strong>：<code>SimpleDateFormat</code>。<code>SimpleDateFormat</code> 是一个线程不安全的类，可以为每个线程提供一个独立的实例，避免竞争。</p><p>在数据库连接的时候应用，通常为每个线程（每个请求）独立创建一个数据库连接，使用 <code>ThreadLocal</code> 来管理这些连接。</p><p>管理用户的上下文信息，这个最常用</p><p>在分布式事务或者嵌套事务中，通过 <code>ThreadLocal</code> 存储事务信息，使得同一线程的不同方法调用间能共享事务上下文。</p><p><strong>InheritableThreadLocal</strong> 用于子线程继承父线程变量；</p><h2 id="15-详细解析下CAS和原子类">15.详细解析下CAS和原子类</h2><p>CAS的英文是compare and swap ，就是比较然后交换的意思，他是一个原子操作，用于在多线程环境下实现同步</p><p>包括三个操作数</p><ul><li><strong>V</strong>：要更新的变量（内存地址）。</li><li><strong>E</strong>：期望值。</li><li><strong>N</strong>：新值。</li></ul><p>CAS 指令会先比较 V 的当前值是否等于 E，如果相等，则将 V 的值原子性地更新为 N；如果不相等，则什么也不做。 整个比较和替换操作是一个原子操作。通常会返回一个布尔值，表示是不是操作成功</p><p>CAS 的实现依赖于 CPU 提供的原子指令。不同的 CPU 架构实现方式有所不同，但基本原理类似</p><p>在java中是使用的是JUC包下的原子类来实现CAS操作的。这些类通过 <code>Unsafe</code> 类来调用底层的 <code>cmpxchg</code> 指令。该指令的操作数与 CAS 的 V、E、N 对应。该指令会 lock 总线，从而实现原子性。</p><p><code>Unsafe</code> 类是 Java 提供的一个后门，可以直接访问底层系统资源，包括内存操作。<code>AtomicInteger</code> 等原子类使用 <code>Unsafe</code> 类的 <code>compareAndSwapInt</code> 等方法来实现 CAS。</p><p>在unsafe类里面静态方法尝试去先获取表示 <code>value</code> 字段在 <code>AtomicInteger</code> 对象中的内存偏移地址。</p><p>然后调用<code>compareAndSwapInt</code>方法去执行调用底层的 <code>cmpxchg</code> 指令</p><p>但是CAS有一个典型的ABA问题</p><p>如果一个变量 V 的值被修改为 A，然后又被修改回 A，CAS 操作会认为 V 的值没有发生变化，从而成功更新。但实际上，V 的值可能已经经过了其他的改变，只是最终又变回了 A。</p><p>我们可以加入版本号或者是时间戳的一个遍历来实现，CAS的时候不仅是要去比较变量的值，还要去比较版本号或者时间戳</p><p>或者是使用**<code>AtomicStampedReference</code>**，<code>AtomicStampedReference</code> 类维护了一个变量值和一个 Stamp（类似于版本号）。CAS 操作需要同时比较变量值和 Stamp，确保变量没有被修改过。</p><p>CAS应用在ConcurrenthashMap这种类里面，JUC包下的原子类里面，AQS的实现，还有自旋。不适合高冲突的场景</p><h2 id="16-详细说明一下concurrenthashmap的变化">16.详细说明一下concurrenthashmap的变化</h2><p>介绍一下，然后其他的线程安全的实现。</p><p>数据结构：由分段锁变为了数组链表+红黑树然后使用node数组来存储数据</p><p>线程安全的实现：</p><p>初始化的时候使用volatile+CAS来确保node数组的初始化</p><p>然后如果桶为空使用CAS，不为空使用synchronized锁住链表/红黑树的头节点。扩容的时候使用ForwardingNode标记正在迁移的桶</p><p>读操作的时候大部分情况无锁，使用volatile来保证可见性，node节点的next和val都是volatile来修饰的</p><p>效果：</p><p>锁粒度更细：只锁住具体的桶，而不是整个segment</p><p>读操作基本无锁</p><p>使用CAS减少锁竞争</p><p>然后扩容和红黑树变换</p><p>结合实际</p><h2 id="17-熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性">17.熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性</h2><p><strong>RocketMQ如何保证消息的幂等性？在您的项目中是如何实现的？</strong></p><p><strong>延迟消息的实现原理是什么？它有什么限制？</strong></p><p><strong>如果消费者处理消息失败，RocketMQ是如何处理的？死信队列的作用是什么？</strong></p><p>1.消息幂等：因为RocketMQ只保证了消息至少发送一次，所以我们要在业务逻辑上实现</p><p>通过业务唯一ID进行检查，然后尽量使用msg的key的操作来保持幂等，在数据库方面，使用唯一索引和去重表</p><p>2.延迟消息：延迟队列定时执行任务，只支持固定的18个延迟级别，可以在broker.conf文件中修改</p><p>3.异常处理：消息是先放入redis设计一个短的过期时间，然后执行业务逻辑，执行成功延长过期时间，失败就过期。然后ACK消息</p><p>然后设置消息为RECONSUME_LATER，执行重试逻辑。到达重试次数，记录日志，发送到死心队列进行人工处理，死信消息默认保留3天</p><h2 id="18-详细解释ZSet在Redis中的底层实现，以及跳表的使用场景">18.<strong>详细解释ZSet在Redis中的底层实现，以及跳表的使用场景</strong></h2><p>ZSet是Redis中一种常用的数据结构，用于存储有序的元素集合，它可以根据元素的分数（score）进行排序，通常用于排行榜等场景。</p><p>他的底层实现是两种数据结构</p><ol><li><p><strong>压缩列表（ziplist）：</strong> 在元素数量较少且元素成员（member）较短时使用。 压缩列表的特点是内存占用小，但插入、删除操作的效率较低，因为它需要进行连续的内存移动。</p><ul><li><strong>结构：</strong> 压缩列表是一种特殊的&quot;连续内存块&quot;构成的数据结构，类似于数组，但可以存储不同长度的数据。 它由多个entry组成，每个entry保存ZSet中的一个元素（member-score）。</li><li>**缺点：**当压缩列表中某个entry的长度发生变化时，可能会导致后续entry的offset也需要更新，如果更新的entry数量较多，就会导致连锁更新，影响性能。</li></ul></li><li><p><strong>跳表（skiplist） + 字典（dict）：</strong> 在元素数量较多或元素成员较长时使用。 跳表可以提供较高的插入、删除、查找效率，但会占用更多的内存空间。 字典则用于存储member到score的映射，使得可以通过member快速查找score。</p><ul><li><strong>跳表的定义：</strong> 跳跃表（skiplist）是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳表是一种概率型数据结构，它通过随机算法来决定每个节点拥有多少个指针。 跳表是一种可以实现平均O(log N) 查找，插入，删除的有序数据结构。</li><li><strong>跳表的结构：</strong> 跳表由多层链表组成，每一层链表都包含所有的元素，但元素之间的连接方式不同。 最底层是包含所有元素的有序链表，而上层链表则以一定的概率包含下层链表的元素，从而构成一种类似于索引的结构。 节点会包含一个后退指针（backward pointer），指向位于前一个节点。 在跳表中，节点按照它们的分值大小进行排序。</li><li><strong>字典的定义：</strong> 字典，也称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。</li></ul></li></ol><p>满足这两个条件就会使用跳表</p><ol><li><strong>元素数量超过<code>zset_max_ziplist_entries</code>配置的值（默认128）：</strong> 这个配置限制了使用压缩列表存储的元素数量。</li><li><strong>集合中任一member的长度大于<code>zset_max_ziplist_value</code>配置的值（默认64）：</strong> 这个配置限制了使用压缩列表存储的元素的长度。</li></ol><h2 id="19-ziplist的底层以及改进">19.ziplist的底层以及改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry1&gt;&lt;entry2&gt;...&lt;entryN&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure><p><code>zlbytes</code>：整个压缩列表占用字节数</p><p><code>zltail</code>：表尾节点距离起始地址的偏移量</p><p><code>zllen</code>：节点数量</p><p><code>entry</code>：各个节点</p><p><code>zlend</code>：标记压缩列表末端</p><p>每个entry</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen&gt;&lt;encoding&gt;&lt;entry-data&gt;</span><br></pre></td></tr></table></figure><p>当前一个节点长度从小于254字节变为大于等于254字节时,prevlen字段会从1字节扩展到5字节,可能引发后续节点的连锁扩展</p><p>然后就属于节点数量比较少的时候使用</p><p>在list中会被listpack代替，zset中被skiplist代替在listpack中，取消了prevlen字段，增加了len字段记录当前节点长度，可以从后往前遍历，避免连锁更新</p><h2 id="20-索引下推">20.索引下推</h2><p>SELECT * FROM users WHERE age &gt; 20 AND name LIKE ‘张%’ AND city = ‘北京’;</p><p>存在复合索引：<code>(age, name, city)</code></p><p>没有索引下推的话，使用索引定位范围测试之后，每一个查询都需要进行回表。然后在MySQL Server层过滤name和city条件</p><p>有索引下推的话，使用索引定位完之后，在索引层直接判断，只有同时满足三个条件的记录才回表。大幅度减少回表查询的次数</p><p>因为他范围查询，会破坏后续字段的有序性。正常无法走索引，但是索引下推可以。</p><p>使用 <code>EXPLAIN</code> 命令查看执行计划，确认是否使用了索引下推优化。ICP，然后进行调试让其走索引下推</p><h2 id="21-JVM垃圾回收器">21.JVM垃圾回收器</h2><p>分类：</p><p><strong>Serial / Parallel（吞吐优先）</strong></p><p><strong>CMS（低停顿）</strong></p><p><strong>G1（低停顿 + 区域化收集）</strong></p><p>**ZGC / Shenandoah（可预测、低延迟、支持大内存）**搜集场景题</p><table><thead><tr><th>收集器</th><th>特点</th><th>回收策略</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>CMS</strong></td><td>并发回收，停顿低，已淘汰</td><td>标记-清除/存在内存碎片问题</td><td>老项目，注重响应延迟（已不推荐）</td></tr><tr><td><strong>G1</strong></td><td>分区回收，预测停顿</td><td>Region + 标记-整理</td><td>推荐，适合大内存、对吞吐和延迟平衡</td></tr><tr><td><strong>ZGC</strong></td><td>并发、低延迟、支持 TB 级堆</td><td>可并发标记/重定位</td><td>极低停顿、现代系统（JDK ≥ 17）</td></tr></tbody></table><h2 id="22-Redis-数据库分布式锁">22.Redis&amp;数据库分布式锁</h2><p>我们一般就是使用的redisson，Redisson 基于 RedLock；提到了锁的可重入机制；与 AQS 有类比意识；简略提到数据库锁的粒度更大，Redis 粒度更细并发性更好；</p><p>Redisson 提供的是一种 <strong>基于 Redis 的可重入分布式锁实现</strong>，其原理包括：</p><ul><li>使用 Redis 的 <code>SET key value NX PX timeout</code> 命令原子性加锁；</li><li><code>value</code> 为唯一线程标识（如 UUID + ThreadId）；</li><li>可重入：同一个线程再次加锁会对 <code>value</code> 维护一个计数器；</li><li>释放锁时会先比对线程标识，确保只有锁的拥有者可以释放；</li><li>使用 Lua 脚本释放锁，保证原子性；</li><li>提供“看门狗机制（watchdog）”，定时自动续期避免超时释放锁；</li></ul><p>数据库：</p><p>常见方式有两种：</p><ul><li>利用数据库的行级锁（如基于 <code>select ... for update</code>）；</li><li>使用数据库表记录作为“锁资源”，进行 <code>insert/update</code> 加锁；</li></ul><p>特点：</p><ul><li>实现简单，易于理解；</li><li>可靠性高（依赖事务和 ACID）；</li><li><strong>性能差</strong>，阻塞严重，不适合高并发；</li><li>不具备重入机制，不支持超时释放；</li><li>会增加数据库压力，影响主业务。</li></ul><h1>场景题目</h1><h2 id="1-MySQL自增ID用完了怎么办？">1.MySQL自增ID用完了怎么办？</h2><p>那么我们先来分析一下，我们的自增ID最多可以多少呢？</p><p>如果是<em>INT类型</em>类型的话，普头的int，差不读能容纳约21的数据，UNSIGNED INT的话，能容纳43亿的数据</p><p>如果我们使用的BIGINT的话，-2^63^ ----2^63的数据，UNSIGNED BIGINT更多了，大约1844万亿的数据</p><p>一般的话，我们有一下几个方案：</p><p>1.INT升级到BIGINT，可以<em>使用pt-online-schema-change安全升级</em>，或者直接使用Mysql的ALTER TABLE your_table MODIFY COLUMN id BIGINT AUTO_INCREMENT;</p><p>这样的话，我们的数据量变大了，但是升级过程中会锁表，建议在维护窗口进行，而且需要同步修改相关的外键应用，而且java里面我们得用long字段而不是int字段了</p><p>2.分库分表，一般的我们可以根据ID的范围来分表，多少到多少为一个。这样分表比较简单。</p><p>3.使用UUID，是由32个十六进制数字组成的，因此一个UUID总共由128（32*4）个bit组成，也是说理论上有2的128次方个值可以使用。作为我们的自增主键，但是普通的UUID性能较差，可以使用OrderedUUID，这个有序的UUID，而且还可以将时间戳嵌入UUID的前缀，确保了有序性</p><p>4.使用雪花算法，利用机器ID和时间戳来生成64位长整型ID。最终生成的ID是会按时间递增的，但是也要考虑时钟回拨的问题，建议使用。</p><p>5.使用ID回收策略，回收被我们删除的ID，然后优先使用回收的ID，没有回收的话，才使用新的ID。一般用于实现假删除的表，但是我们需要去查，哪一些才是假删除的。</p><h2 id="2-如何把一个文件快速下发到100w个服务器">2.如何把一个文件快速下发到100w个服务器</h2><p>对于100万台服务器的文件快速下发问题，我感觉可以使用P2P网络来解决</p><p>我们传统的方案是中心化下发，一个传输端发送给很多的接收端，很显然，在这个场景下不合适</p><p>我们可以设计一下</p><p><strong>构建多个独立的生成树同时传输</strong>，将100万节点构建成<strong>3-5个不相交的生成树</strong>，每个节点在不同树中担任不同角色（有时是父节点，有时是子节点），文件分片后通过不同树路径并行传输</p><p><strong>分片策略</strong>，将大文件切分为N个数据块，不同的数据块交给不同的生成树，每个节点收集所有分片之后重组文件</p><p>我们构建三层架构，<strong>种子层</strong>：5-10台高带宽服务器作为初始种子，<strong>中继层</strong>：按地理位置/网络拓扑划分的1000-5000台中继节点，<strong>叶子层</strong>：普通服务器节点</p><p>减少网络的跳数，降低延迟。然后理由网络拓扑特性，避免跨地域传输。</p><p>然后建立容错机制，每个节点连接2-3个父节点并行下载，任一节点故障时子节点自动重新寻找父节点，通过健康检查和动态调整保证传输连续性。<strong>优化策略</strong>包括最稀缺分片优先传输、自适应带宽分配、就近父节点选择等。</p><p>这样的话，我们理论上O(log N)轮传输完成，实际10-15轮即可完成。</p><p>实际上是树状结构升级为容错的多树并行网络，既保持P2P高效性又解决了单点故障和路径瓶颈问题。</p><h2 id="3-服务器上如果有很多time-wait如何解决，以及出现这个问题的场景有哪些">3.服务器上如果有很多time wait如何解决，以及出现这个问题的场景有哪些</h2><p>首先time_wait是tcp连接中，主动关闭一方的状态，等待2MSL后关闭。然后服务器出现说明是服务器主动断开的连接</p><p>比如：</p><ol><li><strong>并发Web服务</strong>：比如电商大促期间，Nginx反向代理服务器向后端应用服务器发起大量短连接请求，每次请求完成后主动关闭连接，导致Nginx服务器积累大量TIME_WAIT状态。</li><li><strong>微服务架构</strong>：服务A调用服务B的REST API，使用HTTP短连接方式，每次调用后都关闭连接。在高QPS场景下，比如订单服务调用库存服务，会产生大量TIME_WAIT。</li><li><strong>数据库连接池配置不当</strong>：应用服务器连接MySQL时，如果没有使用连接池或连接池配置过小，频繁创建和关闭数据库连接，会在应用服务器上产生大量TIME_WAIT。</li><li><strong>监控和健康检查</strong>：负载均衡器（如F5、ELB）对后端服务器进行健康检查，每次检查都是短连接，高频率的健康检查会导致后端服务器TIME_WAIT堆积。</li></ol><p>timewait过多会导致：</p><p><strong>端口耗尽</strong>：Linux默认可用端口范围是32768-65535，大约3万个端口。当TIME_WAIT状态的连接达到这个数量时，无法创建新的出站连接，出现&quot;Cannot assign requested address&quot;错误。</p><p><strong>内存占用</strong>：每个TIME_WAIT连接都会占用一定的内核内存，大量堆积会消耗系统资源。</p><p>我们可以使用分层解决的办法</p><p>应用层：因为可能是http短连接导致的，我们启用<strong>启用HTTP Keep-Alive</strong>，在nginx里面配置keeplive</p><p>然后可能是数据库的频繁连接导致的，我们使用连接池，HikariCP、Druid。http的连接池，HttpClient的PoolingHttpClientConnectionManager，redis的连接池，Jedis Pool</p><p>系统层：</p><ol><li><strong>开启TIME_WAIT重用</strong>，使用echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse 参数设置为1开启</li><li><strong>TIME_WAIT超时时间</strong>设计减少，尽快让其超时</li><li>扩大端口的可用范围，ip_local_port_range增大</li><li><strong>增加socket buffer</strong>，/etc/sysctl.conf里面设置’net.core.rmem_max = 16777216’</li></ol><h2 id="4-服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置">4.服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置</h2><p>我们一般都是部署在linux服务器上，如果安装了监控软件的话，直接从监控软件上看</p><p>没有的话，我们使用top -c找出CPU占用最多的进程，然后top -H -PID 找出占用最多的线程</p><p>然后将线程ID转为16进制之后，jstack PID|grep -A 20 ID 查看其栈堆，对比找出我们具体是什么问题？</p><p>典型场景：</p><ol><li>死循环和无限递归</li><li>频繁的GC，我们可以jstat -gc PID 1000查看GC统计</li><li>正则表达式回溯，复杂的正则表达式出现了回溯</li><li>死锁，我们可以jstack PID|grep -A 5 -B &quot;deadlock&quot;直接显示死锁，或者是用<em>jconsole</em>等图形化工具来检测</li></ol><p>死锁的场景，<strong>数据库事务死锁</strong>，查询Mysql日志，<em>DEADLOCK</em>信息。然后在应用层的表现是，大量的线程阻塞在JDBC操作上</p><p>分布式死锁，主要是redis分布式锁，查找redis-cli keys “<em>lock</em>”，应用层表现是线程一直在等待锁</p><h2 id="5-有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现">5.有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现</h2><p>我们可以不主动查询，等用户登录到时候，执行会员过期时间的检测，给用户发送邮件提醒。但是这样用户不登录，我们没有办法提醒了就。而且我们要进行全表扫描，效率较低，数据库压力大。但我们可以将他作为补充的手段。</p><p>我们可以使用ES等搜索引擎，把会员表里的会员id和会员到期时间存储到搜索引擎里面。然后根据范围查询，查询到即将过期的用户，对他们发送消息。但是这样系统复杂度高了，而且我们还是需要进行定时轮询</p><p>可以使用redis，key为用户的id，value为该id的过期时间。然后使用redis的过期提醒功能，监视key的过期事件，检查成功发送邮件提醒。但是这样只能精确到秒，不能提前提醒，而且内存压力较大。</p><p>使用MQ延迟队列，计算该用户的过期事件，然后存储到延迟消息队列里面，轮询执行，一道过期事件发送消息。这是我们最佳的方案。</p><p>流程：</p><p>→ 计算提醒时间点（到期前7天、3天、1天）</p><p>→ 投递延迟消息到RocketMQ</p><p>→ 消息到期自动消费</p><p>→ 验证用户状态后发送邮件</p><p>然后加上补偿机制，定时执行任务，只扫描近期（如15天内）即将到期用户，然后查看是否发送，补偿未发送的。重新发送</p><p>然后这个过程中需要保持消息幂等，不应该多次发送，查询用户当前会员状态，然后检查到期时间，检查是否发送过，发送之后记录日志。消费失败后自动重试三次，发送失败进入死信队列处理。然后多个途径进行提醒。</p><p>RocketMQ作为消息队列，mysql作为主库，redis缓存用户的状态。</p><h2 id="6-假设你们系统有一个下单接口，突然并发量暴增，比如从-1k-QPS-涨到-10w-QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。">6.假设你们系统有一个下单接口，突然并发量暴增，比如从 1k QPS 涨到 10w QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。</h2><p>第一，限流。我们在网关层加了 Sentinel 做接口限流和熔断，防止系统被打垮。或者是我们使用AOP+bucket令牌桶进行限流</p><p>第二，缓存优化。我们使用了本地 + Redis 两级缓存，热点商品信息预加载，避免高并发直接打到数据库。然后防止缓存击穿，使用互斥锁</p><p>第三，异步削峰。下单写操作进入 MQ，由后台线程异步落库，极大缓解数据库压力。</p><p>第四，数据库层我们做了读写分离，写入走主库，查询走从库，提升吞吐。<br>最后就只能服务熔断了不行的话。</p><h2 id="7-你们系统中-Redis-如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？">7.你们系统中 Redis 如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？</h2><p>失效的影响：</p><p><strong>请求直打数据库</strong>：热点接口并发高时，数据库容易被压垮。</p><p><strong>响应时间变长</strong>：Redis 是内存级别，数据库响应慢，用户体验下降。</p><p><strong>缓存穿透</strong>：用户请求不存在的数据，Redis 拿不到，数据库压力大。</p><p><strong>缓存不一致</strong>：应用读了 Redis 旧值，可能会造成业务逻辑问题。</p><p>应对策略：</p><p>1）<strong>缓存高可用部署</strong></p><ul><li>Redis 使用主从 + Sentinel 实现自动故障转移；</li><li>或使用 Redis Cluster，提供分布式高可用能力。</li></ul><p>2）<strong>加缓冲 + 限流</strong></p><ul><li>引入线程池 / 信号量等方式限流；</li><li>使用本地缓存（如 Caffeine）做短时间的过渡保护。</li></ul><p>3）<strong>缓存预热 / 冷数据淘汰</strong></p><ul><li>关键数据在启动时预热到 Redis；</li><li>利用定时任务刷热点数据；</li><li>对非热点数据设置较短 TTL。</li></ul><p>4）<strong>避免缓存穿透 / 击穿 / 雪崩</strong></p><ul><li><strong>穿透</strong>：对 null 值做缓存 / 用布隆过滤器拦截；</li><li><strong>击穿</strong>：加互斥锁 / 单飞请求重建缓存；</li><li><strong>雪崩</strong>：设置随机 TTL + 限流 + 降级处理。</li></ul><p>5）<strong>降级与熔断</strong></p><ul><li>如果 Redis 和数据库都失败，降级为静态页 / 弹窗提示；</li><li>监控超时率，自动熔断部分接口，防止服务雪崩。</li></ul><p>热点数据丢失后？AOP的日志自己来恢复</p><p>用户体验如何保证？</p><p>redis的高可用，主从，哨兵，集群</p><p>缓存一致性保证，延迟双删策略</p><h2 id="8-假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？">8.假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？</h2><p>技术选型：</p><ol><li>concurrenthashmap+AtomicLong 精确统计，但是占内存较大，不适合大量用户</li><li>Redis HyperLogLog，内存占用小，适合大基数去重，有0.81%的误差，无法获取具体的元素</li></ol><h2 id="9-您在-生活商店优选-项目中提到了-多级缓存（Caffeine-Redis-MySQL）“和-基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：">9.您在&quot;生活商店优选&quot;项目中提到了&quot;多级缓存（Caffeine-Redis-MySQL）“和&quot;基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：</h2><p>多级缓存的数据一致性如何保证？</p><p>延迟双删+异步补偿</p><p>BCP中间件：</p><p>CDC方案，使用Canal订阅binglog然后通过MQ发送，缓存更新，允许短暂不一致，保证最终一致</p><p><strong>无侵入性</strong>：不需要修改业务代码</p><p><strong>准确性</strong>：只有事务提交后才会写入binlog</p><p><strong>完整性</strong>：捕获所有数据变更</p><p><strong>实时性</strong>：近实时同步</p><h2 id="10-mysql的分页查询优化">10.mysql的分页查询优化</h2><p>SELECT * FROM products ORDER BY id LIMIT 1000000, 20;</p><p>意识到了大偏移量会导致性能问题,</p><p>需要----</p><p>扫描并排序前1000020条记录</p><p>丢弃前1000000条记录</p><p>返回后20条记录,然后即使走了索引，也要&quot;数&quot;1000000条记录才能定位到起始位置</p><p>我们可以使用子查询来优化，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products p1 </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span></span><br><span class="line">) p2 <span class="keyword">ON</span> p1.id <span class="operator">=</span> p2.id;</span><br></pre></td></tr></table></figure><p>或者是使用游标，假设上页最后一个id是1000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-分库分表的查询如何进行">11.分库分表的查询如何进行</h2><p>如何定位需要查询的分表？</p><p>如何聚合多个分表的结果？</p><p>如何处理分页查询？</p><p>按用户ID分表（user_id % 16）</p><p>可以使用异构索引表来查询，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product_order_index (</span><br><span class="line">    product_id BIGINT,</span><br><span class="line">    user_id BIGINT,</span><br><span class="line">    order_id BIGINT,</span><br><span class="line">    table_suffix INT,  -- 记录在哪个分表</span><br><span class="line">    INDEX(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者是引入ES搜索</p><p>然后我们如何聚合查询呢？使用归并排序</p><p>从每个分表获取足够的数据，每个分表需要取 page * size + size 条数据，然后返回冰柜排序</p><h2 id="12-大数据量找最值">12.大数据量找最值</h2><p>就是一个非常大的数据量，然后在里面找出最大的数字</p><p>就是分三步，分桶，计数，比大小</p><p>先把大文件按照hash分成小文件，使用hash取模来分桶，同一个数字要进同一个桶</p><p>使用HashMap来找到出现次数最多的数字，然后遍历每个桶里面出现次数最多的，和当前全局最大值进行比较</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring面试题hot2-源码分析</title>
      <link>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础&lt;/h1&gt;
&lt;h2 id=&quot;1-什么是-IOC？&quot;&gt;1.什么是</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础</h1><h2 id="1-什么是-IOC？">1.什么是 IOC？</h2><p>IOC就是控制反转，反转之前是啥，，，反转之后是啥。。。。实现核心就是反射，设计模式是工厂模式</p><p>然后IOC和核心就是DI，几种实现方式，循环依赖的解决方式。</p><p>@bean的生命周期，@PostConstruct @PreDestroy，bean的作用域，单例，原型，websocket,session,request,application</p><p>bean的单例不一定是线程安全的，这个跟我们的业务逻辑有关，如果bean没有一个可变的成员变量，那么他就是无状态的，也就是线程安全的</p><p>我们为了保证线程安全可以改变作作用域为prototype，或者使用ThreadLocal，或者是用锁</p><p>IOC容器：</p><p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 都是Spring的IoC容器，但后者是前者的超集，提供了更强大的功能。</p><p><code>ApplicationContext</code>继承了<code>BeanFactory</code>，所以它具备<code>BeanFactory</code>的所有能力，同时还提供了更多面向企业应用的功能。它的预加载机制能帮助你在应用启动时就发现配置错误，而不是等到运行时才报错。</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>BeanFactory</strong></th><th style="text-align:left"><strong>ApplicationContext (推荐使用)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心定位</strong></td><td style="text-align:left">Spring IoC容器的<strong>基础接口</strong>，是“底层基础设施”。</td><td style="text-align:left">IoC容器的<strong>高级接口</strong>，是<code>BeanFactory</code>的子接口。</td></tr><tr><td style="text-align:left"><strong>Bean加载</strong></td><td style="text-align:left"><strong>懒加载 (Lazy-loading)</strong>：只有当<code>getBean()</code>被调用时，才会去实例化Bean。</td><td style="text-align:left"><strong>预加载 (Eager-loading)</strong>：容器启动时，会一次性实例化所有<code>singleton</code>作用域的Bean。</td></tr><tr><td style="text-align:left"><strong>功能丰富度</strong></td><td style="text-align:left">功能较少，主要提供Bean的注册和获取。</td><td style="text-align:left"><strong>功能非常丰富</strong>，除了<code>BeanFactory</code>的所有功能外，还提供了：</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>国际化支持 (i18n)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>事件发布与传播机制 (ApplicationEvent)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>AOP集成</strong>（自动识别并配置<code>BeanPostProcessor</code>等）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>Web环境支持</strong>（如<code>WebApplicationContext</code>）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>资源访问</strong>（如<code>classpath:</code>、<code>file:</code>前缀的资源加载）</td></tr><tr><td style="text-align:left"><strong>使用场景</strong></td><td style="text-align:left">对内存消耗要求极高的场景（如移动设备）。在现代企业应用开发中<strong>几乎不直接使用</strong>。</td><td style="text-align:left"><strong>绝大多数Spring应用和所有Spring Boot应用</strong>的默认选择。</td></tr></tbody></table><h2 id="2-什么是spring-Aop">2.什么是spring Aop</h2><p>AOP是啥，作用</p><p>实现的原理，动态代理，jdk,cgilb</p><p>几个概念，切面，连接点，通知，切点，织入</p><p>AOP通过<strong>织入(Weaving)</strong>，将<strong>切面(Aspect)<strong>中的</strong>通知(Advice)</strong>，应用到由**切点(Pointcut)<strong>匹配到的</strong>连接点(Join Point)<strong>所对应的</strong>目标对象(Target)**上。</p><p>通知类型，用了代理这个设计模式</p><p>代理对象（Proxy）接管了对目标对象（Target）的访问。所有外部调用都必须先经过代理对象。</p><p>代理对象在将调用请求转发给真正的目标对象<strong>之前</strong>或<strong>之后</strong>，有机会执行额外的操作。这些额外的操作，就是我们之前说的<strong>通知（Advice）</strong>，也就是切面逻辑。</p><p><strong>pring AOP的核心是基于动态代理实现的。它利用代理模式，在运行时为我们的目标Bean动态地创建一个代理对象。这个代理对象拦截了对原始Bean方法的所有调用，并在调用前后织入了我们定义的切面逻辑（比如日志、事务等），从而在不修改源代码的情况下，实现了功能的增强。</strong></p><p>这个只能作用在public方法上，所以非public的方法会失效</p><p>通知注解，@Around<strong>包裹</strong>在目标方法的整个执行过程周围。它是功能最强大、最灵活的通知。</p><p>环绕通知的第一个参数必须是<code>ProceedingJoinPoint</code>，它有一个<code>proceed()</code>方法。</p><ul><li>你可以在<strong>调用<code>proceed()</code>方法之前</strong>执行逻辑（等同于<code>@Before</code>）。</li><li>你可以<strong>决定是否调用<code>proceed()</code>方法</strong>，从而决定是否执行目标方法。</li><li>你可以在<strong>调用<code>proceed()</code>方法之后</strong>执行逻辑（等同于<code>@AfterReturning</code>）。</li><li>你可以<strong>修改目标方法的参数或返回值</strong>。</li><li>你可以<strong>捕获并处理目标方法抛出的异常</strong>（等同于<code>@AfterThrowing</code>）。</li></ul><h2 id="3-spring的常用注解">3.spring的常用注解</h2><p>组件：</p><p><strong><code>@Component</code></strong>，标记为一个组件，生成一个bean</p><p><strong><code>@Service</code></strong>，业务层的组件注解</p><p><strong><code>@Repository</code></strong>，DTO层的组件注解，但是能让Spring<strong>自动转换特定于平台的数据库异常</strong>为统一的<code>DataAccessException</code>。</p><p><strong><code>@Controller</code></strong>，controller层的组件注解</p><p><strong><code>@Scope</code></strong>，定义Bean的作用域。最常用的两个是：</p><ul><li><code>singleton</code>：（默认值）在整个应用中只有一个实例。</li><li><code>prototype</code>：每次请求（获取）时都会创建一个新的实例。request，websocket,context,session</li></ul><p><strong><code>@PostConstruct</code></strong> 和 <strong><code>@PreDestroy</code></strong>,初始化合销毁</p><p>DI</p><p><strong><code>@Autowired</code></strong>，按**类型（byType）<strong>自动注入依赖。如果找到多个相同类型的Bean，会尝试按</strong>名称（byName）**匹配。如果还找不到就会报错。</p><p><strong><code>@Qualifier(&quot;beanName&quot;)</code></strong>，指定bean的名称注入，多个bean相同的</p><p><strong><code>@Resource(name = &quot;beanName&quot;)</code></strong>，默认按名称注入，找不到就按类型注入</p><p>web</p><p><strong><code>@RestController</code></strong>，专门写API的</p><p><strong><code>@RequestMapping(&quot;/path&quot;)</code></strong>，指定URL</p><p><strong><code>@RequestParam</code></strong>，从请求的URL的？中获取参数</p><p><strong><code>@PathVariable</code></strong>，从URL路径里面获取参数</p><p><strong><code>@RequestBody</code></strong>，把发过来的JSON请求体变成一个Java对象</p><p>配置</p><p><strong><code>@SpringBootApplication</code></strong>=</p><ul><li><code>@SpringBootConfiguration</code>: (就是<code>@Configuration</code>)</li><li><code>@EnableAutoConfiguration</code>: 启用Spring Boot的自动配置机制。内部使用@Import注解是自动装配的核心，每发现一个自动配置类，就Selector使用条件判断来确实是不是满足导入条件，自动创建所选bean</li><li>@AutoConfigurationPackage，将项目src中main包下的所有组件注册到容器中</li><li><code>@ComponentScan</code>: 自动扫描启动类所在包及其子包下的所有组件。</li></ul><p><strong><code>@Value</code></strong>，配置文件读取值</p><p><strong><code>@Bean</code></strong>，作用方法上</p><p><strong><code>@Configuration</code></strong>，表明配置类</p><h2 id="4-Bean">4.@Bean</h2><p>创建-&gt;实例化-&gt;填充属性-&gt;初始化-&gt;可用和销毁</p><p>实例化：当客户端请求一个Bean，或者在容器启动时，Spring容器会查找Bean的定义。利用java的反射机制或者工厂方法创建一个原始的bean</p><p>填充属性，IOC容器识别bean的依赖关系，比如@Autowired@Resource。从容器中查找对应的bean，通过反射将依赖注入到bean的属性中</p><p>初始化，最重要的点，扩展点最多的。</p><p><strong>执行Aware接口的方法</strong>，实现了特定的<code>Aware</code>接口，比如BeanNameAware<code>, </code>BeanFactoryAware<code>, </code>ApplicationContextAware</p><p><strong>执行<code>BeanPostProcessor</code>的前置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法。</p><p><strong>执行<code>@PostConstruct</code>注解的方法</strong>，调用使用了@postConstruct的方法</p><p><strong>执行<code>InitializingBean</code>接口的方法</strong>，实现了<code>InitializingBean</code>接口，Spring会调用它的<code>afterPropertiesSet()</code>方法。</p><p><strong>执行自定义的<code>init-method</code></strong>，如果在XML配置或<code>@Bean</code>注解中指定了<code>init-method</code>，Spring会调用这个自定义的初始化方法。</p><p><strong>执行<code>BeanPostProcessor</code>的后置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法。</p><p>Spring的**AOP（动态代理）**就是在这个阶段通过包装原始Bean实例，并返回一个代理对象来实现的。我们平时拿到的Bean，很多时候其实是这一步处理后的代理对象。</p><p>可用和销毁，当Spring容器关闭时（或者对于非<code>singleton</code>作用域的Bean，当其作用域结束时）。按照顺序执行</p><ul><li><strong>执行<code>@PreDestroy</code>注解的方法</strong>：如果Bean的方法上使用了<code>@PreDestroy</code>注解，Spring会调用这个方法。这也是<strong>推荐</strong>的销毁回调方式。</li><li><strong>执行<code>DisposableBean</code>接口的方法</strong>：如果Bean实现了<code>DisposableBean</code>接口，Spring会调用它的<code>destroy()</code>方法。</li><li><strong>执行自定义的<code>destroy-method</code></strong>：如果在XML配置或<code>@Bean</code>注解中指定了<code>destroy-method</code>，Spring会调用这个方法。</li></ul><p>扩展点</p><p><strong><code>BeanFactoryPostProcessor</code></strong></p><ul><li><strong>作用时机</strong>：在Spring容器<strong>加载了所有Bean的定义信息（BeanDefinition），但尚未创建任何Bean实例之前</strong>。</li><li><strong>能力</strong>：允许你<strong>读取并修改Bean的定义元数据</strong>。例如，你可以动态地修改某个Bean的属性值，甚至更改它的作用域。</li><li><strong>通俗理解</strong>：给你一个机会在“蓝图”阶段修改设计图纸，而不是等房子建好了再去敲墙。</li></ul><p>比如是在<code>application.properties</code>中使用占位符 <code>$&#123;...&#125;</code> 的功能(<code>PropertySourcesPlaceholderConfigurer</code>)。MyBatis的<code>MapperScannerConfigurer</code>，它会扫描接口并将其注册为Bean定义。</p><p><strong><code>BeanPostProcessor</code></strong></p><ul><li><p><strong>作用时机</strong>：在Bean<strong>实例化和属性填充之后，初始化方法（<code>init-method</code>, <code>@PostConstruct</code>）的前后</strong>。</p></li><li><p>能力</p><p>：包含两个方法：</p><ul><li><code>postProcessBeforeInitialization</code>: 在初始化之前干预。</li><li><code>postProcessAfterInitialization</code>: 在初始化之后干预。<strong>Spring的AOP就是通过它实现的</strong>，在此处返回Bean的代理对象。</li></ul></li><li><p><strong>通俗理解</strong>：在房子建好（实例化）并装修完（填充属性）之后，在主人入住（可用）前后，给你机会对房子进行“精装修”或“改造”（如加装监控系统-AOP）。</p></li></ul><p><strong><code>Aware</code>系列接口</strong>:</p><ul><li><strong>作用时机</strong>：在Bean的初始化阶段，<code>BeanPostProcessor</code>之前。</li><li><strong>能力</strong>：让Bean能“感知”并获取到Spring容器自身的资源，如<code>ApplicationContext</code>、<code>BeanFactory</code>、<code>BeanName</code>等。</li><li><strong>通俗理解</strong>：让Bean知道自己“身在何处”以及“叫什么名字”。</li></ul><p><strong><code>InitializingBean</code>和<code>DisposableBean</code></strong>:</p><ul><li><strong>作用时机</strong>：初始化和销毁阶段的特定回调。</li><li><strong>能力</strong>：提供<code>afterPropertiesSet()</code>和<code>destroy()</code>方法，用于自定义初始化和销毁逻辑。</li><li><strong>通俗理解</strong>：Bean的“出生仪式”和“临终遗言”的固定写法。（现在更推荐使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，因为无代码侵入）</li></ul><h2 id="5-spring事务">5.spring事务</h2><p>事务分为声明型事务和编程型事务</p><p>声明型事务，通过注解**<code>@Transactional</code>**来声明，他的底层是基于AOP实现的</p><ul><li><ol><li>Spring容器在启动时，会为标记了<code>@Transactional</code>的Bean创建一个<strong>代理对象 (Proxy)</strong>。</li><li>当外部调用这个代理对象的方法时，代理逻辑会先被触发。</li><li><strong>事务开始</strong>：代理逻辑会负责开启事务（例如，禁用数据库连接的自动提交 <code>connection.setAutoCommit(false)</code>）。</li><li><strong>执行业务</strong>：然后，代理对象再调用你编写的原始业务方法。</li><li>事务提交/回滚：<ul><li>如果业务方法正常执行完毕，代理逻辑会<strong>提交</strong>事务。</li><li>如果业务方法抛出<strong>运行时异常 (RuntimeException)</strong> 或 <strong>Error</strong>，代理逻辑会<strong>回滚</strong>事务。</li></ul></li></ol></li><li><strong>优点</strong>：对业务代码<strong>无侵入</strong>，将事务管理代码与业务逻辑彻底解耦，使得代码非常清晰。</li></ul><p>编程型事务，在业务代码中，通过手动调用<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>的API来精确地控制事务的边界。</p><p>然后调用方法，自己进行手动的提交和手动的回滚</p><p>提供了极高的灵活性，可以实现非常精细的事务控制，比如在一个方法内实现多次提交或回滚。但是高耦合</p><p>事务的隔离级别跟mysql的事务的隔离级别相同。多了一个**<code>DEFAULT</code><strong>：这是<code>@Transactional</code>注解的</strong>默认值**。它表示使用数据库本身设置的默认隔离级别。一般数据库的事务的隔离级别就是rr</p><p>或者rc?</p><p>但是事务会失效的，事务失效的场景如下：</p><p>AOP代理有关的</p><ol><li><strong>方法不是<code>public</code>的</strong><ul><li><strong>原因</strong>：Spring AOP的代理机制在为类创建代理时，只会代理其<code>public</code>方法。如果你将<code>@Transactional</code>注解用在<code>protected</code>、<code>private</code>或<code>package-private</code>方法上，事务不会生效，也不会有任何报错。</li><li><strong>一句话总结</strong>：<strong>代理对象无法覆盖非公有方法</strong>。</li></ul></li><li><strong>方法被<code>final</code>修饰</strong><ul><li><strong>原因</strong>：被<code>final</code>修饰的方法无法被子类重写（Override）。Spring的CGLIB动态代理是通过创建目标类的子类来实现的，因此无法代理<code>final</code>方法。</li><li><strong>一句话总结</strong>：<strong>final方法无法被代理</strong>。</li></ul></li><li><strong>同一个类中的方法调用（<code>this</code>调用）</strong><ul><li><strong>原因</strong>：这是最常见也最隐蔽的失效场景。当你在一个Bean的<code>methodA</code>中调用同一个类中的<code>methodB</code>（<code>methodB</code>有<code>@Transactional</code>注解）时，这个调用是通过<code>this</code>指针直接发生的，<strong>绕过了代理对象</strong>。事务增强逻辑是存在于代理对象中的，所以事务会失效。</li></ul></li></ol><p>跟运行时异常有关的</p><ol><li><strong>异常被<code>try-catch</code>捕获了</strong><ul><li><strong>原因</strong>：Spring声明式事务默认只在遇到<strong>RuntimeException或Error</strong>时才会回滚。如果你在事务方法内部用<code>try-catch</code>捕获了异常，并且没有在<code>catch</code>块中重新抛出，那么Spring的事务代理就无法感知到异常的发生，从而会正常提交事务。</li><li><strong>一句话总结</strong>：<strong>异常没有传播到代理层，代理以为一切正常</strong>。</li></ul></li><li><strong>指定了不回滚的异常类型</strong><ul><li><strong>原因</strong>：在<code>@Transactional(noRollbackFor = ...)</code>中指定了某个异常类，那么当这个异常发生时，事务将不会回滚。</li><li><strong>示例</strong>：<code>@Transactional(noRollbackFor = NullPointerException.class)</code></li></ul></li></ol><p>事务有关的</p><ol><li><strong>数据库引擎不支持事务</strong><ul><li><strong>原因</strong>：例如，MySQL的MyISAM引擎就不支持事务。如果表使用了不支持事务的引擎，所有事务相关的操作都会被静默忽略。</li><li><strong>一句话总结</strong>：<strong>底层基础不支持，上层框架无能为力</strong>。</li></ul></li><li>事务的传播类型设置的不对，比如不支持事务never</li></ol><p>事务的传播机制：</p><ol><li><strong><code>REQUIRED</code> (需要)</strong><ul><li><strong>描述</strong>：这是<strong>默认</strong>的传播特性。如果当前存在一个事务，那么新方法就<strong>加入</strong>到这个事务中。如果当前没有事务，就<strong>新建</strong>一个事务。</li><li><strong>场景</strong>：绝大多数情况下的选择。</li></ul></li><li><strong><code>SUPPORTS</code> (支持)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就加入。如果当前没有事务，就以<strong>非事务</strong>的方式执行。</li><li><strong>场景</strong>：用于那些“可有可无”的事务方法，比如一些只读查询操作。</li></ul></li><li><strong><code>MANDATORY</code> (强制)</strong><ul><li><strong>描述</strong>：<strong>强制</strong>要求当前必须存在一个事务。如果当前没有事务，就会抛出异常。它不会自己创建事务。</li><li><strong>场景</strong>：用于那些必须在事务环境下执行的核心操作，起到一种校验作用。</li></ul></li><li><strong><code>REQUIRES_NEW</code> (需要新的)</strong><ul><li><strong>描述</strong>：<strong>总是创建一个全新的、独立的事务</strong>。如果当前已经存在一个事务，会把当前事务<strong>挂起</strong>，然后执行新事务。新事务执行完毕后，再恢复被挂起的事务。</li><li><strong>场景</strong>：希望某些操作的事务结果独立于外部事务，不受其影响。比如，在一个大的下单流程中，记录操作日志，无论下单成功与否，日志都必须成功入库。</li></ul></li><li><strong><code>NOT_SUPPORTED</code> (不支持)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，会把当前事务<strong>挂起</strong>。</li><li><strong>场景</strong>：用于那些明确不希望在事务中运行的方法。</li></ul></li><li><strong><code>NEVER</code> (从不)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，就会抛出异常。</li><li><strong>场景</strong>：用于和<code>MANDATORY</code>相对的校验场景。</li></ul></li><li><strong><code>NESTED</code> (嵌套)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就在这个事务中创建一个<strong>嵌套事务（保存点 Savepoint）</strong>。嵌套事务独立于外部事务进行提交或回滚。如果外部事务回滚，嵌套事务也会回滚。但嵌套事务的回滚不影响外部事务。如果当前没有事务，行为等同于<code>REQUIRED</code>。</li><li><strong>注意</strong>：这是一个部分数据库才支持的特性（如Oracle），需要底层JDBC驱动和数据库的支持。</li></ul></li></ol><h2 id="6-spring-MVC">6.spring MVC</h2><p>MVC 设计模式：</p><p>model-&gt;view-&gt;controller</p><p>作用：</p><ol><li><strong>实现MVC模式的解耦</strong>：它提供了一套清晰的架构，将处理请求的控制器、业务逻辑的模型和展示用的视图分离开来，极大地提高了代码的可维护性、可扩展性和可测试性。</li><li><strong>简化Web开发</strong>：它基于Servlet API构建，但极大地简化了底层的Servlet、Request、Response等对象的直接操作。开发者可以用简单的注解（如<code>@GetMapping</code>, <code>@PostMapping</code>）来处理复杂的HTTP请求。</li><li><strong>与Spring生态无缝集成</strong>：它可以非常方便地使用Spring核心的IoC和AOP功能，轻松整合Service层、DAO层以及事务管理等。</li><li><strong>提供强大的功能</strong>：内置了强大的参数绑定、数据校验、RESTful风格支持、拦截器、国际化、文件上传等一系列Web开发所需的核心功能。</li></ol><p>springmvc核心组件&amp;&amp;执行过程c</p><p>常用注解，那几个mappring 参数绑定的那几个</p><p>深入知识：</p><p>1.<strong>统一异常处理 (<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>)</strong></p><ul><li><strong>作用</strong>：通过创建一个带有<code>@ControllerAdvice</code>注解的类，可以在其中定义多个<code>@ExceptionHandler</code>方法，来集中处理整个应用中由Controller抛出的特定异常。这避免了在每个Controller中都写<code>try-catch</code>，实现了优雅的全局异常处理。</li><li><strong>示例</strong>：捕获所有<code>NullPointerException</code>，并返回一个自定义的错误JSON。</li></ul><p>2.<strong>拦截器 (<code>HandlerInterceptor</code>)</strong></p><ul><li><p><strong>作用</strong>：提供了在请求处理的生命周期中（<strong>Controller方法执行前后</strong>）织入自定义逻辑的能力。它比Servlet Filter更精细，因为它能访问到即将执行的<code>Handler</code>信息。</p></li><li><p>三大方法</p><p>：</p><ul><li><code>preHandle</code>: 在Controller方法执行<strong>之前</strong>调用。可以进行权限验证、日志记录等。返回<code>false</code>则中断后续流程。</li><li><code>postHandle</code>: 在Controller方法执行<strong>之后</strong>，视图渲染<strong>之前</strong>调用。可以修改<code>ModelAndView</code>中的数据。</li><li><code>afterCompletion</code>: 在整个请求处理完成（包括视图渲染）<strong>之后</strong>调用。主要用于资源清理。</li></ul></li><li><p><strong>与Filter的区别</strong>：Filter是Servlet规范的一部分，作用范围更广，能处理所有HTTP请求；Interceptor是Spring MVC的一部分，只能处理经过<code>DispatcherServlet</code>的请求，但能获取到Spring MVC的上下文信息。</p></li></ul><p>3.<strong>数据绑定与类型转换 (<code>DataBinder</code>, <code>Converter</code>)</strong></p><p>Spring MVC能自动将请求参数（都是字符串）转换为Controller方法参数所需的类型（如<code>Integer</code>, <code>Date</code>）。这个过程就是数据绑定。我们可以通过实现<code>Converter</code>接口，并将其注册到Spring中，来定义自定义的类型转换逻辑（例如，将&quot;2023-01-01&quot;字符串转换为<code>LocalDate</code>对象）。</p><p>4.<strong>跨域请求处理 (<code>@CrossOrigin</code>)</strong></p><ul><li><strong>作用</strong>：简单方便地解决Web开发中常见的跨域资源共享（CORS）问题。可以直接在<code>Controller</code>类或方法上使用<code>@CrossOrigin</code>注解，来允许来自特定域的跨域请求。</li></ul><h2 id="7-springboot">7.springboot</h2><p>springboot是啥，四大特性（自动配置，starter，内嵌web服务器，无需xml配置）</p><p>常用的starter，Starter本质上是一个<strong>Maven依赖描述符 (pom)</strong>。它的作用是将实现某一特定功能所需的所有依赖项打包在一起，并触发与该功能相关的自动配置。</p><p>启动springboot，</p><p>spring-boot-devtools热部署工作原理：</p><p>当<code>devtools</code>检测到classpath下的文件发生变化时，它会触发应用<strong>快速重启</strong>（不是完全重启，速度很快）。它通过维护两个类加载器（一个加载不变的第三方库，一个加载你自己的代码）来实现这一点，只重新加载你自己写的代码，从而大大加快了速度。</p><p><strong>Spring Boot JAR 与 普通JAR的区别</strong></p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>普通JAR (Thin JAR)</strong></th><th style="text-align:left"><strong>Spring Boot JAR (Fat JAR / Executable JAR)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>内容</strong></td><td style="text-align:left">只包含你项目自己编译的<code>.class</code>文件和资源文件。</td><td style="text-align:left"><strong>包含所有内容</strong>：你的代码、资源文件，以及项目所需的所有第三方依赖库的JAR包。</td></tr><tr><td style="text-align:left"><strong>大小</strong></td><td style="text-align:left">非常小。</td><td style="text-align:left">非常大，因此也叫“胖JAR”。</td></tr><tr><td style="text-align:left"><strong>运行方式</strong></td><td style="text-align:left">不能直接<code>java -jar</code>运行（除非配置了<code>Main-Class</code>且无外部依赖）。通常是作为其他项目的库被引用。</td><td style="text-align:left">可以通过<code>java -jar</code>命令<strong>直接运行</strong>，因为它内置了所有依赖和启动逻辑。</td></tr><tr><td style="text-align:left"><strong>结构</strong></td><td style="text-align:left">标准JAR结构。</td><td style="text-align:left">特殊的结构。解压后会看到一个<code>BOOT-INF</code>目录，里面包含了<code>classes</code>（你的代码）和<code>lib</code>（所有依赖的JAR包）。还有一个<code>org/springframework/boot/loader</code>目录，这是Spring Boot的启动加载器。</td></tr></tbody></table><p>自动装配原理，Spring Boot的自动装配核心在于<code>@SpringBootApplication</code>注解，而这个注解又是一个组合注解，其中最关键的是<code>@EnableAutoConfiguration</code>。</p><ol><li><strong><code>@EnableAutoConfiguration</code></strong>：这个注解是自动配置的开关。</li><li><strong><code>@Import(AutoConfigurationImportSelector.class)</code></strong>：<code>@EnableAutoConfiguration</code>内部通过<code>@Import</code>注解导入了<code>AutoConfigurationImportSelector</code>这个类。</li><li><strong><code>AutoConfigurationImportSelector</code></strong>：这个类的核心作用是去<strong>加载和筛选</strong>需要被激活的自动配置类。</li><li><strong>扫描<code>META-INF/spring.factories</code></strong>：它会扫描项目中所有JAR包的<code>META-INF/spring.factories</code>文件。这个文件中定义了所有可能的自动配置类（key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>）。</li><li><strong>按需加载</strong>：<code>Selector</code>会根据<strong>条件注解 (<code>@ConditionalOnClass</code>, <code>@ConditionalOnBean</code>等)</strong> 来判断这些自动配置类是否满足生效条件（比如<code>DataSourceAutoConfiguration</code>只有在classpath下存在<code>DataSource.class</code>时才会生效）。</li><li><strong>注入Bean</strong>：最终，满足条件的自动配置类被加载到Spring容器中，它们内部定义的各种Bean（如<code>DataSource</code>, <code>RestTemplate</code>）就被创建并注入了。</li></ol><p>@Import注解：</p><p><code>@Import</code>是Spring框架提供的基础注解，它比<code>@Bean</code>更强大，通常用于<strong>批量导入Bean</strong>或者<strong>导入配置类</strong>。它有三种主要使用方式，而Spring Boot的自动配置正是利用了第三种：</p><ol><li><strong>导入普通的类</strong>：<code>@Import(MyService.class)</code>，Spring会将<code>MyService</code>注册为一个Bean。</li><li><strong>导入配置类</strong>：<code>@Import(MyConfig.class)</code>，Spring会加载<code>MyConfig</code>这个配置类以及它内部定义的所有<code>@Bean</code>。</li><li><strong>导入<code>ImportSelector</code>实现类</strong>：<strong>这是最关键的用法</strong>。<code>@Import(MyImportSelector.class)</code>，Spring会实例化<code>MyImportSelector</code>，并调用它的<code>selectImports()</code>方法，该方法返回一个字符串数组，数组里的每一个类名都会被Spring注册为Bean。<strong>Spring Boot的自动配置就是通过这种方式，动态地、可选择地加载了大量的配置类。</strong></li></ol><h1>spring源码分析</h1><h2 id="bean">bean</h2><p>凡是可以存放数据的具体数据结构实现，都可以称之为容器，在 Spring Bean 容器的场景下，我们需要一种可以用于存放和名称索引式的数据结构，所以选择 HashMap 是最合适不过的。</p><p>HashMap 是一种基于扰动函数、负载因子、红黑树转换等技术内容，形成的拉链寻址的数据结构，它能让数据更加散列的分布在哈希桶以及碰撞时形成的链表和红黑树上。它的数据结构会尽可能最大限度的让整个数据读取的复杂度在 O(1) ~ O(Logn) ~O(n)之间，当然在极端情况下也会有 O(n) 链表查找数据较多的情况。不过我们经过10万数据的扰动函数再寻址验证测试，数据会均匀的散列在各个哈希桶索引上，所以 HashMap 非常适合用在 Spring Bean 的容器实现上。但是我们实际上应用的是concurrenthashmap，因为他是线程安全的。我们的bean不可能只是单线程进行操作的。他是一个弱一致性迭代器，避免了并发的修改异常。</p><p>一个简单的 Spring Bean 容器实现，还需 Bean 的定义、注册、获取三个基本步骤</p><ul><li>定义：BeanDefinition，可能这是你在查阅 Spring 源码时经常看到的一个类，例如它会包括 singleton、prototype、BeanClassName 等。</li><li>注册：这个过程就相当于我们把数据存放到 HashMap 中，只不过现在 HashMap 。在我们注册阶段Map里面存储的是beanDefintion</li><li>获取：最后就是获取对象，Bean 的名字就是key，Spring 容器初始化好 Bean 以后，就可以直接获取了。</li><li>实例化完成之后里面存储的才是bean实例</li></ul><p>我们解决循环依赖的三级缓存就是这么设计的，key是bean的名字，value是bean的实例。</p><hr><p>Spring Bean 容器的整个实现内容非常简单，也仅仅是包括了一个简单的 BeanFactory 和 BeanDefinition</p><ol><li><p>BeanDefinition，用于定义 Bean 实例化信息，现在的实现是以一个 Object 存放对象，可以继续添加属性，比如:SCOPE_SINGLETON、SCOPE_PROTOTYPE、ROLE_APPLICATION、ROLE_SUPPORT、ROLE_INFRASTRUCTURE 以及 Bean Class 信息。</p></li><li><p>BeanFactory，代表了 Bean 对象的工厂，可以存放 Bean 定义到 Map 中以及获取。</p></li></ol><p>在 Bean 工厂的实现中，包括了 Bean 的注册，这里注册的是 Bean 的定义信息。同时在这个类中还包括了获取 Bean 的操作。</p><p>然后我们使用的时候，是先初始化beanfactory容器，然后通过beanDefinition来创建一个bean。</p><p>然后去通过beanfactory去获取我们注册的bean，然后去使用bean里面封装的方法。这个时候才会实例化</p><p>然后实际我们使用的spring容器比如说是<strong>DefaultListableBeanFactory</strong>，他是继承了AbstractAutowireCapableBeanFactory，然后实现了ConfigurableListableBeanFactory, BeanDefinitionRegistry</p><p>里面包括存储BeanDefinition的容器，存储bean定义名词的列表，一级缓存，已经完成初始化的单例bean,二级缓存，早期bean的引用。三级缓存，单例工厂</p><p>我们注册bean的时候bean并没有实例化，直到获取bean的时候才会实例化，这就是懒加载</p><p>获取的时候先从一级缓存获取，缓存没有才创建bean</p><hr><h2 id="设计模式">设计模式</h2><p>职责分清，一个接口只关注一个核心的职责，通过组合来实现多种能力。这样的话，方便我们的后续扩展和维护</p><p>比如我们的BeanFactory只负责获取bean,SingletonBeanRegistry只负责单例bean的管理，BeanDefinitionRegistry 只负责定义注册</p><p>模板方法模式，所有子类都遵循相同的Bean获取流程，子类只需实现特定的抽象方法，通用逻辑在父类中实现</p><p>比如一个抽象的基类AbstractBeanFactory定义了获取bean的标准流程，先去看一级缓存中有没有，没有的话，获取一个beandefinition，然后创建实例化这个bean</p><p>然后剩下的方法只是定义完，具体的逻辑留给子类实现</p><p>分层架构，每一层都该干属于自己的事情，比如接口层定义契约和规范，然后抽象类层，实现通用的逻辑和模板方法，实现类层，实现具体的业务逻辑实现</p><p>然后在我们的项目中，比如说实现一个支付的实现的话，我们可以先创建一个支付接口，定义一个执行方法。</p><p>然后创建一个所有的支付类共同的抽象类，实现支付的基本逻辑，先检验参数，然后执行，获取执行结果，返回执行结果</p><p>然后子类具体的去实现这个执行的逻辑，比如支付宝的具体的实现逻辑</p><p>比如说我们在项目中可以根据我们的类型来选择我们要实例化bean的模式，一般就是普通的jdk代理或者是cglib代理，可以在bean属性中class里面设定，然后我们根据属性的设定来选择我们具体是选择哪一种策略。</p><h2 id="实例化">实例化</h2><p>jdk实例化，首先通过 beanDefinition 获取 Class 信息，这个 Class 信息是在 Bean 定义的时候传递进去的。然后看我们获取的class信息是不是空的，空的就是无构造函数实例化，不是空的就是有构造函数实例化。这里我们重点关注有构造函数的实例化，实例化方式为 <code>clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</code>，把入参信息传递给 newInstance 进行实例化。比较简单，适用于简单的pojo对象。</p><p>cglib实例化,先是构建enhancer，设置目标为父类。设置回溯，使用noop就是说明不需要额外的处理。可以设置<code>MethodInterceptor</code>等其他回调来实现AOP功能</p><p>如果class信息为空，就enhacers默认的创建，不为空的话，就创建我们指定的构造器的类型。</p><p>支持动态代理，适用于需要进行增强的对象。运行的时候动态的生成新的class文件，比如需要事务代理，需要缓存代理的</p><table><thead><tr><th>特性</th><th>JDK反射</th><th>Cglib动态代理</th></tr></thead><tbody><tr><td><strong>实现原理</strong></td><td>Java原生反射API</td><td>字节码动态生成</td></tr><tr><td><strong>性能表现</strong></td><td>反射调用开销较小</td><td>首次创建开销大，后续调用快</td></tr><tr><td><strong>功能扩展</strong></td><td>仅支持实例化</td><td>支持方法拦截、AOP增强</td></tr><tr><td><strong>依赖要求</strong></td><td>无额外依赖</td><td>需要cglib和asm库</td></tr><tr><td><strong>代理限制</strong></td><td>无法代理final类/方法</td><td>无法代理final类/方法</td></tr></tbody></table><h2 id="注入">注入</h2><p>属性填充的时机，实在对象创建后立刻进行。<strong>. PropertyValue - 属性值载体****，PropertyValues - 属性集合管理</strong> <strong>BeanReference - 对象依赖标识</strong></p><ul><li><strong>延迟解析</strong>：不是直接存储Bean对象，而是存储Bean名称</li><li><strong>递归创建</strong>：在属性填充时才真正创建依赖的Bean</li><li><strong>循环依赖预留</strong>：为后续处理循环依赖留下接口</li></ul><p>属性填充方法，内部使用递归，检测到<code>BeanReference</code>类型，调用<code>getBean(beanReference.getBeanName())</code>获取他的依赖的名字</p><p>使用递归获取，被依赖的Bean创建完成后返回，用创建好的Bean对象填充当前Bean的属性</p><p>框架自动处理依赖关系，开发者无需关心创建顺序，只有真正需要这个bean的时候才会创建，提高了性能。然后我们创建后的Bean会被缓存，避免重复创建。这是缓存的思想</p><p>处理循环依赖：使用三级缓存架构来解决，一级缓存，完整的bean。二级缓存，实例化，没有进行属性的填充。三级缓存，bean的工厂对象，用于解决aop代理的问题</p><table><thead><tr><th>缓存级别</th><th>存储内容</th><th>作用</th><th>时机</th></tr></thead><tbody><tr><td><strong>一级缓存</strong></td><td>完整的Bean对象</td><td>存放完全初始化好的Bean</td><td>Bean创建完成后</td></tr><tr><td><strong>二级缓存</strong></td><td>早期Bean对象</td><td>存放实例化但未填充属性的Bean</td><td>解决循环依赖时</td></tr><tr><td><strong>三级缓存</strong></td><td>ObjectFactory</td><td>用于创建代理对象</td><td>Bean实例化后立即放入</td></tr></tbody></table><p>扩展支持private boolean allowCircularReference = true;</p><p><strong>DefaultSingletonBeanRegistry</strong>：</p><p>一级一级的调用，先去找一次缓存没有，标记为正在创建，然后再找二级缓存，允许早期引用。没有就从三级缓存中获取，还没有的话，<em>通过ObjectFactory创建Bean</em></p><p>然后放入二级缓存，从三级缓存中删除。</p><p>实体类方法：</p><p>实例化后立刻放入三级缓存，然后进行填充属性。然后初始化bean，成功之后放入一级缓存，标记为完成</p><p>流程：</p><p><strong>创建UserService</strong></p><ol><li>doGetBean(“userService”)</li><li>getSingleton(“userService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“userService”) → 标记正在创建</li><li>createBeanInstance() → 实例化UserService对象</li><li>addSingletonFactory(“userService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充orderService属性</li><li>getBean(“orderService”) → 触发OrderService创建</li></ol><p>创建orderService</p><ol start="8"><li>doGetBean(“orderService”)</li><li>getSingleton(“orderService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“orderService”) → 标记正在创建</li><li>createBeanInstance() → 实例化OrderService对象</li><li>addSingletonFactory(“orderService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充userService属性</li><li>getBean(“userService”) → 再次请求UserService</li></ol><p>循环依赖解析</p><ol start="15"><li>doGetBean(“userService”)</li><li>getSingleton(“userService”, true) → 执行三级缓存查找<ul><li>一级缓存：null</li><li>isSingletonCurrentlyInCreation(“userService”) → true</li><li>二级缓存：null</li><li>三级缓存：找到ObjectFactory</li><li>factory.getObject() → 返回早期UserService对象</li><li>放入二级缓存，移除三级缓存</li></ul></li><li>返回早期UserService对象给OrderService</li><li>OrderService属性填充完成</li><li>OrderService初始化完成，添加到一级缓存</li><li>返回OrderService给UserService</li><li>UserService属性填充完成</li><li>UserService初始化完成，添加到一级缓存</li></ol><p>这就是我们所说的提前暴露的问题</p><h2 id="bean管理">bean管理</h2><p>使用配置文件来管理我们的bean,添加一个资源解释器，也就是能读取classpath、本地文件和云文件的配置内容</p><p>里面会包括 Bean 对象的描述和属性信息。在读取配置文件信息后，接下来就是对配置文件中的 Bean 描述信息解析后进行注册操作，把 Bean 对象注册到 Spring 容器中。</p><p>从配置文件层-&gt;资源加载层-&gt;解析注册层-&gt;bean容器层</p><hr><p>资源加载：定义 Resource 接口，提供获取 InputStream 流的方法</p><p>然后策略实现类，多种的实现策略。</p><p><strong>ClassPath资源加载</strong>：</p><p>通过 <code>ClassLoader</code> 读取<code>ClassPath</code> 下的文件信息，具体的读取过程主要是：<code>classLoader.getResourceAsStream(path)</code></p><ul><li><strong>打包后的配置文件</strong>：JAR包内的spring.xml</li><li><strong>测试资源</strong>：src/test/resources下的配置文件</li><li><strong>类路径资源</strong>：与class文件同目录的配置文件</li></ul><p><strong>文件系统资源加载</strong>：</p><p>通过指定文件路径的方式读取文件信息</p><ul><li><strong>外部配置文件</strong>：/etc/app/config.xml</li><li><strong>用户自定义配置</strong>：~/app/custom.properties</li><li><strong>绝对路径资源</strong>：D:/config/spring.xml</li></ul><p><strong>URL资源加载</strong>：</p><p>通过 HTTP 的方式读取云服务的文件，我们也可以把配置文件放到 GitHub 或者 Gitee 上，使用URLConnection</p><ul><li><strong>远程配置中心</strong>：<a href="http://config-server/app.xml">http://config-server/app.xml</a></li><li><strong>云端配置文件</strong>：<a href="https://github.com/user/repo/config.xml">https://github.com/user/repo/config.xml</a></li><li><strong>动态配置</strong>：从配置中心实时拉取</li></ul><hr><p>智能资源定位器，<strong>DefaultResourceLoader</strong></p><p>按照资源加载的不同方式，资源加载器可以把这些方式集中到统一的类服务下进行处理，外部用户只需要传递资源地址即可</p><p>使用的顺序是先去从classpath进行获取，然后再去获取url资源。都没有的话采取获取默认的文件系统资源</p><p>Bean定义读取器，BeanDefinitionReader</p><p>通过这个抽象类的具体实现就可以把解析后的 XML 文件中的 Bean 信息，注册到 Spring 容器去了。<em>以前我们是通过单元测试使用，调用 BeanDefinitionRegistry 完成Bean的注册，现在可以放到 XMl 中操作了</em></p><p>解析xml处理bean注册，<strong>XmlBeanDefinitionReader</strong> 基础自抽象类</p><p>将xml文件映射为我们需要的代码，然后进行在spring容器中的注册</p><h2 id="bean组件的扩展">bean组件的扩展</h2><p>在实际工作中，当我们开发基于Spring的技术组件（如中间件、SpringBoot Starter等）时，经常需要：</p><ul><li>修改Bean的信息</li><li>添加日志打印、监控</li><li>处理数据库路由和数据源切换</li><li>给RPC服务连接注册中心</li><li>实现AOP切面功能</li></ul><p>这些都需要在Bean的生命周期中插入自定义逻辑，这就是Spring扩展机制的核心价值。</p><p><strong>BeanFactoryPostProcessor - Bean定义后置处理器</strong></p><p>在beandefinition加载完之后，bean实例化之前，可以去修改beandefinition的属性信息。相当于我们去建筑的蓝图。用于配置属性修改、Bean定义动态调整</p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 场景1：动态修改Bean的属性值</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">userServiceDef</span> <span class="operator">=</span> beanFactory.getBeanDefinition(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">PropertyValues</span> <span class="variable">pv</span> <span class="operator">=</span> userServiceDef.getPropertyValues();</span><br><span class="line">        pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;environment&quot;</span>, <span class="string">&quot;production&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景2：根据环境调整Bean配置</span></span><br><span class="line">        <span class="keyword">if</span> (isProductionEnvironment()) &#123;</span><br><span class="line">            pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;timeout&quot;</span>, <span class="string">&quot;30000&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景3：添加额外的Bean定义</span></span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;dynamicBean&quot;</span>, createDynamicBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanPostProcessor - Bean实例后置处理器</strong></p><p><em>Bean实例化和属性注入后，初始化方法调用前执行</em>,他有前置和后置的类型，我们一般在后置进行增加的更多，比如AOP代理，Bean增强，属性修改。依赖检查，权限校验和监控</p><p>ApplicationContext应用上下文架构</p><p>为了避免繁琐的操作，他是我们最常用的一个IOC容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简洁的上下文操作</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">UserService userService = context.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接口体系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 接口层次结构</span><br><span class="line">BeanFactory                           // 基础Bean工厂</span><br><span class="line">└── ListableBeanFactory              // 可列举Bean的工厂</span><br><span class="line">    └── ApplicationContext           // 应用上下文接口</span><br><span class="line">        └── ConfigurableApplicationContext  // 可配置的应用上下文</span><br><span class="line"></span><br><span class="line">// 实现层次结构  </span><br><span class="line">DefaultResourceLoader                 // 资源加载能力</span><br><span class="line">└── AbstractApplicationContext       // 上下文抽象实现</span><br><span class="line">    └── AbstractRefreshableApplicationContext     // 可刷新的上下文</span><br><span class="line">        └── AbstractXmlApplicationContext         // XML配置支持</span><br><span class="line">            └── ClassPathXmlApplicationContext    // 类路径XML上下文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在applicationcontext里面最重要的方法就是refresh方法</p><p>创建beanfactory然后加载beandefinnition</p><p>然后我们去获取beanfactory，执行<em>BeanFactoryPost</em>processor修改beandefinition</p><p>然后注册beanpostprocessor,为后续的处理进行准备</p><p>然后提前实例化单例的bean。</p><p>完整的生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. BeanDefinition注册</span><br><span class="line">        ↓</span><br><span class="line">2. BeanFactoryPostProcessor执行 ← 修改BeanDefinition</span><br><span class="line">        ↓</span><br><span class="line">3. Bean实例化（Constructor）</span><br><span class="line">        ↓</span><br><span class="line">4. 属性注入（Setter）</span><br><span class="line">        ↓</span><br><span class="line">5. BeanPostProcessor.postProcessBeforeInitialization ← Bean增强</span><br><span class="line">        ↓</span><br><span class="line">6. 初始化方法执行（@PostConstruct, InitializingBean, init-method）</span><br><span class="line">        ↓</span><br><span class="line">7. BeanPostProcessor.postProcessAfterInitialization ← AOP代理创建</span><br><span class="line">        ↓</span><br><span class="line">8. Bean就绪，放入容器</span><br><span class="line">        ↓</span><br><span class="line">9. 应用运行</span><br><span class="line">        ↓</span><br><span class="line">10. 容器关闭时执行销毁方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanFactoryPostProcessor应用场景</strong>：</p><ol><li><strong>配置中心集成</strong>：动态读取远程配置修改Bean属性</li><li><strong>环境相关配置</strong>：根据环境（dev/test/prod）调整Bean配置</li><li><strong>属性占位符解析</strong>：解析${property}占位符</li><li><strong>条件化Bean注册</strong>：根据条件动态注册Bean</li></ol><p><strong>BeanPostProcessor应用场景</strong>：</p><ol><li><strong>AOP实现</strong>：Spring AOP就是通过此接口创建代理对象</li><li><strong>中间件集成</strong>：如MyBatis的MapperScannerConfigurer</li><li><strong>监控和日志</strong>：自动添加监控、日志功能</li><li><strong>依赖注入增强</strong>：如@Autowired注解的实现</li><li><strong>数据源路由</strong>：动态数据源切换</li></ol><p><strong>Spring中哪些功能使用了这些扩展机制</strong></p><p><strong>BeanFactoryPostProcessor的应用</strong>：</p><ul><li><code>PropertyPlaceholderConfigurer</code>：属性占位符解析</li><li><code>PropertySourcesPlaceholderConfigurer</code>：Spring 3.1+的属性解析</li><li><code>ConfigurationClassPostProcessor</code>：@Configuration类处理</li></ul><p><strong>BeanPostProcessor的应用</strong>：</p><ul><li><code>AutowiredAnnotationBeanPostProcessor</code>：@Autowired注解处理</li><li><code>CommonAnnotationBeanPostProcessor</code>：@Resource等注解处理</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>：AOP代理创建</li></ul><h2 id="bean的初始化和销毁">bean的初始化和销毁</h2><p>完整的生命周期：</p><p>Bean定义注册<br>↓<br>BeanFactoryPostProcessor执行<br>↓<br>Bean实例化（Constructor）<br>↓<br>属性注入（Setter/Field）<br>↓<br>BeanPostProcessor.postProcessBeforeInitialization<br>↓<br>InitializingBean.afterPropertiesSet() ← 接口方式初始化<br>↓<br>init-method执行 ← XML配置方式初始化<br>↓<br>BeanPostProcessor.postProcessAfterInitialization<br>↓<br>Bean就绪状态<br>↓<br>容器关闭触发<br>↓<br>DisposableBean.destroy() ← 接口方式销毁<br>↓<br>destroy-method执行 ← XML配置方式销毁</p><p>在这个里面,init-method和destory-method他们也是要xml配置来进行的。所以也要通过 XmlBeanDefinitionReader 加载 spring.xml 配置信息到 BeanDefinition 中。</p><ul><li>InitializingBean、DisposableBean，两个接口方法还是比较常用的，在一些需要结合 Spring 实现的组件中，经常会使用这两个方法来做一些参数的初始化和销毁操作。比如接口暴漏、数据库数据读取、配置文件加载等等。</li><li>在方法 invokeInitMethods 中，主要分为两块来执行实现了 InitializingBean 接口的操作，处理 afterPropertiesSet 方法。另外一个是判断配置信息 init-method 是否存在，执行反射调用 initMethod.invoke(bean)。这两种方式都可以在 Bean 对象初始化过程中进行处理加载 Bean 对象中的初始化操作，让使用者可以额外新增加自己想要的动作。先执行接口方式，再执行配置方式，通过反射避免重复执行同名方法</li><li>方法destory跟上面的invokeinitMethods差不多，都是先实现接口，然后<em>配置信息 destroy-method {判断是为了避免二次执行销毁}</em></li></ul><p>虚拟机关闭钩子：</p><ul><li>首先我们需要在 ConfigurableApplicationContext 接口中定义注册虚拟机钩子的方法 <code>registerShutdownHook</code> 和手动执行关闭的方法 <code>close</code>。</li><li>在抽象实现类里面进行实现，注册JVM关闭构造的时候，是Runtime.getRuntime().addShutdownHook</li></ul><p>1.<strong>初始化方法和构造函数的区别？</strong></p><p>主要的区别在于执行的实际和功能定位，构造函数执行的时候，依赖注入还没完成，无法进行初始化</p><p>初始化方法执行的时候，所有属性已经完成。可以使用依赖对象进行初始化。比如建立数据库连接池，缓存预热，注册到注册中心</p><p>然后构造函数主要用于对象创建、基本属性设置，初始化方法主要使用依赖就绪后的业务初始化</p><p>2.<strong>为什么需要销毁方法？不能依赖GC吗</strong></p><p>GC只能回收内存，不能处理资源的释放</p><p>比如，socket,http连接，文件流，数据库连接等。比如线程池，定时器。还有注册中心，Mbean</p><p>3.<strong>Spring中哪些组件使用了初始化/销毁机制？</strong></p><p><strong>几乎所有核心组件都有应用</strong>，比如数据源组件，初始化连接池，销毁连接池</p><p>缓存组件，初始化缓存预热，关闭redis连接</p><p><strong>消息队列</strong>，启动监听消息队列，停止监听关闭消息队列</p><p>4.<strong>如何保证初始化方法的执行顺序？</strong></p><p>使用*@DependsOn*注解，就是一个前置条件，<em>确保configService和cacheService先初始化</em></p><p><strong>@Order注解配合ApplicationListener</strong>，数字越小，约先执行。</p><p><em>实现Ordered接口</em>，然后确定高优先级的初始化</p><p>5.<strong>如何处理初始化方法的异常？</strong></p><ol><li><strong>快速失败</strong>：关键资源初始化失败时立即抛异常</li><li><strong>优雅降级</strong>：非关键失败时使用备用方案</li><li><strong>延迟重试</strong>：网络等临时性失败可以重试</li></ol><h2 id="Aware">Aware</h2><p>Aware是Spring提供的一种<strong>容器感知机制</strong>，让Bean能够获取Spring容器中的各种资源和服务。它是一个<strong>标记接口</strong>，通过实现不同的Aware子接口，Bean可以感知到：</p><ul><li>BeanFactory</li><li>ApplicationContext</li><li>ClassLoader</li><li>Bean名称</li><li>以及其他容器资源</li></ul><p>继承 Aware 的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware</p><p>在具体的接口实现过程中你可以看到，一部分(<em>BeanFactoryAware、BeanClassLoaderAware、BeanNameAware</em>)在 factory 的 support 文件夹下，另外 ApplicationContextAware 是在 context 的 support 中，这是因为不同的内容获取需要在不同的包下提供。所以，在 AbstractApplicationContext 的具体实现中会用到向 beanFactory 添加 BeanPostProcessor 内容的 <code>ApplicationContextAwareProcessor</code> 操作，最后由 AbstractAutowireCapableBeanFactory 创建 createBean 时处理相应的调用操作。</p><p>Aware接口</p><ul><li><p>在 Spring 中有特别多类似这样的标记接口的设计方式，它们的存在就像是一种标签一样，可以方便统一摘取出属于此类接口的实现类，通常会有 instanceof 一起判断使用。</p></li><li><p><strong>标记模式</strong>：类似于<code>Serializable</code>接口，用于标识具有某种特性的类</p></li><li><p><strong>instanceof判断</strong>：通过<code>bean instanceof Aware</code>统一识别和处理</p></li><li><p><strong>统一管理</strong>：将所有感知接口归类到一个体系下</p></li></ul><p>四大核心感知接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 感知BeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 感知ClassLoader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanClassLoaderAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 感知Bean名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 感知ApplicationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用感知：</p><ul><li><p>首先在 initializeBean 中，通过判断 <code>bean instanceof Aware</code>，调用了三个接口方法，<code>BeanFactoryAware.setBeanFactory(this)</code>、<code>BeanClassLoaderAware.setBeanClassLoader(getBeanClassLoader())</code>、<code>BeanNameAware.setBeanName(beanName)</code>，这样就能通知到已经实现了此接口的类。</p></li><li><p>另外我们还向 BeanPostProcessor 中添加了 <code>ApplicationContextAwareProcessor</code>，此时在这个方法中也会被调用到具体的类实现，得到一个 ApplicationContex 属性。</p></li><li><p>确保Bean获得感知能力后再进行业务初始化</p></li></ul><p><strong>ApplicationContext</strong>比较特殊他要单独去执行在refresh方法中进行，ApplicationContext在<code>AbstractAutowireCapableBeanFactory</code>中不可直接获取，需要在容器启动时注册专门的处理器，体现了<strong>分层架构</strong>的设计思想。ApplicationContextAwareProcessor在ApplicationContext，其他的他们在<em>BeanFactory层</em> 。</p><p>实现：</p><ol><li>在ApplicationContext层创建<code>ApplicationContextAwareProcessor</code></li><li>将processor注册到BeanFactory中</li><li>利用BeanPostProcessor机制在Bean初始化时注入ApplicationContext</li></ol><p>题目：</p><p>1.<strong>Aware接口的作用是什么？</strong></p><p><strong>Aware接口提供了Bean获取Spring容器资源的标准机制：</strong></p><ol><li><strong>容器感知</strong>：让Bean能够感知到Spring容器的存在</li><li><strong>资源获取</strong>：提供获取容器内部资源的标准方式</li><li><strong>扩展能力</strong>：为开发中间件和框架提供扩展点</li><li><strong>解耦设计</strong>：通过接口回调而非静态方法获取资源</li></ol><p>比如setApplicationContext方法，可以获取容器中的其他的bean，发布应用事件，可以获取环境配置</p><p>setBeanFactory方法，可以动态获取bean，检查bean是不是存在</p><p>2.<strong>不同Aware接口的执行顺序是什么？</strong></p><p>\1. BeanNameAware.setBeanName()</p><p>\2. BeanClassLoaderAware.setBeanClassLoader()</p><p>\3. BeanFactoryAware.setBeanFactory()</p><p>\4. EnvironmentAware.setEnvironment() (如果实现)</p><p>\5. EmbeddedValueResolverAware.setEmbeddedValueResolver() (如果实现)</p><p>\6. ResourceLoaderAware.setResourceLoader() (如果在ApplicationContext中)</p><p>\7. ApplicationEventPublisherAware.setApplicationEventPublisher() (如果在ApplicationContext中)</p><p>\8. MessageSourceAware.setMessageSource() (如果在ApplicationContext中)</p><p>\9. ApplicationContextAware.setApplicationContext() (如果在ApplicationContext中)</p><ul><li><strong>Bean自身信息</strong>先设置（Name、ClassLoader、Factory）</li><li><strong>容器环境信息</strong>后设置（Context、Environment等）</li><li><strong>应用层面信息</strong>最后设置（Event、Message等）</li><li>最后是我们的context</li></ul><p>3.<strong>Aware机制与@Autowired的区别？</strong></p><table><thead><tr><th>对比维度</th><th>Aware接口</th><th>@Autowired</th></tr></thead><tbody><tr><td><strong>注入对象</strong></td><td>Spring容器内部资源</td><td>业务Bean对象</td></tr><tr><td><strong>执行时机</strong></td><td>Bean初始化阶段</td><td>属性注入阶段</td></tr><tr><td><strong>耦合度</strong></td><td>与Spring框架耦合</td><td>相对解耦</td></tr><tr><td><strong>使用场景</strong></td><td>框架扩展、中间件开发</td><td>业务依赖注入</td></tr><tr><td><strong>灵活性</strong></td><td>可以获取容器的动态能力</td><td>静态依赖关系</td></tr></tbody></table><h2 id="FactoryBean-Bean的作用域">FactoryBean&amp;Bean的作用域</h2><p>FactoryBean是Spring提供的一种<strong>创建复杂Bean对象的工厂接口</strong>，它允许我们自定义Bean的创建逻辑，特别适用于：</p><ul><li><strong>代理对象创建</strong>（如MyBatis的Mapper代理）</li><li><strong>复杂对象初始化</strong>（需要多步骤构建的对象）</li><li><strong>第三方框架集成</strong>（将外部框架的对象纳入Spring管理）</li></ul><p><strong>Bean作用域（Scope）机制</strong></p><p>Spring支持多种Bean作用域：</p><ul><li><strong>singleton</strong>：单例模式（默认），容器中只有一个实例</li><li><strong>prototype</strong>：原型模式，每次获取都创建新实例</li><li><strong>request/session/application</strong>：Web环境中的作用域</li></ul><p>单例模式和原型模式的区别就在于是否存放到内存中，如果是原型模式那么就不会存放到内存中，每次获取都重新创建对象</p><p>这就是我们常说的五大作用域</p><p>FactoryBean设计：获取对象、对象类型，以及是否是单例对象</p><p>比如我们的<strong>MyBatis Mapper代理创建</strong>就是我们自定义的一个FactoryBean， 使用 <code>MapperFactoryBean</code> 将<strong>接口注册为代理对象</strong>，启动时会把接口方法解析成 <code>MappedStatement</code> 存入 Configuration 中，运行时由 <code>MapperProxy</code> 通过反射动态执行 SQL。</p><p>还有数据源代理等等。</p><p>作用域就是我们定义在BeanDefinition中的一个常量，然后我们通过指定scpore字段来定义</p><p>然后xml解析回去xml里获取作用域，然后设置beandefinition的信息</p><p>1.<strong>FactoryBean和BeanFactory的区别？</strong></p><table><thead><tr><th>对比维度</th><th>BeanFactory</th><th>FactoryBean</th></tr></thead><tbody><tr><td><strong>性质</strong></td><td>Spring容器的根接口</td><td>用户可实现的工厂接口</td></tr><tr><td><strong>作用</strong></td><td>管理Bean的生命周期</td><td>创建复杂的Bean对象</td></tr><tr><td><strong>使用者</strong></td><td>Spring框架内部使用</td><td>开发者实现和使用</td></tr><tr><td><strong>获取方式</strong></td><td>通过ApplicationContext</td><td>通过getBean()获取其产品</td></tr></tbody></table><p>2.<strong>如何获取FactoryBean本身而不是它创建的对象</strong></p><p>使用&amp;的前缀符表示我们需要的是FactoryBean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyFactoryBean factoryBean = (MyFactoryBean) applicationContext.getBean(&quot;&amp;myFactoryBean&quot;);</span><br></pre></td></tr></table></figure><p>然后内部处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;&amp;&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 去掉&amp;前缀，获取FactoryBean本身</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryBeanName</span> <span class="operator">=</span> name.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getFactoryBean(factoryBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常获取FactoryBean创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> getObjectForBeanInstance(getSingleton(name), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.<strong>FactoryBean在什么场景下使用？</strong></p><p>代理对象的创建，<strong>复杂对象初始化</strong>， <strong>第三方框架集成</strong>（比如redis中设置redis的运行的参数和序列化方式）</p><p>4.<strong>FactoryBean的生命周期是怎样的？</strong></p><p><strong>FactoryBean有双重生命周期</strong>，一个是他本身的生命周期，一个是他产品对象的生命周期</p><h2 id="事件">事件</h2><p>Event机制</p><p>在复杂的业务系统中，直接调用会导致<strong>紧耦合</strong>问题：</p><ul><li><strong>用户注册</strong> → 直接调用发送邮件、赠送积分、风控检查等服务</li><li><strong>订单支付</strong> → 直接调用库存扣减、物流发货、积分计算等服务</li><li><strong>文章发布</strong> → 直接调用消息推送、索引更新、缓存刷新等服务</li></ul><p>这种方式会导致：</p><ol><li><strong>代码耦合度高</strong>：核心业务逻辑与辅助功能混杂</li><li><strong>扩展性差</strong>：新增功能需要修改核心代码</li><li><strong>维护困难</strong>：一个环节出错影响整个流程</li><li><strong>性能问题</strong>：同步执行所有操作，响应慢</li></ol><p>我们可以通过观察者模式进行解耦</p><p>用户注册成功 → 发布UserRegisteredEvent → 多个监听器异步处理</p><p>├── EmailListener: 发送欢迎邮件</p><p>├── CouponListener: 赠送新人礼包</p><p>├── RiskListener: 风控分析</p><p>└── StatisticsListener: 数据统计</p><p>spring event</p><p>定义出事件类、事件监听、事件发布 事件广播器</p><p>applicationevent-&gt;applicationlistener-&gt;applicationeventpublisher-&gt;applicaitoneventmulticaster</p><p>我们事件类是构建一个基本的抽象类，然后其他的具体事件继承这个抽象类</p><p>事件广播器定义了添加监听和删除监听的方法，和添加广播的方法。<code>multicastEvent</code> 最终推送时间消息也会经过这个接口方法来处理谁该接收事件。</p><p>那我们怎么处理事件广播的并发处理呢？</p><ul><li><strong>监听器隔离</strong>：一个监听器异常不影响其他监听器</li><li><strong>异步执行</strong>：可配置同步或异步处理</li><li><strong>顺序控制</strong>：支持监听器执行顺序</li></ul><p>然后我们怎么去确定某个事件如何被监听器处理？我们使用泛型参数匹配来实现</p><p>我们先去获取监听的class，然后如果存在GCLIB代理的话，我们处理CGLIB代理。spring中Bean可能被代理，需要获取真实类型，就是他的父类。</p><p>然后获取泛型接口，提取泛型参数，获取事件的类型。</p><p>然后判断事件是否匹配，就是判断ParameterizedType 和eventClassName是不是子类和父类的关系</p><p>事件发布器，初始化事件发布者(initApplicationEventMulticaster)，</p><ul><li><p>主要用于实例化一个 SimpleApplicationEventMulticaster，这是一个事件广播器。</p></li><li><p>注册事件监听器(registerListeners)，通过 getBeansOfType 方法获取到所有从 spring.xml 中加载到的事件配置 Bean 对象。</p></li><li><p>发布容器刷新完成事件(finishRefresh)，发布了第一个服务器启动完成后的事件，这个事件通过 publishEvent 发布出去，其实也就是调用了 applicationEventMulticaster.multicastEvent(event); 方法。</p></li></ul><p>问题</p><p>1.spring event事件执行的流程：</p><ol><li><strong>事件定义</strong>：继承<code>ApplicationEvent</code>创建事件类</li><li><strong>监听器注册</strong>：实现<code>ApplicationListener</code>并注册到容器</li><li><strong>事件发布</strong>：通过<code>ApplicationEventPublisher.publishEvent()</code>发布</li><li><strong>事件广播</strong>：<code>ApplicationEventMulticaster</code>接收事件</li><li><strong>监听器匹配</strong>：根据泛型参数匹配感兴趣的监听器</li><li><strong>事件处理</strong>：调用匹配监听器的<code>onApplicationEvent()</code>方法</li></ol><p>2.<strong>如何保证Event处理的事务一致性？</strong></p><p>使用事件同步机制，事务提交后执行事务监听器，发送邮件通知等，然后事务回滚的时候发送清理操作</p><p>通过@TransactionalEventListener的状态来确定</p><p>然后失败之后通过补偿机制。</p><h2 id="动态代理">动态代理</h2><p>动态代理是我们spring的AOP的</p><p>AOP主要就是解耦，他将跟核心业务没关系的业务比如权限，日志等业务的抽离出来，一般都是以注释的形式。然后方法只执行业务核心方法</p><p>动态代理分为JDK动态代理和CGLIB动态代理</p><p>JDK动态代理基于接口，代理实现了接口的类，在运行时动态生成代理类的字节码。速度较快，不需要生成新的字节码</p><p>JdkDynamicAopProxy实现了AopProxy, InvocationHandler</p><p>获取代理方式，获取当前线程的context类加载器，然后通知通知添加目标接口。然后执行<em>InvocationHandler实现</em></p><p>然后使用Invoke方法，执行代理。检查方法是不是匹配切点表达式，匹配成功后执行方法拦截器，拦截，然后换取我们自己实现的bean。如果不匹配的话，我们就执行原来的方法</p><p>CGLIB动态是基于继承目标类生成子类代理，使用了使用ASM字节码技术。除了final都可以代理，速度较慢，需要生成字节码。但是性能较好</p><p>get方法是通过设置我们的需要代理的类，然后设置接口，设置回调处理器</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring/">spring</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试总结</title>
      <link>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;面试题目类型&lt;/h1&gt;
&lt;h2 id=&quot;双指针&quot;&gt;双指针&lt;/h2&gt;
&lt;h2 id=&quot;二叉树&quot;&gt;二叉树&lt;/h2&gt;
&lt;h2 id=&quot;链表&quot;&gt;链表&lt;/h2&gt;
&lt;h2 id=&quot;滑动窗口&quot;&gt;滑动窗口&lt;/h2&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>面试题目类型</h1><h2 id="双指针">双指针</h2><h2 id="二叉树">二叉树</h2><h2 id="链表">链表</h2><h2 id="滑动窗口">滑动窗口</h2><h2 id="堆-栈">堆&amp;栈</h2><h1>回溯</h1><p>所有回溯问题，都可以抽象成在一个“决策树”上进行深度优先搜索（DFS）的过程。这个过程包含三个关键部分：</p><ol><li><strong>路径（Path）</strong>：已经做出的选择。在全排列问题中，就是当前已经选了哪几个数字，构成了一个不完整的排列。我们通常用一个 <code>List</code> 或 <code>Stack</code> 来记录。</li><li><strong>选择列表（Choices）</strong>：当前可以做的选择。在全排列问题中，就是那些<strong>还没有被选过</strong>的数字。</li><li><strong>结束条件（End Condition）</strong>：当“选择列表”为空，或者说“路径”的长度达到了要求（比如等于原数组长度），就意味着我们走到了决策树的叶子节点，找到了一个完整的解。此时需要把“路径”存入最终结果集。</li></ol><p>比如说一个全排列的问题，抽象出来就是</p><p>我们需要先从选择列表中将其加入到路径之中，然后标记为已选</p><p>继续递归</p><p>下一层递归返回后，为了能去尝试其他的，就将这次的撤销，就是我们说的回溯，然后移除，标记为没有启用</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 基础知识</title>
      <link>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;普通概念&lt;/h1&gt;
&lt;h2 id=&quot;Model&quot;&gt;Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ChatModel&lt;/strong&gt;: 基于&lt;strong&gt;自回归语言模型&lt;/strong&gt;，其核心是 &lt;strong&gt;Transformer</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>普通概念</h1><h2 id="Model">Model</h2><ul><li><strong>ChatModel</strong>: 基于<strong>自回归语言模型</strong>，其核心是 <strong>Transformer Decoder</strong> 架构。它通过“逐字生成”的方式工作：接收一段文本（Prompt），预测下一个最可能的词（Token），然后将新生成的词加入输入，再次预测下一个，如此循环，直到生成完整的回答。这种机制保证了生成文本的上下文连贯性和逻辑性。</li><li><strong>EmbeddingModel</strong>: <code>EmbeddingModel</code>（如text-embedding-ada-002、text2vec-chinese）基于<strong>双向编码器</strong>，其核心是 <strong>Transformer Encoder</strong> 架构。与ChatModel不同，它会同时分析整个输入文本的上下文，然后将文本的深层语义信息<strong>映射</strong>到一个高维、密集的数字向量（Vector）中。在这个向量空间里，语义上相似的文本在空间距离上会更接近。</li></ul><p>EmbeddingModel负责检索阶段：就是我们常说的嵌入模型</p><p>- 将查询和文档转换为向量表示</p><p>- 通过余弦相似度计算相关性</p><p>- 检索最相关的K个文档片段</p><p>ChatModel负责生成阶段：就是我们常用的聊天的那种模型</p><p>- 接收检索到的上下文+用户查询</p><p>- 基于上下文生成回答</p><p>- 保证回答的连贯性和准确性</p><p>那么我们如何选择模型呢？</p><ol><li><p>维度大小：向量的维度。维度越高，通常能编码更丰富的语义信息，但也会增加存储和计算开销。</p><ul><li><strong>示例</strong>：<code>BERT-base</code> 通常是768维，而OpenAI的 <code>text-embedding-ada-002</code> 是1536维。</li></ul></li><li><p>语言支持：模型是否针对特定语言（如中文）进行过优化。对于中文场景，使用专门的中文Embedding模型（如 <code>text2vec-chinese</code>）效果远超通用模型。</p></li><li><p>领域适配：通用模型在开放域表现良好，但在专业领域（如法律、医疗），使用经过该领域数据微调过的模型能显著提升准确性。</p></li><li><p>性能指标：</p><p>检索准确率 (Recall/Precision)：衡量Embedding模型检索到的相关文档的准确度。</p><p>推理延迟 (Latency)：模型处理一次请求所需的时间，直接影响用户体验。</p></li></ol><p>比如我自定义知识库使用的就是Embedding v2 ada</p><p>重排模型:</p><h2 id="VectorStore">VectorStore</h2><p><code>VectorStore</code> 负责存储<code>EmbeddingModel</code>生成的向量，并提供高效的相似度检索能力。</p><table><thead><tr><th>特性</th><th>Redis Vector</th><th>Pinecone</th><th>Weaviate</th></tr></thead><tbody><tr><td><strong>架构</strong></td><td>内存+持久化</td><td>云原生分布式</td><td>图数据库+向量</td></tr><tr><td><strong>索引算法</strong></td><td>HNSW/IVF</td><td>专有优化算法</td><td>HNSW</td></tr><tr><td><strong>存储成本</strong></td><td>中等(内存占用高)</td><td>高(按量计费)</td><td>低(开源版免费)</td></tr><tr><td><strong>检索延迟</strong></td><td>&lt;10ms</td><td>10-50ms</td><td>20-100ms</td></tr><tr><td><strong>扩展性</strong></td><td>水平扩展复杂</td><td>自动扩缩容</td><td>手动扩展</td></tr></tbody></table><ul><li><strong>小规模验证 (&lt;10万文档)</strong>：<strong>Redis Vector</strong> 是绝佳选择。部署简单，延迟极低，与现有Java生态无缝集成。</li><li><strong>中等规模生产 (10万-1000万)</strong>：<strong>Pinecone</strong> 提供完全托管的服务，免去运维烦恼，让你专注于业务逻辑。</li><li><strong>大规模或定制化场景 (&gt;1000万)</strong>：<strong>Weaviate</strong> 的开源和分布式特性提供了极高的灵活性和成本优势，但需要投入运维资源。</li><li><strong>成本敏感场景</strong>：<strong>Weaviate 开源版</strong> 自建部署是理想选择。</li></ul><h2 id="RAG">RAG</h2><p>RAG就是检索增强，是一种让LLM访问外部知识库以回答问题的框架，极大地减少了模型幻觉，提高了回答的准确性。</p><p>我们使用嵌入模型的时候是需要对我们传入的文档进行切分的</p><p>切分策略：</p><p>一般的切分策略就是按照大小进行切分的，一般就是多少个字就切分。这样的话比较简答，但是可能破坏语句的完整性。适用于API，代码等</p><p>还有就是按照语义进行切分，这样就是按照句子边界，标点符号进行切分。这样保证了语句的完整性，但是我们切分的效率比较慢。适用于文章报告等</p><p>我们切分的时候要去按照场景进行选择</p><ul><li><p><strong>检索准确率</strong>：语义切分通常能确保每个Chunk包含完整的答案片段，从而提升准确率。</p></li><li><p><strong>上下文利用率</strong>：合适的Chunk大小可以最大化利用模型的上下文窗口，不多也不少。</p></li><li><p><strong>重叠比例 (Overlap)</strong>：设置一部分重叠内容（如10%）可以防止重要信息在切分边界处丢失。</p><p>在Spring AI中，通常通过实现<code>DocumentTransformer</code>接口来定义切分逻辑。</p></li></ul><hr><p>检索策略：</p><p>密集检索，就是使用模型调用embed方法，然后调用向量库进行密集搜索。这样的话语义理解强，但是对罕见词汇搜索较差</p><p>bm25检索，传统的关键词匹配算法，对罕见词、专业术语友好，但缺乏语义理解。</p><p>混合检索，就待用密集检索和bm25检索，然后分析文档。结合了两种检索，但是复杂度增加了</p><h2 id="上下文构建">上下文构建</h2><p>检索到的文档片段不能直接丢给LLM，需要精心组织成“上下文”（Context），以避免噪声干扰。</p><p>1.如何避免<strong>上下文噪声干扰</strong>？</p><ul><li><strong>重排序 (Reranking)</strong>：使用更轻量、但更精确的模型（如Cross-Encoder）对初步检索到的Top-K结果进行二次排序，将最相关的文档排在最前面。</li><li><strong>上下文压缩 (Context Compression)</strong>：从检索到的文档中提取与用户问题最相关的句子或摘要，丢弃无关信息，减少噪声。</li><li><strong>分层检索 (Hierarchical Retrieval)</strong>：对于结构化的长文档，可以先检索到相关的章节标题，再在章节内部进行精确检索。</li><li><strong>动态上下文长度 (Dynamic Context Length)</strong>：根据问题的复杂度和模型上下文窗口的限制，动态调整送入模型的文档数量。</li></ul><p>在Spring AI中，这些策略通常在调用<code>ChatModel</code>之前，通过自定义逻辑实现。</p><h2 id="Function-Calling">Function Calling</h2><p>函数调用允许LLM将自然语言指令转化为对外部工具（API、数据库查询等）的结构化调用。</p><ul><li><p><strong>参数校验</strong>：这是安全的第一道防线。可以使用<strong>JSON Schema</strong>来定义函数期望的参数格式、类型和范围，在执行前进行严格校验。</p></li><li><p>安全机制</p><ul><li><strong>参数沙箱</strong>：绝不直接将用户输入用于代码执行或数据库查询，进行严格的无害化处理。</li><li><strong>权限控制</strong>：根据用户身份，限制其能调用的函数集合。</li><li><strong>执行隔离/超时</strong>：在独立、受限的环境中执行函数，并设置超时，防止恶意调用消耗系统资源。</li><li><strong>审计日志</strong>：记录所有函数调用，便于追踪和分析。</li></ul></li><li><p><strong>错误处理</strong>：健壮的错误处理至关重要。需要明确处理参数验证失败（<code>ParameterValidationException</code>）、执行超时（<code>ExecutionTimeoutException</code>）、资源超限（<code>ResourceLimitException</code>）等情况，并设计合理的<strong>重试策略</strong>（如使用<code>@Retryable</code>）</p><p>先捕捉ParameterValidationException，参数验证</p><p>再捕捉ExecutionTimeoutException，执行超时</p><p>再捕捉ResourceLimitException，资源限制</p><p>然后再执行重试策略，加上重试注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))</span><br></pre></td></tr></table></figure></li></ul><p>在Spring AI中，你可以定义一个<code>@Bean</code>，通过<code>@Description</code>注解描述其功能，Spring AI会自动将其注册为可供LLM调用的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionParameterValidator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ValidationResult <span class="title function_">validate</span><span class="params">(FunctionCall call)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ValidationResult.builder()</span><br><span class="line">            .typeValidation(validateTypes(call.getParameters()))</span><br><span class="line">            .rangeValidation(validateRanges(call.getParameters()))</span><br><span class="line">            .formatValidation(validateFormats(call.getParameters()))</span><br><span class="line">            .businessValidation(validateBusinessRules(call.getParameters()))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validateTypes</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="comment">// JSON Schema验证</span></span><br><span class="line">        <span class="comment">// 类型强制转换</span></span><br><span class="line">        <span class="comment">// null值处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Agent">Agent</h2><p>Agent是什么，是一个自主决策的智能体</p><p><strong>如何设计多Agent协作的通信机制？</strong></p><p>消息总线模式：</p><p>- 使用Redis/RabbitMQ作为消息中介</p><p>- Agent间异步通信</p><p>- 支持广播和点对点通信</p><p>协调者模式：</p><p>- 中央协调器管理任务分配</p><p>- Agent向协调器汇报状态</p><p>- 协调器负责冲突解决</p><p>契约式协作：</p><p>- 定义Agent间的服务契约</p><p>- 使用OpenAPI规范描述接口</p><p>- 支持版本管理和向后兼容</p><p>状态同步机制：</p><p>- 共享状态存储(Redis Cluster)</p><p>- 乐观锁处理并发冲突</p><p>- 事件溯源记录状态变更</p><p>决策树/状态机实现：</p><ul><li>可以使用<strong>状态机</strong>来定义Agent的行为逻辑。例如，一个Agent的状态可以流转于：<code>IDLE</code> -&gt; <code>PLANNING</code> -&gt; <code>EXECUTING_TOOL</code> -&gt; <code>WAITING_FOR_RESULT</code> -&gt; <code>COMPLETED/ERROR</code>。每个状态转移都由特定的事件触发。这种方式使得Agent的行为清晰、可控、易于调试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentStateMachine</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgentState</span> &#123;</span><br><span class="line">        IDLE, PLANNING, EXECUTING, WAITING_INPUT, COMPLETED, ERROR</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AgentState <span class="title function_">transition</span><span class="params">(AgentState current, AgentEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">            <span class="keyword">case</span> IDLE -&gt; event == START ? PLANNING : IDLE;</span><br><span class="line">            <span class="keyword">case</span> PLANNING -&gt; event == PLAN_READY ? EXECUTING : </span><br><span class="line">                           event == NEED_INPUT ? WAITING_INPUT : PLANNING;</span><br><span class="line">            <span class="keyword">case</span> EXECUTING -&gt; event == SUCCESS ? COMPLETED :</span><br><span class="line">                            event == FAILURE ? ERROR : EXECUTING;</span><br><span class="line">            <span class="keyword">default</span> -&gt; current;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MCP">MCP</h2><p>MCP是一个由Anthropic、OpenAI、Google等行业巨头共同支持的<strong>开放标准</strong>。你可以把它理解为<strong>AI世界的JDBC或JMS</strong>——它旨在标准化AI模型与外部工具、数据源进行交互的方式。</p><ul><li><strong>MCP服务器 (MCP Server)</strong>：任何外部工具、API或数据源（比如你的Spring Boot应用提供的服务）都可以通过实现MCP协议，将自己暴露为一个MCP服务器。它会“宣告”自己能提供哪些能力（如<code>查询订单</code>、<code>读取文件</code>）。</li><li><strong>MCP客户端 (MCP Client)</strong>：AI模型或代理（Agent）作为客户端，可以<strong>发现</strong>并<strong>连接</strong>到这些MCP服务器，使用标准化的请求/响应格式与之交互，而无需关心服务器底层的具体实现。</li></ul><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">传统函数调用 (Function Calling)</th><th style="text-align:left">模型上下文协议 (MCP)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>本质</strong></td><td style="text-align:left"><strong>模型特定的API</strong></td><td style="text-align:left"><strong>开放的、通用的通信协议</strong></td></tr><tr><td style="text-align:left"><strong>耦合度</strong></td><td style="text-align:left">高度耦合（与特定LLM提供商绑定）</td><td style="text-align:left"><strong>松耦合</strong>（与任何支持MCP的LLM兼容）</td></tr><tr><td style="text-align:left"><strong>互操作性</strong></td><td style="text-align:left">弱（切换模型成本高）</td><td style="text-align:left"><strong>强</strong>（工具可被不同模型复用）</td></tr><tr><td style="text-align:left"><strong>生态</strong></td><td style="text-align:left">封闭（各厂商各自为政）</td><td style="text-align:left"><strong>开放</strong>（促进工具和服务的生态系统）</td></tr></tbody></table><p><strong>作为MCP客户端（消费工具）</strong></p><ol><li>在<code>application.yml</code>中配置需要连接的外部MCP服务器的地址。</li><li>Spring AI将提供一个统一的<code>McpTemplate</code>或类似的客户端Bean。</li><li>我们的Agent通过这个<code>McpTemplate</code>来发现并调用外部工具。</li><li><code>McpTemplate</code>会将调用转化为标准的MCP请求，并发送给目标服务器。</li></ol><p>我们如何去导入一个mcp呢在我的项目中？</p><p>如果是内部的，我直接写一个mcp工具即可，实现mcptool接口，继承抽象mcp基类</p><p>外部的我先导入依赖，中添加<code>spring-ai-mistralai-spring-boot-starter</code>依赖</p><p>然后配置mcp服务器，在里面指定mcp的json配置</p><p>然后再spring ai中配置我们chatmodel的apikey</p><p>然后我们就可以使用注册好mcp的chatmodel，来完成使用mcp完成</p><h2 id="Dify">Dify</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>核心能力：</p><ol><li><strong>可视化的提示词编排 (Prompt Studio)</strong>：提供一个图形界面，让开发者可以像填表格一样设计和调试Prompt，管理变量、上下文和模型输出。</li><li><strong>内置的RAG引擎</strong>：允许用户直接上传文档（PDF, TXT, Markdown等），Dify会自动处理数据清洗、分块、向量化和索引，快速构建起一个可供检索的知识库。</li><li><strong>Agent能力</strong>：支持应用集成“工具 (Tools)”，让大模型可以调用外部API（如查询天气、搜索、计算等），完成更复杂的任务，而不仅仅是文本生成。</li><li><strong>统一的API服务</strong>：一旦你在Dify上构建好应用，它会自动生成一套标准的API。你的前端或业务后端可以直接调用这个API，无需关心背后的大模型是哪个、RAG流程如何运作。</li><li><strong>监控与分析</strong>：内置日志和数据分析功能，可以让你监控应用的调用情况、用户反馈、Token消耗等，方便持续运营和优化。</li></ol><p>那么我们怎么构建一个dify，比如n8n工作流</p><p>1.创建新的应用</p><p>2.编排提示词，加入变量</p><p>3.构建RAG知识库，选择嵌入模型</p><p>4.调试程序问题</p><p>5.发布</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 面试题目</title>
      <link>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;model类型面试题目&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>model类型面试题目</h1><h2 id="1-如何实现大模型的连续对话？">1.如何实现大模型的连续对话？</h2><p>所有的大模型本身是不进行信息存储的，也不提供连续对话功能，<strong>所以想要实现连续对话功能需要开发者自己写代码才能实现</strong></p><p>所以呢我们需要将当前用户的提问与<strong>经过管理的对话历史</strong>一同作为输入，提交给模型。</p><p>我们需要维护一个session，</p><p>通常是<code>List&lt;Message&gt;</code>结构。<code>Message</code>对象至少包含两个关键字段：</p><ul><li><code>role</code>: 角色（<code>system</code>、<code>user</code>、<code>assistant</code>）</li><li><code>content</code>: 消息内容</li></ul><p>然后进入交互循环</p><ul><li><strong>用户输入</strong>：接收用户的新消息（<code>user</code> role）。</li><li><strong>上下文构建</strong>：从存储中获取该会话的历史消息列表，并将新消息追加到列表末尾。</li><li><strong>API调用</strong>：将完整的消息列表提交给大模型。</li><li><strong>获取响应</strong>：接收模型的回复（<code>assistant</code> role）。</li><li><strong>上下文持久化</strong>：将模型的回复也追加到历史消息列表中，并更新存储（如Redis、数据库等），为下一次交互做准备。</li></ul><p>在这里面最重要的就是上下文是有窗口限制的，超出模型的Token限制（如4K, 8K, 32K, 128K）。这不仅会导致API调用失败，还会增加成本和响应延迟。</p><p>1.截断策略：</p><ul><li><strong>简单滑动窗口</strong>：只保留最近的 N 轮对话。实现最简单，但会丢失早期的重要信息。</li><li><strong>保留首轮+滑动窗口</strong>：保留系统提示（<code>system</code> prompt）和第一轮对话，然后截取最近的 N-2 轮对话。适用于需要固定初始设定的场景。</li></ul><p>2.摘要策略：</p><ul><li><strong>滚动摘要</strong>：当对话长度达到一定阈值时，使用另一个LLM调用将较早的对话内容进行总结，用这个摘要替换掉原始的多轮对话。</li><li><strong>优点</strong>：保留了长期记忆的精华。</li><li><strong>缺点</strong>：摘要过程会丢失细节，并产生额外的API开销和延迟。</li></ul><p>3.RAG策略：</p><ol><li><strong>存储</strong>：将每一轮完整的对话历史（或其要点）向量化后存入向量数据库 (VectorDB)。</li><li><strong>检索</strong>：当用户提出新问题时，先将问题向量化，然后去向量数据库中检索最相关的 N 条历史对话记录。</li><li><strong>注入</strong>：将这些检索出的、最相关的历史记录，连同当前问题，一起注入到提示词中，提交给大模型。</li></ol><ul><li><ul><li><strong>突破长度限制</strong>：理论上可以维护无限的对话历史。</li><li><strong>高相关性</strong>：只提供与当前问题最相关的上下文，效率高。</li></ul></li><li><strong>挑战</strong>：需要引入向量数据库（如Milvus, Pinecone）和embedding模型，系统复杂度更高。</li></ul><p>这是我们自己需要配置的，但是Spring AI Alibaba 因为内置了连续对话的多种实现,比如mysql,redis</p><p>只需要简单配置就ok，我们注入注入 RedisChatMemoryRepository 对象。</p><p>然后配置 ChatClient 实现连续对话。</p><p>直接调用先prompt，然后advisors,最好call.context发送给模型</p><h2 id="2-AI项目的执行流程">2.AI项目的执行流程</h2><p>我习惯上分为<strong>离线数据处理（Data Preparation）</strong> 和 <strong>在线请求处理（Real-time Inference）</strong></p><p>1.离线数据处理：</p><p>这个阶段的目标是将原始、异构的数据处理成AI模型可以高效检索的结构化知识库。它是一次性的或周期性执行的。</p><ol><li><strong>多源数据抽取 (Extraction)</strong>：<ul><li>首先，需要从多个来源抽取数据，这些数据就是我们常说的“知识”。来源可能包括：<ul><li><strong>结构化数据</strong>：如MySQL, PostgreSQL里的业务数据。</li><li><strong>半结构化数据</strong>：如网页HTML, Markdown文档。</li><li><strong>非结构化数据</strong>：如PDF, Word文档, 纯文本。</li><li><strong>API数据</strong>：通过调用内部或外部API获取的动态信息。</li></ul></li></ul></li><li><strong>数据清洗与分块 (Cleaning &amp; Chunking)</strong>：<ul><li>原始数据是“脏”的，必须清洗。这包括去除无关信息（如HTML标签、广告、页眉页脚）、处理格式错误、统一编码等。</li><li>清洗后，将长文本（如一篇长文档）切分成有意义的、大小适中的“文本块 (Chunks)”。这一步至关重要，因为文本块是后续向量检索的基本单位。分块的好坏直接影响检索质量。</li></ul></li><li><strong>向量化与索引 (Embedding &amp; Indexing)</strong>：<ul><li>这是将文本语言转换为数学语言的核心步骤。</li><li>我们使用一个特定的<strong>Embedding模型</strong>，将每一个“文本块”计算成一个高维向量（Embedding）。这个向量可以被认为是该文本块在语义空间中的“坐标”。</li><li>然后，将这些文本块原文连同它们的向量索引，存入一个或多个<strong>向量数据库</strong>（如Milvus, Pinecone）中。同时，也可能将关键词、元数据等存入传统检索引擎（如Elasticsearch）。</li></ul></li></ol><p>2.在线请求处理：</p><p>这个阶段是用户与系统实时交互的过程，追求低延迟和高精度。</p><ol><li><strong>意图分析 (Intention Analysis)</strong>：<ul><li>请求的入口。当用户输入一句话，系统首先要理解“他想干什么”。</li><li>这不仅仅是关键词识别，更深层次会判断用户意图，例如：是闲聊（Chitchat）？是问答（FAQ）？还是需要执行一个任务（Task-oriented）？</li><li>意图分析的结果会决定后续调用哪些检索路径。比如，闲聊意图可能直接交给大语言模型，而问答意图则会触发后续的召回和排序流程。</li></ul></li><li><strong>多路召回 (Multi-path Recall)</strong>：<ul><li>这是为了“宁可错杀，不可放过”，尽可能多地从不同渠道找回所有相关的候选答案。各路召回并行执行，以保证效率。</li><li><strong>向量召回（语义召回）</strong>：将用户的查询也进行向量化，然后去向量数据库里进行相似度检索，找出语义上最接近的N个文本块。这是您提到的“向量检索”的应用环节。</li><li><strong>关键词召回（词法召回）</strong>：使用传统搜索引擎（如Elasticsearch）根据关键词匹配，找出包含查询词的文本块。这能弥补向量召回在精确匹配上的不足。</li><li><strong>其他召回</strong>：还可能包括基于知识图谱的召回、基于数据库精确查询的召回等。</li></ul></li><li><strong>混合排序 (Hybrid Ranking/Re-ranking)</strong>：<ul><li>多路召回会返回大量候选结果，质量良莠不齐，甚至有重复。排序阶段就是优中选优的过程。</li><li><strong>粗排 (Coarse Ranking)</strong>：首先，通过一些简单的规则和模型，对召回的上百个结果进行快速排序和去重，筛选出Top K（比如Top 50）个候选结果。</li><li><strong>精排 (Fine-grained Ranking / Re-ranking)</strong>：然后，使用一个更复杂、更强大的排序模型（通常是Cross-Encoder或专门的排序大模型），对这Top K个结果进行精准打分。这个模型会综合考虑查询与候选答案的语义相关性、业务重要性、时效性等多种特征，给出最终的、最合理的排序。</li></ul></li><li><strong>答案生成与整合 (Answer Generation &amp; Synthesis)</strong>：<ul><li>最后，系统会将排序最高的一个或几个结果，作为核心上下文，连同用户的原始问题，一起组织成一个精炼的提示词（Prompt）。</li><li>将这个Prompt提交给一个强大的生成式大语言模型（如GPT-4），由它基于给定的上下文，生成最终的、通顺自然的回答，并呈现给用户。</li></ul></li></ol><h2 id="3-Dify是什么？怎么使用？">3.Dify是什么？怎么使用？</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>1.为什么选择Dify?</p><ul><li><strong>从效率和速度角度看：</strong> 对于需要快速验证原型（MVP）或业务逻辑不那么极端的项目，我会首选Dify。因为它将RAG、多模型支持、API封装等通用能力产品化了，可以让我们在几天甚至几小时内就搭建起一个可用的AI应用，极大地缩短了Time-to-Market（产品上市时间）。</li><li><strong>从维护成本角度看：</strong> Dify提供了一个完整的后台管理界面，包括日志、监控和用户反馈。这意味着运营人员或产品经理也可以参与到应用的优化中来，例如更新知识库、标注数据等。如果自研，这部分工作都需要开发人员投入精力去构建和维护，长期成本更高。</li><li><strong>对于自定义和灵活性：</strong> 当然，如果项目需求非常特殊，比如需要一个高度定制化的RAG策略（例如复杂的混合检索和重排逻辑），或者对系统性能有极致要求，那么基于LangChain或LlamaIndex自研会提供更高的灵活性和控制力。</li></ul><p>2.Dify的Agent和Tool（工具）能力是如何工作的？它与传统的API调用有什么不同？</p><p>Dify的Agent和Tool能力，是实现<strong>Language Model as a Reasoning Engine（将语言模型作为推理引擎）<strong>的关键。它和传统API调用的核心区别在于</strong>‘决策者’不同</strong>。</p><ul><li><strong>传统API调用</strong>：是我们开发者在代码里<strong>提前写好逻辑</strong>。比如，<code>if</code>用户想查天气，<code>then</code>调用天气API。这个决策逻辑是<strong>由人预先编码</strong>的。</li><li><strong>Dify中的Agent/Tool工作流</strong>:</li></ul><ol><li><strong>工具注册</strong>：我们首先向Dify注册一个或多个工具，比如“天气查询API”、“计算器API”。关键在于，我们需要用自然语言<strong>向模型清晰地描述这个工具是做什么的、需要哪些参数</strong>（比如，天气查询API需要一个<code>city</code>参数）。</li><li><strong>模型决策 (Reasoning)</strong>：当用户提出一个模糊的需求，比如“帮我查查明天北京会不会下雨，适合穿什么？”，Agent接收到请求后，大模型会进行“思考”。</li><li><strong>工具选择与调用</strong>：模型会分析用户的意图，并根据我们提供的工具描述，<strong>自主决定</strong>需要使用“天气查询API”。然后，它会从用户问题中<strong>提取出参数</strong><code>city: &quot;北京&quot;</code>，并生成一个调用该API的请求。</li><li><strong>结果整合与响应</strong>：模型获取到API返回的天气数据后（比如“晴天”），会将其作为新的信息，结合它自己的知识（晴天适合穿什么），最终生成一段通顺的、完整的回答给用户。</li></ol><p>Dify的Agent模式，把**‘决定调用哪个API’以及‘如何组织参数’的权力，从开发者交给了大模型**，实现了更高层次的自动化和智能化。”</p><p>3.如果让你来设计一个类似Dify的平台，你会如何规划它的技术架构？</p><p>设计一个类似Dify的平台，我会将其拆分为几个核心模块，并采用微服务的思想来构建，确保可扩展性和可维护性</p><ol><li><strong>前端 (Frontend)</strong>：<ul><li>使用React或Vue等现代前端框架，负责提供所有可视化的操作界面，包括应用管理、Prompt Studio、知识库上传和运营后台等。</li></ul></li><li><strong>API网关 (API Gateway)</strong>：<ul><li>作为所有服务的统一入口，处理用户认证、请求路由、速率限制等。这是外部应用（比如用户的前端）与我们平台交互的门户。</li></ul></li><li><strong>应用编排服务 (Orchestration Service)</strong>：<ul><li>这是平台的大脑。它负责解释在Studio中保存的应用配置。当一个API请求进来时，这个服务会根据应用定义，决定是走简单的LLM对话流程，还是需要执行RAG或Agent流程。它会编排并调用下游的各个服务。</li></ul></li><li><strong>模型管理服务 (Model Management Service)</strong>：<ul><li>用于统一管理和对接不同的大模型提供商（OpenAI, Anthropic, Google Gemini, 以及开源模型）。它会封装好各家API的差异，对上层提供一个统一的调用接口。</li></ul></li><li><strong>RAG服务 (RAG Service)</strong>：<ul><li>这是一个独立的模块，负责知识库的全生命周期管理。</li><li><strong>写入路径</strong>：接收文档 -&gt; 文本解析 -&gt; 分块 (Chunking) -&gt; 调用Embedding模型 -&gt; 存入向量数据库。</li><li><strong>读取路径</strong>：接收查询 -&gt; 向量化 -&gt; 在向量数据库中进行相似性搜索 -&gt; 返回相关文本块。</li><li><strong>技术选型</strong>：会用到向量数据库（如Milvus/Weaviate）和Embedding模型。</li></ul></li><li><strong>日志与监控服务 (Logging &amp; Monitoring Service)</strong>：<ul><li>专门收集所有API调用的日志、Token消耗、用户反馈等数据。</li><li>将数据存入专门的数据库（如ClickHouse或Elasticsearch），并提供数据可视化界面，用于运营分析和应用优化。</li></ul></li></ol><h2 id="4-那么怎么区分使用简单模型还是使用agent呢？">4.那么怎么区分使用简单模型还是使用agent呢？</h2><p>可以使用前置规则与关键词匹配 ，比如系统会维护一个“触发词”列表。当用户的输入包含这些特定的动词或名词时，系统会<strong>绕过复杂的判断</strong>，直接将其路由到Agent流程。</p><p>或者是利用大语言模型进行意图分类 ，我们设计一个专门用于“路由”的<strong>元提示 (Meta-Prompt)</strong>。这个Prompt会包含以下内容：</p><ol><li><strong>用户的原始问题</strong>。</li><li><strong>一个“选项列表”</strong>，这个列表描述了所有可用的“路径”。每个路径就是一个Agent或工具，外加一个“默认闲聊”的选项。</li><li><strong>一个明确的指令</strong>，要求LLM根据用户问题，从列表中选择一个最合适的路径。</li></ol><p>非常智能和灵活，能理解深层语义。这是目前最主流和最有效的方法。现代LLM的“Function Calling”或“Tool Use”功能，本质上就是这种机制的高度优化和内置实现。</p><p>或者是结合上下文进行动态判断，系统在做意图判断时，不仅考虑当前这一句，还会<strong>附加上下文（最近的几轮对话历史）</strong>。</p><p>我在这个项目中主要用的是，<strong>分层漏斗模型</strong></p><ol><li><strong>首先，通过一个‘快速通道’进行前置判断</strong>。我们会用关键词和规则匹配，快速识别出那些意图非常明确的请求，比如包含‘查询’、‘计算’、‘预订’等词语的指令，直接将它们路由给相应的Agent。这能覆盖掉一部分简单明确的任务，且成本最低。</li><li><strong>其次，对于无法被快速通道处理的请求，我们会启用一个‘智能路由’层</strong>。这一层的核心是利用大语言模型自身的理解能力。我们会设计一个专门的‘路由Prompt’，把用户的请求和所有可用的‘工具’（Agents）以及一个‘闲聊’选项一起发给LLM，让模型来判断用户最可能的意图是什么。比如，模型需要从‘查询天气’、‘检查订单’和‘普通聊天’这几个选项里做出选择。这是目前最主流也最可靠的方式。</li><li><strong>最后，在多轮对话中，我们会引入上下文进行动态判断</strong>。用户的意图可能不会在第一句话就完全暴露。因此，在做意图识别时，系统会结合最近的对话历史。比如用户先说了‘我想去北京’，接着问‘那边天气如何？’，系统就能结合上下文，准确地将这个模糊的问题路由到‘天气查询Agent’。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BUG收集</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;配置bug&lt;/h1&gt;
&lt;h2 id=&quot;MyBatis-bug&quot;&gt;&lt;strong&gt;MyBatis bug&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;[x] factoryBeanObjectType的兼容性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring Boot 在</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>配置bug</h1><h2 id="MyBatis-bug"><strong>MyBatis bug</strong></h2><ul><li>[x] factoryBeanObjectType的兼容性问题</li></ul><p>Spring Boot 在 3.2 版本中更新了 <code>FactoryBeanRegistrySupport#getTypeForFactoryBeanFromAttributes</code> 方法，它要求 <code>factoryBeanObjectType</code> 必须是 <code>Class&lt;?&gt;</code> 或 <code>ResolvableType</code>，绝不接受 <code>String</code></p><p>旧版本的 MyBatis-Spring 在 <code>ClassPathMapperScanner.processBeanDefinitions()</code> 中将 <code>beanClassName</code>（一个 <code>String</code>）赋给了 <code>factoryBeanObjectType</code></p><p>slove:</p><p>我们使用MyBatis-Plus starter3.5.5。然后现在基本都要升级成springboot3，因为springaialibaba等框架也是需要3的</p><p>然后我们分模块的时候，为了避免@MapperScan重复扫描，我们只在业务模块进行mybatisplus的导入，然后common模块就只导入一个annotion。不到人core</p><p>防止出现重复扫描的问题。</p><h1>nacos配置bug</h1><ul><li>[x] 缺少NacosShutdownHook，然后导致nacos-clint无法运行，添加nacos钩子然后让其更美观的关闭</li></ul><p>关闭通知中心，然后强制关闭所有的后台线程</p><p>reason:</p><p>Spring 会先销毁 Bean，然后执行注册的 <code>ShutdownHook</code>，如果 Nacos 没有注册自己的钩子，那它的后台线程就会存活到 JVM 强制退出。</p><p>Nacos 客户端（<code>nacos-client</code>）在正常退出时会通过 <code>ShutdownHook</code> 释放 HttpClient、长连接、定时任务等资源。<br>如果没有这个钩子，<code>DefaultHttpClientFactory</code> 之类的类无法加载或初始化不完整，就会出现 <code>NoClassDefFoundError</code>，或者后台线程挂起不退出。</p><p>slove:</p><p>所以我们需要在应用的时候手动注册一个nacos的关闭的钩子，通知中心 → 释放 HttpClient → 停止定时任务</p><p>然后为了防止还有存活，再强制关闭所有的后台线程</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/BUG/">BUG</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>开源项目经历</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/kaiyuan/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/kaiyuan/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;strong&gt;issue计划已同步到飞书管理，此文档暂时作废&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;Github&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><strong>issue计划已同步到飞书管理，此文档暂时作废</strong></p><h1>Github</h1><h2 id="close">close</h2><ol><li></li></ol><p>2025.7.15晚上十点，提交了我人生中的第一个PR，</p><p>是阿里巴巴的<a href="https://github.com/alibaba/fastjson2/%E9%A1%B9%E7%9B%AE%E3%80%82">https://github.com/alibaba/fastjson2/项目。</a></p><p>看到一个issue没有人哈哈，我直接在vscode跑了一下，然后发现是</p><p>在 Android 10 的系统中，<br>com.alibaba.fastjson2.util.IOUtils.isNULL(IOUtils.java:2)<br>会产生一个 native 侧的 crash，Signal 7(SIGBUS), Code 1(BUS_ADRALN)出现了问题</p><p>我发现是内存对齐问题: 在 Android 10 ARM 架构上，IOUtils.getLongUnaligned(char[] buf, int offset) 方法直接使用 UNSAFE.getLong() 访问 char 数组内存，ARM 处理器要求 8 字节 long 读取必须在 8 字节对齐的地址上进行，当计算出的内存地址 ARRAY_CHAR_BASE_OFFSET + ((long) offset &lt;&lt; 1) 不是 8 字节对齐时，触发 Signal 7(SIGBUS), Code 1(BUS_ADRALN) 崩溃<br>我已经提交PRhttps://github.com/<a href="https://github.com/alibaba/fastjson2/pull/3639">/pull/3639</a></p><p>然后直接进行测试，测试的三个类全部通过。overall</p><p>看看对不对，能不能给我合并了吧哈哈，好了睡觉舒服了，该PR已经解决</p><p>然后后来根据我的代码发布了一个快照，然后我测试完之后发现成功！他采纳了我的建议</p><h2 id="open">open</h2><ol><li></li></ol><p>2025.7.16八点左右</p><p>提交了我的第三个PR，是rocketMQ的。也是到知名中间件的issue了哈哈</p><p>这个问题是一个时序问题，一个topic被创建的时候，队列为null,最大偏移量为0<br>然后生产者发送第一条消息的时候，最大偏移量为1。<br>消费者启动的时候，查询最大偏移量为-1，然后调用maxoffset(mq),就会返回1.这样我们为0的消息就被跳过了。<br>可以在发送消息前，可以先启动 Consumer 实例，或者在 Consumer 启动后等待一段时间再发送消息。<br>然后在配置的时候，设置从ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET开始消费。<br>也可以在代码方面更改再前面加一层校验，如果maxoffset&lt;=1的话，就返回0L</p><p>然后else就返回maxoffset</p><p>maxoffset=this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</p><p><a href="https://github.com/apache/rocketmq/pull/9552">https://github.com/apache/rocketmq/pull/9552</a></p><p>然后发现这个issue很久没解决了哈哈，看看我的能不能被通过吧</p><h2 id="merged">merged</h2><ol><li></li></ol><p>2025.7.16中午头，提交了我的第二个PR</p><p>这个PR是<a href="https://github.com/alibaba/spring-ai-alibaba/">https://github.com/alibaba/spring-ai-alibaba/</a> 仓库的， <a href="https://github.com/alibaba/spring-ai-alibaba/pull/1645">https://github.com/alibaba/spring-ai-alibaba/pull/1645</a></p><p>是解决了一个人的issue，node枚举字段里面没有template-transform他非要调用，肯定是失败的啊</p><p>然后我就在枚举类里添加了template-transform节点，然后写了一个NodeData类和一个NodeDataConverter类</p><p>NodeData就设置一下setter和getter，然后Conventer就是一个<strong>模板转换节点数据转换器</strong> 的 Java 类，属于阿里云 AI 服务中工作流 DSL 处理模块</p><p>实现了实现了<code>TemplateTransformNodeDataConverter</code>转换器类</p><ul><li>继承抽象Converter类</li><li><strong>DIFY方言</strong>: 完整的解析和导出逻辑</li><li><strong>CUSTOM方言</strong>: 使用默认自定义方言转换器</li><li><strong>输入处理</strong>: 变量选择器解析</li><li><strong>输出管理</strong>: 固定string类型结果</li><li><strong>变量命名</strong>: <code>templateTransformNode&#123;count&#125;</code>格式</li><li><strong>后处理</strong>: 自动设置输出键名</li></ul><p>然后添加其node节点的具体实现， 实现了完整的模板转换功能:</p><ul><li><strong>占位符模式</strong>: 支持<code>&#123;&#123;key&#125;&#125;</code>语法</li><li><strong>正则引擎</strong>: 使用<code>\\&#123;\\&#123;\\s*(.+?)\\s*\\&#125;\\&#125;</code>匹配</li><li><strong>高效处理</strong>: StringBuffer + Matcher进行字符串替换</li><li><strong>安全机制</strong>: 自动转义特殊字符防止正则注入</li><li><strong>容错设计</strong>: 缺失变量时保留原占位符，不中断执行</li><li><strong>状态管理</strong>: 正确使用<code>state.data().containsKey(key)</code>检查变量存在性</li></ul><p>在代码生成层实现了nodesection</p><ul><li>实现了<code>TemplateTransformNodeSection</code>代码生成器</li><li>完整的Builder模式实现，支持流式配置</li><li>提供了完善的错误处理和SLF4J日志记录</li></ul><p>然后通过了他的CI测试，其中代码格转为spring的格式和头信息,java格式化卡了我一点时间，没注意格式的问题。</p><p>然后通过全部的lint测试</p><ol start="2"><li></li></ol><p>2025.7.22完事八点，继续干spring ai alibaba</p><p>这次主要是修复了一个空指针异常，DashScope API返回数据质量问题，ToolCall对象的function.name字段为null。在buildGeneration方法中，Toolcall对象的时候，这里如果toolCall.function().name()返回null，就会导致后续Spring AI框架在DefaultToolCallingManager.executeToolCall中执行toolName.equals()(时出现NPE。导致streaming 和 non-streaming 聊天调用都受影响。可以添加null过滤器，然后记录日志。这是防御性编程的经典模式，添加空值过滤。</p><p>然后我们就添加了两个null的校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ToolCall&gt; validToolCalls = toolCalls.stream()</span><br><span class="line">    .filter(toolCall -&gt; toolCall.function() != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">                        toolCall.function().name() != <span class="literal">null</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>解决了一个issue <a href="https://github.com/alibaba/spring-ai-alibaba/pull/1766">https://github.com/alibaba/spring-ai-alibaba/pull/1766</a></p><ol start="3"><li></li></ol><p>2025.7.23 下午</p><p>今天修复了还是我们熟悉的fastjson2的一个小issue</p><p>因为他jsonfactory设定的内存的最大阈值时2048.然后我看他们反馈实际应用的是比这要打的</p><p>那么我们就可以去自己去设定这一个max值。但是这样内存太大的话，又会出现oom问题。不知道怎么处理</p><p><a href="https://github.com/alibaba/fastjson2/pull/3658">https://github.com/alibaba/fastjson2/pull/3658</a></p><ol start="4"><li></li></ol><p>fastjson2的一个版本兼容的问题，但是他的checkstyle格式实在是改不过来我吐。我就用的main函数来直接测试了</p><p>添加了判断方法和set方法，<strong>字段默认值类型转换</strong></p><p>然后默认值的实际类型与目标字段类型不匹配开始，当启用兼容模式时，对于 <code>String → Date</code> 的转换进行特殊处理</p><ul><li><code>isJSONFieldDefaultValueCompatMode()</code>: 检查是否启用 FastJSON 1.x 兼容模式</li><li><code>defaultValue instanceof String</code>: 默认值是字符串类型</li><li><code>Date.class.isAssignableFrom(fieldClass)</code>: 目标字段是 Date 类型或其子类</li></ul><p><a href="https://github.com/alibaba/fastjson2/pull/3661">https://github.com/alibaba/fastjson2/pull/3661</a></p><p>算了，不做了我吐</p><ol start="5"><li></li></ol><p>又是一个fastjson2的项目的pr,这次主要是修复了fastjson2在处理set list等集合的解析的问题，他们在反序列化的时候会出现问题。然后不同编码使用不同的读取方式</p><p>让他们在操作的时候直接进行byte的操作，如果是set的化就进行特殊处理+去重</p><p><a href="https://github.com/alibaba/fastjson2/pull/3701">https://github.com/alibaba/fastjson2/pull/3701</a></p><ol start="7"><li></li></ol><p>2025.7.28</p><p>这次还是springaialibaba</p><p>调用mcp工具，调用了能有全链路的traceid，串联不了链路</p><ul><li>实现了 <code>McpTraceExchangeFilterFunction</code>，用于在 HTTP 请求中自动注入 traceId、spanId 等分布式链路追踪相关 header，支持 Micrometer Tracing。</li><li>通过 Spring Boot 自动配置（<code>McpTracingAutoConfiguration</code>），自动装配 tracing filter，无需手动配置，提升易用性。</li><li><strong>客户端传输层支持 tracing filter 注入</strong></li><li>让 MCP 客户端具备分布式链路追踪能力，方便排查问题和性能分析。</li></ul><p><a href="https://github.com/alibaba/spring-ai-alibaba/pull/1837">https://github.com/alibaba/spring-ai-alibaba/pull/1837</a></p><ol start="8"><li></li></ol><p>还是spring ai alibaba</p><p>Spring AI Alibaba Graph模块中<strong>Tool节点</strong>与<strong>Dify平台</strong>集成时的<strong>属性映射问题</strong>。原有的ToolNodeData只支持基础的tool相关属性，无法完整支持Dify平台的丰富工具配置。</p><p>添加更多的属性的setter 和getter和处理属性的数组，和属性映射之间的关系</p><p><a href="https://github.com/alibaba/spring-ai-alibaba/pull/1948">https://github.com/alibaba/spring-ai-alibaba/pull/1948</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Github/">Github</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/kaiyuan/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis面试hot-高并发/高级玩法部分</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;redis的高并发和高可用&lt;/h1&gt;
&lt;p&gt;如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。&lt;/p&gt;
&lt;p&gt;redis</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>redis的高并发和高可用</h1><p>如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。</p><p>redis 实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><h2 id="主从架构">主从架构</h2><p>redis的主从架构就是读写分离，一主多从。</p><p>主节点负责写，其他的从节点负责读</p><p>其中重要的就是数据的一致性的问题，就是数据的replication。我们采用了主从架构的时候，必须开启持久化</p><ul><li>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li><li>slave并不会过期key，master的key过期了，会模拟一条del命令发送给slave</li><li>无磁盘复制，master 在内存中直接创建 <code>RDB</code> ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</li></ul><hr><p>主从复制的核心：就是增量复制和全量复制</p><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。这个就是增量复制。</p><p>那么我们怎么确定是增量复制还是全量复制呢，如果复制的过程中中断了怎么办？</p><p>Redis2.8 开始就支持断点传输了。</p><p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> 。</p><p>那么我们增量复制的时候，主节点的backlog_buffer里面存储我们最近的数据，然后跟从节点的slave_reolica_buffer进行对比，根据差值来进行全量复制还是增量复制。</p><p>但是这个缓冲区默认的是1M，我们可以增大这个缓冲区</p><p>打开 <code>redis.conf</code> 文件，找到repl-backlog-size，然后修改值即可。</p><hr><p>复制的流程：</p><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><p>全量复制：</p><ul><li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li><li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li><li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li><li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure><ul><li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中。注意，在清空旧数据之前，slave node 依然会<strong>基于旧的数据版本</strong>对外提供服务。</li><li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li></ul><p>增量复制：</p><ul><li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li><li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li><li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li></ul><h2 id="持久化机制">持久化机制</h2><p>一般的我们的持久化机制就是</p><p>RDB，AOF ，RDB-AOF</p><p>持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 Redis 整个挂了，然后 Redis 就不可用了，你要做的事情就是让 Redis 变得可用，尽快变得可用。</p><ul><li>RDB：RDB 持久化机制，是对 Redis 中的数据执行<strong>周期性</strong>的持久化。</li><li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li></ul><p>RDB:</p><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 Redis 中的数据。</li><li>RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis <strong>保持高性能</strong>，因为 Redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 Redis 进程，更加快速。</li><li>如果想要在 Redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟（甚至更长时间）的数据。</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><p>AOF:</p><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 <code>fsync</code> 操作，最多丢失 1 秒钟的数据。</li><li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li><li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li><li>AOF 日志文件的命令通过可读较强的方式进行记录，这个特性非常<strong>适合做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code> ，性能也还是很高的。（如果实时写入，那么 QPS 会大降，Redis 性能会大大降低）</li><li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 <code>merge</code> 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是<strong>基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好很多。</li></ul><p>他们都是有优缺点的，我们可以使用RDB-AOF混合的模式</p><p>当然appendonly yes也是要启动AOF的，然后一般我们选择**<code>appendfsync everysec</code>** 配置 AOF 的同步策略为每秒一次</p><p>在 <code>redis.conf</code> 文件中，找到aof-use-rdb-preamble yes</p><p>这意味着当 AOF 进行 <code>rewrite</code> （重写）时，会使用 RDB 格式的数据作为 AOF 文件的前置内容，然后才是增量的 AOF 命令。  这能大大缩短 Redis 重启时加载 AOF 文件的速度。</p><p>然后重启redis，使配置生效</p><h2 id="哨兵模式">哨兵模式</h2><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li><p>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</p></li><li><p>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p></li><li><p>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</p></li><li><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p></li><li><p>哨兵至少需要 3 个实例，来保证自己的健壮性。按照需求设置配置 <code>quorum=</code></p></li></ul><hr><p>哨兵在让redis node进行主备切换的时候可能会出现数据丢失的问题</p><p>异步复制导致的数据丢失：</p><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p><p>脑裂问题导致的数据丢失:</p><p>脑裂，也就是说，某个 master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会<strong>认为</strong> master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong>。</p><p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p><p>解决：：</p><p>进行如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p><p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。</p><ul><li>减少异步复制数据的丢失</li></ul><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p><ul><li>减少脑裂的数据丢失</li></ul><p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p><hr><p>自动发现机制：</p><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步。</p><p>选举算法：</p><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><p>configuration epoch：</p><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p><h2 id="集群">集群</h2><p>一般我们使用的使redis原生的集群，Redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><p>介绍：</p><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><p>节点之间的通信：</p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p><p>Redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p><ul><li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code> 。</li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li></ul><hr><p>gossip协议：</p><p>gossip 协议包含多种消息，包含 <code>ping</code> , <code>pong</code> , <code>meet</code> , <code>fail</code> 等等。</p><ul><li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-trib.rb add-node</span><br></pre></td></tr></table></figure><p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</li><li>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。</li><li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</li></ul><p>ping:</p><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p><p>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息。</p><hr><p>分布式寻址算法：</p><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul><p>hash：</p><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><p>一致性hash：</p><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><p>Redis cluster 的 hash slot 算法:</p><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/redis/">redis</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cache缓存</title>
      <link>https://blog.tokenlen.top/2025/07/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cache1/</link>
      <guid>https://blog.tokenlen.top/2025/07/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cache1/</guid>
      <pubDate>Sun, 13 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;缓存&lt;/h1&gt;
&lt;p&gt;1.为什么要用缓存？&lt;/p&gt;
&lt;p&gt;用缓存，主要有两个用途：&lt;strong&gt;高性能&lt;/strong&gt;、&lt;strong&gt;高并发&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>缓存</h1><p>1.为什么要用缓存？</p><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p><p>就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。</p><p>缓存功能简单，说白了就是 <code>key-value</code> 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p><hr><p>如果按照我们存储的位置来分的话，缓存分为：</p><p>本地缓存，访问速度最快的，一般我们查数据的时候，首先查的就是本地缓存，比如Caffeine, Guava Cache, Ehcache</p><p>分布式缓存，容量更大，多个应用之间可以i将那些共享数据，比如Redis, Memcached, Hazelcast</p><p>客户端缓存，缓存数据存储在客户端，比如浏览器缓存，app缓存等等</p><p>CDN缓存，缓存静态资源在离用户较近的 CDN 节点上，常用于加速访问的速度</p><p>数据库缓存，数据库自身提供的缓存机制, 用于缓存查询结果，比如mysql就有缓存机制</p><h2 id="Redis">Redis</h2><p>1.Redis 和 Memcached 有啥区别？</p><ol><li>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， Redis 会是不错的选择。</li><li>在 Redis3.x 版本中，便能支持 cluster 模式，而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li><li>由于 Redis 只使用<strong>单核</strong>，而 Memcached 可以使用<strong>多核</strong>，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li></ol><h2 id="本地缓存">本地缓存</h2><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">50万写入:耗时:ms</th><th style="text-align:left">50写+50读(读全命中):耗时:ms</th><th style="text-align:left">50万写+50万读(全命中)+50万读(未命中)：耗时:ms</th><th style="text-align:left">50万读+50万未命中</th></tr></thead><tbody><tr><td style="text-align:left">Guava</td><td style="text-align:left">329/340/326/328/328</td><td style="text-align:left">536/518/546/525/558</td><td style="text-align:left">647/646/638/668/641</td><td style="text-align:left">490/501/482/485/492</td></tr><tr><td style="text-align:left">Caffeine</td><td style="text-align:left">292/284/270/279/267</td><td style="text-align:left">414/382/353/385/361</td><td style="text-align:left">479/513/460/487/481</td><td style="text-align:left">343/326/333/336/369</td></tr><tr><td style="text-align:left">Ohc</td><td style="text-align:left">448/433/430/446/442</td><td style="text-align:left">763/748/765/741/705</td><td style="text-align:left">918/947/901/964/903</td><td style="text-align:left">653/676/607/639/704</td></tr><tr><td style="text-align:left">Ohc-Obj</td><td style="text-align:left">1343/1315/1217/1249/1193</td><td style="text-align:left">1910/1830/1849/1803/1786</td><td style="text-align:left">1979/1965/1947/1968/1946</td><td style="text-align:left">1487/1573/1499/1491/1483</td></tr></tbody></table><p>我们一般使用的时候就使用Caffeine就足够了</p><p>Caffeine 的核心设计目标是提供具有高命中率和低延迟的缓存。 其架构主要由以下几个关键组件组成：</p><ul><li><strong>ConcurrentMap:</strong>  Caffeine 实现了 <code>ConcurrentMap</code> 接口，这意味着它是线程安全的。 底层使用分段锁或无锁数据结构来支持并发访问。</li><li><strong>CacheLoader (可选):</strong> 用于在缓存未命中时自动加载值。 可以自定义实现 <code>CacheLoader</code> 接口， 定义加载数据的逻辑.</li><li><strong>CacheWriter (可选):</strong>  用于处理缓存的写入和删除操作。 可以自定义实现 <code>CacheWriter</code> 接口，定义写入和移除缓存条目的逻辑。</li><li><strong>驱逐策略 (Eviction Policies):</strong>  Caffeine 采用基于 <em>最逼近最优</em>  (Approaching Optimal) 的驱逐算法，包括TinyLFU 和 Window-TinyLFU。<ul><li><strong>TinyLFU (Tiny Least Frequently Used):</strong> 一个频率sketch， 用于估算每个条目的访问频率。 占用了极小的内存空间，但能提供接近最佳的频率估算。</li><li><strong>Window-TinyLFU:</strong> 一个结合了最近访问（Windowed LFU）和频率信息（TinyLFU）的二级缓存结构。最近访问的数据保存在一个小的&quot;窗口&quot;中，而更长时间内的数据则通过TinyLFU来估算访问频率.</li></ul></li><li><strong>刷新策略 (Refresh):</strong> 支持异步地刷新缓存条目，从而保持缓存数据的新鲜度。</li><li><strong>写入策略 (Write):</strong> 支持同步或异步地将缓存条目写入到持久层（例如数据库）。</li><li><strong>监听器 (Listeners):</strong> 允许注册监听器，以便在缓存条目被添加、更新或移除时执行自定义的逻辑。</li></ul><p>优点：</p><ul><li><strong>接近最优的命中率：</strong> Caffeine 使用了非常先进的驱逐算法，能够更好地保留热点数据，从而提高命中率。</li><li><strong>低延迟：</strong> Caffeine 针对低延迟进行了优化，尽可能减少锁竞争，提高并发访问性能。</li><li><strong>自动加载：</strong> 通过 <code>CacheLoader</code> 可以在缓存未命中时自动加载数据，简化了缓存的使用。</li><li><strong>异步刷新：</strong> 异步刷新能够保持缓存数据的新鲜度，同时避免阻塞主线程。</li><li><strong>灵活的配置：</strong> Caffeine 提供了丰富的配置选项，可以根据不同的需求进行定制。</li><li><strong>轻量级：</strong> Caffeine 依赖少，体积小，易于集成到项目中。</li></ul><hr><p>使用</p><p>手动加载:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; manualCache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>))  <span class="comment">// 10 秒后过期</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)                         <span class="comment">// 最大容量 100</span></span><br><span class="line">                .removalListener((String key, String value, com.github.benmanes.caffeine.cache.RemovalCause cause) -&gt;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause)) <span class="comment">//移除监听器</span></span><br><span class="line">                .build();</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>自动加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; loadingCache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .expireAfterWrite(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">               .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)  <span class="comment">// 定时刷新</span></span><br><span class="line">               .build(key -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 在这里实现加载数据的逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Loading value for key: &quot;</span> + key);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&quot;value for &quot;</span> + key;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>异步加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String,String&gt; asyncLoadingCache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                .expireAfterWrite(<span class="number">5</span>,TimeUnit.MINUTES)</span><br><span class="line">                .buildAsync(key -&gt; &#123;</span><br><span class="line">                    <span class="comment">//在这里实现异步加载数据的逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Async Loading value for key :&quot;</span> + key);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Async value for &quot;</span> + key;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><h1>使用缓存会导致的问题</h1><h2 id="数据的一致性问题">数据的一致性问题</h2><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><p>为什么是删除缓存？</p><p>在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。可能是一个多表查询的运算的结果。其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><p>1.先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><ul><li>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</li><li>延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。</li></ul><p>2.数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><p>设计：</p><ul><li><strong>读请求:</strong> 优先从缓存读取。 如果缓存未命中，则发起缓存更新请求（放入队列），并同步等待一段时间。 如果等待超时，则直接读取数据库（返回旧数据）。</li><li><strong>写请求:</strong> 首先删除缓存，然后更新数据库。 更新数据库的操作也放入队列中串行执行。</li><li><strong>队列:</strong> 每个数据项（例如商品 ID）维护一个专属的 JVM 内部队列。</li><li><strong>工作线程:</strong> 每个队列对应一个工作线程，负责串行执行队列中的更新操作（先更新数据库，后更新缓存）。</li><li><strong>路由:</strong> 基于数据唯一标识（例如商品 ID）进行路由，确保对同一数据项的读写请求都会路由到相同的队列和工作线程。</li></ul><p>问题：</p><p>1.队列积压：*务必设置读请求的超时时间，保证请求及时返回。*<em>加队列的数量，将数据分散到不同的队列中，减少每个队列的积压。</em></p><p>或者是如果是热点数据搞得，我们可以拆分热点数据和普通数据</p><p>2.单个热点数据过热，<em>预先识别热点数据，并将其分散到不同的队列中。 可以采用更精细的哈希算法，或者人工配置的方式。</em>，人工限流降级，在服务器内部使用二级缓存。</p><p>3.路由实例间得路由不一致，*使用一致性哈希算法，确保对同一数据项的请求始终路由到相同的服务实例。*或者使用nginx进行代理</p><p>一看这样我们可以直接引入kafka来解决啊</p><table><thead><tr><th>特性</th><th>JVM 内部队列</th><th>Kafka</th></tr></thead><tbody><tr><td>解耦程度</td><td>有限，读写服务在同一 JVM 中</td><td>更彻底，读写服务完全解耦</td></tr><tr><td>扩展性</td><td>受单机 JVM 限制</td><td>高，可以通过增加分区和消费者实例来提高吞吐量</td></tr><tr><td>可靠性</td><td>较低，消息容易丢失</td><td>高，消息持久化和消息重放机制</td></tr><tr><td>容错性</td><td>差，单点故障</td><td>好，集群容错</td></tr><tr><td>复杂度</td><td>低，易于实现</td><td>高，需要配置和维护 Kafka 集群</td></tr><tr><td>延迟</td><td>低，JVM 内部通信</td><td>较高，消息需要经过网络传输</td></tr><tr><td>一致性保证</td><td>容易实现简单的一致性</td><td>需要考虑事务和消息顺序性</td></tr></tbody></table><h2 id="缓存三兄弟">缓存三兄弟</h2><p>缓存三兄弟就是我们常说的的缓存击穿，缓存穿透，缓存雪崩。</p><hr><p>缓存雪崩，是指短时间内有大量key过期，然后一下子压力全到数据库上面去了。</p><p>预防：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。</p><p>处理：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p><p>事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p><p>在代码上的话，我们可以使用互斥锁，只有获得了锁才能去访问。如果是过期时间的问题，采取热点数据永不过期，设置随机的过期时间等等。</p><p>如果是太多请求的话，我们可以限流，或者降级。</p><p>缓存穿透：</p><p>就是很多个缓存查不到的请求，数据库也查不到的请求发过来了</p><p>我们可以采用空值的方式,每次系统  从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code> 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><p>或者是我们使用布隆过滤器，过滤我们数据库没有的请求。</p><p>缓存击穿:</p><p>就是一瞬间热点key直接失效了，大量的请求就击穿了缓存，直接请求数据库。</p><ul><li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li><li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li><li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li></ul><h2 id="缓存并发竞争">缓存并发竞争</h2><p>Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？</p><p>就是<strong>多客户端同时并发写</strong>一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p><p>比如：</p><ul><li><strong>库存扣减：</strong> 多个客户端同时购买同一商品，导致库存超卖。</li><li><strong>计数器更新：</strong> 多个客户端同时增加计数器的值，导致计数器结果不准确。</li><li><strong>排行榜更新：</strong> 多个客户端同时更新排行榜数据，导致排行榜数据不一致。</li></ul><p>1.单线程架构,Redis 本身是单线程架构，这意味着 Redis 命令是顺序执行的，避免了多线程并发问题。 但是，单线程架构并不能完全解决并发竞争问题。 例如，多个客户端同时发送 <code>INCR</code> 命令来增加计数器的值，Redis 仍然可能因为网络延迟等原因导致计数器结果不准确。</p><p>2.原子操作，Redis 提供了许多原子操作，例如 <code>INCR</code>、<code>DECR</code>、<code>SETNX</code> 等。 原子操作可以保证操作的完整性，避免并发竞争问题。 例如，可以使用 <code>INCR</code> 命令来原子地增加计数器的值。</p><p>3.Lua脚本，可以将多个 Redis 命令组合成一个 Lua 脚本，然后使用 <code>EVAL</code> 命令来原子地执行该脚本。 Lua 脚本可以保证多个命令的原子性，避免并发竞争问题。 例如，可以使用 Lua 脚本来实现原子性的库存扣减操作。</p><p>4.CAS，Redis 提供了 <code>WATCH</code> 命令来实现乐观锁。 乐观锁允许多个客户端同时读取同一个 Key 的值，但是在更新 Key 的值之前，需要先检查该 Key 的值是否被其他客户端修改过。 如果被修改过，则更新失败，需要重新尝试。</p><ul><li>如果被 <code>WATCH</code> 监视的 Key 在事务执行期间被其他客户端修改过，那么 <code>EXEC</code> 命令会返回 <code>nil</code>，表示事务执行失败。</li><li>如果被 <code>WATCH</code> 监视的 Key 在事务执行期间没有被其他客户端修改过，那么 <code>EXEC</code> 命令会执行事务中的所有命令，并返回执行结果。</li></ul><p>5.分布式锁，redission?保证同一时间只有一个客户端可以访问共享资源。</p><p>可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p><p>你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。</p><p>每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/Cache/">Cache</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cache1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试题目2</title>
      <link>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodehot2/</link>
      <guid>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodehot2/</guid>
      <pubDate>Sat, 05 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;面试二轮&lt;/h1&gt;
&lt;h2 id=&quot;76-最小覆盖子串-x&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-window-substring/&quot;&gt;76. 最小覆盖子串&lt;/a&gt;(x)&lt;/h2&gt;
&lt;p&gt;给你一个字符串</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>面试二轮</h1><h2 id="76-最小覆盖子串-x"><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>(x)</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">minWindow</span>(<span class="params"><span class="built_in">String</span> S, <span class="built_in">String</span> t</span>) &#123;</span><br><span class="line">        int[] cnt = <span class="keyword">new</span> int[<span class="number">128</span>];</span><br><span class="line">        int less = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (char <span class="attr">c</span>:t.<span class="title function_">toCharArray</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                less++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] s = S.<span class="title function_">toCharArray</span>();</span><br><span class="line">        int m  = s.<span class="property">length</span>;</span><br><span class="line">        int ansleft  = -<span class="number">1</span>;</span><br><span class="line">        int ansRight = m;</span><br><span class="line">        </span><br><span class="line">        int left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int right = <span class="number">0</span>;right&lt;m;right++)&#123;</span><br><span class="line">            char c =s[right];</span><br><span class="line">            cnt[c]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                less--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (right-left&lt;ansRight-ansleft)&#123;</span><br><span class="line">                    ansleft = left;</span><br><span class="line">                    ansRight = right;</span><br><span class="line">                &#125;</span><br><span class="line">                char x = s[left];</span><br><span class="line">                <span class="keyword">if</span> (cnt[x]==<span class="number">0</span>)&#123;</span><br><span class="line">                    less++;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[x]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansleft&lt;<span class="number">0</span>?<span class="string">&quot;&quot;</span>:S.<span class="title function_">substring</span>(ansleft,ansRight+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码使用了滑动窗口的方法，一看他是个window就是滑动窗口</p><p>解决思路是进-改-出</p><p>先区遍历元素，然后确定要出现的最少的次数</p><p>然后进右端端点，需要的出现次数–</p><p>然后最少字母次数–</p><p>当最小次数为0的时候，这个时候如果滑动窗口的长度小于结果的长度的时候</p><p>更新节点位置</p><p>然后出左节点，如果需要出现的为0了</p><p>那么最少字母次数++</p><p>然后左端点对应的字母需要次数++，左端点移动</p><p>最后需要的是结果左端点和右端点之间的</p><p>也就是我们常说的right-left+1</p><h2 id="124-二叉树中的最大路径和"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>就是一个贪心算法，我们每一步都选dfs的最优解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution124A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lval</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rval</span>  <span class="operator">=</span>dfs(root.right);</span><br><span class="line">        ans  = Math.max(ans,lval+rval+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(lval,rval)+ root.val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选左还是选右的问题</p><h2 id="208-实现-Trie-前缀树"><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p>前缀树就是记录字符串用的，一个放孩子孩子节点的字母表，一个放是不是结束的标志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Node[] son = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:word.toCharArray())&#123;</span><br><span class="line">            c -=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.son[c]==<span class="literal">null</span>)&#123;</span><br><span class="line">                cur.son[c] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(word)==<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(prefix)!=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:word.toCharArray())&#123;</span><br><span class="line">            c-=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.son[c]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code> 以内的答案将被接受。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-105 &lt;= num &lt;= 105</code></li><li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素</li><li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size()==right.size())&#123;</span><br><span class="line">            right.offer(num);</span><br><span class="line">            left.offer(right.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left.offer(num);</span><br><span class="line">            right.offer(left.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left.size()&gt;right.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> left.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们维护一个最大堆left和一个最小堆right</p><p>加元素的时候，如果当前左右数量相等的话，那么优先加入最小堆，然后把最小堆的栈顶给左堆</p><p>不想等的话，一般是最大堆需要，然后小的栈顶给最小堆</p><p>取中位数的时候，如果是偶数，那么是最大堆和最小堆顶的平均值</p><p>不是的话就是最大堆的顶</p><h2 id="32-最长有效括号"><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>看到这种括号题目，第一个想到就是使用栈来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution32AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> vaild[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;(&#x27;</span>) stack.push(i);</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;)&#x27;</span>&amp;&amp;!stack.isEmpty())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                vaild[i] = <span class="literal">true</span>;</span><br><span class="line">                vaild[index]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;vaild.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vaild[i])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res,count);</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,count);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用栈，记录一个有效值的数字。</p><p>然后遍历字符找到有效括号</p><h2 id="141-环形链表"><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution141A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常easy的环形链表</p><h2 id="72-编辑距离"><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution72A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] t=  text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[] f= <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            f[j+<span class="number">1</span>] = j+<span class="number">1</span>;<span class="comment">//text2 的前 j + 1 个字符所需的操作数为 j + 1 (即插入 j + 1 个字符)。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> f[<span class="number">0</span>];</span><br><span class="line">            f[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span>f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x ==t[j]?pre:Math.min(Math.min(f[j+<span class="number">1</span>],f[j]),pre)+<span class="number">1</span>;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>text1</code> 的当前字符 <code>x</code> 与 <code>text2</code> 的当前字符 <code>t[j]</code> 相同，那么不需要任何操作</p><ul><li></li><li><p><code>f[j + 1]</code>: 表示删除 <code>text1</code> 的当前字符 <code>x</code>。对应于操作&quot;删除&quot;。</p></li><li><p><code>f[j]</code>: 表示在 <code>text1</code> 中插入一个字符，使得 <code>text1</code> 的当前字符等于 <code>t[j]</code>。对应于操作&quot;插入&quot;。</p></li><li><p><code>pre</code>: 表示将 <code>text1</code> 的当前字符 <code>x</code> 替换为 <code>t[j]</code>。对应于操作&quot;替换&quot;。 由于需要经过一次编辑(删除/插入/替换)才能让<code>text1</code>前<code>i</code>个字符匹配<code>text2</code>前<code>j+1</code>个字符，所以操作总数要+1。</p></li></ul><h2 id="692-前K个高频单词"><a href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前K个高频单词</a></h2><p>给定一个单词列表 <code>words</code> 和一个整数 <code>k</code> ，返回前 <code>k</code> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p><p>一看到这个题，我就想到用hashmap来做，然后我看又需要顺序，那我直接使用linkedhashmap不久得了。发现并不是的</p><p>可以使用优先队列，或者是规定compare的List，这里直接用优先队列吧</p><p>然后挑出前k个</p><p>放入list即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution692</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (w1,w2)-&gt;map.get(w1).equals(map.get(w2))?w2.compareTo(w1):map.get(w1)-map.get(w2)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String word:map.keySet())&#123;</span><br><span class="line">            queue.offer(word);</span><br><span class="line">            <span class="keyword">if</span> (queue.size()&gt;k)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            res.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p>又是不重复，直接上hashset,一开始想这样做来，但发现不对，这样做的是字符串的数量</p><p>然后就想使用滑动窗口，更新值。如果含有就更新左端点，</p><p>不含有就更新最大值，然后放入右端点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(right))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(right)));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(right), right);</span><br><span class="line">            maxlen = Math.max(maxlen, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution394A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span>  <span class="variable">curSting</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack_multi=  <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character c:s.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.isDigit(c))&#123;</span><br><span class="line">                    num = num*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack_multi.push(num);</span><br><span class="line">                    stack.push(curSting);</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    curSting = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">longnum</span> <span class="operator">=</span> stack_multi.pop();</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack.pop());</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;longnum;i++)&#123;</span><br><span class="line">                        temp.append(curSting);</span><br><span class="line">                    &#125;</span><br><span class="line">                    curSting=  temp.toString();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    curSting +=c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> curSting;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经典的括号和栈的问题</p><p>一个放之前的字符，一个放数字。当变成】结束的时候。将里面的字符遍历数字遍</p><h2 id="82-删除排序链表中的重复元素-II"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution82AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next!=<span class="literal">null</span>&amp;&amp;cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.next.val == val)&#123;</span><br><span class="line">                <span class="keyword">while</span> (cur.next!=<span class="literal">null</span>&amp;&amp;cur.next.val == val)&#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是去检测cur.next和cur和cur.next之后的值是不是想到，想到就只留cur，然后其他的跳过</p><h2 id="18-四数之和"><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p>可以使用hash表+定长的滑动窗口试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//简单去重</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//最小的都大，直接抛弃</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[n - <span class="number">3</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//最大的都小直接抛弃</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="comment">//简单去重</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="comment">//最小的三个都大，抛弃</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="comment">//最大的三个都小抛弃</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;<span class="comment">//找出左右边界</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p>**注意：**解集不能包含重复的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution40A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,target,candidates,ans,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> left,<span class="type">int</span>[] candidates,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;candidates.length&amp;&amp;candidates[j]&lt;=left;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;i&amp;&amp;candidates.length==candidates[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[j]);</span><br><span class="line">            dfs(j+<span class="number">1</span>,left-candidates[j],candidates,ans,path);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选与不选的问题，如果j&gt;i且等与j的数都不选</p><p>记得回溯哈</p><h2 id="415-字符串相加"><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p>就是类似于一个加法的计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStringsA</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        String ans= <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(turn(num1)+turn(num2));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">turn</span><span class="params">(String nums)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=nums.length();i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans +=(i-<span class="number">1</span>)*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        StringBuilder res= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length()-<span class="number">1</span>,j=num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span>  <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            res.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="946-验证栈序列"><a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></h2><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution946</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;stack.peek()==popped[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的模拟栈运行的操作</p><p>当前栈的栈顶的数，如果是pop序列中的第i个的话，就说明这次成功，然后i++;</p><p>最后如果栈为空了，也就是所有的都符合，返回true</p><h2 id="146-LRU-缓存-x"><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a>(x)</h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCacheAA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key,vaule;</span><br><span class="line">        Node prev,next;</span><br><span class="line">        Node(<span class="type">int</span> k,<span class="type">int</span> v)&#123;</span><br><span class="line">            key = k;</span><br><span class="line">            vaule = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; keyToNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCacheAA</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        dummy.prev = dummy;</span><br><span class="line">        dummy.next = dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(key);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="literal">null</span>?node.vaule:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(key);</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            node.vaule = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">        keyToNode.put(key,node);</span><br><span class="line">        pushFront(node);</span><br><span class="line">        <span class="keyword">if</span> (keyToNode.size()&gt;capacity)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">backNode</span> <span class="operator">=</span> dummy.prev;</span><br><span class="line">            keyToNode.remove(backNode.key);</span><br><span class="line">            remove(backNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushFront</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        x.prev = dummy;</span><br><span class="line">        x.next = dummy.next;</span><br><span class="line">        x.prev.next = x;</span><br><span class="line">        x.next.prev = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyToNode.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> keyToNode.get(key);</span><br><span class="line">        remove(node);</span><br><span class="line">        pushFront(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是实现了按LRU缓存的策略，主要使用的双向链表和hash表来解决的</p><h2 id="1-两数之和"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">。</span><br></pre></td></tr></table></figure><p>快速的时候hashmap来进行查询</p><p>如果是更多的话，可以参考固定一个，然后移动另外一个</p><h2 id="88-合并两个有序数组"><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p>**注意：**最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution88AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> m-<span class="number">1</span>,len2=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len1&gt;=<span class="number">0</span>&amp;&amp;len2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[len--] = nums1[len1]&gt;nums2[len2]?nums1[len1--]:nums2[len2--];</span><br><span class="line">        &#125;</span><br><span class="line">       System.arraycopy(nums2,<span class="number">0</span>,nums1,<span class="number">0</span>,len2+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的排序，就是从后面开始遍历，看谁大就行了</p><h2 id="143-重排链表"><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>这里就用到了反转链表的知识，我们先找到链表的中点，然后将链表一分为二，然后反转后面的链表，然后再合并两个链表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution143B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> middle(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> reverseList(mid);</span><br><span class="line">        <span class="keyword">while</span> (head2.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next2</span> <span class="operator">=</span> head2.next;</span><br><span class="line">            head.next = head2;</span><br><span class="line">            head2.next = next;</span><br><span class="line">            head = next;</span><br><span class="line">            head2 = next2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre=  cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span>head,fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="91-解码方法"><a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h2><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1&quot; -&gt; &#x27;A&#x27; &quot;2&quot; -&gt; &#x27;B&#x27; ... &quot;25&quot; -&gt; &#x27;Y&#x27; &quot;26&quot; -&gt; &#x27;Z&#x27;</span><br></pre></td></tr></table></figure><p>然而，在 <strong>解码</strong> 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（<code>&quot;2&quot;</code> 和 <code>&quot;5&quot;</code> 与 <code>&quot;25&quot;</code>）。</p><p>例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1, 1, 10, 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11, 10, 6)</code></li><li>消息不能分组为 <code>(1, 11, 06)</code> ，因为 <code>&quot;06&quot;</code> 不是一个合法编码（只有 “6” 是合法的）。</li></ul><p>注意，可能存在无法解码的字符串。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。如果没有合法的方式解码整个字符串，返回 <code>0</code>。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution91AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s=  <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i] = f[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i]+=f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个简单的动态规划</p><p>就只有俩选择，如果是1-9之内的就说明是a,也就是选择前面的一个就够了</p><p>如果是10-26之内，就说明要前面的两个才行</p><p>如果都可以的话，这俩都要。所以是+=f[i-2]</p><p>转移 <code>f[i]</code> 时只依赖 <code>f[i-1]</code> 和 <code>f[i-2]</code> 两个状态。</p><p>可以采用与「滚动数组」类似的思路，只创建长度为 3 的数组，通过取余的方式来复用不再需要的下标。进行一波优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution91AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s=  <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i] = f[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i]+=f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodingsA</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[]f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>]  =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i%<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i%<span class="number">3</span>] = f[(i-<span class="number">1</span>)%<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i%<span class="number">3</span>] +=f[(i-<span class="number">2</span>)%<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution215</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈哈两行直接解决，虽然不是最合适的。</p><h2 id="25-K-个一组翻转链表（x暂时有点懵逼啊）"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>（x暂时有点懵逼啊）</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution215</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25AAa</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//统计节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur!=<span class="literal">null</span>;cur = cur.next)&#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span>  <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;n&gt;=k;n-=k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span>cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> p0.next;</span><br><span class="line">            p0.next.next = cur;</span><br><span class="line">            p0.next = pre;</span><br><span class="line">            p0 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先按k个数字分开好几组，然后k个数字的内部就是简单的交换</p><p>然后外部的话，p0=dummy</p><p>ListNode next = p0.next;下一部分的起始节点</p><p>p0.next.next = cur，下一部分的起点。</p><p>p0.next = pre;真起点</p><p>p0 = next往下移动，将 <code>p0</code> 移动到下一组待翻转节点的前面。</p><h2 id="15-三数之和"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>;k&lt;nums.length-<span class="number">2</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> i=k+<span class="number">1</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k]+nums[i]+nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[++i]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[--j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k],nums[i],nums[j])));</span><br><span class="line">                    i++;j--;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟前面的四个组合是用的一样的方法，就是双指针，从头开始，然后去遍历，确定最大的和最小的，然后在里面去寻找。</p><h2 id="53-最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution53B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minpresum</span> <span class="operator">=</span> <span class="number">0</span>,presum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            presum +=x;</span><br><span class="line">            ans = Math.max(ans,presum-minpresum);</span><br><span class="line">            minpresum = Math.min(minpresum,presum);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护一个最大值和一个最小值，最大值就是和-小的。</p><p>可以扩展为乘法，最大值可能就是最小值乘出来的</p><h2 id="21-合并两个有序链表"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution21B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list2==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">           list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁的使用递归直接完成</p><h2 id="5-最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (s==<span class="literal">null</span>||s.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">strlen</span> <span class="operator">=</span> s.length();</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxStart</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="type">boolean</span>[][] dp  =<span class="keyword">new</span> <span class="title class_">boolean</span>[strlen][strlen];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> r= <span class="number">1</span>;r&lt;strlen;r++)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l&lt;r;l++)&#123;</span><br><span class="line">             <span class="keyword">if</span> (s.charAt(l)==s.charAt(r)&amp;&amp;(r-l&lt;=<span class="number">2</span>||dp[l+<span class="number">1</span>][r-<span class="number">1</span>]))&#123;</span><br><span class="line">                 dp[l][r] = <span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">if</span> (r-l+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                     maxLen = r-l+<span class="number">1</span>;</span><br><span class="line">                     maxStart = l;</span><br><span class="line">                     maxEnd = r;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> s.substring(maxStart,maxEnd+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用 动态规划来完成，</p><p>(r-1&lt;=2||dp l+1 r-1这个很好玩成了这个</p><p>如果r-l&lt;=2的话，就说明就一个数 了，肯定是回文。就是基数的时候</p><h2 id="102-二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution102B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为他是层序遍历，遍历完这一层才进行下一次遍历。所以我们要把这一层的节点全都放进队列。</p><p>然后一个一个取出来，记录值。然后再左右的去遍历</p><h2 id="33-搜索旋转排序数组"><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[n-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span>  <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target&lt;=end&amp;&amp;nums[mid]&gt;end)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target&gt;end&amp;&amp;nums[mid]&lt;=end)&#123;</span><br><span class="line">                right =mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left]!=target?-<span class="number">1</span>:left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一看到这个时间复杂度，我们第一时间想到的就是我们最喜欢的二分查找哈哈。</p><p>然后一看到这个旋转数组，我们肯定要关注最后一个数字，因为就是从他这旋转的</p><p>然后有三种大情况</p><p>目标值小于最后一个数，中位大于最后一个数，也就是说目标值在右边，中位在左。我们移动left指针到mid+1</p><p>然后都在一遍的话，就是普通的二分查找了</p><h2 id="200-岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>看到这个题，一个矩阵，直接进行遍历，就可以了。如果是求最大面积的话，再加上动态规划即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution200B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid ,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=grid.length||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] =<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>看到这种排列的题目，首先想到的就是回溯法+dfs哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution46</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="built_in">this</span>.nums.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span>  <span class="operator">=</span> nums.get(a);</span><br><span class="line">        nums.set(a,nums.get(b));</span><br><span class="line">        nums.set(b,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x== nums.size()-<span class="number">1</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;nums.size();i++)&#123;</span><br><span class="line">            swap(i,x);</span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            swap(i,x);<span class="comment">//这就是回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是固定一位，然后去移动他后面的位置。</p><p>然后移动完，再给他恢复。这就是回溯算法的所在</p><h2 id="20-有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution20AB</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>||c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;)&#x27;</span>||c==<span class="string">&#x27;]&#x27;</span>||c==<span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) || (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看到这个题目我就知道要使用栈，之前的哪些题都是差不多的</p><h2 id="121-买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution121B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE,profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price:prices)&#123;</span><br><span class="line">            cost = Math.min(cost,price);</span><br><span class="line">            profit = Math.max(profit,price-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较easy的一道题目了</p><h2 id="236-二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution236B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span>lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是比较简单的一道递归题目</p><h2 id="103-二叉树的锯齿形层序遍历"><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp  =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) queue.add(node.right); </span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是一个达到锯齿状层序遍历的目的，普通的层序遍历直接使用一个队列就ok</p><p>现在的如果现在比如我们里面的是奇数的话，就说明当前是偶数层，从右到左开始遍历，就是往前面加，</p><p>如果是偶数的话，就从左往右开始遍历，就是往后面开始加</p><p>一个层一个List<Interger></p><h2 id="手撕快速排序-x">手撕快速排序(x)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">OptimizedQuickSort</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] sortArry(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (right-left+<span class="number">1</span>&lt;=INSERTION_SORT_THRESHOLD)&#123;</span><br><span class="line">            insertionSort(nums,left,right);<span class="comment">//小数字使用插入排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pivots = partition3Way(nums,left,right);</span><br><span class="line">        quickSort(nums,left,pivots[<span class="number">0</span>]-<span class="number">1</span>);<span class="comment">//只递归小于的部分</span></span><br><span class="line">        quickSort(nums,pivots[<span class="number">1</span>]+<span class="number">1</span>,right);<span class="comment">//只递归大于的部分</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i!=j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j]  = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span>  <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=left&amp;&amp;nums[j]&gt;key)&#123;</span><br><span class="line">                nums[j+<span class="number">1</span>]  = nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] partition3Way(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left+random.nextInt(right-left+<span class="number">1</span>);</span><br><span class="line">        swap(nums,left,randomIndex);<span class="comment">//一个随机值，交换left和随机值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span>right +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;gt)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;pivot)&#123;<span class="comment">//小于pivot放入左区域</span></span><br><span class="line">                swap(nums,++lt,i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&gt;pivot)&#123;<span class="comment">//放入右区域</span></span><br><span class="line">                swap(nums,--gt,i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;<span class="comment">//只需要移动指针即可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,left,lt);<span class="comment">//最后交换回来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;lt,gt-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p>使用头插法真的得劲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution92B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">g</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;step&lt;left-<span class="number">1</span>;step++)&#123;</span><br><span class="line">            g = g.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">removed</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next  = g.next;</span><br><span class="line">            g.next =removed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先设一个虚拟节点，这样的话，就不用考虑边界值的问题了</p><p>然后g指针式left前面的</p><p>p指针指向left节点</p><p>然后我们这样把指针移动到该有的位置</p><p>然后反转的时候要反转的是right-left个节点</p><p>然后我们从把他们使用头插相继的插入到g节点的后面，因为g节点不动，动的是p节点。头插的话，先插的就在后面了。实现 了反转的效果</p><p>这样的就完成了。</p><h2 id="141-环形链表-2"><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution141B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span>  <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是经典快慢节点完成哈哈</p><h2 id="54-螺旋矩阵"><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution54B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        Integer[] ans = <span class="keyword">new</span> <span class="title class_">Integer</span>[(r+<span class="number">1</span>)*(b+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=l;i&lt;=r;i++) ans[x++]  = matrix[t][i];</span><br><span class="line">            <span class="keyword">if</span>(++t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=t;i&lt;=b;i++) ans[x++] = matrix[i][r];</span><br><span class="line">            <span class="keyword">if</span> (l&gt;--r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r;i&gt;=l;i--) ans[x++] = matrix[b][i];</span><br><span class="line">            <span class="keyword">if</span> (t&gt;--b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=b;i&gt;=t;i--) ans[x++]  = matrix[i][l];</span><br><span class="line">            <span class="keyword">if</span> (++l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是设定好边界值只会然后进行遍历即可</p><h2 id="300-最长递增子序列"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution300B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的动态规划，如果相等就+1，然后统计数量</p><h2 id="23-合并-K-个升序链表"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);</span><br><span class="line">        <span class="keyword">for</span> (ListNode head:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(head);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用最小堆，因为每个链表之中的head肯定是最小的</p><p>那我们就一直遍历里面的head，然后放入最小堆，然后将最小堆里面的取出来，放进我们的新的链表</p><p>可以加上dummy哨兵节点</p><h2 id="415-字符串相加-2"><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p>经典计算器类型的题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> i=num1.length()-<span class="number">1</span>,j = num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            sb.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) sb.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这种的题目都要使用StringBuilder这一个单线程的</p><h2 id="56-合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution56B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>]-q[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span>ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是按头上第一个排序之后，然后看最后面1的位置的数，是不是小于下一个的头上的数，小于的话，就可以合并</p><p>然后更新新的值</p><h2 id="160-相交链表"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution160B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        ListNode pA= headA;</span><br><span class="line">        ListNode pB=  headB;</span><br><span class="line">        <span class="keyword">while</span> (pA!=pB)&#123;</span><br><span class="line">            pA = (pA==<span class="literal">null</span>)?headB:pA.next;</span><br><span class="line">            pB = (pB==<span class="literal">null</span>) ?headA:pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是有公共部分的，如果我们其中一个遍历完之后，再从另一个链表的起点继续遍历</p><p>等他们相遇的时候，就是我们需要的那个交点</p><h2 id="42-接雨水-x"><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>(x)</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left= <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> <span class="number">0</span>,sufMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(preMax,height[left]);</span><br><span class="line">            sufMax = Math.max(sufMax,height[right]);</span><br><span class="line">            ans +=preMax&lt;sufMax?preMax-height[left++]:sufMax-height[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双指针谁小就移动谁，算是1D接雨水的最优解</p><p>2D接雨水</p><p>转换为了矩阵，但还是之前使用的木桶效应。</p><p>我们可以从这个最矮的方块出发，向其内部（上下左右）相邻的、未访问过的方块进行探索：</p><ul><li>如果相邻的方块 <code>(nr, nc)</code> 比 <code>h</code> 还矮，说明水可以把它淹没。这个方块能接的水量就是 <code>h - height[nr][nc]</code>。然后将这个方块也视为新的海岸线（因为它现在是水能到达的边界了），其有效高度是<code>h</code>（因为水是从<code>h</code>处漫灌过来的），把它加入我们的“海岸线”集合。</li><li>如果相邻的方块比 <code>h</code> 高，它自己就成了一堵新墙，无法积水。但它也成为了新的边界，需要加入“海岸线”集合。</li></ul><p>看到这个我们就要用我们的优先队列，也就是最小堆了，不断更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution407</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] DIRS = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapRainWater</span><span class="params">(<span class="type">int</span>[][] heightMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heightMap==<span class="literal">null</span>||heightMap.length&lt;=<span class="number">2</span>||heightMap[<span class="number">0</span>].length&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> heightMap.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span>  <span class="operator">=</span> heightMap[<span class="number">0</span>].length;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>||i==rows-<span class="number">1</span>||j==<span class="number">0</span>||j==cols-<span class="number">1</span>)&#123;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;heightMap[i][j],i,j&#125;);</span><br><span class="line">                    heightMap[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] t = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span> t[<span class="number">0</span>],i=t[<span class="number">1</span>],j=t[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] d:DIRS)&#123;</span><br><span class="line">                <span class="type">int</span> x= i+d[<span class="number">0</span>],y = j+d[<span class="number">1</span>];<span class="comment">//i,j的邻居</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; rows &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; cols &amp;&amp; heightMap[x][y] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    ans +=Math.max(minHeight-heightMap[x][y],<span class="number">0</span>);</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Math.max(minHeight, heightMap[x][y]), x, y&#125;);</span><br><span class="line">                    heightMap[x][y] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列-x"><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a>(x)</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[]f = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x==t[j]?pre+<span class="number">1</span>:Math.max(f[j+<span class="number">1</span>],f[j]);</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用动态规划，这种的题目一般都是使用动态规划或者使用滑动窗口进行解决的</p><h2 id="93-复原-IP-地址"><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution93B&#123;</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        int n  = s.length();</span><br><span class="line">        List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i =1;i&lt;n&amp;&amp;isvalid(s,0,i);i++)&#123;</span><br><span class="line">            for (int j=i+1;j&lt;n&amp;&amp;isvalid(s,i,j);j++)&#123;</span><br><span class="line">                for (int k =j+1;k&lt;n&amp;&amp;isvalid(s,j,k);k++)&#123;</span><br><span class="line">                    if (isvalid(s,k,n))&#123;</span><br><span class="line">                        ans.add(String.format(&quot;%s.%s.%s.%s&quot;,s.substring(0,i),s.substring(i,j),s.substring(j,k),s.substring(k)</span><br><span class="line">                                ));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isvalid(String s,int i,int j)&#123;</span><br><span class="line">        if (j-i&gt;3||j-i&gt;1&amp;&amp;s.charAt(i)==&#x27;0&#x27;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return Integer.parseInt(s.substring(i,j))&lt;=255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是相当于将这一串数分割成4段，我们需要切三次，然后这里面的每一个都要符合ip的定义就可以</p><h2 id="142-环形链表-II"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head,slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="literal">null</span>||fast.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是我们第一次循环之后，如果这个适合fast节点空了，就说明是没有环了</p><p>然后我们进行第二次循环，fast从头开始，然后继续遍历。我们下一次fast和slow相遇的节点就是我们需要的环的开始的节点</p><h2 id="19-删除链表的倒数第-N-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution19AA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummy,right = dummy;</span><br><span class="line">        <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = left.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法非常的巧妙，就是一把尺子，右节点先走n步，然后两个节点一块走，右节点走到头的适合，左节点就是我们需要的倒数第n个节点的前一个节点。</p><p>然后跳过该节点就Ok</p><h2 id="4-寻找两个正序数组的中位数"><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>一看到 这个熟悉的时间复杂度，就知道了我们应该使用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">        <span class="comment">//确保num1是较短的数组</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length&gt;nums2.length)&#123;</span><br><span class="line">            <span class="type">int</span>[] tmp  = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">//哨兵值</span></span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">0</span>] = b[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        a[m+<span class="number">1</span>] = b[n+<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        System.arraycopy(nums1,<span class="number">0</span>,a,<span class="number">1</span>,m);</span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,b,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = m;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m+n+<span class="number">1</span>)/<span class="number">2</span>-i;<span class="comment">//总的</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]&lt;=b[j+<span class="number">1</span>]&amp;&amp;b[j]&lt;=a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> Math.max(a[i],b[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">min2</span> <span class="operator">=</span>Math.min(a[i+<span class="number">1</span>],b[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> (m+n)%<span class="number">2</span>&gt;<span class="number">0</span>?max1:(max1+min2)/<span class="number">2.0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[i]&gt;b[j+<span class="number">1</span>])&#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i是我们变得，j是我们合起来得中间的数</p><h2 id="199-二叉树的右视图"><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution199A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth==ans.size())&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>,ans);</span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右视图就是我们当前的深度等于我们的ans里面的数目的时候就是。</p><p>然后递归即可</p><h2 id="94-二叉树的中序遍历"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution94B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,ans);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        dfs(root.right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归中序遍历</p><h2 id="165-比较版本号"><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><p>给你两个 <strong>版本号字符串</strong> <code>version1</code> 和 <code>version2</code> ，请你比较它们。版本号由被点 <code>'.'</code> 分开的修订号组成。<strong>修订号的值</strong> 是它 <strong>转换为整数</strong> 并忽略前导零。</p><p>比较版本号时，请按 <strong>从左到右的顺序</strong> 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 <code>0</code>。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution165A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> version1.length(),m = version2.length();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n||j&lt;m)&#123;</span><br><span class="line">            <span class="type">int</span> num1=<span class="number">0</span>,num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n&amp;&amp;version1.charAt(i)!=<span class="string">&#x27;.&#x27;</span>) num1 = num1*<span class="number">10</span>+version1.charAt(i++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;m&amp;&amp;version2.charAt(j)!=<span class="string">&#x27;.&#x27;</span>) num2 =num2*<span class="number">10</span>+version2.charAt(j++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num1&lt;num2)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            i++;j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把字符串转换为数字然后进行比较。.前面是一部分，后面是一部分</p><h2 id="704-二分查找"><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果 <code>target</code> 存在返回下标，否则返回 <code>-1</code>。</p><p>你必须编写一个具有 <code>O(log n)</code> 时间复杂度的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution704B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right  = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意边界的问题</p><h2 id="232-用栈实现队列"><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueueAB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueueAB</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> peek();</span><br><span class="line">        B.pop();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.peek();</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            B.push(A.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.isEmpty()&amp;&amp;B.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单的一道题目，就是我们使用两个栈来完成队列的先进先出的实现</p><p>一个栈A，一个栈B</p><p>我们进队列的时候先进入A栈，然后将A栈的元素，逐个放入B栈，我们从B栈里面pop元素，这样的话，就是按照顺序出栈的</p><h2 id="148-排序链表"><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution148AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> middle(head);</span><br><span class="line">        head = sortList(head);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line">        <span class="keyword">return</span> mergeTowLists(head,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head )</span>&#123;</span><br><span class="line">        ListNode pre=  head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTowLists</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="literal">null</span>&amp;&amp;list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val&lt;list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1  = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1!=<span class="literal">null</span>?list1:list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个题目类似于第k个反转链表的那个题目。都是先找中点，这个只不过是直接排序了</p><p>那个还有一个反转的操作</p><h2 id="22-括号生成"><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution22B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] path = <span class="keyword">new</span> <span class="title class_">char</span>[n*<span class="number">2</span>];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,n,path,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n,<span class="type">char</span>[] path,List&lt;String&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right==n)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;n)&#123;</span><br><span class="line">            path[left+right] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(left+<span class="number">1</span>,right,n,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right&lt;left)&#123;</span><br><span class="line">            path[left+right] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(left,right+<span class="number">1</span>,n,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>left代表左括号的，right代表右括号。使用选与不选的方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodehot2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
