<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Sun, 27 Apr 2025 10:18:14 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>开发项目总结</title>
      <link>https://blog.tokenlen.top/2025/04/26/work1/</link>
      <guid>https://blog.tokenlen.top/2025/04/26/work1/</guid>
      <pubDate>Fri, 25 Apr 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;项目开发经验总结&lt;/h1&gt;
&lt;h2 id=&quot;总体架构&quot;&gt;总体架构&lt;/h2&gt;
&lt;h3 id=&quot;架构思想：&quot;&gt;架构思想：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;分层&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Controller → Service →</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>项目开发经验总结</h1><h2 id="总体架构">总体架构</h2><h3 id="架构思想：">架构思想：</h3><p><strong>分层</strong>：</p><p>Controller → Service → Entity，这三层架构体系，</p><p><code>Controller</code> 层 <strong>不直接操作数据库</strong>，而是通过 <code>subjectService</code> 去拿数据。</p><p>业务逻辑集中在 <code>Service</code> 层，<code>Controller</code> 只负责<strong>接收请求、调用服务、返回结果</strong>。</p><p><strong>统一的返回结果</strong>：</p><p>不直接返回裸的 <code>List</code> 或 <code>对象</code>，而是包一层 <code>RestResponse</code>。</p><p>成功返回 <code>RestResponse.ok(数据)</code>。</p><p>统一格式，前端处理简单。</p><p>后期可以很方便统一加异常码、消息、分页信息。</p><p><strong>合理的使用对象映射：</strong></p><p><code>Subject</code> 是实体类（Entity），对应数据库。</p><p><code>SubjectVM</code>、<code>SubjectEditRequestVM</code> 是视图模型（VM），对应前端页面。</p><p>通过 <code>modelMapper.map(d, SubjectVM.class)</code> 进行转换，不暴露数据库结构。进行反序列化，更加安全</p><p><strong>使用流式编程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubjectVM&gt; subjectVMS = subjects.stream().map(d -&gt; &#123;</span><br><span class="line">    SubjectVM subjectVM = modelMapper.map(d, SubjectVM.class);</span><br><span class="line">    subjectVM.setId(String.valueOf(d.getId()));</span><br><span class="line">    return subjectVM;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>stream().map(...).collect(...)</code>，<br>一次性把 <code>List&lt;Subject&gt;</code> 转换成 <code>List&lt;SubjectVM&gt;</code>，代码简洁、可读性高。</p><h2 id="common方法模板">common方法模板</h2><h3 id="根据id查询">根据id查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/read/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;ExamPaperReadVM&gt; <span class="title function_">read</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询实体</span></span><br><span class="line">    <span class="type">ExamPaperAnswer</span> <span class="variable">answer</span> <span class="operator">=</span> examPaperAnswerService.selectById(id);</span><br><span class="line">    <span class="comment">// 转 VM</span></span><br><span class="line">    <span class="type">ExamPaperReadVM</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExamPaperReadVM</span>();</span><br><span class="line">    vm.setPaper(examPaperService.examPaperToVM(answer.getExamPaperId()));</span><br><span class="line">    vm.setAnswer(examPaperAnswerService.examPaperAnswerToVM(answer.getId()));</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.ok(vm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询实体-&gt;转成视图vm-&gt;结果</p><h3 id="新增">新增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Integer&gt; <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> SubjectEditRequestVM model)</span> &#123;</span><br><span class="line">    <span class="comment">// VM → Entity</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">entity</span> <span class="operator">=</span> modelMapper.map(model, Subject.class);</span><br><span class="line">    subjectService.insert(entity);</span><br><span class="line">    <span class="comment">// 返回新 ID</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.ok(entity.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vm-&gt;转为实体-&gt;插入返回id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/answerSubmit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">answerSubmit</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> ExamPaperSubmitVM vm)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getCurrentUser();</span><br><span class="line">    <span class="type">ExamPaperAnswerInfo</span> <span class="variable">info</span> <span class="operator">=</span> examPaperAnswerService.calculateExamPaperAnswer(vm, user);</span><br><span class="line">    <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.fail(<span class="number">2</span>, <span class="string">&quot;试卷不能重复做&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算结果 &amp; 事件</span></span><br><span class="line">    <span class="type">ExamPaperAnswer</span> <span class="variable">answer</span> <span class="operator">=</span> info.getExamPaperAnswer();</span><br><span class="line">    <span class="type">String</span> <span class="variable">scoreVm</span> <span class="operator">=</span> ExamUtil.scoreToVM(answer.getUserScore());</span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">CalculateExamPaperAnswerCompleteEvent</span>(info));</span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UserEvent</span>(<span class="keyword">new</span> <span class="title class_">UserEventLog</span>(</span><br><span class="line">        user.getId(), user.getUserName(), user.getRealName(), <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">        user.getUserName() + <span class="string">&quot; 提交试卷：&quot;</span> + info.getExamPaper().getName() +</span><br><span class="line">        <span class="string">&quot; 得分：&quot;</span> + scoreVm + <span class="string">&quot; 耗时：&quot;</span> + ExamUtil.secondToVM(answer.getDoTime())</span><br><span class="line">    )));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RestResponse.ok(scoreVm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改">修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Void&gt; <span class="title function_">edit</span><span class="params">(<span class="meta">@RequestBody</span> SubjectEditRequestVM model)</span> &#123;</span><br><span class="line">    <span class="comment">// VM → Entity</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">entity</span> <span class="operator">=</span> modelMapper.map(model, Subject.class);</span><br><span class="line">    subjectService.updateById(entity);</span><br><span class="line">    <span class="comment">// 返回成功</span></span><br><span class="line">    <span class="keyword">return</span> RestResponse.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟新增逻辑差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse <span class="title function_">edit</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> ExamPaperSubmitVM vm)</span> &#123;</span><br><span class="line">    <span class="comment">// 校验 &amp; 状态检查</span></span><br><span class="line">    <span class="keyword">if</span> (vm.getAnswerItems().stream().anyMatch(i -&gt; i.getDoRight()==<span class="literal">null</span> &amp;&amp; i.getScore()==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.fail(<span class="number">2</span>, <span class="string">&quot;有未批改题目&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ExamPaperAnswer</span> <span class="variable">answer</span> <span class="operator">=</span> examPaperAnswerService.selectById(vm.getId());</span><br><span class="line">    <span class="keyword">if</span> (ExamPaperAnswerStatusEnum.fromCode(answer.getStatus()) == ExamPaperAnswerStatusEnum.Complete) &#123;</span><br><span class="line">        <span class="keyword">return</span> RestResponse.fail(<span class="number">3</span>, <span class="string">&quot;试卷已完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务 &amp; 事件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">score</span> <span class="operator">=</span> examPaperAnswerService.judge(vm);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getCurrentUser();</span><br><span class="line">    eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UserEvent</span>(<span class="keyword">new</span> <span class="title class_">UserEventLog</span>(</span><br><span class="line">        user.getId(), user.getUserName(), user.getRealName(), <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">        user.getUserName() + <span class="string">&quot;批改试卷&quot;</span> + answer.getPaperName() + <span class="string">&quot;得分&quot;</span> + score</span><br><span class="line">    )));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RestResponse.ok(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除">删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;Void&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    subjectService.deleteById(id);</span><br><span class="line">    <span class="keyword">return</span> RestResponse.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询">分页查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/pageList&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestResponse&lt;PageInfo&lt;ExamPaperAnswerPageResponseVM&gt;&gt; <span class="title function_">pagelist</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestBody</span> <span class="meta">@Valid</span> ExamPaperAnswerPageVM model)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ——— 固定模板 ———</span></span><br><span class="line">    model.setCreateUser(getCurrentUser().getId());</span><br><span class="line">    PageInfo&lt;ExamPaperAnswer&gt; pageInfo = examPaperAnswerService.studentPage(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ——— 流式转换 &amp; 工具调用 ———</span></span><br><span class="line">    PageInfo&lt;ExamPaperAnswerPageResponseVM&gt; page = PageInfoHelper.copyMap(pageInfo, e -&gt; &#123;</span><br><span class="line">        <span class="type">ExamPaperAnswerPageResponseVM</span> <span class="variable">vm</span> <span class="operator">=</span> modelMapper.map(e, ExamPaperAnswerPageResponseVM.class);</span><br><span class="line">        vm.setSubjectName(subjectService.selectById(vm.getSubjectId()).getName());</span><br><span class="line">        vm.setDoTime(ExamUtil.secondToVM(e.getDoTime()));</span><br><span class="line">        vm.setSystemScore(ExamUtil.scoreToVM(e.getSystemScore()));</span><br><span class="line">        vm.setUserScore(ExamUtil.scoreToVM(e.getUserScore()));</span><br><span class="line">        vm.setPaperScore(ExamUtil.scoreToVM(e.getPaperScore()));</span><br><span class="line">        vm.setCreateTime(DateTimeUtil.dateFormat(e.getCreateTime()));</span><br><span class="line">        <span class="keyword">return</span> vm;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RestResponse.ok(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分页查询 → map 转 VM → RestResponse</p><h2 id="注解">注解</h2><p>动态参数用 <code>@PathVariable</code>，将 URL 中的占位符参数绑定到控制器方法的参数上。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/subject/select/&#123;id&#125;&quot;, method = RequestMethod.POST)</span><br><span class="line">public RestResponse&lt;SubjectEditRequestVM&gt; select(@PathVariable Integer id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用了 <code>@RequestMapping</code>，明确 URL 和 HTTP 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/subject/select/&#123;id&#125;&quot;, method = RequestMethod.POST)</span><br><span class="line">public RestResponse&lt;SubjectEditRequestVM&gt; select(@PathVariable Integer id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以优化，使用PostMapping代替</p></blockquote><blockquote><p><em>@RestController</em></p><p>等同于 <code>@Controller</code> + <code>@ResponseBody</code>。</p><p>将该类标记为 Spring MVC 的控制器，并自动将方法返回值序列化为 JSON（或其他格式）写入 HTTP 响应体。</p></blockquote><blockquote><h2 id="RequestBody"><code>@RequestBody</code></h2><ul><li><strong>作用</strong>：<ul><li>将 HTTP 请求体中的 JSON（或其他格式）反序列化为方法参数的 Java 对象。</li></ul></li><li><strong>使用场景</strong>：<ul><li>接收 POST、PUT 等请求中传来的 JSON 数据。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/edit&quot;)</span><br><span class="line">public RestResponse edit(@RequestBody ExamPaperSubmitVM vm) &#123; ... &#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h2 id="Valid"><code>@Valid</code></h2><ul><li><strong>作用</strong>：<ul><li>启用对方法参数（通常与 <code>@RequestBody</code> 或表单对象）上的 JSR-303/JSR-380 校验注解（如 <code>@NotNull</code>、<code>@Size</code>）的校验。</li></ul></li><li><strong>使用场景</strong>：<ul><li>当你在 VM 或 DTO 类上使用了校验注解，需要在 Controller 中自动触发校验，并在验证失败时抛出异常。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">、</span><br><span class="line">public RestResponse edit(@RequestBody @Valid ExamPaperSubmitVM vm) &#123; ... &#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h2 id="Autowired"><code>@Autowired</code></h2><ul><li><strong>作用</strong>：<ul><li>将 Spring 容器中的 Bean 自动注入到当前类的字段或构造函数中。</li></ul></li><li><strong>使用场景</strong>：<ul><li>在 Controller、Service 等类中注入依赖的 service、repository、publisher 等。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">public ExamPaperAnswerController(ExamPaperAnswerService examPaperAnswerService, ...) &#123;</span><br><span class="line">    this.examPaperAnswerService = examPaperAnswerService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h2 id="EventListener-ApplicationEventPublisher）">@EventListener / ApplicationEventPublisher）</h2><ul><li><strong>作用</strong>：<ul><li><strong><code>ApplicationEventPublisher</code></strong>：通过 <code>publishEvent()</code> 发布自定义事件。</li><li><strong><code>@EventListener</code></strong>（可选）：在其他 bean 中使用，监听并处理被发布的事件。</li></ul></li><li><strong>使用场景</strong>：<ul><li>解耦业务逻辑，通过事件驱动在不同模块间传递消息。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventPublisher.publishEvent(new UserEvent(userEventLog));</span><br></pre></td></tr></table></figure></blockquote>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/redis/">redis</category>
      
      
      <comments>https://blog.tokenlen.top/2025/04/26/work1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode二分查找专项</title>
      <link>https://blog.tokenlen.top/2025/04/19/leetcode1/</link>
      <guid>https://blog.tokenlen.top/2025/04/19/leetcode1/</guid>
      <pubDate>Fri, 18 Apr 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;二分查找&lt;/h1&gt;
&lt;p&gt;二分查找的原理就是取一个中间值，然后那中间值和目标值进行比较。&lt;/p&gt;
&lt;p&gt;如果比目标值大的话，说明目标值在左边，中间值mid就变为右边right&lt;/p&gt;
&lt;p&gt;相对应的，小于目标值的话，说明目标值在右边，中间值mid就变为left&lt;/p&gt;
&lt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>二分查找</h1><p>二分查找的原理就是取一个中间值，然后那中间值和目标值进行比较。</p><p>如果比目标值大的话，说明目标值在左边，中间值mid就变为右边right</p><p>相对应的，小于目标值的话，说明目标值在右边，中间值mid就变为left</p><p>二分查找的总结：</p><p>必须数组/序列是<strong>有序的</strong>，二分前必须先进行排序。</p><p>要确定搜索区间常见形式：<code>[lo, hi]</code>、<code>[lo, hi)</code>、<code>(lo, hi]</code>、<code>(lo, hi)</code></p><p>确定开区间闭区间</p><p>开区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>闭区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mid的取值：通常用 <code>mid = lo + (hi - lo) / 2</code>（或无符号右移 <code>&gt;&gt;&gt; 1</code>）这样来防止溢出</p><p>还要设计check条件：</p><p>将问题转化为一个布尔函数 <code>check(mid)</code>，能准确告诉你“mid 是否满足某侧条件”。</p><p>根据 <code>check(mid)</code> 结果，把 <code>lo</code> 或 <code>hi</code> 缩到 <code>mid</code> 及其左／右一侧。</p><h2 id="2563-统计公平数对的数目"><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">2563. 统计公平数对的数目</a></h2><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和两个整数 <code>lower</code> 和 <code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p><p>如果 <code>(i, j)</code> 数对满足以下情况，则认为它是一个 <strong>公平数对</strong> ：</p><ul><li><code>0 &lt;= i &lt; j &lt; n</code>，且</li><li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution119</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countFairPairs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lower, <span class="type">int</span> upper)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> lowerBound(nums,j,upper-nums[j]+<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> lowerBound(nums,j,lower-nums[j]);</span><br><span class="line">            ans += r-l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用二分查找，最后target=right</p><p><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code>进行移项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意要在 [<span class="number">0</span>, j-<span class="number">1</span>] 中二分，因为题目要求两个下标 i &lt; j</span><br></pre></td></tr></table></figure><p>因为不相等的话upper那个就要+1</p><p>lower-nums[i]</p><p>upper-nums[j]+1</p><p>最后两个数量相减的和就是对数，就是答案</p><h2 id="33-搜索旋转排序数组"><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line">            mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] ==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target&gt;=nums[start]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    end  = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target&lt;=nums[end]&amp;&amp;target&gt;nums[mid])&#123;</span><br><span class="line">                    start = mid +<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个二分查找</p><p>if (nums[start]&lt;=nums[mid]){<br>if (target&gt;=nums[start]&amp;&amp;target&lt;nums[mid]){<br>end  = mid-1;<br>}else {<br>start = mid+1;<br>}<br>}</p><p>如果在start小于mid的话</p><p>如果是target值在start和mid值之间的话</p><p>end = mid-1</p><p>否则的话，也就是说target值不在这</p><p>start=mid+1</p><p>else {<br>if (target&lt;=nums[end]&amp;&amp;target&gt;nums[mid]){<br>start = mid +1;<br>}<br>else {<br>end = mid-1;<br>}<br>}</p><p>如果target值在mid和end之间的话</p><p>start=mid</p><p>不在的话end=mid-1</p><p>这样进行二分查找就能找到那个target值</p><p>如果这样都没找到话return-1</p><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> lowBound(nums,target);</span><br><span class="line">        <span class="keyword">if</span> (start==nums.length||nums[start] !=target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lowBound(nums,target+<span class="number">1</span>)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start,end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是查找一个target值的目标为止，我们先设定好一个二分查找的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意的是，这里的<strong>mid开头并不是0</strong></p><p>所以mid=left+(right-left)/2</p><p>while 循环的条件，如果是 left &lt;= right，就是闭区间；如果是 left &lt; right，就是半闭半开区间；如果是 left + 1 &lt; right，就是开区间。这里我们选择开区间，就是不可以取到边界值的</p><p>先把目标值找出来就是start</p><p>int start = lowBound(nums,target);</p><p>如果数组里没有这个数，或者是超出范围的话，返回{-1，-1}</p><p>int end = lowBound(nums,target+1)-1;</p><p>然后找出end结束值</p><p>要想找到 ≤target 的最后一个数，无需单独再写一个二分。我们可以先找到这个数的右边相邻数字，也就是 &gt;target 的第一个数。在所有数都是整数的前提下，&gt;target 等价于 ≥target+1，这样就可以复用我们已经写好的二分函数了，即 lowerBound(nums, target + 1)，算出这个数的下标后，将其减一，就得到 ≤target 的最后一个数的下标。</p><p>所以最后的数组就是{start,end}</p><h2 id="35-搜索插入位置"><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的二分查找，直接开始就行</p><p>left &lt;= right，就是闭区间，所以说边界值是可以取到的</p><h2 id="704-二分查找"><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution704</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单的二分查找</p><p>注意的是</p><p>一般选择闭区间来写，这样right可以取到</p><p>right = nums.length-1,while(left&lt;=right)</p><p>一般这样写</p><p>然后mid = left+(right-left)/2防止溢出</p><h2 id="744-寻找比目标字母大的最小字母"><a href="https://leetcode.cn/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h2><p>给你一个字符数组 <code>letters</code>，该数组按<strong>非递减顺序</strong>排序，以及一个字符 <code>target</code>。<code>letters</code> 里<strong>至少有两个不同</strong>的字符。</p><p>返回 <code>letters</code> 中大于 <code>target</code> 的最小的字符。如果不存在这样的字符，则返回 <code>letters</code> 的第一个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution744</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>,r=letters.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (letters[mid]&gt;target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[l]&gt;target?letters[l]:letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的二分查找，而且是闭区间的，</p><p>int mid=(l+r)&gt;&gt;1;这里相当于取l+r的中点，而且防止了mid的溢出</p><h2 id="2529-正整数和负整数的最大计数"><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">2529. 正整数和负整数的最大计数</a></h2><p>给你一个按 <strong>非递减顺序</strong> 排列的数组 <code>nums</code> ，返回正整数数目和负整数数目中的最大值。</p><ul><li>换句话讲，如果 <code>nums</code> 中正整数的数目是 <code>pos</code> ，而负整数的数目是 <code>neg</code> ，返回 <code>pos</code> 和 <code>neg</code>二者中的最大值。</li></ul><p><strong>注意：</strong><code>0</code> 既不是正整数也不是负整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumCount</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                neg++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(neg,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的递归写法</p><p>使用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2529</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumCount</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">negativeCount</span> <span class="operator">=</span> findFirstIndex(nums, <span class="number">0</span>); <span class="comment">// 第一个 &gt;= 0 的位置就是负数个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">positiveCount</span> <span class="operator">=</span> n - findFirstIndex(nums, <span class="number">1</span>); <span class="comment">// 第一个 &gt; 0 的位置就是正数个数</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(negativeCount, positiveCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回第一个 &gt;= target 的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findFirstIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>); <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2300-咒语和药水的成功对数"><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数</a></h2><p>给你两个正整数数组 <code>spells</code> 和 <code>potions</code> ，长度分别为 <code>n</code> 和 <code>m</code> ，其中 <code>spells[i]</code> 表示第 <code>i</code> 个咒语的能量强度，<code>potions[j]</code> 表示第 <code>j</code> 瓶药水的能量强度。</p><p>同时给你一个整数 <code>success</code> 。一个咒语和药水的能量强度 <strong>相乘</strong> 如果 <strong>大于等于</strong> <code>success</code> ，那么它们视为一对 <strong>成功</strong> 的组合。</p><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>pairs</code>，其中 <code>pairs[i]</code> 是能跟第 <code>i</code> 个咒语成功组合的 <strong>药水</strong> 数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2300</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] successfulPairs(<span class="type">int</span>[] spells, <span class="type">int</span>[] potions, <span class="type">long</span> success)&#123;</span><br><span class="line">        Arrays.sort(potions);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;spells.length;i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">target</span> <span class="operator">=</span> (success-<span class="number">1</span>)/spells[i];</span><br><span class="line">            <span class="keyword">if</span> (target&lt;potions[potions.length-<span class="number">1</span>])&#123;</span><br><span class="line">                spells[i] = potions.length-upperBound(potions,(<span class="type">int</span>)target);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                spells[i]=<span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> spells;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">upperBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于正整数来说：<br>$$<br>xy≥success 等价于 y≥⌈<br>x<br>success<br>​<br>⌉。<br>$$<br>为了方便二分，可以利用如下恒等式：<br>$$<br>⌈<br>b/a<br>​<br>⌉=⌊</p><p>a+b−1/b<br>​<br>⌋=⌊</p><p>a−1/b<br>​<br>⌋+1<br>$$<br>所以我们可以得到<br>$$<br>y&gt;⌊</p><p>success−1/x<br>​<br>⌋<br>$$<br>对 potions 排序后，就可以二分查找了：设 x=spells[i]，j 是最小的满足 potions[j]&gt;<br>(success−1)/x</p><p>j的下标，由于数组已经排序，那么下标大于 j 的也同样满足该式，这一共有 m−j 个，其中 m 是 potions 的长度。</p><h2 id="1385-两个数组间的距离值"><a href="https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/">1385. 两个数组间的距离值</a></h2><p>给你两个整数数组 <code>arr1</code> ， <code>arr2</code> 和一个整数 <code>d</code> ，请你返回两个数组之间的 <strong>距离值</strong> 。</p><p>「<strong>距离值</strong>」 定义为符合此距离要求的元素数目：对于元素 <code>arr1[i]</code> ，不存在任何元素 <code>arr2[j]</code> 满足 <code>|arr1[i]-arr2[j]| &lt;= d</code></p><p>对于 <em>arr</em>1 中的元素 <em>x</em>，如果 <em>arr</em>2 没有在 [<em>x</em>−<em>d</em>,<em>x</em>+<em>d</em>] 中的数，那么答案加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1385</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheDistanceValue</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:arr1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> Arrays.binarySearch(arr2,x-d);</span><br><span class="line">            <span class="keyword">if</span> (i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                i=~i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==arr2.length||arr2[i]&gt;x+d)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接遍历使用二分查找，查找有没有在arr2中的值</p><p>如果没有的化，i是负数，取反，找到应该插入的位置</p><p>如果不存在这个数的话，计数ans++</p><p>return ans</p><h2 id="2389-和有限的最长子序列"><a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/">2389. 和有限的最长子序列</a></h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，和一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。</p><p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是 <code>nums</code> 中 元素之和小于等于 <code>queries[i]</code> 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度 。</p><p><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2389</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">upperBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] answerQueries(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i]+=nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;queries.length;i++)&#123;</span><br><span class="line">            queries[i] = upperBound(nums,queries[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是先求出这个前缀和</p><p>然后再进行遍历，queries[i]赋值于二分查找能不能找到这个值</p><p>这里的等于号，<strong>求大于用 &gt;，求大于等于用 &gt;=</strong></p><h2 id="1170-比较字符串最小字母出现频次"><a href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/">1170. 比较字符串最小字母出现频次</a></h2><p>定义一个函数 <code>f(s)</code>，统计 <code>s</code> 中**（按字典序比较）最小字母的出现频次** ，其中 <code>s</code> 是一个非空字符串。</p><p>例如，若 <code>s = &quot;dcce&quot;</code>，那么 <code>f(s) = 2</code>，因为字典序最小字母是 <code>&quot;c&quot;</code>，它出现了 2 次。</p><p>现在，给你两个字符串数组待查表 <code>queries</code> 和词汇表 <code>words</code> 。对于每次查询 <code>queries[i]</code> ，需统计 <code>words</code> 中满足 <code>f(queries[i])</code> &lt; <code>f(W)</code> 的 <strong>词的数目</strong> ，<code>W</code> 表示词汇表 <code>words</code> 中的每个词。</p><p>请你返回一个整数数组 <code>answer</code> 作为答案，其中每个 <code>answer[i]</code> 是第 <code>i</code> 次查询的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1170</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numSmallerByFrequency(String[] queries, String[] words)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            nums[i] = f(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> f(queries[i]);</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r= n;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]&gt;x)&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i]=n-l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            ++cnt[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先把f(x)函数写出来，就是统计words的字典序比较最小字母的出现频次</p><p>然后把f(w)计算出来，存入数组nums,进行排序</p><p>然后进行二分查找，进行比较，找到在 <em><strong>nums</strong></em> 中二分查找第一个大于 <em>f</em>(q) 的位置 <em>i</em></p><p>然后后面的就都满足f(q)&lt;f(w)，所以数量就是n-i</p><p>把n-i存入ans[i]中，然后返回ans即可</p><h2 id="2080-区间内查询数字的频率"><a href="https://leetcode.cn/problems/range-frequency-queries/">2080. 区间内查询数字的频率</a></h2><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 <strong>频率</strong> 。</p><p>子数组中一个值的 <strong>频率</strong> 指的是这个子数组中这个值的出现次数。</p><p>请你实现 <code>RangeFreqQuery</code> 类：</p><ul><li><code>RangeFreqQuery(int[] arr)</code> 用下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 构造一个类的实例。</li><li><code>int query(int left, int right, int value)</code> 返回子数组 <code>arr[left...right]</code> 中 <code>value</code> 的 <strong>频率</strong> 。</li></ul><p>一个 <strong>子数组</strong> 指的是数组中一段连续的元素。<code>arr[left...right]</code> 指的是 <code>nums</code> 中包含下标 <code>left</code> 和 <code>right</code> <strong>在内</strong> 的中间一段连续元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeFreQuery</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBound</span><span class="params">(List&lt;Integer&gt; a,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,right = a.size();</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a.get(mid)&lt;target)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, List&lt;Integer&gt;&gt; pos = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RangeFreQuery</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            pos.computeIfAbsent(arr[i],k-&gt;<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; a = pos.get(value);</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowBound(a,right+<span class="number">1</span>)-lowBound(a,left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3488-距离最小相等元素查询"><a href="https://leetcode.cn/problems/closest-equal-element-queries/">3488. 距离最小相等元素查询</a></h2><p>给你一个 <strong>循环</strong> 数组 <code>nums</code> 和一个数组 <code>queries</code> 。</p><p>对于每个查询 <code>i</code> ，你需要找到以下内容：</p><ul><li>数组 <code>nums</code> 中下标 <code>queries[i]</code> 处的元素与 <strong>任意</strong> 其他下标 <code>j</code>（满足 <code>nums[j] == nums[queries[i]]</code>）之间的 <strong>最小</strong> 距离。如果不存在这样的下标 <code>j</code>，则该查询的结果为 <code>-1</code> 。</li></ul><p>返回一个数组 <code>answer</code>，其大小与 <code>queries</code> 相同，其中 <code>answer[i]</code> 表示查询<code>i</code>的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3488</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">solveQueries</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries)</span>&#123;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; indices = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            indices.computeIfAbsent(nums[i],k-&gt;<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(i);</span><br><span class="line">        &#125;<span class="comment">//构建hash表，indices存储</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; p :indices.values())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i0</span> <span class="operator">=</span> p.get(<span class="number">0</span>);</span><br><span class="line">            p.add(<span class="number">0</span>,p.get(p.size()-<span class="number">1</span>)-n);<span class="comment">//循环向左的哨兵</span></span><br><span class="line">            p.add(i0+n);<span class="comment">//循环向右的哨兵</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queries.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i :queries)&#123;</span><br><span class="line">            List&lt;Integer&gt; p = indices.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (p.size()==<span class="number">3</span>)&#123;</span><br><span class="line">                ans.add(-<span class="number">1</span>);<span class="comment">//没有，只有一次</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Collections.binarySearch(p,i);<span class="comment">//二分查找位置，i在p的位置</span></span><br><span class="line">                ans.add(Math.min(i-p.get(j-<span class="number">1</span>),p.get(j+<span class="number">1</span>)-i));<span class="comment">//比较前一个和后一个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2563-统计公平数对的数目-2"><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">2563. 统计公平数对的数目</a></h2><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和两个整数 <code>lower</code> 和 <code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p><p>如果 <code>(i, j)</code> 数对满足以下情况，则认为它是一个 <strong>公平数对</strong> ：</p><ul><li><code>0 &lt;= i &lt; j &lt; n</code>，且</li><li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countFairPairs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lower, <span class="type">int</span> upper)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> lowerBound(nums,j,upper-nums[j]+<span class="number">1</span>);<span class="comment">//右边的边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> lowerBound(nums,j,lower-nums[j]);<span class="comment">//左边的边界</span></span><br><span class="line">            ans += r-l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/most-beautiful-item-for-each-query/">2070. 每一个查询的最大美丽值</a></p><p>给你一个二维整数数组 <code>items</code> ，其中 <code>items[i] = [pricei, beautyi]</code> 分别表示每一个物品的 <strong>价格</strong> 和 <strong>美丽值</strong> 。</p><p>同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>queries</code> 。对于每个查询 <code>queries[j]</code> ，你想求出价格小于等于 <code>queries[j]</code> 的物品中，<strong>最大的美丽值</strong> 是多少。如果不存在符合条件的物品，那么查询的结果为 <code>0</code> 。</p><p>请你返回一个长度与 <code>queries</code> 相同的数组 <code>answer</code>，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><p><strong>二分查找的时候一般都要将数组进行排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2070</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">upperBound</span><span class="params">(<span class="type">int</span>[][] items, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> items.length;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (items[mid][<span class="number">0</span>]&gt;target)&#123;</span><br><span class="line">                    right =mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maximumBeauty(<span class="type">int</span>[][] items, <span class="type">int</span>[] queries)&#123;</span><br><span class="line">        Arrays.sort(items,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);<span class="comment">//排序规则</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">            items[i][<span class="number">1</span>] = Math.max(items[i][<span class="number">1</span>],items[i-<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//更新美丽值，是前一个位置的最大美丽值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;queries.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> upperBound(items,queries[i]);</span><br><span class="line">            queries[i] =j&gt;<span class="number">0</span>?items[j-<span class="number">1</span>][<span class="number">1</span>]:<span class="number">0</span>;<span class="comment">//查找到了，就是前一个的最大美丽值，不是的话就是0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1146-快照数组"><a href="https://leetcode.cn/problems/snapshot-array/">1146. 快照数组</a></h2><p>实现支持下列接口的「快照数组」- SnapshotArray：</p><ul><li><code>SnapshotArray(int length)</code> - 初始化一个与指定长度相等的 类数组 的数据结构。<strong>初始时，每个元素都等于</strong> <strong>0</strong>。</li><li><code>void set(index, val)</code> - 会将指定索引 <code>index</code> 处的元素设置为 <code>val</code>。</li><li><code>int snap()</code> - 获取该数组的快照，并返回快照的编号 <code>snap_id</code>（快照号是调用 <code>snap()</code> 的总次数减去 <code>1</code>）。</li><li><code>int get(index, snap_id)</code> - 根据指定的 <code>snap_id</code> 选择快照，并返回该快照指定索引 <code>index</code> 的值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void set(int index, int val) &#123;</span><br><span class="line">    history.computeIfAbsent(index, k -&gt; new ArrayList&lt;&gt;())</span><br><span class="line">           .add(new int[]&#123;curSnapId, val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>computeIfAbsent</code> 方法：如果 <code>history</code> 里<strong>没有</strong>当前 <code>index</code>，就<strong>自动新建</strong>一个空的 <code>ArrayList&lt;int[]&gt;</code>；如果有，就直接用已有的列表。</p><p>然后 <code>.add(new int[]&#123;curSnapId, val&#125;)</code>：表示把当前的<strong>快照 ID 和对应的值</strong>作为一个数组 <code>&#123;curSnapId, val&#125;</code> 加到列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> curSnapId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer,List&lt;<span class="type">int</span>[]&gt;&gt; history = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnapshotArray</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        history.computeIfAbsent(index,k-&gt;<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;curSnapId,val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snap</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curSnapId++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> snapId)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!history.containsKey(index))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; h = history.get(index);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span>  <span class="operator">=</span> search(h,snapId);</span><br><span class="line">        <span class="keyword">return</span> j&lt;<span class="number">0</span>?<span class="number">0</span>:h.get(j)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(List&lt;<span class="type">int</span>[]&gt; h,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> h.size();</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (h.get(mid)[<span class="number">0</span>]&lt;=x)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意数组h.get(mid)[0]是指的curSnapId</p><p>跟snapId相对应了</p><h2 id="981-基于时间的键值存储"><a href="https://leetcode.cn/problems/time-based-key-value-store/">981. 基于时间的键值存储</a></h2><p>设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。</p><p>实现 <code>TimeMap</code> 类：</p><ul><li><code>TimeMap()</code> 初始化数据结构对象</li><li><code>void set(String key, String value, int timestamp)</code> 存储给定时间戳 <code>timestamp</code> 时的键 <code>key</code> 和值 <code>value</code>。</li><li><code>String get(String key, int timestamp)</code> 返回一个值，该值在之前调用了 <code>set</code>，其中 <code>timestamp_prev &lt;= timestamp</code> 。如果有多个这样的值，它将返回与最大  <code>timestamp_prev</code> 关联的值。如果没有值，则返回空字符串（<code>&quot;&quot;</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;Info&gt;&gt; tmap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">        String value;</span><br><span class="line">        <span class="type">int</span> timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(String value, <span class="type">int</span> timestamp)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.timestamp = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        tmap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, <span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        tmap.computeIfAbsent(key,k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(<span class="keyword">new</span> <span class="title class_">Info</span>(value, timestamp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key, <span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tmap.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Info&gt; tmp = tmap.get(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = tmp.size();</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp.get(mid).timestamp &gt; timestamp)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt; <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : tmp.get(left).value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟1146一样</p><h2 id="658-找到-K-个最接近的元素"><a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></h2><p>给定一个 <strong>排序好</strong> 的数组 <code>arr</code> ，两个整数 <code>k</code> 和 <code>x</code> ，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。</p><p>整数 <code>a</code> 比整数 <code>b</code> 更接近 <code>x</code> 需要满足：</p><ul><li><code>|a - x| &lt; |b - x|</code> 或者</li><li><code>|a - x| == |b - x|</code> 且 <code>a &lt; b</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution658</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span>  <span class="operator">=</span> n-k;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid+k&lt;n&amp;&amp;x-arr[mid]&gt;arr[mid+k]-x)&#123;</span><br><span class="line">                left= mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>left;i&lt;left+k;i++)&#123;<span class="comment">//找到&lt;=x</span></span><br><span class="line">            list.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if (mid+k&lt;n&amp;&amp;x-arr[mid]&gt;arr[mid+k]-x){<br>left= mid+1;<br>}else {<br>right = mid-1;<br>}</p><p>mid+k&lt;n保证不越界</p><p>然后</p><p>x-arr[mid]&gt;arr[mid+k]-x说明还是左边的距离更大，应该往右移动</p><p>所以mid = left+1</p><p>直到找到&lt;=x的那个点，加入list之中</p><h2 id="1287-有序数组中出现次数超过25-的元素"><a href="https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/">1287. 有序数组中出现次数超过25%的元素</a></h2><p>给你一个非递减的 <strong>有序</strong> 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。</p><p>请你找到并返回这个整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1287</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSpecialInteger</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span>  <span class="operator">=</span> <span class="number">0</span>,r = n/<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l]==arr[r]) <span class="keyword">return</span> arr[r];</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为如果某个数字的出现次数超过了 25%，那么<strong>在它第一次出现的位置</strong>和<strong>它向右移动 <code>n/4</code> 的位置</strong>，<strong>一定也还是它本身</strong>。</p><p>当l=r的时候，就是这个数了</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/04/19/leetcode1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis基础</title>
      <link>https://blog.tokenlen.top/2025/04/19/redis1/</link>
      <guid>https://blog.tokenlen.top/2025/04/19/redis1/</guid>
      <pubDate>Fri, 18 Apr 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;redis数据类型&lt;/h1&gt;
&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;
&lt;h3</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>redis数据类型</h1><h2 id="基础">基础</h2><h3 id="String">String</h3><p>redis中的数据是以键值对的形式存储的，然后存储是以二进制安全的形式进行存储</p><p>默认是不支持中文的，但连接的时候可以加上参数–raw，就是以原始的形式进行存储。这样就可以看到中文了</p><p><strong>set</strong>:set key value 设置一个键值对</p><p><strong>get</strong>:get key,返回的是值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name 你好</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">你好</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>del</strong>：del key，用来删除一个键</p><p><strong>exists</strong>:exists key 用来看一个键是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>返回1表明存在</p><p><strong>keys</strong>:key * 用来查看所有的键，支持通配符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">name</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>flushall</strong>:flushall用来刷新所有的键</p><p>TTL：TTL key，用来查看一个键的过期时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ttl key</span><br><span class="line">-2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">-1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>返回-1表示没有过期时间</p><p>返回-2表示已经过期</p><p><strong>expire</strong>:expire key time 设置一个键的过期时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire name 99</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">95</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">93</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">93</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>setex</strong>:setex key time value,设置一个过期时间的键值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex age 99 88</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">92</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">91</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">90</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>setnx</strong>:setnx key value,只有当键不存在的时候才设置值</p><h3 id="List">List</h3><p>list是一个有序集合，可以重复</p><p>lpush:lpush Listname value，添加到头</p><p>rpush:rpush Listname value,添加到尾</p><p>lrange：lrange Listname start end，查看一个列表</p><p>这里index是从0开始的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list 88</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; lpush list 99</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt; lpush list 100</span><br><span class="line">3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">100</span><br><span class="line">99</span><br><span class="line">88</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>lpop:lpop Listname，从头部弹出元素</p><p>rpop:rpop Listname，从尾部弹出元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">100</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">99</span><br><span class="line">88</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>也可以一次性删除多个元素，后面加上个数就可以了</p><p>llen: llen Listname,查看列表的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>ltrim:ltrim name start end，只保留start-end的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ltrim list 0 -1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">99</span><br><span class="line">88</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="set">set</h3><p>没有顺序，不能重复</p><p>sadd:sadd name value，添加元素</p><p>smembers：smembers name，查看元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd class 1 2 3 4 5 8</span><br><span class="line">6</span><br><span class="line">127.0.0.1:6379&gt; smembers</span><br><span class="line">ERR wrong number of arguments for &#x27;smembers&#x27; command</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; smembers class</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>sismember:sismember name value,查看元素是否在set集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember class 8</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; sismember class 6</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>srem:srem name value，删除元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem class 8</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; smembers class</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="sortedset">sortedset</h3><p>有序集合，每个集合中的元素，都会关联一个浮点类型的分数</p><p>按照这个分数进行排序，从小到大</p><p>元素是唯一的，但分数是可以重复的</p><p>zadd:zadd name score value,插入一个元素</p><p>zrange:zrange name start end withscore，查看集合中的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd r 800 a 600 b 700 c</span><br><span class="line">3</span><br><span class="line">127.0.0.1:6379&gt; zrange r 0 -1</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange r 0 -1 withscores</span><br><span class="line">b</span><br><span class="line">600</span><br><span class="line">c</span><br><span class="line">700</span><br><span class="line">a</span><br><span class="line">800</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>zscore:zscore name value</strong>，查看该元素的分数</p><p><strong>zrank:zrank name value</strong>,查看排名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrank r b</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; zscore r b</span><br><span class="line">600</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>zrevrank:zrevrank name value,查看排名，从大到小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrank r b</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>zrem:zrem name value，删除集合中的元素</p><p>可以做成排行榜</p><h3 id="hash">hash</h3><p><strong>hset:hset name key value</strong>,设置键值对</p><p><strong>hget name key</strong> ，获取值</p><p><strong>hegt:hgetall name</strong>,获取全部的键值对</p><p><strong>hdel:hdel name key</strong>,删除键值对</p><p>hexists:hexists name key,键值对是否存在</p><p><strong>hkeys:hkeys name</strong>,获取所有键</p><p><strong>hlen:hlen name</strong> 获取数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset person name lihua age 100</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt; hkeys *</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hkeys name</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hkeys person</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">127.0.0.1:6379&gt; hlen person</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt; hgetall person</span><br><span class="line">name</span><br><span class="line">lihua</span><br><span class="line">age</span><br><span class="line">100</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式">发布订阅模式</h2><p><strong>subscribe:subscribe name</strong>,订阅频道</p><p><strong>publish:publish name value</strong>,发布消息到name</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe zhou</span><br><span class="line">subscribe</span><br><span class="line">zhou</span><br><span class="line">1</span><br><span class="line">message</span><br><span class="line">zhou</span><br><span class="line">你好啊</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish zhou 你好啊</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>消息无法持久化，无法记录历史消息</p><h2 id="stream">stream</h2><p><strong>xadd name id key value</strong>，添加一条消息，id可以使用*自动生成id</p><p><strong>xlen name</strong>,查看消息的数量</p><p><strong>xrange name - +</strong>,查看所有的消息</p><p>**xdel name id,**删除一条消息</p><p><strong>xtrim name maxlen 0</strong>,删除所有消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd stram 1-0 man 1</span><br><span class="line">1-0</span><br><span class="line">127.0.0.1:6379&gt; xadd stram 2-0 man 2</span><br><span class="line">2-0</span><br><span class="line">127.0.0.1:6379&gt; xrange stram - +</span><br><span class="line">1-0</span><br><span class="line">man</span><br><span class="line">1</span><br><span class="line">2-0</span><br><span class="line">man</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt; xlen stram</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt; xadd stram 3-0 man 8</span><br><span class="line">3-0</span><br><span class="line">127.0.0.1:6379&gt; xrange stram 0 2</span><br><span class="line">1-0</span><br><span class="line">man</span><br><span class="line">1</span><br><span class="line">2-0</span><br><span class="line">man</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>xread count 2 block 1000  streams name 0</strong>,一次读取两条消息,没有消息阻塞1s,从0开始读取</p><p>0可以改成$符号，代表最新的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xread count 2 block 1000 streams stram 0</span><br><span class="line">stram</span><br><span class="line">1-0</span><br><span class="line">man</span><br><span class="line">1</span><br><span class="line">2-0</span><br><span class="line">man</span><br><span class="line">2</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>xgruop create name gname id</strong>,创建一个消费者组，在创建一个之前没存在的组的时候，需要参数mkstream</p><p><strong>xinfo groups name</strong> ,查看一个组的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup create redis group1 0 mkstream</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; xinfo groups redis</span><br><span class="line">name</span><br><span class="line">group1</span><br><span class="line">consumers</span><br><span class="line">0</span><br><span class="line">pending</span><br><span class="line">0</span><br><span class="line">last-delivered-id</span><br><span class="line">0-0</span><br><span class="line">entries-read</span><br><span class="line"></span><br><span class="line">lag</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>xgroup createconsumer name group consumer</strong>,创建一个消费者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xgroup createconsumer redis group1 consumer1</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; xgroup createconsumer redis group1 consumer2</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; xgroup createconsumer redis group1 consumer3</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; xinfo groups redis</span><br><span class="line">name</span><br><span class="line">group1</span><br><span class="line">consumers</span><br><span class="line">3</span><br><span class="line">pending</span><br><span class="line">0</span><br><span class="line">last-delivered-id</span><br><span class="line">0-0</span><br><span class="line">entries-read</span><br><span class="line"></span><br><span class="line">lag</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>xreadgroup group gname consumer count 2 block time streams name &gt;</strong>,读取最新的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xreadgroup group group1 consumer1 count 2 block 1000 streams redis &gt;</span><br></pre></td></tr></table></figure><h2 id="geospatial">geospatial</h2><p><strong>geoadd name 经纬度 name</strong>,添加一个经纬度</p><p><strong>geopos name name</strong>,获取一个经纬度</p><p><strong>geodist name A B</strong> ，计算两个地方的距离，默认是米，加上km为千米</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd city 116.41667 39.91668 beijing</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; geoadd city 116.41667 39.91667 shanghai</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; geopos shanghai</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geopos city beijing</span><br><span class="line">116.41667157411575317</span><br><span class="line">39.91668109162052502</span><br><span class="line">127.0.0.1:6379&gt; geopos city shanghai</span><br><span class="line">116.41667157411575317</span><br><span class="line">39.91667095273589183</span><br><span class="line">127.0.0.1:6379&gt; geodist city beijing shanghai KM</span><br><span class="line">0.0011</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>geosearch name frommember A byradius 800 KM</strong> ,搜索A，⚪800千米以内的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist city beijing shanghai KM</span><br><span class="line">0.0011</span><br><span class="line">127.0.0.1:6379&gt; geosearch city frommember shanghai byradius 0.0011 KM</span><br><span class="line">shanghai</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="bitmap">bitmap</h2><p>bitmap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。bitmap 支持的最大位数是 232 位，使用 512M 内存就可以存储多达 42.9 亿的字节信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value （offset位偏移量，从0开始）</span><br></pre></td></tr></table></figure><p>很适合用于「签到」这类只有两种取值的场景。比如按月存储，一个月最多 31 天，那么我们一个用于再某一个月的签到缓存二进制就是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000 00000 00000 00000 00000 00000 0</span><br></pre></td></tr></table></figure><p>当某天签到将 0 改成 1 即可。</p><p><strong>setbit name 第几位bit 1</strong>,第几位bit改为1</p><p><strong>get bit name bitnumber</strong>,获取第几位bit的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT key1 7 1</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; getbit key1 7</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; getbit key1 8</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>bitcount name start end</strong>,统计start到end1的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount key1 0 8</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>BITFIELD key</strong><br><strong>[GET type offset]</strong><br><strong>[SET type offset value]</strong><br><strong>[INCRBY type offset increment]</strong><br><strong>[OVERFLOW WRAP | SAT | FAIL]</strong></p><p><code>type</code>：字段类型，比如 <code>i8</code>、<code>u4</code>，表示有符号/无符号整数，占几位</p><ul><li><code>i8</code>：8 位有符号整数（-128 到 127）</li><li><code>u4</code>：4 位无符号整数（0 到 15）</li></ul><p><code>offset</code>：字段偏移位（第几个 bit）</p><ul><li>支持绝对偏移 <code>0</code>、<code>5</code>，或相对偏移（比如 <code>#0</code>）</li></ul><p><code>value</code> / <code>increment</code>：<strong>要设置的值或增加的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield key1 set u8 0 100</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u4 0 get u4 4</span><br><span class="line">6</span><br><span class="line">4</span><br><span class="line">127.0.0.1:6379&gt; bitfield key1 get u8 0</span><br><span class="line">100</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>BITFIELD mykey INCRBY i5 0 1</strong></p><p>把从第 <code>0</code> 位开始的 5 位有符号整数加 <code>1</code></p><p>BITFIELD mykey OVERFLOW SAT INCRBY u4 0 10</p><p>如果加法结果超出 <code>u4</code>（无符号 4 位整数最大 15），则使用 “饱和” 模式（最大值就是 15）</p><p><code>WRAP</code>（默认）：溢出后从头开始（环绕）</p><p><code>SAT</code>：饱和到最大或最小值</p><p><code>FAIL</code>：溢出时返回 null，不更新</p><p>签到系统模拟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 一个用于在 2021 年 8 月第一个签到了</span><br><span class="line">SETBIT user:sign:5:202108 0 1</span><br><span class="line"></span><br><span class="line"># 检查某个用户在 2021 年 8 月 3 号是否签到了</span><br><span class="line">GETBIT user:sign:5:202108 2</span><br><span class="line"></span><br><span class="line"># 统计某个用户在 2021 年 8 月签到了多少次</span><br><span class="line">BITCOUNT user:sign:5:202108</span><br><span class="line"></span><br><span class="line"># 获取某个用户在 2021 年 8 月首次签到</span><br><span class="line">BITPOS user:sign:5:202108 1</span><br><span class="line"></span><br><span class="line"># 获取某个用户在 2021 年 8 月首次漏签</span><br><span class="line">BITPOS user:sign:5:202108 0</span><br><span class="line"></span><br><span class="line"># 获取偏移量 0 的 3 位无符号整数</span><br><span class="line">BITFIELD user:sign:5:202108 get u3 0</span><br></pre></td></tr></table></figure><p>将一系列较小的数存在一个较大的位图中</p><p>bitfield key set u8 #1 100，将第1个位置设置成100</p><p>bitfield key get u8 #1,查看第一个位置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield player:1 set u32 #1 100</span><br><span class="line">0</span><br><span class="line"> bitfield player:1 get u32 #1</span><br><span class="line">100</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h2 id="hyperloglog">hyperloglog</h2><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>什么是基数？比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数（<strong>不重复元素个数</strong>）为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身</p><p>HyperLogLog 算法是一种非常巧妙的近似统计海量去重元素数量的算法。它内部维护了 16384 个桶（bucket）来记录各自桶的元素数量。当一个元素到来时，它会散列到其中一个桶，以一定的概率影响这个桶的计数值。因为是概率算法，所以单个桶的计数值并不准确，但是将所有的桶计数值进行调合均值累加起来，结果就会非常接近真实的计数值。</p><p>pfadd name  element,插入元素到name</p><p>pfcount name 返回基数的估计</p><p>pfmerge name1 name2 合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd cat 1</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; pfadd cat 2</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; pfadd cat 3</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; pfadd cat 4</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; pfadd cat 56</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; pfcount cat</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt; pfadd cat1 56</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; pfadd cat1 57</span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; pfmerge cat1 cat</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount cat1</span><br><span class="line">6</span><br><span class="line">127.0.0.1:6379&gt; pfcount cat</span><br><span class="line">5</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>合并之后的name在前面</p><p>基数统计可以用作统计活跃ip，统计非重复的数据</p><h1>redis事务</h1><p>Redis 事务是 Redis 提供的一种 <strong>原子性操作</strong>，使得一系列命令可以作为一个整体执行，从而确保操作的一致性和可靠性。事务中的命令要么全部成功，要么全部失败，不会出现部分成功的情况。</p><p>通过 <code>MULTI</code> 命令启动，进入事务模式，之后的所有命令都会被加入到事务队列中，但不会立即执行。</p><p>然后输入命令…</p><p>输入完成之后</p><p>通过 <code>EXEC</code> 命令提交执行，Redis 会按顺序依次执行在事务队列中的所有命令。</p><p>事务可以通过 <code>DISCARD</code> 命令放弃，丢弃事务队列中的所有命令。</p><p><code>which</code>监视一个或多个键。如果监视的键在事务执行前被其他客户端修改，事务会被中止。</p><p><code>UNWATCH</code>取消监视</p><p>$$<br>127.0.0.1:6379&gt; bitfield player:1 get u32 #1<br>100<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379(TX)&gt; set key1 8888<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set key2 8887<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set key2 8883<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set key3 883<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incy key3<br>ERR unknown command ‘incy’, with args beginning with: ‘key3’</p><p>127.0.0.1:6379(TX)&gt; incry key2<br>ERR unknown command ‘incry’, with args beginning with: ‘key2’</p><p>127.0.0.1:6379(TX)&gt; incr key2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; incr key1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; exec<br>EXECABORT Transaction discarded because of previous errors.</p><p>127.0.0.1:6379&gt;<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitfield player:1 get u32 #1</span><br><span class="line">100</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key1 8888</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key2 8887</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key2 8883</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key3 883</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incy key3</span><br><span class="line">ERR unknown command &#x27;incy&#x27;, with args beginning with: &#x27;key3&#x27;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379(TX)&gt; incry key2</span><br><span class="line">ERR unknown command &#x27;incry&#x27;, with args beginning with: &#x27;key2&#x27;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379(TX)&gt; incr key2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr key1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>这样的话，事务被终止了，体现了他的原子性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key3 883</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set key2 8887</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr key2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">8888</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">d</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">883</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">8888</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>执行成功的事务</p><h1>redis持久化</h1><p>因为redis是存储在内存之中的，所以关机后数据会消息</p><p>这个时候就需要redis持久化来保存数据</p><h2 id="RDB">RDB</h2><p>在指定时间间隔能对数据进行快照存储，类似 MySQL 的 dump 备份文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>在配置文件中修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 放行 IP 访问限制</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"># 后台启动</span><br><span class="line">daemonize yes</span><br><span class="line"># 日志存储目录及日志文件名</span><br><span class="line">logfile &quot;/usr/local/redis/log/redis.log&quot;</span><br><span class="line"># RDB 数据文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># RDB 数据文件和 AOF 数据文件的存储目录</span><br><span class="line">dir /usr/local/redis/data</span><br><span class="line"># 设置密码</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><p>在 <code>redis.conf</code> 文件末尾加上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">900 秒内如果超过 1 个key改动，则发起快照保存</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">300 秒内如果超过 10 个 key 改动，则发起快照保存</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">60 秒内如果超过 1W 个 key 改动，则发起快照保存</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>这就备份了一个快照，快照是<strong>默认</strong>的持久化方式。这种方式就是将内存中数据以快照的放入写入<strong>二进制文件</strong>中，默认的文件名为 <code>dump.rdb</code>，可以通过配置设置自动做快照持久化的方式。</p><p>产生快照的情况有以下几种：</p><ul><li>手动 <code>bgsave</code> 执行（不会阻塞，后台一点点备份）。</li><li>手动 <code>save</code> 执行（会阻塞，不接受客户端命令，备份完了才放开）。</li><li>根据配置文件自动执行。</li><li>客户端发送 <code>shutdown</code>，系统会先执行 save 命令阻塞客户端，然后关闭服务器。</li><li>当有主从架构时，从服务器向主服务器发送 <code>sync</code> 命令来执行复制时，主服务器会执行 <code>bgsave</code> 操作。</li></ul><p>也可以手动执行save，但是这个过程中redis是阻塞的</p><p>所以可以创建一个子进程，边处理边备份 bgsave</p><h2 id="AOF">AOF</h2><p>记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据（MySQL 的 binlog）。</p><p>也就是每次处理完请求命令后都会将此命令追加到 <code>.aof</code> 文件的末尾。而 RDB 是压缩成二进制等时机开子进程去干这件事。</p><p>在配置文件中通过配置 <code>redis.conf</code> 进行启动，默认是关闭的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认 appendonly 为 no</span></span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RDB 文件和 AOF 文件所在目录</span></span><br><span class="line">dir /usr/local/redis/data</span><br></pre></td></tr></table></figure><p>Redis 中提供了 3 种 AOF 同步策略：</p><ul><li>每秒同步（默认，每秒调用一次 <code>fsync</code>，这种模式性能并不是很糟糕）。</li><li>每修改同步（会极大削弱 Redis 的性能，因为这种模式下每次 <code>write</code> 后都会调用 <code>fsync</code>）。</li><li>不主动同步（由操作系统自动调度刷盘，Linux 是 30s 一次，性能是最好的）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每秒钟同步一次，默认</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每次有数据修改发生时都会写入 AOF 文件</span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从不同步，由操作系统自动调度刷盘，高调但是数据不会主动被持久化</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><h3 id="重写">重写</h3><p>随着运行时间的增长，执行的命令越来越多，会导致 AOF 文件越来越大，当 AOF 文件过大时，Redis 会执行重写机制来压缩 AOF 文件。这个压缩和上面提到的 RDB 文件的算法压缩不同，重写机制主要是将文件中无效的命令去除。比如：</p><ul><li>同一个 key 的值，只保留最后一次写入。</li><li>已删除或者已过期数据相关命令会被去除。这样就避免了 aof 文件过大而实际内存数据小的问题（如频繁修改数据时，命令很多，实际数据很少）</li></ul><p>触发条件：</p><ul><li><p>手动执行 <code>bgrewriteaof</code> 触发AOF重写。</p></li><li><p>在 <code>redis.conf</code>文件中配置重写的条件，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当文件小于64M时不进行重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64MB  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当文件比上次重写后的文件大 100% 时进行重写</span></span><br><span class="line">auto-aof-rewrite-min-percenrage 100</span><br></pre></td></tr></table></figure></li></ul><p>常用配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># fysnc 持久化策略</span><br><span class="line">appendfsync everysec</span><br><span class="line"># AOF 重写期间是否禁止 fsync。如果开启该选项，可以减轻文件重写时 CPU 和影片的负载（尤其是硬盘），但是会丢失 AOF 重写期间的数据，因此我们需要在负载和安全性之间进行平衡。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"># 当前 AOF 文件大于多少字节后才触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"># 当文件比上次重写后的文件大 100% 时进行重写，也就是2倍时触发 rewrite</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># 如果 AOF 文件结尾损耗，Redis 启动时是否仍加载 AOF 文件</span><br><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/redis/">redis</category>
      
      
      <comments>https://blog.tokenlen.top/2025/04/19/redis1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>后端开发笔试题目集合</title>
      <link>https://blog.tokenlen.top/2025/04/12/write1/</link>
      <guid>https://blog.tokenlen.top/2025/04/12/write1/</guid>
      <pubDate>Fri, 11 Apr 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1&gt;数据结构&lt;/h1&gt;
&lt;p&gt;1.将关键字9, 17, 25, 33, 21, 77, 64, 53, 42,</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>[TOC]</p><h1>数据结构</h1><p>1.将关键字9, 17, 25, 33, 21, 77, 64, 53, 42, 31依次插入到初始为空的小根堆H中，得到的H是</p><p>小根堆是一个完全二叉树，每个节点都要小于等与他的左右节点</p><p>根节点是最小的值</p><p>最终：</p><p>[9, 17, 25, 33, 21, 77, 64, 53, 42, 31]</p><p>二叉树的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        9</span><br><span class="line">      /   \</span><br><span class="line">    17     25</span><br><span class="line">   /  \   /  \</span><br><span class="line"> 33  21 77  64</span><br><span class="line">/  \ /</span><br><span class="line">53,42,31</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.在一个二维数组A中，假设每个数组元素的长度为3个存储单元，行下标i为0~9，列下标j为0~7，从首地址200开始连续按列优先存放，在这种情况下，元素A[9][2}的起始地址为（ ）</p><p>一列一列地存，每列里是从上到下。</p><p>所以每个元素的起始地址相对于前一个元素的起始地址增加3个存储单元</p><p>起始地址 = 首地址 + (j * 行数 + i) * 元素长度</p><p>所以最后是287</p><p>3.考虑以下递归函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int calculateI(int i) &#123;</span><br><span class="line">    if (i &lt;= 1) &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return calculateI(i - 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于给定的初始i值（i&gt;1），计算最终的i值是多少？</p><p>这个函数是每次调用的时候，i-1，然后调用的结果又+1</p><p>所以最后还是i</p><p>4.已知串S=‘bccabcaac’，采用KMP算法进行模式匹配，则得到的next数组值为（）</p><p>这道题采用手工求next数组的方法。</p><p>先求串S='bccabcaac’的部分匹配值：</p><p>'b’的前后缀都为空，最长相等前后缀长度为0。</p><p>'bc’的前缀{b}交集后缀{c}为空</p><p>'bcc’前缀{b,bc}交后缀{c,cc}为空</p><p>依次求出的部分匹配值如下表第三行所示，将其整体右移一位，低位用-1填充，如下表第四行所示。</p><p>PM是部分匹配值（Partial Match）</p><table><thead><tr><th>编号</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>S</td><td>b</td><td>c</td><td>c</td><td>a</td><td>b</td><td>c</td><td>a</td><td>a</td><td>c</td></tr><tr><td>PM</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td><td>0</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td></tr></tbody></table><p>next[1]=0所以,next数组整体+1</p><p>所以答案为011112311</p><h1>计算机网络</h1><h2 id="基础">基础</h2><p>1.在HTTP协议中，请求报文中的请求行包括：<strong>请求方法，url,和http版本号</strong></p><p>2.TCP&quot;四次挥手&quot;过程中，第一次&quot;挥手&quot;时，发送的报文段中fin标志位被置为1。</p><p>3.在DNS配置文件中，CNAME用于表示某主机别名的</p><p>4.令牌总线访问控制方法是在物理总线上建立一个逻辑环，从逻辑上看是环状结构的局域网，从物理上看是总线状结构。</p><p>令牌总线MAC方法结合了令牌环和总线两种拓扑结构的优点</p><p>从物理结构来看:<br>- 采用总线型拓扑,所有站点都连接在同一条物理总线上<br>- 这种结构布线简单,易于扩展和维护<br>- 站点的物理连接就是一条直线型总线</p><p>从逻辑结构来看:<br>- 站点按照预先确定的顺序组成一个逻辑环<br>- 令牌在逻辑环中按固定顺序从一个站传递到下一个站<br>- 站点获得令牌后才能发送数据,发送完毕后将令牌传给下一站</p><p>6.TCP连接中的确认号反映了接收方期望收到的下一个序号,一个TCP报文段的序号和确认号与以下因素都有关系:</p><ol><li>初始序号(ISN)</li><li>已传输的数据字节</li></ol><p>8.属于DHCP客户端发送的消息是（ ）</p><p>discover</p><p>request</p><p>discover消息：当DHCP客户端启动时，会在本地网络上广播发送discover消息，用于发现DHCP服务器。这是客户端发起的第一步操作。</p><p>request消息：客户端收到服务器的offer消息后，会发送request消息，表明接受某台DHCP服务器提供的IP地址等配置信息。</p><p>offer：这是DHCP服务器对客户端discover消息的响应，用于向客户端提供可用的IP地址等配置信息，由服务器发送。</p><p>ack：这是DHCP服务器对客户端request消息的确认响应，表示同意将相关配置信息分配给该客户端，同样是由服务器发送。</p><p>发送的顺序分别是：</p><p>discover-&gt;offer-&gt;request-&gt;ack</p><p>c-s-c-s模式</p><p>10.在以太网中,帧长度是有明确限制的。根据IEEE 802.3标准规定,以太网帧的长度必须在64-1518字节之间:</p><p>最小帧长度为64字节:<br>- 这是为了确保冲突检测机制(CSMA/CD)能够正常工作<br>- 如果帧太短,可能无法及时检测到冲突<br>- 不包括前导码和帧起始定界符的7+1字节</p><p>最大帧长度为1518字节:<br>- 这个限制是由于物理层和链路层的技术约束<br>- 过长的帧会占用信道时间过长,影响网络性能<br>- 也会增加出错概率</p><p>11.Socket，即套接字，是一个对 TCP / IP协议进行封装 的编程调用接口。socket的使用类型主要有：</p><p>基于 TCP协议，采用 流的方式 提供可靠的字节流服务</p><p>基于 UDP协议，采用 数据报文 提供数据打包发送的服务</p><p>基于TCP协议的套接字提供面向连接的、可靠的字节流服务。TCP协议本身就是面向流的协议，能够保证数据的可靠传输。</p><p>基于UDP协议的套接字提供无连接的数据报服务。UDP是面向数据报的协议，每个UDP数据报都是一个独立的信息单位。</p><p>12.http协议头字段中：</p><p>Expires：它通常的使用格式是Expires:Fri ,24 Dec 2027 04:24:07 GMT，后面跟的是日期和时间，超过这个时间后，缓存的内容将失效</p><p>Last-Modified / If-Modified：一般服务端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间</p><p>Content-Length：用于描述HTTP消息实体的传输长度</p><p>Etag/If-None-Match：用于验证缓存有效性</p><p>Content-Length与http缓存没有关系</p><p>13.在传输层可采用( )策略防止拥塞</p><ul><li>重传策略</li><li>流控制策略</li></ul><p>14.以<strong>集线器</strong>组建的以太网上某个主机发送一个帧到此网络上的另一主机，则这个网络上的所有主机都会收到这个帧</p><p>集线器(Hub)是工作在物理层的网络设备,采用<strong>广播</strong>的形式转发数据，都会接受到</p><p>但只有目的MAC地址与自己MAC地址匹配的主机才会将帧去掉首部和尾部,并上交给网络层处理。其他主机收到后会直接丢弃这个帧。</p><h2 id="协议">协议</h2><p>1.在BSC(二进制同步通信)协议中，字符填充是为了避免数据中出现的控制字符序列与实际控制字符混淆。当数据中出现DLE(数据链路转义)字符时，需要在其后额外插入一个DLE字符作为填充。</p><p>若 BSC 帧的数据段中出现字符串“ A DLE STX ”，则字符填充后的输出为 (   )</p><p>所以字符串输出为A DLE DLE STX</p><p>2.OSPF(开放最短路径优先)协议是一种链路状态路由协议,直接运行在<strong>IP层</strong>之上,使用IP协议号89。它不依赖于TCP或UDP等传输层协议。</p><p>3.在 TCP 拥塞控制机制中，当拥塞窗口小于阈值时，拥塞窗口呈指数增长</p><p>TCP拥塞控制机制中,当拥塞窗口小于慢启动阈值(ssthresh)时,处于慢启动阶段,此时拥塞窗口是指数增长的。每收到<strong>一个ACK,拥塞窗口就加1</strong>,这意味着每经过一个RTT(往返时延),拥塞窗口就会翻倍,因此增长速度是指数级的。</p><p>4.电子邮件系统的确主要由用户代理(User Agent, UA)和消息传输代理(Message Transfer Agent, MTA)两大部分组成</p><p>用户代理(UA)：<br>- 是用户直接与之交互的客户端软件<br>- 提供编写、发送、接收、阅读邮件的界面<br>- 常见的如Outlook、Thunderbird等邮件客户端</p><p>消息传输代理(MTA)：<br>- 负责邮件的存储和转发<br>- 实现邮件在网络中的传递<br>- 典型的如Sendmail、Postfix等服务器软件</p><h2 id="网络物理连接">网络物理连接</h2><p>5.两个厂商交换机之间双线互联，应该使用动态链路聚合</p><p>动态链路聚合的优势:</p><ol><li>自动协商和检测 - 通过LACP协议,两端设备可以自动协商参数并检测链路状态</li><li>故障自动切换 - 当某条链路发生故障时,可以自动切换到备用链路</li><li>兼容性更好 - 动态协议可以更好地处理不同厂商设备之间的互通</li><li>维护便捷 - 无需手动配置大量参数,减少人为错误</li></ol><p>7.双绞线一般使用RJ-45接头和接口。RJ-45接头有8个引脚,完全满足双绞线传输的需求,广泛应用于以太网连接中</p><p>双绞线一般传输不超过100米</p><p>9.下面关于虚拟局域网 VLAN 的叙述错误的是 ()</p><p>AVLAN是由一些局域网网段构成的与物理位置无关的逻辑组。</p><p>B利用以太网交换机可以很方便地实现VLAN。</p><p>C每一个VLAN的工作站可处在不同的局域网中。</p><p>D虚拟局域网是一种新型局域网。</p><p>VLAN不是一种新型局域网,而是在现有局域网基础上的一种网络管理技术。它通过配置交换机等网络设备,将物理局域网划分成多个逻辑子网。</p><p>VLAN确实是由局域网网段构成的逻辑组,其划分与物理位置无关,可以根据功能、部门等需求进行灵活分组。</p><p>现代以太网交换机都支持VLAN功能,通过配置交换机端口的VLAN ID等参数就可以方便地实现VLAN。</p><p>VLAN的成员可以分布在不同的物理局域网中,只要这些局域网的交换机支持相同的VLAN即可实现通信。</p><p>VLAN技术的主要作用是:<br>\1. 提高网络安全性,限制广播域范围<br>\2. 减少网络负载,提升网络性能<br>\3. 简化网络管理,提供灵活的网络配置方案<br>\4. 降低网络设备成本,有效利用现有网络资源</p><p>10.异步传递模式 ATM 采用称为信元的定长分组，并使用光纤信道传输。</p><p>11.屏蔽双绞线的缩写为stp</p><p>屏蔽双绞线是在非屏蔽双绞线(UTP)的基础上,在双绞线外层加装了金属屏蔽层,可以有效防止电磁干扰。</p><p>UTP(Unshielded Twisted Pair)是非屏蔽双绞线的缩写,与题目要求不符<br>CAT3是3类网线的简称,表示传输速率等级,不是屏蔽双绞线的缩写<br>CAT5E是5类增强型网线的简称,同样是表示传输速率等级,不是屏蔽双绞线的缩写</p><p>12.物理层主要负责在物理介质上传输比特流。<strong>集线器</strong>(Hub)是最典型的物理层设备,它工作在OSI参考模型的第一层,主要功能是对接收到的信号进行放大和转发,实现物理层上的数据传输。</p><p>交换机工作在数据链路层(第二层),能够学习MAC地址并进行数据帧的转发</p><p>路由器工作在网络层(第三层),负责不同网络之间的数据包转发和路由选择</p><p>网卡虽然有物理层的功能,但它同时也工作在数据链路层,具有MAC地址</p><p>生活中其他常见的物理层设备还包括:<br>- 中继器:用于延长网络传输距离<br>- 光纤收发器:用于光电信号转换<br>- 网线和光纤:作为物理传输介质</p><p>13.下列哪项陈述描述了默认路由的作用 ( )</p><p>不存在通往目的主机的其它路由时，主机使用默认路由将数据传输到本地网络外的主机</p><p>默认路由主要用于处理<strong>目的地址不在路由表</strong>中的数据包转发,当路由表中没有特定的路由条目指向目的主机时,数据包会通过默认路由发送到本地网络之外。</p><h1>操作系统</h1><p>1.<strong>高响应比优先（HRRN）算法</strong>属于快速响应式调度算法</p><p>2.在操作系统中，PV操作用于管理资源的访问和同步。<strong>P用于申请资源，V用于释放资源</strong></p><p>3.下面关于 Linux 进程地址空间中的代码段和数据段的说法错误的是</p><p>A 代码段用于存储程序的可执行指令</p><p>B 数据段用于存储初始化的全局和静态变量</p><p>C 代码段和数据段通常属于只读内存区域</p><p>D 在 Linux 中，代码段和数据段总是共享同一个物理页面</p><p>在Linux进程地址空间中,代码段和数据段是两个不同的内存区域,它们有着不同的特点和用途。</p><p>代码段(text segment)确实用于存储程序的可执行指令,这些指令是CPU直接执行的机器码。</p><p>数据段(data segment)用于存储已初始化的全局变量和静态变量,这些数据在程序启动时就被加载到内存中。</p><p>代码段通常是只读的,这样可以防止程序在运行时意外修改指令;而数据段中可能包含只读数据区(.rodata)。</p><p>代码段和数据段出于以下原因通常不会共享同一个物理页面:<br>1 内存保护需求不同:代码段需要执行权限,数据段需要读写权限<br>2 缓存效率考虑:分开存放有利于CPU缓存的使用效率<br>3 内存对齐要求:不同段可能有不同的对齐要求<br>4 安全性考虑:分开存放可以防止缓冲区溢出等攻击</p><p>4.某系统中有3个并发进程，都需要同类资源4 个，试问该系统不会发生死锁的最少资源数是（）</p><p>系统<strong>不会发生死锁的安全条件</strong>是：</p><blockquote><p><strong>系统可用资源数 ≥ 所有进程最大需求数 - 1</strong></p></blockquote><p>这需要用到银行家公式<br>$$<br>通用公式如下：</p><p>最少资源数=P×(R−1)+1<br>$$</p><ul><li><p>P：进程数</p></li><li><p>R：每个进程最多需要的资源数</p></li></ul><p>所以此题的答案是10个</p><p>5.进程和线程是操作系统中最基本的概念，下列有关描述不正确的是（）</p><p>A进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位</p><p>B线程之间的通信简单（共享内存即可，但须注意互斥访问的问题），而不同进程之间的通信通常需要调用内核实现</p><p>C由于线程没有独立的地址空间，因此同一个进程的一组线程可以访问该进程资源，这些线程之间的通信也很高效</p><p>D线程有独立的虚拟地址空间，但是拥有的资源相对进程来说，只有运行所必须的堆栈，寄存器等。</p><p>因为线程并不具有独立的虚拟地址空间，线程是共享所在进程的地址空间的。线程确实拥有独立的运行时资源如堆栈和寄存器等，<strong>但地址空间是与其所在进程的其他线程共享的</strong>。</p><p>线程是<strong>轻量级的进程</strong>，它们共享所在进程的地址空间和其他资源，但拥有<strong>独立的运行时资源</strong>（如堆栈、程序计数器、寄存器等）。这种特性使得线程的创建、切换开销较小，且线程间通信效率较高。</p><p>进程是进行分配资源的最小单位，线程没有独立资源。<strong>线程是调度的最小单位</strong></p><h1>数据库</h1><h2 id="E-R图">E-R图</h2><p>1.在 E-R 图中，<strong>矩形用于表示实体</strong></p><p>4.一般情况下,当对关系R和S进行自然连接时,要求R和S含有一个或者多个共有的<strong>属性</strong>，也就是表中的行</p><p>5.在数据库设计中，将E－R图转换成关系数据模型的过程属于逻辑设计阶段</p><h2 id="备份">备份</h2><p>2.<strong>增量备份</strong>能基于上次任意一种备份，将上次备份后发生变化的数据进行备份，并将备份后的数据进行标记</p><h2 id="sql语句">sql语句</h2><p>3.在MySQL存储过程中，以下关于声明存储过程的参数类型的说法正确的是（）</p><p>A使用DECLARE语句声明参数类型</p><p>B在参数名前加上“@”符号来表示参数类型</p><p>C在参数名后加上数据类型来声明参数类型</p><p>D在存储过程名后使用中括号来声明参数类型</p><p>在MySQL存储过程中，可以在<strong>存储过程名后使用括号来声明参数</strong></p><p>在存储过程中，也可以使用DECLARE语句来声明变量的类型，但是不能用来声明存储过程的参数类型。在MySQL中，不需要在参数名前加上“@”符号来表示参数类型。</p><p>6.众所周知，MySQL通过使用绑定变量能够极大地提高执行效率，并且执行重复的语句。因为</p><ul><li>只需解析1次SQL语句</li><li>仅发送参数和句柄</li><li>参数之间缓存至内存中</li></ul><p>8.通过CHARINDEX如果能够找到对应的字符串，则返回该字符串位置i（有效位置范围为1&lt;= i &lt;= length(input)），否则返回0。</p><p>注意*<strong>位置是从1开始*</strong>。</p><p><strong>CHARINDEX ( expressionToFind , expressionToSearch [ , start_location ] )</strong></p><p>expressionToFind ：目标字符串，就是想要找到的字符串，最大长度为8000 。</p><p>expressionToSearch ：用于被查找的字符串。</p><p>start_location：开始查找的位置，为空时默认从第一位开始查找。</p><p>9.使用insert插入字段的时候，不能使用双引号，否则会执行报错</p><p>10.MySQL 通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。</p><p>11.如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序</p><h2 id="视图">视图</h2><p>7.视图：</p><p>视图可以被嵌套，当SELECT语句的选择列表有TOP子句时，视图可以包含ORDER BY子句，其他情况下不行</p><p>视图不能对临时表或表变量进行引用。更新视图数据可用sp_refreshview。sp_helptext用于获取自定义视图创建的T_SQL文本</p><h1>java</h1><h2 id="基础语法">基础语法</h2><p>1.下面 Java 代码能够编译通过的是（）</p><p>Aint arr[3] = {1, 2, 3};</p><p>Bint arr[] = new int[3];</p><p>Cint[] arr = new int[]{1, 2, 3};</p><p>Dint[] arr = {1, 2, 3};</p><p>错误的是A，Java中声明数组时不能在[]中指定长度。</p><p>2.boolean b = true ? false : true==true ? false : true;b的值是？</p><p>首先要明确三元运算符的结合性是从右到左的，但此处有一个条件表达式true在最前面，所以先执行第一个三元运算</p><p>拆解步骤：<br>\1. 最外层的三元运算符: true ? false : (true==true ? false : true)<br>\2. 因为条件为true，所以直接返回false，后面的部分不再执行<br>\3. 所以 b = false</p><p>所以return false</p><p>3.double x=2.0; int y=4; x/=++y;</p><p>执行后x的值为0.4</p><p>复合赋值运算符/=的优先级低于++运算符<br>++y是前缀自增，会先进行自增运算再参与其他运算<br>double类型除以int类型，结果会自动转换为double类型</p><p>4.Integer.valueOf()会优先使用缓存池中的对象<br>new Integer()每次都会创建新的对象<br>当涉及到基本类型时，包装类会自动拆箱进行值比较<br>使用equals()方法比较Integer对象时比较的是值而不是引用</p><p>其中=是复制，==是比较的是在内存中的地址，equals方法比较的才是值的大小</p><p>5.java中的基础数据类型：</p><p>byte、short、int、long、float、double、boolean和char。</p><p>String 属于引用类型</p><p>基本数据类型和引用类型的主要区别在于:<br>\1. 基本类型变量存储的是实际的数据值<br>\2. 引用类型变量存储的是对象的引用(内存地址)<br>\3. 基本类型在栈中分配内存,引用类型在堆中分配内存</p><h2 id="反射">反射</h2><p>2.下面关于 Java 中反射机制的说法正确的是（）</p><p>A反射机制可以在程序运行时获取类的信息</p><p>B反射机制可以动态地创建对象、调用方法和访问属性</p><p>C反射机制能够提高程序的性能和安全性</p><p>D反射机制只能用于访问 public 访问控制修饰符修饰的成员</p><p>反射机制实际上会降低程序的性能,因为它需要在运行时进行类型检查和解析。同时,反射也可能破坏封装性,带来安全风险,因为它可以访问私有成员。</p><p>反射机制不仅可以访问public成员,通过setAccessible(true)方法,它还可以访问private、protected等其他访问控制级别的成员。这也是反射强大但需要谨慎使用的原因之一。</p><p>所以选择A和B这是反射的关键特性和优势</p><h2 id="集合">集合</h2><p>3.下面关于 Java 中集合相关的说法正确的是（）</p><p>AList 是一个有序的集合，可以包含重复的元素</p><p>BJava 中的集合框架只包括 List、Set 两种类型的集合</p><p>CSet 是一个无序的集合，不允许包含重复的元素</p><p>DMap 是一种键值对的集合，其中键和值都可以重复</p><p>Java集合框架不仅包括List和Set，还包括Map、Queue等多种集合类型。这是对Java集合框架范围的错误理解。</p><p>Map中的键(Key)必须是唯一的，不能重复，而值(Value)可以重复。这是Map的基本特性，确保了每个键都能唯一标识一个值。比如HashMap、TreeMap等Map实现类都必须遵守这个规则。</p><p>Set是一个不允许重复元素的集合接口。Set的实现类(如HashSet)不保证元素的存储顺序，因此是无序的。虽然LinkedHashSet保持了插入顺序，TreeSet按照自然顺序排序，但Set接口本身的特性是无序的。</p><h3 id="MAP">MAP</h3><p>当在遍历HashMap的同时对其进行结构性修改(如删除元素)时,会抛出ConcurrentModificationException异常。代码会运行错误</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public` `static` `void` `main(String[] args) &#123;</span><br><span class="line">  ``Map&lt;Integer, String&gt; map = ``new` `HashMap&lt;&gt;();</span><br><span class="line">  ``map.put(``1``, ``&quot;A&quot;``);</span><br><span class="line">  ``map.put(``2``, ``&quot;B&quot;``);</span><br><span class="line">  ``map.put(``3``, ``&quot;C&quot;``);</span><br><span class="line">  ``map.forEach((key, value) -&gt; &#123;</span><br><span class="line">    ``if` `(key == ``2``) &#123;</span><br><span class="line">      ``map.remove(key);</span><br><span class="line">    ``&#125;</span><br><span class="line">  ``&#125;);</span><br><span class="line">  ``System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会抛出异常，运行错误</p><h2 id="特性">特性</h2><h3 id="volatile">volatile</h3><p>4.下列关于 Java 中 volatile 关键字的说法正确的是（）</p><p>Avolatile 关键字修饰的变量被修改之前会从主存中读取最新的值覆盖掉cpu缓存</p><p>Bvolatie 底层实现遵循 happens-before 原则</p><p>Cvolatile 关键字修饰的共享变量是线程安全的</p><p>Dvolatile 关键字可以保证被修饰变量在运算时不会进行指令重排</p><p>volatile关键字是Java中用于保证变量可见性和有序性的重要机制。</p><p>volatile变量在每次被线程访问时，都强制从主内存中重新读取最新值，而不是使用线程工作内存中的值。这确保了变量的可见性。</p><p>volatile的实现确实遵循happens-before原则。happens-before原则是Java内存模型中的重要概念，它保证了volatile写操作一定happens-before于后续对这个volatile变量的读操作。</p><p>volatile关键字通过内存屏障(Memory Barrier)来阻止指令重排序。它能确保volatile变量读写操作的顺序性，防止编译器和处理器对这些操作进行重排序优化。</p><p>volatile不能保证线程安全。它只能保证变量的可见性和禁止指令重排序，但不能保证原子性。</p><p>volatile只能保证可见性和有序性,无法保证互斥性和原子性。例如count++这样的操作,volatile无法保证其原子性,因为这个操作实际包含读取、递增、写入三个步骤。</p><p>volatile只能用于修饰变量,不能修饰方法和类。这是Java语法规定的使用范围。</p><p>volatile不能完全替代锁机制。虽然volatile能保证可见性和有序性,但无法保证原子性,因此在需要互斥访问或原子操作的场景下,仍然需要使用synchronized等锁机制来实现线程安全。</p><h3 id="constructor">constructor</h3><p>constructor是类的构造方法,它会在使用new关键字创建类的实例时自动执行,用于初始化对象的属性。</p><p>ass中的constructor是可以省略的。如果一个类没有显式定义constructor,JavaScript会自动添加一个空的constructor方法。</p><p>constructor是类的特殊方法,不需要与类同名。而且类中的其他方法也可以与类同名,这不受限制。</p><h2 id="jvm">jvm</h2><p>5.在Java中，当对象的所有引用都消失后，对象使用的内存将自动回收是<strong>Garbage Collection</strong></p><p>Garbage Collection(垃圾回收)是Java中的一种自动内存管理机制,当程序中的对象不再被引用时,JVM会自动回收这些对象占用的内存空间。C选项正确地描述了这一机制:当对象的所有引用都消失后,对象使用的内存将自动回收。</p><p>6.局部变量在Java中必须要先初始化后才能使用，直接运行的话直接会编译失败</p><p>7.以下哪些jvm的垃圾回收方式采用的是复制算法回收</p><p>A新生代串行收集器</p><p>B老年代串行收集器</p><p>C并行收集器</p><p>D新生代并行回收收集器</p><p>E老年代并行回收收集器</p><p>Fcms收集器</p><p>复制算法主要用于垃圾回收中存活对象较少的场景,通常应用在新生代的垃圾回收中,复制算法的特点是把<strong>内存分为两块,每次只使用其中一块</strong>。当这一块内存用完,就将<strong>还存活的对象复制到另一块上面</strong>,然后把已使用过的内存空间一次清理掉。</p><p>老年代收集器使用的是标记-整理算法</p><p>CMS(Concurrent Mark Sweep)收集器采用的是标记-清除算法</p><h2 id="类">类</h2><h3 id="泛型">泛型</h3><p>5.下列关于 Java 中泛型（Generics）的说法正确的是（）</p><p>A泛型可以在编译时检查类型安全性，避免运行时出现类型转换异常</p><p>B泛型可以应用于类、接口和方法，但不能用于数组</p><p>C泛型中的类型参数可以是任何类或接口类型，甚至包括基本数据类型</p><p>D泛型中的类型参数只能是对象类型，不能是基本数据类型</p><p>泛型的一个主要优势就是在<strong>编译时进行类型检查</strong>。这可以帮助开发者在编码阶段就发现类型不匹配的问题,而不是等到运行时才出现ClassCastException。这提高了代码的类型安全性和可靠性。</p><p>Java泛型支持任何引用类型(类或接口)作为类型参数。这包括自定义类、集合类、包装类等所有对象类型。</p><p>Java泛型不仅可以应用于类、接口和方法,还可以用于数组。虽然不能直接创建泛型数组(如new T[]),但可以声明泛型数组类型。例如List[] array是合法的。</p><p>6.<strong>封装、继承、多态</strong>是面向对象的三大特征</p><p>封装就是将<strong>属性私有化</strong>，提供公有的方法访问私有属性，修改属性的可见性来限制对属性的访问，并为每个属性创建一对取值（ getter ）方法和赋值（ setter ）方法，用于对这些属性的访问。<br>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private String name;</span><br><span class="line">public String getName()&#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">          this.name=name;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>通过封装，可以实现对属性的数据访问限制，同时增加了程序的可维护性。<br>由于取值方法和赋值方法隐藏了实现的变更，因此并不会影响读取或修改该属性的类，避免了大规模的修改，程序的可维护性增强</p><p>7.instanceof是可以判断一个对象是否是类或者接口的对象</p><p>8.同一个类的不同对象会在堆内存中占用不同的内存空间，而静态成员则是该类所有对象共享的，存储在方法区中的静态区</p><p>9.因为Integer类型的默认值是null而不是1。作为包装类型,Integer对象的默认值是null。</p><p>int和Integer的主要区别还包括:</p><p>int是基本数据类型,而Integer是引用类型</p><p>int变量存储在<strong>栈</strong>中,而Integer对象存储在<strong>堆中</strong></p><p>int不可以为null,而Integer可以为null</p><p>Integer提供了更多的方法来操作数据</p><p>10.在使用 interface 声明一个外部接口时，只可以使用public修饰符修饰该接口</p><p>11.java8中，下面ThreadLocal类用到了解决哈希冲突的开放定址法</p><h3 id="序列化">序列化</h3><p>12.以下关于对象序列化描述正确的是</p><p>A使用FileOutputStream可以将对象进行传输</p><p>B使用PrintWriter可以将对象进行传输</p><p>C使用transient修饰的变量不会被序列化</p><p>D对象序列化的所属类需要实现Serializable接口</p><p>在Java对象序列化中,C和D是正确的答案。</p><p>C选项正确:transient关键字用于声明不需要序列化的成员变量。当一个对象被序列化时,被<strong>transient</strong>修饰的变量的值不会被保存,在反序列化后,<strong>这些变量会被设置为默认值</strong>。这通常用于那些不需要或不应该被序列化的敏感数据或临时数据。</p><p>D选项正确:要实现对象序列化,该对象的类必须实现Serializable接口。这是Java序列化机制的基本要求,Serializable是一个标记接口,表明该类的对象可以被序列化。</p><p>A选项错误:FileOutputStream是字节流,它只能处理原始字节数据的写入,不能直接序列化对象。要序列化对象,需要使用<strong>ObjectOutputStream</strong>包装FileOutputStream。</p><p>B选项错误:PrintWriter是处理字符数据的输出流,主要用于写入文本数据,不能直接进行对象序列化。要序列化对象必须使用<strong>ObjectOutputStream</strong>。</p><p>需要注意的是,正确的对象序列化过程通常需要:<br>\1. 实现Serializable接口<br>\2. 使用ObjectOutputStream进行序列化<br>\3. 可以通过transient关键字控制某些字段不被序列化</p><h3 id="Servle">Servle</h3><p>13**.ServletConfig**可以获得Servlet的初始化参数</p><p>每个Servlet都有自己的ServletConfig对象,可以通过init()方法获得。开发者可以在web.xml中通过标签为Servlet配置初始化参数,然后在代码中通过ServletConfig的getInitParameter()方法获取这些参数值。</p><p><strong>ServletContext</strong>用于获取整个Web应用程序的配置信息和共享数据,</p><h3 id="json">json</h3><p>JSON格式有严格的语法规则要求</p><p>A选项 {company：4399} 错误原因：<br>- JSON中的键必须用双引号括起来<br>- 使用了中文冒号而不是英文冒号<br>正确写法应该是 {“company”:4399}</p><p>C选项 {[4399,4399,4399]} 错误原因：<br>- JSON对象必须是键值对的形式<br>- 数组不能直接作为对象的值，必须有键名<br>正确写法应该是 {“array”:[4399,4399,4399]}</p><h3 id="接口">接口</h3><p>在Java中接口是一种<strong>完全抽象的类型</strong>，主要用于<strong>定义对象的行为规范</strong>。</p><p>接口中的方法默认就是public和abstract的。这是Java接口的特性，即使不显式声明这些修饰符，编译器也会自动添加。这样可以确保接口方法的可访问性和抽象性。</p><p>Java确实使用interface关键字定义接口，使用implements关键字实现接口。这是Java的基本语法规则，体现了面向对象编程中接口的语法实现方式。</p><p>Java支持多接口实现，<strong>一个类可以同时实现多个接口，这体现了Java的多继承特性。同时，接口之间也可以通过extends关键字实现继承，且支持多继承。</strong></p><h3 id="方法">方法</h3><p>1.抽象方法被子类重写实现时,不能声明为虚方法。子类在实现抽象方法时,只能将其实现为具体方法。</p><p>虚方法可以被子类继承和重写,这是虚方法的基本特性,通过virtual关键字声明。</p><p>抽象方法是一种特殊的方法,只有方法的声明而没有具体的实现代码,所以不能带有方法体。</p><p>非抽象子类继承抽象类时,必须实现所有抽象方法。这是抽象方法的强制要求,确保子类提供具体的实现。</p><p>虚方法和抽象方法都支持多态,但有明显区别:<br>- 虚方法有具体实现,子类可<strong>选择是否重写</strong><br>- 抽象方法没有实现,子类<strong>必须实现</strong><br>- 子类实现抽象方法时只能实现为<strong>具体方法</strong>,不能声明为虚方法</p><p>7.在java中重写方法应遵循规则的包括</p><p>在Java中重写(Override)方法确实需要遵循一些规则</p><p>可以有不同的访问修饰符</p><p>参数列表必须完全与被重写的方法相同</p><p>访问修饰符的限制不一定要大于被重写方法。实际上是可以相等，也可以更宽松，但<strong>不能更严格</strong>。例如，如果父类方法是protected，子类重写的方法可以是protected或public，但不能是private。</p><p><strong>参数列表必须相同而不是不同</strong>。如果参数列表不同，那就变成了方法重载(Overload)而不是方法重写(Override)</p><p>8.总结来说，hashCode和equals方法之间存在如下约束：<br>- equals返回true的两个对象必须具有相同的hashCode，值相等才能hash值相等<br>- hashCode相同的两个对象不一定equals返回true，因为可能hash碰撞了<br>- hashCode不同的两个对象一定equals返回false</p><p>9.静态方法和和非静态成员</p><p>实例变量可以通过对象实例访问</p><p>实例方法可以通过对象实例调用</p><p>实例方法method1()不能通过类名直接调用，必须通过对象实例调用。因为实例方法需要依赖对象状态。</p><p>静态方法可以通过类名直接调用，这是正确的访问方式。</p><p>基本原则：<br>\1. 静态成员(静态变量和静态方法)可以通过类名直接访问<br>\2. 非静态成员(实例变量和实例方法)必须通过对象实例访问<br>\3. 不能通过类名直接访问非静态成员</p><h3 id="Collection">Collection</h3><p>Collection是java.util下的接口，它是各种集合结构的父接口</p><p>Collections是java.util下的类，它包含有各种有关集合操作的静态方法</p><h2 id="线程">线程</h2><h3 id="TLS">TLS</h3><p>10.TLS(线程局部存储)是一种特殊的存储机制，它为每个线程提供独立的变量副本</p><p>TLS确实是解决<strong>多线程访问冲突</strong>的一种技术。通过为每个线程提供<strong>独立的变量副本</strong>，避免了线程间的数据竞争，从而解决了并发访问冲突问题。</p><p>它会为每个线程创建并维护一个独立的变量副本，这些副本与特定线程绑定，<strong>其他线程无法访问。</strong></p><p>虽然TLS为每个线程提供了独立的变量副本，但这并不意味着<strong>完全不需要同步</strong>。如果变量的操作涉及多个步骤，或者存在其他共享资源的访问，仍然可能需要<strong>同步机制</strong>。</p><p>Java中的<strong>ThreadLocal</strong>类就是TLS技术的一个具体实现。它提供了创建线程局部变量的功能，使每个线程都拥有自己的变量副本。</p><p>11.ThreadLocal是Java中实现线程本地存储的重要机制。</p><p>ThreadLocal确实采用哈希表的实现方式，在Thread类中有一个ThreadLocalMap成员变量，用于存储本线程的ThreadLocal变量。每个线程访问ThreadLocal变量时，实际是在<strong>操作自己的ThreadLocalMap中的副本。</strong></p><p>ThreadLocal的设计目的就是为了保证线程安全，它为每个线程提供了独立的变量副本，使得每个线程都可以独立地改变自己的副本，而不会影响其他线程的数据。</p><p>ThreadLocal不是继承自Thread类，它是一个独立的类，主要用于实现线程本地存储。</p><p>ThreadLocal并没有实现Runnable接口，它与线程的执行方式无关，只负责提供线程本地变量的存储机制。</p><p>ThreadLocal的重要作用恰恰相反，它是为了避免多线程间共享数据，而是让每个线程都拥有自己的数据副本，实现线程间的数据隔离。共享数据会导致线程安全问题，而ThreadLocal正是解决这个问题的一种方案。</p><p>用了开放定址法来解决了hash冲突问题</p><h3 id="线程分类">线程分类</h3><p>线程实现主要分为三类:<strong>用户级线程(ULT)、内核级线程(KLT)和混合型线程</strong>实现。</p><p>线程实现主要分为三类:用户级线程(ULT)、内核级线程(KLT)和混合型线程实现。轻量级进程(LWP)不是线程的实现方式,而是操作系统内核用来支持线程运行的一种机制。</p><p>分析三种线程实现方式:</p><p>\1. 用户级线程(ULT):<br>- 线程的创建、调度和管理都由用户程序完成<br>- 操作系统对线程一无所知<br>- 优点是切换开销小,缺点是无法利用多处理器</p><p>\2. 内核级线程(KLT):<br>- 线程的创建、调度和管理都由内核完成<br>- 操作系统直接对线程进行调度<br>- 优点是可以利用多处理器,缺点是系统调用开销大</p><p>\3. 混合线程:<br>- 结合了ULT和KLT的优点<br>- 用户级线程与内核级线程进行多对多映射<br>- 既保证了系统调用的效率,又可以充分利用多处理器</p><h3 id="线程共享和线程私有">线程共享和线程私有</h3><p>线程共享：</p><p><strong>方法区</strong>：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。它是各个线程共享的内存区域。</p><p><strong>Java堆</strong>：是虚拟机管理的最大的一块内存区域，几乎所有的对象实例和数组都在堆上分配。Java堆是垃圾收集器管理的主要区域，也是线程共享的。</p><p>线程私有：</p><p><strong>程序计数器</strong>：是线程私有的，用于记录线程执行的字节码指令地址。每条线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响。</p><p><strong>Java虚拟机栈</strong>：也是线程私有的，它描述的是Java方法执行的线程内存模型。每个线程在创建时都会创建一个虚拟机栈，栈中的栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><h2 id="IO流">IO流</h2><p>1.Java IO确实包含了<strong>字符流和字节流</strong>两种输入输出方式。字节流以字节为单位进行操作(如InputStream、OutputStream),字符流以字符为单位进行操作(如Reader、Writer)。这是Java IO的基本架构设计。</p><p>InputStream和OutputStream都是抽象类,它们分别是所有字节输入流和输出流的抽象基类。作为抽象类,它们不能直接实例化使用,必须使用它们的具体子类,如FileInputStream、ByteArrayOutputStream等。</p><p>Reader和Writer确实是字符流的抽象基类,它们提供了字符流操作的基本接口。所有的字符流类都继承自这两个抽象类。</p><p>Scanner类不仅可以从键盘读取数据,还可以从文件、字符串等多种数据源读取数据。它是一个通用的数据读取类,可以解析各种格式的输入。例如可以使用Scanner(File file)构造方法来读取文件,使用Scanner(String source)来读取字符串等。</p><p>File类中的mkdir()和mkdirs()方法都可以用来创建文件夹，其中：<br>- mkdir()方法用于创建单个目录<br>- mkdirs()方法用于创建多级目录，如果父目录不存在会自动创建父目录</p><p>2.在Java IO中，按照功能可以将流分为节点流和处理流两大类。</p><p>DataInputStream和BufferedInputStream都属于处理流(处理流也叫包装流)。处理流是包装在节点流之上,为程序提供更强大的读写功能。其中:<br>- DataInputStream 是用于读取基本数据类型的处理流<br>- BufferedInputStream 是缓冲输入流,可以提高读取效率</p><p>FileInputStream是典型的节点流,它直接从数据源(文件)读取数据。<br>InputStream是所有输入流的抽象基类,它本身既不是节点流也不是处理流。</p><p>知识点:<br>\1. 节点流是直接与数据源相连,负责读写数据的流。如FileInputStream、FileOutputStream等。<br>\2. 处理流是在节点流基础上对数据进行加工处理的流。如BufferedInputStream、DataInputStream等。<br>\3. 处理流的优点:<br>- 性能的提高<br>- 操作的便捷<br>- 可以提供特定数据类型的读写支持</p><h2 id="AWT">AWT</h2><p>AWT中TextField是专门用于文本输入的组件类,它允许用户输入和编辑单行文本</p><p>Menu是菜单组件类,用于创建下拉菜单,不是文本框组件</p><p>Label是标签组件类,用于显示不可编辑的文本标签</p><p>List是列表组件类,用于显示可选择的列表项目</p><p>TextField作为文本框组件的主要特点包括:<br>\1. 支持文本输入和编辑<br>\2. 可以设置文本框的大小和位置<br>\3. 可以响应文本变化事件<br>\4. 可以设置是否支持编辑、是否可见等属性<br>\5. 可以通过getText()和setText()方法获取和设置文本内容</p><h1>分布式</h1><p>1.Mapreduce是用于分布式数据分析的通用计算模型和运行时系统</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E7%AC%94%E8%AF%95/">笔试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/sql/">sql</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</category>
      
      
      <comments>https://blog.tokenlen.top/2025/04/12/write1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English四月篇</title>
      <link>https://blog.tokenlen.top/2025/04/01/en8/</link>
      <guid>https://blog.tokenlen.top/2025/04/01/en8/</guid>
      <pubDate>Mon, 31 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1&gt;每日一话+单词遗忘表4.1&lt;/h1&gt;
&lt;p&gt;The liar’s punishment is, not in the least that he is not believed, but that he cannot believe</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>[TOC]</p><h1>每日一话+单词遗忘表4.1</h1><p>The liar’s punishment is, not in the least that he is not believed, but that he cannot believe anyone else.</p><ul><li>abosorption 吸收</li><li>accelerate 加速</li><li>accumulation 积累</li><li>acquisition 获得</li></ul><h1>每日一话+单词遗忘表4.2</h1><p>There are dark shadows on the earth, but its lights are stronger in the contrast.</p><ul><li>admminttance 允许进入</li></ul><h1>每日一话+单词遗忘表4.3</h1><p>Healing is a matter of time, but it is sometimes also a matter of opportunity.</p><ul><li>adverb 副词</li><li>advisor 顾问</li><li>advocate 主张</li><li>aerial 空气</li><li>affair 事情</li><li>affluent 丰富的</li></ul><h1>每日一话+单词遗忘表4.4</h1><p>Death is not the opposite of life, but the part of it.</p><ul><li>affordability 支付能力</li><li>ageing 变老</li><li>agent 议题</li><li>aggression 侵略</li></ul><h1>每日一话+单词遗忘表4.5</h1><p>The ones that love us never really leave us.</p><ul><li>acquaintance 熟悉的人</li><li>aeroplance 飞机</li><li>album 相册</li><li>alcohol 酒精</li><li>alert 使警觉</li><li>allegation 陈述</li><li>alliance 联盟</li></ul><h1>每日一话+单词遗忘表4.6</h1><p>The time is always right to do what is right.</p><ul><li>alternative 可供选择的</li><li>altitude 高度</li><li>aisle 通道</li><li>amusement 娱乐活动</li></ul><h1>每日一话+单词遗忘表4.7</h1><p>There is no such thing as a moral or immoral book. Books are well written or badly written. That is all.</p><ul><li>ancestry 祖先</li><li>anchhor 锚</li><li>annoyance 恼怒</li><li>anonymity 匿名</li><li>anticipate 先于</li></ul><h1>每日一话+单词遗忘表4.8</h1><p>Be not angry that you cannot make others as you wish them to be, since you cannot make yourself as you wish to be.</p><ul><li>accusation 谴责</li><li><strong>apparatus</strong> 运动器材</li><li>apparent 表面上的</li><li>appliance 器具</li></ul><h1>每日一话+单词遗忘表4.9</h1><p>You don’t write because you want to say something, you write because you have something to say.</p><ul><li>applause 鼓掌</li><li>appoint 指定</li><li>allegation 陈述</li><li>applicable 合适的</li><li>aptitude 自然倾向</li><li>arbitrary 随意的</li><li>arithmetic 算术</li></ul><h1>每日一话+单词遗忘表4.10</h1><p>Every block of stone has a statue inside it and it is the task of the sculptor to discover it.</p><ul><li>armament 武器</li><li>arouse 引起</li><li>article 物品</li><li>ass 驴子</li><li>assent 资产</li></ul><h1>每日一话+单词遗忘表4.11</h1><p>You are never too old to set another goal or to dream a new dream.</p><ul><li>assistance 援助</li><li>astonishment 惊讶</li><li>astronaut 宇航员</li><li>atomic 原子的</li><li>attain 达到</li></ul><h1>每日一话+单词遗忘表4.12</h1><p>Nature never deceives us; it is always us who deceive ourselves.</p><ul><li>alcoholic 酒鬼</li><li>attorney 代理人</li><li>attribute 把…归结</li><li>authentic 真正的</li><li>authoritative 权威的</li><li>at length 详细的</li><li>beyond question 毫无疑问</li><li>at this rate 按照这个速度</li><li>at the mercy of 任凭摆布</li></ul><h1>每日一话+单词遗忘表4.13</h1><p>The soul of a journey is liberty, perfect liberty, to think, feel, and do just as one pleases.</p><ul><li>avenue 大道</li><li>aviation 航空</li><li>awesome 很好的</li><li>bachelor 单身汉</li><li>authenticity 可靠的</li><li>every now and then 时不时</li><li>by chance 偶然的</li><li>except for 除了</li></ul><h1>每日一话+单词遗忘表4.14</h1><p>You will do foolish things, but do them with enthusiasm.</p><ul><li>bacon 熏肉</li><li>badge 徽章</li><li>for the sake of 为了…的利益</li><li>every other 每隔一个的</li><li>in accordance of 符合条例</li></ul><h1>每日一话+单词遗忘表4.15</h1><p>In the long river of history, there are moments that shine like stars, illuminating the path of human progress.</p><ul><li>bankrupt 破产</li><li>balcony 阳台</li><li>In brief 总而言之</li></ul><h1>每日一话+单词遗忘表4.16</h1><p>You may not control all the events that happen to you, but you can decide not to be reduced by them.</p><ul><li>beggar 乞丐</li><li>by virtue of 依靠</li><li>in person 亲自</li></ul><h1>4.17</h1><p>Things alter for the worse spontaneously, if they be not altered for the better designedly</p><ul><li>behaviour 行为</li><li>betray 背叛</li><li>arousal 激励</li><li>avenue 大道</li><li>as a matter of fact 事实上</li></ul><h1>4.18</h1><p>A good scare is worth more to a man than good advice.</p><ul><li>betrayal 背叛</li><li>beverage 饮料</li><li>bias 偏见</li><li>bind 捆绑</li><li>biochemistry 生物化学</li><li>biographer 传记作者</li><li>in step with 与…一致</li><li>hand in hand 紧密关联</li></ul><h1>4.19</h1><p>Good rain knows its time right; It will fall when comes spring.</p><ul><li>biscuit 饼干</li><li>blame 责任</li><li>bless 祝福</li><li>blonde 金色的</li></ul><h1>4.20</h1><p>Don’t go around saying the world owes you a living. The world owes you nothing. It was here first.</p><ul><li>boiler 锅炉</li><li>bolt 门闩</li><li>bondgae 奴役</li><li>bonus 津贴</li></ul><h1>4.21</h1><p>There is nothing more deceptive than an obvious fact.</p><ul><li>bounce 弹力</li><li>bowel 肠子</li><li>bracket 支架</li><li>brake 刹车</li><li>brass 黄铜</li></ul><h1>4.23</h1><p>Books are a guide in youth and an entertainment for age.</p><ul><li>breeze 微风</li><li>bribery 行贿</li><li>briefcase 公文包</li><li>brilliance 卓越的</li></ul><h1>4.24</h1><p>The world goes up and the world goes down. And the sunshine follows the rain. And yesterday’s sneer and yesterday’s frown can never come over again.</p><ul><li>brutal 残忍的</li><li>buck 🦌</li><li>bud 芽</li><li>bulk 体积</li><li>bulletin 公告</li><li>bumper 丰盛的</li></ul><h1>4.25</h1><p>Every difficulty slurred over will be a ghost to disturb your repose later on.</p><ul><li>cabl 电缆</li><li>cafeteria 自助餐厅</li></ul><h1>4.26</h1><p>The freshness of her beauty was indeed gone, but its indescribable majesty and its indescribable charm remained.</p><ul><li>camel 骆驼</li><li>candidate 候选者</li><li></li></ul><h1>4.27</h1><p>Learning is not attained by chance; it must be sought for with ardor and attended to with diligence.</p><ul><li>carriage 车厢</li><li>cartoonist 漫画家</li><li>cashier 出纳员</li><li>castle 城堡</li><li>catalogue 目录</li><li>cattle 家畜</li><li></li></ul><h1>4.28</h1><p>Authority without wisdom is like a heavy axe without an edge, fitter to bruise than to polish.</p><ul><li>caution 小心</li><li>cease 停止</li><li>ceiling 天花板</li><li>cargo 货船</li><li>cement 水泥</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/04/01/en8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode 每日一题</title>
      <link>https://blog.tokenlen.top/2025/04/01/leetcodedayone/</link>
      <guid>https://blog.tokenlen.top/2025/04/01/leetcodedayone/</guid>
      <pubDate>Mon, 31 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;4.1&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/solving-questions-with-brainpower/&quot;&gt;解决智力问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你一个下标从 &lt;strong&gt;0&lt;/strong&gt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>4.1</h1><p><a href="https://leetcode.cn/problems/solving-questions-with-brainpower/">解决智力问题</a></p><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>questions</code> ，其中 <code>questions[i] = [pointsi, brainpoweri]</code> 。</p><p>这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong> （也就是从问题 <code>0</code> 开始依次解决），针对每个问题选择 <strong>解决</strong> 或者 <strong>跳过</strong> 操作。解决问题 <code>i</code> 将让你 <strong>获得</strong> <code>pointsi</code> 的分数，但是你将 <strong>无法</strong> 解决接下来的 <code>brainpoweri</code> 个问题（即只能跳过接下来的 <code>brainpoweri</code> 个问题）。如果你跳过问题 <code>i</code> ，你可以对下一个问题决定使用哪种操作。</p><ul><li><p>比方说，给你</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</span><br></pre></td></tr></table></figure><p>：</p><ul><li>如果问题 <code>0</code> 被解决了， 那么你可以获得 <code>3</code> 分，但你不能解决问题 <code>1</code> 和 <code>2</code> 。</li><li>如果你跳过问题 <code>0</code> ，且解决问题 <code>1</code> ，你将获得 <code>4</code> 分但是不能解决问题 <code>2</code> 和 <code>3</code> 。</li></ul></li></ul><p>请你返回这场考试里你能获得的 <strong>最高</strong> 分数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution101</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">mostPoints</span><span class="params">(<span class="type">int</span>[][] questions)</span>&#123;</span><br><span class="line">        <span class="type">long</span>[] memo = <span class="keyword">new</span> <span class="title class_">long</span>[questions.length];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,questions,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[][] questions,<span class="type">long</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=memo.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">notChoose</span>  <span class="operator">=</span> dfs(i+<span class="number">1</span>,questions,memo);</span><br><span class="line">        <span class="type">long</span> <span class="variable">choose</span> <span class="operator">=</span> dfs(i+questions[i][<span class="number">1</span>]+<span class="number">1</span>,questions,memo)+questions[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> memo[i] = Math.max(notChoose,choose);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>questions</strong> [i][0}: 当前问题的分数。</p><p><strong>questions[i][1}</strong>: 如果选择当前问题，你需要跳过接下来的 <code>questions[i][1]</code> 个问题。</p><h1>4.2</h1><p><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-i/">有序三元组中的最大值 I</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>请你从所有满足 <code>i &lt; j &lt; k</code> 的下标三元组 <code>(i, j, k)</code> 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 <code>0</code> 。</p><p><strong>下标三元组</strong> <code>(i, j, k)</code> 的值等于 <code>(nums[i] - nums[j]) * nums[k]</code> 。</p><p>两个变量 <em>mx</em> 和 <em>mxDiff</em> 分别维护前缀最大值和最大差值</p><p>ans维护答案；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution102</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>,mxDiff = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            ans = Math.max(ans,mxDiff*x);</span><br><span class="line">            mxDiff = Math.max(mx-x,mxDiff);</span><br><span class="line">            mx  = Math.max(mx,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.3</h1><p><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/">有序三元组中的最大值 II</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>请你从所有满足 <code>i &lt; j &lt; k</code> 的下标三元组 <code>(i, j, k)</code> 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 <code>0</code> 。</p><p><strong>下标三元组</strong> <code>(i, j, k)</code> 的值等于 <code>(nums[i] - nums[j]) * nums[k]</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            ans = Math.max(ans,(<span class="type">long</span>) maxDiff*x);</span><br><span class="line">            maxDiff = Math.max(maxDiff,preMax-x);</span><br><span class="line">            preMax = Math.max(preMax,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.4</h1><p>给你一个有根节点 <code>root</code> 的二叉树，返回它 <em>最深的叶节点的最近公共祖先</em> 。</p><p>回想一下：</p><ul><li><strong>叶节点</strong> 是二叉树中没有子节点的节点</li><li>树的根节点的 <strong>深度</strong> 为 <code>0</code>，如果某一节点的深度为 <code>d</code>，那它的子节点的深度就是 <code>d+1</code></li><li>如果我们假定 <code>A</code> 是一组节点 <code>S</code> 的 <strong>最近公共祖先</strong>，<code>S</code> 中的每个节点都在以 <code>A</code> 为根节点的子树中，且 <code>A</code> 的深度达到此条件下可能的最大值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution104</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Pair&lt;Integer,TreeNode&gt; <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">0</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Pair&lt;Integer,TreeNode&gt; left = dfs(node.left);</span><br><span class="line">        Pair&lt;Integer,TreeNode&gt; right = dfs(node.right);</span><br><span class="line">        <span class="keyword">if</span> (left.getKey()&gt;right.getKey())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(left.getKey()+<span class="number">1</span>,left.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.getKey()&lt;right.getKey())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(right.getKey()+<span class="number">1</span>,right.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(left.getKey()+<span class="number">1</span>,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Integer代表节点的深度，TreeNode代表该节点的公共祖先</p><p>如果左子树的深度大于右子树，表示深度较大的叶子节点在左子树，返回 <code>(left.getKey() + 1, left.getValue())</code>。</p><p>如果右子树的深度大于左子树，表示深度较大的叶子节点在右子树，返回 <code>(right.getKey() + 1, right.getValue())</code>。</p><p>如果左、右子树深度相同，表示当前节点是深度最深的叶子节点的公共祖先，返回 <code>(left.getKey(), node)</code>。</p><p>递归的终止条件是node==null</p><p>返回深度为0，节点为null</p><h1>4.5</h1><p><a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/">找出所有子集的异或总和再求和</a></p><p>一个数组的 <strong>异或总和</strong> 定义为数组中所有元素按位 <code>XOR</code> 的结果；如果数组为 <strong>空</strong> ，则异或总和为 <code>0</code> 。</p><ul><li>例如，数组 <code>[2,5,6]</code> 的 <strong>异或总和</strong> 为 <code>2 XOR 5 XOR 6 = 1</code> 。</li></ul><p>给你一个数组 <code>nums</code> ，请你求出 <code>nums</code> 中每个 <strong>子集</strong> 的 <strong>异或总和</strong> ，计算并返回这些值相加之 <strong>和</strong> 。</p><p>**注意：**在本题中，元素 <strong>相同</strong> 的不同子集应 <strong>多次</strong> 计数。</p><p>数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 的前提条件是：从 <code>b</code> 删除几个（也可能不删除）元素能够得到 <code>a</code> 。</p><p>一般地，设 <em>nums</em> 所有元素的 OR 为 <em>or</em>，<em>nums</em> 的所有子集的异或和的总和为<br>$$<br>or⋅2^n−1<br>$$<br>or |=x等价于 <code>or = or | x;</code>。它的作用是把 <code>or</code> 变量的值与 <code>x</code> 进行按位或运算，然后把结果赋值回 <code>or</code> 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution105</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subsetXORSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">or</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            or |=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> or&lt;&lt;(nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.6</h1><p><a href="https://leetcode.cn/problems/largest-divisible-subset/">最大整除子集</a></p><p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p><ul><li><code>answer[i] % answer[j] == 0</code> ，或</li><li><code>answer[j] % answer[i] == 0</code></li></ul><p>如果存在多个有效解子集，返回其中任何一个均可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution106</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestDivisibleSubset</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(f,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]%nums[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    f[i] = Math.max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[k]&lt;f[i])&#123;</span><br><span class="line">                k=i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span>f[k];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>k;m&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k]%nums[i]==<span class="number">0</span>&amp;&amp;f[i]==m)&#123;</span><br><span class="line">                ans.add(nums[i]);</span><br><span class="line">                k=i;</span><br><span class="line">                --m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们先对数组进行排序，这样可以保证对于任意的 i&lt;j，如果 nums[i] 可以整除 nums[j]，那么 nums[i] 一定在 nums[j] 的左边。</p><p>接下来，我们定义 f[i] 表示以 nums[i] 为最大元素的最大整除子集的大小，初始时 f[i]=1。</p><p>对于每一个 i，我们从左往右枚举 j，如果 nums[i] 可以被 nums[j] 整除，那么 f[i] 可以从 f[j] 转移而来，我们更新 f[i]=max(f[i],f[j]+1)。过程中，我们记录 f[i] 的最大值的下标 k 以及对应的子集大小 m。</p><p><strong>这是i%j部分</strong></p><p>最后，我们从 k 开始倒序遍历，如果 nums[k] 可以被 nums[i] 整除，且 f[i]=m，那么 nums[i] 就是一个整除子集的元素，我们将 nums[i] 加入答案，并将 m 减 1，同时更新 k=i。继续倒序遍历，直到 m=0。</p><p><strong>这是j%i部分</strong></p><h1>4.7(x)</h1><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></p><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> s= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            s+=num;<span class="comment">//总的和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s/=<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][s+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;=s;j++)&#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j] = j&gt;=x&amp;&amp;f[i][j-x]||f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要判断是否能从 <code>nums</code> 选出若干个数，使它们的和等于 <code>s / 2</code>。</p><p>这里 <code>f[i][j]</code> 表示：</p><ul><li>只使用 <code>nums[0] ~ nums[i-1]</code> 这 <code>i</code> 个元素，能否凑出 <code>j</code>。</li></ul><p><strong>状态转移方程</strong>：<br>$$<br>f[i+1][j]=(j≥x) and f[i][j−x] or  f[i][j]<br>$$</p><ul><li>选择当前元素 <code>x</code>：<code>f[i][j-x]</code> 必须为 <code>true</code>，即 <code>j-x</code> 之前能被凑出。</li><li>不选 <code>x</code>：直接继承 <code>f[i][j]</code> 的状态。</li></ul><h1>4.8</h1><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/">使数组元素互不相同所需的最少操作次数</a></p><p>给你一个整数数组 <code>nums</code>，你需要确保数组中的元素 <strong>互不相同</strong> 。为此，你可以执行以下操作任意次：</p><ul><li>从数组的开头移除 3 个元素。如果数组中元素少于 3 个，则移除所有剩余元素。</li></ul><p>**注意：**空数组也视作为数组元素互不相同。返回使数组元素互不相同所需的 <strong>最少操作次数</strong></p><p>一般地，倒着遍历 nums，如果 nums[i] 之前遍历过，意味着下标在 [0,i] 中的元素都要移除，这一共有 i+1 个数。每次操作移除 3 个数，全部移除完，需要操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!seen.add(nums[i]))&#123;<span class="comment">//nums[i]在seen中</span></span><br><span class="line">                <span class="keyword">return</span> i/<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.9</h1><p><a href="https://leetcode.cn/problems/minimum-operations-to-make-array-values-equal-to-k/">使数组的值全部为 K 的最少操作次数</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>如果一个数组中所有 <strong>严格大于</strong> <code>h</code> 的整数值都 <strong>相等</strong> ，那么我们称整数 <code>h</code> 是 <strong>合法的</strong> 。</p><p>比方说，如果 <code>nums = [10, 8, 10, 8]</code> ，那么 <code>h = 9</code> 是一个 <strong>合法</strong> 整数，因为所有满足 <code>nums[i] &gt; 9</code> 的数都等于 10 ，但是 5 不是 <strong>合法</strong> 整数。</p><p>你可以对 <code>nums</code> 执行以下操作：</p><ul><li>选择一个整数 <code>h</code> ，它对于 <strong>当前</strong> <code>nums</code> 中的值是合法的。</li><li>对于每个下标 <code>i</code> ，如果它满足 <code>nums[i] &gt; h</code> ，那么将 <code>nums[i]</code> 变为 <code>h</code> 。</li></ul><p>你的目标是将 <code>nums</code> 中的所有元素都变为 <code>k</code> ，请你返回 <strong>最少</strong> 操作次数。如果无法将所有元素都变 <code>k</code> ，那么返回 -1</p><p>本质是<strong>计算不同元素个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution109</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Arrays.stream(nums).min().getAsInt();<span class="comment">//获取最小值</span></span><br><span class="line">        <span class="keyword">if</span> (k&gt;min)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">//不存在</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">distinctCount</span> <span class="operator">=</span> (<span class="type">int</span>)Arrays.stream(nums).distinct().count();<span class="comment">//记录不同数字个数</span></span><br><span class="line">        <span class="keyword">return</span> distinctCount-(k==min?<span class="number">1</span>:<span class="number">0</span>);<span class="comment">//等于就1，不等就0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.10(x)</h1><p><a href="https://leetcode.cn/problems/count-the-number-of-powerful-integers/">统计强大整数的数目</a></p><p>给你三个整数 <code>start</code> ，<code>finish</code> 和 <code>limit</code> 。同时给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，表示一个 <strong>正</strong> 整数。</p><p>如果一个 <strong>正</strong> 整数 <code>x</code> 末尾部分是 <code>s</code> （换句话说，<code>s</code> 是 <code>x</code> 的 <strong>后缀</strong>），且 <code>x</code> 中的每个数位至多是 <code>limit</code> ，那么我们称 <code>x</code> 是 <strong>强大的</strong> 。</p><p>请你返回区间 <code>[start..finish]</code> 内强大整数的 <strong>总数目</strong> 。</p><p>如果一个字符串 <code>x</code> 是 <code>y</code> 中某个下标开始（<strong>包括</strong> <code>0</code> ），到下标为 <code>y.length - 1</code> 结束的子字符串，那么我们称 <code>x</code> 是 <code>y</code> 的一个后缀。比方说，<code>25</code> 是 <code>5125</code> 的一个后缀，但不是 <code>512</code> 的后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> String t;</span><br><span class="line">    <span class="keyword">private</span> Long[] f;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">numberOfPowerfulInt</span><span class="params">(<span class="type">long</span> start, <span class="type">long</span> finish, <span class="type">int</span> limit, String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        t = String.valueOf(start - <span class="number">1</span>);</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">Long</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> dfs(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        t = String.valueOf(finish);</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">Long</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> dfs(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> b - a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">boolean</span> lim)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.length() &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!lim &amp;&amp; f[pos] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.length() - pos == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> lim ? (s.compareTo(t.substring(pos)) &lt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> lim ? t.charAt(pos) - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">        up = Math.min(up, limit);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= up; ++i) &#123;</span><br><span class="line">            ans += dfs(pos + <span class="number">1</span>, lim &amp;&amp; i == (t.charAt(pos) - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!lim) &#123;</span><br><span class="line">            f[pos] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>4.11</h1><p><a href="https://leetcode.cn/problems/count-symmetric-integers/">统计对称整数的数目</a></p><p>给你两个正整数 <code>low</code> 和 <code>high</code> 。</p><p>对于一个由 <code>2 * n</code> 位数字组成的整数 <code>x</code> ，如果其前 <code>n</code> 位数字之和与后 <code>n</code> 位数字之和相等，则认为这个数字是一个对称整数。</p><p>返回在 <code>[low, high]</code> 范围内的 <strong>对称整数的数目</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution111</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSymmetricIntegers</span><span class="params">(<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x=low;x&lt;=high;++x)&#123;</span><br><span class="line">            ans +=f(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>+x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;++i)&#123;</span><br><span class="line">            a +=s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n/<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">            b +=s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a==b ?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个简单的枚举，先看是不是能被2整除，能就是1，不能就是0</p><p>然后分别遍历前面的和，和后面的和，看是不是想等</p><p>相等返回1不相等返回0</p><p>然后遍历【low,high]</p><p>返回ans这个和</p><h1>4.12</h1><p><a href="https://leetcode.cn/problems/find-the-count-of-good-integers/">统计好整数的数目</a></p><p>给你两个 <strong>正</strong> 整数 <code>n</code> 和 <code>k</code> 。</p><p>如果一个整数 <code>x</code> 满足以下条件，那么它被称为 <strong>k</strong> <strong>回文</strong> 整数 。</p><ul><li><code>x</code> 是一个 回文整数 。</li><li><code>x</code> 能被 <code>k</code> 整除。</li></ul><p>如果一个整数的数位重新排列后能得到一个 <strong>k 回文整数</strong> ，那么我们称这个整数为 <strong>好</strong> 整数。比方说，<code>k = 2</code> ，那么 2020 可以重新排列得到 2002 ，2002 是一个 k 回文串，所以 2020 是一个好整数。而 1010 无法重新排列数位得到一个 k 回文整数。</p><p>请你返回 <code>n</code> 个数位的整数中，有多少个 <strong>好</strong> 整数。</p><p><strong>注意</strong> ，任何整数在重新排列数位之前或者之后 <strong>都不能</strong> 有前导 0 。比方说 1010 不能重排列得到 101 。</p><p>本质上计算的是「<strong>有重复元素的排列个数</strong>」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution112</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countGoodIntegers</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] factorial = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        factorial[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            factorial[i]=factorial[i-<span class="number">1</span>]*i;</span><br><span class="line">        &#125;<span class="comment">//阶乘</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; vis = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//去重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">10</span>,(n-<span class="number">1</span>)/<span class="number">2</span>);<span class="comment">//前半部分的起始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=base;i&lt;base*<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(i);</span><br><span class="line">            s+=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().substring(n%<span class="number">2</span>);<span class="comment">//构造回文</span></span><br><span class="line">            <span class="keyword">if</span> (Long.parseLong(s)%k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] sortedS = s.toCharArray();</span><br><span class="line">            Arrays.sort(sortedS);</span><br><span class="line">            <span class="keyword">if</span> (!vis.add(<span class="keyword">new</span> <span class="title class_">String</span>(sortedS)))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//去重</span></span><br><span class="line">            <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//次数</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">char</span> c:sortedS)&#123;</span><br><span class="line">                 cnt[c-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (n-cnt[<span class="number">0</span>])*factorial[n-<span class="number">1</span>];<span class="comment">//不能以0为开头，然后乘以(n-1)!</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> c:cnt)&#123;</span><br><span class="line">                 res/=factorial[c];</span><br><span class="line">             &#125;<span class="comment">//去掉重复数字</span></span><br><span class="line">             ans+=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>4.13</h1><p><a href="https://leetcode.cn/problems/count-good-numbers/">统计好数字的数目</a></p><p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 <strong>0</strong> 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （<code>2</code>，<code>3</code>，<code>5</code> 或 <code>7</code>）。</p><ul><li>比方说，<code>&quot;2582&quot;</code> 是好数字，因为偶数下标处的数字（<code>2</code> 和 <code>8</code>）是偶数且奇数下标处的数字（<code>5</code> 和 <code>2</code>）为质数。但 <code>&quot;3245&quot;</code> <strong>不是</strong> 好数字，因为 <code>3</code> 在偶数下标处但不是偶数。</li></ul><p>给你一个整数 <code>n</code> ，请你返回长度为 <code>n</code> 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对 <code>109 + 7</code> <strong>取余后返回</strong> 。</p><p>一个 <strong>数字字符串</strong> 是每一位都由 <code>0</code> 到 <code>9</code> 组成的字符串，且可能包含前导 0 。</p><p>这个好数字的定义是排序的来的</p><p>长度为n的数字，a为偶数下表的数量 a=[n/2]=[n+1/2] 一共五个偶数，02468</p><p>奇数下标的数量为b=[n/2] 一共4个质数2357</p><p>所以总个数为<br>$$<br>5<br>^a<br>4 ^<br>b<br>$$</p><p>所以代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution113</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodNumbers</span><span class="params">(<span class="type">long</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(pow(<span class="number">5</span>,(n+<span class="number">1</span>)/<span class="number">2</span>)*pow(<span class="number">4</span>,n/<span class="number">2</span>)%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> n)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((n&amp;<span class="number">1</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res = res*x%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            x =x*x%MOD;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中注意取mod</p><h1>4.14</h1><p><a href="https://leetcode.cn/problems/count-good-triplets/">统计好三元组</a></p><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code></li></ul><p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p><p>返回 <strong>好三元组的数量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution114</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodTriplets</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.abs(arr[i]-arr[j])&lt;=a&amp;&amp;Math.abs(arr[j]-arr[k])&lt;=b&amp;&amp;Math.abs(arr[i]-arr[k])&lt;=c)&#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不用多说，直接暴力破解遍历就可以</p><h1>4.15</h1><p><a href="https://leetcode.cn/problems/count-good-triplets-in-an-array/">统计数组中好三元组数目</a></p><p>给你两个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>nums1</code> 和 <code>nums2</code> ，两者都是 <code>[0, 1, ..., n - 1]</code> 的 <strong>排列</strong> 。</p><p><strong>好三元组</strong> 指的是 <code>3</code> 个 <strong>互不相同</strong> 的值，且它们在数组 <code>nums1</code> 和 <code>nums2</code> 中出现顺序保持一致。换句话说，如果我们将 <code>pos1v</code> 记为值 <code>v</code> 在 <code>nums1</code> 中出现的位置，<code>pos2v</code> 为值 <code>v</code> 在 <code>nums2</code> 中的位置，那么一个好三元组定义为 <code>0 &lt;= x, y, z &lt;= n - 1</code> ，且 <code>pos1x &lt; pos1y &lt; pos1z</code> 和 <code>pos2x &lt; pos2y &lt; pos2z</code> 都成立的 <code>(x, y, z)</code> 。</p><p>请你返回好三元组的 <strong>总数目</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span>[] tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>]; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">goodTriplets</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        n = nums1.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [4,0,1,3,2] -&gt; [0,1,2,3,4]</span></span><br><span class="line">        <span class="comment">// [4,1,0,2,3] -&gt; [0,2,1,4,3]</span></span><br><span class="line">        <span class="comment">// 左边小于当前数的数量[0,1,1,3,3]</span></span><br><span class="line">        <span class="comment">// 右边大于当前数的数量[4,2,2,0,0]</span></span><br><span class="line">        <span class="comment">// ans = sum(left[i] * right[i]);</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; num2idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            num2idx.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;   <span class="comment">// nums2  [4,1,0,2,3] -&gt; [0,2,1,4,3]的过程</span></span><br><span class="line">            nums2[i] = num2idx.get(nums2[i]);</span><br><span class="line">        &#125;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> query(nums2[i] + <span class="number">1</span>); <span class="comment">// 树状数组查询 左边小于nums2[i]的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> i - l; <span class="comment">// 左边大于nums2[i]的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (n - nums2[i] - <span class="number">1</span>) - t; <span class="comment">// 右边大于nums2[i]的数</span></span><br><span class="line">            add(nums2[i] + <span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">            ans += <span class="number">1L</span> * l * r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowbit(i)) ans += tree[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>映射，将nums1映射到nums[2]上来</p><p>然后把 <code>nums2</code> 中的每个值变成它在 <code>nums1</code> 中的索引。</p><p>lowbit返回最低位的1</p><p>query返回前缀和</p><p>add在x的位置上加u</p><p>l 意思是小于nums2[i]的数，比当前元素小的数有几个出现在之前。</p><p>t 是左边大于当前值的数</p><p>r是右边大于nums2[i]的数</p><h1>4.16</h1><p><a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/"> 统计好子数组的数目</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中 <strong>好</strong> 子数组的数目。</p><p>一个子数组 <code>arr</code> 如果有 <strong>至少</strong> <code>k</code> 对下标 <code>(i, j)</code> 满足 <code>i &lt; j</code> 且 <code>arr[i] == arr[j]</code> ，那么称它是一个 <strong>好</strong> 子数组。</p><p><strong>子数组</strong> 是原数组中一段连续 <strong>非空</strong> 的元素序列。</p><ol><li>如果窗口中有 <em>c</em> 个元素 <em>x</em>，再进来一个 <em>x</em>，会新增 <em>c</em> 个相等数对。</li><li>如果窗口中有 <em>c</em> 个元素 <em>x</em>，再去掉一个 <em>x</em>，会减少 <em>c</em>−1 个相等数对。</li></ol><p>用一个哈希表 <em>cnt</em> 维护子数组（窗口）中的每个元素的出现次数，以及相同数对的个数 <em>pairs</em></p><p>从小到大枚举子数组右端点 right。现在准备把 x=nums[right] 移入窗口，那么窗口中有 cnt[x] 个数和 x 相同，所以 pairs 会增加 cnt[x]。然后把 cnt[x] 加一。</p><p>相同的去掉一个x,窗口中会减少cnt[x]-1个相等对数，然后cnt[x]-1</p><p>再去移动左端点</p><p>当右端点<strong>固定</strong>在 <em>right</em> 时，左端点在 0,1,2,…,<em>left</em>−1 的所有子数组都是满足要求的，这一共有 <em>left</em> 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution116</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countGood</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">long</span> ans= <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> pairs= <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cnt.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            pairs+=c;<span class="comment">//jin</span></span><br><span class="line">            cnt.put(x,c+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (pairs&gt;=k)&#123;<span class="comment">//至少k对</span></span><br><span class="line">                x=nums[left];</span><br><span class="line">                c= cnt.get(x);</span><br><span class="line">                pairs -=(c-<span class="number">1</span>);<span class="comment">//chu</span></span><br><span class="line">                cnt.put(x,c-<span class="number">1</span>);</span><br><span class="line">                left++;<span class="comment">//右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans+=left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>4.17</h1><p><a href="https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/"> 统计数组中相等且可以被整除的数对</a></p><p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回满足 <code>0 &lt;= i &lt; j &lt; n</code> ，<code>nums[i] == nums[j]</code> 且 <code>(i * j)</code> 能被 <code>k</code> 整除的数对 <code>(i, j)</code> 的 <strong>数目</strong> 。</p><p>直接暴力for循环枚举就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution117</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPairs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;nums.length;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;++i)&#123;</span><br><span class="line">                ans +=nums[i]==nums[j]&amp;&amp;(i*j%k)==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$$<br>0 &lt;= i &lt; j &lt; n<br>$$</p><p>根据这个条件确定for循环的边界，然后直接暴力破解就行</p><h1>4.18</h1><p><a href="https://leetcode.cn/problems/count-number-of-bad-pairs/">统计坏数对的数目</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果 <code>i &lt; j</code> 且 <code>j - i != nums[j] - nums[i]</code> ，那么我们称 <code>(i, j)</code> 是一个 <strong>坏****数对</strong> 。</p><p>请你返回 <code>nums</code> 中 <strong>坏数对</strong> 的总数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution118</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countBadPairs</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span>  <span class="operator">=</span> (<span class="type">long</span>)n*(n-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i]-i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cnt.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            ans -=c;</span><br><span class="line">            cnt.put(x,c+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设所有的对数都是坏对，那么总对数一共是n*(n-1)/2</p><p>可以把问题转化为，数组 <code>nums[i] - i</code>，然后统计这些值的频次</p><p><code>Map.getOrDefault(key, defaultValue)</code>：</p><ul><li>如果 <code>key</code> 存在，返回对应的值；</li><li>如果不存在，返回 <code>defaultValue</code>。</li></ul><p><code>Map.put(key, value)</code>：</p><ul><li>如果 <code>key</code> 已存在，覆盖原值；</li><li>否则新增一项。</li></ul><p>这样来统计次数</p><p>附带题目：</p><p><a href="https://leetcode.cn/problems/number-of-good-pairs/">好数对的数目</a></p><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p><p>返回好数对的数目。</p><p>很简单，就是反过来就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution118a</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIdenticalPairs</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cnt.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            ans+=c;</span><br><span class="line">            cnt.put(x,c+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.19</h1><p><a href="https://leetcode.cn/problems/count-the-number-of-fair-pairs/">统计公平数对的数目</a></p><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，和两个整数 <code>lower</code> 和 <code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p><p>如果 <code>(i, j)</code> 数对满足以下情况，则认为它是一个 <strong>公平数对</strong> ：</p><ul><li><code>0 &lt;= i &lt; j &lt; n</code>，且</li><li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution119</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countFairPairs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lower, <span class="type">int</span> upper)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> lowerBound(nums,j,upper-nums[j]+<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> lowerBound(nums,j,lower-nums[j]);</span><br><span class="line">            ans += r-l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用二分查找，最后target=right</p><p><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code>进行移项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意要在 [<span class="number">0</span>, j-<span class="number">1</span>] 中二分，因为题目要求两个下标 i &lt; j</span><br></pre></td></tr></table></figure><p>因为不相等的话upper那个就要+1</p><p>lower-nums[i]</p><p>upper-nums[j]+1</p><p>最后两个数量相减的和就是对数，就是答案</p><h1>4.20</h1><p><a href="https://leetcode.cn/problems/rabbits-in-forest/">781. 森林中的兔子</a></p><p>森林中有未知数量的兔子。提问其中若干只兔子 <strong>“还有多少只兔子与你（指被提问的兔子）颜色相同?”</strong> ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p><p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution120</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRabbits</span><span class="params">(<span class="type">int</span>[] answers)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ans= <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; left = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:answers)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> left.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="number">0</span>)&#123;</span><br><span class="line">                ans+=x+<span class="number">1</span>;</span><br><span class="line">                left.put(x,x);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left.put(x,c-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行一次遍历，如果c==0的话，说明递归完了</p><p>不等于0的话，就执行c-1，直到为0的时候开始执行if下面的语句</p><p>累加ans为x+1,正好多他自己一个</p><p>其他的也可以返回x</p><h1>4.21</h1><p><a href="https://leetcode.cn/problems/count-the-hidden-sequences/">2145. 统计隐藏数组数目</a></p><p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>differences</code> ，它表示一个长度为 <code>n + 1</code> 的 <strong>隐藏</strong> 数组 <strong>相邻</strong> 元素之间的 <strong>差值</strong> 。更正式的表述为：我们将隐藏数组记作 <code>hidden</code> ，那么 <code>differences[i] = hidden[i + 1] - hidden[i]</code> 。</p><p>同时给你两个整数 <code>lower</code> 和 <code>upper</code> ，它们表示隐藏数组中所有数字的值都在 <strong>闭</strong> 区间 <code>[lower, upper]</code> 之间。</p><ul><li><p>比方说，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">differences = [1, -3, 4]</span><br></pre></td></tr></table></figure><p>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower = 1</span><br></pre></td></tr></table></figure><p>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upper = 6</span><br></pre></td></tr></table></figure><p>，那么隐藏数组是一个长度为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>且所有值都在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>（包含两者）之间的数组。</p><ul><li><code>[3, 4, 1, 5]</code> 和 <code>[4, 5, 2, 6]</code> 都是符合要求的隐藏数组。</li><li><code>[5, 6, 3, 7]</code> 不符合要求，因为它包含大于 <code>6</code> 的元素。</li><li><code>[1, 2, 3, 4]</code> 不符合要求，因为相邻元素的差值不符合给定数据。</li></ul></li></ul><p>请你返回 <strong>符合</strong> 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 <code>0</code> 。</p><p>显然，最大值的合法区间为 <code>[lower + d, upper]</code></p><p>计算此区间的长度<code>upper - (lower + d) + 1</code></p><p><img src="https://pic.leetcode.cn/1745208903-cOwZpy-Screenshot%202025-04-21%20at%2012.14.48.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2145</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArrays</span><span class="params">(<span class="type">int</span>[] differences,<span class="type">int</span> lower,<span class="type">int</span> upper)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>,minS = <span class="number">0</span>,maxS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d:differences)&#123;</span><br><span class="line">            s+=d;</span><br><span class="line">            minS = Math.min(minS,s);</span><br><span class="line">            maxS = Math.max(maxS,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) Math.max(upper-lower-maxS+minS+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.22</h1><p>该日的题目太难，已然放弃🆒</p><h1>4.23</h1><p><a href="https://leetcode.cn/problems/count-largest-group/">1399. 统计最大组的数目</a></p><p>给你一个整数 <code>n</code> 。请你先求出从 <code>1</code> 到 <code>n</code> 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p><p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1399</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcDigitSum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ds +=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countLargestGroup</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span> String.valueOf(n).length();</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[m*<span class="number">9</span>+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ds</span> <span class="operator">=</span> calcDigitSum(i);</span><br><span class="line">            cnt[ds]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[ds]&gt;maxCnt)&#123;</span><br><span class="line">                maxCnt = cnt[ds];</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cnt[ds]==maxCnt)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calcDigitSum函数求这个数的位数和</p><p>cnt来存住数据</p><p>ds是第i个的位数和</p><p>如果位数和大于max，max更新，ans=1</p><p>如果cnt[ds]等于max的话，ans增加</p><h1>4.24</h1><p><a href="https://leetcode.cn/problems/count-complete-subarrays-in-an-array/?envType=daily-question&amp;envId=2025-04-24">2799统计完全子数组的数目</a></p><p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code> 。</p><p>如果数组中的某个子数组满足下述条件，则称之为 <strong>完全子数组</strong> ：</p><ul><li>子数组中 <strong>不同</strong> 元素的数目等于整个数组不同元素的数目。</li></ul><p>返回数组中 <strong>完全子数组</strong> 的数目。</p><p><strong>子数组</strong> 是数组中的一个连续非空序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2799</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countCompleteSubarrays</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            set.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span>  <span class="operator">=</span> set.size();</span><br><span class="line">        Map&lt;Integer,Integer&gt; cnt =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            cnt.merge(x,<span class="number">1</span>,Integer::sum);<span class="comment">//cnt[x]++</span></span><br><span class="line">                <span class="keyword">while</span> (cnt.size()==k)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                    <span class="keyword">if</span> (cnt.merge(out,-<span class="number">1</span>,Integer::sum)==<span class="number">0</span>)&#123;<span class="comment">//--cnt[out]==0,左边该出的时候</span></span><br><span class="line">                        cnt.remove(out);</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans +=left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面其中数组越长说明不同的元素越多，越是合法的</p><p>这里采用滑动窗口的用法</p><p>如果 nums[right] 加入哈希表后，发现哈希表的大小等于 k，说明子数组满足要求，移动子数组的左端点 left，把 nums[left] 的出现次数减一。如果 nums[left] 的出现次数变成 0，则从 cnt 中去掉，表示子数组内少了一种元素。</p><p>[<em>left</em>,<em>right</em>] 这个子数组是不满足题目要求的，所以合法的就是[left-1,right]</p><p>从[0,right]到【left.right】一共是left个</p><p>把得到的Left加入ans中就是结果</p><p>改进写法：</p><h1>4.25</h1><p><a href="https://leetcode.cn/problems/count-of-interesting-subarrays/">2845. 统计趣味子数组的数目</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，以及整数 <code>modulo</code> 和整数 <code>k</code> 。</p><p>请你找出并统计数组中 <strong>趣味子数组</strong> 的数目。</p><p>如果 <strong>子数组</strong> <code>nums[l..r]</code> 满足下述条件，则称其为 <strong>趣味子数组</strong> ：</p><ul><li>在范围 <code>[l, r]</code> 内，设 <code>cnt</code> 为满足 <code>nums[i] % modulo == k</code> 的索引 <code>i</code> 的数量。并且 <code>cnt % modulo == k</code> 。</li></ul><p>以整数形式表示并返回趣味子数组的数目。</p><p>**注意：**子数组是数组中的一个连续非空的元素序列。</p><p>假如规定一个数组 preprepre，其中 pre[i]pre[i]pre[i] 表示数组 [0,i][0,i][0,i] 的索引数。那么，求解子数组 [l,r][l,r][l,r] 的索引数时，非常简单，直接用 pre[j]−pre[i−1]pre[j]-pre[i-1]pre[j]−pre[i−1] 就能得到。</p><p>这就是<strong>前缀和</strong></p><p>它是一种能将 O(n) 的统计转化为 O(1) 的快速方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2845</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countInterestingSubarrays</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> modulo, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>]+(nums.get(i-<span class="number">1</span>)%modulo==k?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l;r&lt;n;r++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> prefix[r+<span class="number">1</span>] -prefix[l];</span><br><span class="line">                <span class="keyword">if</span> (cnt%modulo==k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写一下，但还是会超时</p><p>使用模运算的加法和减法同余性质，将<br>$$<br>(prefix[r]−prefix[l−1])modmodulo=k<br>$$<br>变形为<br>$$<br>(prefix[r]−k+modulo)modmodulo=prefix[l−1]mod modulo<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2845</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countInterestingSubarrays8</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> modulo, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>]+(nums.get(i-<span class="number">1</span>)%modulo==k?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>;l&lt;n;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l;r&lt;n;r++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> prefix[r+<span class="number">1</span>] -prefix[l];</span><br><span class="line">                <span class="keyword">if</span> (cnt%modulo==k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countInterestingSubarrays</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> modulo, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.size();</span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>]+(nums.get(i-<span class="number">1</span>)%modulo==k?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        countMap.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentMod</span> <span class="operator">=</span> prefix[i]%modulo;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> (currentMod-k+modulo)%modulo;</span><br><span class="line">            ans += countMap.getOrDefault(target,<span class="number">0</span>);</span><br><span class="line">            countMap.put(currentMod,countMap.getOrDefault(currentMod,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.26</h1><p><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">2444. 统计定界子数组的数目</a></p><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>minK</code> 以及 <code>maxK</code> 。</p><p><code>nums</code> 的定界子数组是满足下述条件的一个子数组：</p><ul><li>子数组中的 <strong>最小值</strong> 等于 <code>minK</code> 。</li><li>子数组中的 <strong>最大值</strong> 等于 <code>maxK</code> 。</li></ul><p>返回定界子数组的数目。</p><p>子数组是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2444</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> minK, <span class="type">int</span> maxK)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minI</span> <span class="operator">=</span> -<span class="number">1</span>,maxI = -<span class="number">1</span>,i0=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (x==minK)&#123;</span><br><span class="line">                minI = i;<span class="comment">//更新</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x==maxK)&#123;</span><br><span class="line">                maxI = i;<span class="comment">//更新</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;minK||x&gt;maxK)&#123;</span><br><span class="line">                i0=i;<span class="comment">//i0不包含在里面</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans +=Math.max(Math.min(minI,maxI)-i0,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.27</h1><p><a href="https://leetcode.cn/problems/count-subarrays-of-length-three-with-a-condition/">3392. 统计符合条件长度为 3 的子数组数目</a></p><p>给你一个整数数组 <code>nums</code> ，请你返回长度为 3 的 子数组 的数量，满足第一个数和第三个数的和恰好为第二个数的一半。</p><p><strong>子数组</strong> 指的是一个数组中连续 <strong>非空</strong> 的元素序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3392</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i-<span class="number">2</span>]+nums[i])*<span class="number">2</span>==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看中间的项和前面后面的关系即可</p><h1>4.28</h1><p><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">2302. 统计得分小于 K 的子数组数目</a></p><p>一个数组的 <strong>分数</strong> 定义为数组之和 <strong>乘以</strong> 数组的长度。</p><ul><li>比方说，<code>[1, 2, 3, 4, 5]</code> 的分数为 <code>(1 + 2 + 3 + 4 + 5) * 5 = 75</code> 。</li></ul><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中分数 <strong>严格小于</strong> <code>k</code> 的 <strong>非空整数子数组数目</strong>。</p><p><strong>子数组</strong> 是数组中的一个连续元素序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution2302&#123;</span><br><span class="line">    public long countSubarrays(int[] nums,long k)&#123;</span><br><span class="line">        long ans = 0;</span><br><span class="line">        long sum = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        for (int right = 0;right&lt;nums.length;right++)&#123;</span><br><span class="line">            sum +=nums[right];</span><br><span class="line">            while (sum*(right-left+1)&gt;=k)&#123;</span><br><span class="line">                sum -=nums[left];</span><br><span class="line">                left++;//下一项</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=right-left+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在left,right这里面的数组都行</p><p>数量是right-left+1个</p><p>加入ans即可</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/04/01/leetcodedayone/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql面试题目</title>
      <link>https://blog.tokenlen.top/2025/03/15/mysql12/</link>
      <guid>https://blog.tokenlen.top/2025/03/15/mysql12/</guid>
      <pubDate>Fri, 14 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础&lt;/h1&gt;
&lt;h2 id=&quot;1-什么是mysql&quot;&gt;1.什么是mysql&lt;/h2&gt;
&lt;p&gt;MySQL 是一个&lt;strong&gt;开源的关系型数据库&lt;/strong&gt;，现在隶属于 Oracle 公司。是我们国内使用频率最高的一种数据库，我在本地安装的是最新的 8.3</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础</h1><h2 id="1-什么是mysql">1.什么是mysql</h2><p>MySQL 是一个<strong>开源的关系型数据库</strong>，现在隶属于 Oracle 公司。是我们国内使用频率最高的一种数据库，我在本地安装的是最新的 8.3 版本。</p><p><strong>怎么删除建立一张表？</strong></p><p>使用DROP TABLE 来删除表</p><p>CREATE TABLE来创建表</p><p>创建表的时候可以使用PRIMARY KEY来创建主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE users (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100) NOT NULL,</span><br><span class="line">    email VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>写一个升序/降序的sql语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>, name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p>排序的第一依据是salary 降序，第二一依据是name 升序</p><p><strong>MYsql出现性能差的原因是什么？</strong></p><p>可能是sql查询的时候使用了全表扫描，也可能是查询语句过于复杂</p><p>也有可能是单表数据量过大。</p><p>我们可以添加索引来解决大部分问题，对于一些热点数据，可以使用Redis缓存</p><h2 id="2-表的连接">2.表的连接</h2><p>内连接：</p><p>返回两个表中有<strong>匹配关系</strong>的行，找出两张表的<strong>交集</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT users.name, orders.order_id</span><br><span class="line">FROM users</span><br><span class="line">INNER JOIN orders ON users.id = orders.user_id;</span><br></pre></td></tr></table></figure><p>INNER JOIN orders ON <a href="http://users.id">users.id</a> = orders.user_id;连接条件：</p><p><a href="http://users.id">users.id</a> = orders.user_id</p><p>外连接：</p><p>不仅返回两个表中匹配的行，还返回没有匹配的行，用 <code>null</code> 来填充。</p><p>想当与找<strong>并集</strong></p><p>left join右表没匹配的null填充</p><p>right join左表没匹配的null填充</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.id, users.name, orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure><p>交叉连接：</p><p>返回两张表的<strong>笛卡尔积</strong>，也就是将左表的每一行与右表的每一行进行组合，返回的行数是两张表行数的乘积。</p><h2 id="3-数据库的三大范式">3.数据库的三大范式</h2><p>第一范式：确保表的每一列都是<strong>不可分割的基本数据单元</strong>，比如说用户地址，应该拆分成省、市、区、详细地址等 4 个字段。</p><p>第二范式：要求表中的<strong>每一列都和主键直接相关</strong>。比如在订单表中，商品名称、单位、商品价格等字段应该拆分到商品表中。</p><p>第三范式：<strong>非主键列应该只依赖于主键列</strong>。比如说在设计订单信息表的时候，可以把客户名称、所属公司、联系方式等信息拆分到客户信息表中，然后在订单信息表中用客户编号进行关联。</p><p>建表的原则：</p><p>考虑表是否符合数据库的三大范式，确保字段不可再分，消除非主键依赖，确保字段仅依赖于主键等。</p><p>然后在选择字段类型时，应该尽量选择合适的数据类型。</p><p>在字符集上，尽量选择 utf8mb4，这样不仅可以支持中文和英文，还可以支持表情符号等。</p><p>当数据量较大时，比如上千万行数据，需要考虑分表。比如订单表，可以采用水平分表的方式来分散单表存储压力。</p><h2 id="4-varchar和char的区别">4.varchar和char的区别</h2><p>varchar是可变长度的字符类型，原则上最多可以容纳 65535 个字符，但考虑字符集，以及 MySQL 需要 1 到 2 个字节来表示字符串长度，所以实际上最大可以设置到 65533。</p><p>varch中空格也要占一个字节</p><p>char是固定长度的字符类型，当定义一个 <code>CHAR(10)</code> 字段时，不管实际存储的字符长度是多少，都只会占用 10 个字符的空间。如果插入的数据小于 10 个字符，剩余的部分会用空格填充。</p><h2 id="5-blob和text有什么区别">5.blob和text有什么区别</h2><p>blob用于存储二进制数据，如图片音频等等，但是实际应用中，我们会把这些文件存储到oss或者文件服务器上，数据库存储文件的url</p><p>text用于存储文本数据，如文章评论等。</p><h2 id="6-DATETIME和TIMESTAMP有什么区别">6.DATETIME和TIMESTAMP有什么区别</h2><p>DATETIME直接存储日期和时间的完整值，与时区无关。</p><p>TIMESTAMP存储的是 Unix 时间戳，1970-01-01 00:00:01 UTC 以来的秒数，受<strong>时区</strong>影响。</p><p>DATETIME 的默认值为 <strong>null</strong>，占用 <strong>8</strong> 个字节；TIMESTAMP 的默认值为当前时间——<strong>CURRENT_TIMESTAMP</strong>，占 <strong>4</strong> 个字节，实际开发中更常用，因为可以自动更新。</p><h2 id="7-in和exists的区别">7.in和exists的区别</h2><p>使用 IN 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着<strong>子查询的结果集需要全部加载到内存</strong>中。</p><p>EXISTS 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 <code>EXISTS</code> 条件为真。<code>EXISTS</code> 关注的是<strong>子查询是否返回行</strong>，而不是返回的具体值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 可以利用关联索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o </span><br><span class="line">            <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> u.id <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>In适用于子查询结果集较小的情况。如果子查询返回大量数据，<code>IN</code> 的性能可能会下降，因为它需要将整个结果集加载到内存。</p><p>EXISTS适用于子查询结果集可能很大的情况。由于 <code>EXISTS</code> 只需要判断子查询是否返回行，而不需要加载整个结果集，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p><p><strong>NUll值陷？</strong></p><p>IN：如果子查询的结果集中包含 <code>NULL</code> 值，可能会导致意外的结果。例如，<code>WHERE column IN (subquery)</code>，如果 <code>subquery</code> 返回 <code>NULL</code>，则 <code>column IN (subquery)</code> 永远不会为真，除非 <code>column</code> 本身也为 <code>NULL</code>。</p><p>EXISTS：对 <code>NULL</code> 值的处理更加直接。<code>EXISTS</code> 只是检查子查询是否返回行，不关心行的具体值，因此不受 <code>NULL</code> 值的影响。</p><h2 id="8-记录货币">8.记录货币</h2><p>货币在数据库中 MySQL 常用 <strong>Decimal</strong> 和 <strong>Numeric</strong> 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。</p><p>salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。</p><p>不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有<strong>一定的误差</strong>。</p><p>会出现大问题的！</p><h2 id="9-如何存储emoji">9.如何存储emoji</h2><p>utf8 字符集仅支持最多 3 个字节的 UTF-8 字符，但是 emoji 表情（😊）是 4 个字节的 UTF-8 字符，所以在 MySQL 中存储 emoji 表情时，需要使用 utf8mb4 字符集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h2 id="10-drop-delete-turncate的区别">10.drop,delete,turncate的区别</h2><p>都表示删除，但是三者有一些差别：</p><table><thead><tr><th>区别</th><th>delete</th><th>truncate</th><th>drop</th></tr></thead><tbody><tr><td>类型</td><td>属于 DML</td><td>属于 DDL</td><td>属于 DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>从数据库中删除表，所有数据行，索引和权限也会被删除</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。</p><h2 id="11-UNION和UNION-ALL的区别">11.UNION和UNION ALL的区别</h2><ul><li>如果使用 UNION，会在表链接后<strong>筛选掉重复</strong>的记录行</li><li>如果使用 UNION ALL，不会合并重复的记录行</li><li>从效率上说，UNION ALL 要比 UNION 快很多，如果合并<strong>没有刻意要删除重复行，那么就使用 UNION All</strong></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/15/mysql12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sql原理之索引</title>
      <link>https://blog.tokenlen.top/2025/03/07/sql3/</link>
      <guid>https://blog.tokenlen.top/2025/03/07/sql3/</guid>
      <pubDate>Thu, 06 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;引入&lt;/h1&gt;
&lt;p&gt;MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>引入</h1><p>MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p><h1>常见的查询算法以及数据结构</h1><p>建立索引，其实就是为了构建一种数据结构，可以应用到上面的一种算法。提供查询的效率</p><p>索引的本质是：</p><p>帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是<strong>数据结构</strong>。</p><p>如果没用索引的话，会按照上下顺序来查找，就会匹配整张表，这叫全表扫描，这样的效率是很低的。</p><p>而mysql中的索引是在引擎层中实现的</p><p>b+tree索引最常见的都支持</p><p>hash索引精确匹配memory支持</p><p>r-tree索引空间位置myisam支持</p><p>full-text索引除了memory不支持其他都支持</p><p>b-tree多路平衡查找树</p><p>几阶b-tree就最多有几个节点，会有n+1个指针</p><h2 id="查询算法">查询算法</h2><p>顺序查找：</p><p>对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。</p><p>数据结构是<strong>队列</strong></p><p>时间复杂度是O(n)</p><p>二分查找：</p><p>查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。</p><p>数据结构是<strong>数组</strong></p><p>时间复杂度：O(logn)</p><p>二叉排序树查找：</p><p>二叉排序树的特点是：</p><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ol><p>搜索的原理：</p><ol><li>若b是空树，则搜索失败，否则：</li><li>若x等于b的根节点的数据域之值，则查找成功；否则：</li><li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li><li>查找右子树。</li></ol><p>数据结构是<strong>二叉排序树</strong></p><p>时间复杂度：O(log2N)</p><p>哈希表：其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。</p><p>数据结构：哈希表</p><p>时间复杂度：几乎是<code>O(1)</code>，取决于产生冲突的多少（hash碰撞）。</p><p>分块查找：</p><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”<strong>按块有序</strong>”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，依次类推。<br>　　<br>算法流程：</p><ol><li>先选取各块中的最大关键字构成一个索引表；</li><li>查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</li></ol><p>这种搜索算法每一次比较都使<strong>搜索范围缩小一半</strong>。它们的查询速度就有了很大的提升，复杂度为。</p><p>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><h2 id="B-tree">B-tree</h2><p>B树，它就是一种平衡多路查找树。下图就是一个典型的B树：</p><p><img src="https://img-blog.csdn.net/20160926140212457" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/3e9a3201e1f546bc88cc9aa83e5ad078.jpeg" alt=""></p><p><strong>满了中间元素向上分裂</strong>每一个key都会对应</p><p>由于B-Tree的特性，在B-Tree中按<strong>key检索数据</strong>的算法非常直观：首先从根节点进行<strong>二分查找</strong>，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。</p><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为<code>logd((N+1)/2)</code>，检索一个key，其查找节点个数的渐进复杂度为<code>O(logdN)</code>。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><h2 id="B-Tree">B+Tree</h2><p>在b+树中所有的元素都会在叶子节点，叶子节点会形成一个单向链表，<strong>非叶子节点</strong>只会起到<strong>索引</strong>的作用</p><p>mysql的所有，会形成了一个带有顺序的指针b+tree</p><p>所有的数据都会在<strong>叶子节点</strong>，用来存储数据，存储在页中</p><p>特点：</p><ul><li>每个节点的指针上限为2d而不是2d+1；</li><li>内节点不存储data，只存储key；</li><li>叶子节点不存储指针；</li></ul><p>下面就是一个B+Tree</p><p><img src="https://img-blog.csdn.net/20160926140413000" alt=""></p><p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p>为什么innodb引擎选择使用b+tree？</p><ul><li><p>对于b+树对于二叉树的层级更少，搜索效率高</p></li><li><p>相对于b-ree无论是叶子节点还是非叶子节点，都会保存<strong>数据</strong>，会导致键值变少，指针变少，同样要保留大量数据，只能增加树的高度，导致性能降低</p></li><li><p>对于hash索引来说，可以<strong>范围索引和排序</strong></p></li></ul><h1>涉及的计算机原理</h1><h2 id="两种类型的存储">两种类型的存储</h2><p>在计算机系统中一般包含两种类型的存储，<strong>计算机主存</strong>（RAM）和<strong>外部存储器</strong>（如硬盘、CD、SSD等）。在设计索引算法和存储结构时，我们必须要考虑到这两种类型的存储特点。主存的读取速度快，相对于主存，外部磁盘的数据读取速率要比主从慢好几个数量级，具体它们之间的差别后面会详细介绍。 上面讲的所有查询算法都是假设数据存储在计算机主存中的，计算机主存一般比较小，实际数据库中数据都是存储到外部存储器的。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以<strong>索引文件的形式存储的磁盘上</strong>。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，<strong>所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度</strong>。换句话说，**索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。**下面详细介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h2 id="主存存取原理">主存存取原理</h2><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p><p><img src="https://img-blog.csdn.net/20160926140724145" alt=""></p><p>从抽象角度看，<strong>主存是一系列的存储单元组成的矩阵</strong>，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。</p><p>主存的存取过程如下：</p><p>当系统需要读取主存时，则将<strong>地址信号放到地址总线</strong>上传给主存，主存读到地址信号后，解析信号并定位到<strong>指定存储单元</strong>，然后将此存储单元数据放到<strong>数据总线</strong>上，供其它部件读取。写主存的过程类似，系统将要写入单元地址和数据分别放在<strong>地址总线和数据总线</strong>上，主存读取两个总线的内容，做相应的写操作。</p><p>这里可以看出，<strong>主存存取的时间仅与存取次数呈线性关系</strong>，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h2 id="磁盘存取原理">磁盘存取原理</h2><p>上文说过，索引一般以<strong>文件</strong>形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>磁盘读取数据靠的是<strong>机械运动</strong>，当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，<strong>即确定要读的数据在哪个磁道，哪个扇区</strong>。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，<strong>磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，<strong><strong><strong>然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间</strong></strong>，最后便是对读取数据的传输。 所以每次读取数据花费的时间可以分为</strong>寻道时间、旋转延迟、传输时间</strong>三个部分。其中：</p><ul><li>寻道时间是<strong>磁臂移动到指定磁道</strong>所需要的时间，主流磁盘一般在5ms以下。</li><li>旋转延迟就是我们经常听说的<strong>磁盘转速</strong>，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。</li><li>传输时间指的是<strong>从磁盘读出或将数据写入磁盘的时间</strong>，一般在零点几毫秒，相对于前两个时间可以忽略不计。</li></ul><p>那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><h2 id="局部性原理和磁盘预读">局部性原理和磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，<strong>磁盘往往不是严格按需读取，而是每次都会预读</strong>，即使只需要一个字节，<strong>磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存</strong>。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p><p>由于<strong>磁盘顺序读取</strong>的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为<strong>页（page）的整倍数</strong>。页是<strong>计算机管理存储器的逻辑块</strong>，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，<strong>每个存储块称为一页</strong>（在许多操作系统中，页得大小通常为<strong>4k</strong>），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h1>性能分析</h1><h2 id="B-Tree-2">B-Tree</h2><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问<code>h-1</code>个节点（根节点常驻内存）。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，<strong>这样每个节点只需要一次I/O就可以完全载入</strong>。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，<strong>就实现了一个node只需一次I/O</strong>。一个节点物理上也是存在一个页里面</p><p>B-Tree中一次检索<strong>最多需要<code>h-1</code>次I/O</strong>（根节点常驻内存），渐进复杂度为<code>O(h)=O(logdN)</code>。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，如果我们**采用B-Tree存储结构，搜索时I/O次数一般不会超过3次，**所以用B-Tree作为索引结构效率是非常高的。</p><h2 id="B-Tree-3">B+Tree</h2><p>从上面介绍我们知道，B树的搜索复杂度为<code>O(h)=O(logdN)</code>，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以<strong>增加出度d的宽度</strong>，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmax=floor(pagesize/(keysize+datasize+pointsize))//floor表示向下取整</span><br></pre></td></tr></table></figure><p>由于B+Tree内节点去掉了data域，因此可以拥有<strong>更大的出度</strong>，从而拥有更好的性能。</p><p>B-树和B+树查找过程基本一致。如上图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生<strong>一次IO</strong>，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生<strong>第二次IO</strong>，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，<strong>发生第三次IO</strong>，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，**3层的b+树可以表示上百万的数据，**如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><p><img src="https://img-blog.csdn.net/20160926141127260" alt=""></p><p>所以说很多数据的话，也只需要<strong>3次IO</strong>，这样的话效率就非常高了。</p><h1>mysql中的索引</h1><h2 id="基础知识">基础知识</h2><p>索引的分类：</p><p>主键索引，对于主键的创建的索引，只能有<strong>一个</strong>，默认自动创建 <strong>primary</strong></p><p>唯一索引，避免同一个表中的数据列的值重复，<strong>unique</strong></p><p>常规索引 快速定位数据</p><p>全文索引 查找文本中的关键字，而不是索引中的值，关键词<strong>fulltext</strong></p><p>还分为</p><p>聚集索引：数据存储和索引放在一个，必须有而且<strong>只能有一个</strong></p><p>二级索引，将数据和索引分开，<strong>叶子节点关联的是对应的主键</strong></p><p>聚集索引：</p><ul><li>存在主键，<strong>主键索引就是聚集索引</strong></li><li>不存在主键，将会引用第一个唯一索引作为聚集索引</li><li>没有主键，没有唯一索引，Innodb会自动生成一个rowid作为隐藏的聚集索引</li></ul><p>回表查询：先走二级索引找到对应的主键值，再到聚集索引中拿到这一行的行数据</p><p>思考：</p><p>innodb的b+tree高度是多少？</p><p><strong>16*1171^h</strong>,高度为h</p><p>语法：</p><p>创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE/FULLLTEXT] INDEX INDEX_NAME ON TABLE_NAME(INDEX_COL_NAME...);</span><br></pre></td></tr></table></figure><p>一个索引是可以关联多个字段的</p><p>查看索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from table_name;</span><br></pre></td></tr></table></figure><p>删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table_name;</span><br></pre></td></tr></table></figure><p>索引名字格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idx_user_name;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_name <span class="keyword">ON</span> uers(name);</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">UNIQUE</span> INDEX idx_users_email <span class="keyword">ON</span> users(email);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_users_name_age <span class="keyword">ON</span> users(name,age);</span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDXE id_users_bio <span class="keyword">ON</span> users(bio);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="keyword">DROP</span> INDEX id_users_name <span class="keyword">ON</span> users;</span><br></pre></td></tr></table></figure><h2 id="sql优化">sql优化</h2><p>查询当前数据的增删改查执行效率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;</span><br></pre></td></tr></table></figure><p>可以统计 <code>Com_select</code>、<code>Com_insert</code>、<code>Com_update</code>、<code>Com_delete</code> 等的执行次数，判断数据库的查询负载。</p><p><strong>慢查询：</strong></p><p>查询当前sql超时标准（默认long_query_time为10s，超过10s的记录才会查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;long_query_time&#x27;;</span><br></pre></td></tr></table></figure><p>开启慢查询日志，编辑 <strong><code>/etc/my.cnf</code></strong> 或 <strong><code>my.ini</code></strong>（Windows）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询慢查询日志文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;slow_query_log_file&#x27;;</span><br></pre></td></tr></table></figure><p>然后 <code>cat</code> 或 <code>tail -f</code> 这个文件，查看慢查询 SQL。</p><p><strong>PROFILES：</strong></p><p>查看sql执行的时间分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br></pre></td></tr></table></figure><p>默认是关闭的状态，需要手动开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET profiling = 1;</span><br></pre></td></tr></table></figure><p>执行查询完成后，再次查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILE CPU FOR QUERY 16;</span><br></pre></td></tr></table></figure><p>这里 <code>16</code> 是 <code>SHOW PROFILES</code> 里查询的 <code>Query_ID</code>，可以查看具体 SQL 的 <strong>CPU 耗时</strong> 详情。</p><p><strong>explain:</strong></p><p>EXPLAIN + sql语句可以看到sql语句的执行情况</p><p>返回的详情为：</p><p>id:sql执行的顺序，数值越大，越先执行</p><p>select_type:</p><ul><li>simple 简单查询 不用表连接和子查询</li><li>primary 主查询 即外层的查询</li><li>union union后的查询 union中的第二个或者后面的查询语句</li><li>subquery 子查询 select/where之后包含了子查询</li></ul><p>type：查询类型，效率从高到低排序</p><ul><li>null</li><li>system</li><li>const</li><li>eq_ref</li><li>ref</li><li>range</li><li>index</li><li>all 全表扫描</li></ul><p>possible_keys：可能用到的索引</p><p>key:实际用到的索引</p><p>key_len：索引的长度</p><p>rows：预估扫描的行数</p><p>filtered:过滤后返回的行数占比，越大越好</p><h2 id="索引的原则">索引的原则</h2><p><strong>最左前缀法则：</strong></p><p>查询使用索引要从索引的最左列开始，不能跳过，跳过的话，后面的索引会失效。</p><p>必须包含最左边的一列，在哪无所谓，必须要存在</p><p>比如我们建立一个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br></pre></td></tr></table></figure><p>如果我们sql语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27;;</span><br><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; AND age = 30;</span><br></pre></td></tr></table></figure><p>这样的话索引不会失效，但是如果从age开始的话，索引就会失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE age = 30;</span><br></pre></td></tr></table></figure><p><strong>范围查询：</strong></p><p>联合查询中，出现范围查询（&lt;&gt;）范围查询右侧的索引列失效</p><p>使用大于等于或者小于等于就可以避免后面的索引失效</p><p>比如我们建立一个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br></pre></td></tr></table></figure><p>进行精确查询，索引不会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; AND age = 30;</span><br></pre></td></tr></table></figure><p>但是进行范围查询的时候，后面的索引就会失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; AND age &gt; 25 AND city = &#x27;New York&#x27;;</span><br></pre></td></tr></table></figure><p><strong>索引列运算操作：</strong></p><p>不饿能在索引列上进行运算操作，否则索引会失效</p><p>不能不加单引号，否则索引也会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE YEAR(created_at) = 2024;</span><br></pre></td></tr></table></figure><p>这样索引会失效的</p><p>但是我们进行一些优化，进行范围查询（带着等于的），索引就不会失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE created_at &gt;= &#x27;2024-01-01&#x27; AND created_at &lt; &#x27;2025-01-01&#x27;;</span><br></pre></td></tr></table></figure><p><strong>模糊查询：</strong></p><p>尾部进行模糊查询，索引不会失效，头部进行模糊匹配索引会失效。</p><p>后面加%可以进行索引，前面加%索引就会失效，一般别写这种sql语句</p><p>尾部匹配是有效的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name LIKE &#x27;Alice%&#x27;;</span><br></pre></td></tr></table></figure><p>但是头部匹配索引就会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name LIKE &#x27;%Alice&#x27;;</span><br></pre></td></tr></table></figure><p>如果我们想使用模糊匹配的话，可以使用FULLTEXT索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX idx_users_bio ON users(bio);</span><br><span class="line">SELECT * FROM users WHERE MATCH(bio) AGAINST(&#x27;keyword&#x27;);</span><br></pre></td></tr></table></figure><p>这样来进行匹配查询</p><p><strong>OR</strong>：</p><p>OR左右两侧都要有索引，否则索引会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27; OR age = 30;</span><br></pre></td></tr></table></figure><p>为了不让其失效，我们可以使用UNION ALL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &#x27;Alice&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT * FROM users WHERE age = 30;</span><br></pre></td></tr></table></figure><p><strong>数据分布影响索引：</strong></p><p>索引适用于高选择性字段（不同值较多的列）</p><p>如果 <strong>查询大量数据</strong>，可能 <strong>全表扫描比索引更快</strong>，可以<strong>忽略索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users IGNORE INDEX(idx_user_name) WHERE status = &#x27;active&#x27;;</span><br></pre></td></tr></table></figure><p><strong>sql提示：</strong></p><p>use index使用某个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users USE INDEX(idx_user_name) WHERE name = &#x27;Alice&#x27;;</span><br></pre></td></tr></table></figure><p>ignore index 忽略索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users IGNORE INDEX(idx_user_name) WHERE name = &#x27;Alice&#x27;;</span><br></pre></td></tr></table></figure><p>force index 强制使用某个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM users FORCE INDEX(idx_user_name) WHERE name = &#x27;Alice&#x27;;</span><br></pre></td></tr></table></figure><p><strong>覆盖索引：</strong></p><p>查询的字段都在索引列内，可以避免回表，提高查询效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br><span class="line">SELECT name, age FROM users WHERE name = &#x27;Alice&#x27;; -- 只查询索引列，避免回表</span><br></pre></td></tr></table></figure><p><strong>前缀过长：</strong></p><p>适用于字符串索引过长的情况，只索引字符串的一部分</p><p>计算型索引（越接近1.0越好）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT email) / COUNT(*) FROM users;</span><br></pre></td></tr></table></figure><p>前缀索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_email_5 ON users(email(5)); -- 仅索引 email 前 5 个字符</span><br></pre></td></tr></table></figure><p><strong>联合索引：</strong></p><p>更推荐联合索引，索引效率更加高效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_user_name_age ON users(name, age);</span><br></pre></td></tr></table></figure><p>大原则：</p><ul><li>数据量大，查询比较频繁的表要建立索引，对查询条件进行索引，尽量使用<strong>联合索引</strong>。</li><li>要使用区分度高的索引</li><li>字符串类型的索引，要建立前缀索引。要考虑前缀的区分度</li><li>要控制索引的效率</li><li>索引不能存储null值，建立表的时候要采用not null的约束</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/07/sql3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络重要问题总结</title>
      <link>https://blog.tokenlen.top/2025/03/06/net3/</link>
      <guid>https://blog.tokenlen.top/2025/03/06/net3/</guid>
      <pubDate>Wed, 05 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础</h1><h2 id="1-说下计算机网络体系结构">1.说下计算机网络体系结构</h2><p>计算机网络体系结构通过复杂的网络通信分为不同的层次，来实现交互化的目的。常见的模型分为OSI七层模型，tcp/ip四层模型和五层体系结构</p><p>OSI是理论上的网络通信模型，TCP/IP是实际应用层面的网络通信模型，五层结构是为了方便理解和记忆</p><p><strong>OSI七层模型</strong>是一个网络架构模型，由国际标准化祖师提出，用于描述和标准化各种计算机网络的功能和过程。这七层分别是<br>应用层：最靠近用户的层，负责处理特定的应用程序细节。这一层提供了网络服务和用户应用软件之间的接口，例如web浏览器,ftp客户端和服务器，电子邮件客户端等等。</p><p>表示层：<strong>确保一个系统发送的信息可以被另一个系统的应用层读取</strong>。负责数据的转换压缩和加密。例如，确保数据从一种编码格式转换为另一种。ASCII-&gt;EBCDIC</p><p>会话层:管理用户的会话，空网络上两节点之间的对话和数据交换的管理。负责建立维护和终止会话。例如建立一个回鹘令牌，以便在网络上两个节点进行传递。</p><p>传输层：提供<strong>端到端</strong>的通信服务，保证数据的完整性和正确顺序。这一层包括TCP和UDP等。</p><p>网络层：负责在多个网络之间进行数据传输，确保数据能够在复杂的网络结构中找到源到目的地的最佳路径，这层使用的是IP协议</p><p>数据链路层：在物理连接中提供可靠的<strong>传输</strong>，负责建立和维护两个相邻节点的链路。包括帧同步,MAC</p><p>物理层:负责在<strong>物理媒介</strong>上实现原始的数据传输，比如电缆光缆和无线信号传输。涉及的内容包括电压，接口，针脚，电缆的规格和传输速率等。</p><p><strong>TCP/IP协议四层模型</strong>是互联网通信的核心，定义了一系列协议和标准，确保设备间可以可靠地进行数据传输。</p><p>应用层：直接面向用户和应用程序，提供各种网络服务。它包含了用于<strong>特定应用的协议和服务</strong>，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</p><p>传输层：提供<strong>端到端</strong>的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 TCP 和 UDP。</p><p>网络层：负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。</p><p>网络接口层：负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。</p><p><strong>五层结构体系</strong></p><p>对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。</p><ul><li>应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。</li><li>传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。</li><li>网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。</li><li>数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。</li><li>物理层：电缆、光纤、无线电频谱、网络适配器等</li></ul><p>TCP的三次握手和四次挥手在哪一层？</p><p>三次握手和四次挥手都是工作在<strong>传输层</strong>。传输层（Transport Layer）是 OSI 模型的第四层，负责提供端到端的通信服务，包括数据传输的建立、维护和终止。</p><p>TCP作为一种面向连接的协议，通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性和完整性。</p><p>将一下计算机网络？</p><p>计算机网络是指将多台计算机通过<strong>通信设备</strong>互联起来，实现资源共享和信息传递的系统。</p><h2 id="2-说一下每层对应的网络协议有哪些">2.说一下每层对应的网络协议有哪些</h2><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad64bbac-e0d5-4286-9b77-d008e8c8d419.jpg" alt=""></p><h2 id="3-数据在各层之中时怎么传输的">3.数据在各层之中时怎么传输的</h2><p>对发送方而言，从上层到下层层层包装，对于接受方来说，从下层到上层层层解开包装。</p><ul><li>发送方的应用进程向接受方的应用进程传送数据</li><li>AP 先将数据交给本主机的<strong>应用层</strong>，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li><li>传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元</li><li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li><li>最后的物理层，进行比特流的传输</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg" alt=""></p><h1>网络综合</h1><h2 id="4-从浏览器地址栏输入url到显示网页的过程">4.从浏览器地址栏输入url到显示网页的过程</h2><p>过程包括多个步骤，涵盖了 DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 响应、浏览器处理响应并渲染页面等多个环节。</p><ol><li><strong>DNS 解析</strong>：浏览器会发起一个 DNS 请求到 DNS 服务器，将<strong>域名解析为服务器的 IP 地址</strong>。</li><li><strong>TCP 连接</strong>：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接。这一步涉及到 TCP 的三次握手，用于确保双方都已经准备好进行数据传输了。</li><li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求，包括请求行、请求头和请求体；然后将请求发送到服务器。</li><li><strong>服务器处理请求</strong>：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理，生成 HTTP 响应消息；响应消息包括状态行、响应头和响应体。</li><li><strong>浏览器接收 HTTP 响应</strong>：浏览器接收到服务器返回的 HTTP 响应数据后，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。</li><li><strong>断开连接</strong>：TCP 四次挥手，连接结束</li></ol><p>各个过程用了哪些协议：</p><p>DNS解析：DNS协议</p><p>剩下的步骤：TCP协议，IP协议，OPSF协议</p><p>ARP协议，HTTP协议</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f5ff6e46-4524-4594-b294-56a23c366df9.jpg" alt=""></p><h2 id="5-DNS解析的过程">5.DNS解析的过程</h2><p>DNS是域名解析系统，可以将域名映射到对应的IP地址上，</p><p>比如说我们访问 www.tokenlen.top，实际上访问的是我在阿里云上一台丐版服务器，它的 IP 地址是 <a href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a>。</p><p>当然也可以直接使用IP地址来访问，但是IP地址不太好记。</p><p>域名到IP的映射就需要DNS来完成</p><p>DNS解析过程：</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-03408af8-3ca8-49bd-9244-6afa6fe132c6.jpg" alt=""></p><h2 id="6-webSOCKET和Socket的区别">6.webSOCKET和Socket的区别</h2><p>Socket=IP+端口+协议</p><p>是一套标准，完成了对TCP/IP的高度封装，屏蔽网络细节，以便更好的网络编程</p><p>webSocket是一个持久化的协议，伴随H5而出的协议，用来解决</p><p>http不支持持久化连接的问题</p><p>Socket是一个<strong>网络编程的标准接口</strong>，webSocket则是<strong>应用层通信协议</strong></p><h2 id="7-常见的端口及其对应的服务">7.常见的端口及其对应的服务</h2><p>port           server</p><p>21ftp</p><p>22ssh</p><p>23 telent</p><p>53dns</p><p>80http</p><p>443https</p><p>1080sockets</p><p>3306mysql</p><p>5524alist</p><p>8080测试端口</p><h1>HTTP</h1><h2 id="8-http常用的状态码及其意义">8.http常用的状态码及其意义</h2><p>1xx：成功，需要进一步操作,100 continue</p><p>2xx:成功，200ok完成 204缺少一部分body</p><p>3xx:重定向 301 永久重定向,302临时重定向</p><p>4xx:客户端有问题,404资源不存在，403没有权限访问</p><p>5xx:服务器有问题，500服务器内部问题，502网关或者代理出了问题，504网关超时</p><h2 id="9-http请求">9.http请求</h2><p>get：获取数据，是幂等的，不能发送太多，限制2kb</p><p>post:提交数据，不是幂等的，发送一般不限制</p><p>delete:删除指定的资源</p><p>put:更新指定的资源</p><p>herd:类似get请求，返回响应中没有具体的内容，获取报头。用于检查资源资源是否存在，验证资源的更新时间等等</p><p>options:获取服务器支持的Http方法</p><p>trace:回显服务器收到的请求，用于测试</p><p>connect:建立一个到目标资源的隧道，用于客户端和服务器之间进行加密的隧道传输。</p><h2 id="10-get和post请求的区别">10.get和post请求的区别</h2><p>get主要用于获取数据，参数附加在url栏中，存在长度限制,2kb，这个长度限制不是url的限制而是服务器的限制，是针对整个url的限制，而不是对数据部分的限制，容易被浏览器缓存，有安全风险，post用于提交数据，参数放在请求体中,适合提交大量或者敏感的数据。</p><p>get请求是幂等的，多次提交不会改变服务器状态，post请求不是幂等的，可能会对服务器数据有影响。</p><h2 id="11-http请求的过程和原理">11.http请求的过程和原理</h2><p>http是基于tcp/ip协议的应用层协议，使用tcp作为传输层协议，通过建立tcp连接来传输数据</p><p>http遵循标准的客户端-服务器模型，客户端打开连接发出请求，然后等待服务器返回的响应</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-9a1a42b7-c14a-43d8-b8d8-f1f18c9b923b.jpg" alt=""></p><ul><li>在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。</li><li>TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。</li><li>服务器收到请求后，会根据请求的信息处理请求。</li><li>处理完请求后，服务器会返回一个 HTTP 响应给浏览器。</li><li>浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。</li></ul><p>客户端发送一个请求到服务器，服务器处理请求并返回一个响应。这个过程是同步的，也就是说，<strong>客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。</strong></p><p>利用多线程来下载一个数据</p><p>可以采用分块下载的策略，首先使用head来获取文件的总大小，然后根据文件大小和线程数，将文件进行切割，每个线程负责下载一个特定范围的数据</p><p>可以通过设置http请求头的range字段指定下载的字节区间</p><p>例如，<code>Range: bytes=0-1023</code> 表示下载文件的前 1024 字节。</p><p>最后启动多线程下载。</p><h2 id="12-http的报文结构">12.http的报文结构</h2><p>http的报文结构分为请求报文和响应报文</p><p>都包含了起始行，头部，和消息正文</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-2ea62914-e1ed-418c-9580-e13ecf7b8992.jpg" alt=""></p><p>请求报文：</p><p>请求报文由请求行，请求头部，空行和消息正文组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.javabetter.cn</span><br><span class="line">Accept: text/html</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br></pre></td></tr></table></figure><p>GET /index.html HTTP/1.1请求行，包括请求url和http协议的版本</p><p>请求头部包含请求的附加信息：</p><ul><li><code>Host: www.javabetter.cn</code>，表示请求的主机名（域名）</li><li><code>Accept: text/html</code>，表示客户端可以接收的媒体类型</li><li><code>User-Agent: Mozilla/5.0</code>，表示客户端的浏览器类型</li><li>Range：用于指定请求内容的范围，如断点续传时表示请求的字节范围。</li></ul><p>请求头部和消息正文之间有一个空行，表示请求头部结束</p><p>消息正文是可选的，如post请求中的表单数据，get请求没有正文</p><p>响应报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;mengnankk&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>状态行：包括http协议的方法，状态码，和消息状态</p><p>响应头部：</p><ul><li><code>Content-Type: text/plain</code>，表示响应的内容类型</li><li><code>Content-Length: 137582</code>，表示响应的内容长度</li><li><code>Expires: Thu, 05 Dec 1997 16:00:00 GMT</code>，表示资源的过期时间</li><li><code>Last-Modified: Wed, 5 August 1996 15:55:28 GMT</code>，表示资源的最后修改时间</li><li><code>Server: Apache 0.84</code>，表示服务器类型</li></ul><p>空行：表示响应头部结束</p><p>消息正文：响应的具体内容，例如html界面，不是所有的响应都有正文消息，例如204(没有响应中的body)</p><h2 id="13-url和uri有什么区别">13.url和uri有什么区别</h2><p>URI：统一资源标识符(Uniform Resource Identifier， URI)，标识的是 Web <strong>上每一种可用的资源</strong>，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。</p><p>URL：统一资源定位符（Uniform Resource Location），它是 URI 的一种子集，主要作用是<strong>提供资源的路径。</strong></p><p>URL <strong>除了提供了资源的标识，还提供了资源访问的方式</strong>。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx 职业技术学院/14 号宿舍楼/525 号寝/张三.男。</p><h2 id="15-http长连接">15.http长连接</h2><p>在Http中，长连接是指客户端和服务器在完成一次http通信后，连接不会立即断开，而是保留连接以供后序使用</p><p>这种机制可以减少了频繁建立和关闭连接的开销</p><p>设置长连接：通过 <strong>Connection: keep-alive</strong> 实现。在 HTTP/1.1 中，长连接是默认开启的。</p><p>超时：</p><p>http一般会有httpd守护进程，里面可以设置keep-alive timeout，当tcp连接闲置超过这个时间就会关闭，也可以在http里的header里设置超时时间</p><p>TCP 的 <strong>keep-alive</strong> 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. tcp_keepalive_intvl = 15</span><br><span class="line">2. tcp_keepalive_probes = 5</span><br><span class="line">3. tcp_keepalive_time = 1800</span><br></pre></td></tr></table></figure><h2 id="16-http和https的区别">16.http和https的区别</h2><p>https是http的增强版，是在http的基础上加入了ssl/tls协议，确保数据在传输过程中是加密的</p><p>http的默认端口是80,url以<a href="http://xn--2sst8k">http://开头</a>,https默认端口是443,url以<a href="https://xn--2sst8k">https://开头</a></p><p>https基于<strong>传输层</strong>，http基于<strong>应用层</strong></p><p>https在浏览器显示绿色安全锁，http则没有</p><h2 id="17-https连接的建立过程">17.https连接的建立过程</h2><p><img src="https://cdn.tobebetterjavaer.com/stutymore/network-20240418124713.png" alt=""></p><ol><li>客户端向服务器发送请求</li><li>服务器接收到请求后，返回自己的数字证书，包含了公匙，颁发机构等</li><li>客户端接收到服务器的证书后，验证证书的合法性，如果合法，会生成一个随机码，然后用服务器的公匙加密整个随机码，然后发送给服务器</li><li>服务器收到会话密钥后，用私钥解密，得到会话密钥</li><li>客户端和服务器通过会吗密码对通信内容进行加密，然后传输</li></ol><p>通信内容被截取，没有会话密钥，无法解密。新的连接建立后，生成的密钥是新的</p><p><strong>url会被https加密吗？</strong></p><p>https会加密url，因为url是http头部的一部分。但是完整的url可能会在web服务器的日志中记录，浏览器中也是可以看到的。所以敏感信息不应该通过url来传输</p><p><strong>中间人攻击</strong>？</p><p>攻击者可以在通信的两端插入自己，以窃取通信双方的信息。</p><p>中间人攻击是一个<strong>缺乏相互认证</strong>的攻击，因此大多数加密协议都会专门加入一些特殊的认证方法，以防止中间人攻击。像 SSL 协议，就是通过验证服务器的数字证书，是否由 CA（权威的受信任的数字证书认证机构）签发，来防止中间人攻击的</p><p><strong>http如何保证建立的信道是安全的？</strong></p><p>通过 SSL/TLS 协议的多层次安全机制，首先在握手阶段，客户端和服务器使用得是非对称加密，生成的会话密钥只<strong>有服务器的私钥</strong>才能解密，而私钥只有服务器持有。</p><h2 id="18-如何理解http是无状态的">18.如何理解http是无状态的</h2><p>http协议是无状态的，表明每个http请求都是<strong>独立</strong>的，服务器不会保留任何关于<strong>客户端请求的历史信息</strong></p><ul><li>每个 HTTP 请求都包含了所必须的信息，服务器在处理当前请求时，不依赖于之前的任何请求信息。</li><li>服务器不会记录任何客户端请求的状态，每次请求都像是第一次与服务器通信。</li></ul><p>维持记录状态</p><p>cookies：服务器通过 Set-Cookie 响应头将状态信息存储在客户端，客户端在后续请求中发送该 Cookie 以维持状态。</p><p>session：服务器生成一个唯一的会话 ID，存储在 Cookie 中，并在服务器端维护与该会话 ID 关联的状态信息。</p><p>token：使用 JWT（JSON Web Token）等机制在客户端存储状态信息，客户端在每次请求中发送该 Token。</p><h1>tcp</h1><h2 id="19-详细说一下tcp的三次握手机制">19.详细说一下tcp的三次握手机制</h2><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-a6c0457e-544e-4291-98d9-862fc6a18631.jpg" alt=""></p><p>第一次握手：客户端将TCP报文标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p><p>第二次握手：服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个序号值<code>seq=K</code>，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</p><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code>状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>服务器发送完<strong>SYN－ACK</strong>包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的<strong>最大重传次数</strong>，系统将该连接信息从<strong>半连接队列</strong>中删除。</p><p>第三次握手：客户端收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><p><strong>全连接队列</strong>就是三次握手已经完成了，建立起的连接就会放到全连接队列里，队列满了就会出现丢包。</p><p>其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而<strong>第三次握手是可以携带数据</strong>的。</p><p>其中上面的ack和ACK不是同一个概念</p><ul><li>小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，<code>ack=seq+1</code>。</li><li>大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。</li></ul><p><strong>说说SYN的概念</strong></p><p>SYN是TCP 协议中用来建立连接的一个标志位，全称为 Synchronize Sequence Numbers，也就是同步序列编号。</p><p>不仅确保了序列号的同步，使得后续的数据能够有序传输，还能防止旧的报文段被误认为是新连接。</p><p><strong>泛洪攻击</strong></p><p>是一种常见的 DoS（拒绝服务）攻击，攻击者会发送大量的伪造的 TCP 连接请求，导致服务器资源耗尽，无法处理正常的连接请求。</p><p>半连接服务拒绝，也称为 SYN 洪泛攻击或 SYN Flood。</p><p>所谓的半连接就是指在 TCP 的三次握手过程中，当服务器接收到来自客户端的第一个 SYN 包后，它会回复一个 SYN-ACK 包，此时连接处于“半开”状态，因为连接的建立还需要客户端发送最后一个 ACK 包。</p><p>在收到最后的 ACK 包之前，服务器会为这个尚未完成的连接分配一定的资源，并在它的队列中保留这个连接的位置。</p><p>解决方法：</p><p>重新设计 TCP 的连接建立过程，可以考虑引入 SYN cookies，这种技术通过在 SYN-ACK 响应中编码连接信息，从而在不占用大量资源的情况下验证客户端。</p><h2 id="20-tcp握手为什么是三次？">20.tcp握手为什么是三次？</h2><p>使用三次握手可以建立一个可靠的连接，确保双方都知道对方已经准备好通信，同步双方的序列号，保证数据包的顺序和完整。</p><p>为什么不能是两次？</p><ul><li>防止客户端一直在等待</li><li>防止客户端已经将失效的连接请求传输到服务器</li></ul><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad16baac-f8fa-4fb1-a459-8a98e4db85ca.jpg" alt=""></p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-4209349f-b80c-4387-8461-c6ecd0e2129b.jpg" alt=""></p><h2 id="21-三次握手中每一次没收到报文会发生什么情况">21.三次握手中每一次没收到报文会发生什么情况</h2><p>第一次：第一次握手服务端未收到 SYN 报文</p><p>服务器不会进行任何的动作，如果客户端没收到发来的SYN-ACK包的话，等待一段时间后，会重新发送SYN报文，如果仍然没有回复，会重复这个过程。知道发送次数超过最大重传次数之后，返回连接建立失败。</p><p>第二次：第二次握手客户端未收到服务端响应的 ACK 报文</p><p>客户端会继续重传，服务端会阻塞在accpet()处，等待客户端发送ACK报文</p><p>第三次：第三次握手服务端为收到客户端发送过来的 ACK 报文</p><p>服务器同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态。</p><h2 id="22-第二次握手回传了ACK为什么还要传回SYN">22.第二次握手回传了ACK为什么还要传回SYN</h2><p>ACK是为了告诉客户端传输的数据已经接受无误</p><p>SYN是为了告诉客户端，服务器响应的确实是客户端发送的报文。</p><h2 id="23-TCP半连接">23.TCP半连接</h2><p>TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种未完全建立的状态。</p><p>就是第二次握手完成后，但是第三次握手还没完成</p><p>如果服务器回复了 SYN-ACK，但客户端还没有回复 ACK，该连接将一直保留在半连接队列中，直到超时或被拒绝。</p><p><strong>半连接队列</strong></p><p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f95c3cbb-cf2d-4444-9878-44ec076beb86.jpg" alt=""></p><p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p><ul><li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 <strong>ACK 和 SYN</strong>，状态由 <strong>LISTEN 变为 SYN_RCVD</strong>，此时这个连接就被推入了 <strong>SYN 队列</strong>，即半连接队列。</li><li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。</li></ul><p><strong>SYN FLood</strong></p><p>SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造<strong>不存在的 IP 地址</strong>, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 <strong>SYN</strong> 接收队列（半连接队列），使得服务器不能为正常⽤户服务。</p><p>应对方案：</p><p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p><ul><li><strong>syn cookie</strong>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li><li><strong>SYN Proxy 防火墙</strong>：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li></ul><h2 id="24-TCP四次挥手的过程">24.TCP四次挥手的过程</h2><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ba156295-03af-46dc-8ef3-869b44b11303.jpg" alt=""></p><p>第一次挥手：客户端向服务器发送一个FIN结束报文，表示客户端没有数据可以发送了，但仍然可以接受数据，客户端进入FIN-WAIT-1状态</p><p>第二次挥手：服务器接受到FIN报文后，向客户端发送一个ACK报文，表示已经接受到客户端的FIN请求，服务器进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态</p><p>第三次挥手：服务器向客户端发送一个FIN请求，表示服务器也没有数据要发送了，服务器进入LAST-ACK状态</p><p>第四次挥手：客户端接收到FIN报文后，向服务器发送一个ACK请求，确认已经接受到服务器的FIN请求，客户端进入TIME-WAIT状态，等等一段时间后确保服务器接受到ACK请求，服务器收到ACK报文后进入CLOSE状态，客户端等待一段时间（2MSL）后进入CLOSE状态。</p><h2 id="25-为什么需要挥手四次">25.为什么需要挥手四次</h2><p>TCP 是<strong>全双工通信协议</strong>，数据的发送和接收需要两次<strong>一来一回</strong>，也就是四次，<strong>来确保双方都能正确关闭连接</strong>。</p><p><strong>MSL</strong>：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p><strong>为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</p><p><strong>2. 防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p><p>等待 2 倍的 MSL，⽐较合理的解释是：<strong>⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应</strong>，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p><h2 id="26-保活计时器有什么用">26.保活计时器有什么用</h2><p>除去时间等待器以外，TCP 还有一个保活计时器（keepalive timer）。</p><p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p><p>简单点理解就是检测客户端是否存活的一个计时器，设定好时间。</p><h2 id="27-close-wait和time-wait的状态和意义">27.close-wait和time-wait的状态和意义</h2><p>close-wait：</p><p>服务端收到客户端关闭连接的请求并确认之后，就会进入 CLOSE-WAIT 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了<strong>保证服务端在关闭连接之前将待发送的数据处理完。</strong></p><p>time-wait：</p><p>time-wait发生在第四次挥手，当客户端在发送 ACK 确认对方的 FIN 报文后，会进入 TIME_WAIT 状态。</p><ul><li>在 TIME_WAIT 状态中，客户端可以重新发送 ACK 确保对方正常关闭连接。</li><li>在 TIME_WAIT 持续的 <strong>2MSL</strong> 时间后，确保旧数据包完全消失，避免它们干扰未来建立的新连接。</li></ul><h2 id="28-time-wait状态过多会导致什么问题">28.time-wait状态过多会导致什么问题</h2><p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。</p><p>过多的time-wait有两种危害：</p><p>一是内存资源占⽤；</p><p>第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；</p><p>如何解决：</p><ul><li>服务器可以设置 <strong>SO_REUSEADDR</strong> 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。</li><li>还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。</li></ul><h2 id="30-tcp报文头部的格式">30.tcp报文头部的格式</h2><p>TCP 报文段主要由报文段头部（Header）和数据两部分组成。头部包含了确保数据可靠传输所需的各种控制信息，比如说序列号、确认号、窗口大小等。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f74d2a4f-b91e-4d8c-9fe7-6b670d818aed.jpg" alt=""></p><ul><li><strong>源端口号</strong>（Source Port）：16 位（2 个字节），用于标识发送端的应用程序。</li><li><strong>目标端口号</strong>（Destination Port）：也是 16 位，用于标识接收端的应用程序。</li><li><strong>序列号</strong>（Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。</li><li><strong>确认号</strong>（Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。</li><li><strong>数据偏移</strong>（Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。</li><li><strong>保留</strong>（Reserved）：6 位，为将来使用预留，目前必须置为 0。</li><li><strong>控制位</strong>（Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。</li><li><strong>窗口大小</strong>（Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。</li><li><strong>校验和</strong>（Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。</li><li><strong>紧急指针</strong>（Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置。</li></ul><h2 id="31-tcp为什么是可靠的">31.tcp为什么是可靠的</h2><p>首先通过<strong>三次握手</strong>和<strong>四次挥手</strong>来保证连接的可靠性，然后通过校验和、序列号、确认应答、超时重传、滑动窗口等机制来保证数据的可靠传输。</p><p>校验和：</p><p>TCP 报文段包括一个校验和字段，用于检测报文段在传输过程中的变化。如果接收方检测到校验和错误，就会丢弃这个报文段。</p><p>序列号:</p><p>TCP 将数据分成多个小段，每段数据都有唯一的序列号，以确保数据包的顺序传输和完整性。同时，发送方如果没有收到接收方的确认应答，会重传数据。</p><p>流量控制：</p><p>接收方会发送窗口大小告诉发送方它的接收能力。发送方会根据窗口大小调整发送速度，避免网络拥塞。</p><p>超时重传：</p><p>如果发送方发送的数据包超过了最大生存时间，接收方还没有收到，发送方会重传数据包以保证丢失数据重新传输。</p><p>拥塞控制：</p><p>TCP 会采用慢启动的策略，<strong>一开始发的少，然后逐步增加</strong>，当检测到网络拥塞时，会降低发送速率。在网络拥塞缓解后，传输速率也会自动恢复。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/06/net3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT100题</title>
      <link>https://blog.tokenlen.top/2025/03/02/leetcodehot/</link>
      <guid>https://blog.tokenlen.top/2025/03/02/leetcodehot/</guid>
      <pubDate>Sat, 01 Mar 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;hash&lt;/h1&gt;
&lt;h2 id=&quot;1-hash映射&quot;&gt;1.&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>hash</h1><h2 id="1-hash映射">1.<a href="https://leetcode.cn/problems/two-sum/solutions/6873/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/?envType=study-plan-v2&amp;envId=top-100-liked">hash映射</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p>wp:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里主要是用了map映射，</p><p>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 <strong>target-nums[i]</strong> 的 key 值<br>如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止</p><h2 id="2-字母异位词分组">2.<a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p>wp:</p><p>字母相同，但排列不同的字符串，排序后都一定是相同的。因为每种字母的个数都是相同的，那么排序后的字符串就一定是相同的。</p><p>所以我们直接进行排序</p><p>使用stream流来做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">getAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.stream(strs).collect(Collectors.groupingBy(str -&gt; Stream.of(str.split(<span class="string">&quot;&quot;</span>)).sorted().collect(Collectors.joining()))).values());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str -&gt; split -&gt; stream -&gt; sort -&gt; join</p><h2 id="3-128-最长连续序列">3.<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>wp:</p><p>首先本题是不能排序来做的，因为排序的时间复杂度为O(<em>n</em>log<em>n</em>)</p><p>不符合题目的要求</p><p>对于 <em>nums</em> 中的元素 <em>x</em>，以 <em>x</em> 为起点，不断查找下一个数 <em>x</em>+1,<em>x</em>+2,⋯ 是否在 <em>nums</em> 中，并统计序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            st.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:st)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.contains(x-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(st.contains(y))&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,y-x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要使用了hashset来存储nums这个数组</p><p>主要的核心就是for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:st)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.contains(x-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(st.contains(y))&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,y-x);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是去试x周围的数据，x-1和x+1。最后取值y-x获得最大序列的长度</p><h1>双指针</h1><h2 id="4-283-移动零">4.<a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p>wp:</p><p>这里我们参考快速排序的方法，以0为基准元素</p><p>我们使用两个指针 <code>i</code> 和 <code>j</code>，只要 <code>nums[i]!=0</code>，我们就交换 <code>nums[i]</code> 和 <code>nums[j]</code>在</p><p>这样我们很快就能完成排序</p><p>时间复杂度：<em>O</em>(<em>n</em>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j++] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-11-盛最多水的容器">5.<a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>**说明：**你不能倾斜容器。</p><p>用一句话概括双指针解法的要点：<strong>指针每一次移动，都意味着排除掉了一个柱子</strong>。</p><p>如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> (j-i)*Math.min(height[i],height[j]);</span><br><span class="line">            res = Math.max(res,area);</span><br><span class="line">            <span class="keyword">if</span> (height[i]&lt;height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.<a href="https://leetcode.cn/problems/3sum/">三数之和</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><p>首先对数组进行排序</p><p>固定一个数i</p><p>L是i后面一个，R是len的最后一个</p><p>如果nums[i]大于0的话,sum必然大于0</p><p>如果num[i]==nums[i-1]的话，说明数字重复了，需要跳过</p><p>sum==0的时候，nums[L]==nums[L+1]重复舍去</p><p>nums[R] = nums[R-1]重负舍去</p><p>其中L是++的，R是——的</p><p>然后开始编码</p><p>当sum&gt;0的时候说明R太大了，R–</p><p>Sum&lt;0的时候说明L太小了，L++</p><p>wp:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution6</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||len&lt;<span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L] == nums[L+<span class="number">1</span>]) L++;</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R] == nums[R-<span class="number">1</span>]) R--;</span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;<span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="85-接雨水">85.<a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>使用双指针，谁小谁移动规则下，相遇的一定是最高的位置，这个位置不能接水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution85</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span>  <span class="operator">=</span> height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sufMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(preMax,height[left]);</span><br><span class="line">            sufMax  = Math.max(sufMax,height[right]);</span><br><span class="line">            ans +=preMax&lt;sufMax?preMax-height[left++]:sufMax-height[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>滑动窗口</h1><h2 id="6-无重复字符的最长子串">6.<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p>wp:</p><p>hashmap <code>dic</code>统计：指针j遍历字符s，哈希表统计s[j]最后一次出现的索引</p><p>根据上轮i与dis[s[j]]更新左边界i，保证[i+1,j]内无重复字符且最大</p><p>i= max(dic[s[j]],i)</p><p>更新res就是[i+1,j]的len即j-1的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution7</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lenOfLongesSubstring</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; dic  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i=-<span class="number">1</span>,res = <span class="number">0</span>,len =s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dic.containsKey(s.charAt(j)))</span><br><span class="line">                i = Math.max(i,dic.get(s.charAt(j)));</span><br><span class="line">            dic.put(s.charAt(j),j);</span><br><span class="line">            res = Math.max(res,j-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-找到字符串中所有字母异位词">41.<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution41</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s,String p)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right=<span class="number">0</span>,required = p.length();</span><br><span class="line">        <span class="keyword">while</span> (right&lt;s.length())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right) -<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                required--;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c]--;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (required==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right-left==p.length())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.charAt(left)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[l]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    required++;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[l]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] cnt = new int[26];</span><br><span class="line">       for (char c : p.toCharArray()) &#123;</span><br><span class="line">           cnt[c - &#x27;a&#x27;]++;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>来统计p中字符的次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while (right &lt; s.length()) &#123;</span><br><span class="line">            // 处理右侧新进入窗口的字符</span><br><span class="line">            int c = s.charAt(right) - &#x27;a&#x27;;</span><br><span class="line">            if (cnt[c] &gt; 0) &#123;</span><br><span class="line">                required--;  // 需要匹配的字符减少</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c]--;</span><br><span class="line">            right++;  // 扩展窗口</span><br><span class="line"></span><br><span class="line">​        // 当窗口大小等于 p.length()，检查是否是异位词</span><br><span class="line">​        if (required == 0) &#123;</span><br><span class="line">​            ans.add(left);</span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure><p>然后超过了窗口</p><p>需要收缩窗口right - left == p.length()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int l = s.charAt(left) - &#x27;a&#x27;;</span><br><span class="line">               if (cnt[l] &gt;= 0) &#123;</span><br><span class="line">                   required++;  // 需要匹配的字符增加</span><br><span class="line">               &#125;</span><br><span class="line">               cnt[l]++;</span><br><span class="line">               left++;  // 收缩窗口</span><br></pre></td></tr></table></figure><p>跟上面想对应</p><p>最后返回ans</p><p>85.<a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution86</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k )&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>,i=<span class="number">1</span>-k;j&lt;nums.length;i++,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;deque.peekFirst()==nums[i-<span class="number">1</span>])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()&amp;&amp;deque.peekLast()&lt;nums[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)</span><br><span class="line">                res[i] =deque.peekFirst();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体是使用i和j这两个移动的指针来完成窗口的滑动</p><p>nums.length-k+1是窗口可以滑动的次数</p><p>形成首个窗口之前，一直都是队列中加入j</p><p>然后当i&gt;=0了，这个时候形成了滑动窗口，队列中最大的那个元素就可以进入结果res了</p><p>然后继续往下遍历</p><p>遇到对了不为空，并且最后一个小于当前j元素的，把后边的元素移除，在后面加入j</p><p>让队列一直处于递减的状态</p><p>队头移出的时候，将头部删除，把过期元素删除</p><h1>链表</h1><h2 id="7-相交链表">7.<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA, B = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = (A != <span class="literal">null</span>) ? A.next : headB;</span><br><span class="line">            B = (B != <span class="literal">null</span>) ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先处理一下A与B不为空的情况</p><p>最重要的是</p><p>while (A != B) {<br>A = (A != null) ? A.next : headB;<br>B = (B != null) ? B.next : headA;<br>}</p><p>两个具有相同结尾的链表拼接，无论哪一个在前，哪一个在后，这两种拼接方式，他们总能保持最后的一段相同的节点是不变的。</p><h2 id="8-反转链表">8.<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>直接通过双指针反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next; <span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">            cur.next = pre;          <span class="comment">// 修改 next 引用指向</span></span><br><span class="line">            pre = cur;               <span class="comment">// pre 暂存 cur</span></span><br><span class="line">            cur = tmp;               <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.<a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></p><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>这个题是在上面的基础上进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution9</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head,pre  = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span>middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span>  <span class="operator">=</span> reverList(mid);</span><br><span class="line">        <span class="keyword">while</span> (head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val!=head2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">       &#125;<span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找到中间的节点，也就是middleNode函数</p><p>slow比慢等到fast.next到终点的时候.slow就是中间的节点</p><p>然后反正mid那一部分，如果mid与反转后的相同的话，那么就是回文串</p><p>返回ture反之则false</p><h2 id="9-环形链表1">9.环形链表1</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p>如果一个链表存在环，那么<strong>快慢指针必然会相遇</strong>。实现代码如下</p><p>所以我们直接编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution10</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="10-环形链表2">10.环形链表2</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p>根据分析，有环的标识是fast==slow</p><p>然后fast和slow第二次相遇的node就是环的节点</p><p>所以很简单的就可以分析出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution11</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head,slwo = head;</span><br><span class="line">            <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                slwo = slwo.next;</span><br><span class="line">                <span class="keyword">if</span> (fast == slwo) &#123;</span><br><span class="line">                    fast = head;</span><br><span class="line">                    <span class="keyword">while</span> (slwo!=fast)&#123;</span><br><span class="line">                        slwo = slwo.next;</span><br><span class="line">                        fast = fast.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> fast;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接使用两次相遇，相遇的fast就是环的起点；</p><h2 id="11-合并两个有序链表">11.<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>我们使用递归算法</p><p>当两个链表都为空的时候，说明已经合并完毕了</p><p>l1和l2哪个同头节点更小，较小节点的Next指针就指向其余节点的合并结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution12</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">mergeTowLists</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l2==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">                l1.next = mergeTowLists(l1.next,l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l2.next = mergeTowLists(l1,l2.next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="12-两数相加">12.<a href="https://leetcode.cn/problems/add-two-numbers/">两数相加</a></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。‘</p><p>计算每一位的时候要考虑上一位的进位问题，计算结束后同样要跟更新进位</p><p>如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution13</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre;</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line"></span><br><span class="line">                carry = sum / <span class="number">10</span>;</span><br><span class="line">                sum = sum % <span class="number">10</span>;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line"></span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="13-删除链表的倒数第-N-个结点">13.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre<br>start 先向前移动n步<br>之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点</p><p>因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 <code>start.next != null</code></p><p>删除后返回 <code>pre.next</code>，为什么不直接返回 <code>head</code> 呢，因为 <code>head</code> 有可能是被删掉的点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution14</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                pre.next = head;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre, end = pre;</span><br><span class="line">                <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                    start = start.next;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;<span class="comment">//start先提前移动</span></span><br><span class="line">                <span class="keyword">while</span> (start.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    start = start.next;</span><br><span class="line">                    end = end.next;</span><br><span class="line">                &#125;<span class="comment">//一块移动</span></span><br><span class="line">                end.next = end.next.next;<span class="comment">//删除某节点</span></span><br><span class="line">                <span class="keyword">return</span> pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="14-两两交换链表中的节点">14.<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换<br>终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换</p><p>假设链表为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp -&gt; (A) -&gt; (B) -&gt; (C) -&gt; (D) -&gt; null</span><br><span class="line">start -&gt; (B)</span><br><span class="line">end -&gt; (C)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使tmp.next = end;</p><p>链表现在变成了这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(A) -&gt; (C) -&gt; (D) -&gt; null</span><br><span class="line">(B) (断开)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再start.next = end.next;</p><p>(B)就指向了（D）</p><p>end.next = start;</p><p>然后（C）就指向了（B）</p><p>所以链表就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(A) -&gt; (C) -&gt; (B) -&gt; (D) -&gt; null</span><br></pre></td></tr></table></figure><p>最后tmp = start;</p><p>再从B开始继续迭代循环</p><p>最终完成了链表节点的交换</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="comment">//没有节点，或者只剩一个的时候</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs1(next.next);<span class="comment">//</span></span><br><span class="line">        next.next = head;<span class="comment">//后节点等于头节点</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs2</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next!=<span class="literal">null</span>&amp;&amp;tmp.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> tmp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> tmp.next.next;</span><br><span class="line">            tmp.next = end;<span class="comment">//head</span></span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            tmp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-随机链表的复制">15.<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/"> 随机链表的复制</a></h2><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution16</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span>head;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(cur,<span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while (cur!=null){<br>map.put(cur,new Node(cur.val));<br>cur = cur.next;<br>}</p><p>先把链表复制一份</p><p>构建新节点的 <code>next</code> 和 <code>random</code> 引用指向。都是随机的</p><p>然后迭代下一个节点</p><p>最后返回head节点</p><h2 id="16-排序链表">16.<a href="https://leetcode.cn/problems/sort-list/">排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p>我们使用新建链表的方式</p><p>把val值排序后再组成一个新链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution17</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i] = cur.val;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">listNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        cur = listNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[i]);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17-LRU-缓存">17.<a href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a></h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>基于LinkedHashMap来实现</p><p><code>LinkedHashMap</code> 是 <strong>有序哈希表</strong>，可以按<strong>插入顺序</strong>或<strong>访问顺序</strong>存储键值对。</p><p>super(capacity, 0.75F, true);</p><p><strong>capacity</strong>: 初始容量</p><p><strong>0.75F</strong>: 负载因子（默认 <code>0.75</code>）</p><p><strong>true</strong>: 启用 <strong>访问顺序</strong>，即 <strong>最近访问的元素会被移到链表尾部</strong>，最久未使用的元素会在链表头部。</p><p><code>size() &gt; capacity</code> 时，返回 <code>true</code>，<code>LinkedHashMap</code> 会自动删除 <strong>链表头部的最老元素</strong>（即最近最少使用的元素）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer,Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer,Integer&gt; eldest)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>数组</h1><h2 id="18-最大子数组和">18.<a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution18</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=Math.max(ans,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用循环来完成这个目的</p><h2 id="19-合并区间">19.<a href="https://leetcode.cn/problems/merge-intervals/">合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><ol><li><p>把 <em>intervals</em>[0] 加入答案。注意，答案的最后一个区间表示<strong>当前正在合并的区间</strong>。</p></li><li><p>遍历到 intervals[1]=[2,6]，由于左端点 2 不超过当前合并区间的右端点 3，可以合并。由于右端点 6&gt;3，那么更新当前合并区间的右端点为 6。注意，由于我们已经按照左端点排序，所以 intervals[1] 的左端点 2 必然大于等于合并区间的左端点，所以无需更新当前合并区间的左端点。</p></li><li><p>遍历到 intervals[2]=[8,10]，由于左端点 8 大于当前合并区间的右端点 6，无法合并（两个区间不相交）。再次利用区间按照左端点排序的性质，更后面的区间的左端点也大于 6，无法与当前合并区间相交，所以当前合并区间 [1,6] 就固定下来了，把新的合并区间 [8,10] 加入答案。</p></li><li><p>遍历到 intervals[3]=[15,18]，由于左端点 15 大于当前合并区间的右端点 10，无法合并（两个区间不相交），我们找到了一个新的合并区间 [15,18] 加入答案。</p><p>上述算法同时说明，按照左端点排序后，合并的区间一定是 <em>intervals</em> 中的连续子数组。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution19</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals)&#123;</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>] - q[<span class="number">0</span>]);<span class="comment">//按照左端点从小到大排序</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;<span class="comment">//限制范围</span></span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-轮转数组">20.<a href="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h2><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        k%=nums.length;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = nums[temp];</span><br><span class="line">            start+=<span class="number">1</span>;</span><br><span class="line">            end-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个主要是轮转，</p><p>首先对整个数组实行翻转，这样子原数组中需要翻转的子数组，就会跑到数组最前面。</p><p>这时候，从 <em>k</em> 处分隔数组，左右两数组，各自进行翻转即可。</p><p>然后k逐渐求余</p><p>然后就构建一个反转函数就行了</p><h2 id="21-除自身以外数组的乘积-x">21.<a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a>(x)</h2><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="comment">//假如nums为[1,2,3,4]，那么answer的值分别为[(2,3,4),(1,3,4),(1,2,4),(1,2,3)]</span></span><br><span class="line">        <span class="comment">//如果吧i当前值相乘的时候看做是1那么就有如下样式</span></span><br><span class="line">        <span class="comment">//  1, 2, 3, 4 </span></span><br><span class="line">        <span class="comment">//  1, 1, 3, 4</span></span><br><span class="line">        <span class="comment">//  1, 2, 1, 4</span></span><br><span class="line">        <span class="comment">//  1, 2, 3, 1</span></span><br><span class="line">        <span class="comment">// 他的对角线1将他们分割成了两个三角形，对于answer的元素，</span></span><br><span class="line">        <span class="comment">//我们可以先计算一个三角形每行的乘积，然后再去计算另外一个三角形每行的乘积，</span></span><br><span class="line">        <span class="comment">//然后各行相乘，就是answer每个对应的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先初始化一个answer数组,但是很多解答都没说明的是这个answer数组，</span></span><br><span class="line">        <span class="comment">//并不是以此计算就得出的结果,而是两次乘积之后的结果</span></span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">//初始化一个初始值，作为三角乘积计算的开始</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先计算左边三角的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">            answer[i] = answer[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次计算右边三角形,为什么是length-2呢？</span></span><br><span class="line">        <span class="comment">//length-1是最后一个值的索引，但是最后一个值temp[length-1] = 1,</span></span><br><span class="line">        <span class="comment">//也是对应对角线上的1，所以不在进行相乘处理</span></span><br><span class="line">        <span class="comment">//temp的作用是计算右边三角形的乘积的累计值，然后再和answer相乘，</span></span><br><span class="line">        <span class="comment">//注意!!!:不能直接nums[i+1]相乘那会在计算右三角的时候变成每行乘积与nums[i+1]的错误答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//先将每行乘积赋予一个中间值</span></span><br><span class="line">            temp *= nums[i+<span class="number">1</span>];</span><br><span class="line">            answer[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="87-缺失的第一个正数">87.<a href="https://leetcode.cn/problems/first-missing-positive/">缺失的第一个正数</a></h2><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution87</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Set&lt;Integer&gt; set  =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num&lt;min)&#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(num);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//找到最小值</span></span><br><span class="line">        <span class="keyword">if</span> (min&gt;<span class="number">1</span>&amp;&amp;!set.contains(<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (set.contains(min))&#123;</span><br><span class="line">            min++;</span><br><span class="line">            <span class="keyword">if</span> (min&lt;<span class="number">0</span>) min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(min)) min++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (min&lt;=<span class="number">0</span>) min++;</span><br><span class="line">            &#125;<span class="comment">//将负数Min++直到为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min&gt;<span class="number">0</span>?min:<span class="number">1</span>;<span class="comment">//不在集合中，大于0直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把负数变为1</p><p>其余的返回</p><h1>树</h1><h2 id="22-二叉树的中序遍历">22.<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p>中序遍历是左-&gt;根-&gt;右</p><p>可以使用递归完成dfs的中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution22</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        dfs(res, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; res,TreeNode root)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(res,root.left);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            dfs(res,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-二叉树的最大深度">23.<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是左子树和右子树分别往下找，然后他们两个最大的+1（root）就是最大深度</p><h2 id="24-翻转二叉树">24.<a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution24</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是左子树变成右子树，右子树变成左子树</p><p>直接设置一个中间值，然后直接递归交换即可。</p><h2 id="25-对称二叉树">25.<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">null</span>||recur(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L,TreeNode R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>&amp;&amp;R==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>||R==<span class="literal">null</span>||L.val!=R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(L.left,R.right)&amp;&amp;recur(L.right,R.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是递归的方法，如果左空右空，那么就肯定对称啊</p><p>左不为空或者右不为空，val还不一样肯定不是对称</p><p>然后递归往下顺延</p><p>左的左，对应右的右。左的右对应右的左。然后递归往下找下一个节点</p><h2 id="26-二叉树的直径">26.<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a></h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution26</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">llen</span> <span class="operator">=</span> dfs(node.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rlen</span> <span class="operator">=</span> dfs(node.right)+<span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans,llen+rlen);</span><br><span class="line">        <span class="keyword">return</span> Math.max(llen,rlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到左子树的最大长，和右子树的最大长，加起来就是长度。</p><p>其中+1是经过root节点</p><h2 id="27-二叉树的层序遍历">27.<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p>使用递归的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution27</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sized</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; layer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (sized--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                layer.add(poll.val);</span><br><span class="line">                <span class="keyword">if</span> (poll.left!=<span class="literal">null</span>) que.add(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right!=<span class="literal">null</span>) que.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(layer);</span><br><span class="line">        &#125;<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while (sized–&gt;0){<br>TreeNode poll = que.poll();<br>layer.add(poll.val);<br>if (poll.left!=null) que.add(poll.left);<br>if (poll.right!=null) que.add(poll.right);<br>}</p><p>sized逐渐递减，大于0的时候执行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode poll = que.poll();</span><br><span class="line">                layer.add(poll.val);</span><br><span class="line">                if (poll.left!=null) que.add(poll.left);</span><br><span class="line">                if (poll.right!=null) que.add(poll.right);</span><br></pre></td></tr></table></figure><p>poll为队列弹出的</p><p>然后List加入弹出的值</p><p>然后先向左递归，然后再向右递归</p><p>直到完成que为空，最后返回res</p><h2 id="28-将有序数组转换为二叉搜索树">28.<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution28</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo&gt;hi)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = dfs(nums,lo,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = dfs(nums,mid+<span class="number">1</span>,hi);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了二分查找，主要是设定了mid为lo加上hi-lo的位置，这个位置就是root</p><p>然后递归查找，就可以出现二叉搜索树了。</p><p>二叉搜索树就是二分查找中出现的</p><h2 id="29-验证二叉搜索树">29.<a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution29</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node,<span class="type">long</span> left,<span class="type">long</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> node.val;</span><br><span class="line">        <span class="keyword">return</span> left&lt;x&amp;&amp;x&lt;right&amp;&amp;</span><br><span class="line">                isValidBST(node.left,left,x)&amp;&amp;</span><br><span class="line">                isValidBST(node.right,x,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉搜索树的特点是左子树是小于根节点的</p><p>右子树是大于根节点的</p><p>我们就根据这个来判断就行</p><p>return left&lt;x&amp;&amp;x&lt;right&amp;&amp;<br>isValidBST(node.left,left,x)&amp;&amp;<br>isValidBST(node.right,x,right);</p><p>这就是成立条件，其中用到了递归</p><h2 id="30-二叉搜索树中第-K-小的元素（topk）">30.<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/"> 二叉搜索树中第 K 小的元素</a>（topk）</h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution30</span>&#123;</span><br><span class="line">    <span class="type">int</span> res,k;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (--k==<span class="number">0</span>) res = root.val;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是找第K小的数，所以先从左子树开始</p><p>然后如果递归下去–k==0了说明不在左子树，是根节点</p><p>然后递归右子树</p><h2 id="31-二叉树的右视图">31.<a href="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution31</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode  root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth==ans.size())&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>,ans);</span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是右视图，所以是从右边开始</p><p>如果深度首次遇到，说明是遇到了最右边的，把值收入</p><p>先递归右子树，保证首次遇到的一定是最右边的节点</p><p>然后逐渐递归，最先右边的递归</p><h2 id="32-二叉树展开为链表">32.<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/"> 二叉树展开为链表</a></h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution32</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="literal">null</span>) &#123; <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.right = root.right; <span class="comment">// 右子树接到左子树的最右节点上</span></span><br><span class="line">                root.right = root.left; <span class="comment">// 左子树变成右子树</span></span><br><span class="line">                root.left = <span class="literal">null</span>; <span class="comment">// 断开左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right; <span class="comment">// 继续处理下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-路径总和-III">33.<a href="https://leetcode.cn/problems/path-sum-iii/">路径总和 III</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        Map&lt;Long, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        cnt.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">        dfs(root, <span class="number">0</span>, targetSum, cnt);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">long</span> s,<span class="type">int</span> targetsum,Map&lt;Long,Integer&gt; cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s+= node.val;</span><br><span class="line">        ans+=cnt.getOrDefault(s-targetsum,<span class="number">0</span>);</span><br><span class="line">        cnt.merge(s,<span class="number">1</span>,Integer::sum);<span class="comment">//cnt[s++]</span></span><br><span class="line">        dfs(node.left,s,targetsum,cnt);</span><br><span class="line">        dfs(node.right,s,targetsum,cnt);</span><br><span class="line">        cnt.merge(s,-<span class="number">1</span>,Integer::sum);<span class="comment">//归零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cnt.merge(s,1,Integer::sum);//想当与逐渐+1</p><p>然后走的时候先走左再走右</p><p>最后清零sum</p><h2 id="34-二叉树的最近公共祖先">34.<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution34</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个节点有一个跟根节点相同的话，那么最近公共祖先就是root</p><p>然后继续递归，当到最下的时候，为Null就是上一个节点</p><h2 id="35-从前序与中序遍历序列构造二叉树">35.<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> in=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree2</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> my(preorder,inorder,Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">my</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder,<span class="type">int</span> stop)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == preorder.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inorder[in] ==stop)&#123;</span><br><span class="line">        in++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[pre++]);</span><br><span class="line">    root.left = my(preorder,inorder,root.val);</span><br><span class="line">    root.right = my(preorder,inorder,stop);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeNode root = new TreeNode(preorder[pre++]);逐渐获得前序遍历的值</p><p>然后构造左子树，构造右子树</p><p>没有子树的时候，返回in++，直到到stop</p><p>然后调用递归</p><h1>二分查找</h1><h2 id="36-搜索插入位置">36.<a href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p>简单的二分查找，不比多说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution36</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left =mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-搜索二维矩阵">37.<a href="https://leetcode.cn/problems/search-a-2d-matrix/">搜索二维矩阵</a></h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>简单的矩阵二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution37</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m*n;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>(left+right)&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//计算中位数，即使为负数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> matrix[mid/n][mid%n];</span><br><span class="line">            <span class="keyword">if</span> (x==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;target)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>a</em>[<em>i</em>]=<em>matrix</em>[i/n】[imod<em>n</em>]</p><p>将矩阵转化为一个数组</p><h2 id="38-在排序数组中查找元素的第一个和最后一个位置">38.<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution38</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> lowBound(nums,target);</span><br><span class="line">        <span class="keyword">if</span> (start==nums.length||nums[start] !=target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lowBound(nums,target+<span class="number">1</span>)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start,end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBound</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是调用使用的方法然后如果超过了范围的话，返回-1,-1</p><p>如果成功的话返回start,end</p><p>要想找到 ≤target 的最后一个数，无需单独再写一个二分。我们可以先找到这个数的右边相邻数字，也就是 &gt;target 的第一个数。在所有数都是整数的前提下，&gt;target 等价于 ≥target+1，这样就可以复用我们已经写好的二分函数了，即 lowerBound(nums, target + 1)，算出这个数的下标后，将其减一，就得到 ≤target 的最后一个数的下标。</p><p>然后开始写二分查找的方法</p><h2 id="39-搜索旋转排序数组">39.<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution39</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line">            mid = start+(end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] ==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start]&lt;=nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target&gt;=nums[start]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    end  = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (target&lt;=nums[end]&amp;&amp;target&gt;nums[mid])&#123;</span><br><span class="line">                    start = mid +<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接写出二分查找就可以了；</p><h2 id="40-寻找旋转排序数组中的最小值">40.<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution40&#123;</span><br><span class="line">    public int findMin(int[] nums)&#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int left  = -1;</span><br><span class="line">        int right = n-1;</span><br><span class="line">        while (left+1&lt;right)&#123;</span><br><span class="line">            int mid = (left+right)&gt;&gt;&gt;1;</span><br><span class="line">            if (nums[mid]&lt;nums[n-1])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的二分查找</p><p>只不过如果 nums[n−1] 是数组最小值，那么 nums 分成两段，第一段 [0,n−2]，第二段 [n−1,n−1]，且第一段的所有数都大于 nums[n−1]。每次 x 和 nums[n−1] 比大小，一定是 x&gt;nums[n−1]。这意味着每次二分更新的都是 left，那么循环结束后，答案自然就是 n−1 了。。</p><h1>矩阵</h1><h2 id="42-矩阵置零">42.<a href="https://leetcode.cn/problems/set-matrix-zeroes/">矩阵置零</a></h2><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法**。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; row_zero = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; col_zero = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    row_zero.add(i);</span><br><span class="line">                    col_zero.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (row_zero.contains(i)||col_zero.contains(j))&#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用两层for循环进行遍历，然后将遇到的0的行和列的index放入</p><p>hashset</p><p>最后将hashset里的索引的值设定为0</p><h2 id="43-螺旋矩阵">43.<a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution43</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, b = matrix.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; t &lt;= b) &#123;</span><br><span class="line">            <span class="comment">// 从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) res.add(matrix[t][i]);</span><br><span class="line">            t++;  <span class="comment">// 更新上边界</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++) res.add(matrix[i][r]);</span><br><span class="line">            r--;  <span class="comment">// 更新右边界</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--) res.add(matrix[b][i]);</span><br><span class="line">            b--;  <span class="comment">// 更新下边界</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--) res.add(matrix[i][l]);</span><br><span class="line">            l++;  <span class="comment">// 更新左边界</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>螺旋就是从左到右，然后从上到下，从右到左，再从下到上</p><p>l为左边界</p><p>t为上边界</p><p>r为右边界</p><p>b为下边界</p><p>然后依次for循环遍历即可</p><h2 id="44-旋转图像">44.<a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution44&#123;</span><br><span class="line">    public void rotate(int[][] matrix)&#123;</span><br><span class="line">        int n = matrix.length;</span><br><span class="line">        int[][] matrix_new  = new int[n][n];</span><br><span class="line">        for (int i =0;i&lt;n;++i)&#123;</span><br><span class="line">            for (int j =0;j&lt;n;j++)&#123;</span><br><span class="line">                matrix_new[j][n-i-1] = matrix_new[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=0;i&lt;n;++i)&#123;</span><br><span class="line">            for (int j=0;j&lt;n;++j)&#123;</span><br><span class="line">                matrix[i][j] = matrix_new[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是新建一个矩阵，然后将旧的一一对应过去。</p><p>对于矩阵中第 <em>i</em> 行的第 <em>j</em> 个元素，在旋转后，它出现在倒数第 <em>i</em> 列的第 <em>j</em> 个位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix_new[j][n-i-1] = matrix_new[i][j];</span><br></pre></td></tr></table></figure><h2 id="45-搜索二维矩阵-II">45.<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II</a></h2><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p>从左下角开始遍历</p><p>ij大于目标值，i–，则往上去找</p><p>ij小于目标值，j++，则往右去找</p><p>这样就是一个搜索</p><p>知道找到target为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution45</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length-<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;j&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]&gt;target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j]&lt;target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>字串</h1><h2 id="46-和为-K-的子数组">46.<a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution46</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> [] s = <span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            s[i+<span class="number">1</span>] = s[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans= <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sj:s)&#123;</span><br><span class="line">            ans+=cnt.getOrDefault(sj-k,<span class="number">0</span>);</span><br><span class="line">            cnt.merge(sj,<span class="number">1</span>,Integer::sum);<span class="comment">//cnt[sj]++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个题先逐渐累加和存入s[]里面,这就是前缀和</p><p><code>cnt</code> 用来存储 <strong>某个前缀和出现的次数</strong>，</p><p>cnt.getOrDefault(sj - k, 0)<code>统计符合条件的</code>s[i]<code>个数，并累加到</code>ans</p><h1>图</h1><h2 id="47-岛屿数量">47.<a href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a></h2><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution47</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] ==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=grid.length||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接dfs 深度优先遍历即可</p><h2 id="48-腐烂的橘子-x">48.<a href="https://leetcode.cn/problems/rotting-oranges/">腐烂的橘子</a>(x)</h2><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p><p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">freshCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计新鲜橘子数量，并找到腐烂橘子的初始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;  <span class="comment">// 修正错误 j &lt; 0</span></span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    freshCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有新鲜橘子，直接返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (freshCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasRotten</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">int</span>[] arr = queue.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历 4 个方向</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">xNext</span> <span class="operator">=</span> x + dir[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">yNext</span> <span class="operator">=</span> y + dir[j][<span class="number">1</span>];  <span class="comment">// 修正错误：应使用 dir[j][1]</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 检查边界条件 &amp; 是否是新鲜橘子</span></span><br><span class="line">                    <span class="keyword">if</span> (xNext &gt;= <span class="number">0</span> &amp;&amp; yNext &gt;= <span class="number">0</span> &amp;&amp; xNext &lt; m &amp;&amp; yNext &lt; n &amp;&amp; grid[xNext][yNext] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[xNext][yNext] = <span class="number">2</span>;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;xNext, yNext&#125;);</span><br><span class="line">                        freshCount--;</span><br><span class="line">                        hasRotten = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有在本轮有橘子腐烂时，才增加时间</span></span><br><span class="line">            <span class="keyword">if</span> (hasRotten) &#123;</span><br><span class="line">                time++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还有新鲜橘子，返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> freshCount == <span class="number">0</span> ? time : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49-课程表-x">49.<a href="https://leetcode.cn/problems/course-schedule/">课程表</a>(x)</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">canFinishclass Solution49&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinsh</span><span class="params">(<span class="type">int</span> numCourses,<span class="type">int</span> [][] prerequisites)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] indegress  = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] cp:prerequisites)&#123;</span><br><span class="line">            indegress[cp[<span class="number">0</span>]]++;</span><br><span class="line">            adjacency.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (indegress[i]==<span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span>  <span class="operator">=</span> queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> cur:adjacency.get(pre))</span><br><span class="line">                <span class="keyword">if</span> (--indegress[cur]==<span class="number">0</span>) queue.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>回溯</h1><h2 id="50-全排列">50.<a href="https://leetcode.cn/problems/permutations/">全排列</a></h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution50</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums.get(a);</span><br><span class="line">        nums.set(a,nums.get(b));</span><br><span class="line">        nums.set(b,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x==nums.size()-<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>x;i&lt;nums.size();i++)&#123;</span><br><span class="line">            swap(i,x);</span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            swap(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="built_in">this</span>.nums.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是找到所有可能的情况</p><p>swap用于交换，先固定，然后再<strong>回溯</strong>，即固定 <code>nums[i]</code> 为当前位元素。</p><p>dfs为深度搜索，搜索x的下一个之后的结果</p><h2 id="51-子集">51.<a href="https://leetcode.cn/problems/subsets/">子集</a></h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution51</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(nums,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,List&lt;Integer&gt; row,<span class="type">int</span> n,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n ==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(row));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nthNumber</span> <span class="operator">=</span> nums[n];</span><br><span class="line">        dfs(nums,row,n+<span class="number">1</span>,res);</span><br><span class="line">        row.add(nthNumber);</span><br><span class="line">        dfs(nums,row,n+<span class="number">1</span>,res);</span><br><span class="line">        row.remove(row.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要使用的方法就是我们的dfs</p><p>任何一个数字都有选择和不选择两种状态。所以结果集就是这个状态二叉树的所有叶子结点</p><p>第n位等于长度的时候就说明完成了，把集合封装进res</p><p>先搜索n+1然后取当前元素nth，再dfs</p><p>然后回溯，撤销选择的元素</p><h2 id="52-电话号码的字母组合">52.<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution52</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String letterMap[] = &#123;</span><br><span class="line">            <span class="string">&quot; &quot;</span>,    <span class="comment">//0</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>,     <span class="comment">//1</span></span><br><span class="line">            <span class="string">&quot;abc&quot;</span>,  <span class="comment">//2</span></span><br><span class="line">            <span class="string">&quot;def&quot;</span>,  <span class="comment">//3</span></span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>,  <span class="comment">//4</span></span><br><span class="line">            <span class="string">&quot;jkl&quot;</span>,  <span class="comment">//5</span></span><br><span class="line">            <span class="string">&quot;mno&quot;</span>,  <span class="comment">//6</span></span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="comment">//7</span></span><br><span class="line">            <span class="string">&quot;tuv&quot;</span>,  <span class="comment">//8</span></span><br><span class="line">            <span class="string">&quot;wxyz&quot;</span>  <span class="comment">//9</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        findCombination(digits,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findCombination</span><span class="params">(String digits,<span class="type">int</span> index,String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==digits.length())&#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">        <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> letterMap[c-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;letters.length();i++)&#123;</span><br><span class="line">            findCombination(digits,index+<span class="number">1</span>,s+letters.charAt(i));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题转化成了从根节点到空节点一共有多少条路径；</p><p>直接递归进行搜索</p><p>主要是字符的形式进行递归</p><h2 id="53-组合总和">53.<a href="https://leetcode.cn/problems/combination-sum/">组合总和</a></h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution53</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state,<span class="type">int</span> target,<span class="type">int</span>[] choices,<span class="type">int</span> start,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start; i&lt;choices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target-choices[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state.add(choices[i]);</span><br><span class="line">            backtrack(state,target-choices[i],choices,i,res);</span><br><span class="line">            state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(state,target,candidates,start,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是解析这个函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">       <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 遍历所有选择</span></span><br><span class="line">       <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; choices.length; i++) &#123;</span><br><span class="line">           <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">           <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">           <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">           state.add(choices[i]);</span><br><span class="line">           <span class="comment">// 进行下一轮选择</span></span><br><span class="line">           backtrack(state, target - choices[i], choices, i, res);</span><br><span class="line">           <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">           state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="54-括号生成-x">54.<a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a>(x)</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution54</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">char</span>[n*<span class="number">2</span>];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span> open)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==n*<span class="number">2</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open&lt;n)&#123;</span><br><span class="line">            path[i] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,open+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-open&lt;open)&#123;</span><br><span class="line">            path[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,open);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于括号字符串的任意前缀，<strong>右括号的个数不能超过左括号的个数</strong>。</p><p>代码中的 open &lt; n 限制左括号至多填 n 个，i - open &lt; open 限制右括号至多填 open 个（不能超过左括号的个数）。由于一共要填 2n 个括号，那么当我们递归到终点时：</p><p>如果左括号少于 n 个，那么右括号也会少于 n 个，与 i == m 矛盾，因为每填一个括号 i 都会增加 1。<br>如果左括号超过 n 个，与 open &lt; n 矛盾，这句话限制了左括号至多填 n 个。<br>所以递归到终点时，左括号恰好填了 n 个，此时右括号也恰好填了 2n−n=n 个。</p><h2 id="55-单词搜索-x">55.<a href="https://leetcode.cn/problems/word-search/">单词搜索</a>(x)</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution55</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] points = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board,String word)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] chars =word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;board.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(i, j, board, <span class="number">0</span>, chars)) &#123;</span><br><span class="line">                    ;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">char</span>[][] board,<span class="type">int</span> index,<span class="type">char</span>[] chars)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>||x&gt;board.length-<span class="number">1</span>||</span><br><span class="line">        y&lt;<span class="number">0</span>||y&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||</span><br><span class="line">                board[x][y]!=chars[index]</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==chars.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] =<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(x+points[i][<span class="number">0</span>],y+points[i][<span class="number">1</span>],board,index+<span class="number">1</span>,chars))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] =chars[index];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//以某点为原点的上下左右四个方向</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] points = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="comment">//特例</span></span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="type">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="comment">//存在符合条件的直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(i, j, board, <span class="number">0</span>, chars))&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始进行递归寻找</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] board, <span class="type">int</span> index , <span class="type">char</span>[] chars)</span>&#123;</span><br><span class="line">        <span class="comment">//超出边界直接返回,board[x][y]位置和单词对应位置的字符不相等也要退出</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt; board.length - <span class="number">1</span> || </span><br><span class="line">           y &lt; <span class="number">0</span> || y &gt; board[<span class="number">0</span>].length -<span class="number">1</span> ||</span><br><span class="line">           board[x][y] != chars[index])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当索引已经是最后一位说明找到了匹配的直接返回true；</span></span><br><span class="line">        <span class="keyword">if</span>(index == chars.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走过的路全部置空，最上面的判定条件的判定（\0表示空字符）</span></span><br><span class="line">        board[x][y] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">        <span class="comment">//以(x,y)为原点向四周递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//当判定存在的后直接退出并返回true,能到这一步的一定是当前index所在的位置的字母</span></span><br><span class="line">            <span class="comment">//和board[x][y]相匹配的</span></span><br><span class="line">            <span class="keyword">if</span>(dfs(x + points[i][<span class="number">0</span>], y + points[i][<span class="number">1</span>], board, index + <span class="number">1</span>, chars))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        board[x][y] = chars[index];</span><br><span class="line">        <span class="comment">//都没有符合则为false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="56-分割回文串">56.<a href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文串</a></h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些 子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution56</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==s.length())&#123;<span class="comment">//分割完毕</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;<span class="comment">//枚举结束的位置</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrom(i,j))&#123;</span><br><span class="line">                path.add(s.substring(i,j+<span class="number">1</span>));<span class="comment">//分割</span></span><br><span class="line">                dfs(j+<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrom</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left++)!=s.charAt(right--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>栈</h1><h2 id="57-有效的括号">57.<a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></h2><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution57</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.empty()||c!=stack.pop())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个括号要求成双成对，有左必有右</p><p>若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 <code>stack</code> 仍然为空；</p><p>遍历完stack为空即为合理</p><h2 id="58-最小栈">58.<a href="https://leetcode.cn/problems/min-stack/">最小栈</a></h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p>push() 方法： 每当push()新值进来时，如果 小于等于 min_stack 栈顶值，则一起 push() 到 min_stack，即更新了栈顶最小值；<br>pop() 方法： 判断将 pop() 出去的元素值是否是 min_stack 栈顶元素值（即最小值），如果是则将 min_stack 栈顶元素一起 pop()，这样可以保证 min_stack 栈顶元素始终是 stack 中的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (min_stack.isEmpty()||x&lt;=min_stack.peek())</span><br><span class="line">            min_stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.pop().equals(min_stack.peek()))</span><br><span class="line">            min_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="59-字符串解码">59.<a href="https://leetcode.cn/problems/decode-string/">字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution59</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; countstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;StringBuilder&gt; stringstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">currentString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//重复次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c))&#123;<span class="comment">//如果c为数字的话</span></span><br><span class="line">                k = k*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//多位数字</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;<span class="comment">//开始</span></span><br><span class="line">                countstack.push(k);</span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">                stringstack.push(currentString);</span><br><span class="line">                currentString = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;]&#x27;</span>)&#123;<span class="comment">//结束</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> countstack.pop();</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> stringstack.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;repeat;i++)&#123;</span><br><span class="line">                    sb.append(currentString);<span class="comment">//</span></span><br><span class="line">                &#125;<span class="comment">//开始重复</span></span><br><span class="line">                currentString = sb;<span class="comment">//更新拼接之后的字符串</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                currentString.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentString.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="60-每日温度">60.<a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution60</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures1(<span class="type">int</span>[] T) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> T.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j += result[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T[j] &gt; T[i]) &#123;</span><br><span class="line">                    result[i] = j - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    result[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; st  = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> temperatures[i];</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty()&amp;&amp;t&gt;=temperatures[st.peek()])&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!st.isEmpty())&#123;</span><br><span class="line">                ans[i] = st.peek()-i;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从后面开始遍历</p><p>t存temperatures的第i个数据</p><p>st不为空的时候，ans[i]个数据是st的顶端的第i个作为候选就是那个答案，第i天</p><p>然后压入第I个</p><p>之后再不为空，，并且右更大的时候，出栈，然后新的最高温度就进栈可以继续比较了</p><p>最后返回ans结果</p><h1>堆</h1><h2 id="61-数组中的第K个最大元素（topk）">61.<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a>（topk）</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution61&#123;</span><br><span class="line">    public int findKthLargest(int[] nums,int k)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        return nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接排序，返回n-k个元素即可</p><h2 id="62-前-K-个高频元素（topk）-代码优美">62.<a href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素</a>（topk）(代码优美)</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums,<span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; counter = IntStream.of(nums).boxed().collect(Collectors.toMap(e-&gt;e,e-&gt;<span class="number">1</span>,Integer::sum));</span><br><span class="line">        <span class="comment">// 定义小根堆，根据数字频率自小到大排序</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((v1,v2)-&gt;counter.get(v1)-counter.get(v2));</span><br><span class="line">        counter.forEach((num,cnt)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size()&lt;k)&#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (counter.get(pq.peek())&lt;cnt)&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:pq)&#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>贪心算法</h1><h2 id="63-买卖股票的最佳时机">63.<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution63</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE,profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price:prices)&#123;</span><br><span class="line">            cost = Math.min(cost,price);</span><br><span class="line">            profit = Math.max(profit,price-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的问题，直接使用Math函数即可。然后遍历一下</p><h2 id="64-跳跃游戏">64.<a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>从左到右遍历 nums，同时维护能跳到的最远位置 mx，初始值为 0。<br>如果 i&gt;mx，说明无法跳到 i，返回 false。<br>否则，用 i+nums[i]更新 mx 的最大值。<br>如果循环中没有返回 false，那么最后返回 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution64</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;mx&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;mx) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            mx = Math.max(mx,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="65-跳跃游戏-II">65.<a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a></h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution65</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPosition</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&gt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            maxPosition = Math.max(maxPosition,nums[i]+i);</span><br><span class="line">            <span class="keyword">if</span> (i==end)&#123;</span><br><span class="line">                end = maxPosition;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟上面64题差不多，只不过遇到了边界的时候，边界更新为最大值，然后步数++</p><p>最后返回统计的步数</p><h2 id="66-划分字母区间">66.<a href="https://leetcode.cn/problems/partition-labels/">划分字母区间</a></h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 <code>&quot;ababcc&quot;</code> 能够被分为 <code>[&quot;abab&quot;, &quot;cc&quot;]</code>，但类似 <code>[&quot;aba&quot;, &quot;bcc&quot;]</code> 或 <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;]</code> 的划分是非法的。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p>遍历 s，计算字母 c 在 s 中的最后出现的下标 last[c]。<br>初始化当前正在合并的区间左右端点 start=0, end=0。<br>再次遍历 s，由于当前区间必须包含所有 s[i]，所以用 last[s[i]] 更新区间右端点 end 的最大值。<br>如果发现 end=i，那么当前区间合并完毕，把区间长度 end−start+1 加入答案。然后更新 start=i+1 作为下一个区间的左端点。<br>遍历完毕，返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution66</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String S)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> [] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            last[s[i]-<span class="string">&#x27;a&#x27;</span>]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>,end =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            end = Math.max(end,last[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (end == i)&#123;</span><br><span class="line">                ans.add(end-start+<span class="number">1</span>);</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>技巧</h1><h2 id="67-只出现一次的数字">67.<a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution67</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            x^=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就能找出只出现一次的数字了，因为只出现一次肯定是没有方的</p><h2 id="68-多数元素">68.<a href="https://leetcode.cn/problems/majority-element/">多数元素</a></h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>初始化： 票数统计 votes = 0 ， 众数 x。<br>循环： 遍历数组 nums 中的每个数字 num 。<br>当 票数 votes 等于 0 ，则假设当前数字 num 是众数。<br>当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 。<br>返回值： 返回 x 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution68</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (votes==<span class="number">0</span>) x=num;</span><br><span class="line">            votes += (num ==x?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="69-颜色分类">69.<a href="https://leetcode.cn/problems/sort-colors/">颜色分类</a></h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution69</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span>  <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;two)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                zero++;</span><br><span class="line">                swap(nums,i,zero);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nums,i,two);</span><br><span class="line">                two--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index1,<span class="type">int</span> index2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是一个字，遇到0往最前面放，遇到2往最后面放。</p><p>然后交换就可以了</p><h2 id="70-下一个排列">70.<a href="https://leetcode.cn/problems/next-permutation/">下一个排列</a></h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            swap(nums,left++,right--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,i+<span class="number">1</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.从右向左，找第一个小于右侧相邻数字的数 <em>x</em></p><p>2.找 <em>x</em> 右边最小的大于 <em>x</em> 的数 <em>y</em>，交换 <em>x</em> 和 <em>y</em></p><p>3.反转 <em>y</em> 右边的数，把右边的数变成最小的排列</p><h2 id="71-寻找重复数">71.<a href="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a></h2><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            f = nums[f];</span><br><span class="line">            f = nums[f];</span><br><span class="line">            s = nums[s];</span><br><span class="line">            <span class="keyword">if</span> (s == f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr!=s)&#123;</span><br><span class="line">            ptr = nums[ptr];</span><br><span class="line">            s = nums[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>ptr == slow 时说明检测到重复元素，两个重复元素同时指向环的入口。<br>$$</p><h1>动态规划</h1><h2 id="72-爬楼梯">72.<a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>,b = <span class="number">1</span>,sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;<span class="comment">//a就是n-2，b就是n-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="73-杨辉三角">73.<a href="https://leetcode.cn/problems/pascals-triangle/">杨辉三角</a></h2><p>给定一个非负整数 *<code>numRows</code>，*生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution73</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(numRows);</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>) <span class="keyword">return</span> c;</span><br><span class="line">        c.add(List.of(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;numRows;i++)&#123;<span class="comment">//每一行的实现</span></span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(i+<span class="number">1</span>);</span><br><span class="line">            row.add(<span class="number">1</span>);<span class="comment">//第一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>;j&lt;i;j++)&#123;<span class="comment">//相加的实现</span></span><br><span class="line">                row.add(c.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+c.get(i-<span class="number">1</span>).get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            row.add(<span class="number">1</span>);<span class="comment">//最后一个元素</span></span><br><span class="line">            c.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="74-打家劫舍">74.<a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution74</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>]; <span class="comment">// 创建 DP 数组，dp[i] 代表抢劫前 i 间房子时的最大金额</span></span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;         <span class="comment">// 不抢任何房子</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];   <span class="comment">// 只有一间房子时，抢它</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= N; k++) &#123;</span><br><span class="line">            dp[k] = Math.max(dp[k - <span class="number">1</span>], nums[k - <span class="number">1</span>] + dp[k - <span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 选择：不抢当前房子(dp[k-1])，或抢当前房子(nums[k-1] + dp[k-2])</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[N]; <span class="comment">// 最后一个状态就是最大金额</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="75-完全平方数">75.<a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h2><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution75</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(f, Integer.MAX_VALUE);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// base case</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i * i &lt;= n; i++) &#123;  <span class="comment">// 遍历所有完全平方数 i*i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= n; j++) &#123; <span class="comment">// 遍历目标值 j</span></span><br><span class="line">                <span class="keyword">if</span> (f[j - i * i] != Integer.MAX_VALUE) &#123;  <span class="comment">// 避免溢出</span></span><br><span class="line">                    f[j] = Math.min(f[j], f[j - i * i] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="76-零钱兑换">76.<a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution76</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(f,Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:coins)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> x;c&lt;=amount;c++)&#123;</span><br><span class="line">                f[c] = Math.min(f[c],f[c-x]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[amount];</span><br><span class="line">        <span class="keyword">return</span> ans&lt;Integer.MAX_VALUE/<span class="number">2</span>?ans:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面的是一个思路，只不过不是平方罢了</p><p>然后加了个判断</p><p>如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><h2 id="77-单词拆分">77.<a href="https://leetcode.cn/problems/word-break/">单词拆分</a></h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算字典中最长的单词长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">            maxlen = Math.max(maxlen, word.length());</span><br><span class="line">        &#125;<span class="comment">//maxlen获得</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 wordDict 存入 HashSet 以提高查询效率</span></span><br><span class="line">        Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 空字符串可以被拆分</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历字符串 s 的每个前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.max(i - maxlen, <span class="number">0</span>); j &lt; i; j++) &#123;  <span class="comment">// 修正 j 的范围</span></span><br><span class="line">                <span class="keyword">if</span> (f[j] &amp;&amp; words.contains(s.substring(j, i))) &#123;<span class="comment">//从j到i在words之中</span></span><br><span class="line">                    f[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n]; <span class="comment">// 返回能否拆分整个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="78-最长递增子序列">78.<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p>动态规划，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution78</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j]&lt;nums[i]) dp[i] = Math.min(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归开始，当nums[j]&lt;nums[i]个的时候，j是更小的，这个时候最长的子序列就能变的更长</p><p>也就是加1 dp[i]长度就+1 然后递归完res就是最大的dp[i]的长度</p><p>最后完成res的结果</p><p>最后返回res结果</p><h2 id="79-乘积最大子数组">79.<a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><p>因为是负负得正，所以可能是两个负数相乘是最大的</p><p>所以不仅要维护一个最大值，还要维护一个最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution79</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE,imax = <span class="number">1</span>,imin=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> imax;</span><br><span class="line">                imax = imin;</span><br><span class="line">                imin= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            imax = Math.max(imax*nums[i],nums[i]);</span><br><span class="line">            imin = Math.min(imin*nums[i],nums[i]);</span><br><span class="line">            max = Math.max(max,imax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="80-不同路径">80.<a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>dp[i】[j】 = dp[i-1】[j] + dp[i][j-1】</p><p>对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，由于都是在边界，所以只能为 <code>1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution80</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++) dp[<span class="number">0</span>][i] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="81-最小路径和">81.<a href="https://leetcode.cn/problems/minimum-path-sum/"> 最小路径和</a></h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>**说明：**每次只能向下或者向右移动一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution81</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) grid[i][j] = grid[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) grid[i][j] = grid[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面的一样</p><p>遇到边界下一个</p><p>然后遇到真正的就找最小的路走。然后最右下角的那个就是最小的路径和</p><h2 id="82-最长回文子串-x">82.<a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a>(x)</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><p>使用：Manacher 算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution82</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理字符串</span></span><br><span class="line">        <span class="type">char</span>[] t = <span class="keyword">new</span> <span class="title class_">char</span>[n * <span class="number">2</span> + <span class="number">3</span>];</span><br><span class="line">        Arrays.fill(t, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        t[<span class="number">0</span>] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">        t[n * <span class="number">2</span> + <span class="number">2</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            t[i * <span class="number">2</span> + <span class="number">2</span>] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] halfLen = <span class="keyword">new</span> <span class="title class_">int</span>[t.length]; <span class="comment">// 这里大小应该与 t 一致</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxI</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">boxM</span> <span class="operator">=</span> <span class="number">0</span>, boxR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Manacher&#x27;s Algorithm</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; t.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算当前点的初始回文半径</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> (i &lt; boxR) ? Math.min(halfLen[<span class="number">2</span> * boxM - i], boxR - i) : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试扩展回文半径</span></span><br><span class="line">            <span class="keyword">while</span> (t[i - hl] == t[i + hl]) &#123;</span><br><span class="line">                hl++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            halfLen[i] = hl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新右边界</span></span><br><span class="line">            <span class="keyword">if</span> (i + hl &gt; boxR) &#123;</span><br><span class="line">                boxM = i;</span><br><span class="line">                boxR = i + hl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最长回文中心</span></span><br><span class="line">            <span class="keyword">if</span> (halfLen[i] &gt; halfLen[maxI]) &#123;</span><br><span class="line">                maxI = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算原字符串中的起始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (maxI - halfLen[maxI]) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + halfLen[maxI] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Manacher 模板</span><br><span class="line">        # 将 s 改造为 t，这样就不需要讨论 len(s) 的奇偶性，因为新串 t 的每个回文子串都是奇回文串（都有回文中心）</span><br><span class="line">        # s 和 t 的下标转换关系：</span><br><span class="line">        # (si+1)*2 = ti</span><br><span class="line">        # ti/2-1 = si</span><br><span class="line">        # ti 为偶数，对应奇回文串（从 2 开始）</span><br><span class="line">        # ti 为奇数，对应偶回文串（从 3 开始）</span><br></pre></td></tr></table></figure><p>暴力破解法：</p><p>等待补充。。。。 2025.4.11</p><h2 id="83-最长公共子序列">83.<a href="https://leetcode.cn/problems/longest-common-subsequence/"> 最长公共子序列</a></h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution83</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1,String text2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];<span class="comment">//初</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j+<span class="number">1</span>] = s[i]==t[j]?f[i][j]+<span class="number">1</span>:</span><br><span class="line">                        Math.max(f[i][j+<span class="number">1</span>],f[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中最主要的就是这一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i+1][j+1] = s[i]==t[j]?f[i][j]+1:</span><br><span class="line">                        Math.max(f[i][j+1],f[i+1][j]);</span><br></pre></td></tr></table></figure><p>下一项赋值为：</p><ul><li><p>如果含有公共的部分，也就是当前相等的话，**f[i][j }+1 长度+1</p></li><li><p>不含有的话，去下或者右的大的去寻找</p></li><li><p>最后这个值在<br>$$<br>f[n][m]<br>$$</p></li></ul><p>这个右下角上</p><h2 id="84-编辑距离">84.<a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution84</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String text1,String text2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> f[<span class="number">0</span>];</span><br><span class="line">            f[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x==t[j]?pre:Math.min(Math.min(f[j + <span class="number">1</span>], f[j]), pre) + <span class="number">1</span>;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面现遍历把text2遍历进数组</p><p>然后遍历text1</p><p>f[j+1]=</p><p>x==t[j]是不是想等</p><p>?pre 想等就是 tmp 也就是f[j+1]不动</p><p>:Math.min(Math.min(f[j + 1], f[j]), pre) + 1;不想打，操作+1<br>pre = tmp;更新前一项，也就是继续往下迭代</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/02/leetcodehot/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English三月篇</title>
      <link>https://blog.tokenlen.top/2025/03/01/en7/</link>
      <guid>https://blog.tokenlen.top/2025/03/01/en7/</guid>
      <pubDate>Fri, 28 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;每日一话+单词遗忘表3.1&lt;/h1&gt;
&lt;p&gt;There is something in every human being, even the most degraded, that slavery cannot corrupt – the soul’s</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>每日一话+单词遗忘表3.1</h1><p>There is something in every human being, even the most degraded, that slavery cannot corrupt – the soul’s instinct for freedom.</p><ul><li>spade 铲子</li><li>steer 驾驶</li><li>stock 股票</li><li>storey 楼层</li></ul><h1>每日一话+单词遗忘表3.2</h1><p>It always seems impossible until it’s done.</p><ul><li><strong>stove</strong> 火炉</li><li>straight 直的</li><li>strain 张力</li><li>strategy 战略</li><li>sphere 球</li><li>stretch 延申</li><li><strong>stride</strong> 大步</li><li>strike 罢工</li><li>strip 剥去</li><li><strong>strive</strong> 努力</li><li><strong>speculate</strong> 思考</li></ul><h1>每日一话+单词遗忘表3.3</h1><p>One cannot always be a hero, but one can always be a man.</p><ul><li>strap 捆绑</li><li>subsequent 随后的</li><li>substance 实质的</li><li><strong>subtract</strong> 减去</li><li>suburb 郊区</li><li>suck 吮吸</li><li>equivalent 平等的</li><li>oblige 强制的</li><li>nuisance 讨厌的人</li></ul><h1>每日一话+单词遗忘表3.4</h1><p>Education is the ability to listen to almost anything without losing your temper or your self-confidence.</p><ul><li>superior 上级</li><li>supervise 监督</li><li>supplement 增补物</li><li>surf 海浪</li><li>surgery 外科</li><li>surrender 投降</li><li><strong>suspend</strong> 推迟</li><li><strong>suspicion</strong> 嫌疑</li><li>sway 动摇</li><li>swear 辱骂</li></ul><h1>每日一话+单词遗忘表3.5</h1><p>Spring has returned. The Earth is like a child that knows poems.</p><ul><li>swift 快的</li><li>swipe 猛击</li><li>sympathy 同情</li><li><strong>tackle</strong> 处理</li><li>tailor 裁剪</li><li>spit 吐口水</li><li>orient 朝向</li></ul><h1>每日一话+单词遗忘表3.6</h1><p>Problems are not stop signs, they are guidelines.</p><ul><li>strain 拉紧</li><li>strap 抽打</li><li>parcel 包裹</li><li><strong>tedious</strong> 冗长的</li><li>temper 脾气</li><li>telescope 望远镜</li><li>tense 拉紧</li></ul><h1>每日一话+单词遗忘表3.7</h1><p>The difference between genius and stupidity is: genius has its limits.</p><ul><li>tent 帐篷</li><li>terrific 极好的</li><li>territory 领土</li><li>textile 纺织品</li><li>theft 偷窃</li><li>theory 伦理</li><li>therapy 治疗</li></ul><h1>每日一话+单词遗忘表3.8</h1><p>A girl should be two things: who and what she wants.</p><ul><li>thesis 论文</li><li>thief 小偷</li><li>fertile 丰饶的</li><li>thorough 彻底的</li><li>faculty 能力</li><li>thrive 繁荣的</li><li>throat 嗓子</li><li>thunder 雷</li></ul><h1>每日一话+单词遗忘表3.9</h1><p>The question isn’t who’s going to let me; it’s who is going to stop me.</p><ul><li>tide 潮汐</li><li>tissue 纸巾</li><li>tobacco 烟草</li><li>toe 脚趾</li><li>toilet 马桶</li><li><strong>tolerate</strong> 忍受</li><li>toll 钟声</li><li>strategy 战法</li><li>straw 稻草</li><li>stripe 稻草</li><li>flee 逃走</li></ul><h1>每日一话+单词遗忘表3.10</h1><p>Life consists not in holding good cards, but in playing well those you hold.</p><ul><li>tongue 舌头</li><li>pigeon 鸽子</li><li>penalty 惩罚</li><li><strong>torture</strong> 折磨</li><li>peril 危险</li><li>toss 投掷</li><li>pesssimism 悲观的</li><li>tractor 拖拉机</li><li>trail 踪迹</li><li>pierce 刺入</li><li>perspective 远景</li></ul><h1>每日一话+单词遗忘表3.11</h1><p>People always entrust their happiness to the future, which slips away unnoticed.</p><ul><li>tram 电车轨道</li><li>theater 剧院</li><li>thransparent 透明的</li><li>tray 托盘</li><li>superb 杰出的</li><li>tremendous 极大的</li><li><strong>trial</strong> 试炼</li><li><strong>trifle</strong> 琐事</li><li>torture 折磨</li></ul><h1>每日一话+单词遗忘表3.12</h1><p>If you want to build a ship, don’t drum up people to collect wood and don’t assign them tasks and work, but rather teach them to long for the endless immensity of the sea.</p><ul><li>triumph 胜利</li><li>precaution 预防措施</li><li>tuition 学费</li><li>tumor 肿块</li><li>tune 曲调</li><li>twist 拧</li><li>typewriter 打字机</li><li>thrive 兴隆</li><li>prescribe 开药方</li></ul><p>今天是植树节，是一个特殊的节日。今天也是孙先生逝世的日子，感谢！</p><h1>每日一话+单词遗忘表3.13</h1><p>Genuine tragedies in the world are not conflicts between right and wrong. They are conflicts between two rights.</p><ul><li>tyre 轮胎</li><li>ultimate 最终的</li><li>umbrella 雨伞</li><li><strong>undergo</strong> 经历</li><li>undertake 承担</li><li>triumph 胜利</li></ul><h1>每日一话+单词遗忘表3.14</h1><p>Do not seat your love upon a precipice because it is high.</p><ul><li>tragedy 悲剧</li><li>tractor 拖拉机</li><li>upringht 正直的</li><li>upset 使心烦</li><li>therapy 治疗</li><li>usage 用法</li><li>urgent 紧急的</li><li>utility 用法</li><li>theft 偷窃</li><li>utmost 最大可能的</li><li>vacuum 真空</li></ul><h1>每日一话+单词遗忘表3.15</h1><p>It’s better to light a candle than to curse the darkness.</p><ul><li>vanish 消失</li><li><strong>vapor</strong> 蒸汽</li><li>vehicle 车辆</li><li>tram 车辆</li><li>pretend 假装</li><li>venture 敢于</li><li>victim 牺牲者</li></ul><h1>每日一话+单词遗忘表3.16</h1><p>Our greatest glory consists not in never falling, but in rising every time we fall.</p><ul><li>vigor 活力</li><li>triumph 胜利</li><li>proof 证明</li><li><strong>violate</strong> 违反</li><li>vigour 精力</li><li>vital 生死攸关的</li><li>tuition 学费</li><li>volume 体积</li><li><strong>vulnrable</strong> 脆弱的</li><li>voyage 航行</li><li>tutor 导师</li></ul><h1>每日一话+单词遗忘表3.17</h1><p><strong>The more solitary, the more friendless, the more unsustained I am, the more I will respect myself.</strong></p><ul><li>pupil 学生</li><li>wage 工资</li><li>provoke 激起</li><li>wary 机警的</li><li>waterproof 不透水的</li><li>volcano 火山</li></ul><h1>每日一话+单词遗忘表3.18</h1><p>Don’t bother just to be better than your contemporaries or predecessors. Try to be better than yourself.</p><ul><li>rag 破布</li><li><strong>weird</strong> 怪异的</li><li>welfare 福利</li><li>whale 鲸鱼</li><li>quota 定额</li></ul><h1>每日一话+单词遗忘表3.19</h1><p>In the end, we will remember not the words of our enemies, but the silence of our friends.</p><ul><li><strong>veteran</strong> 老兵</li><li>whilst 当…时候</li><li>whisper 私语</li><li>amateur 业余的</li><li>ambassador 大使</li><li>versus 对抗</li><li>apparatus 运动器械</li></ul><h1>每日一话+单词遗忘表3.21</h1><p>Keep away from people who try to belittle your ambitions. Small people always do that, but the really great make you feel that you, too, can become great.</p><ul><li>urgent 紧急的</li><li>utter 绝对的</li><li>vigor 活力</li><li>volume 卷</li><li>voyage 航海</li></ul><h1>每日一话+单词遗忘表3.22</h1><p>The night opens the flowers quietly and allows the day to get thanks.</p><ul><li>arrest 吸引</li><li>wrap 包</li><li><strong>wreck</strong> 失事</li><li>yell 大叫</li><li>veteran 老兵</li><li><strong>yoghurt</strong> 酸奶</li><li>realm  王国</li><li>vessel 容器</li><li>reap 收获</li></ul><h1>每日一话+单词遗忘表3.23</h1><p>The empty vessels make the greatest sound.</p><ul><li>attorney 代理人</li><li>reluctant 不情愿的</li><li>naughty 顽皮的</li><li>napkin 餐巾纸</li></ul><h1>每日一话+单词遗忘表3.24</h1><p>The pessimist complains about the wind. The optimist expects it to change. The realist adjusts the sails.</p><ul><li>ridicule 嘲笑</li><li>riot 暴乱</li><li>mushroom 蘑菇</li><li>ribbon 绸缎</li><li>rival 竞争对手</li></ul><h1>每日一话+单词遗忘表3.25</h1><p>I blossom for my own sake because it pleases me, not for the sake of others. My joy consists in my being and my blossoming.</p><ul><li>violate 违背</li><li>gamble 赌博</li><li>vinegar 醋</li><li>vital 极其重要的</li><li>weird 怪诞的</li><li>fragment 碎片的</li></ul><h1>每日一话+单词遗忘表3.26</h1><p>If you are not in good control of time or cannot set priorities for different matters, what you do is surely to be rebated.</p><ul><li>ruin 毁灭</li><li>gorgeous 极好的</li><li>roof 屋顶最高处</li><li>gossip 闲聊</li><li>narrate 讲故事</li><li>yoghurt 酸奶</li><li>glimpse 一瞥</li><li>rope 绳子</li><li>gadget 小玩意</li></ul><h1>每日一话+单词遗忘表3.27</h1><p>To really understand a man we must judge him in misfortune.</p><ul><li>grind 磨碎</li><li>nonsense 胡扯</li><li>sausage 香肠</li><li>scatter 分散</li><li>grief 悲伤</li><li>sauce 酱汁</li></ul><h1>每日一话+单词遗忘表3.28</h1><p>The purpose of art is washing the dust of daily life off our souls.</p><ul><li>haul 拖拉</li><li>handicap 障碍</li><li>separate 分开</li><li>hectare 公顷</li><li>gray 灰色的</li><li>helicopter 直升机</li></ul><h1>每日一话+单词遗忘表3.29</h1><p>The greatest enemy of knowledge is not ignorance; it is the illusion of knowledge.</p><ul><li>authentic 可信的</li><li>yoghurt 酸奶</li></ul><h1>每日一话+单词遗忘表3.31</h1><p>Vast spirit, active thought and industrious heart make a genius.</p><p>Some people walk in the rain, others just get wet.</p><ul><li>abolition 废除</li><li>accordance 一致</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/03/01/en7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sql原理</title>
      <link>https://blog.tokenlen.top/2025/02/25/sql1/</link>
      <guid>https://blog.tokenlen.top/2025/02/25/sql1/</guid>
      <pubDate>Mon, 24 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;事务&lt;/h1&gt;
&lt;p&gt;事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。&lt;/p&gt;
&lt;p&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>事务</h1><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png" alt=""></p><p>ACID特性</p><p><strong>原子性</strong>（Atomicity）</p><p><strong>事务</strong>被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><p><strong>一致性</strong>（Consistency）</p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><p><strong>隔离性</strong>（Isolation）</p><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><p><strong>持久性</strong>（Durability）</p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><p>但是这几个特性不是有一种平级关系</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png" alt=""></p><p>在mysql中一般采用autocommit自动提交模式</p><p>除非使用<code>START TRANSACTION</code>开启一个事务</p><p>否则每一个语句都被视作一个事务</p><p>mysql中事务的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@AUTOCOMMIT;</span><br><span class="line">SET @@AUTOCOMIIT = 0;</span><br></pre></td></tr></table></figure><p>设置为手动提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><p>提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><p>回滚事务</p><p>开启事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION 或 BEGIN;</span><br></pre></td></tr></table></figure><p><strong>实例银行：</strong></p><p>没有发生错误的时候，不需要rollback的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询账户A的余额</span><br><span class="line"><span class="keyword">SELECT</span> MONEY <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 更新账户A的余额，减去<span class="number">1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>更新账户B的余额，增加<span class="number">1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发生错误的时候，则需要rollback</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 查询账户A的余额</span><br><span class="line">    <span class="keyword">SELECT</span> MONEY <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>更新账户A的余额，减去<span class="number">1000</span></span><br><span class="line">    <span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 更新账户B的余额，增加<span class="number">1000</span></span><br><span class="line">    <span class="keyword">UPDATE</span> ACCOUNT <span class="keyword">SET</span> MONEY <span class="operator">=</span> MONEY <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 提交事务</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 如果发生错误，回滚事务</span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 可以添加错误处理的代码，比如记录日志或者返回错误信息</span><br><span class="line"><span class="keyword">END</span> CATCH;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="丢失修改">丢失修改</h2><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><h2 id="读取脏数据">读取脏数据</h2><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h2 id="不可重复读">不可重复读</h2><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h2 id="幻读">幻读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是<strong>通过并发控制来保证隔离性</strong>。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p><h1>锁</h1><h2 id="封锁粒度">封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡</p><h2 id="锁类型">锁类型</h2><p>锁是计算机调解多个进程或者并发访问某一资源的机制</p><p>分类：</p><ul><li>全局锁 锁住所有表</li><li>表级锁 锁住整张表</li><li>行级锁 锁住整个行的数据</li></ul><h3 id="全局锁">全局锁</h3><p>对整个数据库的实例进行加锁，整个实例处于只读状态</p><p>dml 和ddl语句都会阻塞</p><p>数据备份的时候会引发全局锁，从而获得一致性视图，来保证数据的完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;<span class="operator">/</span><span class="operator">/</span>开锁</span><br><span class="line">mysqldump <span class="operator">-</span>u <span class="operator">-</span>p itcast<span class="operator">&gt;</span>itcast.sql;<span class="operator">/</span><span class="operator">/</span>备份</span><br><span class="line">unlock tables;<span class="operator">/</span><span class="operator">/</span>关锁</span><br></pre></td></tr></table></figure><p>在主库上备份，在备份期间都不能更新</p><p>在从库上备份，在备份期间不能执行从主库同步过来的二进制日志，会有主从延迟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p123 itcast &gt;itcast.sql</span><br></pre></td></tr></table></figure><p>这样就能在innnodb引擎上完成不加锁的一致性数据备份</p><h3 id="表级锁">表级锁</h3><p>1.表级锁</p><p>一次锁住整张表，开销小但并发性差。</p><p><strong>表共享锁（READ LOCK）</strong>：多个事务可以读，但不能写。</p><p><strong>表排他锁（WRITE LOCK）</strong>：只能由一个事务进行读写，其他事务无法访问。</p><p><strong>共享锁(read读锁)之间是兼容的，排他锁（写锁）是不能够兼容的</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES table_name READ;</span><br><span class="line">LOCK TABLES table_name WRITE;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>加锁和释放锁</p><p>2.意向锁</p><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>意向锁是innoDB引擎自动加的锁，用户无法手动加锁</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png" alt=""></p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><p>查询当前锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.innodb_locks;</span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="行级锁">行级锁</h3><p>读写锁</p><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</p><p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png" alt=""></p><h2 id="锁的优化">锁的优化</h2><p>避免间隙锁和临键锁</p><p>1.使用 <code>READ COMMITTED</code> 隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样 MySQL 只会使用 <strong>行锁</strong>，不会使用 <strong>Next-Key Lock</strong>，减少锁冲突。</p><p>但可能导致<strong>幻读</strong>。</p><p>2.使用唯一索引</p><p><strong>Next-Key Lock 只会作用于非唯一索引</strong>，如果查询用的是唯一索引，MySQL 只会加<strong>行锁</strong>，不会使用 <strong>Next-Key Lock</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM account WHERE id=5 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>如果 <code>id</code> 是 <strong>主键或唯一索引</strong>，那么 MySQL 只会锁 <code>id = 5</code>，不会锁范围 <code>(1,5]</code>。</p><table><thead><tr><th>锁类型</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>表级锁</strong></th><th>整张表</th><th>开销小，但并发低</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>意向锁（IS/IX）</strong></th><th>简化表锁检查</th><th>事务自动加锁，意向锁之间不会冲突</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>行锁（S/X）</strong></th><th>具体行</th><th>只针对索引数据，不走索引会变表锁</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>间隙锁（Gap Lock）</strong></th><th>锁定索引间隙</th><th>防止 <code>INSERT</code> 幻读，可共存</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>Next-Key Lock</strong></th><th>行锁 + 间隙锁</th><th>只在 <code>REPEATABLE READ</code> 级别下生效</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="封锁协议">封锁协议</h2><h3 id="三级封锁协议">三级封锁协议</h3><p>一级：</p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决<strong>丢失修改问题</strong>，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220440451.png" alt=""></p><p>二级：</p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读<strong>脏数据问题</strong>，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220831843.png" alt=""></p><p>三级：</p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决<strong>不可重复读的问题</strong>，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221313819.png" alt=""></p><h3 id="两段锁协议">两段锁协议</h3><p><strong>加锁和解锁分为两个阶段进行。</strong></p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock<span class="operator">-</span>x(A)...lock<span class="operator">-</span>s(B)...lock<span class="operator">-</span>s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock<span class="operator">-</span>x(A)...unlock(A)...lock<span class="operator">-</span>s(B)...unlock(B)...lock<span class="operator">-</span>s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h3 id="mysql的隐式和显式锁定">mysql的隐式和显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为<strong>隐式锁定</strong>。</p><p>InnoDB 也可以使用特定的语句进行<strong>显示锁定</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">In</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1>隔离级别</h1><p>未提交读（READ UNCOMMITTED）</p><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><p><strong>没提交也能读取</strong></p><p>提交读（READ COMMITTED）</p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><p><strong>提交了才能读取</strong></p><p>可重复读（REPEATABLE READ）</p><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><p><strong>重复读的结果一样</strong></p><p>可串行化（SERIALIZABLE）</p><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><p><strong>事务串行执行</strong></p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png" alt=""></p><h3 id="事务隔离级别对锁的影响"><strong>事务隔离级别对锁的影响</strong></h3><table><thead><tr><th>隔离级别</th><th>读未提交</th><th>读已提交</th><th>可重复读</th><th>可串行化</th></tr></thead><tbody><tr><td><strong>行锁</strong></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>间隙锁</strong></td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td><strong>Next-Key Lock</strong></td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table><p>在mysql可以手动设置事务的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION</span><br></pre></td></tr></table></figure><p>查看当前的隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION TRANSACTION_ISOLATION LEVEL [几种级别]</span><br></pre></td></tr></table></figure><p>设置当前的隔离级别</p><p>实例：</p><p>设置当前事务隔离等级为可重复读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">-- 第一次读取</span></span><br><span class="line"><span class="comment">-- 此时事务 B 插入了一条新的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ACCOUNT <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">-- 结果不变</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ACCOUNT (NAME, MONEY) <span class="keyword">VALUES</span> (<span class="string">&#x27;C&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>; <span class="comment">-- 事务 A 读取不到这条新增数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>多版本并发控制</h1><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现</p><h2 id="基本思想">基本思想</h2><p>在封锁一节中提到，<strong>加锁</strong>能解决<strong>多个事务同时执行时出现的并发一致性问题</strong>。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 <strong>MVCC</strong> 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p>脏读和不可重复读最根本的原因是<strong>事务读取到其它事务未提交的修改</strong>。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读<strong>取已经提交的快照</strong>。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h2 id="版本号">版本号</h2><ul><li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li></ul><h2 id="Undo日志">Undo日志</h2><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p><p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(id,x) <span class="keyword">VALUE</span>(<span class="number">1</span>,&quot;a&quot;);</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;b&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;c&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png" alt=""></p><p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p><h2 id="ReadView">ReadView</h2><p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png" alt=""></p><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快<strong>照时在当前所有未提交事务之前进行更改的</strong>，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在<strong>事务启动之后被更改的，因此不可使用</strong>。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：<strong>如果 TRX_ID 在 TRX_IDs 列表中</strong>，表示该数据行快照对应的事务还<strong>未提交</strong>，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：<strong>都不可以使用</strong>。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p><h2 id="快照读和当前读">快照读和当前读</h2><p>1.快照读：</p><p>MVCC 的 SELECT 操作是<strong>快照中的数据</strong>，不需要进行加锁操作。</p><p>2.当前读：</p><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><h2 id="临键锁-Next-Key-Lock">临键锁(Next-Key Lock)</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下（innoDB引擎默认的隔离级别），使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><p>Next-Key lock是<strong>间隙锁（Gap Lock）</strong> 的一种特殊形式。</p><p>实际上是<strong>行锁加上间隙锁</strong>的结合</p><p>record locks：</p><p>行锁，锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><p>gap locks：</p><p>间隙锁,锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><strong>查询包含范围条件（<code>BETWEEN</code>, <code>&lt;</code>, <code>&gt;</code>）时</strong>，会触发 <strong>间隙锁</strong>。</p><p>Next-key locks:</p><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个<strong>前开后闭区间</strong></p><p>假设表account里有如下数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id   <span class="operator">|</span> name  <span class="operator">|</span> money</span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"><span class="number">1</span>    <span class="operator">|</span> A     <span class="operator">|</span> <span class="number">1000</span></span><br><span class="line"><span class="number">5</span>    <span class="operator">|</span> B     <span class="operator">|</span> <span class="number">2000</span></span><br><span class="line"><span class="number">10</span>   <span class="operator">|</span> C     <span class="operator">|</span> <span class="number">3000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>事务A执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MySQL 会加 <strong>Next-Key Lock</strong>：</p><ul><li>锁住 <strong>id = 5</strong>（行锁）</li><li>锁住 <strong>(1, 5] 这个区间</strong>（间隙锁）</li><li>其他事务不能在 <code>id = 2, 3, 4</code> 处插入数据</li></ul><p>如果表里<strong>没有 id = 5</strong>，那么 MySQL 仍然会锁住 <code>(1, 10)</code> 之间的范围，防止 <code>id = 5</code> 被插入。</p><h1>E-R图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2 id="组成部分">组成部分</h2><h3 id="实体">实体</h3><p>是现实世界中可以被区分的对象，比如学生，课程等</p><p>实体分为强实体和弱实体</p><p>强实体：能够独立存在的实体，通常有<strong>主键</strong>（Primary Key）。</p><p>弱实体：必须依赖其他实体才能存在，没有主键，依赖于强实体的“识别关系（Identifying Relationship）”来标识。</p><p>弱实体的表示：</p><ul><li><p>用 <strong>双框矩形</strong> 表示弱实体。</p></li><li><p>依赖的关系用 <strong>双菱形</strong> 表示。</p></li><li><p>需要一个**外键（Foreign Key）**来引用强实体的主键。</p></li></ul><h3 id="属性">属性</h3><p>实体的属性描述了实体的特征。</p><p><strong>单值属性（Single-valued Attribute）</strong>：例如“姓名（Name）”。</p><p><strong>多值属性（Multivalued Attribute）</strong>：例如“电话号码（Phone Numbers）”，用 <strong>双椭圆</strong> 表示。</p><p><strong>复合属性（Composite Attribute）</strong>：可以再分解，例如“姓名”可以分为“姓”和“名”。</p><p><strong>派生属性（Derived Attribute）</strong>：可以从其他属性计算得到，如“年龄”可以由“出生日期”计算，通常用<strong>虚线椭圆</strong>表示。</p><h3 id="实体的三种联系">实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li><li><strong>菱形（Diamond）</strong> 表示联系，连接实体</li><li><strong>联系的属性（Attributes of Relationship）</strong>：如果联系本身有属性，则连到菱形上，例如“注册（Enroll）”联系可以有“注册日期（Enroll Date）”。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt=""></p><p>Course 和 Student 是一对多的关系。</p><h2 id="图的特点">图的特点</h2><h3 id="表示出现多次的关系">表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt=""></p><h3 id="联系的多向性">联系的多向性</h3><p>用 <strong>一个菱形连接多个实体</strong> 来表示三元或更高阶联系。</p><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt=""></p><h3 id="泛化与特化">泛化与特化</h3><p><strong>泛化（Generalization）</strong>：将多个子类合并为一个更一般的父类。例如，“本科生（Undergraduate）”和“研究生（Graduate）”可以泛化为“学生（Student）”。</p><p><strong>特化（Specialization）</strong>：将一个较一般的实体分解成多个更具体的子类，例如“员工（Employee）”可以特化为“教师（Teacher）”和“行政人员（Admin）”。</p><p>表示子类</p><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt=""></p><h2 id="E-R图到关系模型的转化">E-R图到关系模型的转化</h2><p>E-R 图通常会转换为关系型数据库的表：</p><p><strong>强实体 → 直接变成一个表</strong>。</p><p><strong>弱实体 → 需要外键和强实体的主键组合</strong>。</p><p><strong>一对多关系 → 在“多”的一侧添加外键</strong>。</p><p><strong>多对多关系 → 创建一个独立的中间表，存储双方的主键</strong>。</p><p><strong>三元关系 → 也可以转换为一个关系表，包含所有相关实体的外键</strong>。</p><h2 id="E-R图的扩展">E-R图的扩展</h2><p>EER（Enhanced Entity-Relationship）模型是 E-R 图的扩展，包括</p><p><strong>层次结构（Hierarchy）</strong>：增加继承关系。</p><p><strong>约束（Constraints）</strong>：如**完全（Total）<strong>和</strong>部分（Partial）**约束。</p><p><strong>集合（Aggregation）</strong>：将一个联系当作一个整体，参与其他联系。</p><h1>关系数据库设置理论</h1><p>关系数据库的<strong>设计理论</strong>而是<strong>为了确保数据存储的合理性、减少冗余、消除更新异常，同时保持数据的完整性</strong>。</p><h2 id="函数依赖">函数依赖</h2><p>记 A-&gt;B 表示 <strong>A 函数决定 B</strong>，也可以说 <strong>B 函数依赖于 A。</strong></p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为<strong>键码</strong>。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是<strong>部分函数依赖</strong>，否则就是<strong>完全函数依赖。</strong></p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常">异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入</li></ul><h2 id="范式">范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><p>涉及到<strong>表的分解</strong>，根据表之间的逻辑关系</p><p>这些范式的设计过程通常会导致<strong>将一张表分解成多个子表</strong>，以减少冗余和异常。</p><p>第一范式（1NF）</p><p><strong>属性</strong>不可分</p><p>第二范式（2NF）</p><p>每个非主属性完全函数依赖于<strong>键码</strong>。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Cname</th><th style="text-align:center">Grade</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">课程-1</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-2</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">课程-1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">课程-2</td><td style="text-align:center">95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><p>第三范式（3NF）</p><p><strong>非主属性不传递函数依赖于键码。</strong></p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th style="text-align:center">Sno</th><th style="text-align:center">Sname</th><th style="text-align:center">Sdept</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">学生-1</td><td style="text-align:center">学院-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">学生-2</td><td style="text-align:center">学院-2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">学生-3</td><td style="text-align:center">学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th style="text-align:center">Sdept</th><th style="text-align:center">Mname</th></tr></thead><tbody><tr><td style="text-align:center">学院-1</td><td style="text-align:center">院长-1</td></tr><tr><td style="text-align:center">学院-2</td><td style="text-align:center">院长-2</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/25/sql1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>sql原理基础概念</title>
      <link>https://blog.tokenlen.top/2025/02/25/sql2/</link>
      <guid>https://blog.tokenlen.top/2025/02/25/sql2/</guid>
      <pubDate>Mon, 24 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;p&gt;数据库（Database）：存放和提供数据的库房&lt;/p&gt;
&lt;p&gt;数据(Data)：数据库中存储的基本对象&lt;/p&gt;
&lt;p&gt;数据库管理系统(DBMS)：位于用户和操作系统之间的一层数据管理软件&lt;/p&gt;
&lt;p&gt;数据库系统：包括数据库，数据库管理系统，应</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本概念</h1><p>数据库（Database）：存放和提供数据的库房</p><p>数据(Data)：数据库中存储的基本对象</p><p>数据库管理系统(DBMS)：位于用户和操作系统之间的一层数据管理软件</p><p>数据库系统：包括数据库，数据库管理系统，应用程序，数据库管理员</p><p>主键：用于唯一标识表中的某一条记录的属性或者属性的集合</p><p>外键：用于与另一张表关联，外键为灵一张表的主键</p><p>超键：超键是唯一能区分元组的属性和属性的集合</p><p>实例：数据库在某一时刻存储的真实数据</p><p>数据操纵语言：增删改查</p><p>数据定义语言：定义、删除、修改数据库中的对象</p><p>数据控制语言：用于控制用户对数据库操纵的权限</p><p>数据模型：现实世界数据特征的抽象，用来定于数据如何组织，数据之间的关系是怎么样的</p><p>并相容性：两个关系具有并相容性需要保证具有相同的属性个数，以及对于每个属性都有相同的域</p><p>视图：视图时虚拟的表，并不是物理存储的数据。是基本表或其他视图派生的数据。对视图的更新，实际上转换为对实际基表的更新。</p><h2 id="数据模型">数据模型</h2><p>现实世界数据特征的抽象，用来定义数据如何组织，数据之间的关系怎样。</p><p>层次：</p><p>概念模型：按用户的观点来对数据或者信息进行建模</p><p>逻辑/实现模型：层次模型，网状模型，关系模型</p><p>物理模型：数据在具体DBMS产品中的物理存储方式</p><h2 id="数据库系统">数据库系统</h2><p>三级模式结构：</p><ul><li><p>内模式：<strong>数据物理结构和储存方式</strong>的描述，是数据在数据库内部的表示方式</p></li><li><p>概念模式：是对数据库中全体数据的<strong>逻辑结构</strong>和<strong>特征</strong>的描述</p></li><li><p>外模式：数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述</p></li></ul><p>两级映射：</p><ul><li>概念模式/内模式映射</li><li>外模式/概念模式映射</li></ul><p>数据的物理独立性：</p><p><strong>内模式与概念模式</strong>之间的映射提供了数据的<strong>物理独立性</strong>。当数据的物理结构发生变化时，只需要修改内模式与概念模式之间的映射即可。</p><p>数据的逻辑独立性：</p><p><strong>概念模式与外模式</strong>之间的映射提供了数据的<strong>逻辑独立性</strong>。当数据的整体逻辑结构发生变化时，只需要修改各个外模式与概念模式之间的映射即可保证应用程序不受影响。</p><h2 id="约束">约束</h2><p>完整性约束：</p><ol><li>域约束：对<strong>属性取值范围</strong>的约束</li><li>键约束：每个关系必须要有<strong>主键</strong>，且每个主键必须不相同</li><li>非空约束：属性值不能为NULL</li><li>实体完整性约束：主键值不能为空</li><li>参照完整性约束：外键可以取NULL值，但若外键为另一关系主键，则不能为NULL</li><li>用户定义的完整性</li></ol><p>数据的操作违反的完整性约束：</p><p>插入操作：域约束、键约束、非空约束、实体完整性约束、参照完整性约束</p><p>删除操作：参照完整性约束</p><p>更新操作：域约束、键约束、非空约束、实体完整性约束、参照完整性约束</p><h2 id="关系">关系</h2><p>关系看上去像一张二维表，每个表由行和列组成</p><p>行代表一个元组，即<strong>数据记录</strong>。列代表属性，即<strong>字段</strong></p><p>关系的域为一组原子值（不可再分割的值）</p><p>关系中的元组必须各不相同（元组的唯一性）</p><p>五种基本运算：</p><p>并，差，笛卡尔积，选择，投影</p><p>关系代数是用对关系的运算来表达查询，这个时候可以使用关系代数解释器来模拟关系代数。</p><h3 id="并">并</h3><p>运算符<strong>∪</strong></p><p>并运算将两个关系的所有元组合并为一个新关系，前提是两个关系必须有<strong>相同的属性</strong>（列），且每个元组在结果中只出现一次（去重）。</p><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>3</td><td><strong>4</strong></td></tr></tbody></table><p><code>R1 ∪ R2</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table><p>相当于<strong>增加行</strong></p><h3 id="差">差</h3><p><strong>运算符</strong>：<code>-</code></p><p>差运算返回一个关系中有而另一个关系中没有的元组，前提是两个关系有相同的属性。</p><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table><p><code>R1 - R2</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr></tbody></table><p>相当于<strong>删减行</strong></p><h3 id="笛卡尔积">笛卡尔积</h3><p><strong>运算符</strong>：<code>×</code></p><p>笛卡尔积运算将两个关系中的每一对元组组合成一个新的元组，其中一个关系的所有元组与另一个关系的每个元组组合形成一个新的元组。它的结果是一个新关系，包含了<strong>两个关系中所有属性的组合</strong>。</p><p><strong>两个集合相乘的结果</strong></p><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(C, D)</p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p><code>R1 × R2</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td><td>6</td></tr><tr><td>1</td><td>2</td><td>7</td><td>8</td></tr><tr><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>3</td><td>4</td><td>7</td><td>8</td></tr></tbody></table><p>相当于<strong>增加列</strong></p><h3 id="选择">选择</h3><p><strong>运算符</strong>：<code>σ</code></p><p>选择运算用于从关系中选择满足特定条件的元组。选择操作是一种<strong>过滤</strong>操作，它根据指定的条件返回满足条件的元组。</p><p>R(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p><code>σ(A &gt; 4)(R)</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p>相当于<strong>过滤</strong></p><h3 id="投影">投影</h3><p><strong>运算符</strong>：<code>π</code></p><p>投影运算用于从关系中选择指定的列（属性）。它会返回包含指定列的所有元组，并且会去除重复的元组。</p><p>R(A, B, C)</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><p><code>π(A, B)(R)</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>4</td><td>5</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p>相当于<strong>删减列</strong></p><h3 id="连接">连接</h3><p><strong>运算符</strong>：<code>⨝</code></p><p>连接是将两个关系中的元组按照某些共享的属性进行组合，生成新的元组。它是关系代数中非常重要的运算，因为它能够合并来自不同表的数据。连接运算通常是基于一个公共的列（或多个列）进行的。</p><p><strong>自然连接（Natural Join）</strong>：在自然连接中，连接操作自动寻找两个关系中相同名称的列，并将它们作为连接条件。自然连接将仅返回匹配的元组，并去除重复的列。</p><p><strong>等值连接（Equi-Join）</strong>：等值连接是指使用等号（<code>=</code>）作为连接条件，将两个关系中某个或某些列的值相等的元组合并。</p><p><strong>外连接（Outer Join）</strong>：外连接除了返回两个关系中匹配的元组外，还会保留在其中一个关系中没有匹配的元组，并用<code>NULL</code>填充缺失的值。外连接有三种类型：</p><ul><li><strong>左外连接（Left Outer Join）</strong>：返回左表中所有元组，以及右表中匹配的元组。<strong>右边的补充null</strong></li><li><strong>右外连接（Right Outer Join）</strong>：返回右表中所有元组，以及左表中匹配的元组。<strong>左边的补充null</strong></li><li><strong>全外连接（Full Outer Join）</strong>：返回两个表中的所有元组，不论它们是否匹配。都补充null</li></ul><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(B, C)</p><table><thead><tr><th>B</th><th>C</th></tr></thead><tbody><tr><td>2</td><td>5</td></tr><tr><td>4</td><td>6</td></tr></tbody></table><p>如果我们进行自然连接：<code>R1 ⨝ R2</code>，连接条件是属性<code>B</code>，结果会是：</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td></tr><tr><td>3</td><td>4</td><td>6</td></tr></tbody></table><h3 id="除">除</h3><p><strong>运算符</strong>：<code>÷</code></p><p>除操作用于解决“对于所有”这种类型的查询问题，通常用于查找在某个关系中与所有其他元组匹配的元组。除运算的结果是返回那些“<strong>满足某个条件的所有值</strong>”的元组。</p><p>R1(Student, Course)</p><table><thead><tr><th>Student</th><th>Course</th></tr></thead><tbody><tr><td>Alice</td><td>Math</td></tr><tr><td>Alice</td><td>English</td></tr><tr><td>Bob</td><td>Math</td></tr><tr><td>Bob</td><td>History</td></tr><tr><td>Charlie</td><td>Math</td></tr></tbody></table><p>R2(Course)</p><table><thead><tr><th>Course</th></tr></thead><tbody><tr><td>Math</td></tr><tr><td>English</td></tr></tbody></table><p><code>R1 ÷ R2</code> 的结果是：</p><table><thead><tr><th>Student</th></tr></thead><tbody><tr><td>Alice</td></tr></tbody></table><p>相当于<strong>找到某值</strong></p><h2 id="使用关系代数完成查询">使用关系代数完成查询</h2><p>假设有两个关系：</p><ol><li><p><strong>学生（Student）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(学号, 姓名, 年龄, 系别)</span><br></pre></td></tr></table></figure><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th><th>系别</th></tr></thead><tbody><tr><td>101</td><td>张三</td><td>20</td><td>计算机系</td></tr><tr><td>102</td><td>李四</td><td>22</td><td>数学系</td></tr><tr><td>103</td><td>王五</td><td>21</td><td>计算机系</td></tr><tr><td>104</td><td>赵六</td><td>23</td><td>物理系</td></tr></tbody></table></li><li><p><strong>选课（CourseSelection）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CourseSelection(学号, 课程号, 成绩)</span><br></pre></td></tr></table></figure><table><thead><tr><th>学号</th><th>课程号</th><th>成绩</th></tr></thead><tbody><tr><td>101</td><td>C1</td><td>85</td></tr><tr><td>101</td><td>C2</td><td>90</td></tr><tr><td>102</td><td>C1</td><td>78</td></tr><tr><td>103</td><td>C3</td><td>88</td></tr><tr><td>104</td><td>C2</td><td>76</td></tr></tbody></table></li></ol><p>查询计算机系所有学生的姓名和年龄</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">π姓名, 年龄(σ系别=′计算机系′(Student))</span><br></pre></td></tr></table></figure><p>查询选修了 C1 课程的学生的姓名<br>$$<br>π<br>姓名<br>​<br>(σ<br>课程号=<br>′<br>C1<br>′</p><p>​<br>(CourseSelection)⋈Student)<br>$$<br>查询至少选修了一门课程的学生信息<br>$$<br>π<br>学号, 姓名, 年龄, 系别<br>​<br>(Student⋈CourseSelection)<br>$$<br>其中π 为投影，代表的是保留哪一列</p><p>σ为选择，代表一个过滤的条件</p><p>后面括号代码查询的是哪个关系</p><p>进行<strong>自然连接（⨝）</strong>，匹配相同“学号”的学生信息。</p><p>÷代表找到某值</p><p>x代表笛卡尔积，表示可能出现所有的一个集合</p><h2 id="三值谓词逻辑">三值谓词逻辑</h2><ul><li>TRUE</li><li>FALSE</li><li>UNKNOWN</li></ul><p>只有在比较结果为TRUE是才确定为真，e.g. （TRUE与UNKNOWN交为UNKNOWN， 此元组不会出现在结果中）</p><h2 id="将E-R模型映射成逻辑模型的步骤">将E-R模型映射成逻辑模型的步骤</h2><ol><li>映射<strong>强实体型</strong></li><li>映射<strong>弱实体型</strong></li><li>映射1 : 1 二元联系型</li><li>映射1 : N 二元联系型</li><li>映射M : N二元联系型</li><li>映射<strong>多值属性</strong></li><li>映射<strong>N元联系</strong></li></ol><h2 id="关系模型的三个组成部分">关系模型的三个组成部分</h2><ul><li>数据结构：基本的数据组织形式是关系，关系由元组和属性组成</li><li>数据操作：包括查询，更新操作</li><li>数据约束：包括实体完整性，参照完整性，用户定义完整性</li></ul><h2 id="关系键">关系键</h2><p>主码：唯一标识元组的属性或属性组合，不可为空。</p><p>全码：能够唯一标识元组的属性集合，可能包含冗余属性。</p><p>候选码：最小的全码，不能再减少任何属性，否则就无法唯一标识元组。</p><p>外码：一个关系中的某个属性（或属性组），它引用另一个关系的主码。</p><p>外码的属性的值可以为空值</p><p>主属性：属于某个候选码的属性。</p><p>非主属性：不属于任何候选码的属性。</p><h1>关系型数据库</h1><p>数据库管理的需要催生了DBMS，而关系型数据库管理为RDBMS</p><p>常见的数据模型有三种：</p><ol><li>层次模型</li><li>网状模型</li><li>关系模型</li></ol><p>文件管理数据的缺陷：</p><ol><li><strong>数据冗余和不一致性</strong>。数据冗余表示在每个shell脚本中基本上都是/bin/bash，但很多用户使用的都是bash，那么这个可能出现多次，冗余量很大；不一致性，比如有一个数据在多个文件中都被使用，那么修改的时候，需要把每个文件都手动修改。</li><li><strong>数据访问困难</strong>。如果数据库有上千万行数据，那么我们使用时，需要把这上千万行数据全部载入内存中，再使用，对硬件的要求会很高而且载入时间很长，但其实我们需要比较的也只是那一行数据而已。</li><li><strong>数据孤立</strong>。由于数据保存在不同的文件里面，所以这些文件之间的格式可能各不相同，所以后续开发一个软件来管理的话非常困难，因为它们不满足某一个规范，使得数据之间是相互孤立的。</li><li><strong>完整性问题</strong>。例如两个转账的用户之间数额的总和应该是一样的，但如果在转账的过程中出现了问题，那么文件就无法解决，除非应用程序设计上解决，但应用程序本身并无法理解数据之间的逻辑问题。</li><li><strong>原子性问题</strong>。类似于完整性问题，数据必须从一个稳定的状态转换为另外一个稳定的状态。</li><li><strong>并发访问异常问题</strong>。按道理来讲，如果一个用户访问数据库文的前十行，另一个用户访问最后十行，本身他们俩并不会冲突，但如果某个用户需要修改的话，另外一个用户并不能访问。因为为了保证文件的完整性，我们会加锁的，但文件级别的锁安全性太高，并不适合这种访问</li><li><strong>安全性问题</strong>。部分访问授权很难实现，很难使某一个用户只能看到其中指定的某些字段。</li></ol><p>关系型数据库特点：</p><p>关系数据库想要解决<strong>数据冗余问题</strong>，它将每一个关系都看成了一个表，每一列都看成是一个属性，每一行看成是他的一个元组（也就是数据）如果有许多相同值的话，它将具有相同字段的值独立出来，把一张表拆分成两张表，降低所谓的冗余度，这种关系也叫做E-R关系模型（实体关系模型）</p><p>常见的关系模型：</p><ol><li>关系模型：用一张二维表来表示关系模型</li><li>实体关系模型：将一张表拆分，让它们产生某种联系</li><li>对象关系模型：存储一些比较大的文件如何存储呢？可以将一个比较大的文件先存储在数据库文件管理系统当中的某一个存储空间上，表中用一个指针指向这么某一个数据，把它当作一个存储对象来进行管理。</li><li>半结构化数据模型：结构化是指每一行存储的都是一样的，比如/etc/passwd文件中，第一个字段为用户名，第二个为密码等。半结构化表示它并不是唯一的，可能第一行存储的是用户名和性别，第二行存储的是用户名和年龄这种，<strong>所以每一行存储不止存储它的数据，还存储它的标签。</strong></li></ol><h2 id="SQL">SQL</h2><p>SQL：Structure Query Language(关系结构化语言)</p><ul><li>DML：数据操作语言，增删改查都是DML语句。</li><li>DDL：数据定义语言，实现数据对象的存储和定义。CREATE、DROP、ALTER</li><li>DCL：数据控制语言，GRANT、REVOKE，用来定义数据库中用户的访问权限</li></ul><p>关系数据库RDB的对象基本有：库、表、索引、视图、用户、存储过程、触发器、事件调度器等。</p><p>实现定义的时候，一定要考虑数据的<strong>约束</strong>关系</p><p>域约束：<strong>数据类型的约束</strong><br>外键约束：<strong>引用完整性约束</strong><br>主键约束：某字段能<strong>唯一</strong>标识此字段所属的实体，并且不允许为空,<strong>一张表中只能有一个主键</strong><br>唯一性约束：每一行的某字段都不允许出现相同值，可以为空，一张表中可以有多个<br>检查性约束：比如年龄只能时int型</p><h3 id="结构">结构</h3><ul><li>表示层：表</li><li>逻辑层：存储引擎，实现表和数据文件的解构</li><li>物理层：数据文件</li></ul><p>数据存储和查询</p><ul><li>存储管理器</li><li>查询管理器</li></ul><p>负责接收用户查询，理解用户查询，并将用户的查询包括存储转换为对应的存储管理器可以理解的语句，存储管理器将数据存储到磁盘上或从磁盘上删除的这么一种组件</p><p>存储管理器应该具有的组件（功能）：权限及完整性管理器、事务管理器、文件管理器、缓冲区管理器</p><p>查询管理器应该具有的组件（功能）：DML解释器、DDL解释器、查询执行引擎</p><p>数据存储和执行的过程：</p><ol><li>查询管理器接受用户查询，并理解。使用DML和DDL解释器</li><li>将DML和DDL解释器的结果给查询执行引擎</li><li>查询执行引擎的结果给存储管理器</li><li>存储管理器将操作写入磁盘中</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">数据库原理</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/25/sql2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络基础</title>
      <link>https://blog.tokenlen.top/2025/02/23/net2/</link>
      <guid>https://blog.tokenlen.top/2025/02/23/net2/</guid>
      <pubDate>Sat, 22 Feb 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本概念</h1><h2 id="传输方式">传输方式</h2><p>网络根据传输方式可以进行分类，一般分为<strong>面向连接型和面向无连接型</strong>。</p><ul><li>面向连接型中，在发送数据之前，需要在主机之间建立一条通信线路。</li><li>面向无连接型则不要求建立和断开连接，发送方可用于任何时候发送数据。接收端也不知道自己何时从哪里接收到数据。</li></ul><h2 id="分组交换">分组交换</h2><p>处在互联网边缘部分的机器，也就是互联网终端主机，它们官方一点的话术就是端系统。</p><p>在互联网应用中，每个终端系统都可以彼此交换信息，这种信息也被称为<code>报文(Message)</code>，报文是一个超集的概念，它可以包括你想要的任何东西，比如文字、数据、电子邮件、音频、视频等。为了从源目的地向端系统发送报文，需要把长报文切分为一个个小的数据块，这种数据块称为<code>分组(Packets)</code>，也就是说，报文是由一个个小块的分组组成。</p><p>这些分组其实就是<strong>包</strong></p><p>在分组的传输过程中，每个分组都要经过通信链路和分组交换机，分组要在端系统之间传输需要经过一定的时间，如果两个端系统之间需要传输的分组为 L 比特，链路的传输速率问 R 比特/秒，那么传输时间就是 L / R秒。</p><p>一个端系统需要经过交换机给其他端系统发送分组，当分组到达分组交换机时，交换机会如何操作？交换机会直接进行转发吗？不是的，交换机可没有这么无私，你想让我帮你转发分组？好，首先你需要先把整个分组数据都给我，我再考虑给你发送的问题，这就是<strong>存储转发传输</strong>。</p><h1>数据在不同层的称呼</h1><p>四层传输层数据被称作<strong>段</strong>（Segments）；</p><p>三层网络层数据被称做<strong>包</strong>（Packages）；</p><p>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</p><p>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</p><h1>网络层</h1><h2 id="IP地址">IP地址</h2><p><strong>网络ip地址：</strong></p><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p><strong>广播地址：</strong></p><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p><strong>组播地址：</strong></p><p>D类地址就是组播地址。</p><p><strong>A，B，C，D类地址</strong></p><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p><p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>255.255.255.255</strong></p><p><strong>该IP地址指的是受限的广播地址</strong>。受限广播地址与一般广播地址（直接广播地址）的区别在于，<strong>受限广播地址只能用于本地网络</strong>，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p><strong>0.0.0.0</strong></p><p><strong>常用于寻找自己的IP地址</strong>，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p>回环地址：</p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是<strong>127.0.0.1。</strong> 也可以用<strong>localhost</strong>来表示</p><p><strong>A、B、C类私有地址</strong></p><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h2 id="子网掩码">子网掩码</h2><p>随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。</p><p>这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。</p><p>子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果<strong>两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中</strong>。</p><p><strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即&quot; 0&quot;地址和广播地址，它们是指主机地址或网络地址全为&quot; 0&quot;或&quot; 1&quot;时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><h3 id="子网掩码的计算">子网掩码的计算</h3><p>无需划分：</p><p>在这个无须划分子网里面是按ip地址的类别决定的。比如A类地址占8个网络位，所以是255.0.0.0</p><p>B类地址占16个网络位，所以子网掩码就是255.255.0.0</p><p>C类地址占24个网络位，所以子网掩码就是255.255.255.0</p><p>固定大小的子网：</p><p>通常用于根据特定的网络需求（如特定数量的主机或子网）来划分。计算的关键是确定所需的网络位数和主机位数，并根据此来计算掩码。</p><ul><li><p>确定需要多少个子网，或者每个子网需要多少主机。</p></li><li><p>使用<strong>2的幂</strong>来推算所需的主机位数或子网位数。</p></li><li><p>将其与默认子网掩码结合，进行扩展。</p></li></ul><p>实例：</p><p>假设你有一个<strong>A类地址</strong><code>10.0.0.0</code>，默认子网掩码是<code>255.0.0.0</code>。你希望把这个地址划分为<strong>4个子网</strong>。</p><p>需要划分为4个子网，那么就需要2个子网位，然后又是A类地址，8个网络位。所以一共是10个网络位</p><p>所以新的子网掩码就是（前10位是1，其余是0）</p><p>11111111.11000000.00000000.00000000</p><p>转化为10进制就是</p><p><strong>255.192.0.0</strong></p><p>根据主机数来确定：</p><p>这种方法是通过需求来计算每个子网所能容纳的最大主机数，从而确定子网掩码。</p><ul><li><p>根据你想要的每个子网中的主机数，反推所需的主机位数。</p></li><li><p>用<strong>2的幂</strong>来计算能容纳的最大主机数。公式：<code>2^n - 2</code>（减去2是因为网络地址和广播地址不能用作主机地址）。</p></li><li><p>然后确定剩下的位数就是网络位数，从而确定子网掩码。</p></li></ul><p>实例：</p><p>假设你想要为每个子网容纳50个主机</p><p>2^n - 2 &gt;= 50</p><p><code>2^6 - 2 = 62</code>，所以需要6个主机位。</p><p>如果是C类地址，默认掩码是<code>255.255.255.0</code>，即24个网络位。</p><p>所以那么子网掩码用二进制表示就是</p><p>现在，给定6个主机位，网络位数是：<code>32 - 6 = 26</code></p><p>11111111.11111111.11111111.11000000</p><p>转化为10进制就是<strong>255.255.255.192</strong></p><p>CIDR表示法：</p><p>它允许你直接指定子网掩码的位数，而不是依赖于IP地址的类别。CIDR表示法用斜杠后跟数字的形式表示子网掩码。</p><ul><li><p>CIDR表示法是通过直接指明网络部分的位数来计算子网掩码。例如，<code>/24</code> 表示前24位是网络位，后8位是主机位。</p></li><li><p>你可以通过CIDR来指定任何IP地址和子网掩码，而不仅仅是A类、B类或C类地址。</p></li></ul><p><code>10.0.0.0/8</code>：表示A类地址 <code>10.0.0.0</code>，子网掩码为 <code>255.0.0.0</code>。</p><p><code>172.16.0.0/16</code>：表示B类地址 <code>172.16.0.0</code>，子网掩码为 <code>255.255.0.0</code>。</p><p><code>192.168.1.0/24</code>：表示C类地址 <code>192.168.1.0</code>，子网掩码为 <code>255.255.255.0</code>。</p><p>主机和子网的地址进行计算：</p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10＋1＋1＋1＝13</span><br></pre></td></tr></table></figure><p><strong>注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址</strong></p><p>网关也是要占地址的</p><p>13小于16（2的四次方）所以主机位是4位。256-16=240</p><p>所以子网掩码是<strong>255.255.255.240</strong></p><h2 id="网关">网关</h2><p>网关实质上是一个网络通向其他网络的IP地址。</p><p>比如有网络A和网络B，网络A的IP地址范围为<code>192.168.1.1~192. 168.1.254</code>，子网掩码为<code>255.255.255.0</code>；</p><p>网络B的IP地址范围为<code>192.168.2.1~192.168.2.254</code>，子网掩码为<code>255.255.255.0</code>。</p><p>而要实现这两个网络之间的通信，则必须通过网关。</p><p><strong>所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。</strong></p><p>如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。</p><p>网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。</p><h1>网络协议</h1><p>核心作用：</p><ul><li>**标准化通信：**网络协议为设备之间的通信提供了统一的标准，确保不同厂商、不同操作系统的设备能够互联互通。</li><li>**数据可靠传输：**通过错误检测、数据重传等机制，网络协议确保数据在传输过程中不会丢失或损坏。</li><li>**高效路由与寻址：**网络协议定义了如何将数据从源设备发送到目标设备，包括地址分配、路由选择等。</li><li>**安全性：**现代网络协议通常包含加密和认证机制，保护数据免受窃听或篡改。</li></ul><p>关键组成部分：</p><ul><li><strong>语法:</strong> 定义数据的格式和结构。例如，数据包的头部和尾部如何组织。</li><li><strong>语义:</strong> 定义数据的含义。例如，某个字段表示源地址，另一个字段表示目标地址。</li><li><strong>时序:</strong> 定义数据发送和接收的顺序。例如，TCP协议的三次握手过程。</li><li><strong>网络协议的分层结构:</strong> 网络协议通常按照分层模型组织，最常见的模型是 OSI七层模型 和 TCP/IP四层模型。每一层都有特定的功能和协议。</li></ul><h2 id="网络通信">网络通信</h2><p>网络通信是指通过计算机网络（如互联网）<strong>在不同设备之间传输数据的过程。<strong>这些设备可以是计算机、智能手机、服务器等。网络通信的核心目标是</strong>实现信息的快速、准确和安全传输。</strong></p><p>基本要素：</p><ul><li><strong>发送方（Sender）</strong>：发送数据的设备或应用程序。</li><li><strong>接收方（Receiver）</strong>：接收数据的设备或应用程序。</li><li><strong>传输介质（Transmission Medium）</strong>：数据在网络中传输的物理路径，如光纤、电缆、无线信号等。</li><li><strong>协议（Protocol）</strong>：规定数据如何传输、如何被接收和处理的规则和标准。</li></ul><p>在网络通信中，数据通常以&quot;包&quot;（Packet）的形式传输。数据封装是指将原始数据按照特定的协议格式打包，添加必要的控制信息（如源地址、目标地址、校验和等）。解封装则是接收方将接收到的数据包还原为原始数据的过程。</p><p>传输过程：</p><ol><li><strong>数据分段</strong>：将大块数据分割成适合传输的小块。</li><li><strong>添加头部信息</strong>：在每个数据段前添加协议头部信息，如IP地址、端口号等。</li><li><strong>传输</strong>：通过网络传输介质将数据包发送到目标设备。</li><li><strong>接收与重组</strong>：接收方接收数据包，并根据头部信息将数据包重组为原始数据。</li></ol><p>在网络通信中，数据被分割成小块进行传输，这些小块被称为数据包、帧或报文，具体名称取决于所在的网络层次。</p><ul><li><strong>数据包（Packet）:</strong> 在网络层（如IP协议）中，数据被封装成数据包，包含源地址、目标地址和数据内容。</li><li><strong>帧（Frame）:</strong> 在数据链路层（如以太网协议）中，数据包被进一步封装成帧，包含MAC地址和错误检测信息。</li><li><strong>报文（Message）:</strong> 在应用层（如HTTP协议）中，数据以报文的形式传输，包含请求或响应的具体内容。</li></ul><p>网络通信的基本流程：</p><ol><li><strong>数据封装</strong><ul><li>应用层生成数据报文。</li><li>传输层添加端口号（TCP/UDP）。</li><li>网络层添加IP地址（IP）。</li><li>数据链路层添加MAC地址（帧）。</li><li>物理层将数据转换为比特流。</li></ul></li><li><strong>数据传输</strong><ul><li>数据通过物理介质（如电缆、光纤）传输。</li></ul></li><li><strong>数据解封装</strong><ul><li>接收设备逐层解析数据，最终将数据传递给目标应用程序。</li></ul></li></ol><h2 id="ARP-RARP协议">ARP/RARP协议</h2><p><strong>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议</strong></p><p>ARP 把 IP 地址解析为硬件地址</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</p><p><strong>ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</strong></p><p><strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址</strong></p><p>ARP工作流程：</p><ul><li><p><strong>主机A查询ARP缓存</strong>：主机A检查是否有主机B的IP地址和MAC地址映射。如果有，直接使用该映射进行通信。</p></li><li><p><strong>ARP请求广播</strong>：如果ARP缓存中没有对应的映射，主机A会向网络广播ARP请求，询问目标IP（192.168.1.2）的MAC地址，ARP请求包括主机A的IP和MAC地址。</p></li><li><p><strong>主机B接收ARP请求</strong>：网络中的所有主机接收到ARP请求，检查IP地址是否匹配。如果匹配，则继续处理请求；否则丢弃请求。</p></li><li><p><strong>主机B发送ARP回复</strong>：主机B回复ARP请求，发送自己的MAC地址给主机A。</p></li><li><p><strong>主机A更新ARP缓存</strong>：主机A接收到主机B的ARP回复后，更新ARP缓存，并使用主机B的MAC地址进行通信。</p></li><li><p><strong>缓存生存期</strong>：ARP缓存的条目有生存期，生存期过后，主机A需要重新进行ARP过程以更新MAC地址映射。</p></li></ul><p>RARP工作流程：</p><ul><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li><li>如果不存在，RARP服务器对此不做任何的响应；</li></ul><h2 id="路由选择协议">路由选择协议</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p>RIP协议 ：底层是<strong>贝尔曼福特算法</strong>，它选择路由的度量标准（metric)是跳数，最大跳数是<strong>15跳</strong>，如果大于15跳，它就会丢弃数据包。</p><p>OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是<strong>迪杰斯特拉算法</strong>，是链路状态路由选择协议，它选择路由的度量标准是<strong>带宽，延迟</strong>。</p><h2 id="tcp-ip">tcp/ip</h2><p>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：<strong>TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。</p><p>TCP是面向连接的通信协议，是一个<strong>传输层协议</strong>，是一个<strong>双工协议</strong>，这就意味着客户端和服务端可以平等地发送、接收信息。通过<strong>三次握手</strong>建立连接，通讯完成时要通过<strong>四次挥手</strong>拆除连接，这个连接就是一个通道，由于TCP是面向连接的所以只能用于<strong>端到端</strong>（套接字到套接字）的通讯。TCP提供的是一种可靠的<strong>数据流</strong>服务，采用&quot;带重传的肯定确认&quot;技术来实现传输的可靠性。TCP还采用一种称为&quot;滑动窗口&quot;的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。<strong>面向字节流</strong>。虽然应用程序与TCP交互是一次一个大小不等的数据块，但<strong>TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系</strong>，例如，发送方应用程序交给发送方的TCP10个数据块，接收方的TCP可能只用收到的4个数据块字节流交付给上层的应用程序</p><h3 id="tcp的可靠性原理">tcp的可靠性原理</h3><p>可靠传输有如下两个特点:</p><ol><li>传输信道无差错,保证传输数据正确;</li><li>不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;</li></ol><p>首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，<strong>从而保证建立的传输信道是可靠的</strong>。</p><p>其次，TCP采用了连续ARQ协议（回退N(Go-back-N)；超时自动重传）来保证数据传输的正确性，使用<strong>滑动窗口协议</strong>来保证接方能够及时处理所接收到的数据，进行流量控制。</p><p>最后，TCP使用<strong>慢开始、拥塞避免、快重传和快恢复</strong>来进行拥塞控制，避免网络拥塞。</p><h3 id="TCP报文段"><strong>TCP报文段</strong></h3><p>TCP虽面向字节流，但传送的数据单元为报文段</p><p>报文段=首部+数据两部分</p><ol><li>首部前20个字符固定、后面有4n个字节是根据需而增加的选项</li><li>故 TCP首部最小长度 = 20字节</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-8011660d-24c8-460f-ac3d-b97ad9c99b13.png" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3779-20150904110054856-961661137.png" alt=""></p><p><strong>端口</strong>：</p><p>源端口号和目地端口各占16位两个字节，也就是端口的范围是<code>2^16=65535</code></p><p>另外1024以下是系统保留的，从1024-65535是用户使用的端口范围（一般常用的某些端口，比如5244,8080）</p><p><strong>seq序号</strong>：</p><p>占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。</p><p><strong>ack确认号</strong>：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。</p><p>B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1=500），B期望收到A下一个数据序号是501，B发送给A的确认报文段中把ack确认号置为501。</p><p><strong>数据偏移</strong>：</p><p>头部有可选字段，长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远。</p><p><strong>保留</strong>：保留今后使用的，标记为1</p><p><strong>控制位</strong>：由8个标志位构成，每个标志位表示一个控制功能。</p><p>其中比较重要的6个：</p><ul><li><strong>URG紧急指针标志</strong>，为1表示紧急指针有效，为0忽略紧急指针。</li><li><strong>ACK确认序号标志</strong>，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。</li><li><strong>PSH标志</strong>，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。</li><li><strong>RST重置连接标志</strong>，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。</li><li><strong>SYN同步序号</strong>，同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。。</li><li><strong>FIN终止标志</strong>，用于释放连接，为1时表示发送方没有发送了。</li></ul><p><strong>窗口</strong>：滑动窗口的大小，用来告知发送端接受端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。</p><p><strong>校验和</strong>：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。</p><p><strong>紧急指针</strong>：只有控制位中的URG为1时才有效，指出本报文段中的紧急数据的字节数</p><p><strong>选项</strong>：其长度可变，定义其他的可选参数</p><h3 id="tcp的三次握手和三次挥手"><strong>tcp的三次握手和三次挥手</strong></h3><p><strong>三次握手</strong>：用来建立 TCP 连接，确保双方都准备好进行数据传输：</p><ol><li>客户端发送 SYN 请求，表示希望建立连接。</li><li>服务器回复 SYN-ACK，表示同意建立连接。</li><li>客户端发送 ACK 确认，连接建立成功。</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-f6a9438e-4eb8-4573-9ef5-30e07b8c31df.png" alt=""></p><p>详细的过程</p><p>第一次握手：客户端将TCP报文标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p><p>第二次握手：服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个序号值<code>seq=K</code>，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</p><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code>状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p><p>服务器发送完<strong>SYN－ACK</strong>包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的<strong>最大重传次数</strong>，系统将该连接信息从<strong>半连接队列</strong>中删除。</p><p>第三次握手：客户端收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><p><strong>全连接队列</strong>就是三次握手已经完成了，建立起的连接就会放到全连接队列里，队列满了就会出现丢包。</p><p>其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而<strong>第三次握手是可以携带数据</strong>的。</p><p>其中上面的ack和ACK不是同一个概念</p><ul><li>小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，<code>ack=seq+1</code>。</li><li>大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。</li></ul><p><strong>四次挥手</strong>：用来关闭连接，确保双方都完成数据的传输后才断开连接：</p><ol><li>客户端发送 FIN 请求，表示数据发送完毕，准备关闭连接。</li><li>服务器回复 ACK，确认收到客户端的关闭请求。</li><li>服务器发送 FIN 请求，表示服务器也准备关闭连接。</li><li>客户端回复 ACK，连接正式关闭。</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-4a5e455f-5cf8-47a6-8fe4-a4c83a445f77.png" alt=""></p><p>挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：</p><p>第一次挥手：Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入<code>FIN_WAIT_1</code>状态，这表示Client端没有数据要发送给Server端了。</p><p>第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入<code>FIN_WAIT_2</code>状态，Server端告诉Client端，我确认并同意你的关闭请求。</p><p>第三次挥手：Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入<code>LAST_ACK</code>状态。</p><p>第四次挥手：Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入<code>TIME_WAIT</code>状态，Server端收到Client端的ACK报文段以后，就关闭连接，此时，Client端等待<strong>2MSL</strong>的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</p><p><strong>MSL</strong>：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p><p>为什么要三次握手？</p><p>在只有两次&quot;握手&quot;的情形下，假设Client想跟Server建立连接，但是<strong>却因为中途连接请求的数据报丢失了</strong>，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被<strong>阻塞</strong>了，这种情形下<strong>Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据</strong>…问题就在这里，**Cient端实际上只有一次请求，而Server端却有2个响应，**极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，<strong>因而造成极大的资源浪费</strong>！所以，&quot;三次握手&quot;很有必要！</p><p>为什么要四次挥手？</p><p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是<strong>保证双方的一个合约的完整执行</strong>！</p><p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="Socket">Socket</h3><p>即套接字，是应用层 与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-eff20ef6-9d35-4075-8c53-ab52c7a46ac7.png" alt=""></p><p><code>Socket</code>不是一种协议，而是一个编程调用接口（<code>API</code>），属于传输层（主要解决数据如何在网络中传输）</p><p>对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信</p><h2 id="upd">upd</h2><p><strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</strong></p><p>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p><p>每个UDP报文分UDP报头和UDP数据区两部分。报头由<strong>四个16位长</strong>（2字节）字段组成，分别说明该报文的<strong>源端口、目的端口、报文长度以及校验值</strong>。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li>（1）源端口号；</li><li>（2）目标端口号；</li><li>（3）数据报长度；</li><li>（4）校验值。</li></ul><p><strong>运输层提供应用进程之间的逻辑通信</strong>，运输层之间的通信并不是真正在两个运输层之间直接传输数据。是端对端之间的应用进程传输</p><p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p><p>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</p><h2 id="upd和tcp-ip协议的特点对比">upd和tcp/ip协议的特点对比</h2><p>UDP 的主要特点是 ① <strong>无连接</strong> ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）<strong>upd是不可靠的</strong></p><p>TCP 的主要特点是 ① <strong>面向连接</strong> ② 每一条 TCP 连接只能是一对一的 ③ 提供<strong>可靠</strong>交付 ④ 提供全双工通信 ⑤ 面向字节流</p><h2 id="dns">dns</h2><p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，<strong>可以简单地理解为将URL转换为IP地址</strong>。<strong>域名是由圆点分开一串单词或缩写组成的</strong>，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。</p><p>我们可以通过windows的ping命令来查找域名所对应的ip地址</p><h3 id="dns解析">dns解析</h3><p>A记录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义www.example.com的ip地址</span><br><span class="line">www.example.com.     IN     A     139.18.28.5;</span><br></pre></td></tr></table></figure><p><code>www.example.com</code> 是要解析的域名。</p><p>A 是记录的类型，A 记录代表着这是一条用于解析 IPv4 地址的记录。</p><p>从这条记录可知，<code>www.example.com</code>的 IP 地址是 139.18.28.5。</p><p>CNAME记录：</p><p>CNAME用于<strong>定义域名的别名</strong>，如下面这条 DNS 记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义www.example.com的别名</span><br><span class="line">a.example.com.          IN     CNAME   b.example.com.</span><br></pre></td></tr></table></figure><p>这条 DNS 记录定义了 <code>a.example.com</code> 是 <code>b.example.com</code> 的别名。</p><p>用户在浏览器中输入 <code>a.example.com</code> 时候，通过 DNS 查询会知道 <code>a.example.com</code> 是 <code>b.example.com</code> 的别名，因此需要实际 IP 的时候，会去拿 <code>b.example.com</code> 的 A 记录。</p><p>当你想把一个网站迁移到新域名，旧域名仍然保留的时候；还有当你想将自己的静态资源放到 CDN 上的时候，CNAME 就非常有用。</p><p>AAAA记录：</p><p>A 记录是域名和 IPv4 地址的映射关系。和 A 记录类似，AAAA 记录则是域名和 IPv6 地址的映射关系。</p><p>MX记录：</p><p>MX 记录是邮件记录，用来描述邮件服务器的域名。</p><p>比如说，发送一封邮件到 <code>xiaoming@xiaoflyfish.com</code>，那么如何知道哪个 IP 地址是邮件服务器呢？</p><p>这个时候就可以用到下面这条 MX 记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN MX mail.xiaoflyfish.com</span><br></pre></td></tr></table></figure><p><code>mail.xiaoflyfish.com</code> 的 IP 地址可以通过查询 <code>mail.xiaoflyfishcom </code>的 A 记录和 AAAA 记录获得。</p><p>NS记录：</p><p>NS记录是描述 DNS 服务器网址。从 DNS 的存储结构上说，Name Server 中含有权威 DNS 服务的目录。</p><p>也就是说，NS 记录指定哪台 Server 是回答 DNS 查询的权威域名服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.com.     IN      NS      ns1.a.com.</span><br><span class="line">a.com.     IN      NS      ns2.a.com.</span><br></pre></td></tr></table></figure><p>当解析 <code>a.com</code> 地址时，我们看到 <code>a.com</code> 有两个 NS 记录，所以确定最终 <code>a.com</code> 的记录在 <code>ns1.a.com</code> 和 <code>ns2.a.com</code> 上。</p><p>从设计上看，ns1 和 ns2 是网站 <code>a.com</code> 提供的智能 DNS 服务器，可以提供负载均衡、分布式 Sharding 等服务。</p><p>比如当一个北京的用户想要访问 <code>a.com</code> 的时候，ns1 看到这是一个北京的 IP 就返回一个离北京最近的机房 IP。</p><p>上面代码中 <code>a.com</code> 配置了两个 NS 记录。</p><p>通常 NS 不会只有一个，这是为了保证高可用，一个挂了另一个还能继续服务。</p><p>通常数字小的 NS 记录优先级更高，也就是 ns1 会优先于 ns2 响应。</p><p>配置了上面的 NS 记录后，如果还配置了 <code>a.com</code> 的 A 记录，那么这个 A 记录会被 NS 记录覆盖。</p><h2 id="nat">nat</h2><p>NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将<strong>私有</strong>（保留）地址转化为<strong>合法IP地址</strong>的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><h2 id="dhcp">dhcp</h2><p>DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用<strong>UDP协议工作</strong>，主要有两个用途：<strong>给内部网络或网络服务供应商自动分配IP地址</strong>，<strong>给用户或者内部网络管理员作为对所有计算机作中央管理的手段</strong>。</p><h2 id="http">http</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><h3 id="常见的http方法">常见的http方法</h3><p><strong>GET</strong>：请求服务器返回指定的资源（例如网页）。是从服务器上获取资源，传送的数据量小，不能大于2kb。</p><p><strong>POST</strong>：向服务器提交数据（例如表单数据）。向服务器提交资源，传送的数据量较大，一般默认为不受限制。</p><p>GET请求与Post请求区别：</p><ol><li>GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到body中，在url 中不可见。</li><li>请求的url有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如IE浏览器对 URL的最大限制为<strong>2083</strong>个字符（2kb），如果超过这个数字，提交按钮没有任何反应，因为GET请求的参数是添加到URL中，所以GET请求的URL的长度限制需要将请求参数长度也考虑进去。而POST请求不用考虑请求参数的长度。</li><li><strong>GET</strong>请求产生<strong>一个</strong>数据包; <strong>POST</strong>请求产生<strong>2个</strong>数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为GET没有请求体，所以就发送一个数据包，而POST包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。</li><li>GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>GET是幂等的，而POST不是(幂等表示执行相同的操作，结果也是相同的)</li><li>GET是获取数据，POST是修改数据</li></ol><p><strong>PUT</strong>：更新资源。</p><p><strong>DELETE</strong>：删除资源。</p><p><strong>CONNECT</strong>:HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p><p><strong>OPTIONS</strong>:允许客户端查看服务器的性能。</p><p><strong>TRACE</strong>:回显服务器收到的请求，主要用于测试或诊断。</p><p><strong>PATCH</strong>:是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p><p>根据http规范,get用于信息获取，应该是<strong>安全的</strong>和<strong>幂等的</strong></p><ul><li>所谓 <strong>安全的</strong> 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</li><li><strong>幂等</strong> 的意味着对同一URL的多个请求应该返回同样的结果。</li></ul><h3 id="http状态码">http状态码</h3><p>状态码由三位数字构成，第一位定义响应的类别</p><p><strong>1xx</strong>：代表成功表示请求以接收，继续处理</p><p>HTTP/1.1加入了一个新的状态码100。</p><p>客户端事先发送一个只带头域的请求，<strong>如果服务器因为权限拒绝了请求，就回送响应码401</strong>（Unauthorized）；</p><p><strong>如果服务器接收此请求就回送响应码100</strong>，客户端就可以继续发送带实体的完整请求了。</p><p>100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p><p><strong>2xx</strong>：成功，表示请求已经被成功接收、理解、接受，例如 200 OK 表示请求成功。</p><ul><li>200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</li><li>204 No Content 也是常见的成功状态码，与 200 OK 基本相同，<strong>但响应头没有 body 数据。</strong></li><li>206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示<strong>响应返回的 body 数据并不是资源的全部</strong>，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><strong>3xx</strong>：重定向，例如 301 Moved Permanently 表示资源已永久移动。</p><ul><li><p>301 Moved Permanently 表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。</p></li><li><p>302 Moved Permanently 表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。</p><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p></li><li><p>304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，用于缓存控制。</p></li></ul><p><strong>4xx</strong>：客户端发送的<strong>报文有误</strong>，例如 404 Not Found 表示请求的资源不存在。</p><ul><li>400 Bad Request表示客户端请求的报文有错误。</li><li>401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden表示<strong>服务器禁止访问资源</strong>，并不是客户端的请求出错。</li><li>404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><strong>5xx</strong>：状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，服务器错误，例如 500 Internal Server Error 表示服务器发生错误。</p><ul><li>501 Not Implemented 表示客户端请求的功能还不支持。</li><li>502 Bad Gateway 通常是服务器作为<strong>网关或代理</strong>时返回的错误码，表示服务器自身工作正常，访问<strong>后端服务器</strong>发生了错误。</li><li>503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。</li><li>504 Gateway Timeout：<strong>网关超时</strong>，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</li></ul><h3 id="host字段">host字段</h3><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.0</span><br></pre></td></tr></table></figure><p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p><strong>服务器应当支持 Host 头字段</strong>，用于处理多个虚拟主机共享同一 IP 地址的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><p>在这个请求中，<code>Host: www.example.com</code> 告诉服务器，该请求是针对 <code>www.example.com</code> 这个主机的，即便该服务器托管多个网站（如 <code>example.net</code>、<code>test.com</code>），它也可以正确解析请求。</p><p>此外，服务器应该接受以绝对路径标记的资源请求。</p><p>HTTP/1.1 允许请求中使用<strong>绝对 URI（absolute URI）</strong>，即完整 URL，包括协议、主机名和路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.example.com/index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><h3 id="https和http的区别">https和http的区别</h3><p>HTTPS 在 HTTP 上加入了 SSL/TLS 协议，通过<strong>加密保护数据的机密性和完整性</strong>，防止中间人攻击。</p><p>https更加安全，对搜索引擎更友好</p><p>其中http默认为80port，https默认443port</p><p>https基于<strong>传输层</strong>，http基于<strong>应用层</strong></p><p>https在浏览器显示绿色安全锁，http则没有</p><h3 id="请求报文">请求报文</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-3c00598c-43c2-44cd-96c6-ee4d40b97abd.png" alt=""></p><p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p><p><strong>常见的HTTP报文头属性</strong></p><ul><li><p>Accpet</p><p>告诉服务端，客户端接收什么类型的响应</p></li><li><p>Referer</p><p>表示这是请求是从哪个URL进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的Referer就是：<a href="https://javabetter.cn/cs/www.baidu.com">www.baidu.com</a></p></li><li><p>Cache-Control</p><p>对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置</p></li><li><p>Accept-Encoding</p><p>这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)</p><p>例如:<code>Accept-Encoding:gzip, deflate</code>(这两种都是压缩格式)</p></li><li><p>Host</p><p>指定要请求的资源所在的主机和端口</p></li><li><p>User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称</p></li><li><p>Connection</p></li></ul><p>​决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。</p><ul><li><p>持久连接，事务完成后不关闭网络连接 ：<code> Connection: keep-alive</code></p></li><li><p>非持久连接，事务完成后关闭网络连接： <code>Connection: close</code></p></li></ul><h3 id="响应报文">响应报文</h3><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-58884113-14dc-4cca-a63e-3320f31a4da5.png" alt=""></p><p>响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)</p><ul><li><p>Cache-Control</p><p>响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存</p></li><li><p>ETag</p><p>表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变</p></li><li><p>Location</p><p>在重定向中或者创建新资源时使用</p></li><li><p>Set-Cookie</p><p>服务端可以设置客户端的cookie</p></li></ul><h2 id="ssl-tls">ssl/tls</h2><p>SSL（Secure Sockets Layer，安全套接字层）和 TLS（Transport Layer Security，传输层安全协议）是用于<strong>保障网络通信安全</strong>的加密协议。TLS 是 SSL 的后续版本，TLS 1.0 基于 SSL 3.0 发展而来，目前<strong>TLS 已经取代 SSL</strong>，最新版本是 <strong>TLS 1.3</strong>。</p><p>作用：</p><p><strong>加密</strong>：防止数据被窃听，确保传输的机密性。</p><p><strong>完整性</strong>：防止数据被篡改，确保数据完整性。</p><p><strong>身份验证</strong>：通过证书验证服务器（可选客户端）身份，防止中间人攻击。</p><h3 id="工作流程">工作流程</h3><p><strong>客户端hello</strong></p><p>客户端向服务器发送 <code>ClientHello</code> 消息，包含：</p><ul><li>支持的 TLS 版本（如 TLS 1.2、TLS 1.3）</li><li>支持的加密算法（如 AES、RSA、ECDHE 等）</li><li>一个随机数（用于后续密钥生成）</li></ul><p><strong>服务器hello</strong></p><ul><li><p>服务器响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerHello</span><br></pre></td></tr></table></figure><p>消息，包含：</p><ul><li>选定的 TLS 版本和加密算法</li><li>服务器证书（包含公钥）</li><li>一个随机数</li></ul></li></ul><p><strong>密钥交换</strong>：</p><ul><li>TLS 1.2 及更早版本：<ul><li>服务器的证书中包含公钥，客户端使用该公钥加密一个随机密钥并发送给服务器（RSA 密钥交换）。</li><li>也可使用椭圆曲线 Diffie-Hellman（ECDHE）生成共享密钥。</li></ul></li><li>TLS 1.3（优化握手）：<ul><li>直接使用 ECDHE 进行密钥交换，减少握手步骤，提高安全性。</li></ul></li></ul><p><strong>证书验证：</strong></p><p>客户端验证服务器证书是否合法（CA 颁发、未过期等）。</p><p>可选地，服务器也可以要求客户端提供证书进行身份验证（双向 TLS）。</p><p><strong>对称密钥生成：</strong></p><p>双方根据交换的随机数和密钥交换算法，生成会话密钥。</p><p>后续数据通信使用 <strong>对称加密算法</strong>（如 AES）加密，提高效率。</p><p><strong>安全通信：</strong></p><p>双方交换 <code>Finished</code> 消息，表示握手完成。</p><p>之后所有通信数据都使用协商出的密钥进行加密传输。</p><p><strong>使用场景</strong></p><p>HTTPS（安全网站访问）</p><p>邮件加密（SMTP、IMAP、POP3）</p><p>VPN 连接</p><p>安全的消息传输（如 WhatsApp、Telegram）</p><h2 id="ftp">ftp</h2><p>FTP（File Transfer Protocol，文件传输协议）是一种用于在网络上传输文件的协议。</p><p>FTP 允许用户从一台计算机（客户端）向另一台计算机（服务器）<strong>上传或下载文件</strong>。</p><p>流程：</p><ul><li>客户端连接到服务器的 <strong>21</strong> 端口（默认的控制连接端口）。</li><li>服务器返回状态码 220，表示服务已就绪。</li><li>客户端发送用户名（USER 命令），服务器返回 331，表示需要密码。</li><li>客户端发送密码（PASS 命令），服务器返回 230，表示登录成功。</li></ul><p>文件传输分为两个模式</p><p>一个是主动模式:服务器主动连接到客户端的数据端口。</p><ul><li>客户端发送 PORT 命令，告知服务器自己的 IP 地址和数据端口。</li><li>服务器连接到客户端的数据端口，开始传输文件。</li></ul><p>另一个是被动模式：客户端连接到服务器的数据端口。</p><ul><li>客户端发送 <strong>PASV</strong> 命令，请求进入被动模式。</li><li>服务器返回自己的 IP 地址和数据端口。</li><li>客户端连接到服务器的数据端口，开始传输文件。</li></ul><p>ftp自己本身是并不安全的，因为传输过程中使用明文传输用户名和密码等，所以出现了替代品</p><ul><li><strong>SFTP</strong>：基于 SSH 的文件传输协议，加密传输数据。</li><li><strong>FTPS</strong>：基于 SSL/TLS 的 FTP，加密传输数据。</li></ul><h2 id="ssh">ssh</h2><p>SSH（Secure Shell，安全外壳协议）是一种用于安全远程登录和其他网络服务的加密协议。</p><p>SSH 通过加密通信来保护数据在传输过程中的安全性，广泛应用于系统管理、文件传输和远程命令执行等场景。</p><p>流程：</p><ul><li>客户端连接到服务器的 <strong>22</strong> 端口（默认的 SSH 端口）。</li><li>服务器发送自己的公钥给客户端。</li><li>客户端验证服务器公钥（通常通过已知的主机密钥指纹）。</li><li>客户端和服务器协商加密算法（如 AES、RSA 等）。</li><li>客户端生成一个会话密钥，用服务器的公钥加密后发送给服务器。</li><li>双方使用会话密钥加密后续通信。</li></ul><h2 id="smtp">smtp</h2><p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一种用于发送电子邮件的网络协议。</p><p>SMTP 是互联网上电子邮件传输的核心协议之一，负责将邮件从发送方传递到接收方的邮件服务器。</p><p><strong>发送邮件和传递邮件</strong></p><p>连接建立：</p><ul><li>户端连接到服务器的 25 端口（默认的 SMTP 端口）。</li><li>服务器返回状态码 220，表示服务已就绪。</li><li>客户端发送 HELO 或 EHLO 命令，告知服务器自己的域名。</li><li>服务器返回状态码 250，表示命令成功。</li></ul><p>smtp本身也是不安全的，因为使用过程中也是使用明文传输。可以使用下面的来代替</p><ul><li><strong>STARTTLS</strong>：将明文连接升级为加密连接，使用 TLS/SSL 加密数据。</li><li><strong>SMTP AUTH</strong>：通过身份验证机制（如 PLAIN、LOGIN）验证用户身份。</li></ul><h2 id="数字签名">数字签名</h2><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改</p><p>数字签名校验数据的完整性</p><p>数字签名有两种功效：</p><ul><li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li><li>数字签名能确定消息的完整性，证明数据是否未被篡改过。</li></ul><p>将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者</p><p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。</p><p>如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p><h2 id="cookie和session">cookie和session</h2><p>Session 是<strong>基于Cookie 实现</strong>的另一种记录服务端和客户端会话状态的机制。</p><p>Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。</p><p>Session的认证过程：</p><ol><li>客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID</li><li>客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名</li><li>当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的 Session，如果有对应的 Session 则通过，继续执行请求，否则就中断</li></ol><p><strong>Cookie和Session的区别</strong></p><ol><li>安全性，因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态</li><li>适用性，Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据</li><li>有效期，Cookie 可以设置任意时间有效，而 Session 一般失效时间短</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/23/net2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English二月篇</title>
      <link>https://blog.tokenlen.top/2025/02/01/en6/</link>
      <guid>https://blog.tokenlen.top/2025/02/01/en6/</guid>
      <pubDate>Fri, 31 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;每日一话+单词遗忘表2.1&lt;/h1&gt;
&lt;p&gt;The more you experience and appreciate the goodness of life, the more there is to be lived.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pearl</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>每日一话+单词遗忘表2.1</h1><p>The more you experience and appreciate the goodness of life, the more there is to be lived.</p><ul><li>pearl 珍珠</li><li>peasant 农民</li><li>peculiar 特殊的</li><li>pedestrian 步行者</li><li>peer 凝视</li><li>penalty 处罚</li><li>penetrate 刺入</li><li>perhaps 也许</li><li>peril 危险</li><li>persevere 坚持</li><li>persist 持续</li><li>perspective 远景</li><li>persuade 说服</li></ul><h1>每日一话+单词遗忘表2.2</h1><p>Your generation has come of age facing a challenge like no other generation before you.</p><ul><li>pessimism 悲观的</li><li>petroleum 石油</li><li>phase 相位</li><li>phrase 成语</li><li>pile 堆</li><li>pillar 柱子</li><li>pinch 捏</li></ul><h1>每日一话+单词遗忘表2.3</h1><p>Don’t try to win a friend by presenting gifts.</p><ul><li>pipe 烟斗</li><li>pistol 手枪</li><li><strong>plague</strong> 瘟疫</li><li>implicit 暗示的</li><li><strong>platform</strong> 月台</li><li>pledge 发誓</li><li>inflate 使充气</li><li>plough 耕</li><li>plunge 投入</li><li><strong>plural</strong> 复数的</li></ul><h1>每日一话+单词遗忘表2.4</h1><p>Sometimes I have thought it would be an excellent rule to live each day as if we should die tomorrow.</p><ul><li>politics 政治学</li><li>pond 池塘</li><li>pool 水池</li><li>portion 部分</li><li>pause 暂停</li></ul><h1>每日一话+单词遗忘表2.5</h1><p>The best preparation for good work tomorrow is to do good work today.</p><ul><li>postpone 使。。延期</li><li>pour 倾泻</li><li>poverty 贫困</li><li>powder 火药</li><li>practical 明智的</li><li>praise 称赞</li><li><strong>preach</strong> 说教</li><li>precaution 预防</li><li>precise 精确的</li><li><strong>preface</strong> 前言</li><li>prejudice 成见</li><li>preliminar 初步的</li><li>premier 第一的</li><li>prescribe 开药方</li></ul><h1>每日一话+单词遗忘表2.6</h1><p>As selfishness and complaint cloud the mind, so love with its joy clears and sharpens the vision.</p><ul><li>preserve 保护</li><li><strong>prevail</strong> 盛行</li><li>priest 牧师</li><li>prince 王子</li><li>principal 主要的</li><li>principle 原则</li><li>prior 先前的</li><li>privilege 特权</li><li>conceal 隐藏</li></ul><h1>每日一话+单词遗忘表2.7</h1><p>If you don’t design your own life plan, chances are you’ll fall into someone else’s. And guess what they might have planned for you? Not much.</p><ul><li>principal 本金</li><li>pirate 海盗</li><li>contempt 轻视</li><li>procession 队列</li><li>procliam 宣称</li><li>contaminate 污染</li><li>proficient 精通的</li><li>profound 深度的</li><li>prominemt 显著的</li><li><strong>prompt</strong> 敏捷的</li><li>proof 证明</li><li>proportion 部分</li><li>prose 散文</li><li>protein 蛋白质</li><li>constitution 宪法</li></ul><h1>每日一话+单词遗忘表2.8</h1><p>Keep your friends close, but your enemies closer.</p><ul><li>protest 抗议</li><li>proverb 谚语</li><li>provoke 激怒</li><li>pulse 脉搏</li><li>punch 按键</li><li>purchase 购买</li><li>pure 纯的</li><li>purse 钱包</li><li>pursue 追求</li></ul><h1>每日一话+单词遗忘表2.11</h1><p>We delight in the beauty of the butterfly, but rarely admit the changes it has gone through to achieve that beauty.</p><ul><li>quarrel 吵架</li><li>quiz 考察</li><li><strong>quota</strong> 配额</li><li>quote 引述</li><li>rack 行李架</li><li><strong>radical</strong> 根本的</li><li>rag 破布</li><li>raid 袭击</li></ul><h1>每日一话+单词遗忘表2.12</h1><p>I look for her in vain. When all at once I turn my head, I find her there where lantern light is dimly shed.</p><ul><li>rapid 快速的</li><li>realistic 现实的</li><li>realm 领域</li><li><strong>reap</strong> 收割</li><li>rear 后面的</li><li>rebel 造反</li><li>recite 背诵</li><li>reckon 猜想</li></ul><h1>每日一话+单词遗忘表2.13</h1><p>It never will rain roses. When we want to have more roses we must plant trees.</p><ul><li>recognize 承认</li><li><strong>recreation</strong> 娱乐</li><li>recruit 招聘</li><li><strong>refine</strong> 精炼</li><li>refrain 制止</li><li>reform 改革</li><li>counterpart 地位相当的</li><li>rebel 反抗分子</li><li>intangible 难以琢磨的</li><li>reckon 猜想</li><li>proficient 精炼的</li><li>relative 相对的</li><li>instalment 一部分</li></ul><h1>每日一话+单词遗忘表2.14</h1><p>The love that lasts the longest is the love that is never returned.</p><ul><li>relay 转播</li><li>relevant 有关的</li><li>religion 宗教</li><li>reluctant 不情愿的</li><li>remedy 药品</li><li>render 提出</li><li>renovate 革新</li></ul><h1>每日一话+单词遗忘表2.15</h1><p>The worst tragedy for a poet is to be admired through being misunderstood.</p><ul><li>rescue 营救</li><li>resent 怨恨</li><li>respective 各自的</li><li>retail 零售</li><li>reunite 使…结合</li><li>loophole 弹孔</li></ul><h1>每日一话+单词遗忘表2.16</h1><p>We soon believe what we desire.</p><ul><li>reveal 揭示</li><li>revenue 税收</li><li>revise 修订</li><li>rhythm 节奏</li><li>riddle 解密</li><li>ridicule 嘲笑</li><li>rifle 步枪</li><li>riot 暴乱</li><li>rival 竞争者</li><li>roar 吼叫</li><li>procliam 宣布占领</li></ul><h1>每日一话+单词遗忘表2.17</h1><p>Gather sweet blossoms while you may; And not the twig devoid of flowers!</p><ul><li>rob 抢劫</li><li>rod 棒</li><li>rouse 醒来</li><li>route 路线</li><li>rubber 橡胶</li><li>ruin 毁灭</li><li>rumor 谣言</li></ul><h1>每日一话+单词遗忘表2.18</h1><p>I am no bird; and no net ensnares me: I am a free human being with an independent will.</p><ul><li>sacrifice 牺牲</li><li>saint 圣徒</li><li>sausage 香肠</li><li>scandal 传闻</li></ul><h1>每日一话+单词遗忘表2.19</h1><p>I cannot teach anybody anything, I can only make them think</p><ul><li>scarce 缺少</li><li>scatter 分散的</li><li>scheme 计划</li><li>scissors 剪刀</li><li>scold 责骂</li><li>scount 侦察机</li><li>scratch 抓痕</li><li>screw 旋</li></ul><h1>每日一话+单词遗忘表2.20</h1><p>Tenderness and kindness are not signs of weakness and despair, but manifestations of strength and resolution.</p><ul><li>sector 部门</li><li>secure 安全</li><li>seminar 讨论会</li><li>sentence 宣判</li><li>separate 分局</li><li>servant 仆人</li><li>naughty 顽皮的</li></ul><h1>每日一话+单词遗忘表2.21</h1><p>Morality is not really the doctrine of how to make ourselves happy but of how we are to be worthy of happiness.</p><ul><li>sew 缝上</li><li>sharp 急促的</li><li>shave 剃</li><li>shed 棚子</li><li>sheeer 陡峭的</li><li>shelter 避难所</li></ul><h1>每日一话+单词遗忘表2.22</h1><p>The best way to find out if you can trust somebody is to trust them.</p><ul><li>shiver 颤抖</li><li>shrimp 虾</li><li>shrug 耸肩</li><li>siege 围攻</li></ul><h1>每日一话+单词遗忘表2.23</h1><p>Sometimes you have to travel a long way to find what is near.</p><ul><li>script 轨迹</li><li>silk 蚕丝</li><li>sin 过失</li><li>sip 抿</li><li>situation 形式</li><li>skate 滑冰</li><li>skeleton 骨架</li></ul><h1>每日一话+单词遗忘表2.24</h1><p>The pain of parting is nothing to the joy of meeting again.</p><ul><li>sketch 素描</li><li>skyscraper 摩天大楼</li><li>slap 拍击</li><li>sleeve 袖子</li><li>slender 苗条的</li><li>slide 滑动</li><li>slim 苗条的</li><li>slogan 标语</li><li>smash 打碎</li></ul><h1>每日一话+单词遗忘表2.25</h1><p>A fool thinks he is clever, the wise man knows himself to be a fool.</p><ul><li>soar 高飞</li><li>soil 土壤</li><li>solemn 庄严的</li><li>sophisticated 老练的</li><li>sorrow 悲伤的</li><li>spacecraft 宇宙飞船</li><li>spade 铁锹</li><li>spare 备用的</li><li>sparkle 发火花</li></ul><h1>每日一话+单词遗忘表2.26</h1><p>A man’s reading program should be as carefully planned as his diet, for that too is food, without which he cannot grow mentally.</p><p>今天四级出分了，成功的没过。哎下次再考吧。</p><ul><li>species 物种</li><li>specific 特殊的</li><li>specify 指定</li><li>speculate 思索</li><li>sphere 范围</li><li>spill 溢出</li><li>spite 恶意</li><li>splash 溅</li><li>spoil 溺爱</li><li>spot 斑点</li></ul><h1>每日一话+单词遗忘表2.27</h1><p>A man can fail many times, but he isn’t a failure until he begins to blame somebody else.</p><ul><li><strong>spray</strong> 喷雾</li><li>spur 马刺</li><li>spy 侦察</li><li>squeeze 挤压</li><li>stable 马厩</li><li>stadium 体育场</li><li>stain 玷污</li><li>staple 订书钉</li><li>startle 吓一跳</li></ul><h1>每日一话+单词遗忘表2.28</h1><p>Many people waste a whole life waiting for the chance to meet their desire.</p><ul><li>stem 茎</li><li>stimulate 刺激</li><li>sting 刺痛</li><li>stir 激起</li><li>stomach 胃</li><li>storey 楼层</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/02/01/en6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>毛泽东选集阅读体会&amp;杂谈</title>
      <link>https://blog.tokenlen.top/2025/01/26/mao1/</link>
      <guid>https://blog.tokenlen.top/2025/01/26/mao1/</guid>
      <pubDate>Sat, 25 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;2025.1.26&lt;/h1&gt;
&lt;p&gt;在革命的过程中，我们要注意谁是我们的朋友。谁是我们的敌人，团结我们能所团结的，打到我们的敌人。&lt;/p&gt;
&lt;p&gt;地主阶级是国际资产主义的附庸，特别是大地主阶级和大买办阶级，他们是完全靠着国际资本主义，来压榨底层的百姓的。小地主阶级和小买办</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>2025.1.26</h1><p>在革命的过程中，我们要注意谁是我们的朋友。谁是我们的敌人，团结我们能所团结的，打到我们的敌人。</p><p>地主阶级是国际资产主义的附庸，特别是大地主阶级和大买办阶级，他们是完全靠着国际资本主义，来压榨底层的百姓的。小地主阶级和小买办阶级是可以团结的，给与他们扩大的实力，他们可以为革命所用。要团结一切可以团结的力量。</p><p>中产阶级代表跟小地主阶级类似，他们是矛盾的，他们是人数较少的。可以对他们进行团结，扩大他们的生产，扩大他们的力量，在革命的大旗下进行扩大化。进行革命化的特色改造。</p><p>小资产阶级或者说是无产阶级是我们革命的主力军，他们的力量是强大的，他们的力量是可以翻天覆地的。他们有很少或者没有生产资料，他们处于社会的最底层，其中有很大一部分人有很强的向上的力量，很强的革命的力量。我们要从他们之中去发展力量，积蓄力量，给大地主阶级和大买办阶级或者说是大官僚阶级沉重的打击。</p><h1>2025.1.27</h1><p>组织运动，农民是我国力量最大的，人数最多的阶层。这里的农民不单单是指农村户口的农民，而是指的是出生于农村，从农村长大。祖祖辈辈和土地和农村相关联的人。他们是任劳任怨的，不到迫不得已的的时候，是不会反抗的。他们自发的进行革命力量的组织的力量是弱小的，是没有把力量集中到一起的。</p><p>需要的革命的组织进行正确的领导，这就是农会。农会是从农民中来，到农民中去的。农会中的领导者是农民选举出来的，是农民阶级的代言人。他们领导农民的革命方向，代表着广大农民的利益。</p><h1>2025.1.29</h1><p>资本主义，或者说是资产阶级。他们在很久之前是社会的进步的力量，引导人们从封建主义到了资本主义，这是生产力发展的必然结果。但是资本是逐利的，资本是冒险的。他们很多会不思进取，开源节流，在经济形式不好的时候</p><p>，他们第一想到的就是节流，即降低工人的待遇。降低工人的工资，压榨工人。将工人的剩余价值剥削的更多。工人因为承担着养家糊口的责任，他们不能丢失这个工作，失去了这个工作他们无法生存。只能继续承担着资本的剥削。</p><p>资本在剥削之中会合并资本，大资本跟更大的资本进行结合。阶级实现了固化，普通人向上发展的道路被堵塞了，而资本或者说是特权阶级，一出生就拥有着百分之九十五的人一生都无法获得的生产资料。</p><p>在资本逐利的过程中，他们为了扩大生产，提高自己的影响力。他们会和官员也就是权力勾结起来，形成官商勾结体。官商勾结自古由来已久，大商人或者说是资本有钱，而官员们有权。官商勾结起来，就形成了一个即有权又又钱的利益集团。俗话说有钱有权可以做到世界上的一切事情，如果做不到就是钱还不够多，权还不够大。</p><h1>2025.1.31</h1><p>特权阶级也就是说的官僚阶级和资本他们一旦联合起来，形成一个利益集团。他们只会看着自己眼前的利益，不会把一分一毫的利益分享给其他的平民。利益集团会侵占国家利益，他们不会以国家利益为基础，将整个国家绑在他们的战车之上。整个国家都会变成他们的私有财产。然后在权力和钱财的追逐之下，政府其实就代表这些利益集团的集合利益。</p><h1>2025.2.6</h1><p>我们不能忘记民族矛盾，虽然民族矛盾可以算是阶级矛盾在具体方面的一种体现，按照托洛斯基的理念，或者说激进的马克思主义者的观念来说，国家和民族最终都要消亡的。但是这毕竟是千年可能都完不成的目标，可以说在近一百年这是不可能的。我们是中华民族，我们和日本人，是有着血海深仇的。这是绝对不可以忘掉了，一个甲子之前我们刚刚才把日本人赶出了中国。我们现在和日本人的矛盾是不可以忘却的，南京的三十万百姓惨案不可忘掉。不仅仅是日本人，有一个国家或者说是一个民族，对我们的伤害不亚于日本人，那就是俄罗斯。在特殊的历史条件下，大鹅是我们的朋友。但是我们和大鹅的血海深仇是不可以忘的。二战后期借着打击关东军的民意，侵略我国东北，我国东北人民遭受了巨大的灾难，机械等大型产业被掠夺，非常非常多的资源也被掠夺，更不要说侵占了我们那么多的土地，把我们的人民屠杀了许多。这个仇是不可以忘的！</p><h1>2025.2.12</h1><p>前前后后多少事，还得是将军说的对啊。文化工作者一定要有文化！</p><p>最近刘诗诗主演的电视剧《掌心》正在热播中，这个电视剧拍的怎么样我不敢说，但是以武周时期为蓝本的电视剧，派王子出去和亲实在是太不符合历史了，再说我们着一般说是皇子，一般不说王子。当时武则天他派的是他的一个侄子。根本称不上皇子。而电视剧虽然是里面那个也不是李唐的皇子，但他说的的确是王子和亲。编剧在改编的时候，能不能动点脑子，给抄错了。</p><p>所以说文化工作者要有文化，这句话果然是有大道理的啊。</p><h1>2025.2.13</h1><p>明天就是情人节，但是这个情人节值得是国外传过来的情人节，而我们中国自己的情人节是在农历的七月七，也就是我们常说的七夕。我们长久以来过的是这个情人节。传说这是牛郎织女相会的日子,鹊桥会出现，然后牛郎织女就可以通过鹊桥来相会。然后人们总是会在这个时候举办灯会，女子男子可以通过看灯会来寻找自己的另一半。但是如今，七夕大家都不过了，反而大家都去过国外传过来的情人节，我们自己的文化传统都丢失了。这就是文化入侵！这就是我们为什么要提高我们的文化自信力，我们的上千年的文化是比他们这些国外的蛮人只有近几百年的文化要强大的，我们要对我们的文化要有自信！</p><h1>2025.2.14</h1><p>四十年来家国，三千里地山河。凤阁龙楼连霄汉，玉树琼枝作烟萝，几曾识干戈。</p><p>一旦归为臣虏，沈腰潘鬓消磨。最是仓皇辞庙日，教坊犹奏别离歌，垂泪对宫娥。</p><p>最近又学了什么诗词啊~</p><p>不禁潸然泪下，一生转战三千里，流落异乡倍思亲。</p><h1>2025.2.15</h1><p>不管用什么方法，最终的目的都是社会主义。一个人无论今天穿男装还是女装，并不会影响实际性别。因为性别是由染色体决定的。许多修正主义者就是在这里歪曲了马克思主义道路。宣称的正大光明，实际就是在找借口，篡改和歪曲马克思主义的原则性问题。马克思主义当然需要探索和发展，但绝不是背叛无产阶级革命的探索与发展。如果是为了剥削者而进行发展，那这究竟是马克思主义的探索还是资本主义的探索呢？</p><p>在历史的长河之中，探索道路一定要选择对方向。无论你走的多远，方向错了，那走再多也白费。</p><p>世界上没有不透风的墙，无论在多么封闭的地方，终究最后消息会传出去。可能消息传着传着可能就变了味道。与其被人调侃，不如一开始就处在开放的时候。</p><h1>2025.2.16</h1><p>观史可以明智，世界上是没有新鲜事的。人类的所有，其实都是一个轮回。所有的事情都可以在历史上找到类似的事情，和与其对应的后果和解决方法。</p><p>所以历史是必须要看的，而且是必须要认真看的。</p><p>韩信自大自以为是汉朝离不开他，最后终究还是落个被杀的下场。哎</p><h1>2025.2.18</h1><p>普天之下，莫非王土。率土之滨，莫非王臣。我们无论如何都不能放弃自己科技的发展，虽然国外的可能更加好用，更加便宜。但我们自身必须要有可以研究使用的能力。但是，研究研发不是一味的标榜自己是国产。国产不代表这是一个消费的标签。不能用国货的名义来消费消费者。这样可能一段时间内是比较有效的，但是长久来看，这是非常非常不利的。</p><h1>2025.2.19</h1><p>天行健，君子以自强不息。我们需要在我们的传统文化中，汲取优秀美好的力量，我们上下五千年的历史是悠久的，可以说是文化是没有断绝过的。是非常有利的，我们古人上下总结的文化，是可以实实在运用到我们的生活和实践中的。这就是中国文化的魅力，这就是历史长的好处。我们应该不能放弃我们的文化，不能被外来文化完全入侵了。无论是好的还是坏的，他们都不能改变我们中国的文化！</p><h1>2025.2.22</h1><p>至此天下唯有大秦，我们中华自打秦朝以来，就有着必须大一统的心念存在我们心中。现在我们的领土并不完整，我们的许多自古以来的土地被他人占据，这些土地是我们必须要拿回来的，要不然我们就算不上大一统。比如虎踞夷州岛，比如我们的藏南地区，比如外西北，外东北，我们的第一大岛库页岛。比如我们的三宣六慰，我们的旧港都是我们自古以来的领土。这些是必须一定要收回的！</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/Marxists/">Marxists</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%AF%9B%E9%80%89/">毛选</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/26/mao1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络-七层体系结构</title>
      <link>https://blog.tokenlen.top/2025/01/13/net1/</link>
      <guid>https://blog.tokenlen.top/2025/01/13/net1/</guid>
      <pubDate>Sun, 12 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础引入&lt;/h1&gt;
&lt;p&gt;两个计算机设备想要通信，可以用一根线连接起来，两台设备使用电信号传播数据&lt;/p&gt;
&lt;p&gt;如果都是用一根线连接两台设备的话，所需要的线数C等于&lt;br&gt;
$$&lt;br&gt;
C=(n-1)n/2&lt;br&gt;
$$&lt;br&gt;
但这样不太理想&lt;/p&gt;
&lt;p&gt;所以我们</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础引入</h1><p>两个计算机设备想要通信，可以用一根线连接起来，两台设备使用电信号传播数据</p><p>如果都是用一根线连接两台设备的话，所需要的线数C等于<br>$$<br>C=(n-1)n/2<br>$$<br>但这样不太理想</p><p>所以我们可以使用一个hub就是一个集线器</p><p>比如</p><p>设备1可以通过<strong>hub</strong>然后转发给设备3，但这样的话是群发，不太安全</p><p>而且只能单向的交流，也不太好</p><p>所以使用了<strong>交换机</strong>，使用<strong>mac值</strong>来区分设备</p><p>这个是全球唯一的</p><p>允许两台设备双向交流，也可以两台交换机来交换数据，这叫<strong>桥接网络</strong></p><p>内网这样是可以使用的，但是不能使用很多，因为交换机的存储mac地址的数量是有限的。</p><p><strong>路由器</strong>可以适用于网络的转发</p><p><strong>不同网络连接到路由器的ip叫做默认网关</strong></p><p><strong>ip</strong>只是一个过程使用，最后还是使用<strong>mac地址</strong>来转发数据</p><h1>概述</h1><h2 id="1-1基本术语">1.1基本术语</h2><p><strong>结点 （node）</strong>：网络中的结点可以是计算机，集线器，交换机或路由器等。</p><p><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</p><p><strong>主机（host）</strong>：连接在因特网上的计算机。</p><p><strong>ISP（Internet Service Provider）</strong>：因特网服务提供者（提供商）。</p><p><img src="https://oss.javaguide.cn/p3-juejin/e77e26123d404d438d0c5943e3c65893~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>IXP（Internet eXchange Point）</strong>：互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p><p><strong>RFC(Request For Comments)</strong>：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</p><p><strong>广域网 WAN（Wide Area Network）</strong>：任务是通过长距离运送主机发送的数据。</p><p><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</p><p><strong>局域网 LAN（Local Area Network）</strong>：学校或企业大多拥有多个互连的局域网。</p><p><img src="https://oss.javaguide.cn/p3-juejin/eb48d21b2e984a63a26250010d7adac4~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>个人区域网 PAN（Personal Area Network）</strong>：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</p><p><strong>分组（packet ）</strong>：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</p><p><strong>存储转发（store and forward ）</strong>：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发 送的输出端口地址，然后将该包发送出去。</p><p><img src="https://oss.javaguide.cn/p3-juejin/addb6b2211444a4da9e0ffc129dd444f~tplv-k3u1fbpfcp-zoom-1.gif" alt=""></p><p><strong>带宽（bandwidth）</strong>：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</p><p><strong>吞吐量（throughput ）</strong>：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</p><h2 id="1-2知识点总结">1.2知识点总结</h2><p><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></p><p>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</p><p>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据段的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</p><p>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</p><p>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</p><p>这里介绍一下C/S模式和P2P模式：</p><p>C/S 模式是一种计算机网络通信架构，其中通信由客户端（Client）发起，请求服务，服务器（Server）响应并提供服务。</p><p>特点：</p><p><strong>集中管理</strong>：服务器通常拥有强大的计算和存储能力，负责集中管理资源和处理请求。</p><p><strong>固定角色</strong>：客户端负责发送请求，服务器负责响应。角色明确。</p><p><strong>典型应用</strong>：</p><ul><li>Web浏览器和Web服务器（HTTP/HTTPS通信）</li><li>数据库客户端与数据库服务器（如MySQL）</li></ul><p>服务器是里面的重中之重，服务器承担着接发消息和处理消息的功能。如果服务器瘫痪了，这个功能就可以说是完蛋了。</p><p>P2P 模式是一种网络通信架构，其中所有参与者（节点）既是服务的消费者（Client），又是服务的提供者（Server）。</p><p>特点：</p><p><strong>分布式管理</strong>：网络中的每个节点都可以直接通信，无需中央服务器。</p><p><strong>动态角色</strong>：节点既能发送请求，也能响应其他节点的请求。</p><p><strong>典型应用</strong>：</p><ul><li>文件共享系统（如BitTorrent）</li><li>区块链网络（如比特币、以太坊）</li></ul><p>p2p模式可以说是点对点模式，扩展性高，但是不太安全。</p><h3 id="对比总结"><strong>对比总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>C/S 模式</strong></th><th><strong>P2P 模式</strong></th></tr></thead><tbody><tr><td><strong>架构特点</strong></td><td>集中式架构</td><td>分布式架构</td></tr><tr><td><strong>节点角色</strong></td><td>固定（客户端和服务器）</td><td>动态（节点既是客户端又是服务器）</td></tr><tr><td><strong>适用场景</strong></td><td>Web服务、数据库查询</td><td>文件共享、区块链等分布式服务</td></tr><tr><td><strong>优势</strong></td><td>易管理、高效率</td><td>去中心化、高扩展性</td></tr><tr><td><strong>劣势</strong></td><td>单点故障、扩展性有限</td><td>资源协调和安全性挑战</td></tr></tbody></table><p><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></p><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</p><p><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></p><p><img src="https://oss.javaguide.cn/p3-juejin/acec0fa44041449b8088872dcd7c0b3a~tplv-k3u1fbpfcp-zoom-1.gif" alt=""></p><h1>物理层</h1><h2 id="2-1基本术语">2.1基本术语</h2><ol><li><strong>数据（data）</strong>：运送消息的实体。</li><li><strong>信号（signal）</strong>：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li><li><strong>码元（ code）</strong>：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li><li><strong>单工（simplex ）</strong>：只能有一个方向的通信而没有反方向的交互。</li><li><strong>半双工（half duplex ）</strong>：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</li><li><strong>全双工（full duplex）</strong>：通信的双方可以同时发送和接收信息。</li><li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li><li><strong>奈氏准则</strong>：在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li><li><strong>基带信号（baseband signal）</strong>：来自信源的信号。指没有经过调制的数字信号或模拟信号。</li><li><strong>带通（频带）信号（bandpass signal）</strong>：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li><li><strong>调制（modulation ）</strong>：对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li><li><strong>信噪比（signal-to-noise ratio ）</strong>：指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li><li><strong>信道复用（channel multiplexing ）</strong>：指多个用户共享同一个信道。（并不一定是同时）。</li><li><strong>比特率（bit rate ）</strong>：单位时间（每秒）内传送的比特数</li></ol><p><img src="https://oss.javaguide.cn/p3-juejin/5d9bf7b3db324ae7a88fcedcbace45d8~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>波特率（baud rate）</strong>：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</p><p><strong>复用（multiplexing）</strong>：共享信道的方法。</p><p><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong>：非对称数字用户线。</p><p><strong>光纤同轴混合网（HFC 网）</strong>：在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</p><h2 id="2-2知识点总结">2.2知识点总结</h2><p><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></p><ol><li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li><li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电气或电磁的表现。</strong></li><li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li><li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li><li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li><li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li><li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li><li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li></ol><p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状和尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能的各种可能事件的出现顺序）。</p><p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p><p><strong>常用的信道复用技术</strong></p><ol><li><strong>频分复用(FDM)</strong>：所有用户在同样的时间占用不同的带宽资源。</li><li><strong>时分复用（TDM）</strong>：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li><li><strong>统计时分复用 (Statistic TDM)</strong>：改进的时分复用，能够明显提高信道的利用率。</li><li><strong>码分复用(CDM)</strong>：用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li><li><strong>波分复用( WDM)</strong>：波分复用就是光的频分复用。</li></ol><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ADSL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p><h1>数据链路层</h1><h2 id="3-1基本术语">3.1基本术语</h2><p><strong>链路（link）</strong>：一个结点到相邻结点的一段物理链路。</p><p><strong>数据链路（data link）</strong>：把实现控制<strong>数据运输的协议</strong>的硬件和软件加到链路上就构成了数据链路。</p><p><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong>：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</p><p><strong>帧（frame）</strong>：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</p><p><strong>MTU（Maximum Transfer Uint ）</strong>：最大传送单元。帧的数据部分的的长度上限。</p><p><strong>误码率 BER（Bit Error Rate ）</strong>：在一段时间内，传输错误的比特占所传输比特总数的比率。</p><p><strong>PPP（Point-to-Point Protocol ）</strong>：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路</p><p><img src="https://oss.javaguide.cn/p3-juejin/6b0310d3103c4149a725a28aaf001899~tplv-k3u1fbpfcp-zoom-1.jpeg" alt=""></p><p><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong>：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。”</p><p><strong>网桥（bridge）</strong>：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</p><p><strong>交换机（switch ）</strong>：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</p><h2 id="3-2重要知识点总结">3.2重要知识点总结</h2><p>链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</p><p>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></p><p><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</p><p><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</p><p>PPPoE 是为宽带上网的主机使用的链路层协议</p><p><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></p><p>计算机与外接局域网通信需要通过<strong>通信适配器</strong>（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</p><p>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</p><p>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上的各站点平等地争用以太网信道</p><p>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</p><p>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</p><hr><h2 id="3-3补充问题">3.3补充问题</h2><p>数据链路层的点对点信道与广播信道的特点</p><ol><li><strong>点对点信道</strong>：<ul><li><strong>特点</strong>：数据在两个设备之间进行直接传输，通常不涉及多设备之间的干扰。信号只在发送端和接收端之间传输。</li><li><strong>协议</strong>：常用协议为<strong>PPP（Point-to-Point Protocol）</strong>。PPP是点对点协议，支持多种网络层协议。它提供了封装数据、认证、压缩以及错误检测功能。</li></ul></li><li><strong>广播信道</strong>：<ul><li><strong>特点</strong>：信号在多个设备间广播，所有连接到该信道的设备都能接收到传输的数据。需要控制如何解决多设备争用信道的问题。</li><li><strong>协议</strong>：常用协议为<strong>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）</strong>。CSMA/CD用于以太网，允许多个设备共享同一信道。它通过侦测信道是否空闲，避免冲突；如果发生冲突，设备会退避一段时间后重试。</li></ul></li></ol><p>数据链路层的三个基本问题</p><ol><li><strong>封装成帧</strong>：<ul><li>数据链路层将网络层传来的数据封装成帧，添加头部和尾部信息，如目标地址、源地址、帧校验序列（FCS）等。</li></ul></li><li><strong>透明传输</strong>：<ul><li>保证数据的传输不会受到链路中可能出现的特殊符号的影响（如数据流中的帧分隔符）。通过位填充等技术确保数据在链路上传输时的完整性和正确性。</li></ul></li><li><strong>差错检测</strong>：<ul><li>数据链路层通过CRC（循环冗余校验）等技术对数据进行差错检测，确保数据传输过程中没有发生错误。如果检测到错误，通常会丢弃该帧并要求重传。</li></ul></li></ol><hr><p>以太网的 MAC 层硬件地址</p><ul><li><strong>MAC地址</strong>（媒体访问控制地址）是网络适配器（如网卡）在局域网中的唯一标识符。它通常是由硬件生产商分配的 48 位地址，表示网络接口设备。MAC地址通常以16进制形式表示，如：<code>00:1A:2B:3C:4D:5E</code>。</li></ul><hr><p>适配器、转发器、集线器、网桥、以太网交换机的作用及适用场</p><ol><li><strong>适配器（网络适配器）</strong>：<ul><li><strong>作用</strong>：网络适配器（如网卡）用于连接计算机与网络，通过物理层传输数据。它提供了与网络进行数据通信的接口。</li></ul></li><li><strong>转发器</strong>：<ul><li><strong>作用</strong>：转发器用于在不同的网络之间进行数据转发，通常用于协议转换或将不同网络技术的设备连接起来。</li></ul></li><li><strong>集线器（Hub）</strong>：<ul><li><strong>作用</strong>：集线器是一个简单的网络设备，能够将信号广播到所有端口，适用于小型网络。但它不具备智能，仅用于物理层的信号传输。</li></ul></li><li><strong>网桥（Bridge）</strong>：<ul><li><strong>作用</strong>：网桥用于连接不同的局域网，能够根据MAC地址转发数据帧，从而分割流量，提高网络效率。网桥工作在数据链路层。</li></ul></li><li><strong>以太网交换机（Switch）</strong>：<ul><li><strong>作用</strong>：以太网交换机可以通过MAC地址来转发数据包，只将数据包发送到目标设备所在的端口，相比集线器，它能有效减少网络冲突并提高网络效率。它工作在数据链路层，具有一定的智能，能动态学习和维护MAC地址表。</li></ul></li></ol><h1>网络层</h1><h2 id="4-1基本术语">4.1基本术语</h2><p><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</p><p><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</p><p><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</p><p><strong>ICMP（Internet Control Message Protocol ）</strong>：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</p><p><strong>子网掩码（subnet mask ）</strong>：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p><p><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</p><p><strong>默认路由（default route）</strong>：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</p><p><strong>路由选择算法（Virtual Circuit）</strong>：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</p><h2 id="4-2重要知识总结">4.2重要知识总结</h2><p><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责</strong></p><p>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</p><p>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</p><p>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</p><p><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组</strong></p><p>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法在 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</p><p>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><p><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</p><p><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></p><p>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</p><h1>传输层</h1><h2 id="5-1基本术语">5.1基本术语</h2><p><strong>进程（process）</strong>：指计算机中正在运行的程序实体。</p><p><strong>应用进程互相通信</strong>：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</p><p><strong>传输层的复用与分用</strong>：复用指发送方不同的进程都可以通过同一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</p><p><strong>TCP（Transmission Control Protocol）</strong>：传输控制协议。</p><p><strong>UDP（User Datagram Protocol）</strong>：用户数据报协议</p><p><img src="https://oss.javaguide.cn/p3-juejin/b136e69e0b9b426782f77623dcf098bd~tplv-k3u1fbpfcp-zoom-1.png" alt=""></p><p><strong>端口（port）</strong>：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</p><p><strong>停止等待协议（stop-and-wait）</strong>：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</p><p><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p><p><strong>拥塞控制</strong>：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p><h2 id="5-2重要知识点总结">5.2重要知识点总结</h2><p><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></p><p><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></p><p>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供<strong>面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p><p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</p><p>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</p><p>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</p><p><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></p><p><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></p><p><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一地被通信两端的两个端点所确定。</strong></p><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p>TCP 报文段的前 20 个字节是固定的，其后有 40 字节长度的可选字段。如果加入可选字段后首部长度不是 4 的整数倍字节，需要在再在之后用 0 填充。因此，TCP 首部的长度取值为 20+4n 字节,最长为 60 字节。</p><p><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></p><ol><li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li><li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li><li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li><li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li><li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li></ol><h2 id="5-3补充重要知识">5.3补充重要知识</h2><p>端口和套接字的意义</p><p><strong>端口</strong>：端口是网络协议（如 TCP 或 UDP）中用于标识特定应用进程的数字。端口通常在 0 到 65535 之间，分为不同的范围：</p><p><strong>知名端口（0-1023）</strong>：通常分配给常见的服务（例如 HTTP 用端口 80，HTTPS 用端口 443）。</p><p><strong>注册端口（1024-49151）</strong>：用于不太常见的应用程序和服务。</p><p><strong>动态或私有端口（49152-65535）</strong>：通常由操作系统分配给临时连接。</p><p><strong>套接字</strong>：套接字（Socket）是操作系统提供的一种接口，用于实现进程间的网络通信。它是通过 IP 地址和端口号的组合来唯一标识网络中的一个通信端点。可以通过套接字在应用程序间建立通信，支持 TCP 或 UDP 协议。</p><p>tcp和udp的区别</p><p><strong>TCP（Transmission Control Protocol）</strong>：</p><ul><li><strong>可靠性</strong>：TCP 是面向连接的协议，确保数据按顺序到达，且不会丢失。如果丢包，TCP 会进行重传。</li><li><strong>流量控制</strong>：TCP 使用流量控制（滑动窗口）来避免发送方过快地发送数据，超出了接收方的处理能力。</li><li><strong>拥塞控制</strong>：TCP 会根据网络的负载情况动态调整数据传输速度，以避免网络拥塞。</li><li><strong>连接管理</strong>：需要在通信前建立连接（三次握手），通信结束后需要关闭连接（四次挥手）。</li></ul><p><strong>UDP（User Datagram Protocol）</strong>：</p><ul><li><strong>不可靠性</strong>：UDP 是无连接的协议，不保证数据的可靠到达。数据包可能会丢失、重复或乱序。</li><li><strong>无流量控制和拥塞控制</strong>：UDP 不会进行流量控制或拥塞控制，发送数据时不考虑接收方的处理能力。</li><li><strong>轻量级</strong>：由于其无连接、简单的特性，UDP 的开销较小，适合实时传输等对时延要求高的应用。</li></ul><p>应用场景：</p><p><strong>TCP</strong>：</p><ul><li>适用于需要高可靠性、顺序传输的场景，比如文件传输（FTP）、网页浏览（HTTP/HTTPS）、电子邮件等。</li></ul><p><strong>UDP</strong>：</p><ul><li>适用于对时延要求高、容忍数据丢失的场景，比如视频会议、VoIP（语音通信）、在线游戏等。</li></ul><p>在不可靠网络上实现可靠传输的技术</p><p>在不可靠的网络上实现可靠传输，通常依赖于<strong>自动重传请求（ARQ）协议</strong>和<strong>确认机制</strong>。TCP 就是通过 ARQ 协议来实现数据的可靠传输。</p><ul><li><strong>ARQ 协议</strong>：通过发送方和接收方之间的确认消息（ACK）来确保数据的正确传输。如果接收方未能成功接收到数据，发送方会重新发送数据。</li><li><strong>停止等待协议</strong>：发送方发送一个数据包后，等待接收方的确认消息（ACK）。如果收到确认，则继续发送下一个数据包。如果超时未收到确认，重新发送该数据包。</li><li><strong>滑动窗口协议</strong>：相比停止等待协议，滑动窗口协议允许发送方在等待确认的同时继续发送多个数据包，提高了传输效率。</li></ul><p><strong>tcp的三次握手和三次挥手</strong></p><p><strong>三次握手</strong>：用来建立 TCP 连接，确保双方都准备好进行数据传输：</p><ol><li>客户端发送 SYN 请求，表示希望建立连接。</li><li>服务器回复 SYN-ACK，表示同意建立连接。</li><li>客户端发送 ACK 确认，连接建立成功。</li></ol><p><strong>四次挥手</strong>：用来关闭连接，确保双方都完成数据的传输后才断开连接：</p><ol><li>客户端发送 FIN 请求，表示数据发送完毕，准备关闭连接。</li><li>服务器回复 ACK，确认收到客户端的关闭请求。</li><li>服务器发送 FIN 请求，表示服务器也准备关闭连接。</li><li>客户端回复 ACK，连接正式关闭。</li></ol><h1>应用层</h1><h2 id="6-1基本术语">6.1基本术语</h2><p><strong>域名系统（DNS）</strong>：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</p><p>说明白了就是一个解析的过程</p><p><strong>文件传输协议（FTP）</strong>：FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念：“下载”（Download）和&quot;上传&quot;（Upload）。 &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</p><p><strong>简单文件传输协议（TFTP）</strong>：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</p><p><strong>远程终端协议（TELNET）</strong>：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</p><p><strong>万维网（WWW）</strong>：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“‘W3’”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</p><p><strong>统一资源定位符（URL）</strong>：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p><p><strong>超文本传输协议（HTTP）</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</p><p><img src="https://oss.javaguide.cn/p3-juejin/8e3efca026654874bde8be88c96e1783~tplv-k3u1fbpfcp-zoom-1.jpeg" alt=""></p><p><strong>代理服务器（Proxy Server）</strong>：代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</p><p><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</p><p><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</p><p><strong>垂直搜索引擎</strong>：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</p><p><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</p><p><strong>目录索引</strong>：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</p><h2 id="6-2重要知识点总结">6.2重要知识点总结</h2><p>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</p><p>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</p><p>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</p><p>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</p><h2 id="6-3补充重要知识">6.3补充重要知识</h2><p>常见的http方法</p><p><strong>GET</strong>：请求服务器返回指定的资源（例如网页）。</p><p><strong>POST</strong>：向服务器提交数据（例如表单数据）。</p><p><strong>PUT</strong>：更新资源。</p><p><strong>DELETE</strong>：删除资源。</p><p>http状态码</p><p><strong>2xx</strong>：成功，例如 200 OK 表示请求成功。</p><p><strong>3xx</strong>：重定向，例如 301 Moved Permanently 表示资源已永久移动。</p><p><strong>4xx</strong>：客户端错误，例如 404 Not Found 表示请求的资源不存在。</p><p><strong>5xx</strong>：服务器错误，例如 500 Internal Server Error 表示服务器发生错误。</p><p>https和http的区别</p><p>HTTPS 在 HTTP 上加入了 SSL/TLS 协议，通过加密保护数据的机密性和完整性，防止中间人攻击。</p><p>dns工作流程：</p><p><strong>用户输入网址</strong>：当你在浏览器中输入一个 URL（如 <code>www.example.com</code>）时，浏览器首先需要通过 DNS 查找这个域名对应的 IP 地址。</p><p><strong>查询 DNS 服务器</strong>：</p><ul><li><strong>本地缓存</strong>：浏览器或操作系统首先查看是否缓存了该域名的 IP 地址。如果有缓存且未过期，直接使用缓存的地址。</li><li><strong>递归查询</strong>：如果没有缓存，DNS 客户端向 DNS 服务器发送查询请求。DNS 服务器将从根服务器、顶级域名服务器、权威域名服务器层层查询，直到找到该域名的对应 IP 地址。</li></ul><p><strong>返回 IP 地址</strong>：一旦找到，DNS 服务器将域名对应的 IP 地址返回给浏览器。</p><p><strong>建立连接</strong>：浏览器使用获取到的 IP 地址向目标服务器发起 HTTP 请求，开始页面加载过程。</p><p>访问一个网站的过程：</p><p><strong>输入网址</strong>：用户在浏览器中输入 URL（如 <code>https://www.example.com</code>）。</p><p><strong>DNS 解析</strong>：浏览器通过 DNS 将域名解析为对应的 IP 地址。</p><p><strong>TCP 连接建立</strong>：</p><ul><li>浏览器通过 TCP 协议与服务器建立连接，使用三次握手完成连接建立（对于 HTTPS，还涉及到 TLS 握手以确保数据安全性）。</li></ul><p><strong>发送 HTTP 请求</strong>：浏览器向服务器发送 HTTP 请求，获取网页资源（如 HTML、CSS、JavaScript、图片等）。</p><p><strong>服务器响应</strong>：服务器处理请求后返回 HTTP 响应，包括网页的 HTML 内容和其他相关资源。</p><p><strong>渲染页面</strong>：浏览器接收到响应后，解析并渲染网页，显示给用户。</p><p><strong>关闭连接</strong>：HTTP/1.1 使用持久连接（通过 <code>Connection: keep-alive</code>），但最终浏览器会关闭与服务器的 TCP 连接。</p><h1>其他层次</h1><p>除了常见的OSI七层体系结构外，还有tcp/ip四层协议和tcp/ip五层协议</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-7490-20150904094019903-1923900106.jpg" alt=""></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/1538030296-8668-20150904095142060-1017190812.gif" alt=""></p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/13/net1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Markdown语法</title>
      <link>https://blog.tokenlen.top/2025/01/12/markdown1/</link>
      <guid>https://blog.tokenlen.top/2025/01/12/markdown1/</guid>
      <pubDate>Sat, 11 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;Markdown是啥&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种轻量级&lt;strong&gt;标记语言&lt;/strong&gt;，它以纯文本形式(&lt;em&gt;易读、易写、易更改&lt;/em&gt;)编写文档，并最终以HTML格式发布。&lt;br&gt;
&lt;strong&gt;Markdo</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>Markdown是啥</h1><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。</p><h1>语法</h1><h2 id="标题">标题</h2><p>用=和-来标记一级和二级标题</p><p>一级</p><p>二级</p><hr><p>#一级</p><p>##二级</p><p>###三级</p><h2 id="段落">段落</h2><ul><li>可以用&gt; &gt;&gt; &gt;&gt;&gt;或者是-</li><li></li></ul><p>代码快就在每行加上四个空格或者一个制表符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="强调">强调</h2><p>使用<em>啊</em>  *</p><p>或者是_fff_    -</p><p>·呆呆·  ··使用这个</p><h2 id="列表">列表</h2><p>使用-</p><ul><li></li></ul><p>或者是直接使用符号</p><h2 id="分割线">分割线</h2><p>直接使用三个—</p><hr><h2 id="链接">链接</h2><p>【】（）</p><p>然后图片就是</p><p>！【】（）</p><p>注意是英文的符号好吧</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/Markdown/">Markdown</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/markdown/">markdown</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/12/markdown1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql练习 寒假篇</title>
      <link>https://blog.tokenlen.top/2025/01/10/sqltest3/</link>
      <guid>https://blog.tokenlen.top/2025/01/10/sqltest3/</guid>
      <pubDate>Thu, 09 Jan 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础语法回顾&lt;/h1&gt;
&lt;h2 id=&quot;1-SQL110-插入记录（一）&quot;&gt;1.&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础语法回顾</h1><h2 id="1-SQL110-插入记录（一）">1.<a href="https://www.nowcoder.com/practice/5d2a42bfaa134479afb9fffd9eee970c?tpId=240&amp;tqId=2221797&amp;ru=/exam/oj&amp;qru=/ta/sql-advanced/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page"><strong>SQL110</strong> <strong>插入记录（一）</strong></a></h2><p>牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下：</p><ul><li>用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分；</li><li>用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。</li></ul><p>试卷作答记录表exam_record中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Extra</th><th>Default</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>auto_increment</td><td>(NULL)</td><td>自增ID</td></tr><tr><td>uid</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>用户ID</td></tr><tr><td>exam_id</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>试卷ID</td></tr><tr><td>start_time</td><td>datetime</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>开始时间</td></tr><tr><td>submit_time</td><td>datetime</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>提交时间</td></tr><tr><td>score</td><td>tinyint(4)</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>得分</td></tr></tbody></table><p>该题最后会通过执行SELECT uid, exam_id, start_time, submit_time, score FROM exam_record;来对比结果</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into exam_record(uid,exam_id,start_time,submit_time,score) </span><br><span class="line">VALUES (1001,9001,&#x27;2021-09-01 22:11:12&#x27;,&#x27;2021-09-01 23:01:12&#x27; ,90),</span><br><span class="line">(1002,9002,&#x27;2021-09-04 07:01:02&#x27;,null,NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照顺序插入即可，注意一一对应</p><ol start="2"><li></li></ol><p>牛客的运营同学想要查看大家在SQL类别中高难度试卷的得分情况。</p><p>请你帮她从exam_record数据表中计算所有用户完成SQL类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p><p>示例数据：examination_info（exam_id试卷ID, tag试卷类别, difficulty试卷难度, duration考试时长, release_time发布时间）</p><table><thead><tr><th>id</th><th>exam_id</th><th>tag</th><th>difficulty</th><th>duration</th><th>release_time</th></tr></thead><tbody><tr><td>1</td><td>9001</td><td>SQL</td><td>hard</td><td>60</td><td>2020-01-01 10:00:00</td></tr><tr><td>2</td><td>9002</td><td>算法</td><td>medium</td><td>80</td><td>2020-08-02 10:00:00</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">示例数据：exam_record（uid用户ID, exam_id试卷ID, start_time开始作答时间, submit_time交卷时间, score得分）iduidexam_idstart_timesubmit_time</span><br><span class="line">score1100190012020-01-02 09:01:012020-01-02 09:21:01</span><br><span class="line">8021001</span><br><span class="line">9001</span><br><span class="line">2021-05-02 10:01:012021-05-02 10:30:01</span><br><span class="line">81310019001</span><br><span class="line">2021-06-02 19:01:01</span><br><span class="line">2021-06-02 19:31:01</span><br><span class="line">84</span><br><span class="line">410019002</span><br><span class="line">2021-09-05 19:01:01</span><br><span class="line">2021-09-05 19:40:0189</span><br><span class="line">51001</span><br><span class="line">90012021-09-02 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">61001</span><br><span class="line">9002</span><br><span class="line">2021-09-01 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">710029002</span><br><span class="line">2021-02-02 19:01:01</span><br><span class="line">2021-02-02 19:30:01</span><br><span class="line">87810029001</span><br><span class="line">2021-05-05 18:01:01</span><br><span class="line">2021-05-05 18:59:02909</span><br><span class="line">10039001</span><br><span class="line">2021-09-07 12:01:01</span><br><span class="line">2021-09-07 10:31:01</span><br><span class="line">501010049001</span><br><span class="line">2021-09-06 10:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br></pre></td></tr></table></figure><p>根据输入你的查询结果如下：</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT tag, difficulty,</span><br><span class="line">    ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br><span class="line">FROM exam_record</span><br><span class="line">JOIN examination_info USING(exam_id)</span><br><span class="line">WHERE tag = &#x27;SQL&#x27; AND difficulty = &#x27;hard&#x27;</span><br><span class="line">GROUP BY tag, difficulty;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据sql查询的分别出现的列，然后来根据这些列来写</p><p>主要是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br></pre></td></tr></table></figure><p>这个保留一位小数，计算平均数</p><p>然后使用联合查询</p><p>将examination_info和exam_record连接起来，其主键是exam_id</p><p>然后where条件</p><p>最后可以来个按组排序</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/10/sqltest3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>English一月篇</title>
      <link>https://blog.tokenlen.top/2025/01/01/en5/</link>
      <guid>https://blog.tokenlen.top/2025/01/01/en5/</guid>
      <pubDate>Tue, 31 Dec 2024 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;每日一话+单词遗忘表1.1&lt;/h1&gt;
&lt;p&gt;A New Year is like a blank book, and the pen is in your hands. Go write yourself a beautiful</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>每日一话+单词遗忘表1.1</h1><p>A New Year is like a blank book, and the pen is in your hands. Go write yourself a beautiful story.</p><ul><li>masterpiece 杰作</li><li>mate 匹配</li><li>mature 成年人的</li><li>meantime 其间</li><li>measure 措施</li><li>mechanic 技工</li><li>medal 奖章</li></ul><h1>每日一话+单词遗忘表1.2</h1><p>There is more day to dawn. The sun is but a morning star.</p><ul><li>medicine 药</li><li>melon 瓜</li><li>melt 融化</li><li>memoorandum 信函</li><li>memorial 纪念物</li><li>merchant 商人</li><li>mercy 仁慈</li><li>mere 仅仅</li><li>merit 优点</li><li>microscope 显微镜</li><li>microwave 微波</li><li>marsh 沼泽</li></ul><h1>每日一话+单词遗忘表1.3</h1><p>Not everything that is faced can be changed, but nothing can be changed until it is faced.</p><ul><li>asset 资产</li><li>migrate 移动</li><li>mild 温和的</li><li>military 军事的</li><li>mill 磨坊</li><li>minor 较小的</li><li>minus 减去</li><li>miracle 奇迹</li><li>miserable 悲惨的</li><li>mist 薄雾</li><li></li></ul><h1>每日一话+单词遗忘表1.8</h1><p>They always say time changes things, but you actually have to change them yourself.</p><ul><li>mistress 情妇</li><li>misunderstand 误解</li><li>moderate 适当的</li><li>modify 修改</li><li>moist 潮湿的</li><li>monument 纪念碑</li><li>mop 擦干</li><li>mortgage 抵押</li></ul><h1>每日一话+单词遗忘表1.10</h1><p>Curious things, habits. People themselves never knew they had them.</p><ul><li>motel 汽车旅馆</li><li>motion 动作</li><li>mud 泥浆</li><li>mug 脸</li><li>mule 骡子</li><li>municipal 市政的</li><li>murder 谋杀</li><li>muscle 肌肉</li><li>mushroom 蘑菇</li><li>exterior 外部的</li></ul><h1>每日一话+单词遗忘表1.11</h1><p>While the blanket is short, learn how to bend.</p><ul><li>nyth 神话</li><li>nail 钉子</li><li>naked 裸体的</li><li>namely 即是</li><li>nap 小睡</li><li>napkin 纸巾</li><li><strong>narrate</strong> 叙述</li><li>nasty 下流的</li><li>naughty 调皮的</li><li>navy 海军</li><li>neat 整洁的</li><li>negate 否定</li><li>neglect 疏忽</li></ul><h1>每日一话+单词遗忘表1.13</h1><p>The world is little, people are little, human life is little. There is only one big thing – desire.</p><ul><li>nephew 侄子</li><li>nevertheless 仍然</li><li>niece 外甥女</li><li>nonsense 废话</li></ul><h1>每日一话+单词遗忘表1.25</h1><p>Habit is habit, and not to be flung out of the window by any man, but coaxed downstairs a step a time.</p><ul><li>norm 规范</li><li>massage 按摩</li><li><strong>nourish</strong> 滋养</li><li>nude 裸体的</li><li>nuisance 讨厌的东西</li><li>numerous 许多的</li><li>nurse 看护</li><li>nursery 托儿所</li><li>nut 坚果</li><li>negate 否定的</li></ul><h1>每日一话+单词遗忘表1.26</h1><p>You cannot find peace by avoiding life.</p><ul><li>nutrition 营养</li><li><strong>obese</strong> 肥胖的</li><li>obey 服从</li><li>oblige 强制的</li><li>obstacle 障碍</li><li>obtain 获得</li><li>municipal 市政的</li><li>obvious 显而易见的</li><li><strong>occasiion</strong> 场合</li><li>occupation 工作</li><li>occupy 占领</li><li><strong>occur</strong> 发生</li><li>odor 气味</li><li><strong>offend</strong> 冒犯</li><li>liable 易患的</li></ul><h1>每日一话+单词列表1.27</h1><p>Have no fear of perfection ---- you’ll never reach it.</p><ul><li>occasion 场合</li><li>omit 省略</li><li>ongoing 前进的</li><li>onward 向前的</li><li>opera 歌剧</li><li>operate 运转</li><li>opposite 相反的</li><li>oral 口头的</li><li>orbit 轨道</li><li>orchestra 管弦乐队</li><li>gamble 赌博</li><li></li></ul><h1>每日一话+单词遗忘表1.28</h1><p>May your new year be filled with abundance of smiles and happiness!</p><p>新的一年，祝大家新年快乐哈哈哈哈</p><ul><li>geometry 几何学</li><li>ore 矿</li><li>organ 器官</li><li>organic 有机的</li><li>organism 有机体</li><li>orient 确定方向  东方</li><li>ornament 装饰</li><li>orphan 孤儿</li><li>ought to 应该</li><li>ounce 盎司</li><li>outlet 出口</li><li>outline 轮廓</li><li>orchestra 管弦乐队</li><li>giant 巨大的</li></ul><h1>每日一话+单词遗忘表1.29</h1><p>As the new sun rises in a brand new year may it bring you good luck, prosperity, joy, and contentment.</p><ul><li>outset 开端</li><li>outskirts 郊区</li><li>oval 椭圆的</li><li>oven 烤箱</li><li>overcoat 大衣</li><li>overdue 迟到的</li><li>noun 名词</li><li>overthrow 打到</li><li>overwhelm 淹没</li><li>oxygen 氧气</li><li>ozone 臭氧</li><li>pace 步速</li></ul><h1>每日一话+单词遗忘表1.30</h1><p>To realize the value of one minute, ask the traveler who has just missed his train.</p><ul><li>pad 护具</li><li>paint 油漆</li><li>palace 宫殿</li><li>pale 苍白的</li><li>palm 手掌</li><li>parade 游行</li><li>paralel 平行线</li><li>parcel 包裹</li><li>pardon 原谅</li><li>particle 颗粒</li></ul><h1>每日一话+单词遗忘表1.31</h1><p>Children have more need of models than of critics.</p><ul><li>pastime 娱乐</li><li>patch 小片</li><li>patent 专利</li><li>pause 暂停</li><li>pave 铺设</li><li>pea 豌豆</li><li>peanut 花生</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/English/">English</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/English/">English</category>
      
      
      <comments>https://blog.tokenlen.top/2025/01/01/en5/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
