<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Mon, 16 Jun 2025 14:29:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>https://blog.tokenlen.top/2025/06/16/lastteam/jisuanfangfa/</link>
      <guid>https://blog.tokenlen.top/2025/06/16/lastteam/jisuanfangfa/</guid>
      <pubDate>Mon, 16 Jun 2025 14:26:31 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;下面以 &lt;strong&gt;Markdown&lt;/strong&gt; 形式给出各章的公式汇总，你可以直接复制到支持 LaTeX 渲染的编辑器或导出为 PDF。&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;计算方法——公式汇总&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>下面以 <strong>Markdown</strong> 形式给出各章的公式汇总，你可以直接复制到支持 LaTeX 渲染的编辑器或导出为 PDF。</p><hr><h1>计算方法——公式汇总</h1><h2 id="第一章：误差分析">第一章：误差分析</h2><ol><li><p><strong>绝对误差</strong></p><p>Δ=∣x∗−x∣\Delta = \bigl|x^* - x\bigr|</p></li><li><p><strong>相对误差</strong></p><p>δ=∣x∗−x∣∣x∗∣\delta = \frac{\bigl|x^* - x\bigr|}{\lvert x^*\rvert}</p></li><li><p><strong>四舍五入误差限</strong>（保留到第 nn 位有效数字）</p><p>Δmax⁡=12×10−n,δmax⁡=Δmax⁡∣x∣\Delta_{\max} = \tfrac12 \times 10^{-n}, \quad \delta_{\max} = \frac{\Delta_{\max}}{\lvert x\rvert}</p></li><li><p><strong>有效数字与相对误差关系</strong><br>若已知相对误差 ε\varepsilon，则有效数字位数 nn 满足</p><p>12 10−(n−1)  ≤  ε  &lt;  12 10−(n−2).\frac12 ,10^{-(n-1)} ;\le; \varepsilon ;&lt;; \frac12 ,10^{-(n-2)}.</p></li><li><p><strong>误差传播</strong></p><ul><li><p>乘除法：</p><p>δ(f(x1,…,xk))≈∑i=1kδ(xi).\delta\bigl(f(x_1,\dots,x_k)\bigr) \approx \sum_{i=1}^k \delta(x_i).</p></li><li><p>加减法：</p><p>Δ(f(x1,…,xk))≈∑i=1kΔ(xi).\Delta\bigl(f(x_1,\dots,x_k)\bigr) \approx \sum_{i=1}^k \Delta(x_i).</p></li><li><p>例：若 A=LWA = L W，则</p><p>Δ(A)  ≤  ∣W∣ Δ(L)+∣L∣ Δ(W),δ(A)≈δ(L)+δ(W).\Delta(A) ;\le; |W|,\Delta(L) + |L|,\Delta(W), \quad \delta(A)\approx\delta(L)+\delta(W).</p></li></ul></li></ol><hr><h2 id="第二章：非线性方程求解">第二章：非线性方程求解</h2><ol><li><p><strong>根存在性</strong><br>若 ff 在 [a,b][a,b] 连续且</p><p>f(a) f(b)&lt;0,f(a),f(b) &lt; 0,</p><p>则 (a,b)(a,b) 内至少有一实根。</p></li><li><p><strong>二分法误差界</strong></p><p>∣xn−x∗∣≤b−a2n,n≥⌈log⁡2b−aε⌉.\bigl|x_n - x^*\bigr| \le \frac{b-a}{2^n}, \quad n \ge \bigl\lceil \log_2\tfrac{b-a}{\varepsilon}\bigr\rceil.</p></li><li><p><strong>不动点迭代</strong><br>写成 x=g(x)x = g(x)，迭代</p><p>xn+1=g(xn),x_{n+1} = g(x_n),</p><p>收敛条件：∣g′(x)∣&lt;1\lvert g’(x)\rvert &lt; 1（根附近）。</p></li><li><p><strong>牛顿法</strong></p><p>xn+1=xn−f(xn)f′(xn).x_{n+1} = x_n - \frac{f(x_n)}{f’(x_n)}.</p><p>如为重根 mm，可修正为</p><p>xn+1=xn−m f(xn)f′(xn).x_{n+1} = x_n - m,\frac{f(x_n)}{f’(x_n)}.</p></li><li><p><strong>割线法</strong></p><p>xn+1=xn−f(xn) xn−xn−1f(xn)−f(xn−1).x_{n+1} = x_n - f(x_n), \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}.</p></li></ol><hr><h2 id="第三章：线性方程组数值解法">第三章：线性方程组数值解法</h2><ol><li><p><strong>高斯消去法</strong><br>增广矩阵 [A∣b][A\mid b] → 逐列消元 → 回代求解。</p></li><li><p><strong>列主元策略</strong><br>每列选绝对值最大的元素作为主元，交换后再消元。</p></li><li><p><strong>Jacobi 迭代</strong><br>令 A=D+L+UA=D+L+U，则</p><p>xi(k+1)=1aii(bi−∑j≠iaij xj(k)).x_i^{(k+1)} = \frac{1}{a_{ii}} \Bigl(b_i - \sum_{j\ne i} a_{ij},x_j^{(k)}\Bigr).</p></li><li><p><strong>Gauss–Seidel 迭代</strong></p><p>xi(k+1)=1aii(bi−∑j&lt;iaij xj(k+1)−∑j&gt;iaij xj(k)).x_i^{(k+1)} = \frac{1}{a_{ii}} \Bigl( b_i - \sum_{j&lt;i} a_{ij},x_j^{(k+1)} - \sum_{j&gt;i} a_{ij},x_j^{(k)} \Bigr).</p></li><li><p><strong>SOR（超松弛方法）</strong></p><p>xi(k+1)=(1−ω) xi(k)+ωaii(bi−∑j&lt;iaij xj(k+1)−∑j&gt;iaij xj(k)),x_i^{(k+1)} = (1-\omega),x_i^{(k)} + \frac{\omega}{a_{ii}} \Bigl( b_i - \sum_{j&lt;i} a_{ij},x_j^{(k+1)} - \sum_{j&gt;i} a_{ij},x_j^{(k)} \Bigr),</p><p>其中 1&lt;ω&lt;21&lt;\omega&lt;2。</p></li></ol><hr><h2 id="第四章：插值与拟合">第四章：插值与拟合</h2><ol><li><p><strong>拉格朗日插值</strong><br>给定 (x0,y0),…,(xn,yn)(x_0,y_0),\dots,(x_n,y_n)，</p><p>L(x)=∑j=0nyj ℓj(x),ℓj(x)=∏i=0, i≠jnx−xixj−xi.L(x) = \sum_{j=0}^n y_j,\ell_j(x), \quad \ell_j(x) = \prod_{i=0,,i\ne j}^n \frac{x - x_i}{x_j - x_i}.</p></li><li><p><strong>牛顿插值</strong><br>利用差商，</p><p>Pn(x)=f[x0]+f[x0,x1] (x−x0)+⋯+f[x0,…,xn] ∏i=0n−1(x−xi).P_n(x) = f[x_0] + f[x_0,x_1],(x-x_0) + \cdots + f[x_0,\dots,x_n],\prod_{i=0}^{n-1}(x-x_i).</p></li><li><p><strong>插值余项</strong></p><p>Rn+1(x)=f(x)−Pn(x)=f(n+1)(ξ)(n+1)!∏i=0n(x−xi),ξ∈[a,b].R_{n+1}(x) = f(x) - P_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!} \prod_{i=0}^n (x - x_i),\quad \xi\in[a,b].</p></li></ol><hr><h2 id="第五章：最小二乘拟合">第五章：最小二乘拟合</h2><ol><li><p><strong>一元线性拟合（直线）</strong><br>设 y=ax+by = a x + b，构造正则方程：</p><p>{a∑xi2+b∑xi=∑xiyi,a∑xi+nb=∑yi.\begin{cases} a\sum x_i^2 + b\sum x_i = \sum x_i y_i,\ a\sum x_i + nb = \sum y_i. \end{cases}</p></li><li><p><strong>二次多项式拟合</strong><br>设 y=a0+a1x+a2x2y = a_0 + a_1 x + a_2 x^2，正则方程：</p><p>{na0+(∑xi)a1+(∑xi2)a2=∑yi,(∑xi)a0+(∑xi2)a1+(∑xi3)a2=∑xiyi,(∑xi2)a0+(∑xi3)a1+(∑xi4)a2=∑xi2yi.\begin{cases} n a_0 + (\sum x_i)a_1 + (\sum x_i^2)a_2 = \sum y_i,\ (\sum x_i)a_0 + (\sum x_i^2)a_1 + (\sum x_i^3)a_2 = \sum x_i y_i,\ (\sum x_i^2)a_0 + (\sum x_i^3)a_1 + (\sum x_i^4)a_2 = \sum x_i^2 y_i. \end{cases}</p></li><li><p><strong>加权最小二乘</strong><br>使加权残差平方和最小：</p><p>min⁡∑iwi(yi−P(xi))2.\min \sum_{i} w_i \bigl(y_i - P(x_i)\bigr)^2.</p></li></ol><hr><p>以上公式皆为 <strong>LaTeX</strong> 标准形式，复制到支持 MathJax 或 LaTeX 渲染的 Markdown 编辑器中即可正确显示。</p>]]></content:encoded>
      
      
      
      
      <comments>https://blog.tokenlen.top/2025/06/16/lastteam/jisuanfangfa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mydb自定义数据库</title>
      <link>https://blog.tokenlen.top/2025/06/12/workmenu/mydb1/</link>
      <guid>https://blog.tokenlen.top/2025/06/12/workmenu/mydb1/</guid>
      <pubDate>Wed, 11 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;架构&lt;/h1&gt;
&lt;p&gt;项目分为四个主要模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;backend：数据库核心功能实现&lt;/li&gt;
&lt;li&gt;client：客户端实现&lt;/li&gt;
&lt;li&gt;transport：网络传输层&lt;/li&gt;
&lt;li&gt;common：公共工具和异常处理&lt;/li&gt;
&lt;/ul</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>架构</h1><p>项目分为四个主要模块：</p><ul><li>backend：数据库核心功能实现</li><li>client：客户端实现</li><li>transport：网络传输层</li><li>common：公共工具和异常处理</li></ul><h2 id="后端">后端</h2><p>dm/数据管理：实现数据页面的管理和持久化</p><ul><li>DataManager.java：数据管理器接口</li><li>DataManagerImpl.java：数据管理器实现</li><li>PageOne.java：特殊页面，存储元数据</li><li>PageX.java：数据页面</li><li>Logger.java：日志管理</li></ul><p>im/索引管理：实现B+树索引</p><ul><li>BPlusTree.java：B+树实现</li><li>Node.java：B+树节点</li><li>LeafNode.java：叶子节点</li><li>InternalNode.java：内部节点</li></ul><p>tbm/表管理：实现表的创建、删除和管理</p><ul><li>Table.java：表的抽象</li><li>TableManager.java：表管理器接口</li><li>TableManagerImpl.java：表管理器实现</li><li>Field.java：字段定义和管理</li></ul><p>tm/事务管理：实现事务的ACID特性</p><ul><li>ransactionManager.java：事务管理器接口</li><li>TransactionManagerImpl.java：事务管理器实现</li></ul><p>vm/MVCC管理：</p><ul><li>VersionManager.java：版本管理器接口</li><li>VersionManagerImpl.java：版本管理器实现</li><li>Entry.java：数据项</li><li>Transaction.java：事务实现</li></ul><p>parser/sql语句的解析：</p><ul><li>Parser.java：SQL解析器</li><li>Tokenizer.java：词法分析器</li><li>statement/*.java：各类SQL语句的数据结构</li></ul><p>server/服务器功能：</p><ul><li>erver.java：服务器实现</li><li>Executor.java：SQL执行器</li></ul><h2 id="客户端">客户端</h2><ul><li>Client.java：客户端实现</li><li>Shell.java：命令行交互</li><li>Launcher.java：启动器</li></ul><h2 id="传输">传输</h2><ul><li>Package.java：通信包</li><li>Packager.java：包处理器</li><li>Transporter.java：传输器</li></ul><h2 id="公共模块">公共模块</h2><ul><li>Error.java：错误定义</li><li>Config.java：配置管理</li></ul><h1>解析</h1><h2 id="Logger模块">Logger模块</h2><p>实现<strong>日志的持久化、校验、读取、校正和截断非法数据</strong>，确保数据库的<strong>崩溃恢复能力（crash recovery）</strong></p><p>日志的文件格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Size(4字节)][Checksum(4字节)][Data(N字节)]</span><br></pre></td></tr></table></figure><p>文件头部还有一个全局 <code>xChecksum</code>（4字节）作为整个日志序列的校验值，存储在文件开头，用于<strong>崩溃恢复期间检查文件是否完整</strong>。</p><table><thead><tr><th>位置</th><th>字节数</th><th>含义</th></tr></thead><tbody><tr><td>0-3</td><td>4B</td><td><code>xChecksum</code> 全局校验</td></tr><tr><td>4+</td><td>多条日志</td><td>每条日志如下结构：<code>[Size][Checksum][Data]</code></td></tr></tbody></table><p><code>LoggerImpl</code>：核心实现类</p><p><code>Logger</code>：接口 + 工厂方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LogEntry`：封装完整日志条目 `[fullBytes, data]</span><br></pre></td></tr></table></figure><p><strong>init方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">headerBuf</span> <span class="operator">=</span> ByteBuffer.allocate(HEADER_SIZE);</span><br><span class="line">fc.position(<span class="number">0</span>);</span><br><span class="line">fc.read(headerBuf);</span><br><span class="line"><span class="built_in">this</span>.xChecksum = Parser.parseInt(headerBuf.array());</span><br><span class="line">validateAndTruncateTail();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先读取 <code>xChecksum</code>，然后进入日志校验逻辑 <code>validateAndTruncateTail()</code>。</p><p><strong>日志校验：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rewind();</span><br><span class="line"><span class="type">int</span> <span class="variable">calcXCheck</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">validEnd</span> <span class="operator">=</span> HEADER_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">LogEntry</span> <span class="variable">entry</span> <span class="operator">=</span> readNextLog();</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">    calcXCheck = calChecksum(calcXCheck, entry.fullBytes);</span><br><span class="line">    validEnd += entry.fullBytes.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (calcXCheck != xChecksum) &#123;</span><br><span class="line">    Panic.panic(Error.BadLogFileException);</span><br><span class="line">&#125;</span><br><span class="line">truncate(validEnd);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件头部开始读取每条日志。</p><p>校验每条日志的 <code>checksum</code> 是否匹配。</p><p>若都匹配，则将尾部位置 <code>validEnd</code> 更新为新的合法文件末尾</p><p>如果算出的 <code>calcXCheck</code> 不一致，说明日志文件可能被破坏，抛出异常。否则，<strong>截断非法尾部</strong>。</p><p><strong>log写入：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] logEntry = wrapLog(data);</span><br><span class="line">fc.position(fc.size());</span><br><span class="line">fc.write(ByteBuffer.wrap(logEntry));</span><br><span class="line">updateXChecksum(logEntry);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先计算 data 的 <code>checksum</code></p><p>用 <code>size + checksum + data</code> 拼接为一条日志</p><p>将新的 <code>xChecksum</code> 写入文件头部，用于下次校验。</p><p>读取逻辑：</p><p>先读 <code>[size][checksum]</code> 共 8 字节</p><p>再根据 <code>size</code> 读取 <code>data</code>，并进行校验</p><p>如果不匹配说明日志损坏，返回 null。</p><p><strong>update校验日志：</strong></p><p>设置文件取到文件头，然后写入新的校验和，调用策略接口，执行具体的策略，增加了提示，累计写入数据</p><p>实现了刷盘，采用策略类，实现了同步刷盘，定时异步刷盘，和不刷盘。根据不同的情况进行选择</p><p>用来处理不同的情况。</p><p>定时大小双阈值异步刷盘：</p><p>满足任一条件即可刷盘，提升灵活性与性能保障</p><p>多次 <code>flush()</code> 只设置标志，合并后统一刷盘</p><p>使用原子变量 + <code>synchronized</code> 保证数据一致性</p><p>可通过 <code>shutdown()</code> 停止任务，或动态调整周期</p><p>可通过参数设定周期，如每 100ms 刷一次</p><p>最长可能延迟 <code>flushIntervalMillis</code>，适合非关键日志</p><h2 id="索引模块">索引模块</h2><p>node节点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B+树节点结构</span></span><br><span class="line"><span class="comment">// [LeafFlag][KeyNumber][SiblingUid] 是头部信息</span></span><br><span class="line"><span class="comment">// 后面是 [Son0][Key0][Son1][Key1]...[SonN][KeyN]</span></span><br><span class="line"><span class="comment">// 每个 son 是一个子节点 UID；key 是关键字。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IS_LEAF_OFFSET</span> <span class="operator">=</span> <span class="number">0</span>;           <span class="comment">// 是否为叶子节点（1字节）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO_KEYS_OFFSET</span> <span class="operator">=</span> IS_LEAF_OFFSET+<span class="number">1</span>;   <span class="comment">// 当前 key 数量（2字节）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIBLING_OFFSET</span> <span class="operator">=</span> NO_KEYS_OFFSET+<span class="number">2</span>;   <span class="comment">// 兄弟节点 UID（8字节）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_HEADER_SIZE</span> <span class="operator">=</span> SIBLING_OFFSET+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BALANCE_NUMBER</span> <span class="operator">=</span> <span class="number">32</span>;          <span class="comment">// 节点最多存储 64 个 key</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NODE_SIZE</span> <span class="operator">=</span> NODE_HEADER_SIZE + (<span class="number">2</span>*<span class="number">8</span>)*(BALANCE_NUMBER*<span class="number">2</span>+<span class="number">2</span>); <span class="comment">// 最大容量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>setRawIsLeaf()</code> / <code>getRawIfLeaf()</code>: 设置/获取是否为叶子节点</li><li><code>setRawNoKeys()</code> / <code>getRawNoKeys()</code>: 设置/获取 key 数</li><li><code>setRawSibling()</code> / <code>getRawSibling()</code>: 设置/获取兄弟节点 UID</li><li><code>setRawKthSon()</code> / <code>getRawKthSon()</code>: 设置/获取第 k 个子节点 UID</li><li><code>setRawKthKey()</code> / <code>getRawKthKey()</code>: 设置/获取第 k 个 key</li><li><code>shiftRawKth()</code>: 从第 k 位右移 key/son，为插入腾位置</li><li><code>copyRawFromKth()</code>: 将后半部分节点数据拷贝出来，用于分裂</li><li><code>newRootRaw()</code>：构造新根节点（中间节点）</li><li><code>newNilRootRaw()</code>：构造空的叶子节点</li></ul><p>读取逻辑：</p><p>boolean isLeaf(): 判断是否为叶子节点</p><p>SearchNextRes searchNext(long key): 在中间节点中<strong>查找适合 key 所在的子节点 UID，如果 key 超过最大 key，则返回 sibling 节点 UID。</strong></p><p>LeafSearchRangeRes leafSearchRange(long leftKey, long rightKey):</p><ul><li>仅在叶子节点中执行，从 leftKey 找到 rightKey 范围内的所有 UID。</li><li>如果未覆盖完全，返回 siblingUid 供上层继续搜索。</li></ul><p>插入分裂逻辑：</p><p>InsertAndSplitRes insertAndSplit(long uid, long key):</p><ul><li>调用 insert() 插入一个键值对 [key, uid]</li><li>若插入后 key 数超限，调用 split() 分裂节点</li></ul><p>内部插入逻辑，根据是叶子节点或内部节点采取不同插入策略：</p><ul><li>叶子节点插入：直接插入 [key, uid]</li><li>中间节点插入：先保存原 key，覆盖当前 key，再右移一位插入 [uid, oldKey]</li></ul><p>节点分裂操作：</p><ul><li>创建新节点并复制后半部分 key/son</li><li>新节点插入 DM 中生成新 UID</li><li>当前节点更新 siblingUid 指向新节点</li><li>返回分裂后新节点和新 key（新 key 是新节点的最小 key</li></ul><p>缓存：</p><p>实现了LRU缓存策略，简单的hashmap+sychronized实现</p><p>和concurrenthashmap+readwirtelock实现</p><p>B+tree索引实现：</p><p>新增 <code>NodeCache</code> 来缓存热点节点，减少频繁磁盘读。</p><p><code>BPlusTree</code> 里新增 <code>loadNode</code> 方法，用缓存优先加载节点。</p><p>联合索引：</p><h1>问题文档</h1><h2 id="1-“bug”-sql解释器-：修复了sql语句会有-的问题">1.“bug”(sql解释器)：修复了sql语句会有&lt;&lt;的问题</h2><p>运行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn exec:java --% -Dexec.mainClass=com.mengnankk.mydatabase.backend.Launcher -Dexec.args=&quot;-create ./data&quot;</span><br><span class="line">mvn exec:java --% -Dexec.mainClass=com.mengnankk.mydatabase.backend.Launcher -Dexec.args=&quot;-open ./data&quot;</span><br><span class="line">mvn exec:java --% -Dexec.mainClass=com.mengnankk.mydatabase.client.Launcher -Dexec.args=&quot;./data&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> ikeife    MYDB   master ≡  ~1     1.602s⠀   mvn exec:java --% -Dexec.mainClass=top.guoziyang.mydb.client.Launcher -Dexec.args=&quot;./data&quot;</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -------------------------&lt; top.guoziyang:MyDB &gt;-------------------------</span><br><span class="line">[INFO] Building MyDB 1.0-SNAPSHOT</span><br><span class="line">[INFO]   from pom.xml</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- exec:3.5.1:java (default-cli) @ MyDB ---</span><br><span class="line">:&gt; create table test1</span><br><span class="line">Invalid command!</span><br><span class="line">:&gt; create table test1;</span><br><span class="line">Invalid statement: create table test1&lt;&lt; ;</span><br><span class="line">:&gt; create table test1 (id int, name varchar);</span><br><span class="line">Invalid statement: create table test1 (id &lt;&lt; int, name varchar);</span><br><span class="line">:&gt; create table test1 (id int);</span><br><span class="line">Invalid statement: create table test1 (id &lt;&lt; int);</span><br><span class="line">:&gt; show tables;</span><br><span class="line">Invalid statement: show tables&lt;&lt; ;</span><br><span class="line">:&gt;</span><br></pre></td></tr></table></figure><p>运行之后这个发现总是多了个&lt;&lt;感觉应该是命令行接收输入或者读取输入流的方式出现了问题。</p><p>第一步：修复SQL解析器（Parser.java）</p><ul><li><p>修改了isType方法，使其能识别标准SQL类型</p></li><li><p>新增了combineType方法，用于处理带括号的类型声明（如varchar(20)）</p></li><li><p>修改了parseCreate方法，改进了类型声明的处理逻辑</p></li><li><p>使索引定义成为可选项，不再强制要求必须有索引</p></li></ul><p>第二步：改进字段类型处理（Field.java）</p><ul><li><p>添加了convertType方法，实现SQL类型到内部类型的映射：</p></li><li><p>改进了typeCheck方法，增加了类型转换步骤</p></li><li><p>修改了Field构造函数，在构造时就进行类型转换</p></li></ul><p>主要解决的问题</p><ul><li><p>支持了标准SQL语法</p></li><li><p>处理了带长度的类型声明（如varchar(20)）</p></li><li><p>实现了SQL类型到内部类型的自动转换</p></li><li><p>修复了索引相关的语法解析</p></li></ul><p>最终效果</p><p>现在可以使用标准SQL语句创建表，也可以不带索引的创建sql语句</p><h2 id="2-“feat”-Server-替换成了NIO，单线程实现IO多路复用">2.“feat”(Server): 替换成了NIO，单线程实现IO多路复用</h2><p>问题在于客户端的Socket创建方式。在NIO模式下，我们需要使用SocketChannel来创建非阻塞的套接字。让我修改客户端的Launcher类：</p><ol><li><p>使用SocketChannel替代Socket</p></li><li><p>配置SocketChannel为非阻塞模式</p></li><li><p>使用connect和finishConnect方法来建立连接</p></li><li><p>添加了连接等待逻辑，因为非阻塞模式下连接可能不会立即完成</p></li><li><p>更新了错误处理逻辑</p></li></ol><h2 id="3-“feat”-Encoder-使用中文的话，使用UTF-8编码">3.“feat”(Encoder):使用中文的话，使用UTF-8编码</h2><ol><li>字符串编码问题</li></ol><ul><li><p>问题表现：中文字符显示为乱码（“锟斤拷”）</p></li><li><p>原因：数据库在处理字符串时没有统一使用UTF-8编码</p></li></ul><p>解决方案：</p><p>在Parser类中修改字符串处理：</p><ul><li><p>使用StandardCharsets.UTF_8进行字符串编码和解码</p></li><li><p>修改string2Byte和parseString方法，确保正确处理UTF-8编码</p></li></ul><p>在DataManagerImpl类中修改数据存储：</p><ul><li><p>在insert方法中确保数据使用UTF-8编码</p></li><li><p>在存储前将数据转换为UTF-8编码的字符串</p></li></ul><p>在Table类中修改数据读取和显示：</p><ul><li><p>在parseEntry方法中确保字符串使用UTF-8编码</p></li><li><p>在entry2Raw方法中确保字符串使用UTF-8编码</p></li><li><p>在printEntry方法中确保字符串使用UTF-8编码</p></li></ul><p>Tokenizer访问权限问题</p><ul><li><p>问题表现：Parser类无法访问Tokenizer类的方法</p></li><li><p>原因：Tokenizer类中的方法访问权限设置不正确</p></li></ul><p>解决方案：</p><ul><li><p>将Tokenizer类中的peek和pop方法改为public</p></li><li><p>添加了isAlphaBeta和isDigit静态方法</p></li><li><p>修复了字符串解析中的边界条件问题</p></li></ul><p>数据存储问题</p><ul><li><p>问题表现：数据存储后读取出现异常</p></li><li><p>原因：数据存储和读取的编码不一致</p></li><li><p>解决方案：</p></li><li><p>统一使用UTF-8编码进行数据存储和读取</p></li><li><p>在数据转换过程中保持编码一致性</p></li><li><p>确保数据在存储前进行正确的编码转换</p></li></ul><p>主要修改点</p><ul><li><p>添加了StandardCharsets.UTF_8的导入</p></li><li><p>在所有涉及字符串操作的地方统一使用UTF-8编码</p></li><li><p>在数据存储、读取和显示三个环节都进行了编码处理</p></li><li><p>确保字符串在转换过程中不会丢失编码信息</p></li><li><p>修改了类的访问权限，确保正确的封装性</p></li><li><p>修复了字符串解析的边界条件问题</p></li></ul><p>经验教训</p><ul><li><p>在处理多语言（特别是中文）时，必须统一使用UTF-8编码</p></li><li><p>需要在数据处理的各个环节（存储、读取、显示）都进行编码处理</p></li><li><p>字符串编码问题往往表现为乱码，需要从数据流转的各个环节排查</p></li><li><p>在数据库系统中，编码问题需要从底层（存储）到上层（显示）都进行统一处理</p></li><li><p>类的访问权限设计需要仔细考虑，确保正确的封装性</p></li><li><p>字符串处理时需要注意边界条件</p></li></ul><h2 id="4-“feat”-bug-异常：">4.“feat”(bug):异常：</h2><p>1.空指针：</p><p><code>AbstractCache.release(uid)</code> 里从某个 <code>Map</code> 结构中 <code>get(uid)</code> 后没有判空，直接 <code>.intValue()</code> 了。</p><p>加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ref</span> <span class="operator">=</span> references.get(uid);</span><br><span class="line"><span class="keyword">if</span>(ref == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Release called on unknown UID: &quot;</span> + uid);</span><br><span class="line">&#125;</span><br><span class="line">ref = ref - <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>Map.computeIfPresent()</code> 来减少并发风险，或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">references.compute(uid, (k, v) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Release called on unknown UID: &quot;</span> + uid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.NegativeArraySizeException: -16</p><p>说明你尝试创建一个长度为 <strong>负数</strong> 的数组</p><p><strong>数据文件未完整写入或写入错位</strong></p><ul><li>日志校验失败后仍尝试加载，导致读取偏移错误。</li></ul><p><strong>日志恢复不完整或逻辑错误</strong></p><ul><li>如果你的日志采用 <code>[Size][Checksum][Data]</code> 格式，可能在读取 <code>Size</code> 时读取了非法值（如内存残留数据）。</li></ul><p><strong><code>Parser.parseSize(raw)</code> 实现错误</strong></p><ul><li>可能字节序错、偏移错、字段解码逻辑错。</li></ul><p>添加 <code>size</code> 合法性检查</p><p>那么 <code>Size</code> 是前 4 个字节，你恢复时必须按顺序读</p><p>检查磁盘是否已被写入错位内容，加了边界校验代码。</p><p>3.数据库文件未正确关闭，导致恢复后残留了无效 Entry</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/12/workmenu/mydb1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mydb自定义数据库八股</title>
      <link>https://blog.tokenlen.top/2025/06/12/workmenu/mydb2/</link>
      <guid>https://blog.tokenlen.top/2025/06/12/workmenu/mydb2/</guid>
      <pubDate>Wed, 11 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;项目问题&lt;/h1&gt;
&lt;h2 id=&quot;1-在-Mydb-数据库中，日志模块是如何实现崩溃恢复的？请详细说明日志格式、校验机制、写入流程和恢复逻辑，并分析可能存在的性能瓶颈及优化方案。&quot;&gt;1.在 Mydb</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>项目问题</h1><h2 id="1-在-Mydb-数据库中，日志模块是如何实现崩溃恢复的？请详细说明日志格式、校验机制、写入流程和恢复逻辑，并分析可能存在的性能瓶颈及优化方案。">1.在 Mydb 数据库中，日志模块是如何实现崩溃恢复的？请详细说明日志格式、校验机制、写入流程和恢复逻辑，并分析可能存在的性能瓶颈及优化方案。</h2><h3 id="日志设计">日志设计</h3><p>redo log:记录事务提交后的数据修改，用于崩溃后重做已提交事务（如数据页修改记录）；</p><p>undo log:记录事务提交前的原始状态，用于回滚未提交事务（如行版本号、旧值）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[全局校验码(4B)][日志条目1][日志条目2]...  </span><br><span class="line">日志条目格式：[条目长度(4B)][校验码(4B)][数据内容(N字节)]  </span><br></pre></td></tr></table></figure><p>日志文件头部 4 字节为全局校验码，每条日志以<code>[4字节长度+4字节校验码+数据]</code>组成。启动时会从头部开始校验每条日志的 checksum，若全局校验码不一致则截断文件尾部。”</p><h3 id="崩溃恢复">崩溃恢复</h3><p>校验</p><ul><li>从文件头部开始读取每条日志，校验单条日志的 checksum；</li><li>累计计算全局校验码，与文件头部校验码比对，不一致则截断文件尾部。</li></ul><p>redo</p><ul><li>扫描日志，提取所有状态为<code>COMMITTED</code>的事务记录；</li><li>按日志顺序重新执行数据修改操作（如更新数据页）。</li></ul><p>undo</p><ul><li>扫描日志，找到状态为<code>ACTIVE</code>或<code>ABORTED</code>的事务；</li><li>根据 Undo 日志恢复数据原始状态（如行版本号回退）。</li></ul><h3 id="日志写入和刷盘">日志写入和刷盘</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志写入伪代码  </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">appendLog</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;  </span><br><span class="line">    <span class="type">byte</span>[] entry = wrapLog(data); <span class="comment">// 封装[长度+校验码+数据]  </span></span><br><span class="line">    fileChannel.position(fileChannel.size());  </span><br><span class="line">    fileChannel.write(ByteBuffer.wrap(entry));  </span><br><span class="line">    updateGlobalChecksum(entry); <span class="comment">// 更新全局校验码  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>刷盘策略：</p><ul><li><strong>同步刷盘（SYNC）</strong>：每条日志写入后立即调用<code>force()</code>刷盘，可靠性高但性能低；</li><li><strong>异步刷盘（ASYNC）</strong>：使用双阈值策略（时间阈值 + 大小阈值）：</li></ul><p>使用一个异步的线程池来实现，满足任一条件即可刷盘，提升灵活性与性能保障</p><p>多次 <code>flush()</code> 只设置标志，合并后统一刷盘</p><p>使用原子变量 + <code>synchronized</code> 保证数据一致性</p><p>可通过 <code>shutdown()</code> 停止任务，或动态调整周期</p><p>可通过参数设定周期，如每 100ms 刷一次</p><p>最长可能延迟 <code>flushIntervalMillis</code>，适合非关键日志</p><p>异步刷盘使用<code>ScheduledThreadPoolExecutor</code>定时检查，当日志缓冲区大小超过 1MB 或距上次刷盘超过 2 秒时，加锁批量刷盘，避免多线程同时操作文件导致的一致性问题。”</p><ul><li><strong>不刷盘（NO_FLUSH）</strong>：仅用于测试，数据可能丢失。</li></ul><h3 id="性能问题">性能问题</h3><p><strong>同步刷盘导致的 IO 阻塞</strong></p><p>高并发下刷盘成为瓶颈，TPS 下降（如单线程同步刷盘时 TPS≤1000）。</p><ul><li>采用<strong>组提交（Group Commit）</strong>：将多个日志条目批量刷盘（如每 100 条刷一次）；</li><li>引入<strong>内存映射文件（MappedByteBuffer）</strong>，减少用户态到内核态的拷贝。</li></ul><p><strong>异步刷盘的数据一致性风险</strong></p><ul><li>实现<strong>WAL（Write-Ahead Logging）</strong> 机制：事务提交前强制刷盘 Redo 日志；</li><li>增加<strong>刷盘回调机制</strong>：刷盘完成后通知事务提交。</li></ul><p><strong>日志校验的 CPU 开销</strong></p><ul><li>用<strong>CRC32C 算法</strong>替代自定义校验（JDK1.8 <code>java.util.zip.CRC32C</code>，性能提升 3 倍）；</li><li>对热数据日志启用<strong>校验缓存</strong>，避免重复计算。</li></ul><p>日志缓存可将<code>HashMap+ReentrantLock</code>改为<code>ConcurrentHashMap</code>，利用分段锁减少并发竞争。例如，缓存热点日志的校验结果时，读操作无需加锁，写操作仅锁定对应分段。”</p><p><strong>日志分段与归档</strong></p><ul><li>按时间或大小分割日志文件（如每 1GB 一个文件），避免单文件过大；</li><li>归档旧日志文件，定期清理无效日志（如已完成事务的 Undo 日志）。</li></ul><p><strong>异步刷盘策略下，系统崩溃导致 10 秒内的日志丢失（约 5000 条）。</strong></p><ul><li>调整双阈值为<code>大小阈值=1MB</code>+<code>时间阈值=2秒</code>，平衡性能与可靠性；</li><li>关键业务场景强制使用同步刷盘（如资金交易）。</li></ul><h2 id="2-在-Mydb-数据库中，B-树索引是如何实现高效查询和插入的？请详细说明节点结构、查询算法、插入分裂策略，并分析高并发场景下的性能瓶颈及优化方案。">2.在 Mydb 数据库中，B + 树索引是如何实现高效查询和插入的？请详细说明节点结构、查询算法、插入分裂策略，并分析高并发场景下的性能瓶颈及优化方案。</h2><h3 id="B-树核心结构设计">B + 树核心结构设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[叶子标志(1B)][键数量(2B)][兄弟节点UID(8B)][子节点UID/键值对]  </span><br><span class="line">叶子节点：[键<span class="number">1</span>][值<span class="number">1</span>][键<span class="number">2</span>][值<span class="number">2</span>]...[键n][值n]  </span><br><span class="line">非叶子节点：[子节点UID1][键<span class="number">1</span>][子节点UID2][键<span class="number">2</span>]...[子节点UIDn][键n]  </span><br></pre></td></tr></table></figure><ul><li><strong>叶子节点</strong>：存储实际键值对，通过双向链表连接（便于范围查询）；</li><li><strong>非叶子节点</strong>：仅存储键和子节点引用，加速检索。</li><li><strong>扇出（Fan-Out）</strong>：单个节点可容纳的子节点数，由键长和页大小决定（如 8KB 页 + 8B 键 + 8B 引用，扇出≈512）；</li><li><strong>阶数（Order）</strong>：节点的最小子节点数（通常为扇出的 1/2），保证树的平衡。</li></ul><p>B + 树节点包含叶子标志位（1 字节）、键数量（2 字节）、兄弟节点 UID（8 字节），叶子节点存储键值对，非叶子节点存储子节点 UID 和分隔键，通过页结构（如 4KB）组织数据。”</p><h3 id="查找">查找</h3><p><strong>非叶子节点</strong>：用二分查找确定子节点方向；</p><p><strong>叶子节点</strong>：顺序遍历键值对（因叶子节点有序，可快速定位）。</p><p><strong>IO 次数</strong>：3 层 B + 树可存储约 1000 万条数据，查询仅需 3 次 IO（页大小 16KB，扇出 1000）；</p><p><strong>内存效率</strong>：非叶子节点仅存储键和引用，内存占用比二叉搜索树低 80%。</p><p>查询时非叶子节点用二分查找确定子节点方向，叶子节点因有序可快速定位，范围查询时通过叶子节点的双向链表遍历，避免全树扫描。</p><h3 id="插入与分裂">插入与分裂</h3><p>插入</p><ul><li>定位到目标叶子节点，若空间足够则直接插入；</li><li>若空间不足，触发节点分裂。</li></ul><p>分裂逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">splitLeafNode</span><span class="params">(LeafNode node)</span> &#123;  </span><br><span class="line">    <span class="type">LeafNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafNode</span>();  </span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> node.keyCount / <span class="number">2</span>;  </span><br><span class="line">    <span class="comment">// 复制后半部分键值对到新节点  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid; i &lt; node.keyCount; i++) &#123;  </span><br><span class="line">        newNode.insert(node.keys[i], node.values[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    node.keyCount = mid;  </span><br><span class="line">    <span class="comment">// 连接兄弟节点  </span></span><br><span class="line">    newNode.sibling = node.sibling;  </span><br><span class="line">    node.sibling = newNode.uid;  </span><br><span class="line">    <span class="comment">// 向父节点插入新节点引用  </span></span><br><span class="line">    insertIntoParent(node, newNode.smallestKey, newNode.uid);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><strong>分裂点</strong>：取节点中键的中间位置，前半部分保留，后半部分放入新节点；</li><li><strong>父节点更新</strong>：父节点插入新节点的最小键和 UID，若父节点也满则递归分裂。</li></ul><p>分裂时将节点后半部分数据移至新节点，新节点的兄弟<strong>指针指向原节点的兄弟</strong>，<strong>原节点的兄弟指针指向新节点</strong>，并向父节点插入新节点的最小键和 UID，若父节点已满则递归分裂。</p><p>插入 / 分裂时仅锁定目标节点,ReentrantLock.</p><h3 id="性能问题-2">性能问题</h3><p><strong>节点锁竞争</strong></p><p>高并发插入时，多个线程争夺同一节点锁，导致吞吐量下降（如 1000TPS 时下降至 300TPS）</p><ul><li><p>分层锁（Locking Hierarchy）：</p><ul><li>非叶子节点用<code>ReadWriteLock</code>，读操作共享锁，写操作排他锁；</li><li>叶子节点用<code>ReentrantLock</code>，支持可重入和公平锁模式。</li></ul></li><li><p>使用乐观锁：</p></li><li><pre><code class="language-java">boolean casInsert(Node node, long expectedVersion) &#123;      if (node.version != expectedVersion) return false;      // 插入操作...      node.version++;      return true;  &#125;  </code></pre></li></ul><p><strong>缓存失效与 IO 风暴</strong></p><p>大量随机插入导致 B + 树重组，缓存命中率下降（如从 90% 降至 50%）。</p><ul><li><strong>节点预读（Read-Ahead）</strong>：查询时预判下一层节点，提前加载到缓存；</li><li><strong>冷热数据分离</strong>：用<code>LRU缓存</code>存储热点节点，冷节点定期淘汰（如最近 10 分钟未访问的节点）。LRU可以使用hashmap+reentrantlock或者使用更加精细的concurrenthashmap+readwritrlock</li></ul><p><strong>范围查询性能衰减</strong></p><p>大范围查询时遍历叶子链表，导致 CPU 占用过高（如查询 10 万条记录时 CPU 占比 100%）。</p><ul><li><strong>批量读取（Batch Read）</strong>：一次读取多个页（如 16 个页），减少 IO 次数；</li><li><strong>异步查询（Async Query）</strong>：将大范围查询放入单独线程池，避免阻塞业务线程：</li></ul><h3 id="优化">优化</h3><p><strong>写入优化：批量插入与合并分裂</strong></p><ul><li><strong>批量插入</strong>：将多个插入操作合并为一批，减少分裂次数（如每 1000 条插入后统一分裂）；</li><li><strong>分裂合并</strong>：当相邻节点利用率低于 50% 时，合并节点以减少树高。</li></ul><p><strong>索引覆盖与前缀索引</strong></p><ul><li><strong>索引覆盖</strong>：设计索引时包含查询所需全部字段，避免回表（如<code>SELECT id,name FROM table WHERE id&gt;100</code>）；</li><li><strong>前缀索引</strong>：对长字符串取前缀建立索引（如取 URL 前 100 字节），减少索引体积。</li></ul><p><strong>监控与调优指标</strong></p><p>节点锁等待时间（理想≤1ms）；</p><p>缓存命中率（理想≥95%）；</p><p>平均 IO 次数（理想≤3 次 / 查询）。</p><p>调优工具：</p><ul><li>用<code>JProfiler</code>监控索引操作热点方法；</li><li>用<code>BTrace</code>追踪节点锁竞争场景。</li></ul><p><strong>电商大促时，商品索引插入性能骤降，导致订单创建延迟从 50ms 升至 500ms。</strong></p><p>高并发插入导致 B + 树频繁分裂，节点锁竞争激烈。</p><ul><li>启用<strong>写入限流</strong>（如每秒最多 1 万次插入），超出则返回 “系统繁忙”；</li><li>采用<strong>分段 B + 树</strong>：按商品 ID 哈希分为 16 段，每段独立索引，减少锁冲突；</li><li>大促前预扩容索引，预留 30% 空间（如初始扇出 512，大促时调整为 358）。</li><li>高并发插入时，可采用写入分组（如按 UID 哈希分 16 组，每组独立索引），配合令牌桶限流（如每组每秒 1000 次插入），减少节点锁竞争；同时用乐观锁（CAS）避免频繁加锁。</li></ul><h2 id="3-在-Mydb-数据库中，如何实现事务的-ACID-特性？请详细说明事务日志（Redo-Undo）、锁机制、MVCC-的作用，并分析高并发场景下的脏读、不可重复读、幻读解决方案。">3.在 Mydb 数据库中，如何实现事务的 ACID 特性？请详细说明事务日志（Redo/Undo）、锁机制、MVCC 的作用，并分析高并发场景下的脏读、不可重复读、幻读解决方案。</h2><h3 id="ACID">ACID</h3><ul><li><strong>原子性（Atomicity）</strong>：通过 Undo 日志记录事务前状态，回滚时恢复；</li><li><strong>一致性（Consistency）</strong>：通过 Redo+Undo 共同保证（Redo 重做已提交事务，Undo 回滚未提交事务）；</li><li><strong>持久性（Durability）</strong>：Redo 日志刷盘后，即使崩溃也能恢复数据；</li><li><strong>隔离性（Isolation）</strong>：通过 MVCC + 锁机制实现不同隔离级别。</li></ul><p>事务提交时，先写 Undo 日志记录旧值，再写 Redo 日志记录新值，最后刷盘 Redo 日志（WAL 原则），确保崩溃后 Redo 已提交事务，Undo 回滚未提交事务。</p><h3 id="MVCC">MVCC</h3><p>“MVCC 通过版本号（或时间戳）实现快照读：</p><ol><li>事务启动时记录当前最大活跃事务 ID（max_trx_id）；</li><li>读取数据时，若数据版本号 &lt; 当前事务 ID 且不在活跃事务列表中，可读；</li><li>若数据版本号 &gt;= max_trx_id，说明被后续事务修改，需根据隔离级别决定是否阻塞。</li><li>MVCC 通过快照读避免锁竞争，适合读多写少场景（如报表查询）；锁机制适合写多场景（如订单扣款），需根据业务场景选择。”</li></ol><p>隔离级别：</p><ul><li><strong>读已提交（RC）</strong>：每次查询加行级锁，读完释放，避免脏读；</li><li><strong>可重复读（RR）</strong>：查询加快照读（MVCC），更新加行级锁 + 间隙锁，避免不可重复读和幻读；</li><li><strong>串行化（Serializable）</strong>：全表加锁，串行执行。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/12/workmenu/mydb2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数字逻辑期末复习</title>
      <link>https://blog.tokenlen.top/2025/06/11/lastteam/shuziluoji/</link>
      <guid>https://blog.tokenlen.top/2025/06/11/lastteam/shuziluoji/</guid>
      <pubDate>Tue, 10 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;知识点分布&lt;/h1&gt;
&lt;p&gt;计算：&lt;/p&gt;
&lt;p&gt;1.进制转换&lt;/p&gt;
&lt;p&gt;10进制，8进制，16进制，20进制&lt;/p&gt;
&lt;p&gt;2.源码反码补码&lt;/p&gt;
&lt;p&gt;3.余三码&lt;/p&gt;
&lt;p&gt;4.公式运用转换&lt;/p&gt;
&lt;p&gt;化简，卡诺图，公式&lt;/p&gt;
&lt;p&gt;数字逻辑&lt;/p&gt;
</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>知识点分布</h1><p>计算：</p><p>1.进制转换</p><p>10进制，8进制，16进制，20进制</p><p>2.源码反码补码</p><p>3.余三码</p><p>4.公式运用转换</p><p>化简，卡诺图，公式</p><p>数字逻辑</p><p>两个简答，三个计算二进制转8 10 16饭吗不拿 雨伞吗</p><p>化简</p><p>函数化简，标准语或表达式</p><p>卡诺图化简</p><p>组合逻辑电路分析</p><p>函数逻辑表达，nc图，功能</p><p>隐含表</p><p>状态化简</p><p>时序逻辑电路，什么型的</p><p>死胎针指标</p><p>状态相应队列</p><h1>简答题</h1><p><strong>与非门/或非门型R-S触发器差异</strong></p><p><strong>同步与异步时序电路对比</strong></p><p><strong>组合与时序逻辑区别</strong></p><p><strong>逻辑函数三种描述方式（真值表、代数表达式、卡诺图）</strong></p><p><strong>卡诺图化简步骤与规则</strong></p><h2 id="1-根据所采用的半导体器件不同，集成电路可分为哪两大类？各自的主要优缺点是什么。">1.根据所采用的半导体器件不同，集成电路可分为哪两大类？各自的主要优缺点是什么。</h2><p>根据所采用的半导体器件不同，集成电路可分为两大类：一类是采用双极型半导体器件作为元件的<strong>双极型集成电路</strong>；双极型集成电路的主要特点是<strong>速度快、负载能力强，但功耗较大，集成度较低；</strong></p><p>另一类是采用金属-氧化物-半导体场效应管作为元件的单极型集成电路，又称MOS集成电路。MOS集成电路的特点是<strong>结构简单、制造方便、集成度高、功耗低，但速度较慢。</strong></p><h2 id="2-简述晶体二极管的静态特性">2.简述晶体二极管的静态特性</h2><p>1.<strong>正向特性</strong> ：</p><p>正向电压 UF ≤ UTH ：管子截止，电阻很大、正向电流IF 接近于 0， 二极管类似于开关的断开状态 ；正向电压 UF= UTH ：管子开始导通，正向电流IF开始上<br>升；正向电压 UF ＞ UTH (一般锗管为0.3V，硅管为0.7V) ：管子充分导通，电阻很小，正向电流IF急剧增加，二极管类似于开关的接通状态。<br>2． <strong>反向特性</strong>：<br>二极管在反向电压UR作用下，处于截止状态，反向电阻很大，反向电流IR很小（将其称为反向饱和电流，用IS表示，通常可忽略不计），二极管的状态类似于开关断开。而且反向电压在一定范围内变化基本不引起反向电流的变化。</p><h2 id="3-晶体二极管的开关速度主要取决于什么？">3.晶体二极管的开关速度主要取决于什么？</h2><p>晶体二极管的动态特性是指二极管在<strong>导通与截至</strong>两种状态转换过程中的特性，它表现在完成两种状态之间的转换需要一定的时间。通常把二极管从**正向导通到反向截至所需要的时间称为反向恢复时间，而把二极管从反向截至到正向导通的时间称为开通时间。**相比之下，<strong>开通时间很短</strong>，一般可以忽略不计。因此，晶体二极管的开关速度主要取决于反向恢复时间。</p><h2 id="4-数字电路中，晶体三极管一般工作在什么状态-？">4.数字电路中，晶体三极管一般工作在什么状态 ？</h2><p>在数字电路中，晶体三极管被作为开关元件一般工作在<strong>饱和与截至</strong>两种状态，相当于一个由基极信号控制的无触点开关，其作用对应于触点开关的“闭合”与“断开”</p><h2 id="5-晶体三极管的开关速度取决于哪些因素？为什么MOS管的开关速度比晶体三极管慢-？">5.晶体三极管的开关速度取决于哪些因素？为什么MOS管的开关速度比晶体三极管慢 ？</h2><p>开通时间ton和关闭时间toff是影响电路工作速度的主要因素。由于MOS管导通时的漏源电阻rDS比晶体三极管的饱和电阻rCES要大得多，漏极外接电阻RD也比晶体管集电极电阻RC大，所以，MOS管的充、放电时间较长，使MOS管的开关速度比晶体三极管的开关速度低。</p><h2 id="6-TTL与非门有哪些主要性能参数？">6.TTL与非门有哪些主要性能参数？</h2><p>(1) 输出高电平VOH<br>(2) 输出低电平VOL<br>(3)开门电平VON 开门电平的大小反映了高电平抗干扰能力，VON 愈小，<br>在输入高电平时的抗干扰能力愈强。<br>(4)关门电平VOFF ：关门电平的大小反映了低电平抗干扰能力，VOFF越大，<br>在输入低电平时的抗干扰能力越强。<br>(5) 扇入系数Ni<br>(6) 扇出系数No<br>(7) 输入短路电流Iis<br>(8) 高电平输入电流Iih<br>(9) 平均传输延迟时间tpd<br>(10) 空载功耗P</p><h2 id="7-OC门和TS门的结构与一般TTL与非门有何不同？各有何主要应用-？">7.OC门和TS门的结构与一般TTL与非门有何不同？各有何主要应用 ？</h2><p>集电极开路门(Open Collector Gate)是一种输出端可以直接相互连接的特殊逻辑门，简称OC门。OC门电路将一般TTL与非门电路的推拉式输出级改为三极管集电极开路输出。集电极开路与非门在计算机中应用很广泛，可以用它实现&quot;线与&quot;逻辑、电平转换以及直接驱动发光二极管、干簧继电器等。三态输出门有三种输出状态：输出高电平、输出低电平和高阻状态，前两种状态为工作状态，后一种状态为禁止状态三态与非门主要应用于总线传送，它既可用于单向数据送，也可用于双向数据传送。</p><h2 id="8-简述时序逻辑电路与组合逻辑电路的区别（重点）">8.简述时序逻辑电路与组合逻辑电路的区别（重点）</h2><p>时序逻辑电路在<strong>任何时刻产生的稳定输出信号不仅与该时刻电路的输入信号有关，而且与电路过去的输入信号有关</strong>；而组合逻辑电路仅仅与<strong>该时刻电路的输入信号</strong>有关。</p><h2 id="9-有两个相同型号的TTL与非门，对它们进行测试的结果如下：">9.有两个相同型号的TTL与非门，对它们进行测试的结果如下：</h2><p>（1）甲的开门电平为1.4V，乙的开门电平为1.5V ；<br>（2）甲的关门电平为1.0V，乙的开门电平为0.9V ；</p><p>试问在输入相同的高电平时，哪个抗干扰能力强？在输入相同低电平时，哪个抗干扰能力强？</p><p>对于TTL与非门来说，<strong>开门电平愈小，输入高电平时的抗干扰能力愈强</strong>；关<strong>门电平愈大，在输入低电平时抗干扰能力愈强</strong>。因此，在两种情况下，均是甲的抗干扰能力强。</p><h2 id="10-用与非门组成的基本R-S触发器和用或非门组成的基本R-S触发器在逻辑功能上有什么区别？（重点）">10.用与非门组成的基本R-S触发器和用或非门组成的基本R-S触发器在逻辑功能上有什么区别？（重点）</h2><table><thead><tr><th>项目</th><th>用 NAND（与非门）实现</th><th>用 NOR（或非门）实现</th></tr></thead><tbody><tr><td>构成门电路</td><td>与非门（NAND）</td><td>或非门（NOR）</td></tr><tr><td>电路图形态</td><td>输入为低电平触发</td><td>输入为高电平触发</td></tr></tbody></table><p>或与门:</p><p>看的是S的置位</p><table><thead><tr><th>R</th><th>S</th><th>Q(n+1)</th><th>功能说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Q</td><td>保持</td></tr><tr><td>0</td><td>1</td><td>1</td><td>置 1（Set）</td></tr><tr><td>1</td><td>0</td><td>0</td><td>置 0（Reset）</td></tr><tr><td>1</td><td>1</td><td>不定</td><td>无效（禁止）</td></tr></tbody></table><p>与非门：</p><p>看的是R置位</p><table><thead><tr><th>R</th><th>S</th><th>Q(n+1)</th><th>功能说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>不定</td><td>无效（禁止）</td></tr><tr><td>0</td><td>1</td><td>0</td><td>置 0（Reset）</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置 1（Set）</td></tr><tr><td>1</td><td>1</td><td>Q</td><td>保持</td></tr></tbody></table><p><strong>或非门 NOR 高电平有效”，“与非门 NAND 低电平有效</strong></p><h1>计算</h1><h2 id="1-进制转换">1.进制转换</h2><p>十进制 123 转为八进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123 ÷ 8 = 15 余 3  </span><br><span class="line">15 ÷ 8 = 1 余 7  </span><br><span class="line">1 ÷ 8 = 0 余 1  </span><br><span class="line"></span><br><span class="line">倒序结果：173（八进制）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>十进制 123 转为十六进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 ÷ 16 = 7 余 11 → B  </span><br><span class="line">7 ÷ 16 = 0 余 7  </span><br><span class="line"></span><br><span class="line">倒序结果：7B（十六进制）</span><br></pre></td></tr></table></figure><p>就是除，然后倒叙的写余数。</p><p>然后小数部分，就是乘然后取整数部分</p><p>0.27 转八进制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0.27 × 8 = 2.16      → 取整 2  </span><br><span class="line">0.16 × 8 = 1.28      → 取整 1  </span><br><span class="line">0.28 × 8 = 2.24      → 取整 2  </span><br><span class="line">0.24 × 8 = 1.92      → 取整 1  </span><br><span class="line">0.92 × 8 = 7.36      → 取整 7  </span><br><span class="line">0.36 × 8 = 2.88      → 取整 2  </span><br><span class="line">0.88 × 8 = 7.04      → 取整 7  </span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0.27≈0.2121727</p><h2 id="2-源码反码补码">2.源码反码补码</h2><table><thead><tr><th>表示形式</th><th>正数</th><th>负数</th></tr></thead><tbody><tr><td>原码</td><td>符号位为0，数值位正常</td><td>符号位为1，数值位绝对值</td></tr><tr><td>反码</td><td>同原码</td><td>符号位为1，数值位按位取反</td></tr><tr><td>补码</td><td>同原码</td><td>反码 + 1</td></tr></tbody></table><p>十进制 -5 的表示（8位）</p><p>原码：<code>10000101</code></p><p>反码：<code>11111010</code>（符号位不变，数值部分取反）</p><p>补码：<code>11111011</code>（反码 +1）</p><p>0.1011 的源码反码补码：</p><p>0.1011都一样</p><p>－10110的源码反码补码：</p><p>110110</p><p>101001</p><p>101010</p><h2 id="3-各种编码">3.各种编码</h2><p>BCD码：将十进制的<strong>每位分别转换为4位二进制</strong>（例如 9 → 1001）</p><p>余三码：= BCD码 + 0011</p><table><thead><tr><th>十进制</th><th>BCD (8421)</th><th>余三码</th></tr></thead><tbody><tr><td>0</td><td>0000</td><td>0011</td></tr><tr><td>5</td><td>0101</td><td>1000</td></tr><tr><td>9</td><td>1001</td><td>1100</td></tr></tbody></table><p>余三码 → 减去 0011 → BCD → 十进制</p><p>2421码：<strong>十进制数字 0~9</strong> 编码为 4 位二进制</p><table><thead><tr><th>十进制</th><th>2421码（权值分别为 2-4-2-1）</th></tr></thead><tbody><tr><td>0</td><td>0000</td></tr><tr><td>1</td><td>0001</td></tr><tr><td>2</td><td>0010</td></tr><tr><td>3</td><td>0011</td></tr><tr><td>4</td><td>0100</td></tr><tr><td>5</td><td>1011</td></tr><tr><td>6</td><td>1100</td></tr><tr><td>7</td><td>1101</td></tr><tr><td>8</td><td>1110</td></tr><tr><td>9</td><td>1111</td></tr></tbody></table><p>Gray码：</p><p><strong>相邻两个数的编码只有一位不同</strong>，这也叫做 <strong>最小汉明距离编码</strong>。</p><p>十进制 <code>7</code> → 二进制：<code>0111</code></p><p>G0 = B0 （最高位相同）首位不变，其异或<br>Gi = Bi XOR B(i−1)（从第1位开始，每一位 = 当前位 XOR 前一位）</p><p>Gray 码计算：</p><ul><li>G0 = B0 = 0</li><li>G1 = B1 ⊕ B0 = 1 ⊕ 0 = 1</li><li>G2 = B2 ⊕ B1 = 1 ⊕ 1 = 0</li><li>G3 = B3 ⊕ B2 = 1 ⊕ 1 = 0</li></ul><p>Gray码为0100</p><h2 id="4-二进制运算">4.二进制运算</h2><p>加法：<strong>规则</strong>（逢二进一）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 + 0 = 0  </span><br><span class="line">0 + 1 = 1  </span><br><span class="line">1 + 0 = 1  </span><br><span class="line">1 + 1 = 0 （进位1）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>减法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 - 0 = 0  </span><br><span class="line">1 - 0 = 1  </span><br><span class="line">1 - 1 = 0  </span><br><span class="line">0 - 1 = 1（向高位借1）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>乘法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   101   (5)</span><br><span class="line">×   11   (3)</span><br><span class="line">-------</span><br><span class="line">   101</span><br><span class="line">+ 1010</span><br><span class="line">-------</span><br><span class="line">  1111  (15)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1010 ÷ 10 = 101 (10 ÷ 2 = 5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与或非</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例（1010 和 1100）</th><th>结果</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>1010 &amp; 1100</td><td>1000</td></tr><tr><td>`</td><td>`</td><td>或 只要一个为1就为1</td><td>1010</td></tr><tr><td><code>^</code></td><td>异或</td><td>1010 ^ 1100 两个二进制位相同则为0，不同则为1。</td><td>0110</td></tr><tr><td><code>~</code></td><td>非</td><td>~1010</td><td>0101（取反，视字长而定）</td></tr></tbody></table><h2 id="5-逻辑代数的运算">5.逻辑代数的运算</h2><p><strong>运算：</strong></p><p>比较重要的：</p><p>A + ¬A · B = A + B</p><p>A · (¬A + B) = A · B</p><p><strong>A + A · B = A</strong></p><p>A · (A + B) = A</p><p>A · ¬A · B = 0</p><p><strong>A + B · C = (A + B) · (A + C)</strong></p><p>吸收律：A + AB = A</p><p>分配律：A(B + C) = AB + AC</p><p>对偶律：与或互换、0和1互换</p><p>结合律、德摩根定律等</p><p><strong>反函数</strong></p><p>反函数是对逻辑表达式整体进行<strong>逻辑取反（¬）</strong>，常借助<strong>德摩根定律</strong>进行变换。</p><p>对偶函数：</p><p>所有的 <code>·</code>（AND）换成 <code>+</code>（OR）</p><p>所有的 <code>+</code>（OR）换成 <code>·</code>（AND）</p><p>所有的常量 <code>1</code> 与 <code>0</code> 互换</p><p><strong>变量和非变量（A, ¬A）不变</strong></p><h2 id="6-最小项之和（Sum-of-Minterms）和最大项之积（x）卡诺图化简">6.最小项之和（Sum of Minterms）和最大项之积（x）卡诺图化简</h2><p>最小项（minterm）：在某一组输入下，<strong>输出为 1</strong> 的项 求和符号</p><p>最大项（maxterm）：在某一组输入下，<strong>输出为 0</strong> 的项。 最大符号</p><p>这个真值表的编号从0开始</p><p><strong>卡诺图</strong>编号：</p><table><thead><tr><th>CD\AB</th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>00 C非D非</td><td>0000 (0)</td><td>0001 (1)</td><td>0011 (3)</td><td>0010 (2)</td></tr><tr><td>01 C非D</td><td>0100 (4)</td><td>0101 (5)</td><td>0111 (7)</td><td>0110 (6)</td></tr><tr><td>11 cd</td><td>1100 (12)</td><td>1101 (13)</td><td>1111 (15)</td><td>1110 (14)</td></tr><tr><td>10 cD非</td><td>1000 (8)</td><td>1001 (9)</td><td>1011 (11)</td><td>1010 (10)</td></tr></tbody></table><p>2^n来圈，圈的越大越好</p><p>然后找公共的地方，把这些圈给加（or）起来</p><p>与－或”表达式（SOP）：最后每项用或连接 F = AB + A’C + BC ∑m</p><p>或－与”表达式：F = (A + B)(A’ + C)(B + C) ∏M</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E7%94%B5%E8%B7%AF/">电路</category>
      
      <category domain="https://blog.tokenlen.top/categories/%E7%94%B5%E8%B7%AF/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/">数字逻辑</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/11/lastteam/shuziluoji/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试模拟-1</title>
      <link>https://blog.tokenlen.top/2025/06/11/towork/working1/</link>
      <guid>https://blog.tokenlen.top/2025/06/11/towork/working1/</guid>
      <pubDate>Tue, 10 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;6.11模拟面试&lt;/h1&gt;
&lt;h2 id=&quot;1-什么是-Java-的面向对象编程？它的核心特性有哪些？&quot;&gt;1.什么是 Java</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>6.11模拟面试</h1><h2 id="1-什么是-Java-的面向对象编程？它的核心特性有哪些？">1.什么是 Java 的面向对象编程？它的核心特性有哪些？</h2><p>面向对象编程是OOP是说就是<strong>用“对象”来组织代码</strong>，java就是一门面向对象编程的语言。</p><p>java的面向对象的三大特征是封装继承多态</p><p>封装：反射，修饰符</p><p>继承：构造方法调用，final</p><p>多态：方法重载，方法重写</p><p>抽象：抽象和接口</p><p>静态：</p><h2 id="2-说说-Java-中-ArrayList-和-LinkedList-的区别，以及各自的适用场景">2.说说 Java 中 ArrayList 和 LinkedList 的区别，以及各自的适用场景</h2><p>底层：</p><p>遍历和插入：</p><p>arrayList扩容：1.5，数组的复制</p><p>内存占比：</p><p>使用场景：</p><p>线程安全：</p><h2 id="3-HashMap-的底层原理">3.HashMap 的底层原理</h2><p>特点：</p><p>底层实现，1.7/1.7之后，头插和尾插</p><p>put过程</p><p>转换红黑树/扩容：当链表长度≥8 且数组容量≥64 时转红黑树 为什么用红黑树</p><p>线程安全：</p><p>concurrenthashmap，底层，put过程</p><h2 id="4-Spring-框架中，Bean-的作用域有哪些？请分别说明它们的生命周期和应用场景">4.Spring 框架中，Bean 的作用域有哪些？请分别说明它们的生命周期和应用场景</h2><p><strong>5 大标准作用域</strong>：</p><ul><li><strong>Singleton</strong>：全局唯一实例，Spring 容器加载时创建，适用于无状态服务；</li><li><strong>Prototype</strong>：每次获取新实例，适用于有状态对象（如 DAO 层）；</li><li><strong>Request</strong>：每次 HTTP 请求一个实例，需 Web 环境，适用于请求上下文数据；</li><li><strong>Session</strong>：每个用户会话一个实例，需 Web 环境，适用于会话级数据；</li><li><strong>Application</strong>：全局 ServletContext 共享实例，需 Web 环境。</li></ul><p>生命周期：实例化→属性注入→@PostConstruct→初始化完成→使用→@PreDestroy→销毁。</p><p>循环依赖：setter单例注入，三级缓存，</p><ul><li>一级缓存（singletonObjects）：存储完全初始化的单例 Bean；</li><li>二级缓存（earlySingletonObjects）：存储早期曝光的 Bean（解决 A→B→A 的循环依赖）；</li><li>三级缓存（singletonFactories）：存储 Bean 的工厂，用于生成代理对象（解决 A→B（代理）→A 的循环依赖）。</li></ul><h2 id="5-AOP-的实现原理">5.AOP 的实现原理</h2><p>概念：适用场景</p><p>作用点：</p><ul><li><strong>切面（Aspect）</strong>：封装横切逻辑的类，用<code>@Aspect</code>注解标识；</li><li><strong>切点（Pointcut）</strong>：定义横切逻辑作用的目标方法（如<code>@Pointcut(&quot;execution(* com.service.*.*(..))&quot;)</code>）；</li><li><strong>通知（Advice）</strong>：横切逻辑的具体实现，包括 5 种类型</li><li><strong>连接点（Joinpoint）</strong>：程序执行中的具体点（如方法调用、字段修改），AOP 中主要指<strong>方法调用</strong></li></ul><p>动态代理：</p><ul><li><strong>JDK 动态代理</strong>：基于接口实现，生成<code>InvocationHandler</code>的代理对象，适用于目标类有接口的情况；</li><li><strong>CGLIB 代理</strong>：基于子类继承，生成目标类的子类代理对象，适用于无接口的类（需引入<code>cglib</code>依赖）；</li><li><strong>Spring 默认策略</strong>：有接口用 JDK 代理，无接口用 CGLIB 代理（可通过<code>proxy-target-class</code>属性强制使用 CGLIB）。</li><li>流程：</li><li>Spring 容器扫描到<code>@Aspect</code>注解的切面类，解析切点表达式和通知类型；</li><li>对目标类判断是否适用 JDK/CGLIB 代理，生成代理对象；</li><li>当调用代理对象的方法时，实际执行的是<strong>通知逻辑 + 目标方法</strong>的组合逻辑。</li></ul><p>细节：</p><ol><li><p><strong>开启 AOP 支持</strong>：在配置类中添加<code>@EnableAspectJAutoProxy</code>注解，或在 XML 中配置<code>&lt;aop:aspectj-autoproxy/&gt;</code>；</p></li><li><p>代理模式选择</p><p>：</p><ul><li>默认<code>proxyTargetClass=false</code>（优先 JDK 代理）；</li><li>若需强制 CGLIB 代理，设置<code>proxyTargetClass=true</code>或<code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>；</li></ul></li><li><p><strong>循环依赖与 AOP</strong>：若目标类被代理，注入的是代理对象，需注意<code>this.方法()</code>调用不会触发 AOP（因<code>this</code>指向原始对象）。</p></li></ol><p>场景：</p><ul><li><p><strong>日志记录</strong>：在方法执行前后记录入参 / 结果，避免业务代码污染；</p></li><li><p><strong>事务管理</strong>：<code>@Transactional</code>本质是 AOP 实现，在方法调用时开启 / 提交 / 回滚事务；</p></li><li><p><strong>权限校验</strong>：在接口调用前校验用户权限，拒绝非法请求；</p></li><li><p><strong>性能监控</strong>：统计方法执行耗时，用于性能优化。</p></li></ul><p>流程：</p><ol><li><strong>调用代理方法</strong>：客户端调用代理对象的方法（如<code>userService.save()</code>）；</li><li><strong>匹配切点</strong>：Spring 判断该方法是否匹配切面的切点表达式；</li><li>执行通知逻辑<ul><li><code>@Around</code>中先执行前置逻辑（如日志记录开始）；</li><li>调用<code>proceed()</code>触发目标方法执行；</li><li>执行后置逻辑（如日志记录结束、统计耗时）；</li></ul></li><li><strong>返回结果</strong>：通知逻辑执行完毕后，将结果返回给客户端。</li></ol><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 定义切点（匹配所有Service方法）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.service..*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">servicePointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 环绕通知实现耗时统计</span></span><br><span class="line">    <span class="meta">@Around(&quot;servicePointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法 &quot;</span> + methodName + <span class="string">&quot; 执行耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-MySQL-中，索引是什么？常见的索引类型有哪些？请说明它们的适用场景和优缺点。">6.MySQL 中，索引是什么？常见的索引类型有哪些？请说明它们的适用场景和优缺点。</h2><p>数据库中用于<strong>加快数据查询速度的一种数据结构</strong>，可以类比为书本的目录。通过索引，数据库可以更快地定位到目标数据，而无需全表扫描。</p><p>为什么使用b+树，层高，叶子节点/非叶子节点</p><p>聚簇索引，非聚簇索引，索引下推</p><p>联合索引，覆盖索引</p><p>普通索引，唯一索引，前缀索引，全文索引。</p><p>索引失效：</p><p>explain:</p><h2 id="7-MyBatis-的一级缓存和二级缓存机制？如何禁用缓存？">7.<strong>MyBatis 的一级缓存和二级缓存机制？如何禁用缓存？</strong></h2><p>sqlsession:</p><p>在一次 SqlSession 生命周期内，相同的查询语句（SQL + 参数）会被缓存，第二次执行时直接从缓存中取值，不会发起数据库请求。当前会话有效，执行 <code>insert/update/delete</code>：任何更新操作会清空缓存。执行<code>sqlSession.clearCache()</code>。不同参数的时候也会失效</p><p>mapper：</p><p>二级缓存是 <strong>Mapper 级别</strong>（namespace）共享缓存。</p><p>多个 SqlSession 之间共享该 Mapper 的缓存数据。</p><p>启用条件：</p><p>在 MyBatis 配置中启用全局缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>在对应 Mapper 文件中配置 <code>&lt;cache&gt;</code> 标签：</p><p>查询的 POJO 实体类必须实现 <code>Serializable</code>。</p><p>查询语句不能使用 <code>flushCache=&quot;true&quot;</code>（默认查询是 false，更新是 true）。</p><p>SqlSession 必须关闭后，一级缓存的数据才会被写入二级缓存。</p><p>默认缓存实现是 <code>PerpetualCache + LRU</code>。</p><p>可自定义缓存策略（如 EhCache、Redis）。</p><h2 id="8-MyBatis-Plus-的-Wrapper-和原生-XML-写-SQL-的区别？什么时候该用-Wrapper？"><strong>8.MyBatis Plus 的 Wrapper 和原生 XML 写 SQL 的区别？什么时候该用 Wrapper？</strong></h2><p>Wrapper 是 MyBatis Plus 提供的条件构造器，用于构建 SQL 的 WHERE、ORDER BY 等子句，简化代码书写。</p><p><code>QueryWrapper</code>：用于普通查询。</p><p><code>LambdaQueryWrapper</code>：使用 lambda 表达式避免写字段名字符串。</p><p><code>UpdateWrapper</code> / <code>LambdaUpdateWrapper</code>：用于更新条件构造。</p><p>XML 方式是传统 MyBatis 写 SQL 的方式，通过 Mapper.xml 文件自定义 SQL 语句，更加灵活和强大，支持复杂的多表连接、子查询等。</p><table><thead><tr><th>对比项</th><th>Wrapper（构造器）</th><th>XML 原生 SQL</th></tr></thead><tbody><tr><td>语法风格</td><td>Java 代码风格，链式调用</td><td>SQL 语法，放在 XML 中</td></tr><tr><td>可读性</td><td>简洁、类型安全（特别是 Lambda）</td><td>接近原生 SQL，清晰直观</td></tr><tr><td>编写速度</td><td>快速开发，尤其适合单表 CRUD</td><td>编写略慢，需额外维护 Mapper.xml 文件</td></tr><tr><td>SQL 灵活性</td><td>支持简单查询（单表、分页、排序）</td><td>支持复杂 SQL（多表连接、子查询、聚合）</td></tr><tr><td>维护性</td><td>逻辑分散在代码中，不易集中查看</td><td>逻辑集中在 XML，更适合团队协作维护</td></tr><tr><td>运行效率</td><td>两者本质上都由 MyBatis 执行，性能差异不大</td><td>性能主要看 SQL 写得是否合理</td></tr><tr><td>调试与日志</td><td>SQL 日志可查看</td><td>也可通过日志查看</td></tr></tbody></table><p>✅ 使用 Wrapper 的场景：</p><ul><li>快速开发、原型项目。</li><li>简单的单表查询、分页、筛选。</li><li>Controller/Service 中构造简单业务逻辑。</li><li>需要链式调用构造条件，代码更加优雅。</li><li>使用 Lambda 避免字段拼写错误风险。</li></ul><blockquote><p><strong>推荐：日常开发中能用 Wrapper 就用 Wrapper，提高开发效率。</strong></p></blockquote><hr><p>✅ 使用 XML 写 SQL 的场景：</p><ul><li>涉及复杂 SQL（多表关联、聚合函数、子查询、动态 SQL）。</li><li>查询语句过长、不适合写在 Java 代码中。</li><li>项目追求清晰的逻辑分层、SQL 可维护性。</li><li>性能调优场景，需要手写精细 SQL。</li><li>团队需要 DBA 审查 SQL。</li></ul><blockquote><p><strong>推荐：复杂业务、线上稳定项目，用 XML 更清晰、更可控。</strong></p></blockquote><h1>6.12模拟面试</h1><h2 id="1-单例模式有哪些实现方式？各自的优缺点是什么？（比如饿汉式、懒汉式、双重检查锁，还有静态内部类和枚举方式，有没有线程安全的坑呀？）">1.<strong>单例模式有哪些实现方式？各自的优缺点是什么？（比如饿汉式、懒汉式、双重检查锁，还有静态内部类和枚举方式，有没有线程安全的坑呀？）</strong></h2><p>饿汉式：</p><p>同步模式</p><p>volatile+synchronized</p><p>静态内部类</p><p>枚举</p><h2 id="2-说下Spring-的ApplicationContext是单例模式”“策略模式在排序算法中的应用”">2.说下Spring 的ApplicationContext是单例模式”“策略模式在排序算法中的应用”</h2><p><code>ApplicationContext</code> 本质上采用了<strong>单例模式</strong>来保证 Spring 容器中 <strong>Bean 的唯一性和全局访问能力</strong>。</p><p>Spring Boot 启动时会初始化一个 <code>ApplicationContext</code>（如 <code>AnnotationConfigApplicationContext</code>），作为<strong>IoC 容器的核心上下文</strong>。</p><p>这个容器对象在整个应用中<strong>只创建一次（单例）</strong>，所有组件（Controller、Service、Repository）都从这个容器中获取 Bean 实例。</p><p><strong>避免了重复初始化 Bean 的性能开销</strong>，也方便了依赖管理、统一配置、事件发布等功能的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(MyApp.class, args);</span><br><span class="line"><span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开发中我们只需注入一次上下文或通过 <code>@Autowired</code> 注解获取 Bean，即可全局复用。</p><p>Spring 默认的 Bean 是单例的（<code>@Scope(&quot;singleton&quot;)</code>），这与 <code>ApplicationContext</code> 单例模型相辅相成，进一步保证了资源一致性与管理效率。</p><p>策略模式允许在运行时选择算法逻辑，在排序算法中可用于根据用户选择动态切换不同排序策略。</p><p><strong>定义统一的排序接口（策略抽象）</strong>，不同的排序方式（快排、归并、冒泡等）实现这个接口。</p><p><strong>运行时根据条件动态切换策略</strong>，无需修改原有代码（遵循开闭原则）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 快速排序实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 冒泡排序实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SortStrategy strategy;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SortContext</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        strategy.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SortContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortContext</span>(<span class="keyword">new</span> <span class="title class_">QuickSort</span>());</span><br><span class="line">ctx.executeSort(myArray); <span class="comment">// 快速排序执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>电商平台商品排序（按价格、销量、上架时间）</li><li>数据可视化工具的排序规则切换</li></ul><h2 id="3-Java-线程池的核心参数有哪些？各自的作用是什么？比如corePoolSize和maximumPoolSize，如何根据业务场景设置这些参数呀？">3.<strong>Java 线程池的核心参数有哪些？各自的作用是什么？比如<code>corePoolSize</code>和<code>maximumPoolSize</code>，如何根据业务场景设置这些参数呀？</strong></h2><p>核心线程</p><p>最大线程</p><p>最大线程存活事件</p><p>单位</p><p>阻塞队列</p><p>拒绝策略</p><p>工厂</p><h2 id="4-你项目里用了JWT加双-Token，具体是怎么设计的？两个-Token-各自的作用是什么？拦截器又分别处理什么逻辑？比如有没有考虑过-Token-过期、刷新机制，或者防重放攻击的问题？">4.你项目里用了JWT加双 Token，具体是怎么设计的？两个 Token 各自的作用是什么？拦截器又分别处理什么逻辑？比如有没有考虑过 Token 过期、刷新机制，或者防重放攻击的问题？</h2><p>token:</p><ul><li><strong>access token</strong>（7 天有效期）：放在请求头，用于日常接口认证，用 HS256 加密（密钥服务端持有）；放在前端的localStorage/jwt</li><li><strong>refresh token</strong>（15 天有效期）：存在 Redis，值是随机字符串，且绑定用户 ID ，防止盗用。放在redis中</li></ul><table><thead><tr><th>安全措施</th><th>说明</th></tr></thead><tbody><tr><td>使用 HTTPS</td><td>防止中间人劫持 token</td></tr><tr><td>access token 只读</td><td>JWT 使用 HS256 加密，防篡改</td></tr><tr><td>refresh token 存 Redis</td><td>结合用户 ID 存储，支持设置 TTL，有效控制生命周期</td></tr><tr><td>黑名单机制（登出）</td><td>用户退出登录时可删除 Redis 中 refresh token，立即失效</td></tr><tr><td>防止多端同时登录</td><td>Redis 可使用 userId 为 key，限制 refresh token 单个登录会话</td></tr><tr><td>Token 刷新接口限流</td><td>防止 refresh token 被滥用（加防重放、限频）</td></tr><tr><td>Token 刷新重发保护</td><td>Redis 设置短期 refresh token 使用标记，防止并发重复刷新</td></tr></tbody></table><p>退出策略：</p><p>用户点击退出：</p><ul><li>删除 Redis 中的 refresh token（或设置为无效标记）；</li><li>access token 因为是 JWT，不可被撤销，可考虑实现<strong>黑名单机制</strong>（例如 Redis 中维护一张 token 黑名单）；</li></ul><p>黑名单适用于<strong>高安全场景</strong>（如后台管理系统），但会略增加接口访问时的 Redis 查询压力。</p><p>jwt拦截器：</p><ol><li><strong>认证拦截器</strong>：先检查请求头是否有 access token，没有就返回 401；有则解析 token，校验用户信息是否存在。</li></ol><ul><li>第一个拦截器先校验请求头是否有 access token，没有的话直接返回 401；第二个拦截器在 access token 有效时，额外检查是否快过期（比如剩余时间 &lt; 10 分钟），如果是就用 refresh token 去 Redis 换全新的 access token 和 refresh token（这里要注意刷新时的原子性，避免并发问题）。</li></ul><ol><li>刷新拦截器：如果 access token 剩余有效期 &lt; 10 分钟，就用请求头中的 refresh token 去 Redis 校验：<ul><li>校验通过的话，生成新的 access token 和 refresh token（新 refresh token 会覆盖 Redis 中的旧值，保证单设备登录）；</li><li>校验失败的话，直接让用户重新登录。</li></ul></li></ol><p>危险：</p><p>前端或攻击者<strong>拿到密钥（如部署泄露、浏览器调试泄露）</strong>，就可以伪造合法 token。</p><p>token 内容是可解密的，攻击者可<strong>猜测或修改 payload</strong>，然后重新签名。</p><p>如果服务端<strong>未验证签名</strong>（有些误用场景会只解析不校验），更容易被利用。</p><p>但还是sh256更快，计算算开销低；对称密钥管理更简单，适用于内部系统或中小型项目；</p><p>开发成本更低，不涉及证书管理、公私钥分发；</p><table><thead><tr><th>措施</th><th>说明</th></tr></thead><tbody><tr><td>✅ 使用强密钥</td><td>至少 256 bit 的复杂密钥，不可硬编码进前端或代码中</td></tr><tr><td>✅ 启用 HTTPS</td><td>防止 token 被中间人劫持</td></tr><tr><td>✅ token 签名校验</td><td>每次都校验 JWT 的签名，防止伪造</td></tr><tr><td>✅ 缩短 access token 有效期</td><td>缩小攻击窗口</td></tr><tr><td>✅ refresh token 存 Redis</td><td>结合用户 ID 防重放、防伪造</td></tr><tr><td>✅ 黑名单机制 + 登出清除</td><td>登出时使 refresh token 无效</td></tr><tr><td>✅ 检查 UA/IP 等指纹</td><td>防止 token 被别人拿去复用</td></tr></tbody></table><h2 id="5-看你在优惠劵的发放的时候使用限流，怎么设计的">5.看你在优惠劵的发放的时候使用限流，怎么设计的</h2><p>我们在优惠券领取接口中用 AOP + 令牌桶实现限流</p><ul><li><strong>注解定义</strong>：<code>@RateLimit</code> 注解标注需要限流的方法，参数包括 <code>limitCount=5</code>（每分钟 5 次）、<code>time=1</code>（时间单位分钟）、<code>keyType=&quot;USER_IP&quot;</code>（按用户 IP+ID 限流）。</li><li><strong>切面实现</strong>：通过 <code>@Around</code> 切面拦截注解方法，获取参数后生成唯一限流 key（例如 <code>rate_limit:user_123:192.168.1.1</code>），然后调用 Redis 令牌桶服务校验。</li><li><strong>Redis 令牌桶</strong>：用 Lua 脚本实现原子性校验，核心是根据时间戳计算可生成的新令牌数，不足时拒绝请求。比如用户抢优惠券时，同一 IP+ID 每分钟最多 5 次请求，防止恶意刷接口。</li></ul><ol><li><strong>防重复领取</strong>：避免用户短时间内多次点击接口，导致优惠券<strong>超发</strong>；</li><li><strong>保护服务端</strong>：峰值流量时限制请求频率，防止 Redis 或数据库被击穿。线上遇到过同一 WiFi 下多个用户被误限的情况，后来把 key 改为`IP+用户ID，减少了误判率。”</li></ol><p>切面类如何获取注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.example.RateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimitPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;rateLimitPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取方法上的注解</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line">        <span class="type">RateLimit</span> <span class="variable">rateLimit</span> <span class="operator">=</span> method.getAnnotation(RateLimit.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">limitCount</span> <span class="operator">=</span> rateLimit.limitCount();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> rateLimit.time();</span><br><span class="line">        <span class="type">String</span> <span class="variable">keyType</span> <span class="operator">=</span> rateLimit.keyType();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成限流key（IP+用户ID）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> generateKey(joinPoint, keyType);</span><br><span class="line">        <span class="comment">// 调用Redis令牌桶校验</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allow</span> <span class="operator">=</span> redisBucketService.tryAcquire(key, limitCount, time, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">if</span> (!allow) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请求频繁，请稍后再试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么选令牌桶而不是漏桶？</p><p>令牌桶适合突发流量，漏桶适合平滑流量</p><p>使用redis+lua原子的存储令牌桶，使用时间戳来校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 令牌桶Lua脚本（简化版）</span><br><span class="line"><span class="type">local</span> <span class="variable">key</span> <span class="operator">=</span> KEYS[<span class="number">1</span>]  -- 限流key</span><br><span class="line"><span class="type">local</span> <span class="variable">capacity</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">1</span>])  -- 桶容量</span><br><span class="line"><span class="type">local</span> <span class="variable">rate</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">2</span>])  -- 令牌生成速率（个/秒）</span><br><span class="line"><span class="type">local</span> <span class="variable">now</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">3</span>])  -- 当前时间戳</span><br><span class="line"><span class="type">local</span> <span class="variable">requested</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">4</span>])  -- 请求令牌数</span><br><span class="line"></span><br><span class="line">-- 读取上次更新时间和剩余令牌数</span><br><span class="line"><span class="type">local</span> <span class="variable">last</span> <span class="operator">=</span> redis.call(<span class="string">&#x27;hget&#x27;</span>, key, <span class="string">&#x27;last&#x27;</span>)</span><br><span class="line"><span class="type">local</span> <span class="variable">tokens</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;hget&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>) or <span class="number">0</span>)</span><br><span class="line">last = last or now</span><br><span class="line"></span><br><span class="line">-- 计算可生成的新令牌数</span><br><span class="line"><span class="type">local</span> <span class="variable">delta</span> <span class="operator">=</span> now - last</span><br><span class="line"><span class="type">local</span> <span class="variable">newTokens</span> <span class="operator">=</span> math.min(capacity, tokens + delta * rate)</span><br><span class="line"><span class="keyword">if</span> newTokens &gt;= requested then</span><br><span class="line">    -- 够发令牌，更新状态</span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, <span class="string">&#x27;last&#x27;</span>, now)</span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, key, <span class="string">&#x27;tokens&#x27;</span>, newTokens - requested)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  -- 允许访问</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  -- 拒绝访问</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="6-那么优惠劵的发放呢？一些列的问题呢">6.那么优惠劵的发放呢？一些列的问题呢</h2><p>✅ 一、关于优惠券类型的常见问题</p><p>❓1. 如何区分和应用不同类型的优惠券逻辑？</p><p><strong>面试点</strong>：策略模式、优惠金额计算方式。</p><p><strong>答法</strong>：</p><blockquote><p>我们用策略模式来封装每种优惠券的优惠逻辑（如满减、折扣、无门槛）。每种类型对应一个策略类，实现统一的接口方法 <code>calculateDiscount(OrderInfo order)</code>，这样能在运行时动态选择策略，便于扩展和维护。</p></blockquote><hr><p>✅ 二、关于接口设计的追问</p><p>❓2. 为什么接口是这样的？有没有考虑幂等性和安全性？</p><ul><li><code>POST /use</code> 接口可能会被重复调用，是否<strong>幂等</strong>？</li><li>有没有做权限控制，防止其他用户伪造请求？</li></ul><p><strong>答法</strong>：</p><blockquote><p>在使用优惠券时，为防止重复使用，我们使用 Redis + Lua 实现原子操作，同时标记优惠券为“已使用”。此外接口采用登录态校验，验证当前操作用户是否拥有该优惠券。敏感操作都要求用户登录，并记录操作日志。</p></blockquote><hr><p>✅ 三、关于并发处理和限领逻辑</p><p>❓3. 如果多用户并发领取优惠券，如何防止超发？</p><p><strong>答法</strong>：</p><blockquote><p>发放流程中，我们使用 Redis 的 <code>DECR</code> 或 Lua 脚本实现优惠券库存的原子扣减，保证不会发放超过设定数量。同时加锁防止并发条件下库存扣减不一致。</p></blockquote><hr><p>❓4. 如何限制每个用户只能领取一次？</p><p><strong>答法</strong>：</p><blockquote><p>Redis 中设置一个标识键：<code>user:coupon:received:&#123;couponId&#125;:&#123;userId&#125;</code>，发放前先判断这个键是否存在，避免重复发放。也可以结合布隆过滤器提前过滤无效请求。</p></blockquote><hr><p>✅ 四、关于时间与状态校验</p><p>❓5. 限时券怎么判断是否有效？服务端怎么处理时间逻辑？</p><p><strong>答法</strong>：</p><blockquote><p>每张优惠券记录中保存有效时间范围。使用时，服务端比对当前时间是否在有效期内。同时定时任务每天扫描过期优惠券，标记为“已过期”。</p></blockquote><hr><p>✅ 五、关于优惠券使用过程的逻辑判断</p><p>❓6. 使用时如果有多个优惠券，怎么选最优？</p><p><strong>答法</strong>：</p><blockquote><p>前端可以请求一个“推荐最优券”的接口，我们在服务端遍历用户可用券，调用各个策略类计算预期优惠，返回最高优惠金额对应的券。</p></blockquote><hr><p>✅ 六、关于优惠券与订单系统结合问题</p><p>❓7. 如果下单失败了，优惠券是否要恢复？</p><p><strong>答法</strong>：</p><blockquote><p>下单失败（如支付失败、库存不足）时，我们会在事务回滚后将优惠券状态重置为“未使用”。为了避免并发问题，使用分布式事务（如消息队列、TCC）或 Redis 回滚标记。</p></blockquote><hr><p>✅ 七、进阶设计问题</p><p>❓8. 优惠券支持“异步发放”和“定时生效”吗？</p><p><strong>答法</strong>：</p><blockquote><p>是的，可以结合定时任务（如 Quartz 或 Spring Schedule）实现定时发放；发放时间和有效时间字段分离，发放时写入 Redis 延时队列，当生效时间到达时插入到用户优惠券表中。</p></blockquote><hr><p>✅ 八、可能让你设计代码结构的问题</p><p>❓9. 优惠券模块的结构划分是怎样的？</p><p><strong>答法</strong>（示意）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- entity（Coupon, UserCoupon）</span><br><span class="line">- controller（CouponController）</span><br><span class="line">- service（CouponService、UseStrategy接口及实现）</span><br><span class="line">- repository（MyBatis-Plus Mapper）</span><br><span class="line">- util（金额计算工具类）</span><br></pre></td></tr></table></figure><hr><p>✅ 九、安全性问题</p><p>❓10. 用户伪造优惠券 ID，试图套用别人的优惠券怎么办？</p><p><strong>答法</strong>：</p><blockquote><p>每次使用时不仅要校验优惠券 ID 是否存在，还要校验当前登录用户是否是该优惠券持有人，只有归属校验通过才能使用。</p></blockquote><h2 id="7-AOP记录日志">7.AOP记录日志</h2><p>“我们用 AOP 实现了登录日志和业务日志的分类记录，核心设计是：</p><ul><li><p><strong>注解与策略</strong>：定义<code>@Log</code>注解标注需要记录的方法，通过<code>type()</code>参数区分<code>LOGIN</code>和<code>BUSINESS</code>类型。</p></li><li><p><strong>切面逻辑</strong>：拦截方法执行前后，<strong>获取用户信息、操作参数、接口耗时等数据，封装成日志对象</strong>。例如登录日志会记录 IP、设备信息，业务日志会<strong>记录操作类型</strong>（如下单、领券）和参数（如商品 ID、优惠券 ID）。</p></li><li><p><strong>存储优化</strong>：用 Kafka 异步写入日志，避免影响接口性能，再通过 Logstash 同步到 Elasticsearch，方便用 Kibana 按时间、用户 ID 等维度检索。</p></li></ul><p>举个实际场景：用户领取优惠券时，业务日志会记录<code>&#123;user_id:123, operation:&quot;领取满100减20&quot;, params:&#123;coupon_id:567&#125;, cost:87ms&#125;</code>。有次线上发现某个接口耗时突然增加，通过 ELK 检索该接口的日志，很快定位到是参数校验逻辑异常导致的。</p><p>我们对敏感信息做了脱敏处理，比如用户手机号会存成<code>138****5678</code>，既满足日志追溯需求，又符合数据安全规范。”</p><p>存储的信息，使用json进行存储</p><ul><li>登录日志：用户 ID、登录 IP、设备信息、登录时间、状态（成功 / 失败）、失败原因（如密码错误）；</li><li>业务日志：用户 ID、操作类型（如 “领取优惠券”“下单”）、操作内容、操作时间、接口耗时、请求参数（脱敏处理）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;operationLogPointcut()&quot;)</span><span class="comment">//切入点就是注解</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logOperation</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span>  <span class="operator">=</span> ((MethodSignature)joinPoint.getSignature()).getMethod();</span><br><span class="line">        <span class="type">OperationLog</span> <span class="variable">logAnno</span> <span class="operator">=</span> method.getAnnotation(OperationLog.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span>System.currentTimeMillis()-start;</span><br><span class="line"></span><br><span class="line">        <span class="type">LogDTO</span> <span class="variable">log</span> <span class="operator">=</span> buildLog(joinPoint,logAnno.type(),logAnno.action(),duration);</span><br><span class="line">        asyncLogUtils.record(log);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Method获取主机额上的方法，然后建立实体类，设置参数，然后利用DTO传参，然后执行service方法，然后返回，service就是调用log,info</p><p>DTO层负责service和controller直接传输数据</p><h1>6.14模拟面试</h1><h2 id="1-Spring-事务的实现原理是什么？-Transactional-注解在什么情况下会失效？">1.<strong>Spring 事务的实现原理是什么？@Transactional 注解在什么情况下会失效？</strong></h2><p>spring事务的实现原理是基于AOP的动态代理和TransacationInterceptorh还有底层依赖</p><p>AOP：Spring 通过 ProxyFactoryBean 生成代理对象，默认对接口用 JDK 动态代理，对类用 CGLIB 代理；是采用cglib继承目标类的方式去创建代理类，非pulic的方法不能能继承。</p><p>拦截器：核心拦截器，在方法调用前后开启 / 提交 / 回滚事务，基于 ThreadLocal 存储事务状态；基于运行时异常来回滚的，所以把运行时异常给catch或者返回没指定的异常</p><p>底层依赖：通过 PlatformTransactionManager 接口适配不同事务管理器（如 JDBC、JPA）。</p><p>使用ThreadLocal存储事务的状态，（如连接、隔离级别）通过<code>TransactionSynchronizationManager</code>存在线程本地变量，保证线程安全。</p><p>所以基于这个情况,spring事务失效的场景有：</p><p>1.吃掉运行时异常没抛出：</p><p>2.未配置回滚规则，要配置rollbackFor=Exception.class指定类型</p><p>3.调用this</p><p>4.非public方法</p><p>5.事务的传播属性设置为never,not_support这种不支持事务的</p><p>6.调用了不支持事务的数据库</p><p>7.事务嵌套：</p><p><code>REQUIRES_NEW</code> 会挂起外部事务，<strong>提前提交</strong></p><p>嵌套事务用 <code>NESTED</code> 会创建 savepoint，支持回滚子事务（但数据库需支持）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部事务</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">    inner(); <span class="comment">// REQUIRES_NEW</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(); <span class="comment">// 外部异常不会影响 inner 提交的事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 已提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transactional 属性详解:</p><ul><li><code>propagation</code>：传播行为（如 REQUIRED：当前有事务则加入，无则新建）；</li><li><code>isolation</code>：隔离级别（如 READ_COMMITTED 避免脏读）；</li><li><code>timeout</code>：事务超时时间（如<code>timeout=30</code>秒）；</li><li><code>rollbackFor/rollbackForClassName</code>：指定回滚的异常类型；</li><li><code>noRollbackFor/noRollbackForClassName</code>：指定不回滚的异常类型。</li></ul><h2 id="2-Java-中-HashMap-在-JDK1-8-的底层实现是什么？相对于-JDK1-7-做了哪些优化？">2.<strong>Java 中 HashMap 在 JDK1.8 的底层实现是什么？相对于 JDK1.7 做了哪些优化？</strong></h2><p>1.8：数组+链表+红黑树，1.7数组+链表</p><p>尾插头插</p><p>转换条件，&lt;64先扩容</p><p>为什么不用平衡二叉树，</p><p>尾插解决环的问题（线程 A 和线程 B 同时扩容 HashMap，A 处理链表时被挂起，B 完成扩容后，A 继续处理时按头插法插入元素，导致链表成环；）。</p><p>扩容机制 &lt;64先扩容</p><p>哈希算法优化：</p><ul><li>1.7：通过<code>hashCode() ^ (hashCode() &gt;&gt;&gt; 16)</code>扰动函数打散高 16 位，避免低位冲突；</li><li>1.8：直接使用<code>hashCode()</code>，但计算下标时用<code>(n-1) &amp; hash</code>（n 为数组长度，需是 2 的幂），例：</li></ul><p>实战：</p><ul><li><strong>性能提升</strong>：存储 1000 个哈希冲突的键时，1.7 查询需遍历链表（O (1000)），1.8 用红黑树只需 O (log2 (1000))≈10 次查询；</li><li><strong>内存占用</strong>：红黑树节点比链表节点多存储父节点、左右子节点指针，但若哈希冲突少，链表长度 &lt;8 时仍用链表，节省内存。”</li></ul><p>红黑树特点：</p><ol><li>节点非红即黑；</li><li>根节点和叶节点（null）是黑色；</li><li>红色节点不能相邻；</li><li>任意节点到叶节点的路径上黑节点数相同；<br>插入时最多旋转 2 次即可平衡，适合 HashMap 的高频插入场景。</li></ol><p>场景：</p><p>“线上曾遇到 HashMap 性能问题，通过 JProfiler 发现某接口频繁操作哈希冲突严重的 Map，将 JDK1.7 升级到 1.8 后，接口响应时间从 500ms 降至 50ms，主要得益于红黑树对高冲突场景的优化。”</p><h2 id="3-Spring-Bean-的生命周期是怎样的？-PostConstruct-和-PreDestroy-的作用是什么？">3.<strong>Spring Bean 的生命周期是怎样的？@PostConstruct 和 @PreDestroy 的作用是什么？</strong></h2><p>实例化-&gt;初始化-&gt;使用-&gt;销毁</p><p><strong>实例化</strong>：通过构造器创建 Bean 实例（无参构造或工厂方法）；</p><p><strong>属性赋值</strong>：依赖注入（@Autowired、setter 方法等）；</p><p><strong>初始化前</strong>：执行 BeanPostProcessor 的<code>postProcessBeforeInitialization</code>；</p><p>初始化：</p><ol><li>执行 @PostConstruct 标注的方法；</li><li>实现 InitializingBean 接口的<code>afterPropertiesSet</code>；</li><li>自定义 init-method（XML 配置或 @Bean 的 initMethod 属性）；</li></ol><p><strong>初始化后</strong>：执行 BeanPostProcessor 的<code>postProcessAfterInitialization</code>；</p><p><strong>使用</strong>：Bean 放入容器，供应用获取使用；</p><p><strong>销毁前</strong>：执行 @PreDestroy 标注的方法；</p><p>销毁：</p><ol><li>实现 DisposableBean 接口的<code>destroy</code>；</li><li>自定义 destroy-method。</li></ol><p>三级缓存解决循环依赖：</p><p><strong>@PostConstruct 和 @PreDestroy 的执行时机</strong>：</p><p><strong>@PostConstruct</strong>：在依赖注入完成后，初始化方法（如 init-method）之前执行；</p><p><strong>@PreDestroy</strong>：在 Bean 销毁前执行，先于 destroy-method；</p><p>应用场景：</p><ul><li>初始化：数据库连接池初始化、缓存预热；</li><li>销毁：释放资源（关闭文件流、释放锁）。</li></ul><p>关键点：</p><ul><li><strong>BeanPostProcessor</strong>：初始化前后的拦截器（如 AOP 代理在此阶段创建）；</li><li><strong>InstantiationAwareBeanPostProcessor</strong>：属性赋值前的拦截器（可修改属性值）；</li><li><strong>SmartInitializingSingleton</strong>：所有单例 Bean 初始化完成后执行（适合初始化需要依赖其他 Bean 的场景）。</li></ul><p>问题解决：</p><ul><li>问题：ServiceA 依赖 ServiceB，ServiceB 的 @PostConstruct 方法未完成时，ServiceA 已使用 ServiceB；</li><li>解决：通过<code>@DependsOn(&quot;serviceB&quot;)</code>强制 ServiceA 在 ServiceB 之后初始化，或实现<code>Ordered</code>接口指定初始化顺序。”或者是使用懒加载加载一个，或者是重新构建方法</li></ul><h2 id="4-Java-中-synchronized-和-volatile-的区别是什么？各自的应用场景有哪些？">4.<strong>Java 中 synchronized 和 volatile 的区别是什么？各自的应用场景有哪些？</strong></h2><ul><li><p>synchronized：</p><ul><li><strong>原子性</strong>：通过 <strong>Monitor 锁</strong>确保代码块同一时间只能被一个线程执行；</li><li><strong>可见性</strong>：解锁时将工作内存变量刷新到主内存；</li><li><strong>有序性</strong>：通过 happens-before 原则，禁止指令重排（锁的获取 / 释放形成 happens-before 关系）。</li></ul></li><li><p>volatile：</p><ul><li><strong>可见性</strong>：写操作时强制刷新主内存，读操作时强制从主内存读取；</li><li><strong>有序性</strong>：通过内存屏障（Memory Barrier）禁止指令重排，确保 happens-before 关系；</li><li><strong>不保证原子性</strong>：仅保证单次读 / 写操作的原子性，如<code>i++</code>（实际是读 - 改 - 写三步，非原子）。</li></ul></li></ul><p>内存屏障使用的时间：读写屏障，写写屏障，写读屏障</p><p>使用场景：</p><p>s:原子操作，线程安全比如hashtable</p><p>v:状态标记,interput</p><p>联合使用：单例的DCL模式，concurrenthashmap,</p><p>问题：</p><ul><li><strong>问题</strong>：多线程读取配置开关不生效；</li><li><strong>原因</strong>：配置开关未用 volatile 修饰，线程读取的是本地缓存值；</li><li><strong>解决</strong>：<code>volatile boolean configSwitch = false;</code>，修改后立即通知所有线程。</li></ul><h2 id="5-Java-中为什么要使用线程池？线程池如何处理异常？">5.<strong>Java 中为什么要使用线程池？线程池如何处理异常？</strong></h2><p><strong>线程池的核心优势系统化梳理</strong>：</p><ul><li><strong>资源复用</strong>：避免频繁创建销毁线程（创建线程耗时约 3ms，复用可降低开销）；</li><li><strong>控制并发数</strong>：防止并发过高导致的 OOM（如秒杀场景限制线程数保护数据库）；</li><li><strong>统一管理</strong>：统一设置线程名称、优先级，方便日志追踪和故障排查；</li><li><strong>异步处理</strong>：将耗时任务放入线程池，避免主线程阻塞（如日志异步写入）。</li></ul><p>比较单线程，多线程，和线程池</p><p>异常处理：</p><p>使用<code>try-catch</code>包裹任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doTask();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;任务异常&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过<code>Future</code>获取异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    future.get(); <span class="comment">// 阻塞获取结果，抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;任务异常&quot;</span>, e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拒绝策略<code>AbortPolicy</code>会抛出<code>RejectedExecutionException</code>，需在提交任务时捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    executor.execute(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;任务被拒绝&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景：</p><ul><li><strong>电商下单场景</strong>：<br>用线程池异步处理库存扣减、积分计算等耗时任务，主线程快速返回订单创建结果，提升用户体验；</li><li><strong>日志系统</strong>：<br>用线程池异步写入日志到 Kafka，避免 IO 阻塞影响业务接口响应时间。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/11/towork/working1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>瑞吉外卖逻辑分析</title>
      <link>https://blog.tokenlen.top/2025/06/10/workmenu/reggie2/</link>
      <guid>https://blog.tokenlen.top/2025/06/10/workmenu/reggie2/</guid>
      <pubDate>Mon, 09 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;业务&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>业务</h1><h2 id="service">service</h2><p><strong>ShopServiceImpl：</strong></p><p>使用redis设置和查询店铺的状态。redistemplate.opsforvalue.set/get(key)</p><p><strong>AddressBookServiceImpl:</strong></p><p>新增地址，实体类设置字段的值，然后调用mapper的insert方法。</p><p>修改地址，调用updata调用主键去更新方法更新</p><p>设置默认地址，设置默认地址，然后获取当前用户的id，然后在sql中set用于默认地址,where userid。然后更新默认字段 return</p><p>使用LambdaUpdateWrapper去写一个查询条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 将该用户的所有地址设为非默认</span></span><br><span class="line">LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(AddressBook::getUserId, userId).set(AddressBook::getIsDefault, <span class="number">0</span>);</span><br><span class="line">addressBookMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将当前地址设为默认</span></span><br><span class="line">addressBook.setIsDefault(<span class="number">1</span>);</span><br><span class="line">addressBookMapper.updateById(addressBook);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>CategoryServiceImpl：</strong></p><p>新增菜品，新建菜品的实体类，使用beanuntil，拷贝DTO层数据，然后set状态，然后insert</p><p>分类查询，使用pagehelper插件，=.startpage(num,size);</p><p>然后使用Page&lt;&gt;保证菜品类，然后根据模糊匹配进行搜索，然后mapper调用，然后新建一个分页包装的reseponse返回这个数量和结果。</p><p>根据id删除菜品，先mapper查，然后看dishcount字段是不是关联了菜品，关联套餐不能删除，抛出异常。没有的话，就del删除。</p><p>ReportServiceImpl：</p><p>查询，使用一个map来装这个数据，然后返回数据，传入到mapper中的where/if标签里面一般是。</p><p>Mapper XML 中使用 <code>&lt;if test=&quot;xxx != null&quot;&gt;</code> 拼接 where 条件。</p><p>TOPk,还是使用map，但是加上了连表查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT d.name, SUM(od.number) as total_sales</span><br><span class="line">FROM order_detail od</span><br><span class="line">JOIN dish d ON od.dish_id = d.id</span><br><span class="line">GROUP BY d.id</span><br><span class="line">ORDER BY total_sales DESC</span><br><span class="line">LIMIT #&#123;topK&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>SetmealServiceImpl：</strong></p><p>新增套餐，先新建套餐实体类，拷贝dto数据，插入条数据，获取外键，然后获取关联的菜品，设置外键，然后保存。然后mapper里面使用foreach来遍历填写数据</p><p>分页插件查询。</p><p>批量删除套餐，使用foreach,lamda表达式，通过id查找数据，如果套餐的stuse为1.说明在售卖，不能删除，抛出异常。然后通过id删除套餐表中的数据。删除菜品关系表中的数据。</p><p>套餐的启用和停售，判断套餐内是否有停售菜品，有停售菜品的时候不能启用套餐，</p><p>如果是起售状态的话，直接更新为停售</p><p>修改套餐：</p><p>获取实体类对象，然后拷贝dto，然后更新数据。获取外键，删除套餐和菜品的关联关系。设置新的关系。然后重新插入</p><h2 id="controller">controller</h2><p>DishController:</p><p>查询的时候，先从redis中根据key来拿数据，查到缓存的话，就直接返回缓存。没有的话，就从数据库中拿，然后存入redis中。</p><p>查询缓存：注解 <code>@Cacheable</code>，用于 <strong>将方法的返回值缓存起来</strong>，提高查询效率，避免重复查数据库。你这段代码的意思是：<strong>按分类 ID 查询套餐，并将结果缓存</strong>，条件是结果不为空。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/10/workmenu/reggie2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql练习3</title>
      <link>https://blog.tokenlen.top/2025/06/09/mysql/sqltest3/</link>
      <guid>https://blog.tokenlen.top/2025/06/09/mysql/sqltest3/</guid>
      <pubDate>Sun, 08 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础语法回顾&lt;/h1&gt;
&lt;h2 id=&quot;1-SQL110-插入记录（一）&quot;&gt;1.&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础语法回顾</h1><h2 id="1-SQL110-插入记录（一）">1.<a href="https://www.nowcoder.com/practice/5d2a42bfaa134479afb9fffd9eee970c?tpId=240&amp;tqId=2221797&amp;ru=/exam/oj&amp;qru=/ta/sql-advanced/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page"><strong>SQL110</strong> <strong>插入记录（一）</strong></a></h2><p>牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下：</p><ul><li>用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分；</li><li>用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。</li></ul><p>试卷作答记录表exam_record中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Extra</th><th>Default</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>auto_increment</td><td>(NULL)</td><td>自增ID</td></tr><tr><td>uid</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>用户ID</td></tr><tr><td>exam_id</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>试卷ID</td></tr><tr><td>start_time</td><td>datetime</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>开始时间</td></tr><tr><td>submit_time</td><td>datetime</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>提交时间</td></tr><tr><td>score</td><td>tinyint(4)</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>得分</td></tr></tbody></table><p>该题最后会通过执行SELECT uid, exam_id, start_time, submit_time, score FROM exam_record;来对比结果</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into exam_record(uid,exam_id,start_time,submit_time,score) </span><br><span class="line">VALUES (1001,9001,&#x27;2021-09-01 22:11:12&#x27;,&#x27;2021-09-01 23:01:12&#x27; ,90),</span><br><span class="line">(1002,9002,&#x27;2021-09-04 07:01:02&#x27;,null,NULL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照顺序插入即可，注意一一对应</p><ol start="2"><li></li></ol><p>牛客的运营同学想要查看大家在SQL类别中高难度试卷的得分情况。</p><p>请你帮她从exam_record数据表中计算所有用户完成SQL类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p><p>示例数据：examination_info（exam_id试卷ID, tag试卷类别, difficulty试卷难度, duration考试时长, release_time发布时间）</p><table><thead><tr><th>id</th><th>exam_id</th><th>tag</th><th>difficulty</th><th>duration</th><th>release_time</th></tr></thead><tbody><tr><td>1</td><td>9001</td><td>SQL</td><td>hard</td><td>60</td><td>2020-01-01 10:00:00</td></tr><tr><td>2</td><td>9002</td><td>算法</td><td>medium</td><td>80</td><td>2020-08-02 10:00:00</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">示例数据：exam_record（uid用户ID, exam_id试卷ID, start_time开始作答时间, submit_time交卷时间, score得分）iduidexam_idstart_timesubmit_time</span><br><span class="line">score1100190012020-01-02 09:01:012020-01-02 09:21:01</span><br><span class="line">8021001</span><br><span class="line">9001</span><br><span class="line">2021-05-02 10:01:012021-05-02 10:30:01</span><br><span class="line">81310019001</span><br><span class="line">2021-06-02 19:01:01</span><br><span class="line">2021-06-02 19:31:01</span><br><span class="line">84</span><br><span class="line">410019002</span><br><span class="line">2021-09-05 19:01:01</span><br><span class="line">2021-09-05 19:40:0189</span><br><span class="line">51001</span><br><span class="line">90012021-09-02 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">61001</span><br><span class="line">9002</span><br><span class="line">2021-09-01 12:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br><span class="line">710029002</span><br><span class="line">2021-02-02 19:01:01</span><br><span class="line">2021-02-02 19:30:01</span><br><span class="line">87810029001</span><br><span class="line">2021-05-05 18:01:01</span><br><span class="line">2021-05-05 18:59:02909</span><br><span class="line">10039001</span><br><span class="line">2021-09-07 12:01:01</span><br><span class="line">2021-09-07 10:31:01</span><br><span class="line">501010049001</span><br><span class="line">2021-09-06 10:01:01</span><br><span class="line">(NULL)</span><br><span class="line">(NULL)</span><br></pre></td></tr></table></figure><p>根据输入你的查询结果如下：</p><p>题解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT tag, difficulty,</span><br><span class="line">    ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br><span class="line">FROM exam_record</span><br><span class="line">JOIN examination_info USING(exam_id)</span><br><span class="line">WHERE tag = &#x27;SQL&#x27; AND difficulty = &#x27;hard&#x27;</span><br><span class="line">GROUP BY tag, difficulty;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据sql查询的分别出现的列，然后来根据这些列来写</p><p>主要是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUND((SUM(score) - MAX(score) - MIN(score)) / (COUNT(score) - 2), 1) AS clip_avg_score</span><br></pre></td></tr></table></figure><p>这个保留一位小数，计算平均数</p><p>然后使用联合查询</p><p>将examination_info和exam_record连接起来，其主键是exam_id</p><p>然后where条件</p><p>最后可以来个按组排序</p><h2 id="2-SQL200-查找最晚入职员工的所有信息">2.<strong>SQL200</strong> <strong>查找最晚入职员工的所有信息</strong></h2><p>有一个员工employees表简况如下:</p><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr><tr><td>10002</td><td>1964-06-02</td><td>Bezalel</td><td>Simmel</td><td>F</td><td>1985-11-21</td></tr><tr><td>10003</td><td>1959-12-03</td><td>Parto</td><td>Bamford</td><td>M</td><td>1986-08-28</td></tr><tr><td>10004</td><td>1954-05-01</td><td>Christian</td><td>Koblick</td><td>M</td><td>1986-12-01</td></tr><tr><td>10005</td><td>1955-01-21</td><td>Kyoichi</td><td>Maliniak</td><td>M</td><td>1989-09-12’</td></tr><tr><td>10006</td><td>1953-04-20</td><td>Anneke</td><td>Preusig</td><td>F</td><td>1989-06-02</td></tr><tr><td>10007</td><td>1957-05-23</td><td>Tzvetan</td><td>Zielinski</td><td>F</td><td>1989-02-10</td></tr><tr><td>10008</td><td>1958-02-19</td><td>Saniya</td><td>Kalloufi</td><td>M</td><td>1994-09-15</td></tr><tr><td>10009</td><td>1952-04-19</td><td>Sumant</td><td>Peac</td><td>F</td><td>1985-02-18</td></tr><tr><td>10010</td><td>1963-06-01</td><td>Duangkaew</td><td>Piveteau</td><td>F</td><td>1989-08-24</td></tr><tr><td>10011</td><td>1953-11-07</td><td>Mary</td><td>Sluis</td><td>F</td><td>1990-01-22</td></tr></tbody></table><p>请你查找employees里最晚入职员工的所有信息，以上例子输出如下:</p><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10008</td><td>1958-02-19</td><td>Saniya</td><td>Kalloufi</td><td>M</td><td>1994-09-15</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 1;</span><br></pre></td></tr></table></figure><p>easy题目不必多说。</p><h2 id="3-SQL201-查找入职员工时间升序排名的情况下的倒数第三的员工所有信息">3.<strong>SQL201</strong> <strong>查找入职员工时间升序排名的情况下的倒数第三的员工所有信息</strong></h2><p>有一个员工employees表简况如下:</p><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr><tr><td>10002</td><td>1964-06-02</td><td>Bezalel</td><td>Simmel</td><td>F</td><td>1985-11-21</td></tr><tr><td>10003</td><td>1959-12-03</td><td>Parto</td><td>Bamford</td><td>M</td><td>1986-08-28</td></tr><tr><td>10004</td><td>1954-05-01</td><td>Christian</td><td>Koblick</td><td>M</td><td>1986-12-01</td></tr></tbody></table><p>请你查找employees里入职员工时间升序排名的情况下倒数第三的员工所有信息，以上例子输出如下:</p><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr></tbody></table><p>注意：可能会存在同一个日期入职的员工，所以入职员工时间排名倒数第三的员工可能不止一个,存在多个员工的情况按照emp_no升序排列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">DISTINCT</span> hire_date</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span></span><br><span class="line">    limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用子查询，然后去掉倒数第一第二</p><h2 id="4-SQL202-查找当前薪水详情以及部门编号dept-no">4.<strong>SQL202</strong> <strong>查找当前薪水详情以及部门编号dept_no</strong></h2><p>有一个全部员工的薪水表salaries简况如下:</p><table><thead><tr><th>emp_no</th><th>salary</th><th>from_date</th><th>to_date</th></tr></thead><tbody><tr><td>10001</td><td>88958</td><td>2002-06-22</td><td>9999-01-01</td></tr><tr><td>10002</td><td>72527</td><td>2001-08-02</td><td>9999-01-01</td></tr><tr><td>10003</td><td>43311</td><td>2001-12-01</td><td>9999-01-01</td></tr></tbody></table><p>有一个各个部门的领导表dept_manager简况如下:</p><table><thead><tr><th>dept_no</th><th>emp_no</th><th>to_date</th></tr></thead><tbody><tr><td>d001</td><td>10001</td><td>9999-01-01</td></tr><tr><td>d002</td><td>10003</td><td>9999-01-01</td></tr></tbody></table><p>请你查找各个部门当前领导的薪水详情以及其对应部门编号dept_no，输出结果以salaries.emp_no升序排序，并且请注意输出结果里面dept_no列是最后一列，以上例子输出如下:</p><table><thead><tr><th>emp_no</th><th>salary</th><th>from_date</th><th>to_date</th><th>dept_no</th></tr></thead><tbody><tr><td>10001</td><td>88958</td><td>2002-06-22</td><td>9999-01-01</td><td>d001</td></tr><tr><td>10003</td><td>43311</td><td>2001-12-01</td><td>9999-01-01</td><td>d002</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no,e.salary,e.from_date,e.to_date,d.dept_no</span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> e,dept_manager <span class="keyword">as</span> d</span><br><span class="line"><span class="keyword">where</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.emp_no;</span><br></pre></td></tr></table></figure><p>easy的多表查询</p><h2 id="5-SQL42-分析客户逾期情况-middle">5.<strong>SQL42</strong> <strong>分析客户逾期情况</strong>(middle)</h2><p>有贷款信息表：<strong>loan_tb</strong>（agreement_id：合同id，customer_id：客户id，loan_amount：贷款金额，pay_amount：已还金额，overdue_days：逾期天数）</p><table><thead><tr><th>agreement_id</th><th>customer_id</th><th>loan_amount</th><th>pay_amount</th><th>overdue_days</th></tr></thead><tbody><tr><td>10111</td><td>1111</td><td>20000</td><td>18000</td><td>NULL</td></tr><tr><td>10112</td><td>1112</td><td>10000</td><td>10000</td><td>NULL</td></tr><tr><td>10113</td><td>1113</td><td>15000</td><td>10000</td><td>38</td></tr><tr><td>10114</td><td>1114</td><td>50000</td><td>30000</td><td>NULL</td></tr><tr><td>10115</td><td>1115</td><td>60000</td><td>50000</td><td>NULL</td></tr><tr><td>10116</td><td>1116</td><td>10000</td><td>8000</td><td>NULL</td></tr><tr><td>10117</td><td>1117</td><td>50000</td><td>50000</td><td>NULL</td></tr><tr><td>10118</td><td>1118</td><td>25000</td><td>10000</td><td>5</td></tr><tr><td>10119</td><td>1119</td><td>20000</td><td>1000</td><td>106</td></tr></tbody></table><p>客户信息表：<strong>customer_tb</strong>（customer_id：客户id，customer_age：客户年龄，pay_ability：还款能力级别）</p><table><thead><tr><th>customer_id</th><th>customer_age</th><th>pay_ability</th></tr></thead><tbody><tr><td>1111</td><td>28</td><td>B</td></tr><tr><td>1112</td><td>38</td><td>A</td></tr><tr><td>1113</td><td>20</td><td>C</td></tr><tr><td>1114</td><td>30</td><td>A</td></tr><tr><td>1115</td><td>29</td><td>B</td></tr><tr><td>1116</td><td>21</td><td>C</td></tr><tr><td>1117</td><td>35</td><td>B</td></tr><tr><td>1118</td><td>36</td><td>B</td></tr><tr><td>1119</td><td>25</td><td>C</td></tr></tbody></table><p>请根据以上数据分析各还款能力级别的客户逾期情况，按照还款能力级别统计有逾期行为客户占比。要求输出还款能力级别、逾期客户占比。</p><p>注：逾期客户占比要求按照百分数形式输出并四舍五入保留 1 位小数，最终结果按照占比降序排序。</p><p>示例数据结果如下：</p><table><thead><tr><th>pay_ability</th><th>overdue_ratio</th></tr></thead><tbody><tr><td>C</td><td>66.7%</td></tr><tr><td>B</td><td>25.0%</td></tr><tr><td>A</td><td>0.0%</td></tr></tbody></table><p>结果解释：</p><p>还款能力级别为 C 的客户有1113、1116、1119，其中有逾期行为的客户为 1113、1119，故结果为 2/3=66.7%；其他结果同理。</p><p>我去了，对现在的我还是有些难的啊这个题目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select c.pay_ability,</span><br><span class="line">    concat(format(cast(sum(<span class="keyword">case</span> when l.overdue_days is not <span class="literal">null</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end)as real)*<span class="number">100.0</span>/count(DISTINCT c.customer_id),<span class="number">1</span>),<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line"></span><br><span class="line">as overdue_ratio</span><br><span class="line">from customer_tb as c</span><br><span class="line">left join loan_tb as l on c.customer_id=l.customer_id</span><br><span class="line">group by c.pay_ability</span><br><span class="line">order by overdue_ratio desc;</span><br></pre></td></tr></table></figure><p>最主要的就是这个</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(format(<span class="built_in">cast</span>(<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> l.overdue_days <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)<span class="keyword">as</span> <span class="type">real</span>)<span class="operator">*</span><span class="number">100.0</span><span class="operator">/</span><span class="built_in">count</span>(<span class="keyword">DISTINCT</span> c.customer_id),<span class="number">1</span>),<span class="string">&#x27;%&#x27;</span>)</span><br></pre></td></tr></table></figure><p>计算的过程，主要是浮点数的格式话的问题，其他的还好其实。</p><h2 id="6-SQL204-查找所有员工的last-name和first-name以及对应部门编号dept-no">6.<strong>SQL204</strong> <strong>查找所有员工的last_name和first_name以及对应部门编号dept_no</strong></h2><p>有一个员工表，employees简况如下:</p><table><thead><tr><th>emp_no</th><th>birth_date</th><th>first_name</th><th>last_name</th><th>gender</th><th>hire_date</th></tr></thead><tbody><tr><td>10001</td><td>1953-09-02</td><td>Georgi</td><td>Facello</td><td>M</td><td>1986-06-26</td></tr><tr><td>10002</td><td>1964-06-02</td><td>Bezalel</td><td>Simmel</td><td>F</td><td>1985-11-21</td></tr><tr><td>10003</td><td>1959-12-03</td><td>Parto</td><td>Bamford</td><td>M</td><td>1986-08-28</td></tr><tr><td>10004</td><td>1954-05-01</td><td>Christian</td><td>Koblick</td><td>M</td><td>1986-12-01</td></tr></tbody></table><p>有一个部门表，dept_emp简况如下:</p><table><thead><tr><th>emp_no</th><th>dept_no</th><th>from_date</th><th>to_date</th></tr></thead><tbody><tr><td>10001</td><td>d001</td><td>1986-06-26</td><td>9999-01-01</td></tr><tr><td>10002</td><td>d002</td><td>1989-08-03</td><td>9999-01-01</td></tr></tbody></table><p>请你查找所有已经分配部门的员工的last_name和first_name以及dept_no，也包括暂时没有分配具体部门的员工，以上例子如下:</p><table><thead><tr><th>last_name</th><th>first_name</th><th>dept_no</th></tr></thead><tbody><tr><td>Facello</td><td>Georgi</td><td>d001</td></tr><tr><td>Simmel</td><td>Bezalel</td><td>d002</td></tr><tr><td>Bamford</td><td>Parto</td><td>NULL</td></tr><tr><td>Koblick</td><td>Chirstian</td><td>NULL</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.last_name ,e.first_name ,d.dept_no</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_emp <span class="keyword">as</span> d <span class="keyword">on</span> e.emp_no <span class="operator">=</span> d.emp_no;</span><br></pre></td></tr></table></figure><h2 id="7-SQL46-查询培训指定课程的员工信息">7.<strong>SQL46</strong> <strong>查询培训指定课程的员工信息</strong></h2><p>某公司员工信息数据及员工培训信息数据如下：</p><p>员工信息表<strong>staff_tb</strong>(staff_id-员工id，staff_name-员工姓名，staff_gender-员工性别，post-员工岗位类别，department-员工所在部门)，如下所示：</p><table><thead><tr><th>staff_id</th><th>staff_name</th><th>staff_gender</th><th>post</th><th>department</th></tr></thead><tbody><tr><td>1</td><td>Angus</td><td>male</td><td>Financial</td><td>dep1</td></tr><tr><td>2</td><td>Cathy</td><td>female</td><td>Director</td><td>dep1</td></tr><tr><td>3</td><td>Aldis</td><td>female</td><td>Director</td><td>dep2</td></tr><tr><td>4</td><td>Lawson</td><td>male</td><td>Engineer</td><td>dep1</td></tr><tr><td>5</td><td>Carl</td><td>male</td><td>Engineer</td><td>dep2</td></tr><tr><td>6</td><td>Ben</td><td>male</td><td>Engineer</td><td>dep1</td></tr><tr><td>7</td><td>Rose</td><td>female</td><td>Financial</td><td>dep2</td></tr></tbody></table><p>员工培训信息表<strong>cultivate_tb</strong>(info_id-信息id，staff_id-员工id，course-培训课程)，如下所示：</p><p>注：该公司共开设了三门课程，员工可自愿原则性培训0-3项；</p><table><thead><tr><th>info_id</th><th>staff_id</th><th>course</th></tr></thead><tbody><tr><td>101</td><td>1</td><td>course1, course2</td></tr><tr><td>102</td><td>2</td><td>course2</td></tr><tr><td>103</td><td>3</td><td>course1, course3</td></tr><tr><td>104</td><td>4</td><td>course1, course2, course3</td></tr><tr><td>105</td><td>5</td><td>course3</td></tr><tr><td>106</td><td>6</td><td>NULL</td></tr><tr><td>107</td><td>7</td><td>course1, course2</td></tr></tbody></table><p>问题：请查询培训课程course3的员工信息？</p><p>注：只要培训的课程中包含course3课程就计入结果</p><p>要求输出：员工id、姓名，按照员工id升序排序；<br>示例数据结果如下：</p><table><thead><tr><th>staff_id</th><th>staff_name</th></tr></thead><tbody><tr><td>3</td><td>Aldis</td></tr><tr><td>4</td><td>Lawson</td></tr><tr><td>5</td><td>Carl</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.staff_id,s.staff_name</span><br><span class="line"><span class="keyword">from</span> staff_tb <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> cultivate_tb <span class="keyword">as</span> c <span class="keyword">on</span> s.staff_id<span class="operator">=</span>c.staff_id</span><br><span class="line"><span class="keyword">where</span> concat(<span class="string">&#x27;,&#x27;</span>,c.course,<span class="string">&#x27;,&#x27;</span>) <span class="keyword">like</span> <span class="string">&#x27;%course3%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用分隔符来进行模糊匹配，确保只匹配到course3</p><h2 id="8-SQL43-获取指定客户每月的消费额">8.<strong>SQL43</strong> <strong>获取指定客户每月的消费额</strong></h2><p>某金融公司某项目下有如下 2 张表：</p><p>交易表 <strong>trade</strong>（t_id：交易流水号，t_time：交易时间，t_cus：交易客户，t_type：交易类型【1表示消费，0表示转账】，t_amount：交易金额）:</p><table><thead><tr><th>t_id</th><th>t_time</th><th>t_cus</th><th>t_type</th><th>t_amount</th></tr></thead><tbody><tr><td>1</td><td>2022-01-19 03:14:08</td><td>101</td><td>1</td><td>45.0</td></tr><tr><td>2</td><td>2023-02-15 11:22:11</td><td>101</td><td>1</td><td>23.6</td></tr><tr><td>3</td><td>2023-03-19 05:33:22</td><td>102</td><td>0</td><td>350.0</td></tr><tr><td>4</td><td>2023-03-21 06:44:09</td><td>103</td><td>1</td><td>16.9</td></tr><tr><td>5</td><td>2023-02-21 08:44:09</td><td>101</td><td>1</td><td>26.9</td></tr><tr><td>6</td><td>2023-07-07 07:11:45</td><td>101</td><td>1</td><td>1200.0</td></tr><tr><td>7</td><td>2023-07-19 06:04:32</td><td>102</td><td>1</td><td>132.5</td></tr><tr><td>8</td><td>2023-09-19 11:23:11</td><td>101</td><td>1</td><td>130.6</td></tr><tr><td>9</td><td>2023-10-19 04:32:30</td><td>103</td><td>1</td><td>110.0</td></tr></tbody></table><p>客户表 <strong>customer</strong>（c_id：客户号，c_name：客户名称）:</p><table><thead><tr><th>c_id</th><th>c_name</th></tr></thead><tbody><tr><td>101</td><td>Tom</td></tr><tr><td>102</td><td>Ross</td></tr><tr><td>103</td><td>Julie</td></tr><tr><td>104</td><td>Niki</td></tr></tbody></table><p>现需要查询 Tom 这个客户在 2023 年每月的消费金额（按月份正序显示），示例如下：</p><table><thead><tr><th>time</th><th>total</th></tr></thead><tbody><tr><td>2023-02</td><td>50.5</td></tr><tr><td>2023-07</td><td>1200.0</td></tr><tr><td>2023-09</td><td>130.6</td></tr></tbody></table><p>请编写 SQL 语句实现上述需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">    <span class="title function_">DATE_FORMAT</span><span class="params">(t.t_time, <span class="string">&#x27;%Y-%m&#x27;</span>)</span> AS time,</span><br><span class="line">    SUM(t.t_amount) AS total</span><br><span class="line">from</span><br><span class="line">    trade as t</span><br><span class="line">    left join customer as c on t.t_cus = c.c_id</span><br><span class="line">where</span><br><span class="line">    c.c_name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">    AND t.t_type = <span class="number">1</span></span><br><span class="line">    AND <span class="title function_">YEAR</span><span class="params">(t.t_time)</span> = <span class="number">2023</span></span><br><span class="line">GROUP BY</span><br><span class="line">    <span class="title function_">DATE_FORMAT</span><span class="params">(t.t_time, <span class="string">&#x27;%Y-%m&#x27;</span>)</span></span><br><span class="line">ORDER BY</span><br><span class="line">    time;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-查询连续入住多晚的客户信息？">9.<strong>查询连续入住多晚的客户信息？</strong></h2><p>某酒店客房信息数据及某晚入住信息数据如下：</p><p>客房信息表<strong>guestroom_tb</strong>(room_id-房间号,room_type-房间类型,room_price-房间价格)，如下所示：</p><table><thead><tr><th>room_id</th><th>room_type</th><th>room_price</th></tr></thead><tbody><tr><td>1001</td><td>商务标准房</td><td>165</td></tr><tr><td>1002</td><td>家庭套房</td><td>376</td></tr><tr><td>1003</td><td>商务单人房</td><td>100</td></tr><tr><td>1004</td><td>商务单人房</td><td>100</td></tr><tr><td>1005</td><td>商务标准房</td><td>165</td></tr><tr><td>1006</td><td>商务单人房</td><td>100</td></tr><tr><td>1007</td><td>商务标准房</td><td>165</td></tr><tr><td>1008</td><td>家庭套房</td><td>365</td></tr><tr><td>1009</td><td>商务标准房</td><td>165</td></tr></tbody></table><p>入住信息表<strong>checkin_tb</strong>(info_id-信息id.room_id-房间号,user_id-客户id,checkin_time-入住时间,checkout_time-退房时间)，</p><p>该表存储该晚客户入住信息及后续退房信息，如下所示：</p><table><thead><tr><th>info_id</th><th>room_id</th><th>user_id</th><th>checkin_time</th><th>checkout_time</th></tr></thead><tbody><tr><td>1</td><td>1001</td><td>201</td><td>2022-06-12 15:00:00</td><td>2022-06-13 09:00:00</td></tr><tr><td>2</td><td>1001</td><td>202</td><td>2022-06-12 15:00:00</td><td>2022-06-13 09:00:00</td></tr><tr><td>3</td><td>1003</td><td>203</td><td>2022-06-12 14:00:00</td><td>2022-06-14 08:00:00</td></tr><tr><td>4</td><td>1004</td><td>204</td><td>2022-06-12 15:00:00</td><td>2022-06-13 11:00:00</td></tr><tr><td>5</td><td>1007</td><td>205</td><td>2022-06-12 16:00:00</td><td>2022-06-15 12:00:00</td></tr><tr><td>6</td><td>1008</td><td>206</td><td>2022-06-12 19:00:00</td><td>2022-06-13 12:00:00</td></tr><tr><td>7</td><td>1008</td><td>207</td><td>2022-06-12 19:00:00</td><td>2022-06-13 12:00:00</td></tr><tr><td>8</td><td>1009</td><td>208</td><td>2022-06-12 20:00:00</td><td>2022-06-16 09:00:00</td></tr></tbody></table><p>问题：请查询该酒店从6月12日开始连续入住多晚的客户信息？要求输出：客户id、房间号、房间类型、连续入住天数（按照连续入住天数的升序排序，再按照房间号的升序排序，再按照客户id的降序排序）示例数据结果如下：user_idroom_idroom_typedays2031003商务单人房22051007商务标准房32081009商务标准房4解释：以客户203为例，在2022-06-12入住酒店，在2022-06-14退房，连续在12日晚、13日晚入住在该酒店，故结果如上；其他结果同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select c.user_id,c.room_id,g.room_type,</span><br><span class="line">datediff(c.checkout_time, c.checkin_time) as days</span><br><span class="line">from guestroom_tb as g</span><br><span class="line">join checkin_tb as c on g.room_id = c.room_id</span><br><span class="line">where <span class="title function_">date</span><span class="params">(c.checkin_time)</span> =<span class="string">&#x27;2022-06-12&#x27;</span> </span><br><span class="line">and <span class="title function_">datediff</span><span class="params">(c.checkout_time, c.checkin_time)</span>&gt;=<span class="number">2</span></span><br><span class="line">order by days ASC,c.room_id,c.user_id desc;</span><br></pre></td></tr></table></figure><p>这个题目主要是时间函数的使用</p><h2 id="10-SQL45-统计所有课程参加培训人次">10.<strong>SQL45</strong> <strong>统计所有课程参加培训人次</strong></h2><p>某公司员工培训信息数据如下：</p><p>员工培训信息表<strong>cultivate_tb</strong>(info_id-信息id,staff_id-员工id,course-培训课程)，如下所示：</p><p>注：该公司共开设了三门课程，员工可自愿原则性培训0-3项，每项课程每人可培训1次。</p><table><thead><tr><th>info_id</th><th>staff_id</th><th>course</th></tr></thead><tbody><tr><td>101</td><td>1</td><td>course1,course2</td></tr><tr><td>102</td><td>2</td><td>course2</td></tr><tr><td>103</td><td>3</td><td>course1,course3</td></tr><tr><td>104</td><td>4</td><td>course1,course2,course3</td></tr><tr><td>105</td><td>5</td><td>course3</td></tr><tr><td>106</td><td>6</td><td>NULL</td></tr><tr><td>107</td><td>7</td><td>course1,course2</td></tr></tbody></table><p>问题：请统计该公司所有课程参加培训人次？</p><p>示例数据结果如下：</p><table><thead><tr><th>staff_nums</th></tr></thead><tbody><tr><td>11</td></tr></tbody></table><p>解释：course1课程共有员工1、3、4、7共4名员工培训；</p><p>course2课程共有员工1、2、4、7共4名员工培训；</p><p>course3课程共有员工3、4、5共3名员工培训。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">    <span class="title function_">SUM</span><span class="params">(CONCAT(<span class="string">&#x27;,&#x27;</span>, c.course, <span class="string">&#x27;,&#x27;</span>)</span> LIKE <span class="string">&#x27;%,course1,%&#x27;</span>) +</span><br><span class="line">    SUM(CONCAT(<span class="string">&#x27;,&#x27;</span>, c.course, <span class="string">&#x27;,&#x27;</span>) LIKE <span class="string">&#x27;%,course2,%&#x27;</span>) +</span><br><span class="line">    SUM(CONCAT(<span class="string">&#x27;,&#x27;</span>, c.course, <span class="string">&#x27;,&#x27;</span>) LIKE <span class="string">&#x27;%,course3,%&#x27;</span>) AS staff_nums</span><br><span class="line">FROM </span><br><span class="line">    cultivate_tb c;</span><br></pre></td></tr></table></figure><p>更具性价比的方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/09/mysql/sqltest3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>shopping项目文档面试八股</title>
      <link>https://blog.tokenlen.top/2025/06/07/doc/shopping-mengnankk/</link>
      <guid>https://blog.tokenlen.top/2025/06/07/doc/shopping-mengnankk/</guid>
      <pubDate>Fri, 06 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;JWT+双token+双拦截器登录校验&lt;/h1&gt;
&lt;p&gt;项目文件:&lt;/p&gt;
&lt;p&gt;JwtConfig.java JWT配置类&lt;/p&gt;
&lt;p&gt;SecurityConfig.java 安全请求放行文件&lt;/p&gt;
&lt;p&gt;UserController.java</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>JWT+双token+双拦截器登录校验</h1><p>项目文件:</p><p>JwtConfig.java JWT配置类</p><p>SecurityConfig.java 安全请求放行文件</p><p>UserController.java controller请求层</p><p>JwtAuthenticationFilter.java JWT过滤器</p><p>UserServiceImpl.java 具体的方法实现</p><h1>swagger文档</h1><h1>优惠劵</h1><h1>视频处理</h1><h1>redis限流</h1>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/07/doc/shopping-mengnankk/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库原理期末考试复习</title>
      <link>https://blog.tokenlen.top/2025/06/07/lastteam/sqltest/</link>
      <guid>https://blog.tokenlen.top/2025/06/07/lastteam/sqltest/</guid>
      <pubDate>Fri, 06 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础知识&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础知识</h1><h2 id="关系代数">关系代数</h2><p>关系代数就是：一种抽象的查询语言用对关系的运算来表达查询</p><p>关系看上去像一张二维表，每个表由行和列组成</p><p>行代表一个元组，即<strong>数据记录</strong>。列代表属性，即<strong>字段</strong></p><p>关系的域为一组原子值（不可再分割的值）</p><p>关系中的元组必须各不相同（元组的唯一性）</p><h3 id="符号表示">符号表示</h3><p>元组 t 与 t[Ai] ：</p><p>t 就是一行数据，t[Ai] 就是这一行中某一列的值。</p><p>假设表 R 结构是：</p><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th></tr></thead><tbody><tr><td>101</td><td>张三</td><td>20</td></tr></tbody></table><ul><li>这一行是一个元组 t。</li><li><code>t[学号] = 101</code>，<code>t[姓名] = 张三</code>，<code>t[年龄] = 20</code></li></ul><p>属性组 A、t[A]、Ā ：</p><p>表 R：</p><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th><th>班级</th></tr></thead><tbody><tr><td>101</td><td>张三</td><td>20</td><td>A1</td></tr></tbody></table><ul><li>如果我们说 A = {学号, 姓名}，那：<ul><li><code>t[A] = (101, 张三)</code></li><li>Ā = {年龄, 班级}</li></ul></li></ul><p>元组连接 tr ⨝ ts ：</p><p>表 R（学生）：</p><table><thead><tr><th>学号</th><th>姓名</th></tr></thead><tbody><tr><td>101</td><td>张三</td></tr></tbody></table><p>表 S（成绩）：</p><table><thead><tr><th>课程</th><th>成绩</th></tr></thead><tbody><tr><td>数学</td><td>95</td></tr></tbody></table><p>将 <code>tr ∈ R</code> 和 <code>ts ∈ S</code> 连接（拼接）起来：</p><p>→ 结果元组为：</p><table><thead><tr><th>学号</th><th>姓名</th><th>课程</th><th>成绩</th></tr></thead><tbody><tr><td>101</td><td>张三</td><td>数学</td><td>95</td></tr></tbody></table><p>象集 Zx：</p><p>表 R：</p><table><thead><tr><th>班级</th><th>姓名</th><th>成绩</th></tr></thead><tbody><tr><td>A1</td><td>张三</td><td>90</td></tr><tr><td>A1</td><td>李四</td><td>85</td></tr><tr><td>B1</td><td>王五</td><td>88</td></tr></tbody></table><ul><li>X = {班级}，Z = {姓名}</li><li>那么 A1 班的象集 Zx 是：</li></ul><p>→ <code>Zx = &#123;张三, 李四&#125;</code></p><p>意思是：在班级是 A1 时，姓名有哪些？这就是象集。</p><h3 id="五种基本运算">五种基本运算</h3><p>并，差，笛卡尔积，选择，投影</p><p>关系代数是用对关系的运算来表达查询，这个时候可以使用关系代数解释器来模拟关系代数。</p><p>其中否定操作要使用差的形式</p><h4 id="并">并</h4><p>运算符<strong>∪</strong></p><p>并运算将两个关系的所有元组合并为一个新关系，前提是两个关系必须有<strong>相同的属性</strong>（列），且每个元组在结果中只出现一次（去重）。</p><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>3</td><td><strong>4</strong></td></tr></tbody></table><p><code>R1 ∪ R2</code> 的结果是：s</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table><p>相当于<strong>增加行</strong></p><h4 id="差">差</h4><p><strong>运算符</strong>：<code>-</code></p><p>差运算<strong>返回一个关系中有而另一个关系中没有的元组</strong>，前提是两个关系有相同的属性。</p><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr></tbody></table><p><code>R1 - R2</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr></tbody></table><p>相当于<strong>删减行</strong></p><h4 id="笛卡尔积">笛卡尔积</h4><p><strong>运算符</strong>：<code>×</code></p><p>笛卡尔积运算将两个关系中的每一对元组组合成一个新的元组，其中一个关系的所有元组与另一个关系的每个元组组合形成一个新的元组。它的结果是一个新关系，包含了<strong>两个关系中所有属性的组合</strong>。</p><p><strong>两个集合相乘的结果</strong></p><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(C, D)</p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p><code>R1 × R2</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td><td>6</td></tr><tr><td>1</td><td>2</td><td>7</td><td>8</td></tr><tr><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>3</td><td>4</td><td>7</td><td>8</td></tr></tbody></table><p>相当于<strong>增加列</strong></p><h4 id="选择">选择</h4><p><strong>运算符</strong>：<code>σ</code></p><p>选择运算用于从关系中选择满足特定条件的元组。选择操作是一种<strong>过滤</strong>操作，它根据指定的条件返回满足条件的元组。</p><p>R(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p><code>σ(A &gt; 4)(R)</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p>相当于<strong>过滤</strong></p><h4 id="投影">投影</h4><p><strong>运算符</strong>：<code>π</code></p><p>投影运算用于从关系中选择指定的列（属性）。它会<strong>返回包含指定列的所有元组，并且会去除重复的元组</strong>。</p><p>R(A, B, C)</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr></tbody></table><p><code>π(A, B)(R)</code> 的结果是：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>4</td><td>5</td></tr><tr><td>7</td><td>8</td></tr></tbody></table><p>相当于<strong>删减列</strong></p><h4 id="连接">连接</h4><p><strong>运算符</strong>：<code>⨝</code></p><p>连接是将两个关系中的元组按照某些共享的属性进行组合，生成新的元组。它是关系代数中非常重要的运算，因为它能够合并来自不同表的数据。连接运算通常是基于一个公共的列（或多个列）进行的。</p><p><strong>自然连接（Natural Join）</strong>：在自然连接中，连接操作自动寻找两个关系中相同名称的列，并将它们作为连接条件。**自然连接将仅返回匹配的元组，并去除重复的列。**相当于内连接</p><p><strong>等值连接（Equi-Join）</strong>：等值连接是指使用等号（<code>=</code>）作为连接条件，将两个关系中某个或某些列的值相等的元组合并。</p><p><strong>外连接（Outer Join）</strong>：外连接除了返回两个关系中匹配的元组外，还会保留在其中一个关系中没有匹配的元组，并用<code>NULL</code>填充缺失的值。外连接有三种类型：</p><ul><li><strong>左外连接（Left Outer Join）</strong>：返回左表中所有元组，以及右表中匹配的元组。<strong>右边的补充null</strong></li><li><strong>右外连接（Right Outer Join）</strong>：返回右表中所有元组，以及左表中匹配的元组。<strong>左边的补充null</strong></li><li><strong>全外连接（Full Outer Join）</strong>：返回两个表中的所有元组，不论它们是否匹配。都补充null</li></ul><p>R1(A, B)</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><p>R2(B, C)</p><table><thead><tr><th>B</th><th>C</th></tr></thead><tbody><tr><td>2</td><td>5</td></tr><tr><td>4</td><td>6</td></tr></tbody></table><p>如果我们进行自然连接：<code>R1 ⨝ R2</code>，连接条件是属性<code>B</code>，结果会是：</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>5</td></tr><tr><td>3</td><td>4</td><td>6</td></tr></tbody></table><h4 id="除">除</h4><p><strong>运算符</strong>：<code>÷</code></p><p>除操作用于解决“对于所有”这种类型的查询问题，通常用于查找在某个关系中与所有其他元组匹配的元组。除运算的结果是返回那些“<strong>满足某个条件的所有值</strong>”的元组。</p><p>R1(Student, Course)</p><table><thead><tr><th>Student</th><th>Course</th></tr></thead><tbody><tr><td>Alice</td><td>Math</td></tr><tr><td>Alice</td><td>English</td></tr><tr><td>Bob</td><td>Math</td></tr><tr><td>Bob</td><td>History</td></tr><tr><td>Charlie</td><td>Math</td></tr></tbody></table><p>R2(Course)</p><table><thead><tr><th>Course</th></tr></thead><tbody><tr><td>Math</td></tr><tr><td>English</td></tr></tbody></table><p><code>R1 ÷ R2</code> 的结果是：</p><table><thead><tr><th>Student</th></tr></thead><tbody><tr><td>Alice</td></tr></tbody></table><p>相当于<strong>找到某值</strong></p><h2 id="E-R图">E-R图</h2><p>E-R图向关系模型的转换<br>转换内容<br>E-R图由<strong>实体型、实体的属性和实体型之间的联系</strong>三个要素组成<br>关系模型的逻辑结构是一组关系模式的集合<br>将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式</p><table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody><tr><td><strong>实体（Entity）</strong></td><td>用矩形表示，转换为一个<strong>关系（表）</strong></td></tr><tr><td><strong>属性（Attribute）</strong></td><td>用椭圆表示，转换为<strong>字段（列）</strong></td></tr><tr><td><strong>联系（Relationship）</strong></td><td>用菱形表示，转换为表或外键，依赖于联系的<strong>类型</strong></td></tr></tbody></table><p>E-R 图信息：</p><ul><li>实体：学生(Student)：SID, Name</li><li>实体：课程(Course)：CID, Title</li><li>关系：选修(Takes)，多对多，属性：成绩(Grade)</li></ul><p>转换关系模型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student(SID <span class="keyword">PRIMARY</span> KEY, Name)</span><br><span class="line">Course(CID <span class="keyword">PRIMARY</span> KEY, Title)</span><br><span class="line">Takes(SID <span class="keyword">FOREIGN</span> KEY, CID <span class="keyword">FOREIGN</span> KEY, Grade, <span class="keyword">PRIMARY</span> KEY(SID, CID))</span><br></pre></td></tr></table></figure><p>在E-R图中，i代表弱实体</p><h2 id="sql语句">sql语句</h2><h2 id="锁">锁</h2><h1>重点题目</h1><h2 id="关系代数-2">关系代数</h2><p>做关系代数的题目的时候</p><p>投影等于select 需要筛选出来的列，然后选择是去做where的条件的</p><p>一般都是先用总的连接起来的大表去除select的小表，然后再进行筛选</p><h2 id="关系模式">关系模式</h2><table><thead><tr><th>概念</th><th>定义</th></tr></thead><tbody><tr><td><strong>关系（Relation）</strong></td><td>一张二维表，表名表示关系名。</td></tr><tr><td><strong>属性（Attribute）</strong></td><td>表中的一列，表示一个字段或特征，对应关系模型中的“列”。</td></tr><tr><td><strong>元组（Tuple）</strong></td><td>表中的一行，表示一个实体或记录，对应关系模型中的“行”。</td></tr><tr><td><strong>域（Domain）</strong></td><td>每个属性值的取值范围。例如：性别字段的域是 {男, 女}，年龄的域是整数 [0, 120]。</td></tr><tr><td><strong>主码（Primary Key）</strong></td><td>表中<strong>唯一标识元组的属性集合</strong>，要求唯一且非空。例如：学生表的学号、员工表的工号。</td></tr></tbody></table><p>1.关于系、学生、班级、学会等信息的关系数据库设计</p><table><thead><tr><th>关系名</th><th>属性</th></tr></thead><tbody><tr><td>学生 S(SNO, SN, SB, DN, CNO, SA)</td><td>学号、姓名、出生年月、系名、班号、宿舍区</td></tr><tr><td>班级 C(CNO, CS, DN, CNUM, CDATE)</td><td>班号、专业名、系名、人数、入校年份</td></tr><tr><td>系 D(DNO, DN, DA, DNUM)</td><td>系号、系名、办公室地点、人数</td></tr><tr><td>学会 P(PN, DATE1, PA, PNUM)</td><td>学会名、成立时间、地点、人数</td></tr><tr><td>学生-学会 SP(SNO, PN, DATE2)</td><td>学号、学会名、入会年份</td></tr></tbody></table><p>有关语义如下：一个系有若干专业，每个专业每年只招一个班，每个班有若干学生。一个系的学生住在同一宿舍区。每个学生可参加若干学会，每个学会有若干学生。学生参加某学会有一个入会年份。</p><p>极小依赖集：学生表，Sno-&gt;Sn,SN,DN</p><p>DN-&gt;SA CNO-&gt;DN</p><p>所以传递依赖为Sno-&gt;SA</p><p>班级表：</p><p>CNO-&gt;CS,CNUM,CDATE</p><p>CS-&gt;DN</p><p>(CS,CDATE)-&gt;CNO</p><p><code>(CS, CDATE) → CNO</code> 是<strong>完全函数依赖</strong></p><p>系表：</p><p>DNO-&gt;DN,DNUM DA DN-&gt;DNO</p><p>学会表:</p><p>PN-&gt;确定剩下的那三</p><p>学生-学会:</p><p>(SNO,PN)-&gt;DATE2</p><p>2.关系模式R(U,F)中：U= ABCDE, F={AD→BC,B→C }<br>求：<br>(1) F的最小函数依赖集<br>(2) R的候选码<br>（3）R达到第几范式，为什么？<br>（4）将其转换为3NF（写明分解后各关系模式的侯选码，外码）</p><p><strong>最小依赖集需要满足三点：</strong></p><ul><li>每个依赖右边只有一个属性（右部<strong>原子化</strong>）</li><li>左部不能约简（<strong>左部最小</strong>）</li><li>没有冗余依赖（<strong>去冗余</strong>）</li></ul><p>Fmin = { AD → B, B → C }</p><p>就是先拆分，然后去掉一个重复的</p><p>找出那些属性集的闭包等于全体属性 {A, B, C, D, E}<br><strong>候选码定义：闭包等于所有属性，且不能再删属性</strong></p><p>候选码是 {A, D, E}</p><p>感觉这个就是最小依赖集加上那个不在的就是候选码</p><p>R 属于第几范式？为什么？：</p><p>先列出最小依赖集：Fmin = { AD → B, B → C }</p><p>然后看候选码，{A, D, E}</p><p>发现最小依赖集里面有个不在候选码的，所以只是符合1NF,1NF就是最小依赖集</p><p>分解为 3NF（说明每个子关系的候选码和外键）：</p><p>也是根据候选码跟最小依赖集决定的</p><table><thead><tr><th>子关系</th><th>属性</th><th>候选码</th><th>外键说明</th></tr></thead><tbody><tr><td>R1</td><td>A, D, B</td><td>AD</td><td>AD 是外键指向 R3</td></tr><tr><td>R2</td><td>B, C</td><td>B</td><td>B 是外键指向 R1/R3</td></tr><tr><td>R3</td><td>A, D, E</td><td>ADE</td><td>无</td></tr></tbody></table><p>就是分开的最小依赖集+候选码</p><p>关系 R(A, B, C, D, E) 的函数依赖分析:</p><p>是一种 <strong>比 3NF 更严格的数据库规范化形式</strong>，主要用于<strong>消除函数依赖引起的冗余</strong>，保证关系模式的设计更加规范。</p><p>任何一个决定因素（左部）都<strong>必须是超码</strong>(是或者包含候选码)，否则就不满足 BCNF。</p><p>若 A 是候选码，BC → DE，什么条件下 R 是 BCNF？</p><p>当 <code>BC</code> 是（或包含）候选码时，<code>BC → DE</code> 才不违反 BCNF。</p><p>如果存在依赖：A-→B，BC-→D，DE-&gt;A，列出R的所有码：</p><p>闭包：</p><p>A⁺ = {A, B}</p><p>BC⁺ = {B, C, D}</p><p>DE⁺ = {D, E, A, B} （由 DE → A → B）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCE⁺ = &#123;B, C, E&#125; → D → A → 全部</span><br><span class="line">ACE⁺ = A → B，C，E，D → 全部</span><br></pre></td></tr></table></figure><p>所以候选码有：<strong>ACE</strong>, <strong>BCE</strong>, <strong>DEC</strong></p><p>如果存在依赖：A-→B，BC-&gt;D，DE→A，R属手3NF还是BCNF：</p><p>A {A B}</p><p>BC {B C D}</p><p>DE {A B D E}</p><p>所有依赖左部（A, BC, DE）都不包含候选码<strong>但其右部都为主属性</strong></p><p>所有属性均出现在候选码中 ⇒ 都是主属性</p><h2 id="数据库安全性">数据库安全性</h2><p>1.什么是数据库的安全性:</p><p>数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。数据库的安全性指的是防止<strong>未经授权的访问与操作</strong>，确保数据不会被非法读取、修改、删除或破坏。</p><p>2.表结构如下：</p><p>学生(学号, 姓名, 年龄, 性别, 家庭住址, 班级号)<br>班级(班级号, 班级名, 班主任, 班长)</p><p>授予用户 <code>U1</code> 对两个表拥有<strong>全部权限</strong>，并允许其<strong>再授权</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileger <span class="keyword">on</span> 学生 <span class="keyword">to</span> U1 <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> 班级 <span class="keyword">TO</span> U1 <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>grant all privileger on 学生 to U1 with grant option</p><p>授予用户2</p><ul><li>对 <strong>学生表</strong>具有<strong>查询权限</strong></li><li>对字段 <strong>家庭住址</strong> 具有<strong>更新权限</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grant select on 学生 to U2;</span><br><span class="line">grant update(家庭住址) on 学生 to U2;</span><br><span class="line">GRANT SELECT ON 学生 TO U2;</span><br><span class="line">GRANT UPDATE (家庭住址) ON 学生 TO U2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>授予<strong>所有用户</strong>对班级表的<strong>查询权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on 班级 to public;</span><br></pre></td></tr></table></figure><p>授予角色 <code>R1</code> 对学生表的<strong>查询和更新权限</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select,update on 学生 to R1;</span><br></pre></td></tr></table></figure><p>将角色 <code>R1</code> 授予用户 <code>U1</code>，并允许 <code>U1</code> 再授权该角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant R1 to U1 with admin option;</span><br></pre></td></tr></table></figure><h2 id="数据库完整性">数据库完整性</h2><p>1.什么是数据库的完整性</p><p>数据库的完整性是指数据的正确性和相容性,<strong>正确性、一致性和可靠性</strong>。它保证数据库中的数据符合逻辑规则、业务约束。</p><p>2.数据库的完整性和数据库的安全性有什么区别和联系？</p><p>答：数据的完整性和安全性是两个不同的概念，但是有一定的联系。前者是为了<strong>防止数据库中存在不符合语义的数据</strong>，防止错误信息的输入和输出，即所谓垃圾进垃圾出（Garbage InGarbageOut）所造成的无效操作和错误结果：后者是保护数据库防止恶意的破坏和非法的</p><p>3.有下面的这些消息完成下面的问题：</p><ol><li><strong>职工</strong>（职工号，姓名，年龄，职务，工资，部门号）<ul><li>其中 <strong>职工号</strong> 为主码</li></ul></li><li><strong>部门</strong>（部门号，名称，经理名，电话）<ul><li>其中 <strong>部门号</strong> 为主码</li></ul></li></ol><p>请用 <strong>SQL</strong> 语言定义这两个关系模式，并在定义中完成以下<strong>完整性约束条件</strong>：</p><ol><li>定义每个关系模式的 <strong>主码</strong></li><li>定义 <strong>参照完整性约束</strong>（即外键约束）</li><li>要求职工的 <strong>年龄不得超过60岁</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">crete table dept（</span><br><span class="line">Deptno  NUMBER(2) PRIMARY KEY, </span><br><span class="line">Deptname varchar(10),</span><br><span class="line">Deptmannger varchar(10),</span><br><span class="line">DeptPhone char(12)</span><br><span class="line">）;</span><br><span class="line">crete table Emp(</span><br><span class="line">EMPno NUMBER(2) PRIMART KEY,</span><br><span class="line">EMPname varchar(10),</span><br><span class="line">EMPage NUMBER(2),</span><br><span class="line">EMPjob varchar(10),</span><br><span class="line">EMPSALE NUMBER(7,2),</span><br><span class="line">DeptNO NUMBER(2),</span><br><span class="line"></span><br><span class="line">constartint c1 check (EMPage&lt;=60),</span><br><span class="line">constartint FK_DEPTNO foreign key (deptno) references dept(Deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="数据库恢复">数据库恢复</h2><p>1.试述事务的概念及事务的4个特性。恢复技术能保证事务的哪些特性？</p><p>ACID：</p><p>原子性，一致性，隔离性，持久性</p><p>原子性：事务的方法要么全部执行，要么全部不执行回滚</p><p>一致性：事务操作前后，数据库保持一致性</p><p>隔离性：多个事务并发的时候，相互不干扰</p><p>持久性：事务一旦<strong>提交成功</strong>，对数据库的变更就是<strong>永久性的</strong>，即使系统崩溃也不会丢失。</p><p>故障恢复保证了原子性和持久性</p><p>2.事务的回滚和重做</p><p><strong>已提交事务 → 需要重做（Redo）</strong></p><p><strong>未提交事务 → 需要回滚（Undo）</strong></p><table><thead><tr><th>日志序号</th><th>内容</th><th>事务状态变化</th></tr></thead><tbody><tr><td>1</td><td>T1 开始</td><td>T1 active</td></tr><tr><td>2</td><td>T1 写 A=10</td><td></td></tr><tr><td>3</td><td>T2 开始</td><td>T2 active</td></tr><tr><td>4</td><td>T2 写 B=9</td><td></td></tr><tr><td>5</td><td>T1 写 C=11</td><td></td></tr><tr><td>6</td><td>T1 提交</td><td>✅ T1 committed</td></tr><tr><td>7</td><td>T2 写 C=13</td><td></td></tr><tr><td>8</td><td>T3 开始</td><td>T3 active</td></tr><tr><td>9</td><td>T3 写 A=8</td><td></td></tr><tr><td>10</td><td>T2 回滚</td><td>❌ T2 aborted</td></tr><tr><td>11</td><td>T3 写 B=7</td><td></td></tr><tr><td>12</td><td>T4 开始</td><td>T4 active</td></tr><tr><td>13</td><td>T3 提交</td><td>✅ T3 committed</td></tr><tr><td>14</td><td>T4 写 C=12</td><td></td></tr></tbody></table><p>回滚就是不提交，提交了才算修改</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      <category domain="https://blog.tokenlen.top/categories/408/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/sql/">sql</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/07/lastteam/sqltest/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络面试题hot2</title>
      <link>https://blog.tokenlen.top/2025/06/05/network/net4/</link>
      <guid>https://blog.tokenlen.top/2025/06/05/network/net4/</guid>
      <pubDate>Wed, 04 Jun 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;网络模型&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>网络模型</h1><h2 id="1-网络OSI模型和TCP-IP模型分别介绍一下">1.网络OSI模型和TCP/IP模型分别介绍一下</h2><blockquote><p>OSI七层模型</p></blockquote><p>为了使得多种设备能通过网络相互通信，和为了<strong>解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型</strong>（<em>Open System Interconnection Reference Model</em>），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721097268006-12c71992-11b3-4a8e-9d05-35ad3e0ab86e.png" alt="img"></p><p>每一层负责的职能都不同，如下：</p><ul><li>应用层，负责给应用程序提供统一的接口；</li><li>表示层，负责把<strong>数据转换成兼容另一个系统能识别的格式</strong>；</li><li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li><li>传输层，负责端到端的数据传输；</li><li>网络层，负责数据的路由、转发、分片；</li><li>数据链路层，负责<strong>数据的封帧和差错检测</strong>，以及 MAC 寻址；</li><li>物理层，负责在物理网络中传输数据帧；</li></ul><p>由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。</p><p>事实上，我们比较常见，也比较实用的是<strong>四层模型</strong>，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。</p><blockquote><p>TCP/IP模型</p></blockquote><p>TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721097233614-f7cd6378-32d9-4cb8-9e60-e70b95bb3759.png" alt="img"></p><ul><li>应用层 支持 HTTP、SMTP 等最终用户进程</li><li>传输层 处理主机到主机的通信（TCP、UDP）</li><li>网络层 寻址和路由数据包（IP 协议）</li><li>链路层 通过网络的物理电线、电缆或无线信道移动比特</li></ul><h1>HTTP</h1><h2 id="1-HTTP报文有哪些部分？">1.HTTP报文有哪些部分？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1721710466863-78bf586d-a25c-4fe4-bf27-5dd576b998c8.png" alt="img"></p><p>分请求报文和响应报文来说明。</p><p><strong>请求报文：</strong></p><ul><li>请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。</li><li>请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。</li><li>空行：请求头部和请求体之间用空行分隔。</li><li>请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。</li></ul><p>一般是20个字节吧，请求头的长度</p><p><strong>响应报文：</strong></p><ul><li>状态行：包含HTTP协议版本、状态码和状态信息。</li><li>响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。</li><li>空行：响应头部和响应体之间用空行分隔。</li><li>响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容</li></ul><h2 id="2-HTTP常用的状态码？">2.HTTP常用的状态码？</h2><p>HTTP 状态码分为 5 大类</p><ul><li>1xx 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li><li>2xx 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</li><li>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li><li>4xx 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li><li>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li></ul><p>其中常见的具体状态码有：</p><ul><li>200：请求成功；</li><li>301：永久重定向；302：临时重定向；</li><li>404：无法找到此页面；405：请求的方法类型不支持；</li><li>500：服务器内部出错。</li></ul><h2 id="3-HTTP返回状态301-302分别是什么？">3.HTTP返回状态301 302分别是什么？</h2><p>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明<strong>请求的资源已经不存在了</strong>，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明<strong>请求的资源还在，但暂时需要用另一个 URL 来访问</strong>。</li></ul><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><h2 id="4-http-502和-504-的区别？">4.http 502和 504 的区别？</h2><ul><li>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从<strong>上游服务器接收到无效的响应</strong>。</li><li>504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，<strong>未能及时从上游服务器收到响应</strong>。</li></ul><p>举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（tomcat 等）。</p><ul><li>当nginx收到了无效的响应时，就返回502。</li><li><strong>当nginx超过自己配置的超时时间，还没有收到请求时</strong>，就返回504错误。</li></ul><h2 id="5-HTTP层请求的类型有哪些？">5.HTTP层请求的类型有哪些？</h2><ul><li>GET：用于请求获取指定资源，通常用于获取数据。</li><li>POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</li><li>PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。</li><li>DELETE：用于请求服务器删除指定资源。</li><li>HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</li></ul><h2 id="6-GET和POST的使用场景，有哪些区别？">6.GET和POST的使用场景，有哪些区别？</h2><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，<strong>所以 GET 请求的参数只允许 ASCII 字符</strong> ，而且**浏览器会对 URL 的长度有限制（**HTTP协议本身对 URL长度并没有做任何规定）。</p><p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</p><p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，<strong>body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</strong></p><p>比如，你在我文章底部，敲入了留言后点击「提交」（<strong>暗示你们留言</strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</p><p>如果从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p><ul><li>可以用 GET 方法<strong>实现新增或删除数据</strong>的请求，这样实现的 GET 方法自然就不是安全和幂等。</li><li>可以用 POST 方法<strong>实现查询数据</strong>的请求，这样实现的 POST 方法自然就是安全和幂等。</li></ul><h2 id="7-HTTP的长连接是什么？">7.HTTP的长连接是什么？</h2><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231702564.png" alt="image-20240725231702564"></p><p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231648038.png" alt="image-20240725231648038"></p><p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231628356.png" alt="image-20240725231628356"></p><p>这样实在太累人了，一次连接只能请求一次资源。</p><p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p><p>当然可以，<strong>HTTP 的 Keep-Alive</strong> 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231558255.png" alt="image-20240725231558255"></p><p><strong>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</strong></p><h2 id="8-HTTP1-1怎么对请求做拆包，具体来说怎么拆的？">8.HTTP1.1怎么对请求做拆包，具体来说怎么拆的？</h2><p>在HTTP/1.1中，请求的拆包是通过&quot;<strong>Content-Length</strong>&quot;头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231532943.png" alt="image-20240725231532943"></p><p>具体来说，当客户端发送一个HTTP请求时，会在请求头中添加&quot;Content-Length&quot;字段，该字段的值表示请求正文的字节数。</p><p>服务器在接收到请求后，<strong>会根据&quot;Content-Length&quot;字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。</strong></p><p>这种基于&quot;Content-Length&quot;字段的拆包机制可以确保服务器正确接收到完整的请求，<strong>避免了请求的丢失或截断问题。</strong></p><h2 id="9-http-断点重传是什么？">9.http 断点重传是什么？</h2><p>断点续传是HTTP/1.1协议支持的特性。实现断点续传的功能，<strong>需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1737790649434-0bb21e8e-faae-44c7-9f7b-2f677c38b39d.webp" alt="img">一个最简单的断点续传流程如下：</p><ol><li>客户端开始下载一个1024K的文件，服务端发送A<strong>ccept-Ranges: bytes来告诉客户端，其支持带Range的请求</strong></li><li>假如客户端下载了其中512K时候网络突然断开了，过了一会网络可以了，客户端再下载时候，需要在HTTP头中申明本次需要续传的片段：<strong>Range:bytes=512000-这个头通知服务端从文件的512K位置开始传输文件，直到文件内容结束</strong></li><li>服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：<strong>Content-Range:bytes 512000-/1024000,Content-Length: 512000。<strong>并且此时服务端返回的HTTP状态码应该是</strong>206</strong> Partial Content。如果<strong>客户端传递过来的Range超过资源的大小,则响应416</strong> Requested Range Not Satisfiable</li></ol><p>通过上面流程可以看出：断点续传中4个HTTP头不可少的，<strong>分别是Range头、Content-Range头、Accept-Ranges头、Content-Length头</strong>。其中第一个Range头是客户端发过来的，后面3个头需要服务端发送给客户端。下面是它们的说明：</p><ul><li><strong>Accept-Ranges: bytes：<strong>这个值</strong>声明了可被接受的每一个范围请求</strong>, 大多数情况下是字节数 bytes</li><li>**Range: bytes=开始位置-结束位置：**Range是浏览器告知服务器所需分部分内容范围的消息头。</li></ul><h2 id="10-HTTP为什么不安全？">10.HTTP为什么不安全？</h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1719381758323-e2bd2f7b-d599-4b23-b258-b8620ac52808.jpeg" alt="img"></p><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <strong>SSL/TLS</strong> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><h2 id="11-HTTP和HTTPS-的区别？">11.HTTP和HTTPS 的区别？</h2><p>区别主要有以下四点：</p><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP <strong>网络层之间加入了 SSL/TLS 安全协议</strong>，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS <strong>在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</strong></li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 **CA（证书权威机构）申请数字证书，**来保证服务器的身份是可信的。</li></ul><h2 id="12-HTTPS握手过程说一下">12.HTTPS握手过程说一下</h2><p>传统的 <strong>TLS 握手基本都是使用 RSA 算法来</strong>实现密钥交换的，在将 TLS 证书部署服务端时，<strong>证书文件其实就是服务端的公钥</strong>，会在 TLS 握手阶段传递给客户端，而<strong>服务端的私钥则一直留在服务端</strong>，一定要确保私钥不能被窃取。</p><p>在 RSA 密钥协商算法中，<strong>客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端</strong>。根据非对称加密算法，<strong>公钥加密的消息仅能通过私钥解密</strong>，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p><p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1716097892426-58902c14-da4f-40fc-9199-94752fc5368b.webp" alt="img"></p><p><img src="https://cdn.xiaolincoding.com//picgo/1716097892465-985f6cfe-66c8-4384-aabd-840821de1b66.webp" alt="img"></p><blockquote><p>TLS 第一次握手</p></blockquote><p>首先，由客户端向服务器发起<strong>加密通信</strong>请求，<strong>也就是 ClientHello 请求</strong>。在这一步，客户端主要向服务器发送以下信息：</p><ul><li>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li><li>（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li><li>（3）客户端支持的密码套件列表，如 RSA 加密算法。</li></ul><blockquote><p>TLS 第二次握手</p></blockquote><p>服务器收到客户端请求后，向客户端发出响应，也就是 <strong>SeverHello</strong>。服务器回应的内容有如下内容：</p><ul><li>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li><li>（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li>（3）确认的密码套件列表，如 RSA 加密算法。</li><li>（4）服务器的数字证书。</li></ul><blockquote><p>TLS 第三次握手</p></blockquote><p>客户端收到服务器的回应之后，<strong>首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</strong></p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后<strong>使用它加密报文，向服务器发送如下信息：</strong></p><ul><li>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>（3）客户端握手结束通知**，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。**</li></ul><p>上面第一项的随机数是整个握手阶段的<strong>第三个随机数</strong>，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><blockquote><p>TLS 第四次握手</p></blockquote><p>服务器收到客户端的<strong>第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</strong></p><p>然后，<strong>向客户端发送最后的信息</strong>：</p><ul><li>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>（2）服务器握手结束通知，表示<strong>服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</strong></li></ul><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，<strong>就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</strong></p><h2 id="13-HTTPS是如何防范中间人的攻击？">13.HTTPS是如何防范中间人的攻击？</h2><p>主要通过<strong>加密和身份校验机制</strong>来防范中间人攻击的:</p><ul><li>加密：https 握手期间会通过<strong>非对称加密的方式</strong>来协商出对称加密密钥。</li><li>身份校验：<strong>服务器</strong>会向证书颁发机构申请<strong>数字证书</strong>，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，<strong>客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密。</strong></li></ul><p>中间人攻击的关键在于攻击者冒充服务器与客户端建立连接，并同时与服务器建立连接。</p><p>但由于攻击者无法获得服务器的私钥，因此无法正确解密客户端发送的加密数据。同时，客户端会在建立连接时验证服务器的证书，如果证书验证失败或存在问题，客户端会发出警告或中止连接。</p><h2 id="14-Http1-1和2-0的区别是什么？">14.Http1.1和2.0的区别是什么？</h2><p>HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ul><li><strong>头部压缩</strong>：HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。这就是所谓的 <strong>HPACK</strong> 算法：在客户端和服务器同时维护一张<strong>头信息表</strong>，所有字段都会存入这个表，<strong>生成一个索引号</strong>，以后就<strong>不发送同样字段了，只发送索引号</strong>，这样就<strong>提高速度</strong>了。</li><li><strong>二进制格式</strong>：HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li><li><strong>并发传</strong>输：引出了 <strong>Stream</strong> 概念，多个 Stream 复用在一条 TCP 连接。解决了HTTP/1.1 队头阻塞的问题：</li><li><strong>服务器主动推送资源</strong>：HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</li></ul><h2 id="15-HTTP进行TCP连接之后，在什么情况下会中断">15.HTTP进行TCP连接之后，在什么情况下会中断</h2><ul><li>当服务端或者客户端执行 close 系统调用的时候，会发送FIN报文，就会进行<strong>四次挥手</strong>的过程</li><li>当发送方发送了数据之后，接收方超过一段时间没有响应ACK报文，发送方重传数据达到最大次数的时候，就会断开TCP连接。</li><li>当HTTP长时间没有进行请求和响应的时候，超过一定的时间，这个时间就是长连接的维持时间，就会释放连接</li></ul><h2 id="16-HTTP、SOCKET和TCP的区别">16.HTTP、SOCKET和TCP的区别</h2><p>HTTP是应用层协议，定义了<strong>客户端和服务器之间交换的数据格式和规则</strong>；Socket是通信的一端，<strong>提供了网络通信的接口</strong>；TCP是传输层协议，负责在<strong>网络中建立可靠的数据传输连接</strong>。它们在网络通信中扮演不同的角色和层次。</p><ul><li>HTTP是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示Web页面。</li><li>Socket是计算机网络中的一种抽象，用于描述<strong>通信链路的一端</strong>，提供了底层的通信接口，可实现不同计算机之间的<strong>数据交换</strong>。</li><li>TCP是一种面向连接的、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。</li></ul><h2 id="17-HTTP到底是不是无状态的？">17.HTTP到底是不是无状态的？</h2><p>HTTP是<strong>无状态</strong>的，这意味着<strong>每个请求都是独立的</strong>，服务器不会在多个请求之间保留关于客户端状态的信息。在每个HTTP请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的。</p><p>虽然HTTP本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是使用<strong>Cookie和Session来跟踪用户状态</strong>。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能。或者是使用token，一般这个都是用来认证识别用户使用的</p><h1>DNS</h1><h2 id="1-DNS的全称了解么？">1.DNS的全称了解么？</h2><p>DNS的全称是<strong>Domain Name System</strong>（域名系统），它是互联网中用于将**域名转换为对应IP地址的分布式数据库系统。**DNS扮演着重要的角色，使得人们可以通过易记的域名访问互联网资源，而无需记住复杂的IP地址。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <a href="http://www.server.com">www.server.com</a>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p><p>实际上域名最后还有一个点，比如 <a href="http://www.server.com">www.server.com</a>.，这个<strong>最后的一个点代表根域名。</strong></p><p>也就是，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 <a href="http://server.com">server.com</a>。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（<a href="http://server.com">server.com</a>）</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" alt="DNS 树状结构"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，<strong>客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</strong></p><h2 id="2-DNS-域名解析的工作流程？">2.DNS 域名解析的工作流程？</h2><ol><li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果<strong>缓存</strong>里的表格能找到 <a href="http://www.server.com">www.server.com</a>，则它直接返回 IP 地址。如果没有，<strong>本地 DNS 会去问它的根域名服务器：</strong>“老大， 能告诉我 <a href="http://www.server.com">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com">www.server.com</a> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” <a href="http://server.com">server.com</a> 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1715326531135-c1f081dd-89e1-4b31-94e4-95a76f9fcba4.png" alt="img"></p><p>就是一个递归的过程，从顶级到下面一步一步递归</p><h2 id="3-DNS的底层使用TCP还是UDP？">3.DNS的底层使用TCP还是UDP？</h2><p>DNS 基于UDP协议实现，DNS使用UDP协议进行域名解析和数据传输。因为基于UDP实现DNS能够提供低延迟、简单快速、轻量级的特性，更适合DNS这种需要快速响应的域名解析服务。</p><ul><li><strong>低延迟：</strong> UDP是一种无连接的协议，不需要在数据传输前建立连接，因此可以减少传输时延，适合DNS这种需要快速响应的应用场景。</li><li><strong>简单快速：</strong> UDP相比于TCP更简单，没有TCP的连接管理和流量控制机制，传输效率更高，适合DNS这种需要快速传输数据的场景。</li><li><strong>轻量级</strong>：UDP头部较小，占用较少的网络资源，对于小型请求和响应来说更加轻量级，适合DNS这种频繁且短小的数据交换。</li></ul><p>尽管 UDP 存在丢包和数据包损坏的风险，但在 DNS 的设计中，这些风险是可以被容忍的。DNS 使用了一些机制来提高可靠性，例如查询超时重传、请求重试、缓存等，以确保数据传输的可靠性和正确性。</p><p>但是dns也是可以使用tcp进行的，默认是udp端口号是53</p><p><strong>响应数据超过 UDP 限制时</strong></p><ul><li>如果 DNS 响应内容超过 <strong>512 字节</strong>（在启用 EDNS0 时可以大于此限制，但 UDP 包最大也不能超过 4096 字节）；</li><li>比如：<ul><li>响应包含大量的 A 记录、MX 记录；</li><li>使用 DNSSEC（数据带签名，很大）；</li></ul></li><li>那么就会自动“回退”使用 <strong>TCP 进行重传</strong>。</li></ul><p><strong>区域传送（Zone Transfer）时</strong></p><ul><li>主从 DNS 服务器之间同步区域信息（<strong>AXFR、IXFR 请求</strong>）使用 <strong>TCP</strong>；</li><li>这些传输的数据量大、需要可靠性和顺序性，UDP 无法胜任。</li></ul><p><strong>连接建立更可靠的查询环境时</strong></p><ul><li>一些防火墙或中间设备可能对 UDP 做限制，此时客户端会主动使用 TCP。</li><li>一些安全策略（如 DNS-over-TCP、DoH、DoT）也默认使用 TCP。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/06/05/network/net4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git</title>
      <link>https://blog.tokenlen.top/2025/05/31/new-stack/git/</link>
      <guid>https://blog.tokenlen.top/2025/05/31/new-stack/git/</guid>
      <pubDate>Fri, 30 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基础&lt;/h1&gt;
&lt;p&gt;Git 是一个分布式版本控制系统，用于跟踪和管理代码的变化，广泛应用于软件开发中。一般用于多人开发，或者是版本管理的&lt;/p&gt;
&lt;p&gt;组成部分：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作区（Working</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基础</h1><p>Git 是一个分布式版本控制系统，用于跟踪和管理代码的变化，广泛应用于软件开发中。一般用于多人开发，或者是版本管理的</p><p>组成部分：</p><p><strong>工作区（Working Directory）</strong>：你本地修改代码的目录。</p><p><strong>暂存区（Staging Area/Index）</strong>：用于暂存准备提交的更改。</p><p><strong>本地仓库（Local Repository）</strong>：存储提交的代码版本。</p><p><strong>远程仓库（Remote Repository）</strong>：托管在远程服务器（如 GitHub、GitLab）的代码仓库。</p><p>流程：修改代码 → 暂存更改（git add） → 提交到本地仓库（git commit） → 推送到远程仓库（git push）。</p><p>从远程仓库拉取更新（git pull）或克隆仓库（git clone）。</p><h2 id="命令">命令</h2><p>git init 初始化仓库，建立一个.git文件夹</p><p>git clone ssh/http克隆仓库</p><p>git status 查看工作区的状态</p><p>git add <file name>添加文件。git add .添加所有</p><p>git commit -m &quot;&quot;提交</p><p>git log 查看提交历史</p><p>git log --oneline # 简洁显示</p><p>git log --graph   # 显示分支图形</p><p>git branch 列出本地分支</p><p>git branch -r 远程分支</p><p>git branch -a 列出所有分支</p><p>git branch &lt; name&gt;新建分支</p><p>git checkout &lt; name&gt;切换分支</p><p>git checkout -b &lt; name&gt;切换并创建分支</p><p>git merge &lt; name&gt;合并分支，可能要处理分支冲突</p><p>git branch -d &lt; name&gt;删除已经合并的分支</p><p>git branch -D &lt; name&gt; 强制删除</p><p>git remote add origin 添加远程仓库</p><p>git remote -v 查看远程仓库</p><p>git push origin main 推送本地到某某分支</p><p>git pull origin main 拉起分支，相当于 git fetch + git merge。</p><p>git restore &lt; file&gt;撤销工作区修改</p><p><strong>这些都是需要某次提交的hash值的</strong></p><p>git restore --staged  撤销暂存区修改</p><p>git reset --soft 撤销提交，但修改还在</p><p>git reset --hard 撤销提交，修改也不要</p><p>git revert 回滚到某次提交</p><p>git fetch 只获取更新的内容，不合并</p><p>git diff 工作区和暂存区的差异</p><p>git diff --staged 暂存区和上次提交的差异</p><p>将当前分支的提交应用到另一分支上</p><p>git rebase</p><p>解决冲突后继续：git rebase --continue</p><p>中止变基：git rebase --abort</p><p><strong>gitignore</strong>：</p><ul><li>创建 .gitignore 文件，忽略不需要跟踪的文件（如 node_modules/、.env）。</li></ul><p>扩展命令：</p><ul><li>git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。</li><li>git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。</li><li>git checkout HEAD – files 回滚到复制最后一次提交。</li><li></li></ul><h2 id="问题解决">问题解决</h2><p><strong>合并冲突</strong></p><p>合并或拉取时可能发生冲突，Git 会标记冲突文件。</p><p>当发生冲突时，Git 会提示您文件中的冲突部分。您可以使用以下命令查看所有冲突文件的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ol><li>打开包含冲突的文件，您会看到类似以下的标记：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">// 代码来自目标分支</span><br><span class="line">=======</span><br><span class="line">// 代码来自要合并的分支</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchName</span><br></pre></td></tr></table></figure><p>您需要手动编辑这些文件，决定保留哪些变更或者如何整合这些变更。</p><p>完成冲突解决后，对已解决的文件使用以下命令标记为已解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt; </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p><strong>误提交</strong></p><p>修改最后一次提交：git commit --amend</p><p>回滚到之前版本：git reset 或 git revert</p><p><strong>远程推送被拒绝</strong></p><p>通常是远程仓库有更新，先拉取：git pull --rebase，然后再推送。</p><h1>面试题目</h1><h2 id="1-git-rebase和merge的区别">1.git rebase和merge的区别</h2><ul><li><strong>Rebase</strong>（变基）是将<strong>一个分支上的提交逐个地应用到另一个分支上</strong>，使得提交历史变得更加线性。当执行rebase时，Git会将目标分支与源分支的共同祖先以来的所有提交挪到目标分支的最新位置。这个过程可以看作是<strong>将源分支上的每个提交复制到目标分支上</strong>。简而言之，<strong>rebase可以将提交按照时间顺序线性排列。</strong></li></ul><p>常用来更新的时候</p><ul><li><strong>Merge</strong>（合并）是将<strong>两个分支上的代码提交历史合并为一个新的提交</strong>。在执行merge时，Git会创建一个新的合并提交，将两个分支的提交历史连接在一起。这样，两个分支的修改都会包含在一个合并提交中。合并后的历史会保留每个分支的提交记录。</li></ul><h2 id="2-解释“git-pull”和“git-fetch”之间有什么区别？">2.解释“git pull”和“git fetch”之间有什么区别？</h2><p>在Git中，<code>git fetch</code>和<code>git pull</code>都是用于从远程仓库获取更新的命令，但它们的工作方式有所不同。</p><p><code>git fetch</code></p><ul><li><strong>功能</strong>: 只从<strong>远程仓库获取更新，不会将这些更新合并到当前分支</strong>。</li><li><strong>用途</strong>: 它会下载所有的提交、分支和标签，更新本地的远程跟踪分支（如<code>origin/master</code>），但不会改变你的工作目录或当前分支的内容。</li><li><strong>场景</strong>: 适合在<strong>想要查看远程变化但不希望立即合并的情况下使用</strong>。你可以先审查更新，决定接下来是否要合并。</li></ul><p><code>git pull</code></p><ul><li><strong>功能</strong>: 是<code>git fetch</code>和<code>git merge</code>的组合命令。它首先会执行<code>git fetch</code>，然后会<strong>将获取的更新合并到当前分支。</strong></li><li><strong>用途</strong>: 直接将远程分支的变化合并到你当前的工作分支，适合希望快速同步远程更改并工作于最新状态的场景。</li><li><strong>场景</strong>: 适用于当你确信需要立即合并远程更新时，方便快速将最新的更改合并到本地。</li></ul><h2 id="3-简述Git和SVN有什么区别？">3.简述Git和SVN有什么区别？</h2><p>Git和SVN（Subversion）都是版本控制系统，但它们在设计理念、工作流程和功能等方面有显著的区别。以下是一些主要区别：</p><ol><li><strong>版本控制模型</strong>：<ul><li><strong>SVN</strong>：基于<strong>集中式版本控制系统</strong>（CVCS），所有版本历史记录保存在中央服务器上，工作副本直接与中央库交互。</li><li><strong>Git</strong>：基于<strong>分布式版本控制系统</strong>（DVCS），每个开发者的工作副本都包含整个代码库的历史记录，操作可以在本地完成。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>SVN</strong>：对于大文件的处理和网络操作可能比较慢，因为每次提交或更新都需要与中央服务器交互。</li><li><strong>Git</strong>：大部分操作（如提交、分支、合并等）都在本地进行，速度更快，尤其是在离线时。</li></ul></li><li><strong>分支和合并</strong>：<ul><li><strong>SVN</strong>：分支和标签是从中央库创建的，相对较重，使用上不够灵活。</li><li><strong>Git</strong>：分支操作轻量且快速，鼓励频繁创建和使用分支，合并操作也相对简单。</li></ul></li><li><strong>数据完整性</strong>：<ul><li><strong>SVN</strong>：依赖中央服务器的数据完整性，尽管有一定的安全措施，但主要依靠服务器来维护数据。</li><li><strong>Git</strong>：通过<strong>SHA-1哈希值</strong>来确保每次提交的完整性，每个提交都是整个历史的一部分，易于追踪和验证。</li></ul></li><li><strong>工作流</strong>：<ul><li><strong>SVN</strong>：通常采用拉/推的工作流，开发者需要从中央库更新，提交时也要推送到中央库。</li><li><strong>Git</strong>：支持多种工作流（如Forking、Feature Branch等），开发者可以在本地进行完全隔离的开发，之后再选择何时将更改推送到中央库。</li></ul></li><li><strong>使用场景</strong>：<ul><li><strong>SVN</strong>：适合小团队和需要严格控制版本访问的项目。</li><li><strong>Git</strong>：更适合开源项目和需要频繁更新的团队，灵活性和效率较高。</li></ul></li></ol><p>总的来说，Git更适合现代软件开发的分布式协作需求，而SVN则在一些传统环境中仍然被广泛使用。</p><h2 id="4-简述Github和Gitlab的区别？">4.简述Github和Gitlab的区别？</h2><p>GitHub和GitLab是两个流行的Git代码托管平台，虽然它们有许多相似之处，但在一些关键方面有所不同：</p><ol><li><strong>主机定位</strong>：<ul><li><strong>GitHub</strong>：主要是一个基于云的服务，提供代码托管和协作工具。</li><li><strong>GitLab</strong>：可以选择使用云服务，也可以自行托管在本地服务器上，<strong>适合更注重私有化和自定义的团队。</strong></li></ul></li><li><strong>访问控制</strong>：<ul><li><strong>GitHub</strong>：较为简单的权限管理，主要依赖于组织和仓库的级别设置。</li><li><strong>GitLab</strong>：提供<strong>更细粒度的权限管理，允许用户为不同的项目或分支设置不同的访问权限</strong>。</li></ul></li><li><strong>集成功能</strong>：<ul><li><strong>GitHub</strong>：虽然有GitHub Actions等CI/CD功能，但整体上集成和扩展的选择相对少。</li><li><strong>GitLab</strong>：内置了非常强大的CI/CD功能，几乎所有的<strong>DevOps流程</strong>都可以在一个平台上完成。</li></ul></li><li><strong>issue追踪与项目管理</strong>：<ul><li><strong>GitHub</strong>：提供基础的issue追踪功能，涉及的问题管理相对简单。</li><li><strong>GitLab</strong>：提供更<strong>全面的项目管理工具，包含时间线、里程碑和更复杂的看板</strong>等功能。</li></ul></li><li><strong>开源与闭源</strong>：<ul><li><strong>GitHub</strong>：主要为闭源平台，但有一些开源项目。</li><li><strong>GitLab</strong>：提供开源版本，用户可以自由修改和使用。</li></ul></li><li><strong>社区和生态</strong>：<ul><li><strong>GitHub</strong>：有着庞大的开发者社区和丰富的开源项目资源。</li><li><strong>GitLab</strong>：社区相对较小，但也在快速增长中，尤其是在DevOps领域。</li></ul></li><li><strong>费用结构</strong>：<ul><li><strong>GitHub</strong>：基本的公共仓库免费，但某些高级功能需要付费。</li><li><strong>GitLab</strong>：提供更全面的免费计划，收费方案也根据功能不同而不同。</li></ul></li></ol><p>这些差异使得GitHub和GitLab在满足不同团队和项目需求时，具有各自的优缺点。选择哪个平台主要取决于团队的具体需求和工作流程。</p><ol start="5"><li></li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/git/">git</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/31/new-stack/git/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试题目</title>
      <link>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/</link>
      <guid>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/</guid>
      <pubDate>Tue, 27 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;面试一轮&lt;/h1&gt;
&lt;h2 id=&quot;3-无重复字符的最长子串&quot;&gt;3.&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>面试一轮</h1><h2 id="3-无重复字符的最长子串">3.<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><p>滑动窗口</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,res = <span class="number">0</span>,n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right&lt;n;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                left = Math.max(left,cnt.get(s.charAt(right)));</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.put(s.charAt(right),right);</span><br><span class="line">            res = Math.max(res,right-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典滑动窗口，更新right和left然后计算长度</p><h2 id="146-LRU-缓存"><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p>linkedHashMap</p><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p>一看到是存储键值对数据，那我们可以使用map集合来做，然后返现需要插入xud</p><p>LinkedHashMap而其内部是靠 建立一个<strong>双向链表</strong> 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护 ，准确的来说，是有三个函数来做这件事，这三个函数都统称为 <strong>回调函数</strong> ，这三个函数分别是：</p><p>void afterNodeAccess(Node&lt;K,V&gt; p) { }<br>其作用就是在访问元素之后，<strong>将该元素放到双向链表的尾巴处</strong>(所以这个函数只有在按照读取的顺序的时候才会执行)，之所以提这个，是建议大家去看看，如何优美的实现在双向链表中将指定元素放入链尾！<br>void afterNodeRemoval(Node&lt;K,V&gt; p) { }<br>其作用就是在删除元素之后，将元素从双向链表中删除，还是非常建议大家去看看这个函数的，很优美的方式在双向链表中删除节点！<br>void afterNodeInsertion(boolean evict) { }<br>这个才是我们题目中会用到的，在插入新元素之后，<strong>需要回调函数判断是否需要移除一直不用的某些元素！</strong></p><p>所以我们直接继承linkedhashmap来解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer,Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer,Integer&gt; eldest)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size()&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接返回即可了</p><h2 id="206-反转链表"><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>那我们就一直交换他们的指针应该就可以了，从尾部交换到头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution206A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.pre-&gt;cur</p><p>A.cur-&gt;cur.next</p><p>A.cur.next = pre</p><p>然后用<strong>头插法</strong>依次把节点 1,2,3 插到这个新链表的头部</p><p>1-&gt;2-&gt;3</p><p>2.next-&gt;1</p><p>2.pre-&gt;2</p><p>2.cur-&gt;3</p><p>3-&gt;2-&gt;1</p><h2 id="215-数组中的第K个最大元素"><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接排序，返回倒数第k个就完事</p><h2 id="15-三数之和"><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>双指针</p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;x==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//跳过重复数组</span></span><br><span class="line">            <span class="keyword">if</span> (x+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]&gt;<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//没负数就别看了</span></span><br><span class="line">            <span class="keyword">if</span> (x+nums[n-<span class="number">2</span>]+nums[n-<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//每个正数也不看了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span>  <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;k)&#123;</span><br><span class="line">                <span class="type">int</span> s= x+nums[j]+nums[k];</span><br><span class="line">                <span class="keyword">if</span> (s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.add(List.of(x, nums[j], nums[k]));</span><br><span class="line">                    <span class="keyword">for</span> (j++;j&lt;k&amp;&amp;nums[j]==nums[j-<span class="number">1</span>];j++);<span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">for</span> (k--;k&gt;j&amp;&amp;nums[k]==nums[k+<span class="number">1</span>];k--);<span class="comment">//去重</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个进行优化和提前去观察的双指针方法，提前看最大的能不能实现，还有最小的情况能不能符合.</p><h2 id="25-K-个一组翻转链表"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur!=<span class="literal">null</span>;cur =cur.next)&#123;</span><br><span class="line">            n++;<span class="comment">//计数器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head),preHead = dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = head;</span><br><span class="line">        <span class="keyword">for</span> (;n&gt;=k;n-=k)&#123;<span class="comment">//重复n-k次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">                <span class="type">ListNode</span>  <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre =cur;</span><br><span class="line">                cur  = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> preHead.next;<span class="comment">//反转区间的结尾</span></span><br><span class="line">            tail.next = cur;<span class="comment">//下个区间</span></span><br><span class="line">            preHead.next = pre;<span class="comment">//区间的新head</span></span><br><span class="line">            preHead = tail;<span class="comment">//到达结尾进行下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>分组循环</p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution53A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum +=x;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum = x;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的去解决，如果和为正数的话，就继续去加数。不是的话，就从当前这个数开始重新计算</p><p>也有点分组循环的意思了哈哈</p><h2 id="手撕快速排序">手撕快速排序</h2><p>快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution912</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span>  <span class="operator">=</span> nums.length;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right-left&lt;=INSERTION_SORT_THRESHOLD)&#123;</span><br><span class="line">            insertSort(nums,left,right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> partition(nums,left,right);</span><br><span class="line">        quickSort(nums,left,pIndex-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,pIndex+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;left&amp;&amp;nums[j-<span class="number">1</span>]&gt;tmp)&#123;</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left+RANDOM.nextInt(right-left+<span class="number">1</span>);</span><br><span class="line">        swap(nums,randomIndex,left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (gt &gt; left &amp;&amp; nums[gt] &gt; pivot) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lt &gt;= gt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 细节：相等的元素通过交换，等概率分到数组的两边</span></span><br><span class="line">            swap(nums, lt, gt);</span><br><span class="line">            lt++;</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, gt);</span><br><span class="line">        <span class="keyword">return</span> gt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点难了😓</p><h2 id="21-合并两个有序链表"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span>) <span class="keyword">return</span> list2; <span class="comment">// 注：如果都为空则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="literal">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空的话就返回另一个的链表</p><p>如果l1的值小于l2的话，递归调用的链表接l1之后。反之一样</p><p>然后返回当前节点</p><h2 id="5-最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> expend(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> expend(s,i,i);</span><br><span class="line">            res = res.length()&gt;s1.length()?res:s1;</span><br><span class="line">            res = res.length()&gt;s2.length()?res:s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">expend</span><span class="params">(String s,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;=<span class="number">0</span>&amp;&amp;r&lt;s.length()&amp;&amp;s.charAt(l)==s.charAt(r))&#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(l+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expend返回的是上一次合法回文的范围。然后慢慢扩大范围，s1为偶数回文</p><p>s2为奇数回文</p><h2 id="102-二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution102A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue   = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>level为当前的层数，n为当前层数的所有节点数</p><p>然后使用bfs进步遍历，不为空，就加入队列遍历</p><h2 id="1-两数之和"><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>hashmap</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums,<span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用hash表解决，在map里有target-nums[i]的数，就新建数组</p><p>然后放入nums[i]，没有就扔出异常</p><h2 id="33-搜索旋转排序数组"><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>二分查找</p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> target&gt;end&amp;&amp;x&gt;=target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target&gt;end||x&gt;=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums,target,mid))&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right]==target?right:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用二分查找</p><p>把某个数 <em>x</em> 与最后一个数 <em>nums</em>[<em>n</em>−1] 比大小</p><p>如果x&gt;nums[n-1]的话</p><p>nums一定被旋转分为左右两个递增的，就是前面的一段移动到后面来了</p><p>然后前面的大于后面的</p><p>x还在第一段</p><p>反之，x&lt;=nums[n-1]就说明x在第二段</p><p>或者他就是递增数组</p><p>根据这个写我们的check函数，来确定x的范围，好让我们进行二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x&gt;end)&#123;</span><br><span class="line">            <span class="keyword">return</span> target&gt;end&amp;&amp;x&gt;=target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target&gt;end||x&gt;=target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p>bfs</p><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution200</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i&gt;=grid.length||j&lt;<span class="number">0</span>||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是遍历这整个矩阵，然后如果是1就count++;</p><p>然后把通过的改为2，防止重复遍历</p><h2 id="46-全排列"><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p>回溯法</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, path, onPath, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; path, <span class="type">boolean</span>[] onPath, List&lt;List&lt;Integer&gt;&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (onPath[i]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            onPath[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(nums, path, onPath, ans);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            onPath[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>onPath用来放这个j有没有使用</p><p>path为路径，就是数组，长度全了的话，就给他加入到答案中</p><p>然后遍历，进入路径，设为匹配，dfs后，再恢复</p><h2 id="88-合并两个有序数组"><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p>**注意：**最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p1&gt;=<span class="number">0</span>&amp;&amp;nums1[p1]&gt;nums2[p2])&#123;</span><br><span class="line">                nums1[p--] = nums1[p1--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[p--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的交换，谁大谁在后面</p><h2 id="20-有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>栈</p><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution20</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c :s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;&#123;&#x27;</span>) stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>) stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()||c!=stack.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用栈的思想，有左的话，就把右边的入栈</p><p>或者空了，或者是所不对应的时候，返回fasle</p><p>然后最后看是不是空</p><h2 id="121-买卖股票的最佳时机"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution121</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE,profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p:prices)&#123;</span><br><span class="line">            cost = Math.min(cost,p);</span><br><span class="line">            profit = Math.max(profit,p-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>easy题目</p><h2 id="103-二叉树的锯齿形层序遍历"><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> List.of();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                vals.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.size()%<span class="number">2</span>&gt;<span class="number">0</span>) Collections.reverse(vals);</span><br><span class="line">            ans.add(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看到这种层序遍历，我们首先想到使用bfs，然后层序遍历，先遍历left,然后遍历right</p><p>之前的代码跟层序遍历差不多，只不过，他要形成锯齿状，奇数层就要反转。即就是下面的代码</p><p>刚刚前面判断写的有点麻烦了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>) q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                vals.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.size()%<span class="number">2</span>&gt;<span class="number">0</span>) Collections.reverse(vals);</span><br><span class="line">            ans.add(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更正一下</p><blockquote><p>联系102二叉树的层序遍历</p></blockquote><h2 id="236-二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution236</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==q||root==p) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是有啥就返回啥，没有就返回另一半，都没有就返回root</p><h2 id="141-环形链表"><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution141</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个环形，也就是说是快慢指针碰到一块了就是一个环</p><h2 id="92-反转链表-II"><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution92</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;left-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            p0= p0.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> p0.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur= next;</span><br><span class="line">        &#125;</span><br><span class="line">        p0.next.next = cur;</span><br><span class="line">        p0.next = pre;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似 leetcode25,206</p></blockquote><p>反转需要注意的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur= next;</span><br></pre></td></tr></table></figure><p>反转后在原来的链表上看，pre指向反转一段的末尾，</p><p>cur指向反转一段后续的下一个节点</p><p>然后修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p0.next.next = cur;</span><br><span class="line">        p0.next = pre;</span><br><span class="line">        return dummy.next;</span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution54A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span><span class="number">0</span>,r = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>,b = matrix.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r&amp;&amp;t&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;i&lt;=r;i++) res.add(matrix[t][i]);</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>t;i&lt;=b;i++) res.add(matrix[i][r]);</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;r) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=r;i&gt;=l;i--) res.add(matrix[b][i]);</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">if</span> (t&gt;b) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>b;i&gt;=t;i--) res.add(matrix[i][l]);</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个遍历的问题，从左到右，从上到下，然后从右到左，再从下到上</p><p>然后循环，主要是边界也要跟着移动</p><h2 id="300-最长递增子序列"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution300</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span><span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;res[k])&#123;</span><br><span class="line">                res[++k] = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (res[j]&gt;=nums[i])&#123;</span><br><span class="line">                    res[j] =nums[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先遍历出来个递增的数组</p><p>如果不是的话，从0-k中找一个别的数，来贪心替换</p><p>最后k+1就是有效的长度</p><h2 id="23-合并-K-个升序链表"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span>  lists.length;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;step&lt;m;step*=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;m-step;i+=step*<span class="number">2</span>)&#123;</span><br><span class="line">                lists[i] =  meryTwoLists(lists[i],lists[i+step]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">meryTwoLists</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="literal">null</span>&amp;&amp;list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val&lt;list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1!=<span class="literal">null</span>?list1:list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的函数时按大小来合并链表的</p><p>每次将间隔为 <code>step</code> 的链表合并成一个新链表</p><p>然后要满足所有，可以合并一道二，二到四，四道八这样一点一点的递归下去</p><h2 id="143-重排链表"><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution143</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next!=<span class="literal">null</span>&amp;&amp;fast.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow =slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        ListNode l1_temp;</span><br><span class="line">        ListNode l2_temp;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">null</span>&amp;&amp;l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            l1_temp = l1.next;</span><br><span class="line">            l2_temp = l2.next;</span><br><span class="line"></span><br><span class="line">            l1.next = l2;</span><br><span class="line">            l1 = l1_temp;</span><br><span class="line"></span><br><span class="line">            l2.next = l1;</span><br><span class="line">            l2 = l2_temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span>head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        l2 = reverseList(l2);</span><br><span class="line">        mergeList(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这个题目可以进行拆分，主要是分为三步</p><p>先是找到中间点，然后按照中间点分开，然后后面的链表反转，然后跟前面的链表合并</p><p>所以我们需要写三个函数，和一个主函数</p><p>找到中间点的方法就是</p><p>一个快指针，一个慢指针。然后快指针到尾部了。慢指针的位置就是中间点</p><p>反转链表不必多说：</p><p>next = cur.next</p><p>cur.next = pre;</p><p>pre = cur;</p><p>cur =next;</p><p>然后合并链表，就是先加l1的头，然后再加l2的头这样</p><p>l1tmp  = l1.next;</p><p>l2tmp = l2.next;</p><p>l1.next = l2;</p><p>l1 = l1tmp</p><p>l2.next = l1;</p><p>l2 = l2tmp</p><p>然后完成。</p><p>我自己想的思路是，我用双指针解决，找一个新的链表，然后先是左指针的节点加入，然后再加入右指针，然后左右指针都移动，一次类推，然后到左右指针相遇的时候，加入最后的节点。这个思路。但是这样的时间复杂度是o(n)不太符合哭。</p><h2 id="415-字符串相加"><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式</p><p>既然他不让直接进行计算器算的话，那我们去模拟计算器</p><p>从每个数的结尾去计算，如果进位的话，就加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  num1.length()-<span class="number">1</span>, j = num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            res.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后这里使用的stringBuilder用来操作字符串是非常好的，因为字符串String是final不能修改值</p><p>但是stringbuilder和stringbuffer是可以的。其中stringbuilder是单线程的</p><p>stringbuffer是多线程，是线程安全的。</p><h2 id="56-合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution56A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals)&#123;</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>]-q[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是先按左端点排序，然后这样就可以清楚合并的顺序</p><p>如果ans的大小大于0，然后p的左端点要小于ans最后一个的右端点的话</p><p>那就可以合并</p><p>然后更新右端点，更新为p的右端点ans最后一个的右端点</p><p>如果不是的话，就把这个数组加进入来</p><p>然后最后将ans转为ans.size大小的数组</p><h2 id="160-相交链表"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution160</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA,B=headB;</span><br><span class="line">        <span class="keyword">while</span> (A!=B)&#123;</span><br><span class="line">            A=(A!=<span class="literal">null</span>)?A.next:headB;</span><br><span class="line">            B=(B!=<span class="literal">null</span>)?B.next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种情况</p><p>一个是B走的快吧，B走到null了，然后A处在的位置就是首个公共节点</p><p>为空了就给他赋值为headA,然后让他从A走</p><p>A为空了就赋值为headB让他从B走，然后他们相遇的地方就是公共节点</p><p>实际上就是A遍历完headA再遍历headB；B反之；这样就相当于走了同样的距离，也就是两次循环找到交点</p><h2 id="42-接雨水"><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>就是使用双指针，记录中间夹的地方能记录多少雨水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preMax= <span class="number">0</span>,SubMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(height[left],preMax);</span><br><span class="line">            SubMax = Math.max(height[right],SubMax);</span><br><span class="line">            ans +=preMax&lt;SubMax?preMax-height[left++]:SubMax-height[right--];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个记录左边，一个记录右边</p><p>先记录左边这个小的，就是哪个小先记录哪个</p><p>然后指针移动</p><p>更新最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> preMax= <span class="number">0</span>,SubMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(height[left],preMax);</span><br><span class="line">            SubMax = Math.max(height[right],SubMax);</span><br><span class="line">            ans +=preMax&lt;SubMax?preMax-height[left++]:SubMax-height[right--];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapA</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>,peak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peak)&#123;</span><br><span class="line">                peak = height[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peakInterL</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peakInterL)&#123;</span><br><span class="line">                peakInterL = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=(peakInterL-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peakInterR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> height.length-<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;peakInterR)&#123;</span><br><span class="line">                peakInterR = height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans +=(peakInterR-height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个二次遍历</p><h2 id="72-编辑距离-x"><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a>(x)</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><h2 id="124-二叉树中的最大路径和"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution124</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">LVal</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">RVal</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line">        ans  = Math.max(ans,LVal+RVal+node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(LVal,RVal)+node.val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选择使用左或者右大的哪个，然后最后返回走过的路径，然后记录ans；</p><p>最后返回。</p><h2 id="142-环形链表-II"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        ListNode fast= head,slow  =head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果快慢指针相遇的话，说明有环，然后快指针再从头开始，快慢指针第二次相遇的地方，就是开始入环的第一个节点</p><h2 id="93-复原-IP-地址（回溯）"><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a>（回溯）</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution93</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; segments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;<span class="number">4</span>||s.length()&gt;<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(s,<span class="number">0</span>,segments);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s,<span class="type">int</span> index,List&lt;String&gt; segments)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segments.size()==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index==s.length())&#123;</span><br><span class="line">                ans.add(String.join(<span class="string">&quot;.&quot;</span>,segments));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;len&lt;=<span class="number">3</span>;len++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index+len&gt;s.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">segment</span> <span class="operator">=</span> s.substring(index,index+len);</span><br><span class="line">            <span class="keyword">if</span> (isValid(segment)) &#123;</span><br><span class="line">                segments.add(segment);</span><br><span class="line">                dfs(s, index + len, segments);</span><br><span class="line">                segments.remove(segments.size() - <span class="number">1</span>);  <span class="comment">//恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String segment)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (segment.length() &gt; <span class="number">1</span> &amp;&amp; segment.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(segment);</span><br><span class="line">        <span class="keyword">return</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回溯算法，主要是要符合ip地址的规则</p><h2 id="1143-最长公共子序列"><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p>看到这个就想到了这应该是动态规划问题</p><p>嗯按照灵神的思路慢慢推演</p><p>先是<strong>记忆搜索</strong>，最初级的阶段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] s,t;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        s =text1.toCharArray();</span><br><span class="line">        t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span>s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row:memo)&#123;</span><br><span class="line">            Arrays.fill(row,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j]!=-<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span> (s[i]==t[j]) <span class="keyword">return</span> memo[i][j] = dfs(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j] = Math.max(dfs(i-<span class="number">1</span>,j),dfs(i,j-<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的dfs，然后遇到搜索过的直接调用，减少了时间。</p><p>遇到符合条件的，把这个位置设置为1</p><p>然后返回的时候，去找搜索的时候更好的</p><p>但是这个太慢了，要优化一下</p><p><strong>1:1 翻译成递推</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequenceA</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        s =text1.toCharArray();</span><br><span class="line">        t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span>s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j+<span class="number">1</span>] = s[i] == t[j]?f[i][j]+<span class="number">1</span>:Math.max(f[i][j+<span class="number">1</span>],f[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个主要是递推，就是遍历然后</p><p>下面的i+1,j+1就为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i] == t[j]?f[i][j]+1:Math.max(f[i][j+1],f[i+1][j])</span><br></pre></td></tr></table></figure><p>s[i]和t[j]是不是想到，然后相等的话，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j]</span><br></pre></td></tr></table></figure><p>就+1说明走过了，然后不想的话，就去找下一个路径</p><p>最后公共的就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[n][m]</span><br></pre></td></tr></table></figure><p>然后再进行一波优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequenceB</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> pre=  <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x==t[j]?pre+<span class="number">1</span>:Math.max(f[j+<span class="number">1</span>],f[j]);</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的递推，换成一个数组来操作，这样的话，因为他们的类似方法都是相同的，这样的话，我们直接使用一个数组就可以完成了。</p><h2 id="19-删除链表的倒数第-N-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>想象有一把长度固定的尺子，左端点在链表头部，右端点在正数第 <em>n</em> 个节点。向右移动尺子，当尺子右端点到达链表末尾时，左端点就在倒数第 <em>n</em> 个节点。</p><p>我们需要找到倒数第n+1个节点</p><p>左端点在链表头部，右端点在正数第 <em>n</em>+1 个节点。向右移动尺子，当尺子右端点到达链表末尾时，左端点就在倒数第 <em>n</em>+1 个节点。</p><p>我们可以在头节点的前面插入一个哨兵节点（dummy node），把它当作链表的头节点，这样就有正数第 n+1 个节点了。换句话说，如果遇到需要删除头节点的题目，添加哨兵节点可以简化代码逻辑，请记住这个技巧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solution19A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            left = left.next;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = left.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到这个节点，然后直接跳过这个节点就行了</p><p>就相当于删除了这个节点</p><h2 id="82-删除排序链表中的重复元素-II"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 新头节点，指向原链表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">duplicateVal</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">// 跳过所有重复节点</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == duplicateVal) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数（困难啊）"><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a>（困难啊）</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>如果不限制时间复杂度的话，这个题目还是挺简单的。直接从后面开始遍历数组，合并数组。然后找中间的数即可</p><h2 id="199-二叉树的右视图"><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>这个题目肯定是先从跟节点开始，类似于去找他最右边的那个元素。</p><p>所以我们要先递归这个右子树。就是他的这一层第一次出现的时候，也就是深度第一次出现的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution199</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (depth==ans.size())&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>,ans);</span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p>中序遍历吗。就是根节点在中间</p><p>left root right</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution94</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,ans);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        dfs(root.right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution704</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的二分查找，记得这个是</p><p>可以取到值得</p><h2 id="232-用栈实现队列"><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span>peek();</span><br><span class="line">        B.pop();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!B.isEmpty()) <span class="keyword">return</span> B.peek();</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            B.push(A.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.isEmpty()&amp;&amp;B.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两个栈，入队得时候就是进A栈，然后出栈得时候，就是A出栈得元素，压入B栈，然后B出栈</p><p>实现先进先出FIFO</p><h2 id="165-比较版本号"><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><p>给你两个 <strong>版本号字符串</strong> <code>version1</code> 和 <code>version2</code> ，请你比较它们。版本号由被点 <code>'.'</code> 分开的修订号组成。<strong>修订号的值</strong> 是它 <strong>转换为整数</strong> 并忽略前导零。</p><p>比较版本号时，请按 <strong>从左到右的顺序</strong> 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 <code>0</code>。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution165</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String v1, String v2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> v1.length(),m= v2.length();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n||j&lt;m)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>,num2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n&amp;&amp;v1.charAt(i)!=<span class="string">&#x27;.&#x27;</span>) num1 = num1*<span class="number">10</span>+v1.charAt(i++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;m&amp;&amp;v2.charAt(j)!=<span class="string">&#x27;.&#x27;</span>) num2 = num2*<span class="number">10</span>+v2.charAt(j++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num1&lt;num2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            i++;j++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把小数的哪个分开，然后使用双指针开始遍历</p><p>然后比较</p><h2 id="148-排序链表"><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution148A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> head,f =head,ps = head;</span><br><span class="line">        <span class="keyword">while</span> (f!=<span class="literal">null</span>&amp;&amp;f.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f = f.next.next;</span><br><span class="line">            ps= s;</span><br><span class="line">            s=  s.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l</span>  <span class="operator">=</span>sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> sortList(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(l,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode <span class="title function_">merge</span><span class="params">(ListNode l,ListNode r)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l!=<span class="literal">null</span>&amp;&amp;r!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l.val&lt;=r.val)&#123;</span><br><span class="line">                cur.next = l;</span><br><span class="line">                l = l.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = r;</span><br><span class="line">                r = r.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l==<span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next =r;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了归并排序，跟之前的反转链表类似，找到中点，然后分割，然后进行大小的比较排序</p><h2 id="22-括号生成"><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution22</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>*n];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span> open)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">2</span>*n)&#123;<span class="comment">//填补完成</span></span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open&lt;n)&#123;<span class="comment">//填补左括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,open+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-open&lt;open)&#123;<span class="comment">//填补右括号</span></span><br><span class="line">            path[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>,open);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p><p>从右向左，找第一个小于右侧相邻数字的数 <em>x</em></p><p>找 <em>x</em> 右边最小的大于 <em>x</em> 的数 <em>y</em>，交换 <em>x</em> 和 <em>y</em></p><p>反转 <em>y</em> 右边的数，把右边的数变成最小的排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution31</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,i+<span class="number">1</span>,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            swap(nums,left++,right--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为先找数，然后交交换，然后反转这三步骤。</p><h2 id="69-x-的平方根"><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p>**注意：**不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution69</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = Math.min(x, <span class="number">46340</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid*mid&lt;=x)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用二分查找来解决，注意这里是mid*mid&lt;=x,也就是小于target</p><h2 id="239-滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p>虽然看着说是滑动窗口，其实用队列做是更好的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution239AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindowA(<span class="type">int</span>[] nums, <span class="type">int</span> k )&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span>  <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>,i=<span class="number">1</span>-k;j&lt;nums.length;i++,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;deque.peekFirst()==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()&amp;&amp;deque.peekLast()&lt;nums[j])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">                deque.addLast(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)</span><br><span class="line">                res[i] =deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ans= <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque= <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty()&amp;&amp;nums[deque.getLast()]&lt;=nums[i])&#123;<span class="comment">//入队，维护单调性</span></span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (deque.getFirst()&lt;=i-k)&#123;<span class="comment">//出队队首已经离开窗口了</span></span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=k-<span class="number">1</span>)&#123;队满</span><br><span class="line">                ans[i-k+<span class="number">1</span>] = nums[deque.getFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span>pre;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1==<span class="literal">null</span>?<span class="number">0</span>:l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2==<span class="literal">null</span>?<span class="number">0</span>:l2.val;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span>  <span class="operator">=</span> x+y+carry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            sum = sum%<span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line"></span><br><span class="line">            cur =cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="literal">null</span>)  l1 =l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="literal">null</span>)  l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是实现两个链表数的加法，使用进位的问题</p><h2 id="8-字符串转换整数-atoi"><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li>**空格：**读入字符串并丢弃无用的前导空格（<code>&quot; &quot;</code>）</li><li>**符号：**检查下一个字符（假设还未到字符末尾）为 <code>'-'</code> 还是 <code>'+'</code>。如果两者都不存在，则假定结果为正。</li><li>**转换：**通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。</li><li>**舍入：**如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被舍入为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被舍入为 <code>231 − 1</code> 。</li></ol><p>返回整数作为最终结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Character&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> e : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    started = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    sign = -<span class="number">1</span>;</span><br><span class="line">                    started = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Character.isDigit(e)) &#123;</span><br><span class="line">                    ans.add(e);</span><br><span class="line">                    started = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.isDigit(e)) &#123;</span><br><span class="line">                    ans.add(e);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ans) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; num &gt; Integer.MAX_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (sign == -<span class="number">1</span> &amp;&amp; -num &lt; Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(sign * num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接按要求暴力破解，最后的时候进行一波转换</p><h2 id="70-爬楼梯"><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution70AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">         <span class="keyword">return</span> dfs(n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=<span class="number">0</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="keyword">return</span> memo[i] = dfs(i-<span class="number">1</span>,memo)+dfs(i-<span class="number">2</span>,memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记忆搜推，直接进行</p><h2 id="32-最长有效括号"><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution32A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!stack.isEmpty()&amp;&amp;s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i-leftIndex+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (leftIndex-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    length+=dp[leftIndex-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = length;</span><br><span class="line">                maxlen = Math.max(maxlen,length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一想到了这个有效的括号，我们就想到了用栈来实现</p><p><strong>遇到 <code>'('</code> 左括号就入栈</strong>，记录它的下标。</p><p><strong>遇到 <code>')'</code> 右括号：</strong></p><ul><li><p>如果栈不为空，说明有匹配的左括号。</p></li><li><p>从栈中弹出匹配的左括号的下标 <code>leftIndex</code>。</p></li><li><p>当前这一对括号的<strong>基本长度</strong>就是 <code>i - leftIndex + 1</code>。</p></li><li><p>**注意：*<em>如果 <code>leftIndex &gt; 0</code>，而 <code>dp[leftIndex - 1] &gt; 0</code>，说明前面有一段*<em>连续的有效括号</em></em>，可以加上！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">length = i - leftIndex + 1 + dp[leftIndex - 1];</span><br></pre></td></tr></table></figure></li><li><p>把这段长度记录到 <code>dp[i]</code> 中，表示以 <code>i</code> 为结尾的最长有效括号长度。</p></li><li><p>更新全局最大值 <code>res = Math.max(res, dp[i])</code>。</p></li></ul><h2 id="322-零钱兑换"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>这是背包问题，</p><p>问：关于完全背包，有两种写法，一种是外层循环枚举物品，内层循环枚举体积；另一种是外层循环枚举体积，内层循环枚举物品。如何评价这两种写法的优劣？</p><p>答：两种写法都可以，但更推荐前者。外层循环枚举物品的写法，只会遍历物品数组一次；而内层循环枚举物品的写法，会遍历物品数组多次。从 cache 的角度分析，多次遍历数组会导致额外的 cache miss，带来额外的开销。所以虽然这两种写法的时间空间复杂度是一样的，但外层循环枚举物品的写法常数更小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution322</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(f,Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line">        f[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:coins)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c=x;c&lt;=amount;c++)&#123;</span><br><span class="line">                f[c] = Math.min(f[c],f[c-x]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[amount];</span><br><span class="line">        <span class="keyword">return</span> ans&lt;Integer.MAX_VALUE/<span class="number">2</span>?ans:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全背包，先物品再容量.<strong>内层遍历背包容量（从小到大）：</strong>,如果当前容量 <code>c</code> 用当前硬币 <code>x</code>，可以转移为 <code>f[c - x] + 1</code>（多用了1个 <code>x</code> 面额硬币）。</p><h2 id="43-字符串相乘"><a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘</a></h2><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p>**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution43</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>)||num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[num1.length()+num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (res[i+j+<span class="number">1</span>]+n1*n2);</span><br><span class="line">                res[i+j+<span class="number">1</span>] =sum%<span class="number">10</span>;</span><br><span class="line">                res[i+j] +=sum/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;res[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            result.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是讲乘法拆开，然后根据</p><p>乘数 <code>num1</code> 位数为 <em>M</em>，被乘数 <code>num2</code> 位数为 <em>N</em>， <code>num1 x num2</code> 结果 <code>res</code> 最大总位数为 <strong>M+N</strong></p><p>num1[i] x num2[j] 的结果为 tmp(位数为两位，“0x”, “xy” 的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。</p><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution105AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> indexOf(inorder,preorder[<span class="number">0</span>]);<span class="comment">//左子树大小</span></span><br><span class="line">        <span class="type">int</span>[] pre1 = Arrays.copyOfRange(preorder,<span class="number">1</span>,<span class="number">1</span>+leftSize);<span class="comment">//左子树序列</span></span><br><span class="line">        <span class="type">int</span>[] pre2 = Arrays.copyOfRange(preorder,<span class="number">1</span>+leftSize,n);<span class="comment">//右子树序列</span></span><br><span class="line">        <span class="type">int</span>[] in1 =Arrays.copyOfRange(inorder,<span class="number">0</span>,leftSize);<span class="comment">//左子树</span></span><br><span class="line">        <span class="type">int</span>[] in2 = Arrays.copyOfRange(inorder,<span class="number">1</span>+leftSize,n);<span class="comment">//右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> buildTree(pre1,in1);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> buildTree(pre2,in2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>],left,right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> x)</span>&#123;<span class="comment">//查找位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]==x)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是根据两个遍历，一层一层的递归，然后完成查找。速度有些慢就是了</p><h2 id="LCR-140-训练计划-II"><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">LCR 140. 训练计划 II</a></h2><p>给定一个头节点为 <code>head</code> 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 <code>cnt</code> 个训练项目编号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionLCR140</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainingPlan</span><span class="params">(ListNode head, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1: 将链表的 val 存入数组</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            vals.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step2: 从 vals 的最后 cnt 位构造新链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> vals.size() - cnt; i &lt; vals.size(); i++) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(vals.get(i));</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我就是把这个链表的数据提取出来，然后放入新的链表</p><p>时间复杂度太高了</p><p>然后使用了快慢指针来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionLCR140</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainingPlanA</span><span class="params">(ListNode head, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step1: 将链表的 val 存入数组</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            vals.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step2: 从 vals 的最后 cnt 位构造新链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> vals.size() - cnt; i &lt; vals.size(); i++) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(vals.get(i));</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">trainingPlan</span><span class="params">(ListNode head, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        node1 = head;</span><br><span class="line">        node2 = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node2.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>确实这个方法好啊</p><p>类似的可以找出从中点开始的链表</p><h2 id="151-反转字符串中的单词"><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>**注意：**输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution151</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        String[] str = s.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>str.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i].equals(<span class="string">&quot;&quot;</span>))<span class="keyword">continue</span>;</span><br><span class="line">            res.append(str[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们直接倒着遍历不得了</p><p>遇到空格就跳过继续，然后把当前拿到的全都放入结果</p><h2 id="78-子集"><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p>看到这种题目就知识这应该是使用回溯算法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution78A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i== nums.length)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(i+<span class="number">1</span>);</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        dfs(i+<span class="number">1</span>);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回溯法，就是选不选第i个</p><h2 id="129-求根节点到叶节点数字之和"><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h2><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solution129</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x  =x*<span class="number">10</span>+node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.left==node.right)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(node.left,x)+dfs(node.right,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是遍历，然后到下一层的时候，*10+node.val就ok</p><h2 id="155-最小栈"><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (min_stack.isEmpty()||x&lt;=min_stack.peek())&#123;</span><br><span class="line">            min_stack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>     <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.pop().equals(min_stack.peek()))&#123;</span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>     <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用两个栈，然后最小的栈存储最小的元素，然后维护这个最小栈</p><h2 id="101-对称二叉树"><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution101A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">null</span>||recur(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L,TreeNode R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>&amp;&amp;R==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (L==<span class="literal">null</span>||R==<span class="literal">null</span>||L.val!=R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(L.left,R.right)&amp;&amp;recur(R.left,L.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是遍历，左的左要等于右的右这样的</p><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution34AA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> lowBound(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length || nums[start] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lowBound(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length; <span class="comment">// 注意 right = nums.length，开区间写法</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid; <span class="comment">// nums[mid] &gt;= target</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找，，，</p><h2 id="104-二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution104AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的递归</p><h2 id="39-组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution93AA</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state,<span class="type">int</span> target,<span class="type">int</span>[] choices,<span class="type">int</span> start,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=start;i&lt;choices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target-choices[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            state.add(choices[i]);</span><br><span class="line">            backtrack(state,target-choices[i],choices,i,res);</span><br><span class="line">            state.remove(state.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(state,target,candidates,start,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是回溯法+递归，一个一个去遍历找，然后最后恢复</p><h2 id="394-字符串解码"><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution394</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; countstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;StringBuilder&gt; stringstack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">currentString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c))&#123;</span><br><span class="line">                k = k*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                countstack.push(k);</span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">                stringstack.push(currentString);</span><br><span class="line">                currentString = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> countstack.pop();</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> stringstack.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;repeat;i++)&#123;</span><br><span class="line">                    sb.append(currentString);</span><br><span class="line">                &#125;</span><br><span class="line">                currentString = sb;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                currentString.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentString.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左括号的话，就往字符栈里加字符，然后把重复的次数加进数字栈</p><p>然后右括号的时候</p><p>就把数字取出来，作为重复次数，字符栈取出来作为重复的字符</p><p>然后重复就好，单纯的字符就直接加入</p><p>最后返回字符串</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/28/leetcode/leetocdehot1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JAVA设计模式面试题目hot</title>
      <link>https://blog.tokenlen.top/2025/05/27/java-stack/javasample1/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/java-stack/javasample1/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;Controller&lt;/h1&gt;
&lt;h2 id=&quot;1-写一个简单的登录接口的Controller，包含用户ID和密码字段。&quot;&gt;1.写一个简单的登录接口的Controller，包含用户ID和密码字段。&lt;/h2&gt;
&lt;figure class=&quot;highlight</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>Controller</h1><h2 id="1-写一个简单的登录接口的Controller，包含用户ID和密码字段。">1.写一个简单的登录接口的Controller，包含用户ID和密码字段。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUserId(request.getUserId());</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!user.getPassword().equals(request.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟生成 JWT（可替换为真实生成）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createToken(user.getId().toString(), <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 10分钟有效</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; response = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        response.put(<span class="string">&quot;accessToken&quot;</span>, token);</span><br><span class="line">        response.put(<span class="string">&quot;userId&quot;</span>, user.getId());</span><br><span class="line">        response.put(<span class="string">&quot;username&quot;</span>, user.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findByUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟查库</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(userId)) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setId(<span class="number">1L</span>);</span><br><span class="line">            user.setUserId(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">            user.setUsername(<span class="string">&quot;管理员&quot;</span>);</span><br><span class="line">            user.setPassword(<span class="string">&quot;123456&quot;</span>); <span class="comment">// 明文密码仅用于演示</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-对于POST请求，你是直接用参数接收，还是封装成对象接收？">2.对于POST请求，你是直接用参数接收，还是封装成对象接收？</h2><p>封装成对象来接受。</p><p>在开发中，对于 POST 请求，我更倾向于使用 <code>@RequestBody</code> 将参数封装成对象。这种方式更清晰、可维护，也方便进行参数校验和自动生成 Swagger 文档。如果参数较少、是简单的表单提交，偶尔也可以用 <code>@RequestParam</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> request.getUserId();</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getPassword();</span><br><span class="line">    <span class="comment">// 登录逻辑...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装成类，参数多的时候，不宜混乱，方便扩展，新增字段的时候，不用改方法签名，支持验证注解，如 <code>@NotBlank</code>、<code>@Size</code> 直接加在类字段上。更加适合Swagger自动文档，自动识别请求结构。</p><p>不封装的话，参数签名越来越长，而且无法处理 <code>application/json</code> 请求。不能队单个字段加验证规则。</p><h2 id="3-你在工作中是如何进行参数非空校验的？">3.你在工作中是如何进行参数非空校验的？</h2><p>在工作中，我会根据具体场景，在 <strong>三个层次</strong> 对参数进行非空校验：</p><ol><li><strong>前端校验</strong>：前端通过 JS 或组件校验框架（如 Element Plus 表单校验、AntD Rule）来做第一层参数合法性校验，提升用户体验。</li><li><strong>后端控制层校验（推荐）</strong>：使用 Spring 的 <code>javax.validation</code> 注解（如 <code>@NotBlank</code>、<code>@NotNull</code>、<code>@Size</code>）结合 <code>@Valid</code> 实现自动参数校验，<strong>统一异常处理</strong>返回提示。</li><li><strong>业务逻辑校验（服务层）</strong>：对关键参数进行业务校验（如账号是否存在、密码是否为空、两个字段不能同时为空等），保证逻辑正确性。</li></ol><p>controller层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">    <span class="comment">// 如果参数校验失败，会自动抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> authService.login(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DTO+注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleValidationException(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ex.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(Map.of(<span class="string">&quot;error&quot;</span>, msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还封装了统一的 <code>BaseRequest</code> 类 + 参数校验通用注解，配合全局异常返回标准化的错误结构，做到接口友好、开发高效。</p><p>BaseRequest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseRequest</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;请求时间戳不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;请求来源不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String source; <span class="comment">// web / app / admin 等</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;签名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sign;   <span class="comment">// 用于简单签名校验</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequest</span> <span class="keyword">extends</span> <span class="title class_">BaseRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Controller 中使用 <code>@Valid</code> 接收参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; login(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> LoginRequest request) &#123;</span><br><span class="line">    <span class="comment">// 校验通过，执行业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> authService.login(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局异常处理返回统一格式（如 <code>Result&lt;T&gt;</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">200</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; error(String message) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">400</span>, message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数校验统一异常处理（<code>@ControllerAdvice</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&lt;?&gt;&gt; handleValidation(MethodArgumentNotValidException ex) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> ex.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(Result.error(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他通用异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们项目里统一封装了请求基类 <code>BaseRequest</code>，每个接口请求都包含 timestamp、source、sign 等字段，同时结合 Spring 的 <code>@Valid</code> 和自定义的通用注解进行字段校验，配合统一异常处理类，返回格式统一成 <code>Result&lt;T&gt;</code>。这样接口文档清晰、调试方便、前后端联调效率高，开发体验提升很多。</p><h1>设计模式</h1><table><thead><tr><th>分类</th><th>模式</th><th>作用</th><th>示例关键点</th></tr></thead><tbody><tr><td>创建型</td><td>单例模式</td><td>保证全局只有一个实例</td><td>Spring 中的 Bean 默认就是单例</td></tr><tr><td>创建型</td><td>工厂模式</td><td>统一创建对象</td><td>数据库连接、策略类</td></tr><tr><td>结构型</td><td>代理模式</td><td>给目标对象增加额外功能</td><td>Spring AOP、事务、日志</td></tr><tr><td>结构型</td><td>装饰器模式</td><td>动态扩展对象功能</td><td>IO 流、过滤器链</td></tr><tr><td>行为型</td><td>策略模式</td><td>可切换的行为算法</td><td>支付、消息推送</td></tr><tr><td>行为型</td><td>观察者模式</td><td>发布/订阅事件通知</td><td>MQ、事件监听</td></tr><tr><td>行为型</td><td>模板方法</td><td>固定流程 + 可变步骤</td><td>抽象 Controller、登录流程</td></tr><tr><td>行为型</td><td>责任链模式</td><td>多个处理器依次处理</td><td>过滤器链、权限认证</td></tr><tr><td>行为型</td><td>状态模式</td><td>对象状态驱动行为</td><td>订单、任务状态</td></tr><tr><td>行为型</td><td>命令模式</td><td>把操作封装成对象</td><td>任务撤销、限流操作命令</td></tr></tbody></table><h2 id="单例模式">单例模式</h2><p>确保一个类在整个应用中 <strong>只有一个实例</strong>，并提供一个全局访问点。</p><ul><li>Redis 工具类、线程池、连接池、配置类等</li><li>Spring 默认是单例 Bean（IOC 控制）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 防止指令重排</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于volatile和synchronized</p><p><code>volatile</code>：防止 JVM 指令重排序，确保实例初始化完成后再赋值。</p><p>双重校验：第一次 if 避免每次加锁，第二次 if 避免并发重复创建。</p><p>比如Calendar:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>比如 Logger：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = Logger.getLogger(MyClass.class.getName());</span><br></pre></td></tr></table></figure><p>单例的实现方式：</p><p><strong>饿汉式（静态初始化）</strong>：类加载时直接创建实例，线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单可靠，类加载即初始化，无线程安全问题。不管是否使用都会创建实例，可能浪费内存。</p><p><strong>懒汉式（同步方法）</strong>：首次使用时创建实例，用 synchronized 保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟初始化，节省内存。</p><p>synchronized 锁在方法级别，并发访问时性能较低。</p><p><strong>双重检查锁（DCL）</strong>：用 Volatile + 双重判空 + synchronized，兼顾性能和安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">// 防止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一重判空</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// 锁类</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二重判空</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 非原子操作，需Volatile</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅在第一次创建时加锁，性能高，JDK1.5 后安全。</p><p>instance 必须用<code>volatile</code>修饰，避免多线程下初始化顺序问题。</p><p><strong>静态内部类（推荐！）</strong>：利用类加载机制，内部类加载时创建实例，线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟初始化，代码简洁，JVM 保证线程安全，无反射破坏问题（需额外处理）。</p><p><strong>枚举方式</strong>:枚举类天然单例，防反射、防序列化破坏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">// 可添加方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂模式">工厂模式</h2><p>根据不同类型 <strong>生成不同实现类实例</strong>，解耦对象创建过程。</p><ul><li><p>根据类型创建支付处理器、登录方式、导出类型等</p></li><li><p>创建支付方式（支付宝、微信）</p><p>创建导出服务（Excel、PDF）</p><p>登录策略、文件解析等类型多变组件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExportService <span class="title function_">getExport</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;excel&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExcelExportService</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不支持的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ExportService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">export</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExcelExportService</span> <span class="keyword">implements</span> <span class="title class_">ExportService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;导出Excel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合接口隔离 + 枚举注册</p><p>通过工厂类封装创建逻辑</p><p>返回的是接口类型，利于扩展和解耦</p><p>结合枚举或配置可实现<strong>注册式工厂</strong></p><h2 id="策略模式">策略模式</h2><p>定义一系列算法（策略），并使它们可以相互替换。<strong>将行为与选择解耦</strong>。定义算法族，封装后可相互替换，客户端根据条件选择算法。</p><p>多种支付方式、登录方式、审核策略等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayContext</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,PayStrategy&gt; paymap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dopay</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="type">PayStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> paymap.get(type);</span><br><span class="line">        <span class="keyword">if</span> (strategy!=<span class="literal">null</span>) strategy.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">PayStrategy</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component(&quot;aliPay&quot;)</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">implements</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component(&quot;wechatPay&quot;)</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">WeChatPay</span> <span class="keyword">implements</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;微信支付&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用 Spring 容器自动注入所有策略 Bean</p><p>根据 key 获取策略执行对应逻辑，避免写死 if-else 或 switch</p><p>和工厂模式的最大区别是：<strong>策略封装行为，工厂封装创建</strong></p><p>面试题目：设计模式场景题：比如现在有支付宝、微信、各大银行卡等支付方式，最坏的情况是写了20多个if-else判断是用户选择哪种支付方式，耦合度很高，如果叫你优化，你怎么想？</p><p>我们可以使用策略模式，先封装一个支付的接口，然后把每个支付的方式分装成类，然后用一个map集合或者是工厂类来让用户选择具体的是哪个支付方式，这样就避免了大量使用if-else。</p><p>需要一个接口，然后具体的实现类，然后一个工厂类，使用map简化策略选择。还有一个策略的上下文类</p><p>然后客户端调用上下文类（里面是工厂实例），然后选择支付金额。这里的支付金额要使用BigDecimal</p><p>因为 <code>double</code> 是<strong>二进制浮点数</strong>，在进行运算时会出现<strong>精度误差</strong></p><p>使用BigDecimal <strong>基于字符串表示的小数类</strong>，可以实现精确计算，避免金额误差，防止“丢钱”或“多扣”的风险。</p><h2 id="代理模式">代理模式</h2><p>在不修改目标类的情况下，<strong>增强其功能（如日志、权限、事务等）</strong></p><p>日志、权限、事务控制、接口限流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.mengnankk.designpattern.Log)&quot;)</span> <span class="comment">// 指定注解全路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint point)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法：&quot;</span> + point.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AOP 本质是动态代理（JDK 或 CGLIB）</p><p>利用切点表达式 <code>@annotation</code> 定位目标方法</p><p>增强功能通过切面类编织</p><h2 id="修饰器模式">修饰器模式</h2><p>在不修改原始对象的情况下，<strong>动态增强其功能</strong>（与代理很像，区别是包装对象）</p><p>请求/响应增强处理、日志追加处理、加密/解密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengnankk.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestLogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化逻辑（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录请求日志&quot;</span>);</span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 资源释放逻辑（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类似代理，但更偏向“嵌套增强”</p><p>典型用法是 <strong>Filter、Interceptor</strong>，形成处理链</p><p>可以组合多个修饰器链式增强</p><h2 id="适配器模式">适配器模式</h2><p><strong>配器模式</strong>像是“插头转换器”，让两个原本不兼容的接口连接上。</p><ul><li><strong>类适配器</strong>：通过继承适配源类，实现目标接口（Java 单继承限制，使用较少）。</li><li><strong>对象适配器</strong>：通过组合源类实例，实现目标接口（更常用）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String type, String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playAudio</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;播放音频：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioAdapter</span> <span class="keyword">implements</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">OldPlayer</span> <span class="variable">oldPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OldPlayer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String type, String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;mp3&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            oldPlayer.playAudio(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDBC 驱动适配不同数据库、Spring MVC 的适配器处理不同请求。</p><table><thead><tr><th>维度</th><th>代理模式</th><th>适配器模式</th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>控制访问目标对象，添加附加逻辑</td><td>接口不兼容时进行适配</td></tr><tr><td><strong>原始类</strong></td><td>与代理类实现同一接口</td><td>与目标接口<strong>无关</strong>，通过包装“适配”</td></tr><tr><td><strong>使用时机</strong></td><td>不想或不能直接访问目标对象，增加功能（如远程调用、权限）</td><td>复用已有类但其接口不符合当前系统要求</td></tr><tr><td><strong>是否增强</strong></td><td>是，可以添加前置/后置逻辑</td><td>否，仅做接口适配</td></tr></tbody></table><h2 id="模板方法模式">模板方法模式</h2><p>模板方法，比如说有三个模板方法A、B、C，第一个子类我想让他实现ABC这么执行，第二个子类我想让他实现ACB，这个怎么实现？（使用“钩子方法”，抽离一个方法返回true、false，true就ABC，false就ACB）</p><p><strong>模板方法模式</strong> + <strong>钩子方法（Hook）自定义流程控制</strong>。</p><p>在抽象类中定义整体流程 A → B → C，然后用<strong>钩子方法来控制流程顺序</strong>：</p><ul><li>抽象类中定义 <code>template()</code> 模板方法</li><li><code>A()</code> 和 <code>C()</code> 是固定流程</li><li><code>B()</code> 是可选的</li><li>使用 <code>shouldDoB()</code> 钩子方法（返回 true/false）来决定执行顺序，是 ABC 还是 ACB</li></ul><p>定义抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        A();</span><br><span class="line">        <span class="keyword">if</span> (shouldDoBFirst()) &#123;</span><br><span class="line">            B();</span><br><span class="line">            C();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            C();</span><br><span class="line">            B();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法，默认返回 true，即执行 ABC</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldDoBFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类去继承这个抽象类，然后重写父类的方法shouldDoBFirst,按照需求重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstChild</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;B&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;C&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldDoBFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 默认就是 ABC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>java扩展</h1><h2 id="1-同步和异步的区别是什么？">1.同步和异步的区别是什么？</h2><p><strong>同步（Synchronous）和异步（Asynchronous）</strong> 是两种不同的任务执行方式，主要区别在于任务的执行是否需要等待其他任务完成。</p><p>同步的话是需要等待任务完成之后，收到返回的确认请求的时候再进行其他的</p><p>异步的话，就是不需要等待，直接进行下一步任务</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/java-stack/javasample1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode动态规划</title>
      <link>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;爬楼梯&lt;/h1&gt;
&lt;h2 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;https://leetcode.cn/problems/climbing-stairs/&quot;&gt;70. 爬楼梯&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;假设你正在爬楼梯。需要 &lt;code&gt;n&lt;/code&gt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>爬楼梯</h1><h2 id="70-爬楼梯"><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>按着数学来看的话，就是如果是1阶梯的话，就是1</p><p>大于等于2的有两种，是i-1+(i-2)</p><p>然后我们使用记忆数组来记忆之前算过的</p><p>然后使用递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution70A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n )</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo  = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>  (memo[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = dfs(i-<span class="number">1</span>,memo)+dfs(i-<span class="number">2</span>,memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到记忆数组不是1的，调用记忆数组，为0的就直接计算</p><p>这样就不会超时</p><h2 id="746-使用最小花费爬楼梯"><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution746</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span> [] memo = <span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(n,memo,cost);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span>[] memo,<span class="type">int</span>[] cost)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> dfs(i-<span class="number">1</span>,memo,cost)+cost[i-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> dfs(i-<span class="number">2</span>,memo,cost)+cost[i-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> memo[i] = Math.min(res2,res1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面那个题一样，只不过最后取的时候，是看花费哪个少了</p><h2 id="377-组合总和-Ⅳ"><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>本质还是爬楼梯问题啊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution377</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(target,nums,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span>[] nums,<span class="type">int</span>[] memo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;=i)&#123;</span><br><span class="line">                res +=dfs(i-x,nums,memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i]  = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是类似的</p><h2 id="2466-统计构造好字符串的方案数"><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 统计构造好字符串的方案数</a></h2><p>给你整数 <code>zero</code> ，<code>one</code> ，<code>low</code> 和 <code>high</code> ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p><ul><li>将 <code>'0'</code> 在字符串末尾添加 <code>zero</code> 次。</li><li>将 <code>'1'</code> 在字符串末尾添加 <code>one</code> 次。</li></ul><p>以上操作可以执行任意次。</p><p>如果通过以上过程得到一个 <strong>长度</strong> 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <strong>好</strong> 字符串。</p><p>请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2466</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span>[high+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=zero) f[i] = f[i-zero];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=one) f[i] = (f[i]+f[i-one])%MOD;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=low) ans = (ans+f[i])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递推</p><p>相当于把递推式 <em>f</em>[<em>i</em>]=<em>f</em>[<em>i</em>−<em>zero</em>]+<em>f</em>[<em>i</em>−<em>one</em>] 拆分成了两步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[high + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>); <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt;= high; i++) &#123;</span><br><span class="line">            ans = (ans + dfs(i, zero, one, memo)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> zero, <span class="type">int</span> one, <span class="type">int</span>[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = (dfs(i - zero, zero, one, memo) + dfs(i - one, zero, one, memo)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记忆递推方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/leetcode/leetcode4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>shopping-web项目八股分析</title>
      <link>https://blog.tokenlen.top/2025/05/27/workmenu/shopping-web2/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/workmenu/shopping-web2/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;从整体分析这个项目&lt;/p&gt;
&lt;p&gt;然后加入一些别的项目的通用的知识&lt;/p&gt;
&lt;p&gt;其他项目加入的：：：&lt;/p&gt;
&lt;h1&gt;亮点&lt;/h1&gt;
&lt;h2 id=&quot;身份认证与权限校验&quot;&gt;身份认证与权限校验&lt;/h2&gt;
&lt;p&gt;使用令牌技术实现身份验证，用自定栏截器完成用户认证，并结合</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>从整体分析这个项目</p><p>然后加入一些别的项目的通用的知识</p><p>其他项目加入的：：：</p><h1>亮点</h1><h2 id="身份认证与权限校验">身份认证与权限校验</h2><p>使用令牌技术实现身份验证，用自定栏截器完成用户认证，并结合 ThreadLocal进行截器校验，保障系统安全访间。</p><p><strong>基于Spring Boot + JWT的完整身份认证示例</strong>，包含：</p><ul><li>JWT生成和解析工具类</li><li>认证拦截器（拦截请求验证JWT）</li><li>ThreadLocal存储当前用户信息</li><li>配置拦截器注册</li><li>简单的用户控制器示例</li></ul><h3 id="问题解析">问题解析</h3><h4 id="1-JWT的组成">1.JWT的组成</h4><p>Header（头部）:描述签名的元数据，包含alg(签名算法) HS256，RS256,typ(令牌的类型)通常为JWT，base64URL编码作为一个片段</p><p>Payload：存放业务数据和标准声明（Claims），</p><p><strong>RFC定义</strong>：<code>iss</code>（签发者）、<code>sub</code>（主题）、<code>aud</code>（受众）、<code>exp</code>（过期时间）、<code>iat</code>（签发时间）</p><p><strong>Public Claims</strong>：用户自定义，但要避免冲突</p><p><strong>Private Claims</strong>：双方约定的自定义字段（如 <code>userId</code>、<code>roles</code>）</p><p>Signature（签名）：</p><p>用 <code>Base64Url(Header) + &quot;.&quot; + Base64Url(Payload)</code>，再加上密钥，通过指定算法（如 HMAC SHA256）计算得到。</p><p>防止数据被篡改：接收方用<strong>相同算法和密钥校验签名</strong>。</p><h4 id="2-为什么要设置-exp，以及如何处理过期？">2.为什么要设置 <code>exp</code>，以及如何处理过期？</h4><p>限制令牌的有效期，降低泄露后滥用风险，强制客户端<strong>定期获取新令牌</strong>，有助于权限变更及时生效。</p><p>自动处理过期：</p><p><strong>自动拒绝</strong>：在解析 JWT 时，库（如 jjwt）会抛出 <code>ExpiredJwtException</code>，拦截器／过滤器捕获后返回 <code>401 Unauthorized</code>。</p><p><strong>Refresh Token</strong> 机制：</p><p>Access Token（短时有效）+ Refresh Token（长期有效且存放更安全）</p><p>Access Token 过期后，客户端用 Refresh Token 向专门接口换取新的 Access Token。</p><p><strong>服务端黑名单</strong>：对关键场景，可在 Redis 等存储过期或手动废弃的 Token ID 列表，拦截时进一步比对。</p><h3 id="3-对称加密（HS256）与非对称加密（RS256）的区别？">3.对称加密（HS256）与非对称加密（RS256）的区别？</h3><table><thead><tr><th>特性</th><th>HS256（对称）</th><th>RS256（非对称）</th></tr></thead><tbody><tr><td><strong>密钥</strong></td><td>同一个密钥用于签名和校验</td><td>使用私钥签名，公钥校验</td></tr><tr><td><strong>安全性</strong></td><td>只要共享密钥不会泄露；多服务时需安全分发密钥</td><td>私钥只在签发端保存，公钥可公开，泄露风险低</td></tr><tr><td><strong>性能</strong></td><td>HMAC 速度快</td><td>RSA 运算相对慢一些</td></tr><tr><td><strong>应用场景</strong></td><td>小规模或单体应用，部署简单</td><td>分布式/微服务或第三方验证场景，私钥保护更好</td></tr></tbody></table><h3 id="4-HandlerInterceptor-与-Filter-的区别？">4.<code>HandlerInterceptor</code> 与 <code>Filter</code> 的区别？</h3><table><thead><tr><th>方面</th><th>Filter</th><th>HandlerInterceptor</th></tr></thead><tbody><tr><td><strong>加载时机</strong></td><td>最早，Servlet 容器启动时配置，位于 Spring MVC 之前</td><td>在 Spring MVC 内部，Controller 调用前后拦截</td></tr><tr><td><strong>接口</strong></td><td><code>javax.servlet.Filter</code></td><td><code>org.springframework.web.servlet.HandlerInterceptor</code></td></tr><tr><td><strong>职责</strong></td><td>通用请求预处理：如日志、跨域、请求包装、字符编码</td><td>更贴近 MVC：可以访问 Handler（Controller）信息，做方法级鉴权</td></tr><tr><td><strong>配置方式</strong></td><td><code>@WebFilter</code>、<code>FilterRegistrationBean</code> 等</td><td>实现 <code>WebMvcConfigurer#addInterceptors</code> 注册</td></tr><tr><td><strong>方法</strong></td><td><code>doFilter</code></td><td><code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code></td></tr></tbody></table><h3 id="5-如何配置某些路径放行？">5.如何配置某些路径放行？</h3><p>比如我们让他不用登录就能看的一些页面，商品展示等等</p><p>在 Spring MVC 拦截器注册时，通过 <code>excludePathPatterns(...)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(jwtInterceptor)</span><br><span class="line">        .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>)           <span class="comment">// 拦截所有 /api/**</span></span><br><span class="line">        .excludePathPatterns(</span><br><span class="line">            <span class="string">&quot;/api/auth/**&quot;</span>,                  <span class="comment">// 放行认证相关</span></span><br><span class="line">            <span class="string">&quot;/swagger-ui/**&quot;</span>, <span class="string">&quot;/v3/api-docs&quot;</span>  <span class="comment">// 放行 Swagger</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>如果是 Filter，可在内部判断请求 URI，或在 <code>FilterRegistrationBean</code> 中设置 <code>setUrlPatterns</code> 与 <code>setOrder</code>。</p><h3 id="6-Spring-Boot-默认哪些静态资源路径？是否会被拦截？">6.Spring Boot 默认哪些静态资源路径？是否会被拦截？</h3><ul><li><strong>默认路径（classpath 下）</strong><ul><li><code>/static</code></li><li><code>/public</code></li><li><code>/resources</code></li><li><code>/META-INF/resources</code></li></ul></li><li><strong>是否被拦截？</strong><ul><li>Spring MVC 的拦截器默认只拦截 <code>/**</code>，但静态资源由 <code>ResourceHttpRequestHandler</code> 处理，优先级高于一般的 Controller 调用。</li><li><strong>如果</strong>在 <code>addInterceptors</code> 中使用了拦截所有 <code>/**</code>，且拦截匹配到静态资源路径，就有可能拦截；但通常我们会在 <code>excludePathPatterns(&quot;/**/*.js&quot;, &quot;/**/*.css&quot;, &quot;/**/*.png&quot;, ...&quot;)</code> 或直接排除静态资源目录，确保静态资源正常加载。</li></ul></li></ul><h3 id="7-为什么要在-afterCompletion-清理-ThreadLocal？">7.为什么要在 <code>afterCompletion</code> 清理 <code>ThreadLocal</code>？</h3><p><code>ThreadLocal</code> 存储的数据与当前线程绑定。</p><p>在高并发环境下，使用线程池复用线程，如果不手动清理，后续请求可能读取到上一个用户的信息，导致<strong>数据泄露</strong>或<strong>安全漏洞</strong>。</p><p><code>afterCompletion</code> 保证在请求处理完毕后无论正常或异常，都能移除数据，防止内存泄露。</p><p>或者是如果不清理的话，因为是弱引用，ThreadLocal的key很容易被清理，其还有null的键，一直在那里呆着。所以要使用remove清理或者是，查找与当前线程关联的Map并将键值对设置为当前线程和null，Huoz是在finally中关闭ThreadLocal。</p><h3 id="8-并发场景下-ThreadLocal-的适用与限制？">8.并发场景下 <code>ThreadLocal</code> 的适用与限制？</h3><p><strong>适用</strong>：</p><ul><li>存放与当前请求、当前<strong>线程强关联的数据</strong>（如用户上下文、事务 ID）</li><li>避免在方法间频繁传参</li></ul><p><strong>限制</strong>：</p><ul><li>必须在请求<strong>结束后清理</strong>，否则线程复用会导致“上下文串库”</li><li>不能跨线程（如异步执行、线程池任务）共享；如果在子线程里尝试取数据，需要显式传递或使用 <code>InheritableThreadLocal</code>（但要注意 GC 风险）</li><li>大量数据存放会增加内存压力</li></ul><p>或者是如果不清理的话，因为是弱引用，ThreadLocal的key很容易被清理，其还有null的键，一直在那里呆着。所以要使用remove清理或者是，查找与当前线程关联的Map并将键值对设置为当前线程和null，Huoz是在finally中关闭ThreadLocal。</p><h3 id="9-如何安全地存储用户密码？">9.如何安全地存储用户密码？</h3><p><strong>一定要哈希</strong>，切忌明文存储。</p><p><strong>使用强单向哈希算法</strong>，推荐：</p><ul><li>BCrypt（Spring Security 默认支持）</li><li>Argon2、PBKDF2</li></ul><p><strong>加盐</strong>：每个用户使用<strong>独立随机盐</strong>，防止彩虹表攻击。</p><p><strong>适当迭代</strong>：增加计算成本，防止暴力破解。</p><h3 id="10-为什么不要把敏感信息（如密码）放到-JWT-里？">10.为什么不要把敏感信息（如密码）放到 JWT 里？</h3><p><strong>JWT Payload 可被任意方 Base64Url 解码</strong>，不具备机密性。</p><p>即使<strong>签名防篡改</strong>，也无法防止任何人读取其中的明文数据。</p><p>应只放必要的非敏感标识（如 <code>userId</code>、<code>roles</code>），<strong>敏感数据应在后台按需查询</strong>。</p><h3 id="11-Token-在前端如何存储（localStorage-vs-HttpOnly-Cookie）？">11.Token 在前端如何存储（localStorage vs HttpOnly Cookie）？</h3><table><thead><tr><th>存储方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>localStorage</strong></td><td>简单易用，JS 可直接读写</td><td>易受 XSS 攻击：恶意脚本可读取并窃取 Token</td></tr><tr><td><strong>HttpOnly Cookie</strong></td><td>JS 无法读取，能自动随请求带上，防止 XSS</td><td>需防范 CSRF（可配合 SameSite、双重提交 Cookie）</td></tr></tbody></table><p><strong>最佳实践</strong>：</p><ul><li>推荐将 <strong>Access Token</strong> 存在 <strong>HttpOnly</strong>、Secure、SameSite=strict 的 Cookie 中；</li><li>如果仍需在 JS 中访问，可用 Refresh Token 短时写入 <code>localStorage</code>，但严格防 XSS。</li><li>同时配合 CSRF 令牌、CORS 白名单、内容安全策略（CSP）等。</li></ul><h3 id="1-你们的认证机制是怎么做的？为什么用-JWT？">1.<strong>你们的认证机制是怎么做的？为什么用 JWT？</strong></h3><p>前后端分离架构下使用 <strong>JWT 无状态令牌</strong>，用户登录后由服务端生成 Token，后续请求携带 Token 完成身份验证</p><p>与传统 Session 相比，JWT 不依赖服务端存储，<strong>更适合分布式微服务场景</strong></p><p>签名机制可防止 Token 被伪造，Payload 可携带 <code>userId</code> 等信息减少数据库查询</p><h3 id="2-如何设计-Token-刷新机制？">2.如何设计 Token 刷新机制？</h3><p>在拦截器中检查 Token 剩余有效时间</p><p>当 Token 临近过期（例如剩余 &lt;5 分钟）时，<strong>自动生成新 Token 并通过响应头或 Cookie 返回</strong></p><p>提高用户体验，避免频繁重新登录</p><p>可配合 Refresh Token 强化安全性</p><h3 id="3-为什么使用-ThreadLocal？是否存在线程安全问题？">3.为什么使用 ThreadLocal？是否存在线程安全问题？</h3><p>ThreadLocal 将<strong>用户信息与线程</strong>绑定，避免在每个方法中重复查询、传参，减少数据库/Redis 压力</p><p>在 Controller 层可直接通过 <code>UserHolder.get()</code> 获取用户信息，提升性能（如从 200ms 降到 20ms）</p><p><strong>线程安全性保障</strong>：</p><ul><li>每个线程有独立副本</li><li>使用线程池时必须手动 <code>remove()</code>，否则用户数据串用 → 安全隐患</li></ul><p><strong>限制</strong>：</p><ul><li>必须在请求<strong>结束后清理</strong>，否则线程复用会导致“上下文串库”</li><li>不能跨线程（如异步执行、线程池任务）共享；如果在子线程里尝试取数据，需要显式传递或使用 <code>InheritableThreadLocal</code>（但要注意 GC 风险）</li><li>大量数据存放会增加内存压力</li></ul><p>或者是如果不清理的话，因为是弱引用，ThreadLocal的key很容易被清理，其还有null的键，一直在那里呆着。所以要使用remove清理或者是，查找与当前线程关联的Map并将键值对设置为当前线程和null，Huoz是在finally中关闭ThreadLocal。</p><h3 id="4-为什么要使用两个拦截器？不能一个实现所有功能吗？">4.<strong>为什么要使用两个拦截器？不能一个实现所有功能吗？</strong></h3><p>职责单一，遵循 <strong>单一职责原则</strong>，代码更清晰、可维护性更好</p><p>一级负责认证，二级负责续签，分层逻辑解耦，便于扩展和测试</p><p>也方便后期引入更多层（如角色校验、日志记录等）</p><h3 id="5-Token-在前端如何存储？如何防止被盗用？">5.Token 在前端如何存储？如何防止被盗用？</h3><p>推荐使用 <strong>HttpOnly + Secure 的 Cookie 存储 Token</strong>，防止 JS 脚本读取（防 XSS）</p><p>结合 <code>SameSite=Strict</code> 属性防止 CSRF 攻击</p><p>避免把 Token 存在 localStorage 中，localStorage 易被 XSS 攻击读取</p><p>可选使用双 Token：Access Token + Refresh Token，提升安全性</p><h3 id="6-为什么要使用-Access-Token-和-Refresh-Token-双-token？">6.为什么要使用 Access Token 和 Refresh Token 双 token？</h3><p>Access Token 短期有效，暴露风险小；</p><p>Refresh Token 保护用户无需频繁登录；</p><p>避免频繁验证数据库或 Redis，提高性能；</p><p>配合双拦截器自动刷新，增强用户体验。</p><h3 id="7-Refresh-Token-要不要存-Redis？">7.<strong>Refresh Token 要不要存 Redis？</strong></h3><p>建议存 Redis：</p><ul><li>可主动登出/注销 refresh token；</li><li>可强制下线；</li><li>可限制一个用户只有一个有效 refresh token；</li><li>提高安全性（Refresh Token 不应被频繁验证，但一旦泄露影响很大）。</li></ul><h3 id="8-Refresh-Token-过期后怎么办？">8.Refresh Token 过期后怎么办？</h3><p>前端收到 401 后无法再自动续签；</p><p>引导用户重新登录；</p><p>后端返回特定错误码区分 access 与 refresh 失效。</p><h3 id="9-如何防止-Refresh-Token-被盗用？">9.如何防止 Refresh Token 被盗用？</h3><p>限制 IP、设备标识（User-Agent）等；</p><p>加入 Redis 黑名单机制；</p><p>建议设置 HttpOnly Cookie 存储 refresh token，防止 XSS；</p><h2 id="接口支档编写与测试">接口支档编写与测试</h2><p>使用Swagger编写接口支档，开发过程中进行接口联调测试提升开发效率</p><p>Swagger 是一套 <strong>开放源代码项目</strong>，用于生成、描述、调用和可视化 RESTful 风格 Web 服务的工具集。主要包括：</p><ul><li>Swagger UI：提供一个交互式文档页面，可以直接测试接口。</li><li>Swagger Editor：在线编辑 OpenAPI 规范文档。</li><li>Swagger Codegen：根据文档生成客户端 SDK 或服务端模板代码。</li></ul><p>常见注解：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@Operation(summary = &quot;...&quot;)</code></td><td>用于方法上，描述接口作用</td></tr><tr><td><code>@Parameter(name = &quot;...&quot;)</code></td><td>用于方法参数上，描述参数</td></tr><tr><td><code>@Schema(description = &quot;...&quot;)</code></td><td>用于实体类字段上，描述字段</td></tr><tr><td><code>@Tag(name = &quot;...&quot;)</code></td><td>用于 Controller 上，分组描述</td></tr><tr><td><code>@RequestBody</code> + <code>@Schema</code></td><td>描述请求体</td></tr><tr><td><code>@ApiResponse(responseCode = &quot;200&quot;, description = &quot;...&quot;)</code></td><td>描述响应码与内容</td></tr></tbody></table><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;用户接口&quot;, description = &quot;用户相关接口文档&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;新增用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Parameter(description = &quot;用户信息&quot;)</span> UserDTO user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;添加成功: &quot;</span> + user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;根据ID获取用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;UserDTO&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试问题">面试问题</h3><h4 id="1-Swagger-有什么作用？使用它有什么优势？">1.Swagger 有什么作用？使用它有什么优势？</h4><p>Swagger 可以<strong>自动生成接口文档</strong>，支持接口调试，提升前后端联调效率。优势包括：</p><ul><li>接口文档自动同步，无需手写维护</li><li>可视化交互式页面，便于测试接口</li><li>支持导出 OpenAPI 规范，便于生成 SDK 或 Mock 接口</li></ul><h4 id="2-Swagger-在-Spring-Boot-项目中如何接入？">2.Swagger 在 Spring Boot 项目中如何接入？</h4><p>使用 <code>springdoc-openapi</code> 依赖，添加依赖后即可自动扫描 <code>@RestController</code> 注解的方法生成接口文档，常用注解包括 <code>@Operation</code>、<code>@Schema</code>、<code>@Parameter</code> 等。</p><h4 id="3-Swagger-与-Postman-有何区别？">3.Swagger 与 Postman 有何区别？</h4><p>Swagger 更适合开发阶段自动生成文档和接口调试；</p><p>Postman 更适合接口自动化测试、团队共享测试集合、压测脚本等；</p><p>两者可互补：Swagger 导出 OpenAPI 规范，Postman 可导入执行。</p><h4 id="4-如何通过-Swagger-实现接口-Mock？">4.如何通过 Swagger 实现接口 Mock？</h4><p>Swagger 本身不提供 Mock 功能，但可以通过：</p><ul><li>SwaggerHub 提供在线 Mock；</li><li>使用 Swagger JSON 配合工具如 <a href="https://github.com/stoplightio/prism">Prism</a>、[WireMock] 实现；</li><li>本地模拟返回固定数据，用于前端调试。</li></ul><h4 id="5-MOCK是啥">5.MOCK是啥</h4><p><strong>用于在真实对象不可用、未完成或不方便调用时，使用伪造的“替代对象”来模拟其行为</strong>。</p><p>本质：使用假的对象或返回结果，代替真实依赖或真实数据，方便开发和测试。</p><p>性能与部署优化：使用Redis缓存热门菜品数据居，应对高并发，减少数据库访尚，缩短接口响应时间：配置g作为日P服务器，外理静态资源赔部置、反同代单及负的律，提升系统稳定性与响应能力</p><h2 id="优惠劵">优惠劵</h2><h3 id="1-优惠劵的超卖重复问题，使用lua脚本保持原子性">1.优惠劵的超卖重复问题，使用lua脚本保持原子性</h3><p><strong>使用 Lua 脚本实现购买优惠券的原子性操作</strong>，常用于防止并发问题，比如<strong>超卖</strong>、<strong>重复领取</strong>等。</p><p>Redis 是<strong>单线程</strong>的，它执行 Lua 脚本时会<strong>串行执行整个脚本内容</strong>，所以可以用 Lua 脚本在 Redis 内部实现多个命令的<strong>原子执行</strong>，避免并发问题。</p><p>场景需求：</p><ul><li>用户未领取过优惠券</li><li>库存 &gt; 0</li><li>扣减库存，记录用户领取状态</li></ul><p><code>stock:coupon:&#123;couponId&#125;</code>：优惠券库存</p><p><code>user:coupon:&#123;couponId&#125;</code>：领取记录的 Set（存储 userId）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- KEYS[<span class="number">1</span>]：库存Key</span><br><span class="line">-- KEYS[<span class="number">2</span>]：领取记录Key</span><br><span class="line">-- ARGV[<span class="number">1</span>]：用户ID</span><br><span class="line"></span><br><span class="line">-- 判断是否领取过</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;sismember&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]) == <span class="number">1</span> then</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> -- 已领取</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 获取库存</span><br><span class="line"><span class="type">local</span> <span class="variable">stock</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">if</span> stock &lt;= <span class="number">0</span> then</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> -- 库存不足</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 扣减库存</span><br><span class="line">redis.call(<span class="string">&#x27;decr&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line">-- 记录用户</span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> -- 成功</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span> script = <span class="string">&quot;...&quot;</span>; <span class="comment">// 上面的 Lua 脚本内容</span></span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; keys = <span class="title class_">Arrays</span>.<span class="title function_">asList</span>(<span class="string">&quot;stock:coupon:1001&quot;</span>, <span class="string">&quot;user:coupon:1001&quot;</span>);</span><br><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; args = <span class="title class_">Arrays</span>.<span class="title function_">asList</span>(<span class="string">&quot;user123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span> result = jedis.<span class="built_in">eval</span>(script, keys, args);</span><br><span class="line"><span class="keyword">switch</span> ((<span class="title class_">Long</span>) result) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;重复领取&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;库存不足&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;领取成功&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优惠券库存减 1 关键是要防止超卖，即多个请求同时扣库存导致数据错乱。</p><p>一种常见做法是使用 <strong>乐观锁（CAS）</strong>：</p><ul><li>数据表中给优惠券记录加个 <strong>版本号（version）</strong> 或 <strong>更新时间戳</strong></li><li>更新库存时带上版本号或时间戳条件，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon <span class="type">SET</span> <span class="variable">stock</span> <span class="operator">=</span> stock - <span class="number">1</span>, version = version + <span class="number">1</span> </span><br><span class="line"><span class="type">WHERE</span> <span class="variable">coupon_id</span> <span class="operator">=</span> ? AND stock &gt; <span class="number">0</span> <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> ?</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-lua脚本执行异常">2.lua脚本执行异常</h2><p>提到 Lua 脚本执行异常时因为库存字段不可见被拦截，这里具体是指 Redis 的权限问题，还是脚本中对字段的引用方式有问题？比如有没有检查过 Lua 脚本里的 key 是否和 Redis 中存储的一致</p><p>脚本执行超时 (Timeout)：</p><p>Lua 脚本的执行是原子性的，会阻塞 Redis 实例。如果脚本执行时间过长，会导致其他客户端请求被阻塞，甚至客户端连接超时。Redis 有一个 <code>lua-time-limit</code> 配置（默认为 5 秒），超出这个时间脚本就会被终止。</p><p><strong>保持脚本短小精悍:</strong> Lua 脚本应该只包含最核心、需要原子性执行的逻辑。复杂的、非原子性的业务逻辑应该在客户端侧完成。</p><p><strong>避免昂贵的操作:</strong> 避免在脚本中执行 <code>KEYS</code>、<code>SMEMBERS</code>、<code>HGETALL</code> 等会遍历大量数据的命令。如果确实需要处理大量数据，考虑将大键拆分成小键，或者在客户端分批处理。</p><p><strong>增量处理:</strong> 如果必须在脚本中处理大量数据（例如清理过期键），考虑使用 <code>SCAN</code> 命令的变体（<code>HSCAN</code>, <code>SSCAN</code>, <code>ZSCAN</code>）进行增量迭代，并将脚本设计为分批执行。</p><p><strong>监控 <code>slowlog</code>:</strong> 检查 Redis 的 <code>slowlog</code>，看是否有 <code>EVAL</code> 或 <code>EVALSHA</code> 命令长时间执行。</p><h2 id="3-使用-Redis-Lua-做原子操作时，网络延迟对-CAS-操作的影响及如何保证并发原子性？">3.使用 Redis+Lua 做原子操作时，网络延迟对 CAS 操作的影响及如何保证并发原子性？</h2><p><strong>Lua 脚本在 Redis 中执行是单线程、原子性的。</strong></p><ul><li>只要你把 CAS（Compare-And-Set）逻辑写在 Lua 脚本中，整个脚本执行期间不会被其他命令打断。</li><li>因此，从 Redis 侧来看，<strong>无论多少并发请求同时来，脚本内的检查+更新都是串行执行且原子完成</strong>。</li></ul><p><strong>网络延迟影响主要体现在客户端发送请求和接收结果的时延，但不影响 Redis 端脚本执行的原子性。</strong></p><ul><li>例如两个客户端几乎同时发送请求，Redis 会顺序执行两个 Lua 脚本，避免数据竞争。</li><li>但网络延迟可能导致客户端感知延迟或重试。</li></ul><p><strong>保证多个并发请求下原子性的建议：</strong></p><ul><li><strong>务必把校验库存和扣减库存的操作写到同一个 Lua 脚本中，保证原子执行。</strong></li><li>避免客户端先读库存再决定是否写，因读写分开易出现竞态条件。</li><li>可以结合 Redis 的 <code>WATCH</code> + <code>MULTI/EXEC</code> 事务机制，但比不上 Lua 脚本原子性简单可靠。</li><li>另外，设置合理超时和重试机制，防止网络异常导致操作丢失。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/workmenu/shopping-web2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>shopping-web项目逻辑分析</title>
      <link>https://blog.tokenlen.top/2025/05/27/workmenu/shopping-web/</link>
      <guid>https://blog.tokenlen.top/2025/05/27/workmenu/shopping-web/</guid>
      <pubDate>Mon, 26 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;项目结构&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>项目结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">historical-voting-web/</span><br><span class="line">├── user-service/                 # 用户服务模块</span><br><span class="line">│   ├── src/main/java/</span><br><span class="line">│   │   └── com/historical/voting/user/</span><br><span class="line">│   │       ├── annotation/      # 自定义注解</span><br><span class="line">│   │       ├── config/          # 配置类</span><br><span class="line">│   │       ├── controller/      # 控制器</span><br><span class="line">│   │       ├── entity/          # 实体类</span><br><span class="line">│   │       ├── exception/       # 异常处理</span><br><span class="line">│   │       ├── Factory/         # 工厂类</span><br><span class="line">│   │       ├── interceptor/     # 拦截器</span><br><span class="line">│   │       ├── mapper/          # MyBatis映射</span><br><span class="line">│   │       ├── repository/      # JPA仓库</span><br><span class="line">│   │       ├── service/         # 服务层</span><br><span class="line">│   │       ├── strategy/        # 策略模式实现</span><br><span class="line">│   │       └── util/            # 工具类</span><br><span class="line">│   └── resources/</span><br><span class="line">│       └── application.yml      # 配置文件</span><br></pre></td></tr></table></figure><h2 id="核心功能模块">核心功能模块</h2><h3 id="4-1-用户认证模块">4.1 用户认证模块</h3><p>4.1.1 JWT认证流程</p><ol><li><p>用户登录流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户登录 -&gt; 验证凭据 -&gt; 生成JWT令牌（访问令牌+刷新令牌）-&gt; 返回令牌</span><br></pre></td></tr></table></figure></li></ol><p>流程：</p><p>在serviceimpl中实现login方法：</p><p>从数据库中select有没有输入的username,用户注册状态是不是0，用户是否是被封锁，密码是不是对。</p><p>然后生成access token 和refreash token</p><p>使用redis，opsforvalue.set设置key-vaule和过期时间</p><p>把他们放入map集合里面，然后返回token</p><hr><p>JWT加密：</p><p>采用HS512,然后创建payload，里面存入username。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Jwts.builder()</span><br><span class="line">    .setClaims(claims)                        <span class="comment">// 设置自定义声明</span></span><br><span class="line">    .setSubject(username)                     <span class="comment">// 设置主题，一般也是用户标识</span></span><br><span class="line">    .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())                  <span class="comment">// 签发时间</span></span><br><span class="line">    .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiration))  <span class="comment">// 过期时间</span></span><br><span class="line">    .signWith(key)                            <span class="comment">// 使用给定密钥签名（默认 HMAC-SHA256）</span></span><br><span class="line">    .compact();                               <span class="comment">// 构建并返回字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>请求认证流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求 -&gt; JwtAuthenticationFilter拦截 -&gt; 验证Token -&gt; 提取用户信息 -&gt; 放行请求</span><br></pre></td></tr></table></figure></li></ol><p>JwtAuthenticationFilter：</p><p>尝试直接使用access token，从requset的头里提取header.startsWith(&quot;Bearer &quot;)开头的，然后跳过前面的前缀，获取到token</p><p>access token刷新，claims必须要合法，然后从claims里获取username</p><p>然后检查token是不是在redis的黑名单中，然后看redis是不是存了这个令牌，get出来，然后requset.setAttribute加到请求上，然后返回response</p><p>然后refresh token刷新，</p><p>先是从request看到刷新令牌，然后先验证是不是和redis中的相同</p><p>相同的话，再生成一个新的access token令牌，然后更新redis中的令牌</p><p>把他加到resonse的响应头里，然后去看放不放行请求。</p><hr><p>注册的话，就是使用mailSender去发送验证码，只有验证码对才可以进行注册操作，创建新用户，写入数据库。</p><p>4.1.2 OAuth2认证流程</p><p>GitHub OAuth2登录流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户点击GitHub登录 -&gt; 重定向到GitHub -&gt; 用户授权 -&gt; 回调接口 -&gt; 创建/更新用户信息 -&gt; 生成JWT</span><br></pre></td></tr></table></figure><h3 id="4-2-用户管理模块">4.2 用户管理模块</h3><p>主要接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送验证码</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register/send-code&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户注册</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户登录</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用户登出</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/logout&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-文件存储-处理模块">4.3 文件存储+处理模块</h3><ul><li>支持图片、视频上传</li><li>支持生成缩略图</li><li>文件存储位置可配置（本地/腾讯云COS）</li></ul><p>📌 文件合法性校验（FileUtils）</p><p>在用户上传视频文件时，系统会通过 <code>FileUtils</code> 工具类对文件进行校验，主要包括以下几项逻辑：</p><ul><li><strong>单个文件大小限制</strong>：系统设定上传视频的最大允许体积（如 100MB），超过则直接拒绝上传。</li><li><strong>总上传大小控制</strong>：可根据用户标识或 IP，设置每日或每小时内上传视频的总大小上限，用于防止恶意刷带宽。</li><li><strong>文件类型判断</strong>：仅允许特定的视频类型（如 MP4、AVI 等）通过，防止伪装文件上传。</li></ul><p>该工具类在上传接口中被调用，作为服务端对用户输入的第一道校验防线。</p><hr><p>🧩 策略模式设计：TranscodingStrategy</p><p>系统中使用了策略模式来支持不同的转码协议（如 HLS、DASH），定义了统一的策略接口 <code>TranscodingStrategy</code>，它约定了所有转码实现类都必须提供统一的转码方法。</p><p>该接口屏蔽了具体的命令细节，为后续新增新格式（如 WebM、AV1）提供了扩展点。</p><hr><p>🏗️ 抽象策略实现类：AbstractTranscodingStrategy</p><p>系统设计了一个抽象类 <code>AbstractTranscodingStrategy</code> 来统一封装转码过程的通用步骤。主要逻辑包括：</p><ul><li><strong>组装转码命令</strong>：根据输入路径、输出路径、分辨率等参数拼接出 FFmpeg 的命令行。</li><li><strong>调用系统进程</strong>：通过 <code>ProcessBuilder.start()</code> 执行命令，完成实际的视频转码操作。</li><li><strong>异常捕获与输出校验</strong>：判断进程返回值是否为 0，确认转码是否成功，并统一抛出异常或写入日志。</li></ul><p>这样，具体策略类只需关注自己的格式命令，不用重复通用逻辑。</p><hr><p>🔀 具体策略类：HLS 与 DASH 实现</p><p>系统实现了两个具体的转码策略：</p><ul><li><strong>HLSTranscodingStrategy</strong>：使用 <code>.m3u8</code> + 分片方式转码，适用于直播或渐进式加载。</li><li><strong>DASHTranscodingStrategy</strong>：使用 <code>.mpd</code> 格式与多码率轨道，适用于 ABR（自适应码率）播放。</li></ul><p>每个策略类内部根据自己的输出格式构建专属的 FFmpeg 命令，并通过抽象类封装的方法执行转码。</p><p>策略类使用 <code>@Component</code> 注册为 Spring Bean，支持通过名称注入选择。</p><hr><p>🏭 策略工厂类：TranscodingStrategyFactory</p><p>为了按需获取具体的策略实现，系统设计了一个工厂类：</p><ul><li><strong>构造时收集策略 Bean</strong>：在 Spring 初始化过程中，将所有实现了 <code>TranscodingStrategy</code> 接口的 Bean 收集进 Map，key 为策略名（如 “hls”、“dash”）。</li><li><strong>根据名称获取策略</strong>：对外提供 <code>get(String name)</code> 方法，根据输入的策略名称，返回对应的实现类。</li><li><strong>支持动态扩展</strong>：后续新增策略只需实现接口并加 <code>@Component</code> 即可被自动注册到工厂中。</li></ul><p>该工厂类被视频服务调用，用于根据配置或用户选择的协议动态选择转码策略。</p><hr><p>VideoServiceImpl 服务实现逻辑说明：</p><ol><li>视频上传与转码处理</li></ol><ul><li><strong>视频上传路径配置</strong>：通过配置注入 <code>videoUploadPath</code> 和 <code>thumbnailPath</code>，用于存储上传的视频文件和封面缩略图。</li><li><strong>视频转码处理</strong> (<code>processVideo</code>)：<ul><li>通过 <code>ffmpeg</code> 命令行对上传视频进行转码，统一编码格式（H.264）和音频编码（AAC），并启用快速启动优化。</li><li>转码完成后调用封面提取方法。</li><li>若转码或封面提取失败，抛出自定义异常 <code>FileProcessException</code>，确保上传流程异常可控。</li></ul></li><li><strong>封面缩略图提取</strong> (<code>extractThumbnail</code>)：<ul><li>利用 <code>ffmpeg</code> 截取视频的第一帧作为缩略图，存放到指定目录。</li><li>确保缩略图文件命名与视频文件对应，方便管理和访问。</li></ul></li></ul><hr><ol start="2"><li>ABR（自适应码率）转码任务提交</li></ol><ul><li><strong>多分辨率转码</strong> (<code>submitTranscoding</code>)：<ul><li>针对预设的多个分辨率（如 720p、480p、360p），先通过 <code>ffmpeg</code> 对视频进行缩放处理，生成不同清晰度的视频片段。</li><li>使用线程池异步执行各分辨率转码任务，提高并发性能，避免阻塞主流程。</li><li>转码后调用策略工厂，获取指定格式（如 HLS）的转码策略，执行格式封装转码。</li><li>任何转码失败都会被捕获并记录日志，保证服务稳定。</li></ul></li></ul><hr><ol start="3"><li>播放记录与访问限流</li></ol><ul><li><strong>播放记录统计</strong> (<code>recordView</code>)：<ul><li>使用 Redis 以用户 IP 作为唯一标识限制重复计数，避免刷播放量。</li><li>通过 <code>setIfAbsent</code> 设置一分钟的缓存有效期，实现短时间内对同一视频同一 IP 只计数一次。</li><li>播放量计数存在 Redis，减少数据库压力。</li></ul></li><li><strong>定时同步播放量</strong> (<code>syncViewCounts</code>)：<ul><li>使用定时任务每 5 分钟将 Redis 中缓存的播放量批量同步到数据库。</li><li>同步后清理缓存，保证数据一致性和高效。</li></ul></li></ul><hr><ol start="4"><li>点赞与点踩功能</li></ol><ul><li><strong>点赞与点踩操作</strong>：<ul><li>采用 Redis Set 结构存储点赞和点踩的用户 ID，保证用户只能点赞或点踩其中一个。</li><li>点赞时自动移除对应的点踩记录，点踩亦然，确保数据互斥。</li><li>读取点赞和点踩数量时，直接返回 Redis Set 的大小，实时且性能高。</li></ul></li></ul><hr><ol start="5"><li>分享统计</li></ol><ul><li><strong>分享次数统计</strong>：<ul><li>通过 Redis 字符串计数，记录视频被分享的总次数。</li><li>读写均通过 Redis 完成，避免频繁访问数据库。</li></ul></li></ul><hr><ol start="6"><li>标签分页查询</li></ol><ul><li><strong>视频标签分页查询</strong> (<code>pageByTags</code>)：<ul><li>支持根据标签关键字模糊查询视频列表。</li><li>使用 MyBatis-Plus 的分页功能，按发布时间倒序排列，方便前端分页展示。</li><li>如果标签为空，则返回全部视频列表。</li></ul></li></ul><h3 id="4-3-优惠券模块">4.3 优惠券模块</h3><p>4.3.1 优惠券类型</p><ul><li>满减券：满足指定金额后减免固定金额</li><li>折扣券：按比例折扣</li><li>无门槛券：直接减免固定金额</li><li>限时券：在指定时间段内有效</li></ul><p>4.3.2 主要接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/coupons&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponController</span> &#123;</span><br><span class="line">    <span class="comment">// 创建优惠券</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发放优惠券</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/distribute&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询用户优惠券</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;userId&#125;&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用优惠券</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/use&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询优惠券详情</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;couponId&#125;&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.3.3 优惠券业务流程</p><ol><li><p>优惠券创建流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管理员创建优惠券 -&gt; 设置优惠券规则 -&gt; 设置发放策略 -&gt; 保存优惠券信息</span><br></pre></td></tr></table></figure></li><li><p>优惠券发放流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">触发发放条件 -&gt; 检查发放规则 -&gt; 创建用户优惠券记录 -&gt; 发送优惠券到账通知</span><br></pre></td></tr></table></figure></li><li><p>优惠券使用流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户选择优惠券 -&gt; 验证使用条件 -&gt; 计算优惠金额 -&gt; 标记优惠券已使用 -&gt; 应用优惠</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-4-限流AOP注释">4.4 限流AOP注释</h3><p>限流注解：<strong>RateLimit</strong></p><p>定义了这个注解，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br></pre></td></tr></table></figure><p>这个注解只能用在方法上，注解信息会保留到<strong>运行时</strong>，这允许通过反射读取注解内容，用于 AOP（切面）处理。可以通过@Around来拦截</p><p>里面定义了标识，每秒最大的访问次数，默认五次，然后</p><hr><p><strong>RateLimitUtils</strong>：工具类</p><p>基于内存桶（Bucket4j）限流实现的核心方法，使用 <code>ConcurrentHashMap</code> 存储每个唯一 key 对应的令牌桶。</p><p>然后创键一个限流规则，容量为permitsPerSecond,然后Refill每秒</p><p>然后返回这个使用这个限流规则的Bucket4j作为value</p><hr><p><strong>Aspect</strong>类</p><p>获取注解参数：<code>key</code>（限流维度）、<code>permitsPerSecond</code>（限流速率）、<code>message</code>（失败提示）</p><p>获取客户端 <code>IP + 方法名</code> 作为限流键（若未自定义）</p><p>使用 <code>Bucket4j</code> 获取或创建对应的桶对象</p><p>使用 <code>tryConsume(1)</code> 判断是否允许访问，调用限流器看是不能是访问，失败就返回msg</p><p>@Around规定切入点</p><p>还加上了全局处理异常，如果类型是限流的这个异常，给出429，说明当前是限流了。</p><hr><p>4.5 AOP实现业务和登录的跟踪</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/27/workmenu/shopping-web/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM-java虚拟机</title>
      <link>https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/</link>
      <guid>https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/</guid>
      <pubDate>Sat, 24 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;基本介绍&lt;/h1&gt;
&lt;p&gt;JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···&lt;/p&gt;
&lt;p&gt;JVM 其实就类似于一台小电脑运行在 windows 或者 linux</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>基本介绍</h1><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。<strong>它直接和操作系统进行交互</strong>，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" alt=""></p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进 JVM 里面来。</p><p><img src="https://static001.geekbang.org/infoq/2f/2f012fde94376f43a25dbe1dd07e0dd8.png" alt=""></p><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p><p>类加载器将 .class 文件搬过来就是先丢到这一块上</p><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系</p><p><strong>程序计数器</strong>主要就是完成一个<strong>加载工作</strong>，类似于一个指针一样的，指向<strong>下一行我们需要执行的代码。和栈一样</strong>，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p><p><img src="https://static001.geekbang.org/infoq/c6/c602f57ea9297f50bbc265f1821d6263.png" alt=""></p><p>而 JVM 的调优主要就是围绕堆，栈两大块进行</p><p>线程共享区就是线程不安全的区域</p><p>执行过程：</p><p>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</p><p>JVM 找到 App 的主程序入口，执行 main 方法</p><p>这个 main 中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</p><p>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</p><p>执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</p><p>执行 sayName()</p><p>只需要知道对象实例初始化时会去<strong>方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</strong></p><h1>类加载器</h1><p>之前也提到了它是<strong>负责加载.class 文件</strong>的，它们在文件开头会有特定的文件标示，**将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，**并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</p><p>从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><ol><li><p>将 class 文件加载到内存</p></li><li><p>将静态数据结构转化成方法区中运行时的数据结构</p></li><li><p>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</p></li><li><p>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，<strong>其实就是一个安全检查</strong></p></li><li><p>准备：<strong>为 static 变量在方法区中分配内存空间，设置变量的初始值</strong>，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</p></li><li><p>解析：虚拟机将<strong>常量池内的符号引用替换为直接引用的过程</strong>（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，<strong>直接引用就是指针或者对象地址</strong>，注意引用对象一定是在内存进行）</p></li><li><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由<strong>编译器收集</strong>，<strong>顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句</strong>。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，<strong>初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</strong></p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p></blockquote></li></ol><p>8.GC 将无用对象从内存中卸载</p><h2 id="加载顺序">加载顺序</h2><p>加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li>BootStrap ClassLoader：rt.jar</li><li>Extension ClassLoader: 加载扩展的 jar 包</li><li>App ClassLoader：指定的 classpath 下面的 jar 包</li><li>Custom ClassLoader：自定义的类加载器</li></ol><h2 id="双亲委派机制">双亲委派机制</h2><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，<strong>而是委派给父类去完成</strong>，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，<strong>只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</strong></p><p>这样做的好处是，<strong>加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader</strong> 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 <code>java.lang.String</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">public class String &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p><hr><h1>运行时数据区</h1><h2 id="本地方法栈和程序计数器">本地方法栈和程序计数器</h2><p>比如说我们现在点开 Thread 类的源码，会看到它的 start0 方法带有一个 native 关键字修饰，而且不存在方法体，<strong>这种用 native 修饰的方法就是本地方法</strong>，这是使用 C 来实现的，<strong>然后一般这些方法都会放到一个叫做本地方法栈的区域。</strong></p><p>程序计数器其实就是<strong>一个指针</strong>，它指向了<strong>我们程序中下一句需要执行的指令</strong>，<strong>它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。<strong>这个内存仅代表</strong>当前线程所执行的字节码的行号指示器</strong>，字节码解析器通过<strong>改变这个计数器的值选取下一条需要执行的字节码指令。</strong></p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h2 id="方法区">方法区</h2><p>方法区主要的作用是<strong>存放类的元数据信息</strong>，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h2 id="虚拟机栈和虚拟机堆">虚拟机栈和虚拟机堆</h2><p>一句话便是：<strong>栈管运行，堆管存储</strong>。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h3 id="栈">栈</h3><p>它是 Java 方法执行的<strong>内存模型</strong>。里面会对**局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。**同时如果我们听到局部变量表，那也是在说虚拟机栈</p><p>如果线程请求的<strong>栈的深度大于虚拟机栈的最大深度</strong>，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，<strong>放到 Java 中其实就是方法</strong>，它也是存放在栈中的。</p><p>栈中的<strong>数据都是以栈帧</strong>的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。<strong>它是一个先进后出，后进先出原则。</strong></p><p>局部变量表用于存放<strong>方法参数和方法内部所定义的局部变量</strong>。它的容量是以 Slot 为最小单位，<strong>一个 slot 可以存放 32 位以内的数据类型</strong>。</p><p>虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，范围为 <code>[0,局部变量表的 slot 的数量]</code>。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，<strong>这些 slot 是可以复用的</strong>，**当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。**当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p><h3 id="堆">堆</h3><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 <strong>-XX:+UsePSAdaptiveSurvivorSizePolicy</strong> 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。<strong>非堆内存其实我们已经说过了，就是方法区</strong>。在 1.8 中已经移除永久代，<strong>替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MetaspaceSize：初始化元空间大小，控制发生GC</span><br><span class="line">MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</span><br></pre></td></tr></table></figure><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><p><strong>年轻代：：：：</strong></p><p>当我们 new 一个对象后，会先放到 Eden 划分出来的**一块作为存储空间的内存，<strong>但是我们知道对堆内存是线程共享的，<strong>所以有可能会出现两个对象共用一个内存的情况</strong>。这里 JVM 的处理是</strong>为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB，**有兴趣可以了解一下</p><p>修正：当 Eden 区内存空间满了的时候，就会触发 <strong>Minor GC</strong>，Survivor0 区满不会触发 Minor GC 。</p><p><strong>那 Survivor0 区 的对象什么时候垃圾回收呢？</strong></p><p>假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，<strong>此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换</strong></p><p><strong>老年代</strong>：：：：：</p><p>老年代是<strong>存储长期存活的对象</strong>的，占满时就会触发我们最常听说的 <strong>Full GC</strong>，<strong>期间会停止所有线程等待 GC 的完成</strong>。所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p><p><strong>而且当老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 OOM</strong>，这时候就是<strong>虚拟机中的堆内存不足</strong>，原因可能会是堆内存设置的<strong>大小过小</strong>，这个可以通过参数-Xms、-Xmx 来调整。<strong>也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</strong></p><p><img src="https://static001.geekbang.org/infoq/39/398255141fde8ba208f6c99f4edaa9fe.png" alt=""></p><p><strong>回收：：：：</strong></p><p><img src="https://static001.geekbang.org/infoq/1b/1ba7f3cff6e07c6e9c6765cc4ef74997.png" alt=""></p><p>图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而 Java 堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，<strong>计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</strong></p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的 <strong>GC ROOTS</strong> 作为起始的存活对象集，<strong>从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言</strong>，例如 Java，C#等都是靠这招去判定对象是否存活的。</p><p>3.<strong>终结器</strong>（Finalizer）：如果对象重写了<code>finalize()</code>方法，垃圾回收器会在回收该对象之前调用<code>finalize()</code>方法，对象可以在<code>finalize()</code>方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。这个类似于try-catch-finally中的finally</p><p>一个对象的 finalize()方法只会被<strong>系统自动调用一次</strong>，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。</p><p>补充一句：并不提倡在程序中调用 finalize()来进行自救。**建议忘掉 Java 程序中该方法的存在。**因为它执行的时间不确定，甚至是否被执行也不确定（Java 程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java9 中已经被标记为 <strong>deprecated</strong> ，且 <code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 <code>finalize</code> 来的更加的轻量及可靠。</p><hr><p>在 Java 语言汇总能作为 GC Roots 的对象分为以下几种：</p><ol><li>虚拟机栈（栈帧中的本地方法表）中引用的对象（<strong>局部变量</strong>）</li><li>方法区中静态变量所引用的对象（<strong>静态变量</strong>）</li><li>方法区中<strong>常量引用的对象</strong></li><li><strong>本地方法栈（即 native 修饰的方法）中 JNI 引用的对象</strong>（JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li>已启动的且未终止的 Java 线程</li></ol><p>这种方法的优点是能够<strong>解决循环引用的问题</strong>，可它的实现需要耗费大量资源和时间，也需要 GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果<strong>对象进行可达性分析之后没发现与 GC Roots 相连的引用链</strong>，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。<strong>如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</strong></li><li>GC 对 F-Queue 队列中的对象进行二次标记。<strong>如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</strong></li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p><hr><h1>垃圾回收算法（GC）</h1><h2 id="堆空间的基本结构">堆空间的基本结构</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。1.8之后改为元空间（方法区）</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt=""></p><h3 id="新生代">新生代</h3><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把<strong>新生代的对象提前转移到老年代中去</strong>，老年代上的空间足够存放 <code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存</p><h3 id="老年代">老年代</h3><p>大对象就是需要<strong>大量连续内存空间的对象</strong>（比如：字符串、数组）。</p><p>大对象直接进入老年代的行为是由<strong>虚拟机动态决定</strong>的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p><ul><li>G1 垃圾回收器会根据 <code>-XX:G1HeapRegionSize</code> 参数设置的堆区域大小和 <code>-XX:G1MixedGCLiveThresholdPercent</code> 参数设置的阈值，来决定哪些对象会直接进入老年代。</li><li>Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(<code>XX:ThresholdTolerance</code>是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。</li></ul><p>既然虚拟机采用了<strong>分代收集</strong>的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，<strong>虚拟机给每个对象一个对象年龄（Age）计数器。</strong></p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(<strong>Eden 区-&gt;Survivor 区后对象的初始年龄变为 1</strong>)。</p><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 <strong>survivor 区的 50% 时</strong>（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，）取这个年龄和 MaxTenuringThreshold 中更小的一个值，<strong>作为新的晋升年龄阈值”。</strong></p><p><strong>默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对<strong>老年代进行垃圾收集</strong>。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="空间分配担保">空间分配担保</h3><p>空间分配担保是为了<strong>确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</strong></p><p>JDK 6 Update 24 之前，<strong>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，<strong>则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</strong></p><p>JDK 6 Update 24 之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>，就会进行 Minor GC，否则将进行 Full GC。</p><h2 id="对象死亡的判断方法">对象死亡的判断方法</h2><h3 id="引用计数器">引用计数器</h3><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p><p>例子：</p><p>如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。<strong>但是他们因为互相引用对方，导致它们的引用计数器都不为 0</strong>，于是引用计数算法无法通知 GC 回收器回收他们。</p><h3 id="可达性分析">可达性分析</h3><p>通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机<strong>栈(栈帧中的局部变量表)中引用的对象</strong></li><li><strong>本地方法栈(Native 方法)中引用的对象</strong></li><li>方法区中<strong>类静态属性</strong>引用的对象</li><li>方法区中<strong>常量</strong>引用的对象</li><li>所有<strong>被同步锁</strong>持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><p>然后要进行两次标记之后，才会真正给他回收了</p><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果<strong>对象进行可达性分析之后没发现与 GC Roots 相连的引用链</strong>，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。<strong>如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</strong></li><li>GC 对 F-Queue 队列中的对象进行二次标记。<strong>如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</strong></li></ol><h3 id="使用终结器">使用终结器</h3><p>但是他嗯，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。</p><h2 id="引用类型总结">引用类型总结</h2><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱），<strong>强引用就是 Java 中普通的对象</strong>，而软引用、弱引用、虚引用在 JDK 中定义的类分别是 <code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>。</p><h3 id="强引用">强引用</h3><p>就是程序代码中普遍存在的引用赋值，这是使用最普遍的引用，其代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strongReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 <strong>OutOfMemoryError</strong> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h3 id="软引用">软引用</h3><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。软引用代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 软引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br></pre></td></tr></table></figure><p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p><p><strong>软引用可以和一个引用队列</strong>（ReferenceQueue）联合使用，<strong>如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</strong></p><h3 id="弱引用">弱引用</h3><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line">str = <span class="literal">null</span>; <span class="comment">//str变成软引用，可以被收集</span></span><br></pre></td></tr></table></figure><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<strong>不过，由于垃圾回收器是</strong>一个优先级很低</strong>的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p><strong>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</strong></p><h3 id="虚引用">虚引用</h3><p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str, queue);</span><br></pre></td></tr></table></figure><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> **虚引用必须和引用队列（ReferenceQueue）联合使用。**当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，<strong>那么就可以在所引用的对象的内存被回收之前采取必要的行动。</strong></p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><p><strong>1.为什么软引用可以防止内存溢出</strong></p><p>减轻内存压力：</p><p>软引用对象在内存紧张时会被 GC 回收，这意味着,对于一些<strong>缓存型对象</strong>（如图片缓存、数据缓存）：</p><ul><li>使用软引用能让 JVM 在不影响系统运行的前提下<strong>自动清理不重要的对象</strong>；</li><li>避免这些对象<strong>一直占用内存</strong>导致 OOM（OutOfMemoryError）。</li></ul><p>有利于缓存系统的实现：</p><p>比如在图片浏览器、数据库连接池、网页浏览器中，常常需要缓存大量数据；使用软引用作为缓存的基础可以确保：</p><ul><li>缓存不会<strong>占用过多堆内存</strong>；</li><li>系统空闲时缓存仍可用；</li><li>一旦内存紧张，<strong>缓存自动释放</strong>，系统依旧安全运行。</li></ul><p>相比强引用更灵活、相比弱引用更安全</p><table><thead><tr><th>引用类型</th><th>回收时机</th><th>是否适合做缓存</th><th>对系统安全性的影响</th></tr></thead><tbody><tr><td>强引用</td><td>永不回收（除非没有引用）</td><td>❌ 会导致 OOM</td><td>高风险</td></tr><tr><td>弱引用</td><td>GC 时就回收</td><td>⚠️ 不适合</td><td>稳定但易失效</td></tr><tr><td>软引用</td><td>内存不足时回收</td><td>✅ 非常适合</td><td>✅ 安全可靠</td></tr></tbody></table><p>为什么弱引用/虚引用用得少？</p><p><strong>弱引用</strong>：一旦 GC 触发，不管内存够不够都会被回收，<strong>太激进，不适合缓存</strong>；</p><p><strong>虚引用</strong>：更偏底层，<strong>用于监控对象被回收的时机</strong>，不具备访问能力，<strong>需要配合 ReferenceQueue 使用</strong>，复杂度高。</p><h2 id="判断是不是该废弃">判断是不是该废弃</h2><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><blockquote><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，<strong>如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量</strong>，如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池了。</p><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类所有的<strong>实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</strong></li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在<strong>任何地方被引用</strong>，<strong>无法在任何地方通过反射访问该类的方法。</strong></li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾回收算法">垃圾回收算法</h2><h3 id="标记清除算法">标记清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：<strong>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</strong></p><p>它是最<strong>基础</strong>的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p><ol><li>当一个对象被创建时，给一个标记位，假设为 0 (false)；</li><li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</li><li>扫描阶段清除的就是标记位为 0 (false)的对象。</li></ol><h3 id="复制算法">复制算法</h3><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。**它可以将内存分为大小相同的两块，每次使用其中的一块。**当这一块的内存使用完后，**就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果<strong>存活对象数量比较大，复制性能会变得很差</strong>。</li></ul><h3 id="标记整理算法">标记整理算法</h3><p>标记-整理（Mark-and-Compact）算法是根据<strong>老年代</strong>的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，<strong>而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</strong></p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-compact-garbage-collection-algorithm.png" alt=""></p><h3 id="分代收集算法">分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在<strong>新生代</strong>中，每次收集都会有大量对象死去，<strong>所以可以选择“复制”算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，<strong>所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h2 id="垃圾收集器">垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8: <strong>Parallel Scavenge（新生代）+ Parallel Old（老年代）</strong></li><li>JDK 9 ~ JDK22: <strong>G1</strong></li></ul><h3 id="Serial">Serial</h3><p>Serial**（串行）收集器**是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，<strong>更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png" alt="Serial 收集器"></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。<strong>Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</strong></p><h3 id="ParNew">ParNew</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/parnew-garbage-collector.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，<strong>只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</strong></p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上</li></ul><h3 id="Parallerl-Scavenge">Parallerl Scavenge</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure><p>Parallel Scavenge 收集器关注点是<strong>吞吐量（高效率的利用 CPU）</strong>。CMS 等垃圾收集器的关注点更多的是<strong>用户线程的停顿时间</strong>（提高用户体验）。所谓吞吐量就是 <strong>CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值</strong>。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，<strong>使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png" alt=""></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">262921408</span> -XX:MaxHeapSize=<span class="number">4206742528</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_211</span>-b12)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.211</span>-b12, mixed mode)</span></span><br></pre></td></tr></table></figure><p>JDK1.8 默认使用的是 <strong>Parallel Scavenge + Parallel Old</strong>，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="Serial-Old">Serial Old</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：<strong>一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png" alt="Serial 收集器"></p><h3 id="Parallel-Old">Parallel Old</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p><h3 id="CMS">CMS</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 短暂停顿，<strong>标记直接与 root 相连的对象（根对象）；</strong></li><li><strong>并发标记：</strong> <strong>同时开启 GC 和用户线程</strong>，用一个<strong>闭包结构</strong>去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。<strong>所以这个算法里会跟踪记录这些发生引用更新的地方。</strong></li><li><strong>重新标记：</strong> 重新标记阶段就是为了**修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，**这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png" alt="CMS 收集器"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><p><strong>CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。</strong></p><h3 id="G1">G1</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：<strong>G1 能充分利用 CPU、多核环境下的硬件优势</strong>，使用多个 CPU（CPU 或者 CPU 核心）来缩短 <strong>Stop-The-World 停顿时间</strong>(暂停其他的线程)。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，<strong>G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</strong></li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了<strong>分代</strong>的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，<strong>G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</strong></li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，<strong>但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</strong>。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong>： 短暂停顿（Stop-The-World，STW），<strong>标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象</strong></li><li><strong>并发标记</strong>：<strong>与应用并发运行</strong>，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</li><li><strong>最终标记</strong>： 短暂停顿（STW），<strong>处理并发标记阶段结束后残留的少量未处理的引用变更。</strong></li><li><strong>筛选回收</strong>：根据标记结果，<strong>选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。</strong></li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png" alt="G1 收集器"></p><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，<strong>保证了 G1 收集器在有限时间内可以尽可能高的收集效率</strong>（把内存化整为零）。</p><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p><h3 id="ZGC">ZGC</h3><p>与 CMS 中的 ParNew 和 G1 类似，<strong>ZGC 也采用标记-复制算法</strong>，不过 ZGC 对该算法做了重大改进。</p><p><strong>ZGC 可以将暂停时间控制在几毫秒以内，且暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。ZGC 最大支持 16TB 的堆内存。</strong></p><p>ZGC 在 Java11 中引入，处于试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java15 已经可以正式使用了。</p><p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启用 ZGC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseZGC className</span><br></pre></td></tr></table></figure><p>在 Java21 中，<strong>引入了分代 ZGC，暂停时间可以缩短到 1 毫秒以内。</strong></p><p>你可以通过下面的参数启用分代 ZGC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseZGC -XX:+ZGenerational className</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/infoq/9f/9ff72176ab0bf58bc43e142f69427379.png" alt=""></p><h1>JVM 的常用参数</h1><table><thead><tr><th>参数名</th><th>作用描述</th><th>示例值/说明</th></tr></thead><tbody><tr><td><code>-Xms</code></td><td>初始堆内存大小</td><td><code>-Xms512m</code></td></tr><tr><td><code>-Xmx</code></td><td>最大堆内存大小</td><td><code>-Xmx1024m</code></td></tr><tr><td><code>-Xmn</code></td><td>新生代大小（控制 Eden + Survivor 区）</td><td><code>-Xmn256m</code></td></tr><tr><td><code>-XX:PermSize</code>（JDK 8 前）</td><td>初始永久代大小（方法区）</td><td><code>-XX:PermSize=128m</code></td></tr><tr><td><code>-XX:MaxPermSize</code>（JDK 8 前）</td><td>最大永久代大小</td><td><code>-XX:MaxPermSize=256m</code></td></tr><tr><td><code>-XX:MetaspaceSize</code>（JDK 8+）</td><td>元空间初始大小</td><td><code>-XX:MetaspaceSize=128m</code></td></tr><tr><td><code>-XX:MaxMetaspaceSize</code>（JDK 8+）</td><td>元空间最大大小</td><td><code>-XX:MaxMetaspaceSize=512m</code></td></tr><tr><td><code>-XX:+PrintGCDetails</code></td><td>输出 GC 详细信息</td><td>调试用</td></tr><tr><td><code>-XX:+UseSerialGC</code></td><td>使用串行垃圾收集器</td><td>适合单核或小内存环境</td></tr><tr><td><code>-XX:+UseParallelGC</code></td><td>使用并行收集器（吞吐量优先）</td><td>默认在 JDK 8</td></tr><tr><td><code>-XX:+UseG1GC</code></td><td>使用 G1 收集器（低延迟场景）</td><td>推荐在大内存、服务端场景中使用</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>Eden 与 Survivor 区大小比</td><td><code>-XX:SurvivorRatio=8</code></td></tr><tr><td><code>-XX:+HeapDumpOnOutOfMemoryError</code></td><td>OOM 时导出内存快照</td><td>用于定位内存泄漏</td></tr><tr><td><code>-XX:HeapDumpPath</code></td><td>指定 heap dump 文件路径</td><td><code>-XX:HeapDumpPath=/tmp/dump.hprof</code></td></tr><tr><td><code>-Xss</code></td><td>设置每个线程的栈大小</td><td><code>-Xss256k</code></td></tr><tr><td><code>-XX:+PrintGCDateStamps</code></td><td>打印 GC 日志时附带时间戳</td><td>调试用</td></tr><tr><td><code>-XX:+UseCompressedOops</code></td><td>压缩对象指针（节省 64 位 JVM 内存）</td><td>默认开启</td></tr><tr><td><code>-Dkey=value</code></td><td>设置系统属性（常用于配置）</td><td>示例：<code>-Denv=prod</code></td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/jvm/">jvm</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/25/java-stack/jvm1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM-java虚拟机hot面试</title>
      <link>https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/</link>
      <guid>https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/</guid>
      <pubDate>Sat, 24 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;内存模型&lt;/h1&gt;
&lt;h2 id=&quot;1-JVM的内存模型介绍一下&quot;&gt;1.JVM的内存模型介绍一下&lt;/h2&gt;
&lt;p&gt;根据 JDK 8 规范，JVM</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>内存模型</h1><h2 id="1-JVM的内存模型介绍一下">1.JVM的内存模型介绍一下</h2><p>根据 JDK 8 规范，JVM 运行时内存共分为<strong>虚拟机栈、堆、元空间、程序计数器、本地方法栈</strong>五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p><p>JVM的内存结构主要分为以下几个部分：</p><ul><li><strong>程序计数器</strong>：可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>，用于存储当前线程正在执行的 Java 方法的 JVM 指令地址。相当于指针，<strong>如果线程执行的是 Native 方法，计数器值为 null。<strong>是唯一一个在 Java 虚拟机规范中</strong>没有规定任何 OutOfMemoryError</strong> 情况的区域，生命周期与线程相同。</li><li><strong>Java 虚拟机栈</strong>：<strong>每个线程都有自己独立的 Java 虚拟机栈</strong>，生命周期与线程相同。每个<strong>方法在执行时都会创建一个栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。可能会抛出 <strong>StackOverflowError 和 OutOfMemoryError</strong> 异常。</li><li><strong>本地方法栈</strong>：与 Java 虚拟机栈类似，主<strong>要为虚拟机使用到的 Native 方法服务</strong>，在 <strong>HotSpot 虚拟机中和 Java 虚拟机栈合二为一</strong>。本地方法执行时也会创建栈帧，<strong>同样可能出现 StackOverflowError 和 OutOfMemoryError 两种错误。</strong></li><li><strong>Java 堆</strong>：是 <strong>JVM 中最大的一块内存区域，被所有线程共享</strong>，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区（From Survivor 和 To Survivor）。如果在堆中没有内存完成实例分配，<strong>并且堆也无法扩展时会抛出 OutOfMemoryError 异常。</strong></li><li><strong>方法区（元空间）</strong>：在 JDK 1.8 及以后的版本中，<strong>方法区被元空间取代，使用本地内存</strong>。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。虽然方法区被描述为堆的逻辑部分，但有 “非堆” 的别名。<strong>方法区可以选择不实现垃圾收集，内存不足时会抛出 OutOfMemoryError 异常。</strong></li><li><strong>运行时常量池</strong>：是方法区的一部分，<strong>用于存放编译期生成的各种字面量和符号引用</strong>，具有动态性，运行时也可将新的常量放入池中。当无法申请到足够内存时，会抛出 OutOfMemoryError 异常。</li><li><strong>直接内存</strong>：不属于 JVM 运行时数据区的一部分，**通过 NIO 类引入，是一种堆外内存，可以显著提高 I/O 性能。**直接内存的使用受到本机总内存的限制，若分配不当，可能导致 OutOfMemoryError 异常。</li></ul><h2 id="2-JVM内存模型里的堆和栈有什么区别？">2.JVM内存模型里的堆和栈有什么区别？</h2><ul><li><strong>用途</strong>：**栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。**每当一个方法被调用，一个栈帧（stack frame）就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆用于存储对象的实例（包括类的实例和数组）。<strong>当你使用<code>new</code>关键字创建一个对象时，对象的实例就会在堆上分配空间。</strong></li><li><strong>生命周期</strong>：栈中的数据具有<strong>确定的生命周期</strong>，当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，<strong>对象会在垃圾回收机制（Garbage Collection, GC）检测到对象不再被引用时才被回收。</strong></li><li><strong>存取速度</strong>：<strong>栈的存取速度通常比堆快</strong>，因为栈遵循先进后出（LIFO, Last In First Out）的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。</li><li><strong>存储空间</strong>：<strong>栈的空间相对较小，且固定，由操作系统管理</strong>。当栈溢出时，通常是因为递归过深或局部变量过大。堆的空间较大，动态扩展，由JVM管理。<strong>堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。</strong></li><li><strong>可见性</strong>：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。</li></ul><h2 id="3-栈中存的到底是指针还是对象？">3.栈中存的到底是指针还是对象？</h2><p>在JVM内存模型中，栈（Stack）主要用于<strong>管理线程的局部变量和方法调用的上下文</strong>，而堆（Heap）则是用于<strong>存储所有类的实例和数组。</strong></p><p>当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。</p><p>这里的关键点是，栈中存储的<strong>不是</strong>对象，而是<strong>对象的引用</strong>。也就是说，<strong>当你在方法中声明一个对象，比如<code>MyObject obj = new MyObject();</code>，这里的<code>obj</code>实际上是一个存储在栈上的引用</strong>，<strong>指向堆中实际的对象实例</strong>。这个引用是一个固定大小的数据（例如在64位系统上是8字节），它指向堆中分配给对象的内存区域。</p><h2 id="4-堆分为哪几部分呢？">4.堆分为哪几部分呢？</h2><p>Java堆（Heap）是Java虚拟机（JVM）中内存管理的一个重要区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt=""></p><ul><li><strong>新生代（Young Generation）</strong>:新生代分为<strong>Eden Space和Survivor Space</strong>。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，<strong>称为S0（Survivor 0）和S1（Survivor 1）</strong>。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。<strong>这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</strong></li><li><strong>老年代（Old Generation/Tenured Generation）</strong>:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。<strong>老年代中的对象生命周期较长</strong>，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的<strong>空间通常比新生代大</strong>，以存储更多的长期存活对象。</li><li><strong>元空间（Metaspace）</strong>:从Java 8开始，永久代（Permanent Generation）被<strong>元空间</strong>取代，<strong>用于存储类的元数据信息，如类的结构信息（如字段、方法信息等）</strong>。元空间并不在Java堆中，而是使用<strong>本地内存</strong>，这解决了永久代容易出现的内存溢出问题。</li><li><strong>大对象区（Large Object Space / Humongous Objects）</strong>:在某些JVM实现中（如G1垃圾收集器），<strong>为大对象分配了专门的区域，称为大对象区或Humongous Objects区域</strong>。大对象是指<strong>需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。</strong></li></ul><h2 id="5-如果有个大对象一般是在哪个区域？">5.如果有个大对象一般是在哪个区域？</h2><p><strong>大对象通常会直接分配到老年代。</strong></p><p>新生代主要用于<strong>存放生命周期较短的对象，并且其内存空间相对较小</strong>。如果将大对象分配到新生代，可能会很快导致新生代空间不足，从而频繁触发 Minor GC。而每次 Minor GC 都需要进行对象的复制和移动操作，这会带来一定的性能开销。将大对象直接分配到老年代，可以减少新生代的内存压力，降低 Minor GC 的频率。</p><p><strong>大对象通常需要连续的内存空间</strong>，如果在新生代中频繁分配和回收大对象，**容易产生内存碎片，导致后续分配大对象时可能因为内存不连续而失败。**老年代的空间相对较大，更适合存储大对象，有助于减少内存碎片的产生。</p><h2 id="6-程序计数器的作用，为什么是私有的？">6.程序计数器的作用，为什么是私有的？</h2><p>Java程序是支持多线程一起运行的，多个线程一起运行的时候cpu会有一个调动器组件给它们分配时间片，比如说会给线程1分给一个时间片，它在时间片内如果它的代码没有执行完，<strong>它就会把线程1的状态执行一个暂存</strong>，切换到线程2去，执行线程2的代码，等线程2的代码执行到了一定程度，线程2的时间片用完了，再切换回来，再继续执行线程1剩余部分的代码。</p><p>我们考虑一下，<strong>如果在线程切换的过程中，下一条指令执行到哪里了，是不是还是会用到我们的程序计数器啊。每个线程都有自己的程序计数器，因为它们各自执行的代码的指令地址是不一样的呀，所以每个线程都应该有自己的程序计数器。</strong></p><h2 id="7-方法区中的方法的执行过程？">7.方法区中的方法的执行过程？</h2><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p><ul><li><strong>解析方法调用</strong>：JVM会根据<strong>方法的符号引用找到实际的方法地址</strong>（如果之前没有解析过的话）。</li><li><strong>栈帧创建</strong>：在调用一个方法前，JVM会在当前线程的Java<strong>虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</strong></li><li><strong>执行方法</strong>：执行方法内的<strong>字节码指令</strong>，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。</li><li><strong>返回处理</strong>：方法执行完毕后，可<strong>能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。</strong></li></ul><h2 id="8-HotSpot-为什么要分为新生代和老年代？">8.HotSpot 为什么要分为新生代和老年代？</h2><p>HotSpot 将堆内存划分为新生代和老年代，是为了<strong>利用对象生命周期的差异来优化垃圾回收性能。<strong>大多数对象生命周期短，适合在新生代中用高效的</strong>复制算法</strong>快速回收；少量长寿命对象存放在老年代，<strong>减少回收频率。分代设计能有效缩短停顿时间、提高吞吐量，避免每次 GC 都扫描整个堆，从而提升整体系统运行效率。</strong></p><h2 id="9-方法区中还有哪些东西？">9.方法区中还有哪些东西？</h2><p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><ul><li>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。</li><li>常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。</li><li>静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。</li><li>方法字节码：存储类的方法字节码，即编译后的代码。</li><li>符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。</li><li>运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。</li><li>常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。</li></ul><h2 id="10-String保存在哪里呢？">10.String保存在哪里呢？</h2><p>String 保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享</p><h2 id="11-String-s-new-String（“abc”）执行过程中分别对应哪些内存区域？">11.String s = new String（“abc”）执行过程中分别对应哪些内存区域？</h2><p>首先，我们看到这个代码中有一个new关键字，我们知道<strong>new</strong>指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在<strong>运行期</strong>才能确定的，创建的字符串对象是在<strong>堆内存上</strong>。</p><p>其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时，JVM拿字面量&quot;abc&quot;去<strong>字符串常量池</strong>试图获取其对应String对象的引用。<strong>于是在堆中创建了一个&quot;abc&quot;的String对象</strong>，并将其引用保存到字符串常量池中，然后返回；</p><p>所以，<strong>如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new String这个实例对象。如果abc这字符串常量存在，则只会创建一个对象</strong>。</p><h2 id="12-为什么新生代默认-Eden-Survivor-8-1-1？">12.<strong>为什么新生代默认 Eden:Survivor=8:1:1？</strong></h2><p>复制算法需要预留空间，8:1:1 的比例让 Survivor 区足够容纳一次 Minor GC 后存活的对象，减少动态扩容开销（JVM 默认允许 Survivor 区动态调整）。</p><h1>引用</h1><h2 id="1-为什么软引用可以防止内存溢出"><strong>1.为什么软引用可以防止内存溢出</strong></h2><p>减轻内存压力：</p><p>软引用对象在内存紧张时会被 GC 回收，这意味着,对于一些<strong>缓存型对象</strong>（如图片缓存、数据缓存）：</p><ul><li>使用软引用能让 JVM 在不影响系统运行的前提下<strong>自动清理不重要的对象</strong>；</li><li>避免这些对象<strong>一直占用内存</strong>导致 OOM（OutOfMemoryError）。</li></ul><p>有利于缓存系统的实现：</p><p>比如在图片浏览器、数据库连接池、网页浏览器中，常常需要缓存大量数据；使用软引用作为缓存的基础可以确保：</p><ul><li>缓存不会<strong>占用过多堆内存</strong>；</li><li>系统空闲时缓存仍可用；</li><li>一旦内存紧张，<strong>缓存自动释放</strong>，系统依旧安全运行。</li></ul><p>相比强引用更灵活、相比弱引用更安全</p><table><thead><tr><th>引用类型</th><th>回收时机</th><th>是否适合做缓存</th><th>对系统安全性的影响</th></tr></thead><tbody><tr><td>强引用</td><td>永不回收（除非没有引用）</td><td>❌ 会导致 OOM</td><td>高风险</td></tr><tr><td>弱引用</td><td>GC 时就回收</td><td>⚠️ 不适合</td><td>稳定但易失效</td></tr><tr><td>软引用</td><td>内存不足时回收</td><td>✅ 非常适合</td><td>✅ 安全可靠</td></tr></tbody></table><p>为什么弱引用/虚引用用得少？</p><p><strong>弱引用</strong>：一旦 GC 触发，不管内存够不够都会被回收，<strong>太激进，不适合缓存</strong>；</p><p><strong>虚引用</strong>：更偏底层，<strong>用于监控对象被回收的时机</strong>，不具备访问能力，<strong>需要配合 ReferenceQueue 使用</strong>，复杂度高。</p><h2 id="2-引用类型有哪些？有什么区别？">2.引用类型有哪些？有什么区别？</h2><p>引用类型主要分为强软弱虚四种：</p><ul><li>强引用指的就是<strong>代码中普遍存在的赋值方式</strong>，比如A a = new A()这种。强引用关联的对象，永远不会被GC回收。就是一个对象</li><li>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。<strong>系统在发生内存溢出前会对这类引用的对象进行回收。</strong></li><li>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，<strong>弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。</strong></li><li>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，<strong>他必须和ReferenceQueue一起使用</strong>，同样的当发生GC的时候，虚引用也会被回收。<strong>可以用虚引用来管理堆外内存。</strong></li></ul><h2 id="3-弱引用了解吗-举例说明在哪里可以用">3.弱引用了解吗?举例说明在哪里可以用?</h2><p>Java中的弱引用是一种引用类型，它不会阻止一个对象被垃圾回收。</p><p>在Java中，弱引用是通过<code>Java.lang.ref.WeakReference</code>类实现的。弱引用的一个主要用途是创建非强制性的对象引用，<strong>这些引用可以在内存压力大时被垃圾回收器清理，从而避免内存泄露。</strong></p><p>弱引用的使用场景：</p><ul><li><strong>缓存系统</strong>：弱引用常用于<strong>实现缓存</strong>，特别是当希望缓存项能够在内存压力下自动释放时。如果缓存的大小不受控制，可能会导致内存溢出。使用弱引用来维护缓存，可以让JVM在需要更多内存时自动清理这些缓存对象。</li><li><strong>对象池</strong>：在对象池中，<strong>弱引用可以用来管理那些暂时不使用的对象。当对象不再被强引用时，它们可以被垃圾回收，释放内存。</strong></li><li><strong>避免内存泄露</strong>：当一个对象<strong>不应该被长期引用时</strong>，使用弱引用可以防止该对象被意外地保留，从而避免潜在的内存泄露。</li></ul><p>示例代码：</p><p>假设我们有一个缓存系统，我们使用弱引用来维护缓存中的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> Java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> Java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WeakReference&lt;MyHeavyObject&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyHeavyObject <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        WeakReference&lt;MyHeavyObject&gt; ref = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ref.get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MyHeavyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHeavyObject</span>();</span><br><span class="line">            cache.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj));</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设MyHeavyObject是一个占用大量内存的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHeavyObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] largeData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 10MB data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用<code>WeakReference</code>来存储<code>MyHeavyObject</code>实例，当内存压力增大时，垃圾回收器可以自由地回收这些对象，而不会影响缓存的正常运行。</p><p>如果一个对象被垃圾回收，下次尝试从缓存中获取时，<code>get()</code>方法会返回<code>null</code>，这时我们可以重新创建对象并将其放入缓存中。因此，使用弱引用时要注意，一旦对象被垃圾回收，通过弱引用获取的对象可能会变为<code>null</code>，因此在使用前通常需要检查这一点。</p><table><thead><tr><th>特性</th><th>软引用（SoftReference）</th><th>弱引用（WeakReference）</th></tr></thead><tbody><tr><td>回收时机</td><td>内存不足时才回收</td><td>下一次 GC 就可能回收</td></tr><tr><td>存活时间</td><td>相对更长</td><td>非常短，随时可能被清除</td></tr><tr><td>适合场景</td><td>缓存（保留尽可能多对象）</td><td>映射、辅助引用、监听器、ThreadLocal 等</td></tr><tr><td>安全性</td><td>更高（内存紧张时才回收）</td><td>更低（不稳定，随时可能为 null）</td></tr><tr><td>被使用的典型类</td><td><code>SoftReferenceCache</code></td><td><code>WeakHashMap</code>、<code>ThreadLocal</code> 底层</td></tr></tbody></table><h2 id="4-内存泄漏和内存溢出的理解？">4.内存泄漏和内存溢出的理解？</h2><p><strong>内存泄露</strong>：内存泄漏是**指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。**虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。</p><p>内存泄露常见原因：</p><ul><li><strong>静态集合</strong>：使用静态数据结构（如<code>HashMap</code>或<code>ArrayList</code>）存储对象，且未清理。</li><li><strong>事件监听</strong>：未取消对事件源的监听，导致对象持续被引用。</li><li><strong>线程</strong>：未停止的线程可能持有对象引用，无法被回收。</li></ul><p>内存溢出：内存溢出是指<strong>Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发<code>OutOfMemoryError</code>。这通常发生在堆内存不足以存放新创建的对象时。</strong></p><p>内存溢出常见原因：</p><ul><li><strong>大量对象创建</strong>：程序中不断创建大量对象，超出JVM堆的限制。</li><li><strong>持久引用</strong>：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。</li><li><strong>递归调用</strong>：深度递归导致栈溢出。</li></ul><p>内存泄漏是还没满，内存溢出是已经满了</p><h2 id="5-jvm-内存结构有哪几种内存溢出的情况？">5.jvm 内存结构有哪几种内存溢出的情况？</h2><ul><li><strong>堆内存溢出</strong>：当出现Java.lang.OutOfMemoryError:Java heap space异常时，就是堆内存溢出了。原因是代码中<strong>可能存在大对象分配，或者发生了内存泄露</strong>，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。</li><li><strong>栈溢出</strong>：如果我们**写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。**类似这种情况，JVM 实际会抛出 StackOverFlowError；<strong>当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</strong></li><li><strong>元空间溢出</strong>：元空间的溢出，系统会抛出Java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是<strong>系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。</strong></li><li><strong>直接内存内存溢出</strong>：在使用<strong>ByteBuffer中的allocateDirect()的时候会用到</strong>，很多JavaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出Java.lang.OutOfMemoryError: Direct buffer memory异常。</li></ul><p>除了<strong>程序计数器</strong>都会出现OOM</p><h2 id="6-有具体的内存泄漏和内存溢出的例子么请举例及解决方案">6.有具体的内存泄漏和内存溢出的例子么请举例及解决方案?</h2><blockquote><p>1、静态属性导致内存泄露</p></blockquote><p>会导致内存泄露的一种情况就是<strong>大量使用static静态变量</strong>。在Java中，静态属性的生命周期通常伴随着应用整个生命周期（除非ClassLoader符合垃圾回收的条件）。下面来看一个具体的会导致内存泄露的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticTest</span>().populateList();</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果监控内存堆内存的变化，会发现在打印Point1和Point2之间，堆内存会有一个明显的增长趋势图。但当执行完populateList方法之后，对堆内存并没有被垃圾回收器进行回收。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112907539.png" alt="image-20240820112907539"></p><p>但针对上述程序，如果将定义list的变量前的static关键字去掉，再次执行程序，会发现内存发生了具体的变化。VisualVM监控信息如下图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112851893.png" alt="image-20240820112851893"></p><p>对比两个图可以看出，程序执行的前半部分内存使用情况都一样，但当执行完populateList方法之后，后者不再有引用指向对应的数据，垃圾回收器便进行了回收操作。因此，我们要十分留意static的变量，<strong>如果集合或大量的对象定义为static的，它们会停留在整个应用程序的生命周期当中。而它们所占用的内存空间，本可以用于其他地方。</strong></p><p>那么如何优化呢？<strong>第一，进来减少静态变量；第二，如果使用单例，尽量采用懒加载。</strong></p><blockquote><p>2、 未关闭的资源</p></blockquote><p>无论什么时候当我们创建一个连接或打开一个流，JVM都会分配内存给这些资源。比如，数据库链接、输入流和session对象。</p><p>**忘记关闭这些资源，会阻塞内存，从而导致GC无法进行清理。**特别是当程序发生异常时，没有在finally中进行资源关闭的情况。这些未正常关闭的连接，如果不进行处理，轻则影响程序性能，重则导致OutOfMemoryError异常发生。</p><p>如果进行处理呢？<strong>第一，始终记得在finally中进行资源的关闭；第二，关闭连接的自身代码不能发生异常；第三，Java7以上版本可使用try-with-resources代码方式进行资源关闭。</strong></p><p>try-with-resources:</p><p><code>try()</code> 中定义的对象，必须实现 <code>AutoCloseable</code> 接口（<code>Closeable</code> 也可以，间接继承）；</p><p>try 块执行完后，Java 会自动调用这些资源的 <code>.close()</code> 方法；</p><blockquote><p>3、 使用ThreadLocal</p></blockquote><p>ThreadLocal提供了<strong>线程本地变量</strong>，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。<strong>ThreadLocal相当于提供了一种线程隔离</strong>，将变量与线程相绑定，从而实现线程安全的特性。</p><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112835783.png" alt="image-20240820112835783"></p><p>ThreadLocal的实现中，<strong>每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。</strong></p><p>ThreadLocalMap使用ThreadLocal的<strong>弱引用作为key</strong>，如果一个ThreadLocal<strong>没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</strong></p><p>如果当前线程迟迟不结束的话，<strong>这些key为null的Entry的value就会一直存在一条强引用链</strong>：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><p>如何解决此问题？</p><ul><li>第一，<strong>使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除</strong>；</li><li>第二，不要使用ThreadLocal.set(null) 的方式清除value，它实际上并没有清除值，而是<strong>查找与当前线程关联的Map并将键值对分别设置为当前线程和null。</strong></li><li>第三，<strong>最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(System.nanoTime());</span><br><span class="line">    <span class="comment">//... further processing</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>类的加载</h1><h2 id="1-创建对象的过程？">1.创建对象的过程？</h2><p>在Java中创建对象的过程包括以下几个步骤：</p><ol><li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</li><li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为<strong>新生对象分配内存</strong>。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</li><li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要<strong>将分配到的内存空间都初始化为零值</strong>（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所<strong>以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</strong></li></ol><h2 id="2-对象的生命周期">2.对象的生命周期</h2><p>对象的生命周期包括创建、使用和销毁三个阶段：</p><ul><li>创建：对象通过<strong>关键字new在堆内存中被实例化</strong>，构造函数被调用，对象的内存空间被分配。</li><li>使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。</li><li>销毁：当对象不再被引用时，通过<strong>垃圾回收机制自动回收对象所占用的内存空间</strong>。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。</li></ul><h2 id="3-类加载器有哪些？">3.类加载器有哪些？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png" alt=""></p><ul><li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这是<strong>最顶层的类加载器</strong>，负责加载Java的核心库（如位于jre/lib/rt.jar中的类），它是用C++编写的，是JVM的一部分。启动类加载器无法被Java程序直接引用。</li><li><strong>扩展类加载器（Extension Class Loader）</strong>：它是Java语言实现的，<strong>继承自ClassLoader类</strong>，负责加载Java扩展目录（jre/lib/ext或由系统变量Java.ext.dirs指定的目录）下的jar包和类库。<strong>扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。</strong></li><li><strong>系统类加载器（System Class Loader）/ 应用程序类加载器（Application Class Loader）</strong>：这也是Java语言实现的，<strong>负责加载用户类路径（ClassPath）上的指定类库</strong>，是我们平时编写Java程序时默认使用的类加载器。系统类加载器的父加载器是扩展类加载器。它可以通过ClassLoader.getSystemClassLoader()方法获取到。</li><li><strong>自定义类加载器（Custom Class Loader）</strong>：开发者可以根据需求定制类的加载方式，比如从网络加载class文件、数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是Java动态性的一个重要体现。</li></ul><p>这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，<strong>而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</strong></p><p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载</p><h2 id="3-双亲委派模型的作用">3.双亲委派模型的作用</h2><ul><li><strong>保证类的唯一性</strong>：通过委托机制，<strong>确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况</strong>，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</li><li><strong>保证安全性</strong>：由于Java核心库被启动类加载器加载，而<strong>启动类加载器只加载信任的类路径中的类</strong>，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li><li><strong>支持隔离和层次划分</strong>：双亲委派模型<strong>支持不同层次的类加载器服务于不同的类加载需求</strong>，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li><li><strong>简化了加载流程</strong>：通过委派，<strong>大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。</strong></li></ul><h2 id="4-讲一下类加载过程？">4.讲一下类加载过程？</h2><h3 id=""><img src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt=""></h3><ul><li><strong>加载</strong>：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，<strong>转化为方法区运行时的数据结构</strong>，在内存中生成一个代表该类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li><li><strong>连接</strong>：验证、准备、解析 3 个阶段统称为连接。<ul><li><strong>验证</strong>：<strong>确保class文件中的字节流包含的信息，符合当前虚拟机的要求</strong>，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证</li><li><strong>准备</strong>：为类中的<strong>静态字段分配内存，并设置默认的初始值</strong>，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</li><li><strong>解析</strong>：解析阶段是<strong>虚拟机将常量池的「符号引用」直接替换为「直接引用」的过程</strong>。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</li></ul></li><li><strong>初始化</strong>：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是<strong>执行类的构造器方法（()</strong> ），要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。</li><li><strong>使用</strong>：使用类或者创建对象</li><li><strong>卸载</strong>：如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 3. 类对应的Java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="5-讲一下类的加载和双亲委派原则">5.讲一下类的加载和双亲委派原则</h2><p>我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化。</p><p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ul><li>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li><li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li><li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。</li></ul><p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p><p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h1>垃圾回收算法</h1><h2 id="1-什么是Java里的垃圾回收？如何触发垃圾回收？">1.什么是Java里的垃圾回收？如何触发垃圾回收？</h2><p>垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，它负责自动释放不再被程序引用的对象所占用的内存，这种机制减少了内存泄漏和内存管理错误的可能性。垃圾回收可以通过多种方式触发，具体如下：</p><ul><li><strong>内存不足时</strong>：当JVM检测到<strong>堆内存不足</strong>，无法为新的对象分配内存时，会自动触发垃圾回收。</li><li><strong>手动请求</strong>：虽然垃圾回收是自动的，**开发者可以通过调用 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 建议 JVM 进行垃圾回收。**不过这只是一个建议，并不能保证立即执行。</li><li><strong>JVM参数</strong>：启动 Java 应用时可以通过 <strong>JVM 参数来调整垃圾回收的行为</strong>，比如：<code>-Xmx</code>（最大堆大小）、<code>-Xms</code>（初始堆大小）等。</li><li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。</li></ul><h2 id="2-判断垃圾的方法有哪些？">2.判断垃圾的方法有哪些？</h2><p>在Java中，判断对象是否为垃圾（即不再被使用，可以被垃圾回收器回收）主要依据两种主流的垃圾回收算法来实现：<strong>引用计数法和可达性分析算法</strong>。</p><blockquote><p>引用计数法（Reference Counting）</p></blockquote><ul><li><strong>原理</strong>：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。</li><li><strong>缺点</strong>：<strong>不能解决循环引用的问题</strong>，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。</li></ul><blockquote><p>可达性分析算法（Reachability Analysis）</p></blockquote><p><img src="https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" alt="img"></p><p>Java虚拟机主要采用此算法来判断对象是否为垃圾。</p><ul><li><strong>原理</strong>：从一组称为<strong>GC Roots（垃圾收集根）的对象出发</strong>，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。**如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。**GC Roots对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等。</li></ul><h2 id="3-垃圾回收算法是什么，是为了解决了什么问题？">3.垃圾回收算法是什么，是为了解决了什么问题？</h2><p>JVM有垃圾回收机制的原因是为了<strong>解决内存管理的问题</strong>。在传统的编程语言中，开发人员需要手动分配和释放内存，这可能导致<strong>内存泄漏、内存溢出</strong>等问题。而Java作为一种高级语言，旨在提供更简单、更安全的编程环境，因此引入了垃圾回收机制来自动管理内存。</p><p>垃圾回收机制的主要目标是<strong>自动检测和回收****不再使用的对象</strong>，从而释放它们所占用的内存空间。这样可以<strong>避免内存泄漏（一些对象被分配了内存却无法被释放，导致内存资源的浪费）。同时，垃圾回收机制还可以防止内存溢出（即程序需要的内存超过了可用内存的情况）。</strong></p><p>通过垃圾回收机制，JVM可以在程序运行时自动识别和清理不再使用的对象，使得开发人员无需手动管理内存。这样可以提高开发效率、减少错误，并且使程序更加可靠和稳定。</p><h2 id="4-垃圾回收算法有哪些？">4.垃圾回收算法有哪些？</h2><ul><li><strong>标记-清除算法</strong>：标记-清除算法分为**“标记”和“清除”**两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，**标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。**有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</li><li><strong>复制算法</strong>：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。<strong>因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</strong></li><li><strong>标记-整理算法</strong>：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，<strong>但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</strong></li><li><strong>分代回收算法</strong>：分代收集是将内存划分成了<strong>新生代和老年代</strong>。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，<strong>一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</strong></li></ul><p>比如新生代我们使用复制算法效率较高，老年代使用标记-整理算法更好</p><h2 id="5-垃圾回收器有哪些？">5.垃圾回收器有哪些？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png" alt=""></p><h2 id="6-标记清除算法的缺点是什么？">6.标记清除算法的缺点是什么？</h2><p>主要缺点有两个：</p><ul><li>一个是效率问题，标记和清除过程的效率都不高；</li><li>另外一个是空间问题，标记清除之后会产生<strong>大量不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到<strong>足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong></li></ul><h2 id="7-垃圾回收算法哪些阶段会stop-the-world">7.垃圾回收算法哪些阶段会stop the world?</h2><p>标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：</p><ul><li><strong>标记阶段，即从GC Roots集合开始，标记活跃对象；</strong></li><li><strong>转移阶段，即把活跃对象复制到新的内存地址上；</strong></li><li><strong>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</strong></li></ul><p>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1718783586342-9da40db7-1dac-42ec-8148-81c10d8bfc04.png" alt="img"></p><p>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。</p><p><strong>标记阶段停顿分析</strong></p><ul><li>初始标记阶段：初始标记阶段是指从GC Roots出发标记<strong>全部直接子节点</strong>的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。</li><li>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。</li><li>再标记阶段：<strong>重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。</strong></li></ul><p><strong>清理阶段停顿分析</strong></p><ul><li><strong>清理阶段清点</strong>出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。</li></ul><p><strong>复制阶段停顿分析</strong></p><ul><li>**复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，**其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。</li></ul><p>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。</p><p>因此，G1停顿时间的瓶颈<strong>主要是标记-复制中的转移阶段STW。</strong></p><h2 id="8-minorGC、majorGC、fullGC的区别，什么场景触发full-GC">8.minorGC、majorGC、fullGC的区别，什么场景触发full GC</h2><p>在Java中，垃圾回收机制是自动管理内存的重要组成部分。根据其作用范围和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。以下是这三种GC的区别和触发场景：</p><blockquote><p>Minor GC (Young GC)</p></blockquote><ul><li><strong>作用范围</strong>：只针对<strong>年轻代</strong>进行回收，包括Eden区和两个Survivor区（S0和S1）。</li><li><strong>触发条件</strong>：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。</li><li><strong>特点</strong>：<strong>通常发生得非常频繁</strong>，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。</li></ul><blockquote><p>Major GC</p></blockquote><ul><li><strong>作用范围</strong>：主要<strong>针对老年代进行回收</strong>，但不一定只回收老年代。</li><li><strong>触发条件</strong>：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。</li><li><strong>特点</strong>：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。</li></ul><blockquote><p>Full GC</p></blockquote><ul><li><strong>作用范围</strong>：<strong>对整个堆内存（包括年轻代、老年代以及永久代/元空间）进行回收</strong>。</li><li><strong>触发条件</strong>：<ul><li>直接调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>方法时，虽然不能保证立即执行，但JVM会尝试执行Full GC。</li><li>Minor GC（新生代垃圾回收）时，如<strong>果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。</strong></li><li>当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时。</li></ul></li><li><strong>特点</strong>：Full GC是最昂贵的操作，因为它需要停止所有的工作线程（Stop The World），遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发。</li></ul><h2 id="9-垃圾回收器-CMS-和-G1的区别？">9.垃圾回收器 CMS 和 G1的区别？</h2><p><strong>区别一：使用的范围不一样：</strong></p><ul><li>CMS收集器是<strong>老年代</strong>的收集器，可以<strong>配合新生代的Serial和ParNew收集器一起使用</strong></li><li>G1收集器收集范围是<strong>老年代和新生代</strong>。不需要结合其他收集器使用</li></ul><p><strong>区别二：STW的时间：</strong></p><ul><li>CMS收集器以<strong>最小的停顿时间</strong>为目标的收集器。目标是交互更多一点</li><li>G1收集器可预测<a href="https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&amp;spm=1001.2101.3001.7020">垃圾回收 (opens new window)</a>的停顿时间（建立可预测的停顿时间模型），目标是高吞吐量</li></ul><p><strong>区别三： 垃圾碎片</strong></p><ul><li>CMS收集器是使用“标记-清除”<strong>算法进行的垃圾回收，容易产生内存碎片</strong></li><li>G1收集器使用的是“<strong>标记-整理</strong>”算法，进行了空间整合，没有内存空间碎片</li></ul><p>局部上看是标记-复制算法</p><p><strong>区别四： 垃圾回收的过程不一样</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1716015294690-efd71a12-f4b1-4356-9de2-5164393482a5.png" alt="img"></p><p>注意这两个收集器第四阶段得不同</p><p><strong>区别五: CMS会产生浮动垃圾</strong></p><ul><li>CMS产生浮动垃圾过多时<strong>会退化为serial old，效率低</strong>，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户线程同时工作会产生浮动垃圾，<strong>也就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾</strong></li><li>而G1没有浮动垃圾，**G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收，**在执行‘并发清理’步骤时，**用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。**如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,<strong>一旦出现此错误时便会切换到SerialOld收集方式。</strong></li></ul><h2 id="10-什么情况下使用CMS，什么情况使用G1">10.什么情况下使用CMS，什么情况使用G1?</h2><p>CMS适用场景：</p><ul><li><strong>低延迟需求</strong>：适用于对停顿时间要求敏感的应用程序。</li><li><strong>老生代收集</strong>：主要针对老年代的垃圾回收。</li><li><strong>碎片化管理</strong>：容易出现内存碎片，可能需要定期进行Full GC来压缩内存空间。</li></ul><p>G1适用场景：</p><ul><li><strong>大堆内存</strong>：适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。</li><li><strong>对内存碎片敏感</strong>：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。</li><li><strong>比较平衡的性能</strong>：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。</li></ul><h2 id="11-G1回收器的特色是什么？">11.G1回收器的特色是什么？</h2><p><strong>G1 的特点：</strong></p><ul><li>G1最大的特点是**引入分区的思路，弱化了分代的概念。**把区域分为几个region，然后回收的时候</li><li><strong>合理利用垃圾收集各个周期的资源</strong>，解决了其他收集器、甚至 CMS 的众多缺陷</li></ul><p><strong>G1 相比较 CMS 的改进：</strong></p><ul><li><strong>算法</strong>： G1 基于标记–整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。</li><li><strong>停顿时间可控</strong>： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。</li><li><strong>并行与并发</strong>：G1 能更充分的利用 <strong>CPU 多核环境下的硬件优势</strong>，来缩短 stop the world 的停顿时间。</li></ul><h2 id="12-GC只会对堆进行GC吗？">12.GC只会对堆进行GC吗？</h2><p>JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。</p><ol><li><strong>堆（Heap）：</strong> 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，因为大多数对象都会被分配在堆上，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。</li><li><strong>方法区（Method Area）：</strong> 方法区是用于<strong>存储类信息、常量、静态变量</strong>等数据的区域。虽然方法区中的垃圾回收与堆有所不同，<strong>但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。</strong></li></ol><h2 id="13-G1-的-Remembered-Set-是什么？">13.<strong>G1 的 Remembered Set 是什么？</strong></h2><p>每个 Region 维护的<strong>全局引用表</strong>，记录其他 Region 指向自己的对象，避免全堆扫描（解决跨 Region 引用问题），提升标记效率。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/jvm/">jvm</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/25/java-stack/jvm2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络期末考试复习</title>
      <link>https://blog.tokenlen.top/2025/05/25/lastteam/networktest/</link>
      <guid>https://blog.tokenlen.top/2025/05/25/lastteam/networktest/</guid>
      <pubDate>Sat, 24 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;名词解释&lt;/h1&gt;
&lt;h2 id=&quot;1-ARP&quot;&gt;1.ARP**&lt;/h2&gt;
&lt;p&gt;ARP（地址解析协议）用于&lt;strong&gt;根据 IP 地址获取对应的 MAC</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>名词解释</h1><h2 id="1-ARP">1.ARP**</h2><p>ARP（地址解析协议）用于<strong>根据 IP 地址获取对应的 MAC 地址</strong>，<strong>是主机通信前</strong>必须完成的地址解析步骤；RARP（逆地址解析协议）则相反，<strong>用于根据已知的 MAC 地址获取 IP 地址</strong>，常用于无盘工作站启动时向网络请求 IP。ARP 常见于局域网通信，RARP 已被 DHCP 等协议取代。</p><p>其中的单播和广播</p><h2 id="2-CDN">2.CDN*</h2><p>内容分发网络，用于将<strong>内容缓存至离用户更近的节点</strong>，提高访问速度、降低延迟。</p><h2 id="3-CSMA">3.CSMA</h2><p>载波监听多路访问，用于以太网的介质访问控制方式，通过“监听-发送”机制减少冲突。</p><h2 id="4-CRC">4.CRC*</h2><p><strong>循环冗余校验</strong>，链路层常用的差错检测机制，能发现传输过程中的数据错误。</p><h2 id="5-CSP">5.CSP</h2><p>内容安全策略，用于防止 XSS 等网页攻击，浏览器通过该策略限制网页资源加载来源。</p><h2 id="6-MAC">6.MAC*</h2><p>媒体访问控制地址，是网卡的物理地址，也指链路层控制子层，用于网络访问管理。</p><h2 id="7-MAN">7.MAN</h2><p>城域网，覆盖城市范围的计算机网络，规模介于局域网（LAN）和广域网（WAN）之间。</p><h2 id="8-MTU">8.MTU*</h2><p>最大传输单元，指网络层一次能够传输的最大数据报长度，影响分片与传输效率。</p><h2 id="9-NAT">9.NAT*</h2><p>网络地址转换，用于将私有 IP 映射为公网 IP，实现内网设备访问外网。</p><h2 id="10-NTP">10.NTP</h2><p>网络时间协议，用于在互联网上同步主机时间1。</p><h2 id="11-RTT">11.RTT</h2><p>RTT 是从发送方发出数据到接收方应答回来所经历的时间总和，衡量网络延迟。</p><h2 id="12-RIP">12.RIP</h2><p>RIP 是一种基于跳数的内部网关协议，用于在自治系统内部传播路由信息。</p><h2 id="简答题">简答题</h2><h2 id="1-http请求和响应报文">1.http请求和响应报文</h2><p>分为起始行、头部字段和消息主体三部分</p><p>请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求行（Request Line）</span><br><span class="line">请求头（Request Headers）</span><br><span class="line">空行</span><br><span class="line">请求体（Request Body）【仅部分请求有，如 POST】</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常见请求头</strong>：Host、User-Agent、Accept、Content-Type、Authorization</p><p>响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">状态行（Status Line）</span><br><span class="line">响应头（Response Headers）</span><br><span class="line">空行</span><br><span class="line">响应体（Response Body）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常见响应头</strong>：Content-Type、Content-Length、Set-Cookie、Cache-Control</p><h2 id="2-网络体系结构">2.网络体系结构</h2><p>OSI七层模型</p><p>每一层负责的职能都不同，如下：</p><ul><li>应用层，负责给应用程序提供统一的接口；</li><li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li><li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li><li>传输层，负责端到端的数据传输；</li><li>网络层，负责数据的路由、转发、分片；</li><li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li><li>物理层，负责在物理网络中传输数据帧；</li></ul><p>tcp/ip四层模型</p><ul><li>应用层 支持 HTTP、SMTP 等最终用户进程</li><li>传输层 处理主机到主机的通信（TCP、UDP）</li><li>网络层 寻址和路由数据包（IP 协议）</li><li>链路层 通过网络的物理电线、电缆或无线信道移动比特</li></ul><p>五层模型</p><h2 id="3-tcp-udp区别">3.tcp/udp区别</h2><p><strong>TCP 面向连接、可靠传输，有三次握手和四次挥手机制</strong>，适用于对数据完整性要求高的场景；而 <strong>UDP 是无连接、尽最大努力交付、效率高但不保证可靠性</strong>，适合实时性要求高的应用如视频通话、DNS 查询等。</p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>是（三次握手）</td><td>否</td></tr><tr><td>是否可靠</td><td>是（确认、重传）</td><td>否（尽力而为）</td></tr><tr><td>顺序保证</td><td>有</td><td>无</td></tr><tr><td>开销与速度</td><td>大、慢</td><td>小、快</td></tr><tr><td>典型应用场景</td><td>HTTP、FTP、SMTP 等</td><td>DNS、视频会议、VoIP 等</td></tr></tbody></table><ul><li>假定某UDP接收方对接收到的UDP报文段计算因特网检验和，并发现它与承载在检验和字段中的值<br>相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。</li></ul><p>不能，udp的错误检测机制不可能检测到所有的错误，不是百分比可靠的</p><ul><li>我们曾经说过，应用程序可能选择UDP作为运输协议，因为UDP提供了（比TCP）更好的应用层<br>控制，以决定在报文段中发送什么数据和发送时机。<br>a.应用程序为什么对在报文段中发送什么数据有更多的控制？<br>b-应用程序为什么对何时发送报文段有更多的控制？</li></ul><p>因为udp是无连接的，没有建立连接维持连接结束连接的过程，可以自由自在的决定何时发送如何发送数据</p><p>udp无连接，没有流量控制和拥塞控制机制。可以在任何时间发送</p><h2 id="4-网络层的控制平面和数据平面">4.网络层的控制平面和数据平面</h2><p>我们注意到网络层功能可被大体分成数据平面功能和控制平面功能。数据平面的主要功能是什么?控制平面的主要功能呢?</p><p>在网络层，<strong>控制平面</strong>负责“决策”——即如<strong>何选路</strong>（如路由协议 OSPF、BGP），而<strong>数据平面</strong>负责“转发”——<strong>即将数据包按照路由表实际转发出去</strong>。</p><p>控制平面构建和维护路由表，转发表，处理协议交互。</p><p>数据平面使用路由表完成转发，决定如何转发数据包。匹配数据包头部，转发或者丢弃修改数据。</p><p>网络层核心解决的问题是<strong>寻址与选路</strong>，相关知识包括 <strong>IP 地址划分、子网掩码、路由协议（静态/动态）、转发表、最长前缀匹配、NAT、ICMP</strong> 等，是理解网络通信的关键基础。</p><h2 id="5-RDT">5.RDT</h2><p>在我们的rdt协议中，为什么需要引入序号?</p><p>在我们的rdt协议中，为什么需要引入定时器?</p><p>在 RDT（可靠数据传输）协议中，<strong>引入计时器是为了应对数据丢失或 ACK 丢失的情况，保证发送方能在超时后重传数据</strong>；<strong>对帧编号是为了解决数据重复、乱序等问题，使接收方能够识别每个数据帧的唯一性与顺序</strong>。这两个机制共同确保了在不可靠信道上传输的可靠性</p><h2 id="6-url解析的过程">6.url解析的过程</h2><p><strong>浏览器输入 URL</strong><br>如 <code>http://www.example.com/index.html</code></p><p><strong>DNS 解析</strong><br>浏览器<strong>先查询本地缓存</strong>，没有则通过递归/迭代方式向 DNS 服务器请求，将域名（<a href="http://www.example.com">www.example.com</a>）转换为<strong>对应的 IP 地址。</strong></p><p><strong>CDN 节点选择（如果启用 CDN）</strong></p><ul><li>DNS 返回的不是源站 IP，而是离用户最近的 CDN 边缘节点 IP。</li><li>用户请求会被引导到该 CDN 节点，减少跨域和长距离传输。</li></ul><p><strong>建立 TCP 连接</strong><br>浏览器与 CDN 节点（或源站服务器）之间建立 TCP 连接（三次握手），若是 HTTPS，还会进行 TLS 握手。</p><p><strong>发送 HTTP 请求</strong><br>浏览器发送请求报文，请求具体资源（如 index.html）。</p><p><strong>服务器/CDN 节点响应</strong></p><ul><li>CDN 节点若<strong>缓存命中</strong>，直接返回缓存内容。</li><li>缓存未命中时，<strong>CDN 节点向源站服务器请求资源，然后缓存后返回给用户。</strong></li></ul><p><strong>浏览器接收响应，渲染页面</strong><br>浏览器解析 HTML，加载 CSS、JS、图片等资源，完成页面展示。</p><h2 id="7-ARP请求为什么是广播-应答为什么是单播">7.ARP请求为什么是广播,应答为什么是单播</h2><p>ARP 请求采用广播的原因</p><p>未知目标 MAC 地址：ARP 请求的目的是通过 IP 地址 查询对应的 MAC 地址，但<strong>初始时并不知道目标设备的 MAC，因此必须广播到 局域网（LAN）内的所有设备</strong>，确保目标设备能收到请求。</p><p>广播域限制:ARP 仅在同一子网内生效，广播方式能覆盖该网络内的所有主机。</p><p>ARP 应答采用单播的原因</p><p>已知请求方的 MAC 地址：在 ARP 请求报文中，**发送方已经填写了自己的 MAC 和 IP，因此目标设备可以直接 单播回复，**无需再次广播。</p><p>减少网络流量：如果 ARP 应答也广播，<strong>会导致不必要的网络拥塞</strong>，而单播仅发送给请求方，更高效。</p><p>目标明确：ARP 应答的 目标 MAC 和 IP 直接取自 ARP 请求的 发送方字段，因此能精准送达。</p><h1>计算</h1><h2 id="ip地址划分"><strong>ip地址划分</strong></h2><p>主要是子网掩码的计算，还有是不是在一个网段里</p><p>其中广播地址全是1，网络地址全是0.然后/25代表网络号有多少，剩下的是主机号。主要是2^n的数量</p><h2 id="crc循环冗余校验"><strong>crc循环冗余校验</strong></h2><p>例题：</p><p>补的位数是除数位数-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原始数据:     1101</span><br><span class="line">补0后数据:    1101000</span><br><span class="line">除数 G:       1011</span><br><span class="line"></span><br><span class="line">第一轮:</span><br><span class="line">1101 XOR 1011 = 0110</span><br><span class="line">拼接 0 → 01100</span><br><span class="line"></span><br><span class="line">第二轮:</span><br><span class="line">1100 XOR 1011 = 0111</span><br><span class="line">拼接 0 → 01110</span><br><span class="line"></span><br><span class="line">第三轮:</span><br><span class="line">1110 XOR 1011 = 0101</span><br><span class="line"></span><br><span class="line">最终CRC校验码 = 最后结果的后三位 = 101</span><br><span class="line">最终发送数据 = 原始数据 + 校验码 = 1101 101</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后原始数据+crc校验码=最终数据</p><p><strong>D(x)</strong> = 1010101010</p><p><strong>G(x)</strong> = 10011</p><p>求最终：</p><p>余数为0100</p><p>然后相加即可</p><h2 id="二进制回退算法，等多少时间-发生了几次碰撞"><strong>二进制回退算法，等多少时间,发生了几次碰撞</strong></h2><p>最大是10 在[0…2^n- 1]中任意选一个数，这就是等待时间。是CSMA/CD的关键组成</p><p>在CSMA/CD中，在第5次碰撞后，节点选择K =4的概率有多大？结果K=4在10Mbps以太网上对<br>应于多少秒的时延？</p><p>2^5-1=31,然后0-31有32个数，概率为1/32</p><p>然后等待时间=K×slot time</p><p>以太网标准中：</p><ul><li>10 Mbps 的以太网 ⇒ slot time = <strong>512 bit times</strong></li><li>每 bit 时间 = 1 / 10,000,000 = <code>0.1 μs</code></li><li>所以：</li></ul><p>$$<br>Slot time=512×0.1μs=51.2μs<br>$$</p><p>$$<br>Delay=4×51.2μs=204.8μs=0.0002048 秒<br>$$</p><h2 id="TCP计算">TCP计算</h2><p>考虑仅有一条单一的TCP （Reno）连接使用一条10Mbps链路，且该链路没有缓存任何数据。假设<br>这条链路是发送主机和接收主机之间的唯一拥塞链路。假定某TCP发送方向接收方有一个大文件要<br>发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个TCP报文段长度为1500<br>字节；该连接的双向传播时延是150ms；并且该TCP连接总是处于拥塞避免阶段，即忽略了慢<br>启动。<br>a.这条TCP连接能够取得的最大窗口长度（以报文段计）是多少？<br>b. 这条TCP连接的平均窗口长度（以报文段计）和平均吞吐量（以bps计）是多少？<br>c. 这条TCP连接在从丢包恢复后，再次到达其最大窗口要经历多长时间？</p><p>最大窗口大小（报文段） = <strong>带宽 × RTT / MSS</strong><br>$$<br>10Mbps×0.15s=1.5Mb=1,500,000bit<br>$$<br>报文段大小 MSS=12,000 bit</p><p>所以<strong>最大窗口长度</strong>为125</p><p><strong>平均窗口大小</strong>为：平均窗口长度=w/2+w/4=3/4*w，带入报文窗口为125，等于93.75个报文段</p><p><strong>平均吞吐量</strong>（bps）：平均窗口大小 × MSS / RTT = 7,500,000 bps=7.5 Mbps</p><p>每 RTT 将窗口增加 1 个报文段，丢包发生时窗口减半：从 <code>W</code> 降到 <code>W/2</code>，要从 <code>W/2</code> 增长到 <code>W</code>，需增加 <code>W/2</code> 个报文段。RTT*w/2=9.375</p><p><strong>考虑从主机 A 向主机 B 传输一个大小为 LLL 字节的大文件，假设：</strong></p><ul><li>每个 TCP 报文段的最大报文段大小 MSS = 536 字节</li><li>TCP 序号字段占 4 字节（即 32 位）</li><li>每个报文段附加运输层、网络层和链路层首部共计 66 字节</li><li>使用一条速率为 155 Mbps 的链路</li><li>忽略拥塞控制与流量控制，即主机 A 可连续不断地发送数据</li></ul><p>TCP 最大允许传输字节数=2^32=4GB</p><p>传输该文件的最短时间:</p><p>报文段数量=4GB/536=8,013,297</p><p>每个报文段大小（含头部）=536+66=602</p><p>总发送比特数:8,013,297×602×8=38,562,998,592 bit</p><p>t=总发送比特数/155 *10^6=248.76 秒</p><p><strong>假设主机A通过一条TCP连接向主机B</strong>发送两个紧接着的TCP报文段°第一个报文段的序号为90,<br>第二个报文段序号为110</p><p>a.第一个报文段中有多少数据? <strong>20</strong><br>b.假设第一个报文段丢失而第二个报文段到达主机B。那么在主机B发往主机A的确认报文中,<br>确认号应该是多少？ <strong>90</strong></p><p>假设某应用每20ms生成一个40字节的数据块，每块封装在一个TCP报文段中，TCP报文段再封装<br>在一个IP数据报中。每个数据报的开销有多大？应用数据所占百分比是多少？</p><table><thead><tr><th>协议层</th><th>头部大小</th></tr></thead><tbody><tr><td>TCP</td><td>20 字节</td></tr><tr><td>IP</td><td>20 字节</td></tr></tbody></table><p>总大小为40+20+20=80</p><p>占50%</p><p>考虑向具有700字节MTU的一条链路发送一个2400字节的数据报。假定初始数据报标有标识号<br>422。将会生成多少个分片？在生成相关分片的数据报中各个字段的值是多少?</p><p>IP头部占20字节，所以最多是680字节</p><p>总数据为2400-20=2380</p><p>2380/680=3.5，所以需要四个分片</p><h2 id="反码："><strong>反码</strong>：</h2><p>UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110,<br>01110100.这些8比特字节和的反码是多少？（注意到尽管UDP和TCP使用16比特的字来计算检验<br>和，但对于这个问题，你应该考虑8比特和。）写岀所有工作过程。UDP为什么要用该和的反码，即<br>为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 1比特的差错将可能检测不出<br>来吗？ 2比特的差错呢？</p><p>逐个相加，但需注意 <strong>溢出的进位（carry）要加回</strong></p><p>可以先全转为十进制得到301，然后转为2进制，发现为9位超了。然后再回绕，把高位的1加到低位里面</p><p>就是45+1=46然后转为2进制取反</p><p>得到<strong>11010001</strong></p><p>或者是直接二进制运算，但是注意也是要回退的，11的时候返回0，进位1</p><h2 id="网络时延">网络时延</h2><p>考虑两台主机 A 和 B 由一条速率为 <strong>R bps</strong> 的链路相连，两主机间距离为 <strong>m 米</strong>，链路的<strong>传播速率</strong>为 <strong>s 米/秒</strong>。主机 A 向 B 发送一个长度为 <strong>L 比特</strong> 的分组。</p><p>传播时延=m/s</p><p>传输时延=L/R</p><p>忽略排队时延，端到端的延时表达式=m/s+L/R</p><p>若主机 A 在时刻 0 开始传输分组，在 L/R 时，最后一个比特在哪？最后一个比特<strong>刚刚离开 A</strong>，还在链路起点，尚未传播。</p><p>若传播时延&gt;传输时延的时候，t=L/R的时候，第一个比特在哪？</p><p>第一个比特尚未到达 B，正在链路上传播中，位置为：s*L/R</p><p>反过来呢，第一个bit已经到达了B</p><p><strong>那么再加上排队时延和缓存呢？</strong></p><p>总时延=处理时延+排队时延+m/s+L/R</p><p><strong>缓存大小</strong>主要影响的是：</p><ul><li><strong>排队时延（<code>d_queue</code>）是否为 0 或变大</strong></li><li>当链路缓冲区已满，新的分组将被丢弃（产生丢包）→ 导致<strong>TCP重传、拥塞控制触发</strong></li></ul><p><strong>你点击了一个超链接</strong></p><ul><li><strong>本地没有 DNS 缓存</strong>，必须<strong>依次查询 n 个 DNS 服务器</strong></li><li><strong>HTML 页面只包含一个对象</strong>，<strong>对象传输时间忽略</strong></li><li>用 RTT1,RTT2,…,RTTnRTT_1, RTT_2, …, RTT_nRTT1,RTT2,…,RTTn 表示 DNS 查询链每一跳的往返时延</li><li>RTT0RTT_0RTT0 表示浏览器与目标服务器（Web服务器）之间的 RTT</li></ul><p><strong>总时延=DNS+2*RTT</strong></p><p>然后dns是需要递归的就是RTT1+RTT2。。。到RTTN,然后tcp是一个RTT0,http是第二个RTT0</p><p>考虑图3・58。假设TCP Reno是一个经历如上<br>所示行为的协议，回答下列问题。在各种情<br>况中，简要地论证你的回答。<br>指出TCP慢启动运行时的时间间隔。<br>指出TCP拥塞避免运行时的时间间隔。<br>在第16个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测岀<br>来的？ ~<br>在第22个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测出<br>来的？<br>在第1个传输轮回里，ssthresh的初始值设置为多少？<br>在第18个传输轮回里，ssthresh的值设置为多少？<br>在第24个传输轮回里，ssthresh的值设置为多少？<br>h. 在哪个传输轮回内发送第70个报文段？<br>i. 假定在第26个传输轮回后，通过收到3个冗余ACK检测出有分组丢失，拥塞的窗口长度和<br>ssthresh的值应当是多少？<br>j. 假定使用TCP Tahoe （而不是TCP Reno）,并假定在第16个传输轮回收到3个冗余ACK。在第19<br>个传输轮回，ssthresh和拥塞窗口长度是什么？</p><p>k.再次假设使用TCP Tahoe,在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传<br>输轮回（包括这两个传输轮回），一共发送了多少分组？</p><ul><li>考虑互联3个子网（子网1、子网2和子网3）的一台路由器。假定这3个子网的所有接口要求具有<br>前缀223.1.17/24。还假定子网1要求支持多达60个接口，子网2要求支持多达90个接口，子网3<br>要求支持多达12个接口。提供3个满足这些限制的网络地址（形式为a. b.c.d/x）o</li><li>考虑一个具有前缀12&amp; 119. 40. 128/26的子网。给出能被分配给该网络的一个IP地址（形式为<br>xxx. XXX. xxx. xxx）的例子o假定一个ISP拥有形式为12&amp; 119. 40. 64/26的地址块。假定它要从该地<br>址块生成4个子网，每块具有相同数量的IP地址。这4个子网（形式为a. b. c. d/x）的前缀是什么?</li><li>考虑在图4-25中建立的网络。假定ISP现在为路由器分配地址24.34.112.235,家庭网络的网络地<br>址是 192. 16&amp; 1/24。<br>a.在家庭网络中为所有接口分配地址。<br>P17.<br>b.假定每台主机具有两个进行中的TCP连接，所有都是针对主机128.119. 40. 86的80端口的。在<br>NAT转换表中提供6个对应表项。</li></ul><p>•如图6・33所示，考虑通过两台路由器互联的3个局域网。<br>a. 对所有的接口分配IP地址。对子网1使用形式为192. 168. 1. xxx的地址，对子网2使用形式为</p><p>xxx的地址，对子网3使用形式为192. 16&amp; 3. xxx的地址。<br>b. 为所有的适配器分配MAC地址。<br>c. 考虑从主机E向主机B发送一个1P数据报。假设所有的ARP表都是最新的。就像在6.4.1节中<br>对单路由器例子所做的那样，列举出所有步骤。<br>d. 重复（c）,现在假设在发送主机中的ARP表为空（并且其他表都是最新的）。</p><h1>综合题目</h1><h2 id="CSMA-CD-课件6-P33">CSMA/CD(课件6 P33)</h2><p><img src="C:%5CUsers%5Cikeife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250529135805545.png" alt="image-20250529135805545"></p><p><img src="C:%5CUsers%5Cikeife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250529135812262.png" alt="image-20250529135812262"></p><p>网卡接受来自网络层的数据报，并生成帧。</p><p>如果网卡检测到信道空闲，则开始帧的传输，如果信道繁忙，就等到空闲的时候再继续传输</p><p>如果网卡传输了整个帧，但是没有检测另一个帧。网卡将先完成帧的传输</p><p>如果网卡在传输过程中，遇到了另一个传输，将会中止并发送干扰信号</p><p>终止后，网卡将进入二进制回退：</p><p>​在经历m次碰撞后，网卡在0…2^m-1中任意选择K，网卡将会等待k*512位使劲按</p><p>​更长的实践回避，避免更多冲突</p><p>Ttorp=LAN中两个节点直接的最大传播延迟</p><p>ttans=最大传输尺寸帧的时间</p><p>效率就是那个公式</p><h2 id="bob-cdn">bob cdn</h2><p><img src="C:%5CUsers%5Cikeife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250529135827082.png" alt="image-20250529135827082"></p><p>bob从网页的url中获取视频的url，解析视频url到本地的dns，返回的是一个cdn地址。</p><p>本地dns继续递归解析cdn url像cdn的权威服务器请求，获取离bob最近的cdn节点的ip地址</p><p>浏览器向最近的cdn节点发送http请求。</p><p><img src="C:%5CUsers%5Cikeife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250529135831982.png" alt="image-20250529135831982"></p><p><img src="C:%5CUsers%5Cikeife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250529135844667.png" alt="image-20250529135844667"></p><h1>重点题目</h1><ul><li>描述应用程序开发者为什么可能选择在UDP上运行应用程序而不是在TCP上运行的原因</li></ul><p>由于 UDP 是无连接的传输协议，不需要建立连接、无需三次握手，也不进行确认应答和重传机制，因此适合对时效性要求高、可以容忍少量数据丢失的应用场景，如视频会议、在线游戏、实时语音通信等。此外，UDP 的协议开销更小，资源消耗更低，适合需要快速传输小数据包的轻量级应用。</p><ul><li>当某应用程序运行在UDP上时，该应用程序可能得到可靠数据传输吗？如果能，如何实现？</li></ul><p><strong>可以通过在应用层自行设计机制</strong>来实现可靠传输。具体做法包括：为每个数据包添加序号以便接收方能检测是否有丢包、重复包或乱序数据，并利用应答机制（ACK）让接收方告知发送方哪些数据已成功收到；如果发送方在一定时间内未收到 ACK，则可以重传数据包。此外，还可以设置超时重传、滑动窗口、流量控制等机制来进一步增强可靠性</p><ul><li>假定在主机C端口 80上运行的一个Web服务器。假定这个Web服务器使用持续连接，并且正在接 收来自两台不同主机A和B的请求。被发送的所有请求都通过位于主机C的相同套接字吗？如果它 们通过不同的套接字传递，这两个套接字都具有端口 80吗？讨论和解释之：</li></ul><p><strong>会将来自主机 A 和主机 B 的请求都通过同一个套接字处理</strong>。虽然所有请求最初都是通过 <strong>端口 80</strong> 到达服务器的，但操作系统会为每一个客户端连接创建一个 <strong>新的套接字（socket）</strong> 来进行实际通信。</p><ul><li><p>通过一条TCP连接向主机B发送两个紧接着的TCP报文段°第一个报文段的序号为90,<br>第二个报文段序号为110</p><p>第一个报文段中有多少数据?<br>b.假设第一个报文段丢失而第二个报文段到达主机B。那么在主机B发往主机A的确认报文中,<br>确认号应该是多少？</p></li></ul><p>数据=110-90=20</p><p>还是90，然后触发重传机制</p><ul><li>假设两条TCP连接存在于一个带宽为R bps的瓶颈链路上。它们都要发送一个很大的文件（以相同<br>方向经过瓶颈链路），并且两者是同时开始发送文件。那么TCP将为每条连接分配什么样的传输<br>速率？</li></ul><p>当两条 TCP 连接同时通过带宽为 R bps 的瓶颈链路发送大文件时，由于 TCP 拥塞控制机制的作用，系统会根据链路的拥塞情况<strong>动态调整发送速率，使每条连接最终获得约 R/2 bps</strong> 的传输速率，从而公平地共享瓶颈带宽。这种公平性是 TCP 拥塞控制的自然结果，尤其是在网络条件一致、没有其他影响因素时更为明显。</p><h1>作业题目字典</h1><p>第一章：</p><ul><li><p>“主机”和“端系统”之间有什么不同？列举几种不同类型的端系统。Web服务器是一种端系统吗?</p></li><li><p>7.以太LAN的传输速率是多少?</p></li><li><p>.描述今天最为流行的无线因特网接入技术。对它们进行比较和对照。</p></li><li><p>假定在发送主机和接收主机间只有一台分组交换机。发送主机和交换机间以及交换机和接收主机间<br>的传输速率分别是&amp;和忌。假设该交换机使用存储转发分组交换方式，发送一个长度为厶的分组<br>的端到端总时延是什么？（忽略排队时延、传播时延和处理时延。）</p></li><li><p>假定用户共享一条2Mbps链路。同时假定当每个用户传输时连续以1Mbps传输，但每个用户仅传输<br>20%的时间。<br>a.当使用电路交换时，能够支持多少用户?<br>b. 作为该题的后继问题，假定使用分组交换。 为什么如果两个或更少的用户同时传输的话，在链<br>路前面基本上没有排队时延？为什么如果3个用户同时传输的话，将有排队时延?<br>c. 求出某指定用户正在传输的概率。<br>d. 假定现在有3个用户。求出在任何给定的时间，所有3个用户在同时传输的概率。求出队列增长<br>j 的时间比率。</p></li><li><p>—个长度为1000字节的分组经距离为2500km的链路传播，传播速率为2.5xl08m/s并且传输速率<br>为2Mbps,它需要用多长时间？更为一般地，一个长度为厶的分组经距离为/的链路传播，传播速率为并且传输速率为Rbps,它需要用多长时间？该时延与传输速率相关吗？</p></li><li><p>因特网协议栈中的5个层次有哪些？在这些层次中，每层的主要任务是什么？</p></li><li><p>路由器处理因特网协议栈中的哪些层次？链路层交换机处理的是哪些层次？主机处理的是哪些层次？</p></li><li><p>式（1・1）给出了经传输速率为R的7V段链路发送长度厶的一个分组的端到端时延。对于经过/V段链<br>路一个接一个地发送P个这样的分组，一般化地表示出这个公式。</p></li><li><p>这个习题开始探讨传播时延和传输时延，这是数据网络中的两个重要概念。考虑两台主机A和B由<br>一条速率为Abps的链路相连。假定这两台主机相隔肌米，<a href="http://xn--siqsvh13ccmhcyicteuo9blodd8ffuo.sm/so%E4%B8%BB%E6%9C%BAA%E5%90%91">沿该链路的传播速率为.sm/so主机A向</a><br>主机B发送长度L比特的分组。<br>a. 用m和s来表示传播时延&quot;pmp。<br>b. 用厶和/?来确定该分组的传输时间血亦。<br>c. 忽略处理和排队时延，得出端到端时延的表达式。<br>d. 假定主机A在时刻20开始传输该分组。在时刻/二血唤，该分组的最后一个比特在什么地方？<br>e. 假定心卿大于＜n8o在时刻2血g 该分组的第一个比特在何处？<br>f. 假定如中小于血昨。在时刻2九阳，该分组的第一个比特在何处？<br>g. 假定5=2.5 xlO8, L = 120比特，56kbps。，求出使心哪等于血込的距离叫</p></li><li><p>假定用户共享一条3Mbps的链路。又设每个用户传输时要求150kbps，但是每个用户仅有10%的时间<br>传输。（参见1.3节中关于“分组交换与电路交换的对比”的讨论。）<br>当使用电路交换时，能够支持多少用户？<br>对于本习题的后续小题，假定使用分组交换。求出某给定用户正在传输的概率。<br>假定有120个用户。求出在任何给定时刻，实际有n个用户在同时传输的概率。（提示：使用二项<br>式分布。）<br>求出有21个或更多用户同时传输的概率</p></li><li><p>考虑在1.3节“分组交换与电路交换的对比”的讨论中，给出了一个具有一条1Mbps链路的例子。<br>用户在忙时以100kbps速率产生数据，但忙时仅以p=0. 1的概率产生数据。假定用lGbp$链路替代<br>1Mbps的链路。<br>a. 当采用电路交换技术时，能被同时支持的最大用户数量/V是多少？<br>b. 现在考虑分组交换和有M个用户的情况。给出多于/V用户发送数据的概率公式（用p、M、/V<br>表不）O</p></li><li><p>a.假定有N个分组同时到达一条当前没有分组传输或排队的链路。每个分组长为厶，链路传输速率<br>为R。对N个分组而言.其平均排队时延是多少？<br>b.现在假定每隔LN/R秒有N个分组同时到达链路。一个分组的平均排队时延是多少？</p></li><li><p>对两进程之间的通信会话而言，哪个进程是客户，哪个进程是服务器?</p></li><li><p>运行在一台主机上的一个进程，使用什么信息来标识运行在另一台主机上的进程?</p></li><li><p>假定你想尽快地处理从远程客户到服务器的事务，你将使用UDP还是TCP?为什么？</p></li><li><p>前面讲过TCP能用SSL来强化，以提供进程到进程的安全性服务，包括加密。SSL运行在运输层还<br>是应用层？如果某应用程序研制者想要用SSL来强化UDP,该研制者应当做些什么工作？</p></li><li><p>握手协议的作用是什么？</p></li><li><p>考虑一个电子商务网站需要保留每一个客户的购买记录。描述如何使用cookie来完成该功能？</p></li><li><p>CDN通常采用两种不同的服务器放置方法之一。列举并简单描述它们。</p></li><li><p>除了如时延、丢包和带宽性能等网络相关的考虑外，设计一种CDN服务器选择策略时还有其他重<br>要因素。它们是什么？</p></li><li><p>7节中所描述的UDP服务器仅需要一个套接字，而TCP服务器需要两个套接字。为什么？如果<br>TCP服务器支持几个并行连接，每条连接来自不同的客户主机，那么TCP服务器将需要多少个套<br>接字？</p></li><li><p>对于2. 7节所描述的运行在TCP之上的客户-服务器应用程序，服务器程序为什么必须先于客户程序<br>运行？对于运行在UDP之上的客户-服务器应用程序，客户程序为什么可以先于服务器程序运行？</p></li><li><p>考虑一个要获取给定URL的Web文档的HTTP客户。该HTTP服务器的IP地址开始时并不知道。在<br>这种情况下，除了 HTTP外，还需要什么运输层和应用层协议？</p></li><li><p>假定你在浏览器中点击一条超链接获得Web页面。相关联的URL的IP地址没有缓存在本地主机上,<br>因此必须使用DNS lookup以获得该IP地址。如果主机从DNS得到IP地址之前已经访问了 n个DNS<br>服务器；相继产生的RTT依次为RTT|、…、RTT“<br>。 进一步假定与链路相关的Web页面只包含一个<br>对象，即由少量的HTML文本组成。令RTT。表示本地主机和包含对象的服务器之间的RTT值。假定<br>该对象传输时间为零，则从该客户点击该超链接到它接收到该对象需要多长时间？</p></li><li><p>参照习题P7,假定在同一服务器上某HTML文件引用了 8个非常小的对象。忽略发送时间，在下列<br>情况下需要多长时间：<br>a.没有并行TCP连接的非持续HTTP。</p><p>b.配置有5个并行连接的非持续HTTP。<br>c.持续 HTTPO</p></li><li><p>在一台主机上安装编译TCPClient和UDPClient Python程序，在另一台主机上安装编译TCPServer和<br>UDPServer 程序。<br>乩假设你在运行TCPServer之前运行TCPClient,将发生什么现象？为什么？<br>b. 假设你在运行UDPServer之前运行UDPClient,将发生什么现象？为什么？<br>c. 如果你对客户端和服务器端使用了不同的端口，将发生什么现象？</p></li><li><p>你能够配置浏览器以打开对某Web站点的多个并行连接吗？有大量的并行TCP连接的优点和缺点<br>是什么</p></li><li><p>我们已经看到因特网TCP套接字将数据处理为字节流，而UDP套接字识别报文边界。面<br>与显式识别和维护应用程序定义的报文边界的API相比，试给出一个优点和一个缺点。</p></li><li><p><strong>描述应用程序开发者为什么可能选择在UDP上运行应用程序而不是在TCP上运行的原因</strong></p></li><li><p>在今天的因特网中，为什么语音和图像流量常常是经过TCP而不是经UDP发送° （提示：我们寻找<br>的答案与TCP的拥塞控制机制没有关系。）</p></li><li><p>当某应用程序运行在UDP上时，该应用程序可能得到可靠数据传输吗？如果能，如何实现？</p></li><li><p>假定在主机C端口 80上运行的一个Web服务器。假定这个Web服务器使用持续连接，并且正在接<br>收来自两台不同主机A和B的请求。被发送的所有请求都通过位于主机C的相同套接字吗？如果它<br>们通过不同的套接字传递，这两个套接字都具有端口 80吗？讨论和解释之：</p></li><li><p>.在我们的rdt协议中，为什么需要引入序号?</p></li><li><p>.在我们的rdt协议中，为什么需要引入定时器?</p></li><li><p>假设主机A通过一条TCP连接向主机B发送两个紧接着的TCP报文段°第一个报文段的序号为90,<br>第二个报文段序号为110</p><p>第一个报文段中有多少数据?<br>b.假设第一个报文段丢失而第二个报文段到达主机B。那么在主机B发往主机A的确认报文中,<br>确认号应该是多少？</p></li><li><p>假设两条TCP连接存在于一个带宽为R bps的瓶颈链路上。它们都要发送一个很大的文件（以相同<br>方向经过瓶颈链路），并且两者是同时开始发送文件。那么TCP将为每条连接分配什么样的传输<br>速率？</p></li><li><p>UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节：01010011, 01100110,<br>01110100.这些8比特字节和的反码是多少？（注意到尽管UDP和TCP使用16比特的字来计算检验<br>和，但对于这个问题，你应该考虑8比特和。）写岀所有工作过程。UDP为什么要用该和的反码，即<br>为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？ 1比特的差错将可能检测不出<br>来吗？ 2比特的差错呢？</p></li><li><p>假定某UDP接收方对接收到的UDP报文段计算因特网检验和，并发现它与承载在检验和字段中的值<br>相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。</p></li><li><p>我们曾经说过，应用程序可能选择UDP作为运输协议，因为UDP提供了（比TCP）更好的应用层<br>控制，以决定在报文段中发送什么数据和发送时机。<br>a.应用程序为什么对在报文段中发送什么数据有更多的控制？<br>b-应用程序为什么对何时发送报文段有更多的控制？</p></li><li><p>考虑从主机A向主机B传输L字节的大文件，假设MSS为536字节。<br>a. 为了使得TCP序号不至于用完，厶的最大值是多少？前面讲过TCP的序号字段为4字节。<br>b. 对于你在（a）中得到的厶，求出传输此文件要用多长时间？假定运输层、网络层和数据链路层<br>首部总共为66字节，并加在每个报文段上，然后经155Mbps链路发送得到的分组。忽略流量控<br>制和拥塞控制，使主机A能够一个接一个和连续不断地发送这些报文段。</p></li><li><p>主机A和B直接经一条100Mbps链路连接。在这两台主机之间有一条TCP连接。主机A经这条连<br>接向主机B发送一个大文件。主机A能够向它的TCP套接字以高达120Mbps的速率发送应用数据,<br>而主机B能够以最大50Mbps的速率从它的TCP接收缓存中读岀数据。描述TCP流量控制的影响。</p></li><li><p>在3. 5. 4节中，我们看到TCP直到收到3个冗余ACK才执行快速重传。你对TCP设计者没有选择<br>在收到对报文段的第一个冗余ACK后就快速重传有何看法？</p></li><li><p>考虑图3・58。假设TCP Reno是一个经历如上<br>所示行为的协议，回答下列问题。在各种情<br>况中，简要地论证你的回答。<br>指出TCP慢启动运行时的时间间隔。<br>指出TCP拥塞避免运行时的时间间隔。<br>在第16个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测岀<br>来的？ ~<br>在第22个传输轮回之后，报文段的丢失是<br>根据3个冗余ACK还是根据超时检测出<br>来的？<br>在第1个传输轮回里，ssthresh的初始值设置为多少？<br>在第18个传输轮回里，ssthresh的值设置为多少？<br>在第24个传输轮回里，ssthresh的值设置为多少？<br>h. 在哪个传输轮回内发送第70个报文段？<br>i. 假定在第26个传输轮回后，通过收到3个冗余ACK检测出有分组丢失，拥塞的窗口长度和<br>ssthresh的值应当是多少？<br>j. 假定使用TCP Tahoe （而不是TCP Reno）,并假定在第16个传输轮回收到3个冗余ACK。在第19<br>个传输轮回，ssthresh和拥塞窗口长度是什么？</p><p>k.再次假设使用TCP Tahoe,在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传<br>输轮回（包括这两个传输轮回），一共发送了多少分组？</p></li><li><p>考虑仅有一条单一的TCP （Reno）连接使用一条10Mbps链路，且该链路没有缓存任何数据。假设<br>这条链路是发送主机和接收主机之间的唯一拥塞链路。假定某TCP发送方向接收方有一个大文件要<br>发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个TCP报文段长度为1500<br>字节；该连接的双向传播时延是150ms；并且该TCP连接总是处于拥塞避免阶段，即忽略了慢<br>启动。<br>&amp;这条TCP连接能够取得的最大窗口长度（以报文段计）是多少？<br>b. 这条TCP连接的平均窗口长度（以报文段计）和平均吞吐量（以bps计）是多少？<br>c. 这条TCP连接在从丢包恢复后，再次到达其最大窗口要经历多长时间？</p></li><li><p>我们注意到网络层功能可被大体分成数据平面功能和控制平面功能。数据平面的主要功能是什么?<br>控制平面的主要功能呢?</p></li><li><p>我们对网络层执行的转发功能和路由选择功能进行区别路由选择和转发的主要区别是什么</p></li><li><p>路由器中转发表的主要作用是什么?</p></li><li><p>在4.2节中，我们看到路由器通常由输入端口、输出端口、交换结构和路由选择处理器组成。其中<br>哪些是用硬件实现的，哪些是用软件实现的？为什么？转到网络层的数据平面和控制平面的概念,<br>哪些是用硬件实现的，哪些是用软件实现的？为什么?</p></li><li><p>假设一个到达分组匹配了路由器转发表中的两个或更多表项。采用传统的基于目的地转发，路由器<br>用什么原则来确定这条规则可以用于确定输出端口，使得到达的分组能交换到输出端口？</p></li><li><p>描述在输入端口会出现分组丢失的原因。描述在输入端口如何消除分组丢失（不使用无限大缓存区）</p></li><li><p>描述在输出端口会出现分组丢失的原因。通过提高交换结构速率，能够防止这种丢失吗?</p></li><li><p>假定主机A向主机B发送封装在一个IP数据报中的TCP报文段。当主机B接收到该数据报时，主<br>机B中的网络层怎样知道它应当将该报文段（即数据报的有效载荷）交给TCP而不是UDP或某个<br>其他东西呢？</p></li><li><p>什么时候一个大数据报分割成多个较小的数据报？较小的数据报在什么地方装配成一个较大的数据报？</p></li><li><p>假设在一个源主机和一个目的主机之间有3台路由器。不考虑分片，一个从源主机发送给目的主机<br>的IP数据报将通过多少个接口？为了将数据报从源移动到目的地需要检索多少个转发表？4</p></li><li><p>假设某应用每20ms生成一个40字节的数据块，每块封装在一个TCP报文段中，TCP报文段再封装<br>在一个IP数据报中。每个数据报的开销有多大？应用数据所占百分比是多少？</p></li><li><p>假定你购买了一个无线路由器并将其与电缆调制解调器相连。同时假定ISP动态地为你连接的设备<br>（即你的无线路由器）分配一个IP地址。还假定你家有5台PC,均使用802. 11以无线方式与该无<br>线路由器相连。怎样为这5台PC分配IP地址？该无线路由器使用NAT吗？为什么?</p></li><li><p>“路由聚合” 一词意味着什么？路由器执行路由聚合为什么是有用的</p></li><li><p>什么是专用网络地址？具有专用网络地址的数据报会出现在大型公共因特网中吗？解释理由。</p></li><li><p>通用转发与基于目的地转发有何不同？</p></li><li><p>路由器或交换机的“匹配加动作”意味着什么？在基于目的地转发的分组交换机场合中，要匹配什<br>么并采取什么动作？在SDN的场合中，举出3个能够被匹配的字段和3个能被采取的动作。</p></li><li><p>假设两个分组在完全相同的时刻到达一台路由器的两个不同输入端口。同时假设在该路由器中没有<br>其他分组。<br>假设这两个分组朝着两个不同的输出端口转发。当交换结构使用一条共享总线时，这两个分组可<br>能在相同时刻通过该交换结构转发吗？ ’<br>假设这两个分组朝着两个不同的输岀端口转发。当交换结构使用经内存交换时，这两个分组可能<br>在相同时刻通过该交换结构转发吗？ “ . 假设这两个分组朝着相同的输出端口转发。当交换结构使用纵横式时，这两个分组可能在相同时<br>刻通过该交换结构转发吗？</p></li><li><p>考虑使用32比特主机地址的某数据报网络°假定一台路由器具有4条链路.编号为0~3,分组能被<br>转发到如下的各链路接口：<br>目的地址范围<br>11100000 00000000 00000000 00000000<br>到<br>11100000 00111111 11111111 11111111<br>链路接口<br>0<br>11100000 01000000 00000000 00000000<br>到 1<br>11100000 01000000 11111111 11111111<br>111(X)000 01000(X)1 0(X)00000 00000000<br>到 2<br>11100001 01111111 11111111 11111111<br>其他 3<br>网络层:数据平 239<br>a. 提供一个具有5个表项的转发表，使用最长前缀匹配，转发分组到正确的链路接口。<br>b. 描述你的转发表是如何为具有下列目的地址的数据报决定适当的链路接口的。<br>11001000 10010001 01010001 01010101<br>11100001 01000000 11000011 00111100<br>11100001 10000000 00010001 01110111</p></li><li><p>考虑互联3个子网（子网1、子网2和子网3）的一台路由器。假定这3个子网的所有接口要求具有<br>前缀223.1.17/24。还假定子网1要求支持多达60个接口，子网2要求支持多达90个接口，子网3<br>要求支持多达12个接口。提供3个满足这些限制的网络地址（形式为a. b.c.d/x）o</p></li><li><p>考虑一个具有前缀12&amp; 119. 40. 128/26的子网。给出能被分配给该网络的一个IP地址（形式为<br>xxx. XXX. xxx. xxx）的例子o假定一个ISP拥有形式为12&amp; 119. 40. 64/26的地址块。假定它要从该地<br>址块生成4个子网，每块具有相同数量的IP地址。这4个子网（形式为a. b. c. d/x）的前缀是什么?</p></li><li><p>考虑向具有700字节MTU的一条链路发送一个2400字节的数据报。假定初始数据报标有标识号<br>422。将会生成多少个分片？在生成相关分片的数据报中各个字段的值是多少?</p></li><li><p>考虑在图4-25中建立的网络。假定ISP现在为路由器分配地址24.34.112.235,家庭网络的网络地<br>址是 192. 16&amp; 1/24。<br>a.在家庭网络中为所有接口分配地址。<br>P17.<br>b.假定每台主机具有两个进行中的TCP连接，所有都是针对主机128.119. 40. 86的80端口的。在<br>NAT转换表中提供6个对应表项。</p></li><li><p>比较和对照链路状态和距离矢量这两种路由选择算法</p></li><li><p>为什么在因特网中用到了不同的AS间与AS内部协议？</p></li><li><p>在OSPF自治系统中区域表示什么？为什么引入区域的概念?</p></li><li><p>假定你要在SDN控制平面中实现一个新型路由选择协议。你将在哪个层次中实现该协议？解释<br>理由。</p></li><li><p>.什么类型的报文流跨越SDN控制器的北向和南向API?谁是从控制器跨越南向接口发送的这些报文<br>的接收者？谁是跨越北向接口从控制器发送的这些报文的接收者？</p></li><li><p>描述两种从受控设备到控制器发送的0penFlow报文（由你所选）类型的目的。描述两种从控制器<br>到受控设备发送的OpenFlow报文（由你所选）类型的目的。</p></li><li><p>在发送主机执行Traceroute程序，收到哪两种类型的ICMP报文?</p></li><li><p><strong>第五章习题7</strong> 考虑下图所示的网络段。兀只有两个相连邻居⑷与y。⑷有一条通向目的地仏（没有显示）的最低开<br>销路径，其值为5, y有一条通向目的地&quot;的最低开销路径，其值为6。从如与y到u （以及⑷与y之<br>间）的完整路径未显示出来。网络中所有链路开销皆为正整数值。<br>5<br>/<br>a-给出x对目的地⑷、y和u的距离向量。<br>280 第5袁<br>b. 给出对于c&amp;, w)或c(%, y)的链路开销的变化，使得执行了距离向量算法后，％将通知其邻居<br>有一条通向“的新最低开销路径。<br>c. 给出对c(%, w)或c(g y)的链路开销的变化，使得执行了距离向量算法后，力将不通知其邻居<br>有一条通向x的新最低开销路径。</p></li><li><p>如果在因特网中的所有链路都提供可靠的交付服务，TCP可靠传输服务将是多余的吗？为什么？</p></li><li><p>在CSMA/CD中，在第5次碰撞后，节点选择K =4的概率有多大？结果K=4在10Mbps以太网上对<br>应于多少秒的时延？</p></li><li><p>MAC地址空间有多大？ IPv4的地址空间呢？ IPv6的地址空间呢?</p></li><li><p>ARP査询为什么要在广播帧中发送呢？ ARP响应为什么要在一个具有特定目的MAC地址的帧中发<br>送呢?</p></li><li><p>考虑5比特生成多项式，6 = 10011,并且假设。的值为lOlOlOlOlOo /?的值是什么</p></li><li><p>考虑上一个习题，这时假设D具有值：<br>a. 1001010101c<br>b. 0101101010o •一一<br>c. 1010100000</p></li><li><p>•如图6・33所示，考虑通过两台路由器互联的3个局域网。<br>a. 对所有的接口分配IP地址。对子网1使用形式为192. 168. 1. xxx的地址，对子网2使用形式为</p><p>xxx的地址，对子网3使用形式为192. 16&amp; 3. xxx的地址。<br>b. 为所有的适配器分配MAC地址。<br>c. 考虑从主机E向主机B发送一个1P数据报。假设所有的ARP表都是最新的。就像在6.4.1节中<br>对单路由器例子所做的那样，列举出所有步骤。<br>d. 重复（c）,现在假设在发送主机中的ARP表为空（并且其他表都是最新的）。</p></li><li><p>在某网络中标识为A到F的6个节点以星形与一台交换机连接，考虑在该网络环境中某个正在<br>学习的交换机的运行情况。假定：（i） B向E发送一个帧；（ii） E向B回答一个帧；（iii） A<br>向B发送一个帧；（iv） B向A回答一个帧“该交换机表初始为空。显示在这些事件的前后该<br>交换机表的状态。对于每个事件，指出在其上面转发传输的帧的链路，并简要地评价你的<br>答案。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/408/">408</category>
      
      <category domain="https://blog.tokenlen.top/categories/408/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/net/">net</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/25/lastteam/networktest/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试题目hot2集合</title>
      <link>https://blog.tokenlen.top/2025/05/23/javase/javase3/</link>
      <guid>https://blog.tokenlen.top/2025/05/23/javase/javase3/</guid>
      <pubDate>Thu, 22 May 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1&gt;概念&lt;/h1&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1>概念</h1><h2 id="1-数组与集合区别，用过哪些？">1.数组与集合区别，用过哪些？</h2><p>数组和集合的区别：</p><ul><li>数组是<strong>固定长度</strong>的数据结构，一旦创建长度就无法改变，而集合是<strong>动态长度</strong>的数据结构，可以根据需要动态增加或减少元素。</li><li>数组可以<strong>包含基本数据类型和对象</strong>，而集合<strong>只能包含对象</strong>。</li><li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</li></ul><p>我用过的一些 Java 集合类：</p><ol><li><strong>ArrayList：</strong> 动态数组，实现了List接口，支持动态增长。</li><li><strong>LinkedList：</strong> 双向链表，也实现了List接口，支持快速的插入和删除操作。</li><li><strong>HashMap：</strong> 基于哈希表的Map实现，存储键值对，通过键快速查找值。</li><li><strong>HashSet：</strong> 基于HashMap实现的Set集合，用于存储唯一元素。</li><li><strong>TreeMap：</strong> 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。</li><li><strong>LinkedHashMap：</strong> 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。</li><li><strong>PriorityQueue：</strong> 优先队列，可以按照比较器或元素的自然顺序进行排序。</li></ol><h2 id="2-说说Java中的集合？">2.说说Java中的集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt=""></p><p>List是<strong>有序的Collection</strong>，使用此接口能够精确的控制每个元素的插入位置，用户能根据索引访问List中元素。常用的实现List的类有LinkedList，ArrayList，Vector，Stack。</p><ul><li>ArrayList是容量可变的非线程安全列表，其底层使用数组实现。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>ArrayList支持对元素的快速随机访问，但插入与删除速度很慢。</strong></li><li>LinkedList本质是<strong>一个双向链表</strong>，与ArrayList相比，，<strong>其插入和删除速度更快</strong>，但随机访问速度更慢。</li></ul><p>Set不允许存在重复的元素，与List不同，set中的元素是<strong>无序的</strong>。常用的实现有HashSet，LinkedHashSet和TreeSet。</p><ul><li>HashSet通过HashMap实现，HashMap的Key即HashSet存储的元素，<strong>所有Key都是用相同的Value</strong>，一个名为<strong>PRESENT</strong>的Object类型常量。使用Key保证元素唯一性，但不保证有序性。由于HashSet是HashMap实现的，因此线程不安全。</li><li>LinkedHashSet继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序。</li><li>TreeSet通过TreeMap实现的，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。</li></ul><p>Map 是<strong>一个键值对集合</strong>，存储键、值和之间的映射。Key 无序，唯一；value 不要求有序，允许重复。Map 没有继承于 Collection 接口，从 Map 集合中检索元素时，<strong>只要给出键对象，就会返回对应的值对象</strong>。主要实现有TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap</p><ul><li>HashMap：JDK1.8 之前 HashMap <strong>由数组+链表组成的</strong>，数组是 HashMap 的主体，<strong>链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）</strong>，JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间</strong></li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是**基于拉链式散列结构即由数组和链表或红黑树组成。**另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，<strong>使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</strong></li><li>HashTable：<strong>数组+链表</strong>组成的，数组是 HashTable 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap：<strong>红黑树（自平衡的排序二叉树）</strong></li><li>ConcurrentHashMap：<strong>Node数组+链表+红黑树实现</strong>，<strong>线程安全的</strong>（jdk1.8以前<strong>Segment</strong>锁，<strong>1.8以后volatile + CAS 或者 synchronized）</strong></li></ul><h2 id="3-Java中的线程安全的集合是什么？">3.Java中的线程安全的集合是什么？</h2><ul><li><strong>Vector</strong>：<strong>线程安全的动态数组</strong>，其内部方法基本都经过synchronized修饰，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，<strong>当数组已满时，会创建新的数组，并拷贝原有数组数据。</strong></li><li><strong>Hashtable</strong>：线程安全的哈希表，**HashTable 的加锁方法是给每个方法加上 synchronized 关键字，这样锁住的是整个 Table 对象，<strong>不支持 null 键和值</strong>，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用ConcurrentHashMap。</li></ul><p>java.util.concurrent 包提供的都是线程安全的集合：</p><p>并发Map：</p><ul><li><strong>ConcurrentHashMap</strong>：它与 HashTable 的主要区别是<strong>二者加锁粒度</strong>的不同，在<strong>JDK1.7</strong>，ConcurrentHashMap加的是<strong>分段锁，也就是Segment锁</strong>，每个Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在<strong>JDK 1.8</strong> ，它取消了Segment字段，**直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。**对于put操作，如果Key对应的数组元素为null，<strong>则通过CAS操作（Compare and Swap）将其设置为当前值</strong>。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，<strong>则对该元素使用 synchronized 关键字申请锁，然后进行操作</strong>。如果该 put 操作使得当前链表长度超过一定阈值，<strong>则将该链表转换为红黑树，从而提高寻址效率。</strong></li><li><strong>ConcurrentSkipListMap</strong>：实现了一个<strong>基于SkipList（跳表）<strong>算法的可排序的并发集合，SkipList是</strong>一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的“跳跃”链接来实现高效查找。</strong></li></ul><p>并发Set：</p><ul><li><strong>ConcurrentSkipListSet</strong>：是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</li><li><strong>CopyOnWriteArraySet</strong>：是<strong>线程安全的Set实现</strong>，它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，<strong>HashSet是通过“散列表”实现的</strong>，而<strong>CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。</strong></li></ul><p>并发List：</p><ul><li><strong>CopyOnWriteArrayList</strong>：它是 ArrayList 的线程安全的变体，<strong>其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现</strong>，<strong>允许存储 null 元素</strong>。即当对象进行写操作时，**使用了Lock锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；**若进行的读操作，则直接返回结果，操作过程中不需要进行同步。</li></ul><p>并发 Queue：</p><ul><li><strong>ConcurrentLinkedQueue</strong>：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。通常，ConcurrentLinkedQueue 的性能要好于 BlockingQueue 。</li><li><strong>BlockingQueue</strong>：与 ConcurrentLinkedQueue 的使用场景不同，BlockingQueue 的主要功能并不是在于提升高并发时的队列性能，**而在于简化多线程间的数据共享。**BlockingQueue 提供一种读写阻塞等待的机制，**即如果消费者速度较快，则 BlockingQueue 则可能被清空，此时消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。**反之，如果生产线程较快，则 BlockingQueue 可能会被装满，此时，生产线程再试图向 BlockingQueue 队列装入数据时，便会被阻塞等待。</li></ul><p>并发 Deque：</p><ul><li><strong>LinkedBlockingDeque</strong>：是<strong>一个线程安全的双端队列</strong>实现。它的内部使用<strong>链表结构</strong>，每一个节点都维护了一个前驱节点和一个后驱节点。<strong>LinkedBlockingDeque 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作</strong></li><li><strong>ConcurrentLinkedDeque</strong>：ConcurrentLinkedDeque是一种<strong>基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作</strong>。当<strong>许多线程同时访问一个公共集合时</strong>，ConcurrentLinkedDeque是一个合适的选择</li></ul><h2 id="4-Collections和Collection的区别">4.Collections和Collection的区别</h2><ul><li>Collection是<strong>Java集合框架中的一个接口</strong>，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。Collection接口有许多实现类，如List、Set和Queue等。</li><li>Collections（注意有一个s）<strong>是Java提供的一个工具类</strong>，位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。</li></ul><h2 id="5-集合遍历的方法有哪些？">5.集合遍历的方法有哪些？</h2><ul><li><strong>普通 for 循环：</strong> 可以使用带有索引的普通 for 循环来遍历 List。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>增强 for 循环（for-each循环）：</strong> 用于循环访问数组或集合中的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Iterator 迭代器：</strong> 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ListIterator 列表迭代器：</strong> ListIterator是迭代器的子类，可以双向访问列表并在迭代过程中修改元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; listIterator= list.listIterator();</span><br><span class="line"><span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> listIterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 forEach 方法：</strong> Java 8引入了 forEach 方法，可以对集合进行快速遍历。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><ul><li><strong>Stream API：</strong> Java 8的Stream API提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><h1>List</h1><h2 id="1-讲一下java里面list的几种实现，几种实现有什么不同？">1.讲一下java里面list的几种实现，几种实现有什么不同？</h2><ul><li>Vector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用<strong>对象数组</strong>来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li><li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，**Vector 在扩容时会提高 1 倍，**而 ArrayList 则是增加 <strong>50%。</strong></li><li>LinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</li></ul><blockquote><p>这几种实现具体在什么场景下应该用哪种？</p></blockquote><ul><li>Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合<strong>随机访问</strong>的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。</li><li>而 LinkedList 进行节点插入、<strong>删除却要高效得多，但是随机访问性能则要比动态数组慢。</strong></li></ul><h2 id="2-list可以一边遍历一边修改元素吗？">2.list可以一边遍历一边修改元素吗？</h2><ul><li>使用普通for循环遍历：可以在遍历过程中修改元素，只要修改的索引不超出<code>List</code>的范围即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用普通for循环遍历并修改元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list.set(i, list.get(i) * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用foreach循环遍历：一般不建议在<code>foreach</code>循环中直接修改正在遍历的<code>List</code>元素，因为<strong>这可能会导致意外的结果或<code>ConcurrentModificationException</code>异</strong>常。在<code>foreach</code>循环中修改元素可能会破坏迭代器的内部状态，因为<code>foreach</code>循环底层是基于迭代器实现的，在遍历过程中修改集合结构，会导致迭代器的预期结构和实际结构不一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用foreach循环遍历并尝试修改元素，会抛出ConcurrentModificationException异常</span></span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            list.set(list.indexOf(num), num * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代器遍历：<strong>可以使用迭代器的<code>remove</code>方法来删除元素，但如果要修改元素的值，需要通过迭代器的<code>set</code>方法来进行</strong>，而不是直接通过<code>List</code>的<code>set</code>方法，否则也可能会抛出<code>ConcurrentModificationException</code>异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTraversalAndModification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器遍历并修改元素</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 使用迭代器的set方法修改元素</span></span><br><span class="line">                iterator.set(<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于线程安全的<code>List</code>，如<code>CopyOnWriteArrayList</code>，由于其采用了写时复制的机制，**在遍历的同时可以进行修改操作，不会抛出<code>ConcurrentModificationException</code>异常，**但可能会读取到旧的数据，因为修改操作是在新的副本上进行的。</p><h2 id="3-list如何快速删除某个指定下标的元素？">3.list如何快速删除某个指定下标的元素？</h2><p><code>ArrayList</code>提供了<code>remove(int index)</code>方法来删除指定下标的元素，**该方法在删除元素后，会将后续元素向前移动，以填补被删除元素的位置。**如果删除的是列表末尾的元素，时间复杂度为 O (1)；如果删除的是列表中间的元素，时间复杂度为 O (n)，n 为列表中元素的个数，因为需要移动后续的元素。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除下标为1的元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LinkedList</code>的<code>remove(int index)</code>方法也可以用来删除指定下标的元素。**它需要先遍历到指定下标位置，然后修改链表的指针来删除元素。**时间复杂度为 O (n)，n 为要删除元素的下标。不过，如果已知要删除的元素是链表的头节点或尾节点，可以直接通过修改头指针或尾指针来实现删除，时间复杂度为 O (1)。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除下标为1的元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copyOnWriteArrayList</code>的<code>remove</code>方法同样可以删除指定下标的元素。由于<code>CopyOnWriteArrayList</code>在写操作时会创建一个新的数组，<strong>所以删除操作的时间复杂度取决于数组的复制速度，通常为 O (n)</strong>，n 为数组的长度。但在并发环境下，它的删除操作不会影响读操作，具有较好的并发性能。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListRemoveExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除下标为1的元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Arraylist和LinkedList的区别，哪个集合是线程安全的？">4.Arraylist和LinkedList的区别，哪个集合是线程安全的？</h2><p>ArrayList和LinkedList都是Java中常见的集合类，它们都实现了List接口。</p><ul><li><strong>底层数据结构不同</strong>：ArrayList使用<strong>数组</strong>实现，通过索引进行快速访问元素。LinkedList使用<strong>链表</strong>实现，通过节点之间的指针进行元素的访问和操作。</li><li><strong>插入和删除操作的效率不同</strong>：ArrayList<strong>在尾部的插入和删除操作效率较高，但在中间或开头的插入和删除操作效率较低</strong>，需要移动元素。<strong>LinkedList在任意位置的插入和删除操作效率都比较高</strong>，因为只需要调整节点之间的指针，但是LinkedList是<strong>不支持随机访问的</strong>，所以除了头结点外插入和删除的时间复杂度都是0(n)，效率也不是很高所以LinkedList基本没人用。</li><li><strong>随机访问的效率不同</strong>：ArrayList<strong>支持通过索引进行快速随机访问</strong>，时间复杂度为O(1)。LinkedList需要从头或尾开始遍历链表，时间复杂度为O(n)。</li><li><strong>空间占用</strong>：ArrayList在创建时需要<strong>分配一段连续的内存空间，因此会占用较大的空</strong>间。LinkedList每个节点只需要存储元素和指针，因此相对较小。</li><li><strong>使用场景</strong>：<strong>ArrayList适用于频繁随机访问和尾部的插入删除操作，而LinkedList适用于频繁的中间插入删除操作和不需要随机访问的场景。</strong></li><li><strong>线程安全</strong>：这两个集合<strong>都不是线程安全的</strong>，Vector是线程安全的</li></ul><h2 id="5-ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？">5.ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？</h2><p>不是线程安全的，ArrayList变成线程安全的方式有：</p><ul><li>使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用Vector类代替ArrayList，Vector是线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><h2 id="6-线程安全的-List，-CopyonWriteArraylist是如何实现线程安全的">6.线程安全的 List， CopyonWriteArraylist是如何实现线程安全的</h2><p>CopyOnWriteArrayList底层也是<strong>通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p><strong>在写入操作时，加了一把互斥锁ReentrantLock以保证线程安全。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取到当前List集合保存数据的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">//获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//将当前数组拷贝一份的同时，让其长度加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//替换引用，将数组的引用指向给新数组的地址</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到源码可以知道写入新元素时，首先<strong>会先将原来的数组拷贝一份并且让原来数组的长度+1后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置都在新数组最后一个位置后，用新数组的地址替换掉老数组的地址就能得到最新的数据了。</strong></p><p>在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。</p><p>现在我们来看读操作，读是没有加锁的，所以读是一直都能读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-为什么ArrayList不是线程安全的，具体来说是哪里不安全？">7.为什么ArrayList不是线程安全的，具体来说是哪里不安全？</h2><p>在高并发添加数据下，ArrayList会暴露三个问题;</p><ul><li>部分值为null（我们并没有add null进去）</li><li>索引越界异常</li><li>size与我们add的数量不符</li></ul><p>为了知道这三种情况是怎么发生的，ArrayList，add 增加元素的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ensureCapacityInternal()这个方法的详细代码我们可以暂时不看，它的作用就是判断如果将当前的新元素加到列表后面，列表的elementData数组的大小是否满足，如果size + 1的这个需求长度大于了elementData这个数组的长度，那么就要对这个数组进行扩容。</p><p>大体可以分为三步：</p><ul><li>判断数组需不需要扩容，如果需要的话，调用grow方法进行扩容；</li><li>将数组的size位置设置值（因为数组的下标是从0开始的）；</li><li>将当前集合的大小加1</li></ul><p>下面我们来分析三种情况都是如何产生的：</p><ul><li>部分值为null：当线程1走到了扩容那里发现当前size是9，而数组容量是10，所以不用扩容，这时候cpu让出执行权，线程2也进来了，发现size是9，而数组容量是10，所以不用扩容，这时候线程1继续执行，将数组下标索引为9的位置set值了，还没有来得及执行size++，这时候线程2也来执行了，又把数组下标索引为9的位置set了一遍，这时候两个先后进行size++，导致下标索引10的地方就为null了。</li><li>索引越界异常：线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）；</li><li>size与我们add的数量不符：这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的；</li><li></li></ul><h2 id="8-ArrayList的扩容机制说一下">8.ArrayList的扩容机制说一下</h2><p>ArrayList在添加元素时，如果当前元素个数已经达到了内部数组的容量上限，就会触发扩容操作。ArrayList的扩容操作主要包括以下几个步骤：</p><ul><li>计算新的容量：一般情况下，新的容量会扩大为原容量的1.5倍（在JDK 10之后，扩容策略做了调整），然后检查是否超过了最大容量限制。</li><li>创建新的数组：根据计算得到的新容量，创建一个新的更大的数组。</li><li>将元素复制：将原来数组中的元素逐个复制到新数组中。</li><li>更新引用：将ArrayList内部指向原数组的引用指向新数组。</li><li>完成扩容：扩容完成后，可以继续添加新元素。</li></ul><p>ArrayList的扩容操作涉及到数组的复制和内存的重新分配，所以在频繁添加大量元素时，扩容操作可能会影响性能。为了减少扩容带来的性能损耗，可以在初始化ArrayList时预分配足够大的容量，避免频繁触发扩容操作。</p><p>之所以扩容是 1.5 倍，是因为 <strong>1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新容量计算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="9-arratlist的尾插法，为什么要用换尾插法">9.arratlist的尾插法，为什么要用换尾插法</h2><p>通常推荐使用尾插法</p><p>头插法：</p><p>每次插入都需要将<strong>所有已有元素整体后移一位</strong>。</p><p>时间复杂度：<code>O(n)</code>，n 为当前元素数量。</p><p>尾插法：</p><p>直接插入到数组末尾，无需移动元素。</p><p>时间复杂度：<code>O(1)</code>（摊还），只在扩容时需要重新分配数组并拷贝数据，其他情况为常数时间。</p><p>✅ <strong>性能更高</strong>：</p><ul><li>尾插法不会频繁移动元素，尤其是数据量大时，性能差距明显。</li><li>头插法每次插入都要整体移动，效率低下。</li></ul><p>✅ <strong>减少内存拷贝开销</strong>：</p><ul><li>尾插法只在扩容时才整体拷贝数组。</li><li>头插法<strong>每次插入都在触发拷贝</strong>（位置偏移），浪费 CPU 时间和内存带宽。</li></ul><p>✅ <strong>符合 <code>ArrayList</code> 的设计特点</strong>：</p><ul><li><code>ArrayList</code> 本质是一个<strong>动态数组</strong>，不适合频繁从头部插入或删除。</li></ul><h1>MAP</h1><h2 id="1-hashmap的key可以重复吗？如果不能重复说出他的原因。">1.hashmap的key可以重复吗？如果不能重复说出他的原因。</h2><p>HashMap的**key不允许重复，**当你尝试使用已存在的键插入新值时，<strong>会覆盖原有的值</strong>。</p><p>HashMap基于哈希表实现，每个键（key）通过哈希函数计算出一个唯一的哈希值，用于确定存储位置。</p><p><code>HashMap</code> 通过 <code>hashCode()</code> 计算键的哈希值，决定其在数组中的位置，如果两个不同的键产生相同哈希值（哈希冲突），则通过 <code>equals()</code> 方法进一步比较键的内容：</p><ul><li><strong>若</strong> <code>equals()</code> <strong>返回</strong> <code>true</code>：视为同一键，新值覆盖旧值。</li><li><strong>若</strong> <code>equals()</code> <strong>返回</strong> <code>false</code>：视为不同键，通过链表或红黑树存储</li></ul><p>解决hash冲突的方法是<strong>链地址法</strong>，链表超过 8 转红黑树</p><p>为什么不能重复的原因：</p><ul><li><strong>哈希表的基本语义</strong>：哈希表通过键快速定位值，若键重复会导致语义混乱。</li><li><strong>数据一致性</strong>：避免同一键对应多个值，确保数据的确定性。</li><li><strong>业务需求</strong>：大多数场景下，键作为唯一标识（如用户 ID、订单号），不允许重复。</li></ul><h2 id="2-如何对map进行快速遍历？">2.如何对map进行快速遍历？</h2><ul><li>使用for-each循环和entrySet()方法：这是一种较为常见和简洁的遍历方式，它可以同时获取<code>Map</code>中的键和值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用for-each循环和entrySet()遍历Map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用for-each循环和keySet()方法：如果只需要遍历<code>Map</code>中的键，可以使用<code>keySet()</code>方法，这种方式相对简单，性能也较好。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用for-each循环和keySet()遍历Map的键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用迭代器：通过获取Map的entrySet()或keySet()的迭代器，也可以实现对Map的遍历，这种方式在需要<strong>删除元素</strong>等操作时比较有用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器遍历Map</span></span><br><span class="line">        Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 Lambda 表达式和forEach()方法：在 Java 8 及以上版本中，可以使用 Lambda 表达式和<code>forEach()</code>方法来遍历<code>Map</code>，这种方式更加简洁和函数式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式和forEach()方法遍历Map</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Stream API：Java 8 引入的<code>Stream API</code>也可以用于遍历<code>Map</code>，可以将<code>Map</code>转换为流，然后进行各种操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Stream API遍历Map</span></span><br><span class="line">        map.entrySet().stream()</span><br><span class="line">          .forEach(entry -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还可以进行其他操作，如过滤、映射等</span></span><br><span class="line">        Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()</span><br><span class="line">                                            .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">                                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">        System.out.println(filteredMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-HashMap实现原理介绍一下？">3.HashMap实现原理介绍一下？</h2><p>在 JDK 1.7 版本之前， HashMap 数据结构是<strong>数组和链表</strong>，HashMap通过哈希算法将元素的键（Key）映射到数组中的<strong>槽位（Bucket）</strong>。<strong>如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，<strong>因为链表的</strong>查询时间是O(n)</strong>，所以冲突很严重，一个索引上的链表非常长，效率就很低了。</p><p><img src="https://cdn.xiaolincoding.com//picgo/1719565480532-57a14329-c36b-4514-8e7d-2f2f1df88a82.webp" alt=""></p><p>所以在 <strong>JDK 1.8</strong> 版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用<strong>红黑树</strong>，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，<strong>但是在数量较少时，即数量小于6时，会将红黑树转换回链表。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1719565481289-0c2164f4-f755-46e3-bb39-b5f28621bb6b.webp" alt=""></p><h2 id="4-了解的哈希冲突解决方法有哪些？">4.了解的哈希冲突解决方法有哪些？</h2><ul><li><p>链接法：使用链表或**其他数据结构（红黑树）**来存储冲突的键值对，将它们链接在同一个哈希桶中。</p><p>hashmap就用的这个方法</p></li><li><p>开放寻址法：在<strong>哈希表中找到另一个可用的位置来存储冲突的键值对</strong>，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。</p><p>Redis 的 Hash 字典底层用的是 <strong>开放寻址 + rehash + 平滑扩容</strong></p></li><li><p>再哈希法（Rehashing）：当发生冲突时，<strong>使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</strong></p></li></ul><p><strong>一些嵌入式设备中的 Hash 表实现</strong>，或者一些 <strong>空间敏感的数据结构库</strong></p><ul><li>哈希桶扩容：当哈希冲突过多时，<strong>可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。</strong></li></ul><p>Java HashMap 扩容，Redis 渐进式 rehash</p><h2 id="5-HashMap是线程安全的吗？">5.HashMap是线程安全的吗？</h2><p>hashmap不是线程安全的，hashmap在多线程会存在下面的问题：</p><ul><li>JDK 1.7 HashMap 采用数组 + 链表的数据结构，多线程背景下，<strong>在数组扩容的时候，存在 Entry 链死循环和数据丢失问题。</strong></li><li>JDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。<strong>但是多线程背景下，put 方法存在数据覆盖的问题。</strong></li></ul><p>如果要保证线程安全，可以通过这些方法来保证：</p><ul><li>多线程环境可以使用<strong>Collections.synchronizedMap</strong>同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</li><li><strong>ConcurrentHashmap</strong>在JDK1.7和1.8的版本改动比较大，<strong>1.7使用Segment+HashEntry分段锁</strong>的方式实现，1.8则抛弃了Segment，改为使用<strong>CAS+synchronized+Node</strong>实现，同样也加入了红黑树，避免链表过长导致性能的问题。</li></ul><h2 id="6-hashmap的put过程介绍一下">6. hashmap的put过程介绍一下</h2><p>HashMap HashMap的put()方法用于向HashMap中添加键值对，当调用HashMap的put()方法时，会按照以下详细流程执行（JDK8 1.8版本）：</p><blockquote><p>第一步：根据要添加的键的哈希码计算在数组中的位置（索引）。</p></blockquote><blockquote><p>第二步：检查该位置是否为空（即没有键值对存在）</p></blockquote><ul><li>如果为空，则直接在该位置<strong>创建一个新的Entry对象</strong>来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。<strong>将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。</strong></li></ul><blockquote><p>第三步：如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？</p></blockquote><ul><li><strong>如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。</strong></li></ul><blockquote><p>第四步：如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键：</p></blockquote><p>如果键值对集合是链表结构，<strong>从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。</strong></p><ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，<strong>则将新的键值对添加到链表的头部。</strong></li></ul><p>如果键值对集合是红黑树结构，在红黑树中使用<strong>哈希码和equals()方法</strong>进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，<strong>直到找到相同的键或达到红黑树末尾。</strong></p><ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，<strong>则将新的键值对添加到红黑树中。</strong></li></ul><blockquote><p>第五步：检查链表长度是否达到阈值（默认为8）：</p></blockquote><ul><li>如果<strong>链表长度超过阈值，且HashMap的数组长度大于等于64</strong>，则会将链表转换为红黑树，以提高查询效率。</li></ul><blockquote><p>第六步：检查负载因子是否超过阈值（默认为0.75）：</p></blockquote><ul><li><strong>如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作</strong>。</li></ul><blockquote><p>第七步：扩容操作：</p></blockquote><ul><li>创建一个<strong>新的两倍大小</strong>的数组。</li><li>将旧数组中的键值对<strong>重新计算哈希码</strong>并分配到新数组中的位置。</li><li>更新HashMap的数组引用和阈值参数。</li></ul><blockquote><p>第八步：完成添加操作。</p></blockquote><p>此外，HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。</p><h2 id="7-HashMap的put-key-val-和get-key-过程">7.HashMap的put(key,val)和get(key)过程</h2><ul><li>存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash<strong>从而得到bucket位</strong>置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(<strong>超过Load Facotr则resize为原来的2倍</strong>)。</li><li>获取对象时，我们将K传给get，它调用hashCode计算hash从而得到<strong>bucke</strong>t位置，并进一步调<strong>用equals()方法确定键值对</strong>。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</li></ul><h2 id="8-hashmap-调用get方法一定安全吗？">8.hashmap 调用get方法一定安全吗？</h2><p>不是，调用 get 方法有几点需要注意的地方：</p><ul><li><strong>空指针异常（NullPointerException）</strong>：如果你尝试用 <code>null</code> 作为键调用 <code>get</code> 方法，<strong>而 <code>HashMap</code> 没有被初始化（即为 <code>null</code>）</strong>，那么会抛出空指针异常。不过，如果 <code>HashMap</code> 已经初始化，使用 <code>null</code> 作为键是允许的，因为 <code>HashMap</code> 支持 <code>null</code> 键。</li><li><strong>线程安全</strong>：<code>HashMap</code> 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 <code>HashMap</code> 进行读写操作可能会导致不可预测的行为。例如，**在一个线程中调用 <code>get</code> 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 <code>ConcurrentModificationException</code>。**如果需要在多线程环境中使用类似 <code>HashMap</code> 的数据结构，可以考虑使用 <code>ConcurrentHashMap</code>。</li></ul><h2 id="9-HashMap一般用什么做Key？为啥String适合做Key呢？">9.HashMap一般用什么做Key？为啥String适合做Key呢？</h2><p>用 string 做 key，<strong>因为 String对象是不可变的</strong>，一旦创建就不能被修改，这确保了Key的稳定性。如果Key是可变的，**可能会导致hashCode和equals方法的不一致，**进而影响HashMap的正确性。</p><h2 id="10-为什么HashMap要用红黑树而不是平衡二叉树？">10.为什么HashMap要用红黑树而不是平衡二叉树？</h2><ul><li>平衡二叉树追求的是一种 <strong>“完全平衡”</strong> 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，<strong>导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则</strong>，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li><li>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因。</li></ul><h2 id="11-hashmap-key可以为null吗？">11.hashmap key可以为null吗？</h2><p>可以为 null。但是需要<strong>初始化</strong></p><ul><li>hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1720685862193-66a32b79-ddf0-46d5-87df-d2fc2b3d87cb.png" alt="img"></p><ul><li>hashMap虽然支持key和value为null，<strong>但是null作为key只能有一个</strong>，null作为value可以有多个；</li><li>因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个</li></ul><h2 id="12-重写HashMap的equal和hashcode方法需要注意什么？">12.重写HashMap的equal和hashcode方法需要注意什么？</h2><p>HashMap使用Key对象的<strong>hashCode()和equals方法去决定key-value对的索引</strong>。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，<strong>两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</strong></p><p>同样的，<strong>所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复</strong>，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p><ul><li>如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。</li><li>如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</li></ul><h2 id="13-重写HashMap的equal方法不当会出现什么问题？">13.重写HashMap的equal方法不当会出现什么问题？</h2><p>HashMap在比较元素时，<strong>会先通过hashCode进行比较，相同的情况下再通过equals进行比较。</strong></p><p>所以 equals相等的两个对象，hashCode一定相等。**hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）**散列冲突是指：两个不同的对象（或值）经过哈希函数计算后，得到相同的哈希值</p><p><strong>重写了equals方法，不重写hashCode方法时</strong>，可能会出现equals方法返回为true，而hashCode方法却返回false，<strong>这样的一个后果会导致在hashmap等类中存储多个一模一样的对象，导致出现覆盖存储的数据的问题，这与hashmap只能有唯一的key的规范不符合。</strong></p><h2 id="14-列举HashMap在多线程下可能会出现的问题？">14.列举HashMap在多线程下可能会出现的问题？</h2><ul><li>JDK1.7中的 HashMap 使用<strong>头插法</strong>插入元素，在多线程的环境下，<strong>扩容的时候有可能导致环形链表的出现，形成死循环。<strong>因此，JDK1.8使用</strong>尾插法</strong>插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li><li><strong>多线程同时执行 put 操作</strong>，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li></ul><h2 id="15-HashMap的扩容机制介绍一下">15.HashMap的扩容机制介绍一下</h2><p>hashMap默认的<strong>负载因子是0.75</strong>，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容分为两个步骤：</p><ul><li><strong>第1步</strong>是对<strong>哈希表长度的扩展（2倍）</strong></li><li><strong>第2步</strong>是将旧哈希表中的数据放到新的哈希表中。</li></ul><p>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</strong></p><p>如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>。可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p><p>这个设计确实非常的巧妙，<strong>既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了</strong></p><h2 id="16-HashMap的大小为什么是2的n次方大小呢？">16.HashMap的大小为什么是2的n次方大小呢？</h2><p>在 JDK1.7 中，HashMap **整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。**这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p><p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。<strong>由于扩容数组的长度是 2 倍关系</strong>，所以对于假设初始 tableSize = 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），<strong>在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。</strong></p><p>之所以能通过这种“与运算“来重新分配索引，<strong>是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，<strong>所以扩容的过程就能</strong>把之前哈希冲突的元素再随机分布到不同的索引中去。</strong></p><h2 id="17-往hashmap存20个元素，会扩容几次？">17.往hashmap存20个元素，会扩容几次？</h2><p>当插入 20 个元素时，HashMap 的扩容过程如下：</p><p><strong>初始容量</strong>：16</p><ul><li>插入第 1 到第 12 个元素时，不需要扩容。</li><li>插入第 13 个元素时，达到负载因子限制，<strong>需要扩容。此时，HashMap 的容量从 16 扩容到 32。</strong></li></ul><p><strong>扩容后的容量</strong>：32</p><ul><li>插入第 14 到第 24 个元素时，不需要扩容。</li></ul><p>因此，总共会进行<strong>一次扩容</strong>。</p><h2 id="18-说说hashmap的负载因子">18.说说hashmap的负载因子</h2><p>HashMap 负载因子 loadFactor 的默认值是 0.75，当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。</p><p>默认负载因子为 0.75，是因为它<strong>提供了空间和时间复杂度之间的良好平衡</strong>。</p><p><strong>负载因子太低会导致大量的空桶浪费空间</strong>，<strong>负载因子太高会导致大量的碰撞</strong>，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。</p><h2 id="19-Hashmap和Hashtable有什么不一样的？Hashmap一般怎么用？">19.Hashmap和Hashtable有什么不一样的？Hashmap一般怎么用？</h2><ul><li><strong>HashMap线程不安全</strong>，**效率高一点，可以存储null的key和value，**null的key只能有一个，null的value可以有多个。<strong>默认初始容量为16</strong>，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li><strong>HashTable线程安全</strong>，<strong>效率低一点，其内部方法基本都经过synchronized修饰</strong>，<strong>不可以有null的key和value</strong>。<strong>默认初始容量为11</strong>，<strong>每次扩容变为原来的2n+1</strong>。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li><li><strong>怎么用</strong>：HashMap主要用来存储键值对，可以调用put方法向其中加入元素，调用get方法获取某个键对应的值，也可以通过containsKey方法查看某个键是否存在等</li></ul><h2 id="20-ConcurrentHashMap怎么实现的？">20.ConcurrentHashMap怎么实现的？</h2><blockquote><p>JDK 1.7 ConcurrentHashMap</p></blockquote><p>在 JDK 1.7 中它使用的是<strong>数组加链表的形式</strong>实现的，而数组又分为：<strong>大数组 Segment 和小数组 HashEntry</strong>。 Segment 是一种<strong>可重入锁</strong>（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；<strong>HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。</strong></p><p><img src="https://cdn.xiaolincoding.com//picgo/1721807523151-41ad316a-6264-48e8-9704-5b362bc0083c.webp" alt="img"></p><p>JDK 1.7 ConcurrentHashMap <strong>分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</strong></p><blockquote><p>JDK 1.8 ConcurrentHashMap</p></blockquote><p>在 JDK 1.7 中，ConcurrentHashMap 虽然是线程安全的，<strong>但因为它的底层实现是数组 + 链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表</strong>，而 JDK 1.8 则使用了数组 + 链表/红黑树的方式优化了 ConcurrentHashMap 的实现，具体实现结构如下：</p><p><img src="https://cdn.xiaolincoding.com//picgo/1721807523128-7b1419e7-e6ba-47e6-aba0-8b29423a8ce7.webp" alt="img"></p><p>JDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap <strong>主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的</strong>。添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 CAS 来初始化</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空。<ul><li>如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；</li><li>如果根据存储的元素计算结果不为空，<strong>则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中</strong>，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul></li></ul><p>如果把上面的执行用一句话归纳的话，<strong>就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。</strong></p><p>而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。</p><h2 id="21-分段锁怎么加锁的？">21.分段锁怎么加锁的？</h2><p>在 ConcurrentHashMap 中，将整个数据结构分为**多个 Segment，每个 Segment 都类似于一个小的 HashMap，**每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。</p><p>在 ConcurrentHashMap 中，对于插入、更新、删除等操作，**需要先定位到具体的 Segment，然后再在该 Segment 上加锁，**而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。</p><h2 id="22-已经用了synchronized，为什么还要用CAS呢？">22.已经用了synchronized，为什么还要用CAS呢？</h2><p>ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，<strong>主要是根据锁竞争程度来判断的</strong>。</p><p>比如：在putVal中，如果<strong>计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值</strong>，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，<strong>那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。</strong></p><p>当<strong>发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了</strong>，因此这时候使用<strong>synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。</strong></p><h2 id="23-ConcurrentHashMap用了悲观锁还是乐观锁">23.ConcurrentHashMap用了悲观锁还是乐观锁?</h2><p>悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 <strong>CAS （乐观锁）</strong> 来初始化。</li><li>如果容器不为空，则<strong>根据存储的元素计算该位置是否为空。</strong></li><li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点；</li><li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul><h2 id="24-HashTable-底层实现原理是什么？">24.HashTable 底层实现原理是什么？</h2><ul><li>Hashtable的底层数据结构主要是<strong>数组加上链表</strong>，数组是主体，<strong>链表是解决hash冲突存在的。</strong></li><li>HashTable是线程安全的，实现方式是<strong>Hashtable的所有公共方法均采用synchronized关键字</strong>，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。</li></ul><p><img src="https://cdn.xiaolincoding.com//picgo/1719982934770-8587cb0a-6e1d-4007-9a22-bc1e41276491.png" alt=""></p><h2 id="25-HashTable线程安全是怎么实现的？">25.HashTable线程安全是怎么实现的？</h2><p>因为它的put，get做成了同步方法，保证了Hashtable的线程安全性，每个操作数据的方法都进行同步控制之后，由此带来的问题任何一个时刻<strong>只能有一个线程可以操纵Hashtable，所以其效率比较低</strong>。</p><p>Hashtable 的 put(K key, V value) 和 get(Object key) 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line"><span class="comment">// Make sure the value is not null</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line"><span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">        entry.value = value;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> addEntry(hash, key, value, index);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (V)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Hashtable是通过使用了 synchronized 关键字来保证其线程安全</strong>。</p><p>在Java中，可以使用synchronized关键字来标记一个方法或者代码块，<strong>当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</strong></p><h2 id="26-说一下HashMap和Hashtable、ConcurrentMap的区别">26.说一下HashMap和Hashtable、ConcurrentMap的区别</h2><ul><li>HashMap<strong>线程不安全</strong>，效率高一点，<strong>可以存储null的key和value，null的key只能有一个，null的value可以有多个</strong>。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li>HashTable线程安全，效率低一点，<strong>其内部方法基本都经过synchronized修饰</strong>，不可以有null的key和value。<strong>默认初始容量为11</strong>，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li><li>ConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的<strong>实现原理主要基于分段锁和CAS操作</strong>。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。<strong>在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。</strong></li></ul><h2 id="27-说说concurrenthashmap和hashmap的区别，说说copyonwritearraylist，copyonwrite会加锁吗？">27.说说concurrenthashmap和hashmap的区别，说说copyonwritearraylist，copyonwrite会加锁吗？</h2><p><strong>HashMap</strong>：<strong>非线程安全</strong>，在并发写入时可能导致数据不一致，甚至死循环（JDK 1.7 链表转成环形）。</p><p><strong>ConcurrentHashMap</strong>：<strong>线程安全</strong>，内部通过分段锁（JDK 1.7）或 <strong>CAS + synchronized（JDK 1.8）</strong> 实现并发访问控制。</p><p><code>ConcurrentHashMap</code> 用 <strong>CAS + synchronized</strong> 控制粒度细的写操作</p><p>使用 <code>Node</code> 数组 + 链表 + 红黑树结构，提升查询效率</p><p>读操作（如 <code>get</code>）<strong>无锁</strong></p><p>写操作（如 <code>put/remove</code>）使用 <code>synchronized</code> 仅锁住<strong>当前桶</strong></p><table><thead><tr><th>特性</th><th>HashMap</th><th>ConcurrentHashMap</th></tr></thead><tbody><tr><td>线程安全</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>底层结构</td><td>数组 + 链表/红黑树</td><td>相同，但加了线程安全控制</td></tr><tr><td>并发机制</td><td>无</td><td>分段锁（1.7），CAS+锁（1.8）</td></tr><tr><td>允许 null key/value</td><td>✅ 是</td><td>❌ 都不允许</td></tr></tbody></table><p>CopyOnWriteArrayList</p><ul><li>写时复制，读无锁，<strong>写操作加锁</strong></li><li>适合<strong>读多写少</strong>场景</li><li>不适合频繁写入（复制开销大</li></ul><p>是的，<strong><code>CopyOnWriteArrayList</code> 的写操作会加锁</strong>，使用的是 <strong><code>ReentrantLock</code></strong></p><blockquote><p><strong>写操作时复制数组，修改新数组，最后替换原数组引用</strong>。</p></blockquote><p>为了保证“复制 + 修改 + 替换”这整个过程是<strong>原子的、线程安全的</strong>，就必须在写操作时加锁。</p><h1>Set</h1><h2 id="1-Set集合有什么特点？如何实现key无重复的？">1.Set集合有什么特点？如何实现key无重复的？</h2><ul><li><strong>set集合特点</strong>：Set集合中的元素是<strong>唯一</strong>的，不会出现重复的元素。</li><li><strong>set实现原理</strong>：Set集合通过<strong>内部的数据结构（如哈希表、红黑树等）来实现key的无重复。<strong>当向Set集合中插入元素时，会</strong>先根据元素的hashCode值来确定元素的存储位置，然后再通过equals方法来判断是否已经存在相同的元素</strong>，如果存在则不会再次插入，保证了元素的唯一性。</li></ul><h2 id="2-有序的Set是什么？记录插入顺序的集合是什么？">2.有序的Set是什么？记录插入顺序的集合是什么？</h2><ul><li><strong>有序的 Set 是TreeSet和LinkedHashSet</strong>。<strong>TreeSet是基于红黑树实现，保证元素的自然顺序。LinkedHashSet是基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序</strong></li><li><strong>记录插入顺序的集合通常指的是LinkedHashSet</strong>，它不仅保证元素的唯一性，<strong>还可以保持元素的插入顺序</strong>。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/05/23/javase/javase3/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
