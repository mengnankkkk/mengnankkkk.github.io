<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mengnankkのblog</title>
    <link>https://blog.tokenlen.top/</link>
    
    <image>
      <url>https://blog.tokenlen.top/icon.png</url>
      <title>mengnankkのblog</title>
      <link>https://blog.tokenlen.top/</link>
    </image>
    
    <atom:link href="https://blog.tokenlen.top/rss2.xml" rel="self" type="application/rss+xml"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <description>清风拂柳影，碧水映花香。</description>
    <pubDate>Sat, 16 Aug 2025 10:06:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JUC-源码分析</title>
      <link>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/</link>
      <guid>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/</guid>
      <pubDate>Thu, 14 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;h2 id=&quot;1-从-JVM-的角度来说一下线程和进程之间的关系&quot;&gt;&lt;a href=&quot;#1-从-JVM-的角度来说一下线程和进程之间的关系&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="1-从-JVM-的角度来说一下线程和进程之间的关系"><a href="#1-从-JVM-的角度来说一下线程和进程之间的关系" class="headerlink" title="1.从 JVM 的角度来说一下线程和进程之间的关系"></a>1.从 JVM 的角度来说一下线程和进程之间的关系</h2><p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)\</strong>资源，但是每个线程有自己的*<em>程序计数器<strong>、</strong>虚拟机栈<strong> 和 </strong>本地方法栈*</em>。</p><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><p>那么？为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><ol><li>程序计数器：</li></ol><p>主要作用：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>so,程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><ol><li>虚拟机栈和本地方法栈</li></ol><p><strong>虚拟机栈：</strong> 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><p>那么我们怎么创建线程呢？</p><p>一般来说，创建线程有很多种方式，例如继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口、使用线程池、使用<code>CompletableFuture</code>类等等。</p><p>严格来说，Java 就只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><p>然后我们的run方法是直接启动线程，start方法是新建一个线程然后使用run方法来启动线程</p><h2 id="2-说一下线程的生命周期"><a href="#2-说一下线程的生命周期" class="headerlink" title="2.说一下线程的生命周期"></a>2.说一下线程的生命周期</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕</li></ul><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p><p>当线程进入 <code>synchronized</code> 方法/块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3.多线程"></a>3.多线程</h2><p>为什么我们要使用多线程？</p><p>总体上呢：</p><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p><p><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><p>底层来看：</p><p><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p><p><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p><p>单核CPU实现多线程：</p><p>单核 CPU 是支持 Java 多线程的。操作系统通过时间片轮转的方式，将 CPU 的时间分配给不同的线程。尽管单核 CPU 一次只能执行一个任务，但通过快速在多个线程之间切换，可以让用户感觉多个任务是同时进行的</p><p>操作系统主要通过两种线程调度方式来管理多线程的执行：</p><ul><li><strong>抢占式调度（Preemptive Scheduling）</strong>：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I/O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。</li><li><strong>协同式调度（Cooperative Scheduling）</strong>：线程执行完毕后，主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，容易阻塞。</li></ul><h2 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h2><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>四个条件：</p><p><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</p><p><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p><p><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p><p><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</p><p>如何判断死锁呢？</p><p>使用<code>jmap</code>、<code>jstack</code>等命令查看 JVM 线程栈和堆内存的情况。如果有死锁，<code>jstack</code> 的输出中通常会有 <code>Found one Java-level deadlock:</code>的字样，后面会跟着死锁相关的线程信息。另外，实际项目中还可以搭配使用<code>top</code>、<code>df</code>、<code>free</code>等命令查看操作系统的基本情况，出现死锁可能会导致 CPU、内存等资源消耗过高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取Java进程PID</span><br><span class="line">jps -l</span><br><span class="line"></span><br><span class="line"># 生成线程堆栈信息</span><br><span class="line">jstack &lt;pid&gt; &gt; thread_dump.txt</span><br><span class="line"></span><br><span class="line"># 实时监控（每3秒输出一次）</span><br><span class="line">while true; do jstack &lt;pid&gt;; sleep 3; done</span><br></pre></td></tr></table></figure><p>然后我们可以在程序中去检查死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDetector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">detectDeadlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="type">long</span>[] deadlockedThreads = threadBean.findDeadlockedThreads();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadInfo[] threadInfos = threadBean.getThreadInfo(deadlockedThreads);</span><br><span class="line">            <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;检测到死锁线程: &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mysql的话，我们可以去查看日志，找deadlock字段记录的，然后看他选择的哪一个事务进行了回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看最近的死锁信息</span><br><span class="line">SHOW ENGINE INNODB STATUS;</span><br><span class="line"></span><br><span class="line">-- 开启死锁日志记录</span><br><span class="line">SET GLOBAL innodb_print_all_deadlocks = ON;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何避免死锁呢？</p><p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><ol><li>按照顺序获取锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderedLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock1) &#123; <span class="comment">// 同样先获取lock1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>超时锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeoutLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">acquired1</span> <span class="operator">=</span> <span class="literal">false</span>, acquired2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acquired1 = lock1.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!acquired1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            acquired2 = lock2.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!acquired2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行转账逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acquired2) lock2.unlock();</span><br><span class="line">            <span class="keyword">if</span> (acquired1) lock1.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去给这个锁设置一个超时的时间</p><ol><li>使用并发工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Semaphore避免死锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">// 业务逻辑，同时最多2个线程执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁-amp-关键字"><a href="#锁-amp-关键字" class="headerlink" title="锁&amp;关键字"></a>锁&amp;关键字</h1><h2 id="1-Synchonized"><a href="#1-Synchonized" class="headerlink" title="1.Synchonized"></a>1.Synchonized</h2><ol><li><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。在 JDK18 中，偏向锁已经被彻底废弃</li></ol><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。对象锁的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><ol><li>monitor和对象头</li></ol><p>在HotSpot JVM中，每个Java对象都有对象头，主要包含：Markword这里记录的是锁信息的状态，GC标记，hashcode等，然后是一个Class Pointer指向Class对象的指针</p><p>Markword是根据锁的状态是变化的，根据锁的升级是进行变化的</p><p>锁的升级：</p><ul><li>无锁状态：Mark Word存储hashCode、GC年龄等，头是unused</li><li>首次进入：尝试偏向锁，Mark Word存储: 线程ID + epoch + age + 01，头是threadID:54</li><li>重入：recursions++，仍是偏向锁</li><li>如果有其他线程竞争，升级为轻量级锁，Mark Word存储: Lock Record指针 + 00，JVM在当前线程栈中创建Lock Record，markOop就是原始的markword,oop被指向的锁对象。头是ptr_to_lock_record</li><li>竞争激烈时，升级为重量级锁 ，Mark Word存储: Monitor对象指针 + 10，当升级到重量级锁时，创建Monitor对象，Mark Word指向它。头是ptr_to_monitor</li></ul><p>然后我们的线程是要去竞争锁的，首先我们会使用快速路径：尝试CAS获取锁，如果失败了就自旋等待，然后超过重试的次数的话，加入EntryList，阻塞等待。</p><p>然后我们如果阻塞了的话，这个时候需要去notify，需要从WaitSet移到EntryList，然后等待的话，需要先释放锁，然后加入等待Set，然后阻塞等待notify</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking          // 开启偏向锁（默认开启）</span><br><span class="line">-XX:BiasedLockingStartupDelay=0 // 立即启用偏向锁</span><br><span class="line">-XX:+UseHeavyMonitors          // 强制使用重量级锁（调试用）</span><br></pre></td></tr></table></figure><p>实际应用问题：</p><p>​    hashCode调用**会导致偏向锁失效</p><p>​    <strong>System.identityHashCode()</strong>会强制升级锁</p><p>​    <strong>大量短期锁竞争</strong>时，禁用偏向锁可能更好</p><p>​    Monitor对象**在锁释放后不会立即回收，可能影响GC</p><ol><li>偏向锁的撤销（好难哭）,JDK18已经废弃</li></ol><p>条件：</p><p>比如说线程1获取了偏向锁，然后线程2去尝试获取偏向锁，然后这个时候就会触发偏向撤销，升级为轻量级锁</p><p>调用Object.hashCode()或System.identityHashCode()，此时obj处于偏向锁状态，Mark Word存储线程ID等信息</p><p>调用hashcode就会立刻撤销偏向锁，因为偏向锁的Mark Word无法存储hashCode</p><p>然后调用wait方法，让obj等待了，立即撤销偏向锁，升级为重量级锁，因为wait需要Monitor对象支持</p><p>流程：</p><p>​    检测撤销条件：检查是否为偏向锁模式，在markword获取偏向的线程ID,判断撤销类型,如果是匿名偏向直接撤销，有具体偏向线程，需要更复杂的处理</p><p>​    安全点操作：在安全点执行撤销操作，</p><h2 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2.volatile"></a>2.volatile</h2><p> Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>他能保证可见性，禁止重排，但是不能保证原子性，比如i++</p><p>指令重排是编译器和 CPU 的优化手段，通过改变代码执行顺序来提升性能。然而，重排序可能会破坏多线程中的正确性。<br> 通过插入 <strong>内存屏障</strong>（Memory Barrier），<code>volatile</code> 保证了对该变量的操作的顺序不会被重排，确保了对共享变量的写操作在前，读操作在后。这种内存屏障的插入通常是 <code>StoreLoad</code> 指令，它确保写操作的数据先写入主内存，后续的读操作必须从主内存中获取最新值</p><p>插入的是StoreLoad指令，先将cpu缓存刷新到主内存之前，不会将主内存的缓存，加载到cpu中</p><p>使用场景：</p><p><strong>停止标志位</strong>：多线程间通过共享的 <code>volatile</code> 变量来通知其他线程是否停止工作。</p><p>DCL的单例模式</p><p>AQS中的state变量，用来计数</p><h2 id="3-乐悲观锁"><a href="#3-乐悲观锁" class="headerlink" title="3.乐悲观锁"></a>3.乐悲观锁</h2><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</p><p>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变</p><p>量类）。</p><h2 id="4-ReentranLock"><a href="#4-ReentranLock" class="headerlink" title="4.ReentranLock"></a>4.ReentranLock</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。<code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁</p><p> 相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说当前线程在等待获取锁的过程中，如果其他线程中断当前线程「 <code>interrupt()</code> 」，当前线程就会抛出 <code>InterruptedException</code> 异常，可以捕捉该异常进行相应处理。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来指定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li><li><strong>支持超时</strong> ：<code>ReentrantLock</code> 提供了 <code>tryLock(timeout)</code> 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li></ul><p>总结：</p><p>ReentrantLock是Java中的显式可重入互斥锁，提供灵活的线程同步功能。它支持公平和非公平模式，允许同一线程多次获取锁而不会发生死锁。其核心特性包括：可中断的锁获取（lockInterruptibly()）、超时尝试锁（tryLock()）、以及支持多个Condition条件变量。与synchronized相比，ReentrantLock需要手动管理锁的获取和释放，适用于复杂的多线程场景。</p><p>voliate修饰变量的实现</p><ul><li>当同一个线程再次请求锁时，如果它已经持有该锁，计数器会增加，以允许多次获取而不会阻塞。</li><li>ReentrantLock维护一个等待队列，当线程无法获取锁时，会被放入该队列。每当持有锁的线程释放锁时，计数器会减少，直到归零，其他线程才能获取锁。</li></ul><h2 id="5-Semaphore"><a href="#5-Semaphore" class="headerlink" title="5.Semaphore"></a>5.Semaphore</h2><p><code>Semaphore</code>(信号量)可以用来控制同时访问特定资源的线程数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始共享资源数量</span><br><span class="line">final Semaphore semaphore = new Semaphore(5);</span><br><span class="line">// 获取1个许可</span><br><span class="line">semaphore.acquire();</span><br><span class="line">// 释放1个许可</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>当初始的资源个数为 1 的时候，<code>Semaphore</code> 退化为排他锁。</p><p><code>Semaphore</code> 有两种模式：。</p><ul><li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的，默认是非公平的</li></ul><p>可以使用Redis+Lua来做限流的处理</p><p>它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><h2 id="6-CountDownLatch"><a href="#6-CountDownLatch" class="headerlink" title="6.CountDownLatch"></a>6.CountDownLatch</h2><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</p><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。当线程使用 <code>countDown()</code> 方法时,其实使用了<code>tryReleaseShared</code>方法以 CAS 的操作来减少 <code>state</code>,直至 <code>state</code> 为 0 。当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。直到<code>count</code> 个线程调用了<code>countDown()</code>使 state 值被减为 0，或者调用<code>await()</code>的线程被中断，该线程才会从阻塞中被唤醒，<code>await()</code> 方法之后的语句得到执行</p><p>比如多次处理六个没有顺序关系的文件，全都处理完之后，返回给用户</p><h2 id="7-CyclicBarrier-有什么用？"><a href="#7-CyclicBarrier-有什么用？" class="headerlink" title="7.CyclicBarrier 有什么用？"></a>7.CyclicBarrier 有什么用？</h2><p>它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。</p><p><code>CountDownLatch</code> 的实现是基于 AQS 的，而 <code>CyclicBarrier</code> 是基于 <code>ReentrantLock</code>(<code>ReentrantLock</code> 也属于 AQS 同步器)和 <code>Condition</code> 的。</p><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><p>比如我们去好几个任务完成之后，给他们综合起来</p><h2 id="8-Java中的CAS"><a href="#8-Java中的CAS" class="headerlink" title="8.Java中的CAS"></a>8.Java中的CAS</h2><p>CAS（Compare-And-Swap）是一种无锁的原子操作机制，广泛应用于Java的并发编程中。它通过比较内存中的实际值与预期值，决定是否将该值更新为新值。CAS的操作依赖于三个参数：当前值、预期值和新值。如果当前值等于预期值，则更新为新值；否则不做任何操作。CAS的优势是能够避免传统锁带来的性能开销，但也存在ABA问题，可以通过引入版本号或时间戳来解决。典型应用包括AtomicInteger等原子类的实现。</p><p>底层是Unsafe的CAS操作，是调用的操作系统的</p><p>在unsafe类里面静态方法尝试去先获取表示 <code>value</code> 字段在 <code>AtomicInteger</code> 对象中的内存偏移地址。</p><p>然后调用<code>compareAndSwapInt</code>方法去执行调用底层的 <code>cmpxchg</code> 指令</p><h2 id="9-ReentrantReadWriteLock"><a href="#9-ReentrantReadWriteLock" class="headerlink" title="9.ReentrantReadWriteLock"></a>9.ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 适用于读多写少的高并发场景，特别是在需要频繁读取但较少修改的数据同步需求。它的读锁允许多个线程并行访问，而写锁则保证写操作的独占性和数据一致性。常见的应用场景包括缓存系统、配置管理和统计数据管理等。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-线程池的处理任务的流程"><a href="#1-线程池的处理任务的流程" class="headerlink" title="1.线程池的处理任务的流程"></a>1.线程池的处理任务的流程</h2><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p><p>答案是可以的！<code>ThreadPoolExecutor</code> 提供了两个方法帮助我们在提交任务之前，完成核心线程的创建，从而实现线程池预热的效果：</p><ul><li><code>prestartCoreThread()</code>:启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；</li><li><code>prestartAllCoreThreads()</code>:启动所有的核心线程，并返回启动成功的核心线程数。</li></ul><h2 id="2-设计一个能根据任务优先级执行的线程池"><a href="#2-设计一个能根据任务优先级执行的线程池" class="headerlink" title="2.设计一个能根据任务优先级执行的线程池"></a>2.设计一个能根据任务优先级执行的线程池</h2><p>不同的线程池会选用不同的阻塞队列作为任务队列，比如<code>FixedThreadPool</code> 使用的是<code>LinkedBlockingQueue</code>（有界队列），默认构造器初始的队列长度为 <code>Integer.MAX_VALUE</code> ，由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</p><p><code>PriorityBlockingQueue</code> （优先级阻塞队列）作为任务队列（<code>ThreadPoolExecutor</code> 的构造函数有一个 <code>workQueue</code> 参数可以传入任务队列）。</p><p>要想让 <code>PriorityBlockingQueue</code> 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：</p><ol><li>提交到线程池的任务实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法来指定任务之间的优先级比较规则。</li><li>创建 <code>PriorityBlockingQueue</code> 时传入一个 <code>Comparator</code> 对象来指定任务之间的排序规则(推荐)。</li></ol><p>不过会遇见以下的问题</p><p><code>PriorityBlockingQueue</code> 是无界的，可能堆积大量的请求，从而导致 OOM。</p><p>可能会导致饥饿问题，即低优先级的任务长时间得不到执行。</p><p>由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 <code>ReentrantLock</code>），因此会降低性能。</p><p>对于 OOM 这个问题的解决比较简单粗暴，就是继承<code>PriorityBlockingQueue</code> 并重写一下 <code>offer</code> 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。</p><p>饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><h2 id="1-一个任务需要依赖另外两个任务执行完之后再执行，怎么设计"><a href="#1-一个任务需要依赖另外两个任务执行完之后再执行，怎么设计" class="headerlink" title="1.一个任务需要依赖另外两个任务执行完之后再执行，怎么设计"></a>1.一个任务需要依赖另外两个任务执行完之后再执行，怎么设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1</span></span><br><span class="line">CompletableFuture&lt;Void&gt; futureT1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T1 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// T2</span></span><br><span class="line">CompletableFuture&lt;Void&gt; futureT2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;T2 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class="line">    ThreadUtil.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用allOf()方法合并T1和T2的CompletableFuture，等待它们都完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; bothCompleted = CompletableFuture.allOf(futureT1, futureT2);</span><br><span class="line"><span class="comment">// 当T1和T2都完成后，执行T3</span></span><br><span class="line">bothCompleted.thenRunAsync(() -&gt; System.out.println(<span class="string">&quot;T3 is executing after T1 and T2 have completed.Current time：&quot;</span> + DateUtil.now()));</span><br><span class="line"><span class="comment">// 等待所有任务完成，验证效果</span></span><br><span class="line">ThreadUtil.sleep(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>通过 <code>CompletableFuture</code> 的 <code>allOf()</code> 这个静态方法来并行运行 T1 和 T2，当 T1 和 T2 都完成后，再执行 T3。</p><h2 id="2-使用-CompletableFuture，有一个任务失败，如何处理异常？"><a href="#2-使用-CompletableFuture，有一个任务失败，如何处理异常？" class="headerlink" title="2.使用 CompletableFuture，有一个任务失败，如何处理异常？"></a>2.使用 CompletableFuture，有一个任务失败，如何处理异常？</h2><p>使用 <code>CompletableFuture</code>的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。</p><p>下面是一些建议：</p><ul><li>使用 <code>whenComplete</code> 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。</li><li>使用 <code>exceptionally</code> 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。</li><li>使用 <code>handle</code> 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。</li><li>使用 <code>CompletableFuture.allOf</code> 方法可以组合多个 <code>CompletableFuture</code>，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复</li></ul><h2 id="3-在使用-CompletableFuture-的时候为什么要自定义线程池？"><a href="#3-在使用-CompletableFuture-的时候为什么要自定义线程池？" class="headerlink" title="3.在使用 CompletableFuture 的时候为什么要自定义线程池？"></a>3.在使用 CompletableFuture 的时候为什么要自定义线程池？</h2><p><code>CompletableFuture</code> 默认使用全局共享的 <code>ForkJoinPool.commonPool()</code> 作为执行器，所有未指定执行器的异步任务都会使用该线程池。这意味着应用程序、多个库或框架（如 Spring、第三方库）若都依赖 <code>CompletableFuture</code>，默认情况下它们都会共享同一个线程池。</p><p>虽然 <code>ForkJoinPool</code> 效率很高，但当同时提交大量任务时，可能会导致资源竞争和线程饥饿，进而影响系统性能。</p><p>为避免这些问题，建议为 <code>CompletableFuture</code> 提供自定义线程池，带来以下优势：</p><ul><li>隔离性：为不同任务分配独立的线程池，避免全局线程池资源争夺。</li><li>资源控制：根据任务特性调整线程池大小和队列类型，优化性能表现。</li><li>异常处理：通过自定义 <code>ThreadFactory</code> 更好地处理线程中的异常情况。</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/juc3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mysql底层分析</title>
      <link>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/</link>
      <guid>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/</guid>
      <pubDate>Thu, 14 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;1-索引的分类&quot;&gt;&lt;a href=&quot;#1-索引的分类&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="1-索引的分类"><a href="#1-索引的分类" class="headerlink" title="1.索引的分类"></a>1.索引的分类</h2><p>从数据结构上分类，B+树索引，hash索引，倒排索引，R树索引</p><p>从InoDB的B+树的索引分类，分为聚簇索引和非聚簇索引</p><p>从索引的性质进行分类，普通索引，主键索引，唯一索引，联合索引，全文索引，空间索引</p><h1 id="锁-amp-隔离级别"><a href="#锁-amp-隔离级别" class="headerlink" title="锁&amp;隔离级别"></a>锁&amp;隔离级别</h1><h2 id="1-表级锁与行级锁的区别？"><a href="#1-表级锁与行级锁的区别？" class="headerlink" title="1.表级锁与行级锁的区别？"></a>1.表级锁与行级锁的区别？</h2><p>MySQL 常见的两种锁是表级锁和行级锁。</p><p>表级锁锁定整个表，所有对该表的读写操作都会被阻塞，适用于低并发场景；而行级锁锁定特定行，允许其他行的操作并发进行，适用于高并发场景。</p><p> 表级锁粒度大，加锁快、开销小，但并发性能差，典型代表是 MyISAM。<br> 行级锁粒度小，允许多个事务并发操作不同的行，并发性高，但锁的开销大，容易出现死锁，典型代表是 InnoDB。<br> 因此实际使用时，MyISAM 适合读多写少的分析场景，而 InnoDB 的行级锁更适合高并发的 OLTP 系统。</p><h2 id="2-MySQL-默认隔离级别？为何选择它？"><a href="#2-MySQL-默认隔离级别？为何选择它？" class="headerlink" title="2.MySQL 默认隔离级别？为何选择它？"></a>2.MySQL 默认隔离级别？为何选择它？</h2><p>MySQL 的默认隔离级别是可重复读（REPEATABLE READ）。选择这一隔离级别是因为它能够提供较高的数据一致性，防止不可重复读，并通过 MVCC（多版本并发控制）技术支持高效的并发性能。同时，通过间隙锁（Gap Lock）解决了幻读问题，使得在一个事务中多次读取结果一致，尽管它并不能完全消除幻读的可能性。</p><p>如果选择 <strong>Serializable</strong>，虽然隔离性最强，但会强制事务串行化执行，性能开销过大。</p><p>如果选择 <strong>Read Committed</strong>，虽然性能更高，但会出现不可重复读，影响数据一致性。但是某些大厂的事务隔离级别就是RC，数据的一致性可以由MQ等组件来完成，为了提高并发量</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1-MySQL-的-buffer-pool-与缓存命中率如何监控？"><a href="#1-MySQL-的-buffer-pool-与缓存命中率如何监控？" class="headerlink" title="1.MySQL 的 buffer pool 与缓存命中率如何监控？"></a>1.MySQL 的 buffer pool 与缓存命中率如何监控？</h2><p>MySQL 的 buffer pool 是 InnoDB 存储引擎中用于缓存数据和索引的内存区域。监控 buffer pool 和缓存命中率可以通过 <code>SHOW ENGINE INNODB STATUS</code> 查看状态变量，关键指标包括 buffer pool 的总大小、当前缓存的数据页数量等。或者是直接SHOW GLOBAL STATUS，SHOW GLOBAL STATUS LIKE ‘Innodb_buffer_pool_read%’;</p><p>视图更加友好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看 Buffer Pool 状态的摘要信息</span><br><span class="line">SELECT * FROM sys.innodb_buffer_stats_by_schema;</span><br><span class="line"></span><br><span class="line">-- 按表查看 Buffer Pool 的使用情况，用于定位热点数据</span><br><span class="line">SELECT * FROM sys.innodb_buffer_stats_by_table ORDER BY pages DESC LIMIT 10;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缓存命中率的计算方法是：命中率 = (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) × 100%。使用性能监控工具如 MySQL Enterprise Monitor 或 Percona Monitoring and Management （<strong>PMM</strong>）可以实时监控这些指标，从而优化数据库性能。</p><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="1-Order-by是怎么实现的"><a href="#1-Order-by是怎么实现的" class="headerlink" title="1.Order by是怎么实现的"></a>1.Order by是怎么实现的</h2><p>在 MySQL 中，<code>ORDER BY</code> 的实现主要有三种方式：</p><ul><li><p><strong>索引有序扫描</strong>：如果 <code>ORDER BY</code> 字段能和索引顺序匹配，直接按索引返回，最优。</p></li><li><p><strong>Filesort 文件排序</strong>：无法利用索引时，MySQL 会将结果放入 sort buffer 排序，小数据在内存，大数据写磁盘；它有单路和双路两种实现方式。</p><ul><li>双路：扫描符合条件的行 → 将排序字段和主键 ID 放到 sort buffer → 排序 → 再根据主键 ID 回表取数据。需要两次数据访问，性能差。</li><li>单路：直接将排序字段和要返回的所有列一起放入 sort buffer → 排序 → 直接返回。回表减少了，需要更大内存，sort buffer 容量不够时会写磁盘临时文件。</li></ul></li><li><strong>优先队列排序</strong>：当 <code>ORDER BY</code> 搭配 <code>LIMIT N</code> 时，可能只维护一个 N 大小的堆，提高效率。结果集很大，但只取前 N 条。</li></ul><p>调优：</p><p>尽量让 <code>ORDER BY</code> 和索引顺序匹配，避免 filesort。</p><p>如果必须 filesort，调大 <code>sort_buffer_size</code>、<code>tmp_table_size</code>，减少磁盘落盘。</p><p>避免 <code>SELECT *</code>，减少 sort buffer 内存占用。</p><p>大数据排序时考虑加索引或改写 SQL。</p><h2 id="2-MySQL-如何存储-IP-地址？"><a href="#2-MySQL-如何存储-IP-地址？" class="headerlink" title="2.MySQL 如何存储 IP 地址？"></a>2.MySQL 如何存储 IP 地址？</h2><p>因为我们的IP地址是有两种的IPV4 IPV6</p><ul><li><p><strong>VARCHAR</strong>：直接存 <code>&#39;192.168.0.1&#39;</code>，简单直观，但存储和查询效率差。</p></li><li><p><strong>UNSIGNED INT</strong>：用 <code>INET_ATON/INET_NTOA</code> 把 IPv4 转整数（4B），空间小、查询快，但只支持 IPv4。使用Mysql提供的两个函数，</p></li><li><pre><code>INET_ATON(&#39;192.168.0.1&#39;)` → `3232235521INET_NTOA(3232235521)` → `&#39;192.168.0.1&#39;</code></pre></li><li><p><strong>VARBINARY(16)</strong>：用 <code>INET6_ATON/INET6_NTOA</code> 存二进制，既支持 IPv4 又支持 IPv6（推荐做法）。使用函数</p></li><li><p><code>INET6_ATON(&#39;2001:db8::1&#39;)</code> → 二进制（16B）</p><p><code>INET6_NTOA(binary_value)</code> → 字符串 IP</p></li></ul><p>如果只考虑 IPv4，<code>INT</code> 最优；如果要兼容 IPv6，推荐 <code>VARBINARY(16)</code>。</p><h2 id="3-MySQL-一行记录是怎么存储的？"><a href="#3-MySQL-一行记录是怎么存储的？" class="headerlink" title="3.MySQL 一行记录是怎么存储的？"></a>3.MySQL 一行记录是怎么存储的？</h2><p><strong>InnoDB</strong> 是最常用的存储引擎，数据以 <strong>页（Page，16KB）</strong> 为最小单位。</p><p>一个页中包含多个行记录。页内部有 <strong>页头、页目录、行数据</strong> 等。</p><p>一行记录的结构主要包括：行头信息（删除标记、指针）、事务信息（事务 ID、回滚指针）、NULL 标记位、变长字段长度列表以及实际字段值。<br> 如果某行太大（例如包含 TEXT/BLOB），就会发生行溢出，行内只存前 768 字节和指针，其余内容存放在溢出页。<br> InnoDB 还支持 Compact、Dynamic、Compressed 等多种行格式，Compact 是默认的。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="1-Mysql长事务可能带来哪些问题？"><a href="#1-Mysql长事务可能带来哪些问题？" class="headerlink" title="1.Mysql长事务可能带来哪些问题？"></a>1.Mysql长事务可能带来哪些问题？</h2><p>首先，它会长时间持有锁，阻塞其他事务，影响并发性能；<br> 其次，InnoDB 的 MVCC 机制需要依赖 undo log 保存历史版本，长事务不提交会导致 undo log 膨胀，版本链变长，阻止 purge 线程清理，造成表膨胀和性能下降；<br> 同时也会增加死锁概率和主从延迟。<br> 因此在开发中我们要控制事务范围，及时提交，并通过监控和超时机制避免长事务。</p><p>比如：</p><ul><li><strong>及时提交事务</strong>：避免在事务中执行不必要的逻辑，比如用户交互、网络请求。</li><li><strong>控制事务大小</strong>：大批量操作要拆分成多个小事务。</li><li>SELECT * FROM information_schema.INNODB_TRX \G;监控长事务</li><li><strong>设置超时</strong>：<ul><li><code>innodb_lock_wait_timeout</code>：控制锁等待时间。</li><li><code>wait_timeout</code> / <code>interactive_timeout</code>：控制会话空闲超时。</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/sql/">sql</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/mysql/">mysql</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/mysql/mysql1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经优化回答</title>
      <link>https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/</link>
      <guid>https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/</guid>
      <pubDate>Wed, 13 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;Spring框架&quot;&gt;&lt;a href=&quot;#Spring框架&quot; class=&quot;headerlink&quot; title=&quot;Spring框架&quot;&gt;&lt;/a&gt;Spring框架&lt;/h1&gt;&lt;h2 id=&quot;1-SpringBoot的配置加载优先级&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="1-SpringBoot的配置加载优先级"><a href="#1-SpringBoot的配置加载优先级" class="headerlink" title="1.SpringBoot的配置加载优先级"></a>1.SpringBoot的配置加载优先级</h2><p>首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：</p><ol><li><p>先是<strong>命令行参数</strong>（<code>--server.port=9000</code> 或 <code>java -jar app.jar --spring.config.location=...</code>）</p></li><li><p>然后是我们的系统的环境变量和JVM系统属性，比如设置端口为8080，比如我们在这里设置API的KEY</p></li><li><p>然后<strong><code>RandomValuePropertySource</code></strong>（<code>random.*</code> 占位符，用于生成随机数/字符串，可在配置中引用）</p></li><li><p>接着是<strong>外部配置文件</strong>（properties / yml）</p><ul><li><p>JAR 包外部的 <code>./config/</code></p></li><li><p>JAR 包外部的 <code>./</code></p></li><li><p>JAR 包内部的 <code>classpath:/config/</code></p></li><li><p>JAR 包内部的 <code>classpath:/</code></p></li></ul></li><li><p>接着是我们@PropertySource注解指定的配置</p></li><li><p>最后是我们Springboot默认的配置</p></li></ol><p>然后在配置文件中，properties的配置大于yml，因为springboot是按加载顺序来的，后加载的properties把yml的值给覆盖了</p><p>对于外部配置文件，查找路径的优先级为：</p><ol><li><code>./config/</code>（当前目录下的config目录）</li><li><code>./</code>（当前目录）</li><li><code>classpath:/config/</code></li><li><code>classpath:/</code></li></ol><p>实际应用:</p><p><strong>基础配置</strong>：放在 <code>classpath:/application.yml</code></p><p><strong>环境特定配置</strong>：使用 <code>application-&#123;profile&#125;.yml</code>（如 <code>application-prod.yml</code>），通过 <code>--spring.profiles.active=prod</code> 激活</p><p><strong>敏感信息</strong>：放在环境变量或外部化配置文件（避免入库）</p><p><strong>临时调试/测试</strong>：使用命令行参数临时覆盖</p><p><strong>多环境冲突处理</strong>：利用 profile 合并特性，公共配置放在 <code>application.yml</code>，环境差异放在对应 profile 文件</p><h2 id="2-Springboot是如何解决跨域问题的？"><a href="#2-Springboot是如何解决跨域问题的？" class="headerlink" title="2.Springboot是如何解决跨域问题的？"></a>2.Springboot是如何解决跨域问题的？</h2><p>基本都是基于CORS（跨域资源共享）通过设置响应头（如 <code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>）告诉浏览器允许访问。</p><p>对于复杂跨域请求（非 GET/POST/HEAD 或自定义头），浏览器会先发 <strong>OPTIONS 预检请求</strong>。</p><ol><li>局部注解，用@CrossOrigin标记单个接口，秒开跨域权限，适合快速测试。简单高效，优先级高于全局配置</li><li>全局配置，使用WebMvcConfigurer接口，统一设定允许的域名，请求方法，头信息。统一配置，但是不适合动态的控制</li><li>用CorsFilter手动处理跨域逻辑处理，适合需要动态校验权限等特殊场景，比如不同权限开放不同接口，在过滤器中动态判断，但是实现成本较高</li><li>在微服务架构中，也可以在<strong>网关层</strong>（如 Spring Cloud Gateway、Nginx）统一处理跨域，减少业务服务配置。</li></ol><p>优先级：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin` &gt; `WebMvcConfigurer` &gt; `CorsFilter</span><br></pre></td></tr></table></figure><h2 id="3-Spring-解决循环依赖"><a href="#3-Spring-解决循环依赖" class="headerlink" title="3.Spring 解决循环依赖"></a>3.<strong>Spring 解决循环依赖</strong></h2><p><strong>既然Spring能解决循环依赖，那为什么我们还经常听说‘构造器注入无法解决循环依赖’？三级缓存对构造器注入为什么无效？</strong></p><p>您问到了Spring循环依赖解决方案的一个核心<strong>前提</strong>。三级缓存之所以能工作，其根本在于它将<strong>Bean的实例化（Instantiation）\</strong>和*<em>属性填充（Population）*<em>这两个阶段**分离开来</em></em>了。</p><ul><li><strong>第一步：实例化</strong>。Spring首先通过<strong>无参构造函数</strong>创建了Bean A的一个“空壳”实例。这个实例已经有了自己的内存地址。</li><li><strong>第二步：暴露早期引用</strong>。紧接着，Spring立即将这个“空壳”实例的工厂（ObjectFactory）放入三级缓存，从而<strong>提前暴露</strong>了A的引用。</li><li><p><strong>第三步：属性填充</strong>。然后Spring才开始尝试为A注入属性，此时发现需要B，就去创建B。当B需要A时，可以从三级缓存中获取到A的早期引用，从而打破循环。</p><p><strong>构造器注入的工作流程</strong>:</p></li><li><p>对于构造器注入，<strong>Bean的实例化和属性填充这两个阶段是合并在一起的，是原子性的</strong>。</p></li><li>当Spring尝试创建Bean A时，它必须调用A的构造函数。而A的构造函数需要一个Bean B的实例作为参数。</li><li>为了满足这个参数，Spring必须先去创建Bean B。</li><li>而当Spring尝试创建Bean B时，又发现B的构造函数需要一个Bean A的实例作为参数。</li><li>此时，<strong>Bean A的实例根本还没有被创建出来</strong>（它还卡在等待B的阶段），内存中不存在任何A的“空壳”实例，三级缓存中自然也就不可能有任何关于A的引用。</li><li>这就形成了一个无法解开的死结：A的创建依赖B的创建，B的创建又依赖A的创建。因此，Spring会直接抛出<code>BeanCurrentlyInCreationException</code>。</li></ul><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1-线程池常见的坑"><a href="#1-线程池常见的坑" class="headerlink" title="1.线程池常见的坑"></a>1.线程池常见的坑</h2><ol><li><p>线程池的参数配置：核心线程的数量，和最大线程的数量是业务场景来的，CPU密集型，比如数据的计算业务，就是CPU的数量+1。</p><p>IO密集型根据业务压测的值来决定的，最佳线程数=（（线程等待时间+线程CPU时间）/线程CPU时间）*CPU数量</p></li></ol><p>比如，我们服务器CPU核数为8核，任务线程CPU耗时20ms,线程等待等等耗时80ms，那么最佳线程数=（80+20）/20*8=40线程，那我们最大线程数就是80个</p><ol><li>共享线程池，次要的逻辑拖垮主要的逻辑。避免所有的业务都共享一个线程池，防止一个次要的业务一直在执行业务，占用线程池。而主要的业务并没有足够的线程数来执行，影响到了我们主要的服务。这样做是不合理的。我们应该要做线程池的隔离，使用Future.get方法的时候，使用带超时时间的，因为他是阻塞的，防止被其他抢占。</li><li>@Async是Spring中一个注解，他不是线程池，他其实是SimpleAsyncTaskExecutor，不会复用线程，适合执行大量短时间的线程。还是尽量自己定义一个异步的线程池，然后使用@EnableAsync来注册</li><li>使用线程池的时候，不使用threadfactory参数来自定义命名，这样导致后期不好排查问题和回溯问题</li><li>使用submit提交任务，不会把异常直接抛出来。最好我们在submit之中进行try-catch进行捕获，或者是在 <code>Future.get()</code> 时捕获并记录异常。</li><li>线程池使用完之后，记得关闭，防止内存泄漏的问题。最好线程池设计成单例的模式。长期运行的全局线程池（如 Spring 管理的）不需手动关闭，临时线程池需在 finally 中调用 <code>shutdown()</code>。</li><li><p>线程池不要和事务一起使用，使用@Transtation的时候，依赖于当前线程的线程上下文，而线程池的线程和当前事务的线程不是一个线程，事务的上下文不会传递，导致线程池中的业务代码不在事务中执行，事务就失效了。我们可以将事务放在线程池之外进行，这是最好的方法，或者是使用支持事务上下文传递的机制（如 <code>TransactionAwareDataSourceProxy</code>、消息队列保证一致性）</p></li><li><p>我们要负责监控线程池状态，比如当前活跃的线程池的数量，队列的长度，拒绝的次数</p></li><li>要配置合理的拒绝策略，比如一个需要快速获取结果的线程，就需要胚子和callerrunpolicy，这样的话，谁提交谁执行，回退给调用的线程。</li></ol><h2 id="2-AQS的大局解析"><a href="#2-AQS的大局解析" class="headerlink" title="2.AQS的大局解析"></a>2.AQS的大局解析</h2><p>AQS是JUC里面的一个抽象同步框架，核心的作用就是统一分装了线程的等待唤醒排队机制。</p><p>底层通过一个volatile的state变量+FIFO的队列来实现线程安全的资源性抢夺</p><p>state表示资源的状态，独占锁里面0没人占，1就是已经上锁。可重入锁里面数字代表可重入的次数</p><p>线程要抢不到锁，就会被挂到队列里面进行排队，队列是双向链表实现的CLH队列，节点记录了等待状态，信息等</p><p>他只是一个框架，真正的锁逻辑交给实现类自己决定</p><h2 id="3-wait和sleep的区别"><a href="#3-wait和sleep的区别" class="headerlink" title="3.wait和sleep的区别"></a>3.wait和sleep的区别</h2><p>wait()和sleep()的主要区别在于：1. 所属类不同，wait()是Object类的方法，sleep()是Thread类的静态方法；2. wait()会释放对象锁，而sleep()保持锁不释放；3. wait()必须在同步代码块中调用，sleep()没有此限制；4. wait()需要notify()或notifyAll()来唤醒，而sleep()在超时或被中断时自动恢复；5. 使用场景上，wait()用于线程间的协作，sleep()用于简单的延时操作。</p><p>wait()方法使当前线程进入等待状态，将其从运行状态转变为等待状态，并将其加入到等待池中。</p><h2 id="4-异步编排"><a href="#4-异步编排" class="headerlink" title="4.异步编排"></a>4.<strong>异步编排</strong></h2><p>在我看来，<strong>异步编排的核心思想是，将多个独立的、耗时的异步任务（尤其是I/O密集型任务）组合、编排起来，让它们尽可能地并行执行，最终汇总结果，从而极大地缩短整体的响应时间。</strong> 这在微服务架构中尤其重要。</p><p>在现代Java开发中，实现异步编排最核心的工具就是 <strong><code>CompletableFuture</code></strong></p><p>举一个我们项目中非常典型的例子：<strong>获取‘商品详情页’数据</strong>。一个商品详情页通常需要展示多种信息，而这些信息可能来自不同的微服务或数据库表：</p><ul><li><strong>任务A</strong>：调用商品服务，获取商品基本信息。</li><li><strong>任务B</strong>：调用用户服务，获取当前用户的优惠券信息。</li><li><strong>任务C</strong>：调用评论服务，获取商品的热门评论。</li><li><strong>任务D</strong>：调用推荐服务，获取相关商品推荐。</li></ul><p>如果采用传统的同步调用方式，总耗时将是 <code>A + B + C + D</code> 的累加。但实际上，这四个任务<strong>没有任何依赖关系，完全可以并行执行</strong>。通过异步编排，理想情况下的总耗时将仅仅取决于<strong>耗时最长的那一个任务</strong>，即 <code>Max(A, B, C, D)</code>，性能会得到指数级的提升。</p><p>实现：</p><ol><li><strong>任务并行化</strong>：为每一个独立的调用任务创建一个<code>CompletableFuture</code>实例。关键是使用<code>supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code>方法，并为其<strong>提供一个自定义的线程池</strong>。这可以避免耗尽Web服务器（如Tomcat）的业务线程池。</li><li><strong>结果编排与组合</strong>：当所有并行的任务都完成后，我需要将它们的结果组合成一个最终的<code>ProductDetailPageDTO</code>。我会使用<code>CompletableFuture.allOf()</code>来等待所有任务完成。</li><li><strong>最终结果处理</strong>：在<code>allOf()</code>完成后，通过<code>thenApply()</code>或<code>thenAccept()</code>来执行最终的组装逻辑。</li><li><strong>异常处理与超时控制</strong>：在生产环境中，还需要考虑健壮性。我会使用<code>exceptionally()</code>来处理任何一个异步任务的失败，返回一个默认值或降级数据。同时，使用<code>orTimeout()</code>为整个编排流程设置一个最大等待时间，防止因为某个下游服务缓慢而导致整个请求长时间阻塞。</li></ol><h2 id="5-synchronized-锁升级的“细节追问"><a href="#5-synchronized-锁升级的“细节追问" class="headerlink" title="5.synchronized 锁升级的“细节追问"></a>5.<strong><code>synchronized</code> 锁升级的“细节追问</strong></h2><p>1.<strong>线程是如何从‘偏向锁’升级到‘轻量级锁’的？JVM是如何判断‘偏向’失效的</strong></p><p>“偏向锁的核心思想是，它‘偏向’于第一个获取它的线程，认为在接下来的执行中，锁将一直被这个线程持有。</p><ol><li><strong>偏向状态</strong>：当一个线程第一次获取锁时，JVM会通过<strong>CAS操作</strong>，尝试将锁对象头（Mark Word）中的<strong>线程ID</strong>指向当前线程。如果成功，就获取了偏向锁。</li><li><strong>升级触发点</strong>：当<strong>另一个线程</strong>（线程B）尝试获取这个已经被线程A持有的偏向锁时，升级过程就被触发了。</li><li><strong>偏向锁的撤销</strong>：<ul><li>首先，线程B的CAS操作会失败。JVM会检查Mark Word中记录的线程ID是否是线程A。</li><li>JVM会暂停线程A（在一个<strong>全局安全点</strong>），然后检查线程A是否还存活。</li><li>如果线程A<strong>已经执行完毕</strong>，那么锁对象恢复到无锁状态，线程B可以重新尝试获取。</li><li>如果线程A<strong>仍然存活且还在同步块内</strong>，说明发生了真正的竞争。此时，偏向锁就会被<strong>撤销（Revoke）</strong>。锁对象头的Mark Word会被修改，清除偏向锁标志，并升级为<strong>轻量级锁</strong>的状态。同时，线程A的栈帧中会创建锁记录（Lock Record），指向锁对象。</li><li>之后，线程A和线程B都会在轻量级锁的状态下进行竞争（通过自旋）。</li></ul></li><li>只不过目前在<strong>JDK 15</strong> 中被 <strong>默认禁用</strong>，并在 <strong>JDK 18</strong> 被 <strong>完全移除</strong>。因为偏向锁的撤销消耗的性能是比较大的</li></ol><p>2.<strong>那轻量级锁又是如何升级到重量级锁的？‘自旋’失败后发生了什么？</strong></p><p>轻量级锁的核心思想是，它认为锁的竞争时间会非常短，线程只需要‘稍等一下’（自旋），就可以拿到锁，从而避免了线程阻塞和唤醒带来的内核态切换开销。</p><ol><li><strong>轻量级锁的获取</strong>：线程在自己的栈帧中创建锁记录（Lock Record），然后通过<strong>CAS操作</strong>尝试将锁对象的Mark Word指向这个锁记录。如果成功，就获取了轻量级锁。</li><li><strong>自旋等待</strong>：如果CAS失败，说明锁已被其他线程持有。当前线程并不会立即阻塞，而是会进行<strong>自旋</strong>，即执行一个空循环，不断地重试CAS操作。</li><li><strong>升级触发点</strong>：升级到重量级锁主要有两种情况：<ul><li><strong>自旋失败</strong>：自旋的次数是有限的（JVM会动态调整，比如10次）。如果一个线程自旋了指定次数后，仍然没有获取到锁，JVM就认为竞争已经非常激烈了，不适合再空耗CPU。</li><li><strong>竞争者过多</strong>：如果在自旋过程中，又有<strong>第三个线程</strong>也来竞争这把锁，那么也会立即触发升级。</li></ul></li><li><strong>锁膨胀（Inflation）</strong>：<ul><li>一旦触发升级，锁就会<strong>膨胀</strong>为重量级锁。</li><li>锁对象的Mark Word会被修改，指向一个重量级锁的监视器对象（Monitor）。</li><li>所有等待锁的线程（包括正在自旋的线程和后来者）都<strong>不再自旋</strong>，而是会被<strong>阻塞</strong>，并放入Monitor的等待队列中。</li><li>当持有锁的线程释放锁时，会唤醒等待队列中的一个线程，进行新一轮的锁竞争。这个过程就涉及到了操作系统的互斥量（Mutex）和线程的上下文切换。</li></ul></li></ol><p>锁的升级是<strong>单向的</strong>，只能从低级别到高级别，不能降级（在HotSpot JVM的实现中）。</p><h2 id="6-ThreadLocal"><a href="#6-ThreadLocal" class="headerlink" title="6.ThreadLocal"></a>6.ThreadLocal</h2><p><strong>既然<code>key</code>用弱引用会导致内存泄漏，那为什么<code>ThreadLocalMap</code>的设计者不把<code>key</code>也设计成强引用呢？或者，为什么不把<code>value</code>也设计成弱引用</strong></p><p> 1.<strong>为什么Key不能是强引用？</strong></p><ul><li>假设Key是强引用。那么<code>Thread</code>对象会通过<code>threadLocals</code>这个Map强引用着<code>ThreadLocal</code>对象（Key）。只要线程本身不消亡，这个强引用链（<code>Thread</code> -&gt; <code>ThreadLocalMap</code> -&gt; <code>Entry</code> -&gt; <code>ThreadLocal</code>对象）就一直存在。</li><li>这意味着，即使我们在业务代码中已经不再使用某个<code>ThreadLocal</code>对象了（比如，<code>myThreadLocal = null;</code>），只要这个线程还在线程池中被复用，这个<code>ThreadLocal</code>对象本身就<strong>永远无法被GC回收</strong>。这会导致<code>ThreadLocal</code>对象本身的泄漏，比现在的情况更糟糕。”</li></ul><p>2.<strong>为什么Value不能是弱引用？</strong></p><ul><li><code>ThreadLocal</code>的核心目的就是让我们存放一些与线程绑定的<strong>数据（Value）</strong>。这些数据通常是我们业务逻辑中需要用到的对象，比如用户信息对象、数据库连接等。</li><li>如果我们把Value也设计成弱引用，那么当一次GC发生时，<strong>只要这个Value对象在其他地方没有被强引用，它就可能被意外地回收掉</strong>。</li><li>这会导致我们调用<code>threadLocal.get()</code>时，突然得到一个<code>null</code>值，这完全违背了<code>ThreadLocal</code>的设计初衷，会引发严重的业务逻辑错误。我们存放进去的对象，必须保证在<code>remove()</code>之前是可靠存在的。所以，<strong>Value必须是强引用</strong>。”</li></ul><p>因此只能做出了个权衡：</p><ul><li><strong>Key使用弱引用</strong>：是为了当<code>ThreadLocal</code>对象本身在外部不再被使用时，GC能够回收它，从而让Map中的Entry的key变为<code>null</code>，为后续的清理（expungeStaleEntry）提供了可能性。</li><li><strong>Value使用强引用</strong>：是为了保证我们存放的数据的生命周期是可控的，不会被GC意外回收。</li></ul><h2 id="7-谈谈怎么理解线程安全的"><a href="#7-谈谈怎么理解线程安全的" class="headerlink" title="7.谈谈怎么理解线程安全的"></a>7.谈谈怎么理解线程安全的</h2><p><strong>线程安全</strong>指的是当多个线程同时访问一个对象或方法时，无论操作系统如何调度这些线程，也无需调用方在代码中去做额外的同步处理，都能保证程序的正确性，不会出现数据损坏或不一致的情况。</p><p>线程不安全的问题通常会表现在三个方面</p><ol><li>原子性：一个或多个操作作为一个不可分割的整体来进行，要去这个操作序列，必须由一个线程独占完整的去执行，不能被其他线程所干扰，调不可被中断。i++</li><li>可见性：一个线程修改了一个共享变量的值，这个修改的值能够被其他线程看到。但是实际在CPU的高速缓存下，对指令做出的重排序操作，导致共享变量的值，对其他线程不是立即课件的。缓存读的旧值</li><li>有序性：写的代码的顺序和实际代码的顺序不一致，是由于编译器和处理器层面对指令重排优化导致的，可能会导致可见性问题</li></ol><p>我们可以使用voliate或者是直接加synchronized，或者是直接加锁</p><p>或者使用原子类的CAS，或者是线程安全的ThreadLocal</p><h2 id="8-ConditionalOnClass设计内涵"><a href="#8-ConditionalOnClass设计内涵" class="headerlink" title="8.@ConditionalOnClass设计内涵"></a>8.<strong><code>@ConditionalOnClass</code></strong>设计内涵</h2><p>面试官提出了一个非常精妙的问题：“<code>@ConditionalOnClass(User.class)</code>这行代码能编译通过，说明<code>User.class</code>肯定存在于classpath中，那为什么还需要这个注解呢？</p><p>未能理解<code>@Conditional</code>系列注解是为了解决<strong>通用starter模块在不同应用环境下的适配性</strong>问题，而不是为了解决当前项目中的类是否存在的问题。</p><p>确实，如果在我当前的项目中写<code>@ConditionalOnClass(User.class)</code>，这个条件判断看起来是多余的。因为<code>User.class</code>如果不存在，我的项目根本无法编译通过。</p><p>这个注解的真正威力体现在<strong>开发通用的starter模块</strong>时。想象一下，我们正在开发一个<code>my-sms-spring-boot-starter</code>，这个starter希望能够同时支持<strong>阿里云短信</strong>和<strong>腾讯云短信</strong>。</p><ul><li>我们的starter会提供两个自动配置类：<code>AliyunSmsAutoConfiguration</code> 和 <code>TencentSmsAutoConfiguration</code>。</li><li><code>AliyunSmsAutoConfiguration</code>负责创建阿里云短信服务的Bean。</li><li><p><code>TencentSmsAutoConfiguration</code>负责创建腾讯云短信服务的Bean。</p></li><li><p>一个<strong>使用者（应用项目）\</strong>在他的项目中引入了我们的starter。他可能只想使用阿里云短信，所以他只会在他的<code>pom.xml</code>中添加*<em>阿里云的SDK依赖*</em>，而不会添加腾讯云的。</p></li><li>这时，我们的starter如何智能地判断只加载阿里云的Bean，而不去加载腾讯云的Bean呢？（如果去加载腾讯云的Bean，会因为缺少腾讯云SDK的jar包而直接抛出<code>ClassNotFoundException</code>，导致应用启动失败）</li><li>我们就是使用@ConditionalOnClass</li></ul><p>在<code>AliyunSmsAutoConfiguration</code>上，我们会这样写,@ConditionalOnClass(com.aliyun.sms.sdk.SmsClient.class) </p><ul><li>当使用者的应用启动时，Spring Boot会解析我们starter中的这两个自动配置类。</li><li>在解析<code>AliyunSmsAutoConfiguration</code>时，它会检查<strong>当前应用的classpath</strong>中是否存在<code>com.aliyun.sms.sdk.SmsClient.class</code>。因为使用者添加了阿里云的SDK依赖，所以这个类存在，条件满足，这个配置类就会被加载，阿里云的Bean就会被创建。</li><li>在解析<code>TencentSmsAutoConfiguration</code>时，它会检查classpath中是否存在<code>com.tencent.cloud.sms.sdk.SmsSender.class</code>。因为使用者<strong>没有</strong>添加腾讯云的SDK依赖，所以这个类不存在，条件不满足，<strong>这个配置类就会被优雅地跳过，不会被加载</strong>，从而避免了<code>ClassNotFoundException</code>。</li></ul><p><code>@ConditionalOnClass</code>并不是为了判断我们自己项目里的类是否存在，而是为了让我们开发的<strong>通用模块（starter）\</strong>能够*<em>智能地感知和适配它所运行的应用环境*</em>，根据应用环境中引入了哪些依赖，来动态地决定哪些功能应该被激活。这是Spring Boot实现‘约定大于配置’和‘开箱即用’的关键魔法之一</p><h2 id="9-ThreadLocal-在线程池中的失效问题"><a href="#9-ThreadLocal-在线程池中的失效问题" class="headerlink" title="9.ThreadLocal 在线程池中的失效问题"></a>9.<strong><code>ThreadLocal</code> 在线程池中的失效问题</strong></h2><ul><li><code>InheritableThreadLocal</code>之所以能够实现父子线程间的数据传递，是因为在<code>new Thread()</code>创建子线程时，子线程的构造函数会检查父线程的<code>inheritableThreadLocals</code>这个Map。如果它不为空，子线程就会将父线程Map中的所有值<strong>拷贝</strong>一份到自己的<code>inheritableThreadLocals</code>中。</li><li><strong>关键在于</strong>：这个值的拷贝动作，<strong>只发生在子线程被创建的那一瞬间</strong>。</li><li>在线程池的场景下，工作线程通常在系统启动时就已经被<strong>预先创建</strong>好了，并存放在池中。当我们提交一个任务时，线程池只是从池中<strong>取出一个已经存在的线程</strong>来执行我们的任务，并<strong>没有<code>new Thread()</code>这个动作</strong>。</li></ul><p>为了解决这个问题，阿里巴巴开源了一个非常强大的工具——<strong><code>TransmittableThreadLocal</code>（TTL）</strong>。它专门用于解决在使用线程池等会池化线程的组件时，实现父子线程、任务提交者与任务执行者之间的上下文传递问题。</p><p>TTL的优点在于它通过<strong>Java Agent</strong>或<strong>手动包装</strong>的方式，对线程池的<code>submit</code>/<code>execute</code>等方法以及<code>Runnable</code>/<code>Callable</code>任务进行了<strong>装饰（Decorate）</strong>。”</p><ol><li><strong>任务提交时（<code>submit</code>）</strong>：当我们调用被装饰过的<code>threadPool.submit(myRunnable)</code>时，TTL会<strong>捕获</strong>当前线程（父线程）的<code>ThreadLocal</code>值，并将其<strong>‘打包’</strong>进一个<code>TtlRunnable</code>或<code>TtlCallable</code>对象中。</li><li><strong>任务执行前（<code>run</code>）</strong>：当线程池中的某个工作线程开始执行这个被包装过的<code>TtlRunnable</code>时，在其<code>run</code>方法的<code>try</code>块开始处，TTL会将被‘打包’的父线程<code>ThreadLocal</code>值，<strong>‘回放’（replay）</strong>到当前工作线程的<code>ThreadLocal</code>中。</li><li><strong>任务执行后（<code>finally</code>）</strong>：在<code>finally</code>块中，TTL会<strong>清理</strong>当前工作线程的<code>ThreadLocal</code>，将其恢复到执行任务之前的状态，从而避免了数据串扰。</li></ol><h2 id="10-如何保证三个线程有序执行任务"><a href="#10-如何保证三个线程有序执行任务" class="headerlink" title="10.如何保证三个线程有序执行任务"></a>10.如何保证三个线程有序执行任务</h2><p>方案1：使用<strong><code>wait/notify</code> 方案</strong></p><p>你需要自己管理锁（<code>synchronized</code>）、状态变量（<code>volatile int state</code>）、<code>while</code>循环（防止伪唤醒）、<code>try-finally</code>（保证锁释放），代码量大且极易出错。</p><p>使用<code>notifyAll()</code>会唤醒所有等待的线程，造成不必要的CPU竞争。而使用<code>notify()</code>又存在风险：如果错误地唤醒了不该被唤醒的线程（比如T1唤醒了T3而不是T2），信号就可能丢失，导致程序死锁。</p><p>方案2：<strong>升级版 <code>wait/notify</code> - <code>ReentrantLock</code> + <code>Condition</code></strong></p><p><code>ReentrantLock</code>提供了比<code>synchronized</code>更强大的功能。<code>Condition</code>对象则将<code>wait/notify</code>机制从“一个锁只有一个等待队列”升级为“<strong>一个锁可以有多个独立的等待队列</strong>”，我们可以为每个线程的“等待室”创建一个<code>Condition</code>，实现精准的“点对点”唤醒，彻底避免了<code>notify()</code>的信号丢失问题。</p><ol><li>创建一个<code>ReentrantLock</code>实例。</li><li>创建一个<code>volatile</code>状态变量，例如<code>volatile int state = 1;</code>，用于标识当前应该哪个线程执行。</li><li>为<strong>每个线程</strong>创建一个<code>Condition</code>对象：<code>Condition c1 = lock.newCondition(); Condition c2 = lock.newCondition(); Condition c3 = lock.newCondition();</code></li><li>线程T1的逻辑：<ul><li>获取锁 <code>lock.lock()</code>。</li><li>在<code>try...finally</code>中执行，<code>finally</code>块中<code>lock.unlock()</code>。</li><li><code>while (state != 1)</code>，<code>c1.await()</code>。</li><li>执行任务1。</li><li>更新状态 <code>state = 2</code>。</li><li><strong>精准唤醒</strong>线程T2：<code>c2.signal()</code>。</li></ul></li><li><strong>线程T2和T3的逻辑</strong>与T1类似，分别在自己的<code>Condition</code>上<code>await</code>，并在执行完任务后，更新<code>state</code>并<code>signal</code>下一个线程的<code>Condition</code>。</li></ol><p>实现了有序执行，通过<code>signal()</code>实现了精准唤醒，比<code>notifyAll()</code>更高效，比<code>notify()</code>更安全。但还是比较复杂</p><p>方案3：<strong>信号量接力 - <code>Semaphore</code></strong></p><p><code>Semaphore</code>（信号量）是控制同时访问特定资源的线程数量的工具。我们可以创建两个初始许可为0的信号量，作为两个线程之间的“接力棒”。</p><ol><li>创建两个信号量：<code>Semaphore sem2 = new Semaphore(0);</code> 和 <code>Semaphore sem3 = new Semaphore(0);</code>。</li><li>线程T1的逻辑：<ul><li>执行任务1。</li><li>执行完毕后，释放一个“给T2的许可”：<code>sem2.release()</code>。</li></ul></li><li>线程T2的逻辑：<ul><li>首先尝试获取“来自T1的许可”，如果许可未被释放，T2将在此阻塞：<code>sem2.acquire()</code>。</li><li>获取到许可后，执行任务2。</li><li>执行完毕后，释放一个“给T3的许可”：<code>sem3.release()</code>。</li></ul></li><li>线程T3的逻辑：<ul><li>首先尝试获取“来自T2的许可”：<code>sem3.acquire()</code>。</li><li>获取到许可后，执行任务3。</li></ul></li></ol><p>代码清晰简单，但需要创建N-1个<code>Semaphore</code>对象，如果线程数量很多，会增加一些对象管理的开销。</p><p>方案4：<strong><code>SingleThreadExecutor</code></strong></p><p><code>Executors.newSingleThreadExecutor()</code>会创建一个<strong>单线程的线程池</strong>。这个线程池的核心特性是：它内部有一个<strong>无界的<code>LinkedBlockingQueue</code>\</strong>来存放任务，并且*<em>永远只有一个工作线程<strong>来从队列中取出并执行任务。这就天然地保证了所有提交给它的任务，都会</strong>严格按照提交的顺序（FIFO）来串行执行*</em>。</p><ol><li><p>创建一个单线程执行器：<code>ExecutorService executor = Executors.newSingleThreadExecutor();</code></p></li><li><p>定义三个任务（<code>Runnable</code>或<code>Callable</code>）：<code>task1</code>, <code>task2</code>, <code>task3</code>。</p></li><li><p>按顺序提交任务：java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br></pre></td></tr></table></figure></li><li><p>关闭线程池：<code>executor.shutdown()</code>。</p></li></ol><ul><li><strong>严格来说，这是“三个任务有序执行”，而不是“三个不同的线程有序执行”</strong>。因为所有任务都是由<strong>同一个</strong>工作线程来执行的。如果面试官的题目严格要求必须是三个<strong>不同的、预先创建好</strong>的线程，那么这个方案就不完全符合字面要求。</li></ul><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-UserMappe这个类为啥要是接口呢？"><a href="#1-UserMappe这个类为啥要是接口呢？" class="headerlink" title="1.UserMappe这个类为啥要是接口呢？"></a>1.UserMappe这个类为啥要是接口呢？</h2><p>MyBatis的Mapper之所以必须定义为接口，其根本原因在于MyBatis框架在底层使用了<strong>JDK动态代理（JDK Dynamic Proxy）</strong>技术，来为我们自动地生成这个接口的实现类。</p><p>只定义了<code>UserMapper</code>接口，并在XML文件中写了SQL，但我们<strong>从来没有手动编写过一个<code>class UserMapperImpl implements UserMapper</code></strong>。然而，在Service层，我们却可以直接<code>@Autowired</code>注入一个<code>UserMapper</code>的实例并调用它的方法。</p><ol><li><strong>启动时扫描</strong>：当Spring容器启动时，MyBatis的<code>MapperScannerConfigurer</code>会扫描指定的包路径（如<code>com.example.mapper</code>），找到所有被<code>@Mapper</code>注解标记的接口，或者所有继承了特定标记接口的接口。</li><li><strong>注册Bean定义</strong>：对于找到的每一个Mapper接口（比如<code>UserMapper.class</code>），MyBatis并不会去创建一个真实的实现类，而是在Spring容器中注册一个特殊类型的Bean定义——<code>MapperFactoryBean</code>。</li><li><strong>创建代理对象</strong>：当Service层需要注入<code>UserMapper</code>时，Spring会向<code>MapperFactoryBean</code>请求获取Bean实例。此时，<code>MapperFactoryBean</code>就会调用JDK动态代理，<strong>在内存中动态地生成一个<code>UserMapper</code>接口的代理实现对象</strong>。</li></ol><ul><li><p>“这个动态生成的代理对象，它的内部有一个<code>InvocationHandler</code>。当我们调用代理对象的任何方法时（比如<code>userMapper.selectById(1)</code>），这个调用都会被<code>InvocationHandler</code>拦截。”</p></li><li><p>InvocationHandler的逻辑大致是：”</p><ol><li>它会获取到我们调用的<strong>方法名</strong>（<code>selectById</code>）和<strong>参数</strong>（<code>1</code>）。</li><li>它会将方法名与Mapper XML文件中配置的SQL语句的<code>id</code>进行<strong>映射和绑定</strong>。</li><li>它会从连接池获取一个数据库连接，将参数设置到SQL语句中，然后通过JDBC执行这条SQL。</li><li>最后，它会将查询结果封装成我们方法签名中定义好的返回类型（如<code>User</code>对象），并返回。</li></ol></li></ul><p>  正是因为MyBatis依赖于<strong>JDK动态代理</strong>，而JDK动态代理技术本身就<strong>要求被代理的目标必须是一个接口</strong>。它无法为一个具体的类或抽象类创建代理。这就是为什么Mapper必须是接口的根本技术原因。</p><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h1><h2 id="1-流式输出和非流式输出"><a href="#1-流式输出和非流式输出" class="headerlink" title="1.流式输出和非流式输出"></a>1.流式输出和非流式输出</h2><div class="table-container"><table><thead><tr><th>对比点</th><th>流式输出</th><th>非流式输出</th></tr></thead><tbody><tr><td><strong>数据传输</strong></td><td>边生产边传输</td><td>生成完后一次传输</td></tr><tr><td><strong>响应延迟</strong></td><td>首字节快，用户能尽快看到结果</td><td>必须等所有数据生成后才能看到</td></tr><tr><td><strong>内存占用</strong></td><td>占用更少内存（分段处理）</td><td>可能占用大量内存（一次性加载）</td></tr><tr><td><strong>实现复杂度</strong></td><td>较高（需要支持分段协议/推送机制）</td><td>较低（一次性返回）</td></tr><tr><td><strong>应用场景</strong></td><td>视频流、日志实时消费、AI Chat逐字打印</td><td>小文件下载、查询一次性返回结果</td></tr></tbody></table></div><p>非流式输出是等数据全部生成后一次性返回，而流式输出则是边生成边返回，能降低延迟和内存占用，更适合大数据量和实时场景。</p><h2 id="2-HashMap-remove-方法的实现细节"><a href="#2-HashMap-remove-方法的实现细节" class="headerlink" title="2.HashMap remove 方法的实现细节"></a>2.<strong>HashMap <code>remove</code> 方法的实现细节</strong></h2><ol><li>首先，<code>remove(key)</code>方法会计算<code>key</code>的<code>hash</code>值。</li><li>根据<code>hash</code>值定位到它在底层<code>table</code>数组中的索引位置（即bucket）。</li><li>如果该bucket为空，直接返回<code>null</code>。</li><li>如果bucket不为空，则遍历该位置的链表或红黑树，逐个节点使用<code>hash</code>值和<code>equals()</code>方法进行比较，直到找到要删除的目标节点。如果遍历完没找到，也返回<code>null</code>。</li></ol><p><strong>如果当前是链表结构</strong>,是头节点的话，即让头节点的下一个节点成为新的头节点。</p><p><strong><code>p</code>是中间节点或尾节点</strong>。那么就跳过这个节点，GC将自动回收这个不再被引用的节点</p><ul><li>红黑树的删除操作要复杂得多，因为它必须在删除节点后，通过一系列的<strong>旋转（Rotation）和重新着色（Recoloring）\</strong>操作，来*<em>维持红黑树的5条性质*</em>（例如，根是黑的、不能有连续的红节点、任何节点到其每个叶子节点的所有路径都包含相同数目的黑色节点等），从而保证树的平衡性。</li><li><code>HashMap</code>会调用内部的<code>removeTreeNode</code>方法来执行这个复杂的过程。</li><li>在红黑树中删除了一个节点后，<code>HashMap</code>还会检查该bucket的节点数量。如果数量减少到了一个<strong>阈值（UNTREEIFY_THRESHOLD，默认为6）</strong>，为了节省内存和在节点数少时提升性能，这棵红黑树会<strong>退化（untreeify）</strong>变回普通的链表结构。</li><li>删除成功后，<code>HashMap</code>的<code>size</code>会减1。</li><li>方法会返回被删除节点的<code>value</code>值。</li></ul><p>3.</p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="1-多表join的时候，小表驱动大表"><a href="#1-多表join的时候，小表驱动大表" class="headerlink" title="1.多表join的时候，小表驱动大表"></a>1.多表join的时候，小表驱动大表</h2><p>在Mysql的 Nested Loop Join 中</p><p><strong>驱动表（outer table）</strong>：首先被扫描的表。</p><p><strong>被驱动表（inner table）</strong>：对驱动表每一行，根据 Join 条件去查找匹配行的表。</p><p><strong>核心原则</strong>：过滤后剩余行数少的表，应该作为驱动表，这样可以减少被驱动表的访问次数。这就是小表</p><p>执行过程：</p><p>扫描驱动表（全表扫描或索引扫描）。</p><p>对驱动表的每一行，根据连接条件在被驱动表中查找（通常用索引 B+Tree 查找）。</p><p>如果被驱动表使用二级索引且需要回表，则访问主键索引。</p><p>小表驱动大表，大表负责命中索引。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A straight_join B on A.a = B.a;</span><br></pre></td></tr></table></figure><p>数据库会全表扫A，然后每拿到一行就去比较条件 A.a=B.a，去B表里面查，B表命中索引的查询。实际上就是一个搜索树，查询的时间复杂度近似log2^B^，然后加上一次回表，可能就是2Log2 ^B^,所以总体的时间复杂度为A+2log2^B^*A，如果是覆盖索引的话，复杂度可降为 O(A + log₂(B) × A)</p><p>所以我的们A越小越好，join的本质就是查驱动表，然后扫被驱动表，当然是查的越少越好了</p><h2 id="2-一条-UPDATE-语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理"><a href="#2-一条-UPDATE-语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理" class="headerlink" title="2.一条 UPDATE 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理"></a>2.一条 <code>UPDATE</code> 语句发过来，从网络接收开始，到最终落盘，会经过哪些核心模块的处理</h2><p>Mysql是一个分层的，核心模块包括网络层、SQL层和存储引擎层。</p><p>如果以一条 <code>UPDATE t SET c = 2 WHERE id = 1;</code> 语句为例，它的生命周期是这样的：</p><p>网络层：</p><p>首先，客户端通过TCP连接发送这条SQL。我的网络模块基于Java NIO实现，会接收这个请求，并将其传递给SQL层。</p><p>SQL层 - 解析与执行：</p><ul><li><strong>SQL解析器</strong>：SQL层会解析这条字符串，生成一个抽象语法树（AST）。</li><li><strong>执行器</strong>：然后，执行器会解释这棵树。对于这条<code>UPDATE</code>语句，它知道要去表<code>t</code>中找到<code>id=1</code>的行，并更新<code>c</code>列。</li></ul><p>存储引擎层 - 事务与数据处理：这是最核心的部分。</p><ul><li><strong>事务管理器</strong>：执行器会向事务管理器申请开启一个事务。</li><li><strong>访问数据</strong>：执行器请求存储引擎去获取<code>id=1</code>的行。存储引擎会先去 <strong>Buffer Pool</strong>（内存缓冲池）里查找，如果数据页不在内存，会通过 <strong>IO模块</strong> 从磁盘加载。</li><li><strong>并发控制</strong>：在读取和修改数据时，为了保证隔离性，这里会涉及到 <strong>MVCC</strong> 和 <strong>锁管理器</strong>。<code>UPDATE</code> 是一种“当前读”，所以它会读取最新的已提交版本，并在这行数据上加一个 <strong>排他锁（X Lock）</strong>，防止其他事务同时修改。</li><li><strong>执行修改</strong>：获取到锁之后，执行器会在 Buffer Pool 中修改对应的数据页。但它不是直接覆盖旧数据，而是会生成一个 <strong>undo日志</strong>，记录下修改前的样子，用于回滚和支持MVCC。</li><li><strong>记录日志</strong>：在修改内存数据页之前，必须先将这次操作的详细信息写入 <strong>redo日志（WAL）</strong> 的内存缓冲区。这是为了保证持久性。</li><li><strong>提交事务</strong>：当客户端发起 <code>COMMIT</code> 时，<strong>日志管理器</strong> 会确保对应的 redo 日志被刷入磁盘。只要 redo 日志落盘了，即使此时宕机，数据也能恢复，所以我们就可以认为事务提交成功了。</li><li><strong>数据落盘</strong>：至于 Buffer Pool 里的脏数据页，则由一个后台线程根据一定的策略（比如LRU）异步地刷回磁盘，这个过程不影响事务的提交响应。</li></ul><h2 id="3-为什么选择-WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？"><a href="#3-为什么选择-WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？" class="headerlink" title="3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？"></a>3.为什么选择 WAL？它相比于直接写数据文件，核心优势是什么？写日志和更新内存数据页的顺序是怎样的？</h2><p>选择 WAL 的核心优势在于<strong>将随机IO转换为了顺序IO，极大地提升了写入性能并保证了数据不丢失</strong>。</p><ul><li><strong>性能提升</strong>：数据库的数据页在磁盘上是离散存储的，修改它们需要大量的随机磁盘寻址，非常慢。而日志文件是追加写入的，是顺序IO，速度比随机IO快几个数量级。通过 WAL，事务提交时只需要保证日志落盘即可，脏数据页可以异步、批量地刷回磁盘，大大降低了事务提交的延迟。</li><li>顺序保证：这个顺序是绝对不能颠倒的，必须是先写日志（Log），再更新内存页（Buffer Pool）。这就是“Write-Ahead Logging”（预写日志）这个名字的由来。<ul><li><strong>原因</strong>：如果反过来，先修改了内存中的数据页，然后系统在写日志之前宕机了。那么当系统重启时，内存中的修改会全部丢失，而日志里又没有记录这次操作，这个更新就永远地丢失了，这违反了事务的<strong>持久性（Durability）</strong>。而只要保证日志先写入，即使系统在数据页刷盘前宕机，重启后也可以通过扫描 redo 日志来恢复数据，保证了数据的完整性。”</li></ul></li></ul><h2 id="4-当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？"><a href="#4-当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？" class="headerlink" title="4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？"></a>4.当一个叶子节点分裂时，具体逻辑是怎样的？如何处理并发问题？</h2><p>当向一个叶子节点插入数据，发现它已经满了的时候，会触发分裂操作，逻辑如下：</p><ol><li><strong>创建新节点</strong>：首先，创建一个新的兄弟叶子节点。</li><li><strong>找到分裂点</strong>：计算出当前节点所有记录的中间位置。</li><li><strong>移动数据</strong>：将中间位置之后的所有记录移动到新的兄弟节点中。</li><li><strong>更新父节点</strong>：将原中间位置的键值（Key）提升到父节点中，作为一个新的索引项。这个索引项的指针会指向新创建的兄弟节点。</li><li><strong>级联分裂</strong>：如果插入这个新的索引项导致父节点也满了，那么父节点会重复上述的分裂过程，这个过程可能会一直级联到根节点，最坏情况下会导致树的高度增加。</li></ol><p>关于并发问题，这是一个非常关键的点。对B+树的这种结构性修改（如分裂或合并）必须是原子的，否则可能导致树的结构被破坏。</p><ul><li>当一个线程需要修改一个B+树节点时，它会先获取这个节点的 Latch。在分裂过程中，它会同时持有父节点和要分裂的子节点的 Latch，操作完成后再释放。这种方式只锁定了必要的节点，允许其他不相关的读写操作继续进行。</li></ul><p>Lock 和 Latch 区别</p><ul><li><strong>保护对象</strong>：<strong>Lock（锁）</strong> 是在<strong>事务层面</strong>，用来保护<strong>逻辑数据</strong>，比如表中的一行记录。它的目的是保证事务的隔离性。<strong>Latch（闩锁）</strong> 是在<strong>线程层面</strong>，用来保护<strong>内存中的物理数据结构</strong>，比如 Buffer Pool 中的一个数据页、B+树的一个节点或者一个共享的内存链表。它的目的是保证多线程访问共享内存结构时的线程安全。</li><li><strong>持有时间</strong>：<strong>Lock</strong> 的持有时间很长，可能会贯穿整个事务，直到事务提交或回滚才释放。<strong>Latch</strong> 的持有时间非常短，通常只在一次原子操作的临界区内持有，比如修改一个 B+ 树节点，操作一完成马上就释放。</li><li><strong>死锁</strong>：<strong>Lock</strong> 会涉及到死锁问题，需要数据库有专门的死锁检测机制。而 <strong>Latch</strong> 通常通过规定获取顺序（比如在B+树中总是从父节点到子节点获取）来避免死锁，所以一般认为 Latch 是无死锁的。</li></ul><p>简单来说，Lock 是给数据库用户（事务）用的，保证业务逻辑的正确性；Latch 是给数据库内核开发者用的，保证内核数据结构的正确性。”</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-多级缓存数据一致性与失败回滚"><a href="#1-多级缓存数据一致性与失败回滚" class="headerlink" title="1.多级缓存数据一致性与失败回滚"></a>1.<strong>多级缓存数据一致性与失败回滚</strong></h2><p>当被问及如何保证Redis和本地缓存更新的原子性，以及在更新失败时如何回滚，你的回答提到了不甚准确的“编程式事务”，并最终倾向于人工处理。</p><p>方案1：<strong>引入消息队列（MQ）进行可靠的异步处理</strong></p><ol><li>修改架构：Canal不再直接调用消费逻辑，而是将解析后的binlog事件作为消息发送到MQ的一个Topic中。</li><li>消费者逻辑：消费者服务从MQ拉取消息。其处理逻辑是：先失效Redis缓存，再发布一个广播消息（如通过Redis Pub/Sub）通知所有应用实例失效本地Caffeine缓存。</li><li>失败处理：只有当所有步骤成功后，消费者才向MQ发送ACK。如果处理过程中任何一步失败（如Redis连接超时），消费者不发送ACK。MQ会在超时后将该消息重新投递给其他消费者，实现自动重试。</li></ol><p>方案2 死信队列</p><ol><li>在Canal的消费者逻辑中，使用<code>Spring Retry</code>等框架对缓存失效操作进行封装。</li><li>配置重试策略，例如重试3次，每次间隔采用指数退避（如1s, 2s, 4s），避免在故障期间频繁冲击下游服务。</li><li>配置一个<code>RecoveryCallback</code>。当所有重试都失败后，将这条失败的binlog事件（包含表名、主键、操作类型等信息）发送到一个专门的<strong>死信队列（Dead Letter Queue）</strong>或记录到数据库的失败任务表中。</li><li>部署一个独立的监控程序或定时任务，消费DLQ中的消息，并发送告警（邮件、短信、钉钉）。</li></ol><p>如果重试逻辑设计不当，可能会在短时间内放大故障。死信队列需要有完善的监控，否则会成为被遗忘的角落。</p><p>方案3 <strong>先更新缓存，再更新数据库”的策略</strong></p><ol><li>写请求：先更新（或失效）Redis缓存，然后更新数据库。</li><li>为了解决并发更新导致的不一致问题，可以引入“延时双删”：先删缓存 -&gt; 更新数据库 -&gt; 延迟一段时间（如500ms）后再次删除缓存。</li><li>本地Caffeine缓存仍然可以通过监听Redis的key失效事件（Keyspace Notifications）或消息广播来同步失效。</li></ol><p><strong>非常不推荐</strong>。延时双删的延迟时间很难确定，无法100%保证一致性。代码侵入性强，业务逻辑与缓存逻辑耦合严重，维护困难。</p><h2 id="2-什么情况下，就是两个线程会持有同一把锁"><a href="#2-什么情况下，就是两个线程会持有同一把锁" class="headerlink" title="2.什么情况下，就是两个线程会持有同一把锁"></a>2.什么情况下，就是两个线程会持有同一把锁</h2><p><strong>两个不同的线程在同一时刻是不可能持有同一把锁的</strong>，这是锁的<strong>互斥性</strong>基本原则所保证的。如果出现了这种情况，那一定是锁的实现出了严重的问题。</p><p>您这个问题可能是在考察一个非常重要的特性——<strong>锁的可重入性</strong>。可重入性指的是<strong>同一个线程</strong>可以多次成功获取同一把锁，而不会自己把自己锁死。在释放锁时，也需要释放相应次数后，锁才会被真正释放。”</p><p>比如：在一个复杂的业务方法A中，它获取了锁。然后它又调用了另一个方法B，而方法B也需要获取同一个锁。如果没有可重入性，那么在方法B中，当前线程会因为无法获取一个已经被自己持有的锁而陷入死锁。</p><p>实现：Redisson巧妙地使用了Redis的<strong>Hash数据结构</strong>来实现。</p><ul><li>当一个线程第一次获取锁时，它会在Redis中创建一个Hash。这个Hash的Key是锁的名称（例如<code>myLock</code>）。</li><li>这个Hash结构内部会存储两个关键信息：<ul><li>一个field存储<strong>持有锁的线程标识</strong>（例如，UUID + ThreadId）。</li><li>另一个field存储一个<strong>计数器</strong>，表示该线程重入的次数，初始值为1。</li></ul></li><li>当同一个线程<strong>再次</strong>尝试获取这把锁时，Redisson会检查Hash中存储的线程标识。如果与当前线程标识匹配，它就不会阻塞，而是直接将计数器的值加1，表示又重入了一次。</li><li>当线程<strong>释放锁</strong>时，它会去将计数器减1。只有当计数器的值减到0时，Redisson才会真正地从Redis中删除这个Hash（即释放锁），这样其他线程才有机会获取。</li></ul><h2 id="3-如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？"><a href="#3-如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？" class="headerlink" title="3.如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？"></a>3.<strong>如果Canal挂了怎么办？或者Canal到消费端的链路出现长时间中断，会发生什么？有什么容灾方案吗？</strong></h2><p>您提的这个问题非常关键，它涉及到整个数据同步链路的<strong>高可用性</strong>。</p><ol><li><strong>Canal自身的高可用</strong>：首先，Canal自身是可以部署成<strong>高可用集群</strong>的。通过Zookeeper进行集群管理和主备选举，当主节点宕机时，备用节点可以自动接管，从而保证了数据订阅服务的连续性。</li><li><strong>链路中断的影响</strong>：如果Canal到消费端的链路中断，确实会导致缓存与数据库在中断期间的<strong>数据不一致窗口期变长</strong>。新写入的数据无法触发缓存失效，用户可能会在一段时间内读到旧的缓存数据。</li><li><strong>我们的容灾与补偿策略</strong>：<ul><li><strong>监控与告警</strong>：我们必须对Canal的消费位点（Position）与MySQL主库的最新binlog位点之间的<strong>延迟</strong>做严格的监控。一旦延迟超过阈值（比如1分钟），就立即触发高级别告警，通知SRE和开发团队介入。</li><li><strong>设置合理的缓存TTL</strong>：即使同步链路中断，我们缓存中的数据也不是永久有效的。通过为所有缓存设置一个合理的<strong>兜底过期时间（TTL）</strong>，比如1小时，可以保证即使在最坏的情况下，数据不一致的时间也不会无限延长。这是一种<strong>自愈机制</strong>。</li><li><strong>手动全量/增量校准</strong>：对于极端重要的数据，我们会准备一个<strong>手动触发的数据校准脚本</strong>。当链路长时间中断并恢复后，可以运行这个脚本，根据时间戳或版本号，主动查询数据库，强制刷新Redis中的核心数据，确保最终一致性。”</li></ul></li></ol><h2 id="4-你提到用Redis的Pub-Sub来广播失效Caffeine本地缓存。"><a href="#4-你提到用Redis的Pub-Sub来广播失效Caffeine本地缓存。" class="headerlink" title="4.你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。"></a>4.<strong>你提到用Redis的Pub/Sub来广播失效Caffeine本地缓存。</strong></h2><p><strong>Pub/Sub是‘fire-and-forget’（即发即忘）模式，不保证消息必达。如果某个应用实例因为网络抖动没收到失效消息，怎么办？</strong></p><p>您观察得非常仔细，Pub/Sub确实存在消息丢失的风险。对于这个问题，我们有分层级的解决方案</p><ol><li><strong>接受短暂不一致</strong>：对于大部分业务场景，单台服务器上短暂的本地缓存不一致是可以接受的。因为流量通常会通过负载均衡打到多台服务器上，只有一小部分用户请求会命中这台机器的旧缓存，且Caffeine本身也有过期机制，影响是可控的。</li><li><strong>引入更可靠的消息总线</strong>：如果业务对一致性要求极高，我们会放弃轻量级的Pub/Sub，转而使用<strong>更可靠的消息中间件（如RocketMQ）的广播消费模式</strong>。每个应用实例都作为一个消费者组内的广播消费者，订阅失效通知。MQ的ACK机制可以保证每个实例都可靠地收到失效消息。</li><li><strong>版本号机制</strong>：我们可以在缓存的对象中增加一个<strong>版本号或时间戳字段</strong>。当应用从缓存中获取到数据后，可以（在某些关键操作前）与数据库中的版本号进行一次快速比对。如果发现缓存版本落后，就主动失效本地缓存并重新加载。这是一种<strong>主动校验</strong>的补偿机制。”</li></ol><h2 id="5-缓存三问题"><a href="#5-缓存三问题" class="headerlink" title="5.缓存三问题"></a>5.缓存三问题</h2><p><strong>布隆过滤器和缓存空值，这两种方案在你的项目中，你会如何选择？它们各自有什么优缺点和需要注意的地方？</strong></p><p><strong>方案一：缓存空值（Cache Null Values）</strong></p><ul><li><p>优点：</p><ul><li><strong>实现简单</strong>：逻辑清晰，开发和维护成本极低。</li><li><strong>效果直接</strong>：能100%拦截住对同一个不存在的key的重复攻击。</li></ul></li><li><p>缺点与注意事项：</p><ul><li><strong>消耗额外的缓存空间</strong>：如果被恶意攻击，攻击者不断变换不存在的key来查询，会导致Redis中存储大量的空值key，造成内存浪费。</li><li><strong>数据一致性问题</strong>：如果这个之前不存在的数据，后来又在数据库中被创建了（例如，一个新用户注册了），缓存中的空值需要有一种机制被及时地更新或失效，否则会导致用户刚注册完却查不到自己的信息。</li></ul><p>适用于<strong>不存在的key的集合相对固定，或者重复查询率高</strong>的场景。例如，查询一个已经下架的商品</p></li></ul><p><strong>方案二：布隆过滤器（Bloom Filter）</strong></p><ul><li>优点：<ul><li><strong>空间效率极高</strong>：它使用位图（bitmap）来存储数据，占用的内存空间远小于缓存空值方案，非常适合处理海量数据。</li></ul></li><li>缺点与注意事项：<ul><li><strong>存在误判率（False Positive）</strong>：布隆过滤器判断“不存在”是100%准确的，但判断“存在”时，有一定概率会把一个不存在的key误判为存在。这意味着它无法完全拦截所有穿透请求，会有一小部分漏网之鱼打到数据库。</li><li><strong>无法删除元素</strong>：标准的布隆过滤器不支持删除操作。如果数据需要频繁地增删，就需要使用Counting Bloom Filter等变种，实现更复杂。</li><li><strong>初始化和重建成本</strong>：需要在系统启动时，将全量数据加载到布隆过滤器中，这个过程可能比较耗时。当数据发生变化时，也需要有机制来同步更新过滤器。</li></ul></li><li><strong>适用场景</strong>：适用于<strong>数据量巨大，但数据相对稳定，且对误判率有一定容忍度</strong>的场景。例如，防止恶意用户用随机生成的ID来攻击用户查询接口。</li></ul><h2 id="6-用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用-Redis，你会选择哪种数据结构来实现"><a href="#6-用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用-Redis，你会选择哪种数据结构来实现" class="headerlink" title="6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现"></a>6.用户在10分钟之内连续输错三次密码，就禁止其登录”。如果使用 Redis，你会选择哪种数据结构来实现</h2><p>方案1：使用String</p><p>Redis的<code>INCR</code>命令是原子性的，可以保证在并发环境下计数的准确性。<code>EXPIRE</code>命令可以为一个key设置生存时间（TTL），完美地契合了“10分钟之内”这个时间窗口的需求。</p><ol><li><strong>定义Key</strong>：为每个用户的登录失败计数定义一个清晰的Key，例如：<code>login:fail:count:&#123;userId&#125;</code>。</li><li>登录失败逻辑：当用户登录失败时，执行以下操作：<ul><li>对该用户的Key执行<code>INCR</code>命令，获取增长后的计数值：<code>count = redis.incr(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>。</li><li><strong>判断是否是第一次失败</strong>：如果<code>count</code>等于1，说明这是10分钟窗口内的第一次失败。此时，必须为这个Key设置过期时间：<code>redis.expire(&quot;login:fail:count:&#123;userId&#125;&quot;, 600)</code> (600秒 = 10分钟)。</li><li><strong>检查是否达到阈值</strong>：判断<code>count</code>是否大于等于3。如果是，则触发锁定用户的逻辑（例如，在数据库中更新用户状态，或在另一个Redis Key中设置一个锁定标记）。</li></ul></li><li><strong>登录成功逻辑</strong>：当用户登录成功时，应该<strong>立即删除</strong>这个计数Key：<code>redis.del(&quot;login:fail:count:&#123;userId&#125;&quot;)</code>，以清除之前的失败记录。</li></ol><p>问题：</p><ul><li>存在一个微小的<strong>竞态条件（Race Condition）</strong>：在<code>INCR</code>和<code>EXPIRE</code>两个命令之间，如果服务器恰好宕机或重启，可能会导致一个计数Key被创建但<strong>没有设置过期时间</strong>，从而变成一个永久的计数器。虽然概率极低，但在高并发系统中仍需考虑。</li><li><strong>解决方案</strong>：可以使用<strong>Lua脚本</strong>将<code>INCR</code>和<code>EXPIRE</code>两个操作打包成一个原子操作，或者使用一条Redis命令完成</li></ul><p>方案2：<strong>灵活精确 - List 作为失败记录队列</strong></p><p>Redis的<code>List</code>是一个双向链表，可以作为队列使用。通过<code>LPUSH</code>在队头插入元素，<code>LTRIM</code>修剪队列长度，可以非常高效地维护一个固定大小的事件窗口。</p><ol><li><strong>定义Key</strong>：<code>login:fail:log:&#123;userId&#125;</code>。</li><li>登录失败逻辑：<ul><li>获取当前时间戳（秒或毫秒），并将其作为元素<code>LPUSH</code>到List的头部：<code>redis.lpush(&quot;login:fail:log:&#123;userId&#125;&quot;, System.currentTimeMillis())</code>。</li><li><strong>检查当前失败次数</strong>：获取List的长度<code>llen</code>。</li><li>如果<code>llen</code>大于等于3，说明已经发生了至少3次失败。此时，获取List中<strong>第3个元素</strong>（即最早的那次失败记录，索引为2）：<code>third_attempt_time = redis.lindex(&quot;login:fail:log:&#123;userId&#125;&quot;, 2)</code>。</li><li><strong>判断时间窗口</strong>：计算当前时间与<code>third_attempt_time</code>的时间差。如果差值小于10分钟，则说明在10分钟内发生了3次失败，触发锁定逻辑。</li></ul></li><li><strong>队列维护</strong>：为了防止List无限增长，可以在每次<code>LPUSH</code>后，使用<code>LTRIM</code>命令只保留最近的3条记录：<code>redis.ltrim(&quot;login:fail:log:&#123;userId&#125;&quot;, 0, 2)</code>。同时，为整个Key设置一个比10分钟稍长的过期时间，如11分钟，用于自动清理冷数据。</li><li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li></ol><ul><li>实现了精确的时间窗口判断。</li><li>内存占用非常小，因为每个用户的Key最多只存储3个时间戳。</li></ul><p><strong>方案三：功能强大 - ZSET (Sorted Set) 实现滑动时间窗口</strong></p><p> Redis的<code>ZSET</code>是一个有序集合，每个成员都关联一个<code>score</code>。我们可以用<code>score</code>来存储事件发生的时间戳，利用<code>ZSET</code>按分数范围查询和删除的特性，完美地实现<strong>滑动时间窗口</strong>。</p><ol><li><strong>定义Key</strong>：<code>login:fail:zset:&#123;userId&#125;</code>。</li><li>登录失败逻辑：<ul><li>获取当前时间戳<code>now</code>。</li><li>为了防止成员重复，可以给每个成员一个唯一的值，例如<code>now + &quot;:&quot; + Math.random()</code>。</li><li>将新的失败记录添加到ZSET中，<code>score</code>和<code>member</code>都使用时间戳（或<code>score</code>是时间戳，<code>member</code>是唯一ID）：<code>redis.zadd(&quot;login:fail:zset:&#123;userId&#125;&quot;, now, now)</code>。</li><li><strong>清理过期记录</strong>：移除所有10分钟之前的记录，这是一个非常关键的步骤，保证了窗口的滑动：<code>redis.zremrangebyscore(&quot;login:fail:zset:&#123;userId&#125;&quot;, 0, now - 600000)</code> (假设<code>now</code>是毫秒)。</li><li><strong>统计窗口内次数</strong>：获取当前ZSET中的成员数量：<code>count = redis.zcard(&quot;login:fail:zset:&#123;userId&#125;&quot;)</code>。</li><li><strong>检查阈值</strong>：如果<code>count</code>大于等于3，触发锁定逻辑。</li></ul></li><li><strong>登录成功逻辑</strong>：同方案一，<code>DEL</code>掉对应的Key。</li></ol><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="1-消息队列（MQ）消息积压处理"><a href="#1-消息队列（MQ）消息积压处理" class="headerlink" title="1.消息队列（MQ）消息积压处理"></a>1.<strong>消息队列（MQ）消息积压处理</strong></h2><p>当被问及线上Topic消息积压如何处理时，你的第一反应是“清空队列，然后恢复”，这在线上环境中是绝对禁止的操作。在引导下，你提到了扩容消费者。</p><p>方案1 <strong>紧急扩容消费者并监控下游依赖</strong></p><ol><li><strong>监控分析</strong>：在扩容前，必须先快速查看消费者应用的CPU、内存、GC情况，以及其下游依赖（如数据库、外部API）的负载情况。<strong>确认瓶颈在于消费者本身，而不是下游</strong>。</li><li><strong>水平扩容</strong>：如果瓶颈在消费者，立即增加消费者实例数量。在Kubernetes等云原生环境中，可以通过调整Deployment的replica数量快速实现。</li><li><strong>注意Partition数量</strong>：确保消费者实例数<strong>不超过</strong>Topic的Partition数量，因为多余的消费者将处于空闲状态。</li></ol><p>方案2 <strong>消息转储与异步回补</strong></p><ol><li><strong>编写转储程序</strong>：快速开发一个简单的程序，它的唯一作用就是消费积压Topic中的消息，然后原封不动地存储到另一个临时Topic或一个临时存储（如文件、数据库）中。</li><li><strong>启动转储</strong>：启动该程序，快速将积压消息“搬空”。</li><li><strong>修复与回补</strong>：在修复了原始消费者的Bug或性能问题后，再编写一个回补程序，以一个受控的速率，从临时Topic或存储中读取消息，重新发送回原始Topic进行处理。</li></ol><p>以空间换时间，快速恢复线上新消息的处理能力，为修复问题和处理积压数据赢得时间。</p><p>方案3 <strong>优化消费逻辑并临时提升处理能力</strong></p><ol><li>代码审查：快速排查消费逻辑，寻找性能瓶颈。常见的优化点包括：<ul><li>将单条处理改为<strong>批量处理</strong>。</li><li>将同步调用外部API改为<strong>异步并行</strong>调用。</li><li>优化SQL查询，减少不必要的数据库交互。</li></ul></li><li><strong>紧急上线</strong>：快速修复并上线优化后的代码。</li></ol><p>比如说：</p><p><strong>你提到扩容消费者来解决积压。假设现在是双十一零点，流量洪峰导致了严重积压，而下游的数据库集群负载也已经很高了。此时你作为负责人，应该如何决策？直接扩容消费者吗？</strong></p><p>面试官，这是一个非常经典的<strong>‘雪崩前兆’</strong>场景，决策的核心是<strong>‘止损和降级’</strong>，而不是盲目地增加压力。我的决策流程会是这样的</p><ol><li><strong>立即止损，保护核心系统</strong>，绝对不能直接扩容消费者！ 因为监控显示下游数据库已经高负载，扩容消费者只会变成压垮数据库的最后一根稻草，导致核心系统崩溃，造成更大的故障。 <em>立即对消费者进行限流甚至暂停<em>*。我会立即调整消费者的消费速率，甚至在极端情况下，通过配置中心或运维指令，</em></em>暂停非核心业务的消费，优先保住数据库的稳定。</li><li><strong>业务降级，保障核心链路</strong> <em> 我会立即与产品和业务方沟通，启动<strong>业务降级预案</strong>。例如： </em> <strong>关闭非核心功能</strong>：暂时关闭‘实时用户积分更新’、‘推荐商品刷新’等非核心功能的消费，将MQ资源和数据库资源全部让给<strong>核心交易链路</strong>（如下单、支付）。 <em> <em>*异步转同步</em></em>：对于某些可以接受延迟的业务，可以暂时将消息积-压在MQ中，等高峰期过后，系统负载降低了再慢慢处理。</li><li><strong>流量削峰与后续处理</strong> <em> <strong>利用MQ的积压能力</strong>：此时，MQ本身就扮演了一个<strong>天然的流量削峰器</strong>的角色。大量的请求被积压在队列中，而不是直接冲击后端系统，这正是我们使用MQ的一个重要原因。 </em> <strong>高峰后恢复</strong>：等到流量洪峰过去，数据库负载下降后，我们再<strong>逐步、分批地</strong>恢复被暂停的消费者，并可以适当地<strong>增加消费者实例</strong>，以一个受控的速率，慢慢地将积压的消息消费完毕。</li><li><strong>复盘与改进</strong> * 事后，我们会进行深入复盘。分析是数据库容量预估不足，还是SQL存在性能问题，或者是消费者逻辑有待优化。并根据分析结果，进行数据库扩容、SQL优化、或引入更精细化的流量控制策略，为下一次大促做好准备。</li></ol><p>我的核心决策原则是：<strong>牺牲非核心业务的实时性，来换取核心系统的稳定性和可用性。</strong></p><h2 id="2-消费者组的对应"><a href="#2-消费者组的对应" class="headerlink" title="2.消费者组的对应"></a>2.消费者组的对应</h2><p>你刚刚说的就是一个消费者端，然后去对应一个相当于一个partition，然后为什么要一一对应呢？</p><p><strong>核心原因：保证分区内的消息顺序性（Message Ordering Guarantee）</strong></p><p>‘一个Partition在同一个消费者组内，同一时间只能被一个Consumer消费</p><ul><li><strong>理论依据</strong>：Kafka只在<strong>单个Partition内部</strong>保证消息的有序性。也就是说，生产者以1, 2, 3的顺序发送到同一个Partition的消息，消费者也必须以1, 2, 3的顺序来消费它们。</li><li><strong>机制实现</strong>：为了实现这个保证，Kafka必须规定，一个Partition在任意时刻，只能被一个消费者实例“锁定”并消费。<strong>如果允许多个消费者同时消费同一个Partition，那么消息的消费顺序将无法得到保证</strong>，因为无法协调哪个消费者先处理哪条消息，这将彻底破坏Kafka的顺序性承诺。</li></ul><p><strong>实现高并发：以Partition为并行处理的最小单元</strong></p><ul><li><strong>理论依据</strong>：虽然单个Partition是顺序处理的，但Kafka通过<strong>将一个Topic划分为多个Partition</strong>来实F现整体的高并发。</li><li><strong>机制实现</strong>：整个Topic的吞吐量等于所有Partition吞吐量的总和。我们可以通过增加Partition的数量，来水平扩展Topic的处理能力。</li><li><strong>消费者协同</strong>：消费者组（Consumer Group）内的多个消费者实例会通过<strong>Rebalance（再均衡）\</strong>机制，自动协调分配它们各自负责消费的Partition。例如，一个有10个Partition的Topic，如果消费者组有10个消费者，理想情况下就是每个消费者负责一个Partition，此时*<em>并行度达到最大*</em>。</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-当被问及如何在多个接口中统一管理以避免代码重复时"><a href="#1-当被问及如何在多个接口中统一管理以避免代码重复时" class="headerlink" title="1.当被问及如何在多个接口中统一管理以避免代码重复时"></a>1.当被问及如何在多个接口中统一管理以避免代码重复时</h2><p>你的初步想法是提取一个公共方法。面试官进一步引导你思考过滤器和拦截器。</p><p>方案1：<strong>使用Spring MVC的<code>HandlerInterceptor</code>（拦截器）</strong></p><p><code>HandlerInterceptor</code>是Spring MVC提供的AOP实现，专门用于在Controller方法执行前后进行预处理和后处理。它与请求生命周期紧密耦合，是处理用户认证、日志记录、上下文设置等横切关注点的标准方式。</p><ol><li>创建一个类实现<code>HandlerInterceptor</code>接口。</li><li>在<code>preHandle</code>方法中，从请求（如Header）中获取Token，解析出用户信息，然后调用工具类的<code>set()</code>方法将用户信息存入<code>ThreadLocal</code>。</li><li>在<code>afterCompletion</code>方法中，无论Controller方法执行成功还是失败，都调用工具类的<code>remove()</code>方法清理<code>ThreadLocal</code>，通常放在<code>finally</code>块中以确保执行。</li><li>创建一个配置类实现<code>WebMvcConfigurer</code>，重写<code>addInterceptors</code>方法，将你的拦截器注册到Spring容器中，并配置其拦截路径（如<code>/api/**</code>）。</li></ol><p>方案2：<strong>使用Servlet的<code>Filter</code>（过滤器）</strong></p><ol><li>创建一个类实现<code>javax.servlet.Filter</code>接口。</li><li>在<code>doFilter</code>方法中，在调用<code>chain.doFilter(request, response)</code>之前，执行<code>ThreadLocal</code>的<code>set()</code>操作。</li><li>使用<code>try...finally</code>结构，在<code>finally</code>块中执行<code>ThreadLocal</code>的<code>remove()</code>操作，确保无论后续处理是否异常，都能清理资源。</li><li>使用<code>@Component</code>和<code>@Order</code>注解（或通过<code>FilterRegistrationBean</code>）将Filter注册为Spring Bean。</li></ol><p>与<code>Interceptor</code>类似，实现了解耦和统一管理。由于作用范围更广，可以拦截静态资源等非Spring MVC处理的请求。</p><p>方案3：<strong>使用自定义AOP切面（<code>@Aspect</code>）</strong></p><ol><li>创建一个类，并使用<code>@Aspect</code>和<code>@Component</code>注解。</li><li>定义一个切点（Pointcut），例如<code>@Pointcut(&quot;within(@org.springframework.web.bind.annotation.RestController *)&quot;)</code>，用于匹配所有RestController类中的方法。</li><li>创建一个<code>@Around</code>环绕通知。在通知方法的<code>try</code>块中，执行<code>ThreadLocal</code>的<code>set()</code>操作，然后调用<code>proceedingJoinPoint.proceed()</code>执行目标方法。在<code>finally</code>块中，执行<code>remove()</code>操作。</li></ol><p>功能上与前两者类似，但提供了最大的灵活性，可以切入到Service层甚至任意Bean的方法。<code>@Around</code>通知需要手动调用<code>proceed()</code>，如果忘记调用，目标方法将不会被执行。</p><h2 id="2-策略方法怎么去解决具体调用哪一个策略"><a href="#2-策略方法怎么去解决具体调用哪一个策略" class="headerlink" title="2.策略方法怎么去解决具体调用哪一个策略"></a>2.策略方法怎么去解决具体调用哪一个策略</h2><ul><li>为了避免在业务代码中使用大量的<code>if-else</code>或<code>switch</code>来选择策略，我们创建了一个<strong>策略工厂（Strategy Factory）</strong>。</li></ul><ol><li>在项目启动时，Spring容器会扫描并加载所有<code>CouponStrategy</code>的实现类。</li><li>我们创建一个<code>CouponStrategyFactory</code>类，它在构造时注入一个<code>Map&lt;String, CouponStrategy&gt;</code>。Spring会自动将所有策略实现类注入到这个Map中，其中Key是Bean的名称（例如<code>&quot;fullDiscountStrategy&quot;</code>），Value是Bean实例。</li><li>我们约定优惠券类型（例如<code>&quot;FULL_DISCOUNT&quot;</code>, <code>&quot;PERCENTAGE_DISCOUNT&quot;</code>）与Bean名称有映射关系。</li><li>工厂类提供一个<code>getStrategy(String couponType)</code>方法。当业务代码需要使用某个策略时，它只需要传入优惠券类型字符串，工厂就会从Map中返回对应的策略对象。</li><li>我们完全消除了业务代码中的<code>if-else</code>判断。当未来需要增加一种新的优惠券时，我们只需要新增一个策略实现类，而不需要修改任何现有的业务逻辑代码，这完全符合<strong>开闭原则</strong>，使得系统非常易于扩展和维护。”</li></ol><h1 id="异常解决"><a href="#异常解决" class="headerlink" title="异常解决"></a>异常解决</h1><h2 id="1-就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢"><a href="#1-就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢" class="headerlink" title="1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢"></a>1.就比如说你这个部署到线上了，然后他抛了一个异常，然后那你这个应该怎么排查呢</h2><p>线上出现异常，我会遵循一套<strong>从宏观到微观、由表及里</strong>的排查SOP（标准作业程序）来定位和解决问题。</p><p><strong>第一步：信息收集与初步判断</strong></p><ol><li><p><strong>确认影响范围</strong>：首先，快速判断这个异常的影响面有多大。是影响了所有用户，还是部分用户？是核心功能还是边缘功能？这决定了问题的紧急程度。</p></li><li><p>查看监控告警：立即查看监控系统（如Prometheus/Grafana, Zabbix）的告警信息。检查应用的</p><p>关键指标，如：</p><ul><li><strong>应用层面</strong>：QPS、响应时间（RT）、错误率（Error Rate）是否突增？</li><li><strong>JVM层面</strong>：CPU使用率、内存占用、GC活动是否异常？</li><li><strong>主机层面</strong>：服务器的CPU、内存、磁盘I/O、网络流量是否正常？</li><li><strong>依赖服务</strong>：数据库、Redis、MQ等中间件的健康状况如何？</li><li>这一步的目标是快速定位问题是出在<strong>应用本身</strong>，还是<strong>外部依赖</strong>。</li></ul></li></ol><p><strong>第二步：日志分析与精准定位</strong></p><ol><li><strong>聚合日志平台检索</strong>：登录ELK（Elasticsearch, Logstash, Kibana）或类似日志平台，根据告警信息中的时间点、错误信息关键字（如<code>RuntimeException</code>）进行检索。</li><li><strong>利用Trace ID进行链路追踪</strong>：如果系统接入了分布式追踪系统（如SkyWalking, Zipkin），这是最强大的工具。我会根据报错信息找到一个<strong>Trace ID</strong>，然后用这个ID查询完整的请求调用链。这可以清晰地看到请求经过了哪些服务，在哪一个环节耗时最长，又是在哪个服务的具体代码行抛出了异常。</li><li>Linux服务器手动排查（作为补充）：如果日志平台不完善，我会登录到具体的服务器上进行排查。<ul><li>使用<code>grep</code>命令根据关键字快速过滤日志：<code>grep -C 10 &#39;ExceptionNameToFind&#39; /path/to/app.log</code>。<code>-C 10</code>可以显示异常上下文的10行，帮助理解问题背景。</li><li>如果需要根据Trace ID查，我会用：<code>grep &#39;your-trace-id&#39; /path/to/app.log</code>。</li><li>对于实时滚动的日志，我会用<code>tail -f /path/to/app.log | grep &#39;ERROR&#39;</code>来实时监控错误输出。</li></ul></li></ol><p>第三步：<strong>根因分析与问题复现</strong></p><ol><li><strong>代码分析</strong>：定位到具体的异常代码后，分析代码逻辑，判断是业务逻辑错误、空指针、并发问题还是资源未释放等。</li><li><strong>环境复现</strong>：如果可能，尝试在测试环境或预发环境，构造相同的参数和条件，复现这个问题，以便于调试和验证修复方案。</li></ol><p>第四步：<strong>问题解决与复盘</strong></p><ol><li><strong>紧急修复</strong>：如果是严重Bug，立即进行Hotfix修复并上线。如果是资源问题，进行扩容或配置调整。</li><li><strong>复盘总结</strong>：问题解决后，必须进行复盘。分析问题发生的根本原因，是代码缺陷、设计不合理、还是容量预估不足？并制定改进措施，例如增加单元测试、完善监控告警、优化架构等，防止同类问题再次发生。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/14/%E5%B7%A5%E4%BD%9C/towork/workpro1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javase面试-深入源码</title>
      <link>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/</link>
      <guid>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/</guid>
      <pubDate>Mon, 11 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;javase源码详解&quot;&gt;&lt;a href=&quot;#javase源码详解&quot; class=&quot;headerlink&quot; title=&quot;javase源码详解&quot;&gt;&lt;/a&gt;javase源码详解&lt;/h1&gt;&lt;h2 id=&quot;1-和equal-和hashcode&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="javase源码详解"><a href="#javase源码详解" class="headerlink" title="javase源码详解"></a>javase源码详解</h1><h2 id="1-和equal-和hashcode"><a href="#1-和equal-和hashcode" class="headerlink" title="1.==和equal()和hashcode"></a>1.==和equal()和hashcode</h2><p>==和equals函数对于基本类型来说， = = 比较是值，equals不能比较基本类型</p><p>对于包装类型来说，== 比较的是对象的引用，就是对象的内存地址。而<code>equals()</code>通常被重写以比较对象的值。</p><p>需要注意的是，像Interger这种包装类具有缓存机制，如果在缓存的范围，==的结果可能就是true，因为他们都是指向常量池的同一个对象</p><p>对于引用类型来说，==比较的是其对象的内存地址，equals要分为两个情况，看这个类型到底重写了equals函数了没，重写了就按重写的比较，比如String类型，他的equals就是比较的对象的值。然后没有重写的话，equals内部还是使用 ==来比较。没有什么区别。还是比较的对象的内存地址</p><p>hashcode函数的作用是获取哈希码，然后确定该对象再hash表中的位置，比如hashmap,hashset,布隆过滤器等都用到了hashcode</p><p>hasecode分为好几种哈希函数，有取模的，有进行位运算的。我们在布隆过滤器中使用最好是使用两种hash函数来确定位的位置。</p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的</p><p>然后hashcode相同，equals不一定相同。hashcode不相同，这个对象一定不相同。这样的话，我们可以将hashcode和equals函数相结合。我们先用hash函数来判断，然后再用equals判断</p><p>如果这个对象真的不相同的话，那我们就可以用运行速度快的hash函数早判断。然后出现hash碰撞的时候我们再用equals函数来确定是不是真的相同。这样大大提高了效率，因为hash函数的运算是比equals快的。这也是hashmap,hashset，布隆过滤器的设计原理。</p><p>因此，我们在重写equals的时候，hashcode也必须重写，否则就会出现equals相等，但是hash不相同。就会出现重复值的问题</p><h2 id="2-BigDecimial处理精度丢失的问题"><a href="#2-BigDecimial处理精度丢失的问题" class="headerlink" title="2.BigDecimial处理精度丢失的问题"></a>2.BigDecimial处理精度丢失的问题</h2><p><code>BigDecimal</code>是Java中用于处理高精度数值计算的类，尤其适用于金融、科学计算等对精度要求极高的场景。</p><p>最关键的就是两个字段：</p><ul><li><code>intVal</code>: 一个<code>BigInteger</code>对象，用于存储数值的<strong>非标度值 (unscaled value)</strong>。简单来说，就是去掉小数点后的整数值。</li><li><code>scale</code>: 一个<code>int</code>类型的整数，表示<strong>标度 (scale)</strong>。标度指的是小数点后的位数。例如，对于数值 123.45，<code>intVal</code>是12345，<code>scale</code>是2。</li></ul><p><code>BigDecimal</code> <strong>使用整数来表示数值，避免了浮点数的二进制表示法引入的精度问题。</strong> 它通过<code>scale</code>来记录小数点的位置，从而实现对小数的精确表示。</p><p>BigDecimal的运算都是基于BigInterger来实现的</p><ul><li><p>加减法的时候，调整两个数的sacle，对齐标度，然后将intval相加减，最好创建一个新的BigDecial对象，intval为相加减的结果，scale为调整后的标度</p></li><li><p>乘法，将两个数的intval想乘，然后scale为两个BigDecimal的scale的和</p></li><li><p>除法是最复杂的操作，因为可能产生无限循环小数，<code>BigDecimal</code>需要提供多种舍入模式 (RoundingMode) 来控制精度，比如</p><ul><li><p><code>ROUND_UP</code>: 向上舍入</p></li><li><p><code>ROUND_DOWN</code>: 向下舍入</p></li><li><p><code>ROUND_CEILING</code>: 向正无穷方向舍入</p></li><li><p><code>ROUND_FLOOR</code>: 向负无穷方向舍入</p></li><li><p><code>ROUND_HALF_UP</code>: 四舍五入 (大于等于0.5向上舍入)</p></li><li><p><code>ROUND_HALF_DOWN</code>: 五舍六入 (大于0.5向上舍入)</p></li><li><p><code>ROUND_HALF_EVEN</code>: 银行家舍入 (四舍六入，五看奇偶，偶舍奇入)<code>BigDecimal</code>会根据指定的舍入模式，计算出精确的结果，并截断到指定的精度。</p></li></ul></li></ul><p>但是会出现很多个BigDecimal对象：Bigdecimal 是一个immutable类，每次计算都会new一个新的对象。如果在一个循环内多次使用bigdecimal，会生成很多对象，影响性能，建议如果在循化内不要使用string 构造出bigdecimal, 否则生成大量的string对象和bigdecimal对象</p><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><p>成员变量&amp;&amp;局部变量对比—变量存储的内存地址对应的任意随机值</p><ul><li>定义：成员变量是属于类的，局部变量是在代码块或者方法之中的</li><li>存储：成员变量如果是使用static的话，那这个成员变量属于类，没有的话，在堆。局部变量在栈，栈之中维护了一个局部变量表</li><li>生存时间：成员变量是对象的一部分，跟对象的生命周期一样，局部变量跟他的方法的生命周期一样</li><li>默认值：成员变量没有被赋值的话，一般都会是类型的默认值，除非是final修饰的，必须显示的赋值，局部变量不赋值会报错。</li></ul><div class="table-container"><table><thead><tr><th>特性</th><th>成员变量 (Instance Variable)</th><th>成员变量 (Static Variable)</th><th>局部变量 (Local Variable)</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>属于类的属性，在类中方法外定义。</td><td>属于类的静态属性，在类中方法外定义，用<code>static</code>修饰。</td><td>在方法、代码块（如<code>if</code>、<code>for</code>语句内部）中定义的变量。</td></tr><tr><td><strong>存储</strong></td><td>存储在堆内存（Heap）中，作为对象的一部分。</td><td>存储在方法区（Method Area）或元空间(Metaspace)中。（JDK8+之后静态变量从方法区移动到了堆中，但逻辑概念上仍与类相关联）</td><td>存储在Java虚拟机栈（Java Virtual Machine Stack）的栈帧（Stack Frame）的局部变量表中。</td></tr><tr><td><strong>生命周期</strong></td><td>随着对象的创建而创建，随着对象的销毁而销毁。</td><td>随着类的加载而创建，随着类的卸载而销毁。（实际上与类的 Class 对象关联）</td><td>随着方法的调用而创建，随着方法的执行结束而销毁。</td></tr><tr><td><strong>默认值</strong></td><td>存在默认值。如果没有显式赋值，会赋予类型的默认值（如<code>int</code>为0，<code>boolean</code>为<code>false</code>，<code>Object</code>为<code>null</code>）。</td><td>static 变量在类加载的准备阶段就会赋默认值. 如果没有显式赋值，会赋予类型的默认值（如<code>int</code>为0，<code>boolean</code>为<code>false</code>，<code>Object</code>为<code>null</code>）。</td><td>不存在默认值。<strong>必须显式赋值</strong>后才能使用，否则编译报错。</td></tr><tr><td><strong>final修饰</strong></td><td><code>final</code>修饰的成员变量必须在对象创建前（构造器或声明时）显式赋值，之后不能修改。</td><td><code>final static</code>修饰的成员变量必须在类加载完成前（静态代码块或声明时）显式赋值，之后不能修改。</td><td><code>final</code>修饰的局部变量必须在使用前显式赋值，之后不能修改。</td></tr><tr><td><strong>线程安全</strong></td><td>线程不安全，每个对象都有一份独立的成员变量副本，如果多个线程修改同一个对象的成员变量，可能导致数据不一致。</td><td>线程安全，所有该类的对象共享同一个静态变量，需要进行同步处理才能保证线程安全。</td><td>线程安全，局部变量只在当前线程的栈帧中有效，不同线程之间互不影响。</td></tr></tbody></table></div><h2 id="4-String家族三位"><a href="#4-String家族三位" class="headerlink" title="4.String家族三位"></a>4.String家族三位</h2><p>String家族的三位分别是String StringBuffer StringBulider，除去String,剩下的两个都是继承自AbstractStringBuilder</p><p>其中String是不可变的，StringBuffer和StringBulider是可变的，他们都有append等方法来操作字符串</p><p>不同的是StringBuffer是线程安全的，通过同步锁加到方法上，可以多线程操作，而StringBulider是线程不安全的，一般单线程操作。因此StringBulider的性能是最高的</p><p>那么为什么String是不可变的呢？</p><p>String类中使用final来修饰字符串数组来，导致他的引用类型不能再指向其他的对象，并且数组的私有的。并且没有提供暴露这个字符串的方法</p><p>final导致String不能被继承，进而避免了子类破坏String</p><p>字符串拼接使用什么？变量少的时候使用+，然后变量多的时候使用StringBulider，防止在循环中使用，建立多个StringBulider对象</p><p>在我们JVM的堆中，存在一个字符串常量池，主要就是为了避免字符串的重复的问题</p><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>我们去new一个新的字符串的时候，会看字符串常量池有没有这个字符串，有的话，直接返回该字符串的引用。没有的话，JVM会在常量池中创建该字符，然后返回他的引用，也就是说我们新建了两个对象</p><h2 id="5-常见的IO-amp-amp-拷贝"><a href="#5-常见的IO-amp-amp-拷贝" class="headerlink" title="5.常见的IO&amp;&amp;拷贝"></a>5.常见的IO&amp;&amp;拷贝</h2><p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p><p>我们的用户进程想要进行IO操作的话，必须通过系统调用来访问内核空间，也就是拷贝，从用户态转变为内核态进行拷贝</p><p>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</p><p>常见的IO模型：</p><p><strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><p>在我们的java中，有三种常见的IO</p><p>BIO：属于同步堵塞的IO，同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。在客户端连接数量不高的情况下，是没问题的。但是高了就没办法了</p><p>NIO：Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>同步非阻塞 IO，发起一个 read 调用，如果数据没有准备好，这个时候应用程序可以不阻塞等待，而是切换去做一些小的计算任务，然后很快回来继续发起 read 调用，也就是轮询。这个<br> 轮询不是持续不断发起的，会有间隙, 这个间隙的利用就是同步非阻塞 IO 比同步阻塞 IO 高效的地方。</p><p>但是这样有问题的，程序需要不断进行IO系统轮询来判断是不是准备好了,然后就出现了我的IO多路复用</p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><p>线程通过<code>select</code>、<code>poll</code>或<code>epoll</code>等系统调用，<strong>监听多个文件描述符（File Descriptor, FD）</strong>，一旦某个FD就绪（可读、可写），就通知应用程序。</p></li><li><p><strong>select 调用</strong>：最大连接数有限制（通常是1024），由<code>FD_SETSIZE</code>决定。每次调用都需要将FD集合从用户空间拷贝到内核空间，开销大。内核采用轮询方式检查FD是否就绪，效率低。</p></li><li>poll调用：取消了最大连接数的限制。同样需要将FD集合拷贝到内核空间。</li><li><strong>epoll 调用</strong>：基于事件驱动，只关注就绪的FD，避免了无意义的轮询。采用红黑树存储FD，查找效率高。使用<code>mmap</code>技术，减少了用户空间和内核空间之间的数据拷贝。</li></ul><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>而我们java中的NIO,最重要的三个组件，<strong>Selector</strong> ，Buffer，Channel</p><p>通过<strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。然后数据通过Channel让客户端将数据写入到Buffer中去</p><ul><li><code>Channel</code>: <strong>代表一个连接通道，负责数据的读写。</strong> <code>Channel</code> 类似于传统 I/O 中的流 (Stream)，但更加灵活，可以进行双向数据传输。</li><li><code>Buffer</code>: <strong>缓冲区，用于存储数据。</strong> NIO 使用缓冲区来读写数据，而不是直接操作流。 Java NIO 支持多种类型的缓冲区，例如 <code>ByteBuffer</code>、<code>CharBuffer</code>、<code>IntBuffer</code> 等。</li><li><code>Selector</code>: <strong>多路复用器，用于监听多个<code>Channel</code>的事件。</strong> 一个 <code>Selector</code> 可以同时监听多个 <code>Channel</code> 的连接、读、写等事件。 通过 Selector， 只需要一个线程即可管理多个 Channel，实现高效的 I/O 多路复用。</li><li><strong>Reactor模式和Proactor模式：</strong> 是两种常用的并发编程模式，分别对应I/O多路复用和异步I/O。 Netty 采用了 Reactor模式。</li></ul><p>AIO：</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>然后我们需要数据进行传输的时候，就需要对数据进行拷贝。比如用户进程在从硬盘里传输数据的时候，需要从用户态转为内核态然后才能进行拷贝。这样的话，效率比较慢，然后我们就出现了零拷贝技术</p><p>传统的数据传输流程中，用户数据通常会经过如下多次拷贝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘 → 内核缓冲区 → 用户态 → Socket 缓冲区 → 网卡</span><br></pre></td></tr></table></figure><p>一般来说文件拷贝是要拷贝四次的，</p><p>当用户进程调用<code>read()</code>，用户态无法调用内核态的设备，只能触发系统调用（IO）。这时计算机需要从用户态切换为内核态。</p><p>到达内核态之后，计算机通过<code>DMA</code>控制器将数据从磁盘读取出来，放到内核的缓冲区。完成第一次拷贝。</p><p>CPU需要将缓冲区的数据拷贝到用户态的缓冲区，完成第二次拷贝，也是read()函数的返回。这时计算器需要从内核态切换为用户态。</p><p>因为最终的数据需要通过网卡输出，所以用户进程就需要调用<code>write()</code>函数，CPU将用户缓冲区的数据拷贝到<code>Socket</code>缓冲区，完成第三次拷贝。同时需要再次触发系统调用。这时计算机又需要从用户态切换为内核态。</p><p><code>DMA</code>控制器把数据从<code>Socket</code>缓冲区，拷贝到网卡设备输出，至此完成第四次拷贝。同时需要将内核态切换为用户态，<code>write()</code>函数返回。</p><p>而“零拷贝”技术通过内核优化和 API 支持，能<strong>避免数据在用户态与内核态间的多次拷贝</strong>，从而提升性能。常用技术：</p><div class="table-container"><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td><code>mmap</code></td><td>将文件映射到内存地址空间，避免文件拷贝</td></tr><tr><td><code>sendfile</code></td><td>直接将文件从磁盘发送到 Socket，避免数据进入用户态</td></tr><tr><td><code>writev</code></td><td>批量写入多个内存区域，减少系统调用</td></tr><tr><td><code>DirectByteBuffer</code>（Java NIO）</td><td>Java 堆外内存，提高 I/O 性能</td></tr></tbody></table></div><p>mmap</p><ul><li><code>mmap</code>将一个文件或者其他对象映射到进程的地址空间，实现<strong>文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一映射关系</strong>。应用程序可以直接读写映射的内存区域，而<strong>不需要进行显式的<code>read</code>和<code>write</code>系统调用</strong>。</li><li><strong>原理：</strong> <code>mmap</code> 减少了数据在内核空间和用户空间之间的拷贝。 只需要从磁盘拷贝到内核缓冲区，然后用户进程直接从内核缓冲区读取数据，而无需再拷贝到用户空间。</li><li><strong>适用场景：</strong> 适用于需要频繁读写同一文件的场景，例如大型数据库、共享内存等。</li><li>存在的问题：<ul><li><code>mmap</code> 对文件读写仍然需要两次上下文切换。</li><li>如果多个进程同时对同一文件进行<code>mmap</code>映射，可能会导致数据不一致的问题。</li></ul></li><li><strong>使用场景:</strong> 常用于读取静态资源。</li></ul><p><strong>sendfile()</strong></p><p>sendfile() 系统调用允许将数据从一个文件描述符 (例如， 文件)  直接传输到另一个文件描述符 (例如， Socket)。  避免了数据在用户空间和内核空间之间的拷贝。</p><ol><li>用户进程调用 <code>sendfile()</code> 系统调用， 指定输入和输出文件描述符。</li><li>数据通过 DMA 从磁盘读取到内核缓冲区。</li><li>数据直接从内核缓冲区拷贝到 Socket 缓冲区，或者更优的方式是：只有描述符信息从内核缓冲区拷贝到socket缓冲区。</li><li>数据通过 DMA 从 Socket 缓冲区传输到网卡。</li></ol><p>静态文件服务器（例如 Nginx）通常使用 sendfile() 来将静态文件发送给客户端。只能适用于数据从文件传输到Socket的场景，范围有限</p><p> <strong>splice() (管道):</strong></p><p>splice() 系统调用允许在两个文件描述符之间移动数据，而不需要在用户空间和内核空间之间进行复制。</p><ol><li>创建两个管道(pipe)对象</li><li>调用 splice() 系统调用,将数据从输入文件描述符读取到第一个管道.</li><li>调用 splice() 系统调用,将数据从管道数据写到socket 。</li></ol><p>适用于需要数据传输与转换(类似于Linux的管道操作)的场景</p><p><strong>Direct I/O</strong>：</p><p>Direct I/O 允许用户进程绕过内核缓冲区 (Page Cache)， 直接访问磁盘。</p><ol><li>用户进程发起 Direct I/O 请求。</li><li>数据通过 DMA 直接从磁盘传输到用户进程的缓冲区。</li></ol><ul><li>需要用户进程自己管理缓存，增加了开发的复杂性。</li><li>可能影响系统的整体性能， 因为绕过了 Page Cache。 （Page Cache 可以缓存热点数据，提高访问速度）。</li></ul><p>大型数据库（例如 Oracle）通常使用 Direct I/O 来进行数据读写， 因为数据库有自己的缓存管理机制。</p><p><strong><code>DirectByteBuffer</code> (Java NIO)：</strong></p><ul><li>是Java NIO 提供的一种堆外内存分配方式，它<strong>允许JVM直接在操作系统本地内存（堆外内存）中分配缓冲区，而不是在JVM堆中分配。</strong></li><li><strong>避免了数据从JVM堆内存拷贝到直接内存 (Native memory) 的过程。</strong></li><li><strong>适用场景：</strong> 适用于需要高效I/O的场景，例如网络服务器、大数据处理等。</li><li><strong>原理：</strong> <code>DirectByteBuffer</code>并不是真正意义上的零拷贝，因为它仍然需要在用户空间和内核空间之间进行数据拷贝。 但是，它可以减少一次数据拷贝，从而提高I/O性能。 通过调用操作系统的<code>read</code>方法，将数据从IO端口读取到这个直接内存。</li></ul><p>好处：</p><ul><li><strong>减少数据拷贝次数：</strong> 降低CPU的开销， 提高I/O效率。</li><li><strong>减少上下文切换次数：</strong> 降低系统开销， 提高并发能力。</li><li><strong>提高数据传输速度：</strong> 缩短响应时间， 提供更好的用户体验。</li></ul><h2 id="6-Java中的值传递"><a href="#6-Java中的值传递" class="headerlink" title="6.Java中的值传递"></a>6.Java中的值传递</h2><ul><li><strong>值传递</strong>：方法接收的是实参值的拷贝，会创建副本。</li><li><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li></ul><p>但是在java中只有值传递</p><p>比如我们设定一个简单的swap方法，交换值得方法，num1=a num2=b</p><p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p>再比如</p><p>我们设定一个swap方法，交换两个Person参数</p><p>然后我们发现<code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p><p>java值传参：</p><ul><li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li><li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li></ul><h2 id="7-序列化-amp-amp-反序列化"><a href="#7-序列化-amp-amp-反序列化" class="headerlink" title="7.序列化&amp;&amp;反序列化"></a>7.序列化&amp;&amp;反序列化</h2><ul><li><strong>序列化</strong>：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式</li><li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程</li></ul><p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化</li></ul><p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。</p><p>然后我们有好几种序列化的方式,jdk自带的效率低且有安全问题，比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><ul><li><p>jdk自带的序列化方式，只需要实现Serializable接口即可，我们一般会加上一个私有静态final的变量，serialVersionUID。是类似于版本控制的效果，如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。<code>serialVersionUID</code> 是一个特例，<code>serialVersionUID</code> 的序列化做了特殊处理。关键在于，<code>serialVersionUID</code> 不是作为对象状态的一部分被序列化的，而是被序列化机制本身用作一个特殊的“指纹”或“版本号”</p></li><li><p>对于我们不想进行序列化的变量，可以使用<code>transient</code> 关键字修饰。阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。<code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。除了serialVersionUID以外。</p></li><li>Kryo ，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。使用的时候也是需要实现Serializer接口，然后分别去重写serialize方法和deserialize方法</li><li>Protobuf，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</li><li>Protostuff，protostuff 基于 Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</li></ul><p>这些反序列化的话，会有漏洞</p><p>许多序列化协议都存在反序列化漏洞，攻击者可以通过构造恶意的序列化数据，在反序列化过程中执行任意代码，从而控制目标系统。比如kryo</p><ul><li>防止反序列化漏洞的措施：<ul><li>避免使用存在已知漏洞的序列化协议。</li><li>对序列化数据进行签名或加密，防止篡改。</li><li>使用白名单机制，只允许反序列化特定类型的对象。</li><li>限制反序列化的深度和复杂度，防止资源耗尽。</li></ul></li></ul><h2 id="8-Unsafe解析"><a href="#8-Unsafe解析" class="headerlink" title="8.Unsafe解析"></a>8.Unsafe解析</h2><p><code>Unsafe</code> 是位于 <code>sun.misc</code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等</p><p><code>Unsafe</code> 提供的这些功能的实现需要依赖本地方法（Native Method），本地方法使用 <strong><code>native</code></strong> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 <strong>本地代码</strong>。</p><p><code>Unsafe</code> 类为一单例实现，提供静态方法 <code>getUnsafe</code> 获取 <code>Unsafe</code>实例。这个看上去貌似可以用来获取 <code>Unsafe</code> 实例。但是，当我们直接调用这个静态方法的时候，会抛出 <code>SecurityException</code> 异常</p><p>这是因为在<code>getUnsafe</code>方法中，会对调用者的<code>classLoader</code>进行检查，判断当前类是否由<code>Bootstrap classLoader</code>加载，如果不是的话那么就会抛出一个<code>SecurityException</code>异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。</p><p>为什么这个类这么严格？<code>Unsafe</code> 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。</p><p>那我们该怎么去获取unsafe的实例呢？</p><ol><li>利用反射获得 Unsafe 类中已经实例化完成的单例对象 <code>theUnsafe</code> </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从<code>getUnsafe</code>方法的使用限制条件出发，通过 Java 命令行命令<code>-Xbootclasspath/a</code>把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过<code>Unsafe.getUnsafe</code>方法安全的获取 Unsafe 实例。</li></ol><p>Unsafe的功能多种多样，比如内存操作，内存屏障，对象操作，数据操作，CAS 操作，线程调度，Class 操作，系统信息</p><ol><li>内存操作：</li></ol><p>在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure><p>通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p><p>那我们为什么要使用堆外内存？</p><p>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</p><p>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</p><p>比如：<code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。类似实现了零拷贝的功能，但是其实他并没有实现零拷贝。创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放</p><ol><li>内存屏障：</li></ol><p>编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p><p>比如我们的voliate关键词就是通过内存屏障，来保证了禁止重排。主要是就是保证读写的屏障</p><p>内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能</p><p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p><p>应用：</p><p><code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p><p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p><ol><li>对象操作：</li></ol><p>对象成员属性的内存偏移量获取，以及字段属性值的修改</p><p>Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。</p><p>基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）</p><p><code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。</p><p><code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p><p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。</p><p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型。</p><p>其中：</p><ul><li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li><li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li></ul><p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p><ol><li>对象实例化：</li></ol><p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p><p><code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但<code>allocateInstance</code>方法仍然有效。</p><p>比如：</p><p>new 机制有个特点就是当类只提供有参的构造函数且无显式声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</p><p>Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用</p><p>5.数组操作：</p><p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回数组中第一个元素的偏移地址</span><br><span class="line">public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);</span><br><span class="line">//返回数组中一个元素占用的大小</span><br><span class="line">public native int arrayIndexScale(Class&lt;?&gt; arrayClass);</span><br></pre></td></tr></table></figure><p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code>、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作</p><ol><li>CAS</li></ol><p>CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p><p>在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p><p>如果 CAS 操作成功（返回 true），则打印 <code>targetValue</code> 并退出循环。</p><p>如果 CAS 操作失败，或者 <code>currentValue</code> 不满足条件，则当前线程会继续循环（自旋），并通过 <code>Thread.yield()</code> 尝试让出 CPU，直到成功更新并打印或者条件满足。</p><p>这样我们就可以通过CAS来实现多个线程1-9的顺序输出,a=0</p><p>线程1是 i&lt;5的情况，线程2是i&lt;10的情况</p><p>我们的CAS加的是(a,i-1,i);所以的话，线程一就是0-4的输出，线程2就是5-9.然后使用之前，我们要把获取unsafe实例和获取a字段的内存偏移量给静态加载进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 获取 a 字段的内存偏移量</span></span><br><span class="line">        fieldOffset = unsafe.objectFieldOffset(CasTest.class.getDeclaredField(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>线程调度</li></ol><p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure><p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常</p><p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code>、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code>、<code>unpark</code> 方式实现的</p><p>就是通过这个实现了CLH队列,减少了在等待队列里面消耗等待的时间</p><ol><li>Class操作</li></ol><p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取静态属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取静态属性的对象指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断类是否需要初始化（用于获取类的静态属性前进行检测）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure><p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code></p><h2 id="9-SPI机制"><a href="#9-SPI机制" class="headerlink" title="9.SPI机制"></a>9.SPI机制</h2><h2 id="10-语法糖"><a href="#10-语法糖" class="headerlink" title="10.语法糖"></a>10.语法糖</h2><h2 id="11-新特性（Java17-amp-amp-Java21）"><a href="#11-新特性（Java17-amp-amp-Java21）" class="headerlink" title="11.新特性（Java17&amp;&amp;Java21）"></a>11.新特性（Java17&amp;&amp;Java21）</h2><h3 id="1-虚拟线程-JDK21"><a href="#1-虚拟线程-JDK21" class="headerlink" title="1.虚拟线程 JDK21"></a>1.虚拟线程 JDK21</h3><p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p><p>优点：</p><p><strong>非常轻量级</strong>：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</p><p><strong>简化异步编程</strong>： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。</p><p><strong>减少资源开销</strong>： 由于虚拟线程是由 JVM 实现的，它能够更高效地利用底层资源，例如 CPU 和内存。虚拟线程的上下文切换比平台线程更轻量，因此能够更好地支持高并发场景。</p><p>缺点：</p><p><strong>不适用于计算密集型任务</strong>： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。</p><p><strong>与某些第三方库不兼容</strong>： 虽然虚拟线程设计时考虑了与现有代码的兼容性，但某些依赖平台线程特性的第三方库可能不完全兼容虚拟线程。</p><p>创建方法：</p><ol><li><strong>使用 <code>Thread.startVirtualThread()</code> 创建</strong></li><li><strong>使用 <code>Thread.ofVirtual()</code> 创建</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CustomThread</span> <span class="variable">customThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomThread</span>();</span><br><span class="line">    <span class="comment">// 创建不启动</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">unStarted</span> <span class="operator">=</span> Thread.ofVirtual().unstarted(customThread);</span><br><span class="line">    unStarted.start();</span><br><span class="line">    <span class="comment">// 创建直接启动</span></span><br><span class="line">    Thread.ofVirtual().start(customThread);</span><br></pre></td></tr></table></figure><ol><li><strong>使用 <code>ThreadFactory</code> 创建</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CustomThread customThread = new CustomThread();</span><br><span class="line">    ThreadFactory factory = Thread.ofVirtual().factory();</span><br><span class="line">    Thread thread = factory.newThread(customThread);</span><br><span class="line">    thread.start();</span><br></pre></td></tr></table></figure><ol><li><strong>使用<code>Executors.newVirtualThreadPerTaskExecutor()</code>创建</strong></li></ol><h2 id="12-源码详解ArrayList"><a href="#12-源码详解ArrayList" class="headerlink" title="12.源码详解ArrayList"></a>12.源码详解ArrayList</h2><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。一开始先分配一个空间，然后后面快满了再进行扩容。list 列表的结尾会预留一定的容量空间</p><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p><p><code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。</p><p>扩容机制的分析：</p><ul><li><p>默认的初始容量大小就是10，一般采用默认构造函数，创造一个空列表，<strong>实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p></li><li><p>带初始容量的构造参数，就使用用户指定的初始容量。&gt;0就用指定的，=0就创建空数组，&lt;0抛出异常</p></li><li>构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</li></ul><p>扩容的参数是<strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code></strong>所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><h2 id="13-TreeMap"><a href="#13-TreeMap" class="headerlink" title="13.TreeMap"></a>13.TreeMap</h2><p><code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力</p><ul><li><p><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于等于、小于等于、严格大于、严格小于给定键的最接近的键值对。</p></li><li><p><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</p></li><li><p><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</p></li><li><p><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素</p></li></ul><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p><p>指定排序的比较器，重写compare方法</p><h2 id="14-HashMap底层分析-amp-问题解析"><a href="#14-HashMap底层分析-amp-问题解析" class="headerlink" title="14.HashMap底层分析&amp;问题解析"></a>14.HashMap底层分析&amp;问题解析</h2><ol><li>源码分析</li></ol><p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p>通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置，使用位运算的计算速度快，而且HashMap的的容量都是2的次幂，然后这样我们就可以使用位运算，最高位的一个标志。根据这个来确定是否在原位置，0不动，1+当前的长度</p><p>负载因子：一般都是0.75，这是一个经验值，<strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。</strong>长度的默认为16</p><ol><li>HashMap 的长度为什么是 2 的幂次方？</li></ol><p>位运算效率更高：位运算(&amp;)比取余运算(%)更高效。当长度为 2 的幂次方时，<code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。</p><p>可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。</p><p>扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</p><ol><li>HashMap 多线程操作导致死循环问题</li></ol><p>JDK1.7 之前的版本，在多线程下，使用头插法容易形成环形链表。JDK1.8 版本的 HashMap 采用了尾插法，避免了环形问题，但多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题</p><ol><li>ConcurrentHashMap1.7 <strong>Segment 数组 + HashEntry 数组 + 链表</strong></li></ol><p>初始化逻辑：</p><ul><li><p>必要参数校验。</p></li><li><p>校验并发级别 <code>concurrencyLevel</code> 大小，如果大于最大值，重置为最大值。无参构造<strong>默认值是 16.</strong></p></li><li><p>寻找并发级别 <code>concurrencyLevel</code> 之上最近的 <strong>2 的幂次方</strong>值，作为初始化容量大小，<strong>默认是 16</strong>。</p></li><li><p>记录 <code>segmentShift</code> 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。<strong>默认是 32 - sshift = 28</strong>.</p></li><li><p>记录 <code>segmentMask</code>，默认是 ssize - 1 = 16 -1 = 15.</p></li><li><p><strong>初始化 <code>segments[0]</code></strong>，<strong>默认大小为 2</strong>，<strong>负载因子 0.75</strong>，<strong>扩容阀值是 2*0.75=1.5</strong>，插入第二个值时才会进行扩</p></li></ul><p>根据put计算到key的位置，获取指定的Segment,如果为空那么初始化Segment</p><ol><li><p>检查计算得到的位置的 <code>Segment</code> 是否为 null.</p><p>为 null 继续初始化，使用 <code>Segment[0]</code> 的容量和负载因子创建一个 <code>HashEntry</code> 数组。</p><p>再次检查计算得到的指定位置的 <code>Segment</code> 是否为 null.</p><p>使用创建的 <code>HashEntry</code> 数组初始化这个 Segment.</p><p>自旋判断计算得到的指定位置的 <code>Segment</code> 是否为 null，使用 CAS 在这个位置赋值为 <code>Segment</code></p></li><li><p><code>Segment.put</code> 插入 key,value 值。</p></li></ol><p>ConcurrentHashMap1.8 <strong>Node 数组 + 链表 / 红黑树</strong></p><p>的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> （sizeControl 的缩写），它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化，其他线程需要自旋等待</li><li>-N 说明 table 正在进行扩容，高 16 位表示扩容的标识戳，低 16 位减 1 为正在进行扩容的线程数</li><li>0 表示 table 初始化大小，如果 table 没有初始化</li><li>>0 表示 table 扩容的阈值，如果 table 已经初始化</li></ol><p>put方法：</p><p>根据 key 计算出 hashcode 。</p><p>判断是否需要进行初始化。</p><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p><p>如果都不满足，则利用 synchronized 锁写入数据。</p><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/javase/">javase</category>
      
      <category domain="https://blog.tokenlen.top/categories/javase/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/12/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/javase/javase4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务论坛设计方案</title>
      <link>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/</link>
      <guid>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/</guid>
      <pubDate>Sat, 09 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;技术栈应用&quot;&gt;&lt;a href=&quot;#技术栈应用&quot; class=&quot;headerlink&quot; title=&quot;技术栈应用&quot;&gt;&lt;/a&gt;技术栈应用&lt;/h1&gt;&lt;p&gt;Nacos—-服务注册&lt;/p&gt;
&lt;p&gt;OpenFeign—-RPC&lt;/p&gt;
&lt;p&gt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="技术栈应用"><a href="#技术栈应用" class="headerlink" title="技术栈应用"></a>技术栈应用</h1><p>Nacos—-服务注册</p><p>OpenFeign—-RPC</p><p> <strong>Seata</strong> —-分布式事务</p><h1 id="真正内容设计亮点"><a href="#真正内容设计亮点" class="headerlink" title="真正内容设计亮点"></a>真正内容设计亮点</h1><ul><li><strong>基于 Sa-Token 构建统一 OAuth2 认证中心</strong>，实现账号密码、短信验证码、第三方平台（微信/支付宝/GitHub 等）等多种登录方式；通过自定义 Token 生成与权限控制，实现细粒度角色/权限管理；集成 Redis 实现分布式会话共享，支持多微服务统一认证与单点登录（SSO）；结合注解与全局拦截器完成接口级鉴权，有效提升系统安全性与扩展性。</li><li>基于 <strong>Seata 分布式事务框架</strong> 实现跨微服务数据一致性保障，支持 AT/Saga/TCC 多事务模式；通过 Feign 拦截器实现全局事务上下文透传，结合异常分类回滚策略提升稳定性；引入事务监控与告警系统，支持事务状态实时追踪与自动补偿，显著降低人工介入成本。</li><li>设计并实现 <strong>基于 Spring Cloud Gateway 的全局认证过滤器</strong>，支持 JWT 多端统一认证、白名单动态管理、用户上下文透传；集成 Redis 实现 Token 黑名单与防重放攻击机制，提升系统安全性；引入链路追踪 ID 与异常告警体系，支持全链路请求跟踪与安全事件快速响应。</li><li></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/forum1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>微服务论坛问题收集</title>
      <link>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/</link>
      <guid>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/</guid>
      <pubDate>Sat, 09 Aug 2025 16:00:00 GMT</pubDate>
      
      
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/categories/java/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring-boot/">spring boot</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/10/%E5%B7%A5%E4%BD%9C/workmenu/fourm2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringCloud-组件介绍</title>
      <link>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/</link>
      <guid>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/</guid>
      <pubDate>Fri, 08 Aug 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;Spring Cloud 是一系列框架的有序集合。&lt;/p&gt;
&lt;p&gt;Spring Cloud 利用 Spring Boot</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Spring Cloud 是一系列框架的有序集合。</p><p>Spring Cloud 利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>它将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><ul><li><strong>Spring Cloud Netflix</strong>：重要组件之一，与各种Netflix OSS组件集成，组成微服务的核心。</li><li><strong>Netflix Eureka</strong>：服务注册中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。</li><li><strong>Netflix Hystrix</strong>：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li><li><strong>Spring Cloud Config</strong>：配置中心，配置管理工具包，可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Svn。</li><li><strong>Spring Cloud Bus</strong>：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</li><li><strong>Spring Cloud for Cloud Foundry</strong>：Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。</li><li><strong>Spring Cloud Cluster</strong>:Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。</li><li><strong>Spring Cloud Zookeeper</strong>:操作Zookeeper的工具包，用于使用zookeeper方式进行服务发现和配置管理。</li><li><strong>Spring Cloud Starters</strong>:为Spring Cloud提供开箱即用的依赖管理。</li><li>Dubbo:基于RPC调⽤，对于⽬前使⽤率较⾼的Spring Cloud Netflix来说，它是基于HTTP的，所以效率上没有Dubbo⾼，但问题在于Dubbo体系的组件不全，不能够提供⼀站式解决⽅案。</li><li>Nocas:注册中⼼ + 配置中⼼的组合，帮助我们解决微服务开发必会涉及到的服务注册与发现，服务配置，服务管理等问题。<a href="https://zhida.zhihu.com/search?content_id=169091361&amp;content_type=Article&amp;match_order=1&amp;q=Nacos&amp;zhida_source=entity">Nacos</a> 是Spring Cloud Alibaba 核⼼组件之⼀，负责服务注册与发现，还有配置。</li><li><p>Zookeeper:Zookeeper ⽤来做服务注册中⼼，主要是因为它具有节点变更通知功能，只要客户端监听相关服务节点，服务节点的所有变更，都能及时的通知到监听客户端，这样作为调⽤⽅只要使⽤ Zookeeper 的客户端就能实现服务节点的订阅和 变更通知功能了，zookeeper遵循半数集群可用原则。</p></li><li><p>Ribbon负载均衡</p></li></ul><h1 id="开发组件选择"><a href="#开发组件选择" class="headerlink" title="开发组件选择"></a>开发组件选择</h1><h2 id="Eureka注册服务中心"><a href="#Eureka注册服务中心" class="headerlink" title="Eureka注册服务中心"></a>Eureka注册服务中心</h2><p>在微服务项目中，我们一般会对一个项目，以业务的维度拆分至多个服务，比如用户服务、账务服务、订单服务、仓储服务等，这些服务在生产环境部署，<br>至少是2个服务实例，如果业务量大几十个都是有可能的。</p><p>订单服务实例部署了4个，仓库服务部署了5个，仓库服务要调用订单服务，如果没有注册中心，他会怎么做，那只有把对应的ip和端口写死在代码中，如果新增了一个订单服务怎么办？或者下线了订单服务怎么办？</p><p>另外，在云环境中，服务实例随时都有可能启动和关闭，随之IP也会发生变化，没法把IP写死在代码中。</p><p>基于以上问题就有了服务注册中心<code>Eureka</code></p><p><code>Eureka</code>能实现服务自动的注册和发现，在每次服务调用的时候根据服务名称会获取到目标服务的IP和端口，在进行调用。</p><p>如果服务下线或者上线，对应的服务的地址信息也会进行更新，这样就保证了，随时可以调用到有效的服务。</p><p>同时为了提高性能，这个服务地址信息会在每个服务本地缓存一份地址信息表，定时更新，这样每次请求服务时，不用每次去<code>Eureka</code>查询来降低服务调用耗时。</p><p>我们部署一个<code>Eureka Server</code>，并将我们的微服务（部门服务和用户服务）作为 Eureka 客户端，注册到<code>Eureka Server</code>，同时使用用户服务调用根据部门服务的<code>Service ID</code> 来调用部门服务相关接口。</p><p>在项目中添加组件Eureka Server，pom文件中进行导入</p><p>主方法上我们需要添加<code>@EnableEurekaServer</code>注解，使我们应用程序成为服务注册中心。</p><p>默认情况下，每个<code>Eureka Server</code> 也是一个<code>Eureka</code>客户端。由于我们只想让他做好服务注册中心，不想让他做客户端，因此我们将通过在<code>application.properties</code>文件中配置以下属性来禁用此客户端行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=Eureka Server</span><br><span class="line">server.port=8761</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:8761</code>，会显示以下界面</p><p>然后将一个服务注册到Eureka Server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;spring-cloud.version&gt;2021.0.4&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>在application.properties中配置<code>eureka.client.service-url.defaultZone</code> 属性 即可自动注册到 Eureka Server。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.application.name=DEPARTMENT-SERVICE</span></span><br><span class="line"><span class="string">eureka.instance.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>当服务注册到 Eureka Server 时，它会在一定的时间间隔内不断发送心跳。如果 Eureka 服务器没有收到来自任何服务实例的心跳，它将假定该服务实例已关闭并将其从池中取出</p><p>然后目标服务添加注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value = &quot;DEPARTMENT-SERVICE&quot;)</span><br></pre></td></tr></table></figure><h2 id="Open-Feign服务调用"><a href="#Open-Feign服务调用" class="headerlink" title="Open Feign服务调用"></a>Open Feign服务调用</h2><p>声明式 HTTP RPC 调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name = &quot;forum-auth&quot;, path = &quot;/api/auth&quot;)</span><br></pre></td></tr></table></figure><p>表示这是一个 <strong>Feign 客户端接口</strong>，要去调用 <strong>名为 <code>forum-auth</code></strong> 的微服务。</p><ul><li><strong><code>name</code></strong>：对应 Spring Cloud 服务注册中心（如 Nacos、Eureka）里的服务名</li><li><strong><code>path</code></strong>：接口调用时统一加上的路径前缀</li></ul><p>你在别的模块里注入这个接口（<code>@Autowired AuthFeignClient client;</code>），就能直接<strong>像调用本地方法一样发起远程 HTTP 请求</strong>。</p><p>那么什么是RPC呢？</p><p>你写一个 Java 接口并打上 Feign 注解（不需要写实现类）。</p><p>Spring Cloud OpenFeign 会在运行时为这个接口创建 <strong>动态代理对象</strong>。</p><p>当你调用方法时，代理会根据注解信息拼接成 HTTP 请求（<code>GET /api/auth/...</code>），<br> 并通过负载均衡（Ribbon/Spring Cloud LoadBalancer）调用到 <code>forum-auth</code> 服务的对应接口。</p><p>返回 JSON 会被自动反序列化成 <code>Result&lt;T&gt;</code> 类型。</p><h2 id="Nacos服务注册"><a href="#Nacos服务注册" class="headerlink" title="Nacos服务注册"></a>Nacos服务注册</h2><p>config配置类：</p><p>@postconstruct的init方法，设置本地地址和元数据，重写run方法</p><p>然后写NacosShutdownHook类，关闭nacos，防止解决DefaultHttpClientFactory无法加载的问题。</p><p>然后再application文件中加入配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cloud:</span><br><span class="line">  nacos:</span><br><span class="line">    discovery:</span><br><span class="line">      server-addr: $&#123;NACOS_SERVER_ADDR:localhost:8848&#125;</span><br><span class="line">      namespace: $&#123;NACOS_NAMESPACE:&#125;</span><br><span class="line">      group: $&#123;NACOS_GROUP:DEFAULT_GROUP&#125;</span><br><span class="line">      enabled: true</span><br><span class="line">    config:</span><br><span class="line">      server-addr: $&#123;NACOS_SERVER_ADDR:localhost:8848&#125;</span><br><span class="line">      file-extension: yaml</span><br><span class="line">      namespace: $&#123;NACOS_NAMESPACE:&#125;</span><br><span class="line">      group: $&#123;NACOS_GROUP:DEFAULT_GROUP&#125;</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure><p>填写组别，发现端口，name名字，然后记录服务端的端口，组别等</p><h2 id="Seata-分布式事务"><a href="#Seata-分布式事务" class="headerlink" title="Seata 分布式事务"></a>Seata 分布式事务</h2><p>​    Config配置文件：</p><p>根据 <strong>环境</strong>（dev/test/prod）和 <strong>服务名</strong> 动态生成事务组名，避免不同环境污染。</p><p>使用配置中心（Nacos / Apollo）动态管理事务组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GlobalTransactionScanner <span class="title function_">globalTransactionScanner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">txServiceGroup</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s-%s-tx-group&quot;</span>,</span><br><span class="line">        System.getenv(<span class="string">&quot;SPRING_APPLICATION_NAME&quot;</span>),</span><br><span class="line">        System.getenv(<span class="string">&quot;ENV&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GlobalTransactionScanner</span>(<span class="string">&quot;forum-seata-group&quot;</span>, txServiceGroup);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    不同的模式：</p><p>当前是 <strong>AT 模式</strong>（自动 SQL 拦截 + 全局锁），性能不错但会加大数据库锁粒度。</p><p>可以升级为：</p><p>对<strong>长事务/跨多服务耗时操作</strong>改用 <strong>Saga 模式</strong>（状态机驱动 + 补偿动作）。</p><p>对<strong>高并发热点写</strong>改用 <strong>TCC 模式</strong>（Try-Confirm-Cancel）避免全局锁。</p><p>​    回滚策略：</p><p>然后对不同类型的异常，设定不同的回滚的策略</p><p>区分 <strong>业务异常</strong>（不回滚，如参数错误）和 <strong>系统异常</strong>（回滚，如数据库/网络错误）。</p><p>可自定义 <code>BusinessException</code> 并在 <code>@GlobalTransactional</code> 里排除。</p><p>​    告警：</p><p>接入 <strong>Seata 控制台</strong>，实时查看全局事务状态。</p><p>通过 Prometheus + Grafana 做事务失败率/超时监控。</p><p>超时自动告警（钉钉/企业微信）。</p><p>集成 SkyWalking/Zipkin，将 XID 作为 TraceId 的一部分，方便跨服务链路分析。</p><p>在全局事务开始、提交、回滚时打业务日志。</p><h2 id="Gateway网关认证"><a href="#Gateway网关认证" class="headerlink" title="Gateway网关认证"></a>Gateway网关认证</h2><p>安全性升级</p><ul><li><p>现在 JWT 一旦签发，在过期时间内无法撤销（除非改密钥）。升级建议：引入 Redis 存储<strong>黑名单 Token</strong>，用户登出或被封禁时将 Token 加入黑名单，网关在过滤器里校验。</p></li><li><p>目前 <code>JwtUtil</code> 应该是固定签名密钥，建议使用 <strong>定期轮换</strong>（Key Rotation），减少泄漏风险。可以用 <code>kid</code>（key id）标记密钥版本，JWT 验证时先取 <code>kid</code>，再用对应密钥解密。</p></li><li><p>给 Token 增加 <code>jti</code>（唯一 ID），在 Redis 里做一次性校验，防止别人抓包重放。</p></li></ul><p>扩展性升级</p><ul><li>白名单配置化，现在白名单是写死在代码里的，可以改成 Nacos / Apollo 配置动态加载：</li><li>现在你用 <code>X-User-Id</code>、<code>X-Username</code>，但可以考虑：全量透传 <code>claims</code>（JSON 压缩后放 header 或 Gateway Request Attribute）。或者只传一个 <code>User-Context</code> Base64，后端统一解码。</li></ul><p>性能优化</p><ul><li>Gateway 是 Reactor 模型，要确保 <code>JwtUtil</code> 验证不会有阻塞 IO（如 Redis、文件操作）。如果 JWT 公钥存 Redis，可提前加载到内存，用 <code>Cache</code> 缓存，减少每次请求访问 Redis。</li><li>白名单频繁变动时，用单个 <code>volatile</code> 变量指向 <code>Set&lt;String&gt;</code>，避免并发锁开销。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.forum.gateway.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.forum.common.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.ExpiredJwtException;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureException;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;AuthGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析缓存（避免每次都重复解析 JWT）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Claims&gt; tokenCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;gateway.auth.tokenHeader:Authorization&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthGatewayFilterFactory</span><span class="params">(JwtUtil jwtUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Config.class);</span><br><span class="line">        <span class="built_in">this</span>.jwtUtil = jwtUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 白名单放行</span></span><br><span class="line">            <span class="keyword">if</span> (isWhiteListed(path, config.getWhiteList())) &#123;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 Token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(request);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;缺少认证信息&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> tokenCache.computeIfAbsent(token, t -&gt; jwtUtil.getClaimsFromToken(t));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 校验 Token 是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (jwtUtil.isTokenExpired(token)) &#123;</span><br><span class="line">                    tokenCache.remove(token);</span><br><span class="line">                    <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;Token 已过期&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 提取用户信息并添加到请求头</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> StringUtils.defaultString(claims.getSubject(), <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">mutatedRequest</span> <span class="operator">=</span> request.mutate()</span><br><span class="line">                        .header(<span class="string">&quot;X-User-Id&quot;</span>, String.valueOf(userId))</span><br><span class="line">                        .header(<span class="string">&quot;X-Username&quot;</span>, username)</span><br><span class="line">                        .header(<span class="string">&quot;X-Trace-Id&quot;</span>, UUID.randomUUID().toString())</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange.mutate().request(mutatedRequest).build());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Token 已过期: &#123;&#125;&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;Token 已过期&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SignatureException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Token 签名无效: &#123;&#125;&quot;</span>, token);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;无效的认证信息&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Token 验证失败&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> unauthorizedResponse(exchange, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isWhiteListed</span><span class="params">(String path, List&lt;String&gt; whiteList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> whiteList.stream().anyMatch(pattern -&gt;</span><br><span class="line">                path.equals(pattern) || path.startsWith(pattern) || pathMatcher.match(pattern, path)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getToken</span><span class="params">(ServerHttpRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> request.getHeaders().getFirst(tokenHeader);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(authorization) &amp;&amp; authorization.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorization.substring(<span class="number">7</span>).trim();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">unauthorizedResponse</span><span class="params">(ServerWebExchange exchange, String message)</span> &#123;</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        response.getHeaders().set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> String.format(<span class="string">&quot;&#123;\&quot;code\&quot;:401,\&quot;message\&quot;:\&quot;%s\&quot;,\&quot;timestamp\&quot;:%d&#125;&quot;</span>,</span><br><span class="line">                message, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> response.bufferFactory().wrap(body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; whiteList = Arrays.asList(</span><br><span class="line">                <span class="string">&quot;/auth/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/auth/register&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/auth/captcha&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/doc.html&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/swagger-ui/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/v3/api-docs/**&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/SpringCloud/">SpringCloud</category>
      
      
      <comments>https://blog.tokenlen.top/2025/08/09/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springcloud1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-2</title>
      <link>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/</link>
      <guid>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/</guid>
      <pubDate>Mon, 28 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;面试回答优化&lt;/p&gt;
&lt;h1 id=&quot;Gemini模拟面试2025-7-29&quot;&gt;&lt;a href=&quot;#Gemini模拟面试2025-7-29&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>面试回答优化</p><h1 id="Gemini模拟面试2025-7-29"><a href="#Gemini模拟面试2025-7-29" class="headerlink" title="Gemini模拟面试2025.7.29"></a>Gemini模拟面试2025.7.29</h1><p>1.Java面向对象的基本特性：</p><p>总：的介绍一下java面向对象</p><p>分：封装，继承，多态</p><p>总：好处</p><p>2.Hashmap的原理</p><p>总：hashmap是个啥</p><p>分：</p><ol><li><p>基本数据结构类型，1.7 or 1.8</p></li><li><p>hash冲突解决</p></li><li><p>核心put过程</p></li><li><p>扩容机制，为什么是2倍</p></li><li><p>线程安全实现</p></li><li><p>concurrenthashmap</p></li><li><p>平时使用场景</p></li></ol><p>3.<strong>ArrayList 和 LinkedList 的区别</strong> </p><ol><li>底层数据结构</li><li>插入删除遍历节点</li><li>扩容</li><li>使用场景：</li></ol><p>4.常用的设计模式</p><ol><li>单例：饿汉式，懒汉式，DCL 枚举 实际应用，RedisClient AppConfig Spring bean</li><li>策略：</li><li>模板</li><li>观察</li><li>工厂</li></ol><p>5.ThreadLocal的实现</p><ol><li>底层数据结构</li></ol><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，key为实例，value是为具体的对象</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><ol><li><p>内存泄漏问题</p></li><li><p>使用场景</p></li></ol><p>6.你如何理解“悲观锁与乐观锁”？分别适用哪些场景？CAS 原理是什么？</p><ol><li>悲观锁，乐观锁代表什么，实例，场景</li><li>CAS原理，OS的cmpxchg</li><li>CAS问题</li><li>使用场景</li></ol><p>7.说一下 Java 中的 <code>synchronized</code> 关键字的实现原理、优化机制，以及它和 <code>ReentrantLock</code> 的区别</p><ol><li>底层原理，对象头中的 monitor 锁，每个对象在 JVM 中都有一个对象头，包含了锁标志位和指向 monitor 的指针。当线程进入 <code>synchronized</code> 块或方法时，会尝试获得这个对象的 monitor。多线程竞争时，会进行 <strong>锁的升级</strong>，这就是 HotSpot 中的锁优化。</li><li>锁的升级过程，无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li><li>和<code>ReentrantLock</code> 对比</li></ol><p>8.说一下 Java 中的 <code>volatile</code> 关键字的作用，它能实现线程安全吗？它和 <code>synchronized</code> 有什么区别？</p><ol><li><p>可见性，禁止重排性</p></li><li><p>不能保证原子下，i++</p></li><li><p>和JMM的关系：JMM规定了主内存和工作内存的交互规则，volatile 会强制线程刷新工作内存和主内存之间的数据。</p><p>写 volatile → 插入一个 Store + StoreBarrier 。读 volatile → 插入一个 LoadBarrier + Load</p></li><li><p>应用场景，标识位，布尔控制变量，DCL</p></li><li><p>和<code>synchronized</code> 对比</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/29/%E5%B7%A5%E4%BD%9C/towork/woking3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试面经-1</title>
      <link>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/</link>
      <guid>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/</guid>
      <pubDate>Thu, 24 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;他人面经&quot;&gt;&lt;a href=&quot;#他人面经&quot; class=&quot;headerlink&quot; title=&quot;他人面经&quot;&gt;&lt;/a&gt;他人面经&lt;/h1&gt;&lt;h2 id=&quot;1-spring的底层实现-amp-三级缓存原理&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="他人面经"><a href="#他人面经" class="headerlink" title="他人面经"></a>他人面经</h1><h2 id="1-spring的底层实现-amp-三级缓存原理"><a href="#1-spring的底层实现-amp-三级缓存原理" class="headerlink" title="1.spring的底层实现&amp;三级缓存原理"></a>1.spring的底层实现&amp;三级缓存原理</h2><p>我们先来说三级缓存的实现吧</p><p>首先三级缓存是那三个缓存呢？是在DefaultSingletonBeanRegistry类里面定义的三个Map。然后第一第二层都是key是bean的名字，value是bean的实例。第三次key是bean的名字，value是objectfactory.</p><p>第一层缓存是用来存储我们已经完全实例化好的bean,在这里可以直接使用的</p><p>第二层缓存时用来存储我们早期的bean，创建好，但是并没有进行依赖注入的</p><p>第三次缓存是用来存储我们的objectfactory的，用来创建代理对象的</p><p>然后我们缓存的核心方法是我们的getSingleton方法，他定义了我们如何去获取缓存的顺序</p><p>我们首先先去看第一层缓存，如果第一次没有且bean正在创建中的话。我们再去找第二层缓存，第二层也没有的话，允许早期引用。然后从三级缓存中获取objectfactory</p><p>然后使用objectfactory来创建对象，这里可能是代理对象。因为比如AOP，或者使用了其他的代理模式</p><p>然后将其升级到二级缓存，将三级缓存里面的删除。（暂不使用，然后再可以进行依赖注入。然后如果我们的作用域是单例的话，就直接放入一级缓存，不是的话，就根据场景来）</p><p>然后在我们进行依赖注入的时候可能会出现循环依赖的问题，就是A依赖于B，B也依赖于A的问题</p><p>这个时候就需要解决依赖的问题，我们的三层缓存使用的是提前暴露的方法来解决循环依赖的问题</p><p>在AbstractAutowireCapableBeanFactory.doCreateBean的方法里面定义了解决的实现</p><p>首先我们先实例化bean，只是采用<em>构造器，</em>创建，并没有进行属性的注入</p><p>然后我们去判断需不要早期暴露，是不是单例的，因为单例的才会允许循环依赖注入。然后允不允许我们循环依赖。这个是在SpringApplication中设置的，然后这个bean是不是正在被创建中。，</p><p>满足了这个条件，我们才会将objectfactory放入三级缓存的时候，保证二级缓存没有，然后这个会获取一个早期引用，如果我们需要AOP 的话，会获取他的代理对象</p><p>然后对我们需要的依赖进行属性的填充，进行依赖注入</p><p>注入完进行初始化bean</p><p>然后为什么是三级缓存呢？因为<strong>AOP代理对象的延迟创建问题</strong></p><p>在AOP的后置处理器中，获取早期的引用对象的时候，会返回的是我们的代理对象。</p><p>如果我们使用二级缓存的，不知道什么时候创建代理对象，可能会创建多个代理对象，AOP的时机控制会失效。</p><p>so:</p><p>三级缓存通过ObjectFactory实现了：</p><ul><li><strong>按需创建</strong>：只有真正发生循环依赖时才创建代理对象</li><li><strong>唯一性保证</strong>：确保一个Bean只有一个早期引用实例</li><li><strong>时机控制</strong>：代理对象的创建时机由Spring容器精确控制</li></ul><h2 id="2-hashmap为什么扩容要是2的倍数"><a href="#2-hashmap为什么扩容要是2的倍数" class="headerlink" title="2.hashmap为什么扩容要是2的倍数"></a>2.hashmap为什么扩容要是2的倍数</h2><p>HashMap扩容为2的倍数的根本原因是为了实现<strong>高效的哈希计算</strong>和<strong>均匀的元素分布</strong>。</p><p>我们hashmap的tableSizeFor进行容量初始化的时候，通过位运算确保了任何输入都会背转换成<strong>大于等于该数的最小2的幂次方</strong>。确保了容量为2的次方幂。</p><p>然后在put一个元素的时候，我们是通过hash来确定这个值得索引的，使用的是<strong>(n-1) &amp; hash 的按位与运算</strong>来确定位置的。然后hash函数也进行了优化，<em>高16位与低16位异或，增加散列的随机性</em>。</p><p>然后我们的扩容方法里面是这样规定的，是单个元素的话，我们使用位运算重新规划位置，如果是红黑树的话，我们对他的头节点进行位运算，</p><p>如果是链表的话，我们要对链表进行拆分，通过一个位来判断元素的去向，如果与老容量的位运算是0的话，就留在原位置，是1的话就转移到原位置+oldcap的位置，这个算法是非常巧妙的，比如假设hash为21，oldcap=16-1,那么原位置就是5，然后现在我们再进行运算，21&amp;16=0，那么他就是留在原位置。</p><p>然后讲我们拆分的链表加入到我们新的数组之中。这个时候要注意链表的长度，如果超过了8的话，且数组位数大于64，需要转为红黑树。</p><p>然后为什么是2的倍数呢？当我们的数字长度为2的次方幂的时候，我们使用位运算比我们的取模运算高效的多，然后我们不需要重新计算hash值，只需要检查一个位就可以确定新的位置，然后如果是2的幂次方保证了hash值的每一位都能参与到索引计算中，而且对cpu的缓存更加友好</p><h2 id="3-sychronized的底层原理"><a href="#3-sychronized的底层原理" class="headerlink" title="3.sychronized的底层原理"></a>3.sychronized的底层原理</h2><p>sychronized的底层原理，如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>sychronized的字节码层面的实现是基于监视器实现的，进入监视器，然后执行sychronized修饰的代码块，然后退出监视器</p><p>然后在Hotspot JVM中，synchronized基于Monitor对象实现，ObjectMonitor规定了持有锁的线程，重入的次数，等待获取锁的线程的队列，竞争队列，wait方法等待的线程</p><p>然后如果我们成功获得锁，直接返回。如果是线程的id等于锁的id的话，重入锁的计数器+1,然后如果不相等的话，就产生了锁的竞争，将其放入慢路径。然后慢路径里面的线程自旋，继续取尝试获取活，如果超过了重试次数的话，将其加入等待队列。</p><p>然后出现的三个线程的关系是，竞争队列-&gt;唤醒队列-&gt;获取锁</p><p>然后如何实现一个线程在另外一个线程之前执行，两个线程没有进入锁没有先后但要求执行按照指定的前后执行</p><p>我们可以使用countDownLatch</p><p>分为A，B两个线程，分别重写他们的run方法，然后A线程执行完之后计数器完成，就通知B线程可以进行。</p><p>然后B线程，重修run方法，调用wait等待，计数器为0的时候开始线程的执行</p><p>然后countdownlatch的底层实现是，state等于0的时候允许通过，然后释放锁的通过cas来实现的</p><p>或者是使用Semaphore，将其初始化为0，然后分为线程A和线程B，线程A执行完之后释放许可，然后B线程执行的时候，尝试获取许可执行</p><p>或者是直接使用LockSupport，在A线程完之后，直接唤醒线程B，然后重写B线程的run方法，先是park的等待A线程执行完之后的唤醒</p><p>然后我们最常用的实现方案是synchronized + wait/notify</p><p>我们先初始化lock然后用sychronized去获取lock,和一个静态的标识位设定为A线程是不是完成。</p><p>然后重写A线程run方法，讲标志位设定为true，然后唤醒等待的线程。线程Bwait等待去执行</p><h2 id="4-tcp状态机，java底层怎么实现tcp的"><a href="#4-tcp状态机，java底层怎么实现tcp的" class="headerlink" title="4.tcp状态机，java底层怎么实现tcp的"></a>4.tcp状态机，java底层怎么实现tcp的</h2><p>那我先说TCP状态机的流程吧，分为客户端状态机和服务端状态机</p><p>客户端：</p><p>CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED</p><p>服务端：</p><p>CLOSED -&gt; LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED(0),      // 初始状态，无连接</span><br><span class="line">LISTEN(1),      // 服务端监听状态</span><br><span class="line">SYN_SENT(2),    // 客户端发送SYN后的状态</span><br><span class="line">SYN_RCVD(3),    // 服务端收到SYN后的状态</span><br><span class="line">ESTABLISHED(4), // 连接建立状态</span><br><span class="line">FIN_WAIT_1(5),  // 主动关闭方发送FIN后的状态</span><br><span class="line">FIN_WAIT_2(6),  // 主动关闭方收到ACK后的状态</span><br><span class="line">CLOSE_WAIT(7),  // 被动关闭方收到FIN后的状态</span><br><span class="line">CLOSING(8),     // 双方同时关闭的中间状态</span><br><span class="line">LAST_ACK(9),    // 被动关闭方发送FIN后的状态</span><br><span class="line">IME_WAIT(10);  // 主动关闭方的最终等待状态</span><br></pre></td></tr></table></figure><p>那我先说一下TCP三次握手的状态机变化：</p><p>客户端主动连接服务端，首先客户端的状态机位close，然后发送完SYN包之后变为SYN_SENT</p><p>然后收到服务端发来的SYN+ACK包，发送ACK包，然后状态转为 ESTABLISHED </p><p>服务端是监听状态的情况下，接收到客户端的SYN包之后，发送SYN-ACK包，状态变为SYN_RCVD</p><p>然后收到客户端的ACK包，状态转变为ESTABLISHED </p><p>TCP四次挥手状态机变化</p><p>先是主动关闭方，一般是客户端，发送FIN包，然后变为FIN_WAIT_1 状态</p><p>然后收到服务端发来的ACK，状态转变为FIN_WAIT_2</p><p>然后再收到发来的FIN包，向服务端发送ACK，转为 TIME_WAIT 等待2MSL后关闭，变为Close状态</p><p>服务端，收到FIN请求后，发送ACK，请求，变为CLOSE_WAIT，然后应用程序调用close方法，发送FIN包，状态变为LAST_ACK</p><p>然后收到ACK请求后，状态变为CLose,彻底关闭</p><hr><p>后面这个有些难度了，哭</p><h2 id="5-协程和线程的区别是什么？"><a href="#5-协程和线程的区别是什么？" class="headerlink" title="5.协程和线程的区别是什么？"></a>5.协程和线程的区别是什么？</h2><p>线程是由操作系统内核进行抢占式调度，任何时候都可能被强制切换，协程是由用户态程序进行协作式调度，只在主动让出时才会切换</p><p>然后线程：</p><ul><li>每个线程需要独立的栈空间（通常1MB）</li><li>创建和切换需要用户态和内核态转换，开销较大</li><li>1000个线程大约占用1GB内存</li><li>共享内存模型，需要使用锁、synchronized等机制保证线程安全</li></ul><p>适合：</p><ul><li>CPU密集型任务</li><li>需要真正并行执行的场景</li><li>传统的多线程编程</li></ul><p>协程：</p><ul><li>栈空间很小（通常几KB）</li><li>在用户态完成创建和切换，开销很小</li><li>10万个协程可能只占用几百MB内存</li><li>通常采用消息传递模型（如Channel），天然避免数据竞争</li></ul><p>适合：</p><ul><li>IO密集型任务</li><li>高并发场景（如服务器处理大量连接）</li><li>异步编程，避免回调地狱</li></ul><p>协程是轻量级的用户态线程，更适合高并发的IO密集型场景，而线程更适合CPU密集型的并行计算场景。协程的核心优势是用更少的资源实现更高的并发度。</p><h2 id="6-介绍一下ArrayList扩容机制"><a href="#6-介绍一下ArrayList扩容机制" class="headerlink" title="6.介绍一下ArrayList扩容机制"></a>6.介绍一下ArrayList扩容机制</h2><p>首先先介绍一下ArrayList他的底层是动态的数组，默认的容量为10。但是有一个最大数组的容量，这个主要是考虑JVM的，因为ArrayList给他在JVM里面分配的是一个连续的内存。最大是Integer.MAX_VALUE - 8，为什么呢？JVM在数组对象头中需要存储一些元数据，预留防止出现OOM</p><p>然后ArrayList的扩容是add元素之后，剩余的内存容量还足够，通过数组复制的方法，为新元素腾出空间</p><p>我们首先会进行容量的检查，这里检查的是Size+1，先去查查内部的容量，然后去检查我们所需要的容量，如果是空数组的话，那么至少需要10的容量</p><p>然后去显示的检查容量，计数器+1，如果最小需求容量&gt;当前数组的长度的话，就进行扩容</p><p>然后触发核心的扩容方法，新的容量是<em>新容量 = 旧容量 + 旧容量的一半</em>，是根据oldCapacity + (oldCapacity &gt;&gt; 1)计算来的。这样计算更快</p><p>然后处理边界的情况，先是最小边界，1.5倍如果还不够的话，就用最小需求量，然后是超大的边界处理，将容量设为容量的最大值</p><p>然后检查完之后，进行数组的复制，将元素复制到更大的数组。这里使用<em>Arrays.copyOf然后最终调用System.arraycopy的</em>native方法</p><p>优化的策略：</p><p>我们可以先进行预估一下，然后再确定一开始初始化需要的初始容量，避免频繁扩容。最好的办法是，开了负载因子，然后容量比我们预计的多一点</p><h2 id="7-口述实现非公平与公平的redis分布式锁"><a href="#7-口述实现非公平与公平的redis分布式锁" class="headerlink" title="7.口述实现非公平与公平的redis分布式锁"></a>7.口述实现非公平与公平的redis分布式锁</h2><p>非公平锁：</p><p>获取锁</p><ol><li>使用<code>SET key value NX EX timeout</code>命令尝试获取锁</li><li>如果设置成功，说明获取锁成功，返回true</li><li>如果设置失败，说明锁被占用，可以选择重试或返回失败</li><li>value通常设置为当前线程的唯一标识（如UUID+线程ID）</li></ol><p>释放锁</p><ol><li>使用Lua脚本确保原子性操作</li><li>先检查锁的value是否是当前线程设置的</li><li>如果是，则执行DEL命令删除锁</li><li>如果不是，说明锁已超时被其他线程获取，不能删除</li></ol><p>重试机制</p><ul><li>获取失败后，线程sleep一小段时间再重试</li><li>重试间隔可以是固定时间或采用指数退避策略</li><li>设置最大重试次数或超时时间避免无限等待</li></ul><p>公平锁：</p><p>获取锁</p><ol><li><strong>检查当前锁状态</strong><ul><li>如果锁未被占用，直接尝试获取</li><li>如果被占用，进入排队流程</li></ul></li><li><strong>加入等待队列</strong><ul><li>将当前线程标识和时间戳加入<code>queue:resource_name</code>有序列表</li><li>使用ZADD命令，以时间戳为分数确保顺序</li></ul></li><li><strong>检查队列位置</strong><ul><li>获取队列中的第一个元素（最早等待的线程）</li><li>如果是当前线程，说明轮到自己，尝试获取锁</li><li>如果不是，继续等待</li></ul></li><li><strong>等待通知机制</strong><ul><li>使用Redis的BLPOP或发布订阅机制等待通知</li><li>或者采用轮询方式，定期检查是否轮到自己</li></ul></li><li><strong>获取锁的尝试</strong><ul><li>当轮到自己时，使用SET NX命令尝试获取锁</li><li>获取成功后，从等待队列中移除自己</li><li>获取失败说明锁被其他线程抢占，重新进入等待</li></ul></li></ol><p>释放锁</p><ol><li><strong>释放锁资源</strong><ul><li>使用Lua脚本原子性地检查并删除锁</li></ul></li><li><strong>通知下一个等待者</strong><ul><li>从等待队列中获取下一个等待的线程</li><li>向该线程发送通知信号</li><li>可以使用Redis的发布订阅或设置特定key来通知</li></ul></li><li><strong>清理过期等待者</strong><ul><li>定期清理队列中的过期等待线程</li><li>避免队列无限增长</li></ul></li></ol><h2 id="9-OS的虚拟内存和页面置换算法"><a href="#9-OS的虚拟内存和页面置换算法" class="headerlink" title="9.OS的虚拟内存和页面置换算法"></a>9.OS的虚拟内存和页面置换算法</h2><p>虚拟内存是操作系统的核心抽象，通过MMU和页表机制将进程的虚拟地址空间映射到有限的物理内存，实现内存保护、共享和扩展。</p><p>当物理内存不足时，页面置换算法决定哪些页面被换出到磁盘。<strong>FIFO算法</strong>实现简单但可能出现Belady异常；<strong>LRU算法</strong>基于局部性原理效果最好但实现成本高；<strong>Clock算法</strong>是LRU的高效近似实现，使用访问位模拟时钟指针给页面第二次机会；<strong>Enhanced Clock算法</strong>进一步考虑修改位，优先置换干净页面减少磁盘I/O。</p><p>现代操作系统如Linux采用多层LRU设计，将页面分为active和inactive链表动态管理热度，并结合预取、内存压缩等技术优化性能。<strong>关键是要平衡算法复杂度与性能提升，充分利用程序的时间空间局部性，同时考虑NUMA、SSD等现代硬件特性</strong>。在生产环境中需要根据应用特征选择合适策略，避免内存抖动，并通过监控缺页率等指标持续优化。虚拟内存的设计体现了操作系统在资源管理上的核心思想：通过抽象和调度算法，在有限资源上为应用提供无限且高效的服务体验。</p><h2 id="10-AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写"><a href="#10-AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写" class="headerlink" title="10.AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写"></a>10.AQS的设计思想，如果让你去利用AQS设计一个同步工具，怎么写</h2><p>AQS是一个设计思想，本质上就是一个同步器框架。主要控制状态管理和线程排队，状态管理交给子类，然后线程排队AQS统一处理</p><p>核心组件就是state变量和CLH队列变种</p><p>state:</p><ul><li>使用volatile int保证可见性</li><li>通过CAS操作保证原子性修改</li><li>语义由子类定义：可以表示锁的持有状态、信号量的许可数量、CountDownLatch的计数等</li></ul><p>CLH队列：</p><ul><li><strong>双向链表</strong>：支持超时和中断处理</li><li><strong>虚拟头节点</strong>：简化边界条件处理</li><li><strong>节点状态</strong>：SIGNAL、CANCELLED、CONDITION等，精确控制唤醒时机</li></ul><p>流程：</p><p>他是先尝试快速获取锁，避免排队。失败后加入队列，但是不会立刻阻塞。在队列中尝试去获得锁，获取前驱释放的锁。实在无法获取的适合才堵塞。</p><p>然后获取锁的时候state+1，线程Id=锁的Id，然后解锁的时候-1。知道为0的时候释放锁。</p><p>然后在CLH中设计了<strong>懒初始化</strong>：只有竞争时才创建队列，减少内存开销。设计了唤醒机制，释放资源的线程负责唤醒后记的节点，被唤醒的线程获取资源后，唤醒下一个。避免了雷鸣群羊”问题，精确控制唤醒数量</p><p>被唤醒的线程，实现CAS自旋尝试去获得锁，失败后会被park，直到再次unpark。</p><p>同步工具，我写了一个基于AQS和令牌桶实现的限流操作</p><p>先是引入桶容量，每秒补充的速率。然后对他们进行初始化，初始化令牌桶，将时间戳和令牌数压缩到一个long变量中。</p><p>然后重要的是实现<em>tryAcquire </em>和tryRelease，但是令牌桶不需要主动的释放资源</p><p>先去解析我们当前的状态，获取时间和需要的令牌数量，然后计算我们需要补充的令牌的数量，然后判断我们是否可以获取。然后使用CAS更新状态，返回剩余令牌数。CAS失败就自旋重试，避免了线程堵塞。</p><h2 id="11-介绍一下动态代理"><a href="#11-介绍一下动态代理" class="headerlink" title="11.介绍一下动态代理"></a>11.介绍一下动态代理</h2><p>动态代理主要有<strong>JDK动态代理</strong>和<strong>CGLIB字节码增强</strong>两种实现方式。<strong>JDK动态代理</strong>基于接口，在运行时通过Proxy.newProxyInstance()创建代理对象，底层使用反射调用InvocationHandler的invoke方法来拦截目标方法；<strong>CGLIB字节码增强</strong>无需接口，通过ASM字节码操作库在运行时生成目标类的子类，重写目标方法并插入拦截逻辑，在方法中通过super调用原始方法或MethodInterceptor进行增强。<strong>核心区别</strong>：JDK代理生成的是接口实现类，性能更好但必须有接口；CGLIB生成的是继承子类，更灵活但不能代理final方法。Spring AOP默认策略是有接口用JDK代理，无接口用CGLIB，都是在运行时动态生成字节码实现方法拦截和功能增强，广泛应用于AOP、事务管理、权限控制等场景。</p><h2 id="12-tomcat底层（TODO）"><a href="#12-tomcat底层（TODO）" class="headerlink" title="12.tomcat底层（TODO）"></a>12.tomcat底层（TODO）</h2><h2 id="13-布隆过滤器的底层实现"><a href="#13-布隆过滤器的底层实现" class="headerlink" title="13.布隆过滤器的底层实现"></a>13.布隆过滤器的底层实现</h2><p>布隆过滤器本质上就是一个大的Bitset+多个独立的hash函数，<em>根据期望元素数和误判率计算最优参数</em>，假设有m个位，k个哈希函数，插入n个元素，最优数组位大小是 -n <em> ln(p) / (ln(2))²</em>，最优hash函数个数是<em>k = (m/n) </em> ln(2)</p><p>然后我们添加元素的时候，对元素进行hash，然后放在对应的hash%bitsetsize的位置上，然后设置为1</p><p>查询元素的时候，遍历hash，获取其index，然后必须所以的hash位都要是1才可能存在</p><p>我们单个使用hash太慢了，我们需要高效生成k个独立的哈希值，就可以使用双hash方法，使用两个不同的哈希函数，比如一个直接调用，一个取16位，让组合生成一个新的hash比如hash1+i+hash2,常用MurmurHash + FNV Hash两个hash组合</p><p>然后其布隆过滤器不是完全准确的，可能布隆过滤器中没有，但是数据库中有的，我们就需要计算准确率，较少的计算出某个位为0的概率，然后计算出k个位都为1但是元素不存在的概率</p><p>然后1-概率1 pow上概率2</p><p>当这个布隆过滤器很大的时候，一般我们都用16位就可以了，k=16时已经能提供足够好的误判率。理论值误判率：(1 - e^(-kn/m))^k</p><p>单个优化策略：</p><ol><li><strong>动态扩容</strong>，<em>创建新的过滤器，容量翻倍，误判率减半</em>，然后只要有一个过滤器返回true就可以</li><li>增加位数组大小，相同的元素数量下，位数组越多，误判率越小。</li><li><strong>Counting Bloom Filter</strong>，使用计数器代替位数组，成功添加之后，计数器+1，避免单一位冲突，可以支持删除操作</li><li>分层布隆过滤器，元素依次通过多层过滤器，在第一个返回的层添加其元素。然后只有所有的层都返回true才表明存在</li></ol><p>关键特性：</p><p>如何判断没有一定没有？</p><ul><li>如果元素真的被添加过，它的所有哈希位置都<strong>必须</strong>为1，发现任何一个位置为0，说明元素<strong>绝对没有</strong>被添加过，所有位置都为1时，可能是其他元素设置的（假阳性）</li></ul><p>然后实际的参数的设计，100万商品的话，误判率设为0.01</p><p>然后位数组大小 ≈ 9,585,058*，然后单击场景我们就放在JVM内存中，分布式的话就存在redis里面</p><h2 id="14-ThreadLocal的底层实现"><a href="#14-ThreadLocal的底层实现" class="headerlink" title="14.ThreadLocal的底层实现"></a>14.ThreadLocal的底层实现</h2><p>Threalocal涉及两个组件，一个是他对象本身负责set和get</p><p>然后一个ThreadLocalMap负责数据的存储，每一个线程都持有一个ThreadLocalMap他就是副本。是线程隔离的，不会有并发的线程不安全问题</p><p>ThreadLocalMap是Thread下面的一个内部类，使用了自定义的散列表来存储键值对，其键是 <code>ThreadLocal</code> 实例对象（弱引用），值是线程本地变量的值（强引用）。</p><p>然后<code>ThreadLocalMap</code> 的 <code>Entry</code> 是用 <code>WeakReference</code> 来存储 <code>ThreadLocal</code> 对象实例，这样可以避免 <code>ThreadLocal</code> 对象不会因为强引用而无法被垃圾回收。但需要注意的是，<code>value</code> 是一个强引用，如果 <code>ThreadLocal</code> 没有正确清理，就可能导致内存泄漏的问题。然后我们如果想回收内存的话，需要显示的调用remove方法移除。或者是查找当前线程关联的map，将其键值对分别设为当前线程和null</p><p>Threadlocal可以用于线程不安全类的线程安全封装，<strong>典型场景</strong>：<code>SimpleDateFormat</code>。<code>SimpleDateFormat</code> 是一个线程不安全的类，可以为每个线程提供一个独立的实例，避免竞争。</p><p>在数据库连接的时候应用，通常为每个线程（每个请求）独立创建一个数据库连接，使用 <code>ThreadLocal</code> 来管理这些连接。</p><p>管理用户的上下文信息，这个最常用</p><p>在分布式事务或者嵌套事务中，通过 <code>ThreadLocal</code> 存储事务信息，使得同一线程的不同方法调用间能共享事务上下文。</p><p><strong>InheritableThreadLocal</strong> 用于子线程继承父线程变量；</p><h2 id="15-详细解析下CAS和原子类"><a href="#15-详细解析下CAS和原子类" class="headerlink" title="15.详细解析下CAS和原子类"></a>15.详细解析下CAS和原子类</h2><p>CAS的英文是compare and swap ，就是比较然后交换的意思，他是一个原子操作，用于在多线程环境下实现同步</p><p>包括三个操作数</p><ul><li><strong>V</strong>：要更新的变量（内存地址）。</li><li><strong>E</strong>：期望值。</li><li><strong>N</strong>：新值。</li></ul><p>CAS 指令会先比较 V 的当前值是否等于 E，如果相等，则将 V 的值原子性地更新为 N；如果不相等，则什么也不做。 整个比较和替换操作是一个原子操作。通常会返回一个布尔值，表示是不是操作成功</p><p>CAS 的实现依赖于 CPU 提供的原子指令。不同的 CPU 架构实现方式有所不同，但基本原理类似</p><p>在java中是使用的是JUC包下的原子类来实现CAS操作的。这些类通过 <code>Unsafe</code> 类来调用底层的 <code>cmpxchg</code> 指令。该指令的操作数与 CAS 的 V、E、N 对应。该指令会 lock 总线，从而实现原子性。</p><p><code>Unsafe</code> 类是 Java 提供的一个后门，可以直接访问底层系统资源，包括内存操作。<code>AtomicInteger</code> 等原子类使用 <code>Unsafe</code> 类的 <code>compareAndSwapInt</code> 等方法来实现 CAS。</p><p>在unsafe类里面静态方法尝试去先获取表示 <code>value</code> 字段在 <code>AtomicInteger</code> 对象中的内存偏移地址。</p><p>然后调用<code>compareAndSwapInt</code>方法去执行调用底层的 <code>cmpxchg</code> 指令</p><p>但是CAS有一个典型的ABA问题</p><p>如果一个变量 V 的值被修改为 A，然后又被修改回 A，CAS 操作会认为 V 的值没有发生变化，从而成功更新。但实际上，V 的值可能已经经过了其他的改变，只是最终又变回了 A。</p><p>我们可以加入版本号或者是时间戳的一个遍历来实现，CAS的时候不仅是要去比较变量的值，还要去比较版本号或者时间戳</p><p>或者是使用<strong><code>AtomicStampedReference</code></strong>，<code>AtomicStampedReference</code> 类维护了一个变量值和一个 Stamp（类似于版本号）。CAS 操作需要同时比较变量值和 Stamp，确保变量没有被修改过。</p><p>CAS应用在ConcurrenthashMap这种类里面，JUC包下的原子类里面，AQS的实现，还有自旋。不适合高冲突的场景</p><h2 id="16-详细说明一下concurrenthashmap的变化"><a href="#16-详细说明一下concurrenthashmap的变化" class="headerlink" title="16.详细说明一下concurrenthashmap的变化"></a>16.详细说明一下concurrenthashmap的变化</h2><p>介绍一下，然后其他的线程安全的实现。</p><p>数据结构：由分段锁变为了数组链表+红黑树然后使用node数组来存储数据</p><p>线程安全的实现：</p><p>初始化的时候使用volatile+CAS来确保node数组的初始化</p><p>然后如果桶为空使用CAS，不为空使用synchronized锁住链表/红黑树的头节点。扩容的时候使用ForwardingNode标记正在迁移的桶</p><p>读操作的时候大部分情况无锁，使用volatile来保证可见性，node节点的next和val都是volatile来修饰的</p><p>效果：</p><p>锁粒度更细：只锁住具体的桶，而不是整个segment</p><p>读操作基本无锁</p><p>使用CAS减少锁竞争</p><p>然后扩容和红黑树变换</p><p>结合实际</p><h2 id="17-熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性"><a href="#17-熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性" class="headerlink" title="17.熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性"></a>17.熟悉RocketMQ的架构设计，深入了解消息幂等性、延迟消息、死信队列等特性</h2><p><strong>RocketMQ如何保证消息的幂等性？在您的项目中是如何实现的？</strong></p><p><strong>延迟消息的实现原理是什么？它有什么限制？</strong></p><p><strong>如果消费者处理消息失败，RocketMQ是如何处理的？死信队列的作用是什么？</strong></p><p>1.消息幂等：因为RocketMQ只保证了消息至少发送一次，所以我们要在业务逻辑上实现</p><p>通过业务唯一ID进行检查，然后尽量使用msg的key的操作来保持幂等，在数据库方面，使用唯一索引和去重表</p><p>2.延迟消息：延迟队列定时执行任务，只支持固定的18个延迟级别，可以在broker.conf文件中修改</p><p>3.异常处理：消息是先放入redis设计一个短的过期时间，然后执行业务逻辑，执行成功延长过期时间，失败就过期。然后ACK消息</p><p>然后设置消息为RECONSUME_LATER，执行重试逻辑。到达重试次数，记录日志，发送到死心队列进行人工处理，死信消息默认保留3天</p><h2 id="18-详细解释ZSet在Redis中的底层实现，以及跳表的使用场景"><a href="#18-详细解释ZSet在Redis中的底层实现，以及跳表的使用场景" class="headerlink" title="18.详细解释ZSet在Redis中的底层实现，以及跳表的使用场景"></a>18.<strong>详细解释ZSet在Redis中的底层实现，以及跳表的使用场景</strong></h2><p>ZSet是Redis中一种常用的数据结构，用于存储有序的元素集合，它可以根据元素的分数（score）进行排序，通常用于排行榜等场景。</p><p>他的底层实现是两种数据结构</p><ol><li><p><strong>压缩列表（ziplist）：</strong> 在元素数量较少且元素成员（member）较短时使用。 压缩列表的特点是内存占用小，但插入、删除操作的效率较低，因为它需要进行连续的内存移动。</p><ul><li><strong>结构：</strong> 压缩列表是一种特殊的”连续内存块”构成的数据结构，类似于数组，但可以存储不同长度的数据。 它由多个entry组成，每个entry保存ZSet中的一个元素（member-score）。</li><li><strong>缺点：</strong>当压缩列表中某个entry的长度发生变化时，可能会导致后续entry的offset也需要更新，如果更新的entry数量较多，就会导致连锁更新，影响性能。</li></ul></li><li><p><strong>跳表（skiplist） + 字典（dict）：</strong> 在元素数量较多或元素成员较长时使用。 跳表可以提供较高的插入、删除、查找效率，但会占用更多的内存空间。 字典则用于存储member到score的映射，使得可以通过member快速查找score。</p><ul><li><strong>跳表的定义：</strong> 跳跃表（skiplist）是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳表是一种概率型数据结构，它通过随机算法来决定每个节点拥有多少个指针。 跳表是一种可以实现平均O(log N) 查找，插入，删除的有序数据结构。</li><li><strong>跳表的结构：</strong> 跳表由多层链表组成，每一层链表都包含所有的元素，但元素之间的连接方式不同。 最底层是包含所有元素的有序链表，而上层链表则以一定的概率包含下层链表的元素，从而构成一种类似于索引的结构。 节点会包含一个后退指针（backward pointer），指向位于前一个节点。 在跳表中，节点按照它们的分值大小进行排序。</li><li><strong>字典的定义：</strong> 字典，也称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。</li></ul></li></ol><p>满足这两个条件就会使用跳表</p><ol><li><strong>元素数量超过<code>zset_max_ziplist_entries</code>配置的值（默认128）：</strong> 这个配置限制了使用压缩列表存储的元素数量。</li><li><strong>集合中任一member的长度大于<code>zset_max_ziplist_value</code>配置的值（默认64）：</strong> 这个配置限制了使用压缩列表存储的元素的长度。</li></ol><h2 id="19-ziplist的底层以及改进"><a href="#19-ziplist的底层以及改进" class="headerlink" title="19.ziplist的底层以及改进"></a>19.ziplist的底层以及改进</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry1&gt;&lt;entry2&gt;...&lt;entryN&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure><p><code>zlbytes</code>：整个压缩列表占用字节数</p><p><code>zltail</code>：表尾节点距离起始地址的偏移量</p><p><code>zllen</code>：节点数量</p><p><code>entry</code>：各个节点</p><p><code>zlend</code>：标记压缩列表末端</p><p>每个entry</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen&gt;&lt;encoding&gt;&lt;entry-data&gt;</span><br></pre></td></tr></table></figure><p>当前一个节点长度从小于254字节变为大于等于254字节时,prevlen字段会从1字节扩展到5字节,可能引发后续节点的连锁扩展</p><p>然后就属于节点数量比较少的时候使用</p><p>在list中会被listpack代替，zset中被skiplist代替在listpack中，取消了prevlen字段，增加了len字段记录当前节点长度，可以从后往前遍历，避免连锁更新</p><h2 id="20-索引下推"><a href="#20-索引下推" class="headerlink" title="20.索引下推"></a>20.索引下推</h2><p>SELECT * FROM users WHERE age &gt; 20 AND name LIKE ‘张%’ AND city = ‘北京’;</p><p>存在复合索引：<code>(age, name, city)</code></p><p>没有索引下推的话，使用索引定位范围测试之后，每一个查询都需要进行回表。然后在MySQL Server层过滤name和city条件</p><p>有索引下推的话，使用索引定位完之后，在索引层直接判断，只有同时满足三个条件的记录才回表。大幅度减少回表查询的次数</p><p>因为他范围查询，会破坏后续字段的有序性。正常无法走索引，但是索引下推可以。</p><p>使用 <code>EXPLAIN</code> 命令查看执行计划，确认是否使用了索引下推优化。ICP，然后进行调试让其走索引下推</p><h2 id="21-JVM垃圾回收器"><a href="#21-JVM垃圾回收器" class="headerlink" title="21.JVM垃圾回收器"></a>21.JVM垃圾回收器</h2><p>分类：</p><p><strong>Serial / Parallel（吞吐优先）</strong></p><p><strong>CMS（低停顿）</strong></p><p><strong>G1（低停顿 + 区域化收集）</strong></p><p><strong>ZGC / Shenandoah（可预测、低延迟、支持大内存）</strong>搜集场景题</p><div class="table-container"><table><thead><tr><th>收集器</th><th>特点</th><th>回收策略</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>CMS</strong></td><td>并发回收，停顿低，已淘汰</td><td>标记-清除/存在内存碎片问题</td><td>老项目，注重响应延迟（已不推荐）</td></tr><tr><td><strong>G1</strong></td><td>分区回收，预测停顿</td><td>Region + 标记-整理</td><td>推荐，适合大内存、对吞吐和延迟平衡</td></tr><tr><td><strong>ZGC</strong></td><td>并发、低延迟、支持 TB 级堆</td><td>可并发标记/重定位</td><td>极低停顿、现代系统（JDK ≥ 17）</td></tr></tbody></table></div><h2 id="Redis-amp-数据库分布式锁"><a href="#Redis-amp-数据库分布式锁" class="headerlink" title="Redis&amp;数据库分布式锁"></a>Redis&amp;数据库分布式锁</h2><p>我们一般就是使用的redisson，Redisson 基于 RedLock；提到了锁的可重入机制；与 AQS 有类比意识；简略提到数据库锁的粒度更大，Redis 粒度更细并发性更好；</p><p>Redisson 提供的是一种 <strong>基于 Redis 的可重入分布式锁实现</strong>，其原理包括：</p><ul><li>使用 Redis 的 <code>SET key value NX PX timeout</code> 命令原子性加锁；</li><li><code>value</code> 为唯一线程标识（如 UUID + ThreadId）；</li><li>可重入：同一个线程再次加锁会对 <code>value</code> 维护一个计数器；</li><li>释放锁时会先比对线程标识，确保只有锁的拥有者可以释放；</li><li>使用 Lua 脚本释放锁，保证原子性；</li><li>提供“看门狗机制（watchdog）”，定时自动续期避免超时释放锁；</li></ul><p>数据库：</p><p>常见方式有两种：</p><ul><li>利用数据库的行级锁（如基于 <code>select ... for update</code>）；</li><li>使用数据库表记录作为“锁资源”，进行 <code>insert/update</code> 加锁；</li></ul><p>特点：</p><ul><li>实现简单，易于理解；</li><li>可靠性高（依赖事务和 ACID）；</li><li><strong>性能差</strong>，阻塞严重，不适合高并发；</li><li>不具备重入机制，不支持超时释放；</li><li>会增加数据库压力，影响主业务。</li></ul><h1 id="场景题目"><a href="#场景题目" class="headerlink" title="场景题目"></a>场景题目</h1><h2 id="1-MySQL自增ID用完了怎么办？"><a href="#1-MySQL自增ID用完了怎么办？" class="headerlink" title="1.MySQL自增ID用完了怎么办？"></a>1.MySQL自增ID用完了怎么办？</h2><p>那么我们先来分析一下，我们的自增ID最多可以多少呢？</p><p>如果是<em>INT类型</em>类型的话，普头的int，差不读能容纳约21的数据，UNSIGNED INT的话，能容纳43亿的数据</p><p>如果我们使用的BIGINT的话，-2^63^ ——2^63的数据，UNSIGNED BIGINT更多了，大约1844万亿的数据</p><p>一般的话，我们有一下几个方案：</p><p>1.INT升级到BIGINT，可以<em>使用pt-online-schema-change安全升级</em>，或者直接使用Mysql的ALTER TABLE your_table MODIFY COLUMN id BIGINT AUTO_INCREMENT;</p><p>这样的话，我们的数据量变大了，但是升级过程中会锁表，建议在维护窗口进行，而且需要同步修改相关的外键应用，而且java里面我们得用long字段而不是int字段了</p><p>2.分库分表，一般的我们可以根据ID的范围来分表，多少到多少为一个。这样分表比较简单。</p><p>3.使用UUID，是由32个十六进制数字组成的，因此一个UUID总共由128（32*4）个bit组成，也是说理论上有2的128次方个值可以使用。作为我们的自增主键，但是普通的UUID性能较差，可以使用OrderedUUID，这个有序的UUID，而且还可以将时间戳嵌入UUID的前缀，确保了有序性</p><p>4.使用雪花算法，利用机器ID和时间戳来生成64位长整型ID。最终生成的ID是会按时间递增的，但是也要考虑时钟回拨的问题，建议使用。</p><p>5.使用ID回收策略，回收被我们删除的ID，然后优先使用回收的ID，没有回收的话，才使用新的ID。一般用于实现假删除的表，但是我们需要去查，哪一些才是假删除的。</p><h2 id="2-如何把一个文件快速下发到100w个服务器"><a href="#2-如何把一个文件快速下发到100w个服务器" class="headerlink" title="2.如何把一个文件快速下发到100w个服务器"></a>2.如何把一个文件快速下发到100w个服务器</h2><p>对于100万台服务器的文件快速下发问题，我感觉可以使用P2P网络来解决</p><p>我们传统的方案是中心化下发，一个传输端发送给很多的接收端，很显然，在这个场景下不合适</p><p>我们可以设计一下</p><p><strong>构建多个独立的生成树同时传输</strong>，将100万节点构建成<strong>3-5个不相交的生成树</strong>，每个节点在不同树中担任不同角色（有时是父节点，有时是子节点），文件分片后通过不同树路径并行传输</p><p><strong>分片策略</strong>，将大文件切分为N个数据块，不同的数据块交给不同的生成树，每个节点收集所有分片之后重组文件</p><p>我们构建三层架构，<strong>种子层</strong>：5-10台高带宽服务器作为初始种子，<strong>中继层</strong>：按地理位置/网络拓扑划分的1000-5000台中继节点，<strong>叶子层</strong>：普通服务器节点</p><p>减少网络的跳数，降低延迟。然后理由网络拓扑特性，避免跨地域传输。</p><p>然后建立容错机制，每个节点连接2-3个父节点并行下载，任一节点故障时子节点自动重新寻找父节点，通过健康检查和动态调整保证传输连续性。<strong>优化策略</strong>包括最稀缺分片优先传输、自适应带宽分配、就近父节点选择等。</p><p>这样的话，我们理论上O(log N)轮传输完成，实际10-15轮即可完成。</p><p>实际上是树状结构升级为容错的多树并行网络，既保持P2P高效性又解决了单点故障和路径瓶颈问题。</p><h2 id="3-服务器上如果有很多time-wait如何解决，以及出现这个问题的场景有哪些"><a href="#3-服务器上如果有很多time-wait如何解决，以及出现这个问题的场景有哪些" class="headerlink" title="3.服务器上如果有很多time wait如何解决，以及出现这个问题的场景有哪些"></a>3.服务器上如果有很多time wait如何解决，以及出现这个问题的场景有哪些</h2><p>首先time_wait是tcp连接中，主动关闭一方的状态，等待2MSL后关闭。然后服务器出现说明是服务器主动断开的连接</p><p>比如：</p><ol><li><strong>并发Web服务</strong>：比如电商大促期间，Nginx反向代理服务器向后端应用服务器发起大量短连接请求，每次请求完成后主动关闭连接，导致Nginx服务器积累大量TIME_WAIT状态。</li><li><strong>微服务架构</strong>：服务A调用服务B的REST API，使用HTTP短连接方式，每次调用后都关闭连接。在高QPS场景下，比如订单服务调用库存服务，会产生大量TIME_WAIT。</li><li><strong>数据库连接池配置不当</strong>：应用服务器连接MySQL时，如果没有使用连接池或连接池配置过小，频繁创建和关闭数据库连接，会在应用服务器上产生大量TIME_WAIT。</li><li><strong>监控和健康检查</strong>：负载均衡器（如F5、ELB）对后端服务器进行健康检查，每次检查都是短连接，高频率的健康检查会导致后端服务器TIME_WAIT堆积。</li></ol><p>timewait过多会导致：</p><p><strong>端口耗尽</strong>：Linux默认可用端口范围是32768-65535，大约3万个端口。当TIME_WAIT状态的连接达到这个数量时，无法创建新的出站连接，出现”Cannot assign requested address”错误。</p><p><strong>内存占用</strong>：每个TIME_WAIT连接都会占用一定的内核内存，大量堆积会消耗系统资源。</p><p>我们可以使用分层解决的办法</p><p>应用层：因为可能是http短连接导致的，我们启用<strong>启用HTTP Keep-Alive</strong>，在nginx里面配置keeplive</p><p>然后可能是数据库的频繁连接导致的，我们使用连接池，HikariCP、Druid。http的连接池，HttpClient的PoolingHttpClientConnectionManager，redis的连接池，Jedis Pool</p><p>系统层：</p><ol><li><strong>开启TIME_WAIT重用</strong>，使用echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse 参数设置为1开启</li><li><strong>TIME_WAIT超时时间</strong>设计减少，尽快让其超时</li><li>扩大端口的可用范围，ip_local_port_range增大</li><li><strong>增加socket buffer</strong>，/etc/sysctl.conf里面设置’net.core.rmem_max = 16777216’</li></ol><h2 id="4-服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置"><a href="#4-服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置" class="headerlink" title="4.服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置"></a>4.服务器cpu占用过高如何去定位，如何发现和判断死锁发生的位置</h2><p>我们一般都是部署在linux服务器上，如果安装了监控软件的话，直接从监控软件上看</p><p>没有的话，我们使用top -c找出CPU占用最多的进程，然后top -H -PID 找出占用最多的线程</p><p>然后将线程ID转为16进制之后，jstack PID|grep -A 20 ID 查看其栈堆，对比找出我们具体是什么问题？</p><p>典型场景：</p><ol><li>死循环和无限递归</li><li>频繁的GC，我们可以jstat -gc PID 1000查看GC统计</li><li>正则表达式回溯，复杂的正则表达式出现了回溯</li><li>死锁，我们可以jstack PID|grep -A 5 -B “deadlock”直接显示死锁，或者是用<em>jconsole</em>等图形化工具来检测</li></ol><p>死锁的场景，<strong>数据库事务死锁</strong>，查询Mysql日志，<em>DEADLOCK</em>信息。然后在应用层的表现是，大量的线程阻塞在JDBC操作上</p><p>分布式死锁，主要是redis分布式锁，查找redis-cli keys “<em>lock</em>“，应用层表现是线程一直在等待锁</p><h2 id="5-有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现"><a href="#5-有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现" class="headerlink" title="5.有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现"></a>5.有一张200W数据量的会员表，每人会员会有长短不的到期时间，现在想在快到期之前发送邮件通知提醒续费该如何实现</h2><p>我们可以不主动查询，等用户登录到时候，执行会员过期时间的检测，给用户发送邮件提醒。但是这样用户不登录，我们没有办法提醒了就。而且我们要进行全表扫描，效率较低，数据库压力大。但我们可以将他作为补充的手段。</p><p>我们可以使用ES等搜索引擎，把会员表里的会员id和会员到期时间存储到搜索引擎里面。然后根据范围查询，查询到即将过期的用户，对他们发送消息。但是这样系统复杂度高了，而且我们还是需要进行定时轮询</p><p>可以使用redis，key为用户的id，value为该id的过期时间。然后使用redis的过期提醒功能，监视key的过期事件，检查成功发送邮件提醒。但是这样只能精确到秒，不能提前提醒，而且内存压力较大。</p><p>使用MQ延迟队列，计算该用户的过期事件，然后存储到延迟消息队列里面，轮询执行，一道过期事件发送消息。这是我们最佳的方案。</p><p>流程：</p><p>→ 计算提醒时间点（到期前7天、3天、1天）</p><p>→ 投递延迟消息到RocketMQ</p><p>→ 消息到期自动消费</p><p>→ 验证用户状态后发送邮件</p><p>然后加上补偿机制，定时执行任务，只扫描近期（如15天内）即将到期用户，然后查看是否发送，补偿未发送的。重新发送</p><p>然后这个过程中需要保持消息幂等，不应该多次发送，查询用户当前会员状态，然后检查到期时间，检查是否发送过，发送之后记录日志。消费失败后自动重试三次，发送失败进入死信队列处理。然后多个途径进行提醒。</p><p>RocketMQ作为消息队列，mysql作为主库，redis缓存用户的状态。</p><h2 id="6-假设你们系统有一个下单接口，突然并发量暴增，比如从-1k-QPS-涨到-10w-QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。"><a href="#6-假设你们系统有一个下单接口，突然并发量暴增，比如从-1k-QPS-涨到-10w-QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。" class="headerlink" title="6.假设你们系统有一个下单接口，突然并发量暴增，比如从 1k QPS 涨到 10w QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。"></a>6.假设你们系统有一个下单接口，突然并发量暴增，比如从 1k QPS 涨到 10w QPS，你会怎么优化？重点考虑系统的稳定性和响应时间。</h2><p>第一，限流。我们在网关层加了 Sentinel 做接口限流和熔断，防止系统被打垮。或者是我们使用AOP+bucket令牌桶进行限流</p><p>第二，缓存优化。我们使用了本地 + Redis 两级缓存，热点商品信息预加载，避免高并发直接打到数据库。然后防止缓存击穿，使用互斥锁</p><p>第三，异步削峰。下单写操作进入 MQ，由后台线程异步落库，极大缓解数据库压力。</p><p>第四，数据库层我们做了读写分离，写入走主库，查询走从库，提升吞吐。<br>最后就只能服务熔断了不行的话。</p><h2 id="7-你们系统中-Redis-如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？"><a href="#7-你们系统中-Redis-如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？" class="headerlink" title="7.你们系统中 Redis 如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？"></a>7.你们系统中 Redis 如果宕机了，会有哪些影响？你们是怎么保证高可用和数据一致性的？</h2><p>失效的影响：</p><p><strong>请求直打数据库</strong>：热点接口并发高时，数据库容易被压垮。</p><p><strong>响应时间变长</strong>：Redis 是内存级别，数据库响应慢，用户体验下降。</p><p><strong>缓存穿透</strong>：用户请求不存在的数据，Redis 拿不到，数据库压力大。</p><p><strong>缓存不一致</strong>：应用读了 Redis 旧值，可能会造成业务逻辑问题。</p><p>应对策略：</p><p>1）<strong>缓存高可用部署</strong></p><ul><li>Redis 使用主从 + Sentinel 实现自动故障转移；</li><li>或使用 Redis Cluster，提供分布式高可用能力。</li></ul><p>2）<strong>加缓冲 + 限流</strong></p><ul><li>引入线程池 / 信号量等方式限流；</li><li>使用本地缓存（如 Caffeine）做短时间的过渡保护。</li></ul><p>3）<strong>缓存预热 / 冷数据淘汰</strong></p><ul><li>关键数据在启动时预热到 Redis；</li><li>利用定时任务刷热点数据；</li><li>对非热点数据设置较短 TTL。</li></ul><p>4）<strong>避免缓存穿透 / 击穿 / 雪崩</strong></p><ul><li><strong>穿透</strong>：对 null 值做缓存 / 用布隆过滤器拦截；</li><li><strong>击穿</strong>：加互斥锁 / 单飞请求重建缓存；</li><li><strong>雪崩</strong>：设置随机 TTL + 限流 + 降级处理。</li></ul><p>5）<strong>降级与熔断</strong></p><ul><li>如果 Redis 和数据库都失败，降级为静态页 / 弹窗提示；</li><li>监控超时率，自动熔断部分接口，防止服务雪崩。</li></ul><p>热点数据丢失后？AOP的日志自己来恢复</p><p>用户体验如何保证？</p><p>redis的高可用，主从，哨兵，集群</p><p>缓存一致性保证，延迟双删策略</p><h2 id="8-假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？"><a href="#8-假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？" class="headerlink" title="8.假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？"></a>8.假设现在有一个高并发场景，需要统计用户访问次数，您会选择什么数据结构？为什么？</h2><p>技术选型：</p><ol><li>concurrenthashmap+AtomicLong 精确统计，但是占内存较大，不适合大量用户</li><li>Redis HyperLogLog，内存占用小，适合大基数去重，有0.81%的误差，无法获取具体的元素</li></ol><h2 id="9-您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明："><a href="#9-您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：" class="headerlink" title="9.您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明："></a>9.您在”生活商店优选”项目中提到了”多级缓存（Caffeine-Redis-MySQL）”和”基于BCP中间件监听binlog实现DB与Redis的对账”。请详细说明：</h2><p>多级缓存的数据一致性如何保证？</p><p>延迟双删+异步补偿</p><p>BCP中间件：</p><p>CDC方案，使用Canal订阅binglog然后通过MQ发送，缓存更新，允许短暂不一致，保证最终一致</p><p><strong>无侵入性</strong>：不需要修改业务代码</p><p><strong>准确性</strong>：只有事务提交后才会写入binlog</p><p><strong>完整性</strong>：捕获所有数据变更</p><p><strong>实时性</strong>：近实时同步</p><h2 id="10-mysql的分页查询优化"><a href="#10-mysql的分页查询优化" class="headerlink" title="10.mysql的分页查询优化"></a>10.mysql的分页查询优化</h2><p>SELECT * FROM products ORDER BY id LIMIT 1000000, 20;</p><p>意识到了大偏移量会导致性能问题,</p><p>需要——</p><p>扫描并排序前1000020条记录</p><p>丢弃前1000000条记录</p><p>返回后20条记录,然后即使走了索引，也要”数”1000000条记录才能定位到起始位置</p><p>我们可以使用子查询来优化，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products p1 </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1000000</span>, <span class="number">20</span></span><br><span class="line">) p2 <span class="keyword">ON</span> p1.id <span class="operator">=</span> p2.id;</span><br></pre></td></tr></table></figure><p>或者是使用游标，假设上页最后一个id是1000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-分库分表的查询如何进行"><a href="#11-分库分表的查询如何进行" class="headerlink" title="11.分库分表的查询如何进行"></a>11.分库分表的查询如何进行</h2><p>如何定位需要查询的分表？</p><p>如何聚合多个分表的结果？</p><p>如何处理分页查询？</p><p>按用户ID分表（user_id % 16）</p><p>可以使用异构索引表来查询，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product_order_index (</span><br><span class="line">    product_id BIGINT,</span><br><span class="line">    user_id BIGINT,</span><br><span class="line">    order_id BIGINT,</span><br><span class="line">    table_suffix INT,  -- 记录在哪个分表</span><br><span class="line">    INDEX(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者是引入ES搜索</p><p>然后我们如何聚合查询呢？使用归并排序</p><p>从每个分表获取足够的数据，每个分表需要取 page * size + size 条数据，然后返回冰柜排序</p><h2 id="12-大数据量找最值"><a href="#12-大数据量找最值" class="headerlink" title="12.大数据量找最值"></a>12.大数据量找最值</h2><p>就是一个非常大的数据量，然后在里面找出最大的数字</p><p>就是分三步，分桶，计数，比大小</p><p>先把大文件按照hash分成小文件，使用hash取模来分桶，同一个数字要进同一个桶</p><p>使用HashMap来找到出现次数最多的数字，然后遍历每个桶里面出现次数最多的，和当前全局最大值进行比较</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E9%9D%A2%E7%BB%8F/">面经</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/25/%E5%B7%A5%E4%BD%9C/towork/woking2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring面试题hot2-源码分析</title>
      <link>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-IOC？&quot;&gt;&lt;a href=&quot;#1-什么是-IOC？&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-什么是-IOC？"><a href="#1-什么是-IOC？" class="headerlink" title="1.什么是 IOC？"></a>1.什么是 IOC？</h2><p>IOC就是控制反转，反转之前是啥，，，反转之后是啥。。。。实现核心就是反射，设计模式是工厂模式</p><p>然后IOC和核心就是DI，几种实现方式，循环依赖的解决方式。</p><p>@bean的生命周期，@PostConstruct @PreDestroy，bean的作用域，单例，原型，websocket,session,request,application</p><p>bean的单例不一定是线程安全的，这个跟我们的业务逻辑有关，如果bean没有一个可变的成员变量，那么他就是无状态的，也就是线程安全的</p><p>我们为了保证线程安全可以改变作作用域为prototype，或者使用ThreadLocal，或者是用锁</p><p>IOC容器：</p><p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 都是Spring的IoC容器，但后者是前者的超集，提供了更强大的功能。</p><p><code>ApplicationContext</code>继承了<code>BeanFactory</code>，所以它具备<code>BeanFactory</code>的所有能力，同时还提供了更多面向企业应用的功能。它的预加载机制能帮助你在应用启动时就发现配置错误，而不是等到运行时才报错。</p><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>BeanFactory</strong></th><th style="text-align:left"><strong>ApplicationContext (推荐使用)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心定位</strong></td><td style="text-align:left">Spring IoC容器的<strong>基础接口</strong>，是“底层基础设施”。</td><td style="text-align:left">IoC容器的<strong>高级接口</strong>，是<code>BeanFactory</code>的子接口。</td></tr><tr><td style="text-align:left"><strong>Bean加载</strong></td><td style="text-align:left"><strong>懒加载 (Lazy-loading)</strong>：只有当<code>getBean()</code>被调用时，才会去实例化Bean。</td><td style="text-align:left"><strong>预加载 (Eager-loading)</strong>：容器启动时，会一次性实例化所有<code>singleton</code>作用域的Bean。</td></tr><tr><td style="text-align:left"><strong>功能丰富度</strong></td><td style="text-align:left">功能较少，主要提供Bean的注册和获取。</td><td style="text-align:left"><strong>功能非常丰富</strong>，除了<code>BeanFactory</code>的所有功能外，还提供了：</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>国际化支持 (i18n)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>事件发布与传播机制 (ApplicationEvent)</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>AOP集成</strong>（自动识别并配置<code>BeanPostProcessor</code>等）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>Web环境支持</strong>（如<code>WebApplicationContext</code>）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">- <strong>资源访问</strong>（如<code>classpath:</code>、<code>file:</code>前缀的资源加载）</td></tr><tr><td style="text-align:left"><strong>使用场景</strong></td><td style="text-align:left">对内存消耗要求极高的场景（如移动设备）。在现代企业应用开发中<strong>几乎不直接使用</strong>。</td><td style="text-align:left"><strong>绝大多数Spring应用和所有Spring Boot应用</strong>的默认选择。</td></tr></tbody></table></div><h2 id="2-什么是spring-Aop"><a href="#2-什么是spring-Aop" class="headerlink" title="2.什么是spring Aop"></a>2.什么是spring Aop</h2><p>AOP是啥，作用</p><p>实现的原理，动态代理，jdk,cgilb</p><p>几个概念，切面，连接点，通知，切点，织入</p><p>AOP通过<strong>织入(Weaving)</strong>，将<strong>切面(Aspect)</strong>中的<strong>通知(Advice)</strong>，应用到由<strong>切点(Pointcut)</strong>匹配到的<strong>连接点(Join Point)</strong>所对应的<strong>目标对象(Target)</strong>上。</p><p>通知类型，用了代理这个设计模式</p><p>代理对象（Proxy）接管了对目标对象（Target）的访问。所有外部调用都必须先经过代理对象。</p><p>代理对象在将调用请求转发给真正的目标对象<strong>之前</strong>或<strong>之后</strong>，有机会执行额外的操作。这些额外的操作，就是我们之前说的<strong>通知（Advice）</strong>，也就是切面逻辑。</p><p><strong>pring AOP的核心是基于动态代理实现的。它利用代理模式，在运行时为我们的目标Bean动态地创建一个代理对象。这个代理对象拦截了对原始Bean方法的所有调用，并在调用前后织入了我们定义的切面逻辑（比如日志、事务等），从而在不修改源代码的情况下，实现了功能的增强。</strong></p><p>这个只能作用在public方法上，所以非public的方法会失效</p><p>通知注解，@Around<strong>包裹</strong>在目标方法的整个执行过程周围。它是功能最强大、最灵活的通知。</p><p>环绕通知的第一个参数必须是<code>ProceedingJoinPoint</code>，它有一个<code>proceed()</code>方法。</p><ul><li>你可以在<strong>调用<code>proceed()</code>方法之前</strong>执行逻辑（等同于<code>@Before</code>）。</li><li>你可以<strong>决定是否调用<code>proceed()</code>方法</strong>，从而决定是否执行目标方法。</li><li>你可以在<strong>调用<code>proceed()</code>方法之后</strong>执行逻辑（等同于<code>@AfterReturning</code>）。</li><li>你可以<strong>修改目标方法的参数或返回值</strong>。</li><li>你可以<strong>捕获并处理目标方法抛出的异常</strong>（等同于<code>@AfterThrowing</code>）。</li></ul><h2 id="3-spring的常用注解"><a href="#3-spring的常用注解" class="headerlink" title="3.spring的常用注解"></a>3.spring的常用注解</h2><p>组件：</p><p><strong><code>@Component</code></strong>，标记为一个组件，生成一个bean</p><p><strong><code>@Service</code></strong>，业务层的组件注解</p><p><strong><code>@Repository</code></strong>，DTO层的组件注解，但是能让Spring<strong>自动转换特定于平台的数据库异常</strong>为统一的<code>DataAccessException</code>。</p><p><strong><code>@Controller</code></strong>，controller层的组件注解</p><p><strong><code>@Scope</code></strong>，定义Bean的作用域。最常用的两个是：</p><ul><li><code>singleton</code>：（默认值）在整个应用中只有一个实例。</li><li><code>prototype</code>：每次请求（获取）时都会创建一个新的实例。request，websocket,context,session</li></ul><p><strong><code>@PostConstruct</code></strong> 和 <strong><code>@PreDestroy</code></strong>,初始化合销毁</p><p>DI</p><p><strong><code>@Autowired</code></strong>，按<strong>类型（byType）</strong>自动注入依赖。如果找到多个相同类型的Bean，会尝试按<strong>名称（byName）</strong>匹配。如果还找不到就会报错。</p><p><strong><code>@Qualifier(&quot;beanName&quot;)</code></strong>，指定bean的名称注入，多个bean相同的</p><p><strong><code>@Resource(name = &quot;beanName&quot;)</code></strong>，默认按名称注入，找不到就按类型注入</p><p>web</p><p><strong><code>@RestController</code></strong>，专门写API的</p><p><strong><code>@RequestMapping(&quot;/path&quot;)</code></strong>，指定URL</p><p><strong><code>@RequestParam</code></strong>，从请求的URL的？中获取参数</p><p><strong><code>@PathVariable</code></strong>，从URL路径里面获取参数</p><p><strong><code>@RequestBody</code></strong>，把发过来的JSON请求体变成一个Java对象</p><p>配置</p><p><strong><code>@SpringBootApplication</code></strong>=</p><ul><li><code>@SpringBootConfiguration</code>: (就是<code>@Configuration</code>)</li><li><code>@EnableAutoConfiguration</code>: 启用Spring Boot的自动配置机制。内部使用@Import注解是自动装配的核心，每发现一个自动配置类，就Selector使用条件判断来确实是不是满足导入条件，自动创建所选bean</li><li>@AutoConfigurationPackage，将项目src中main包下的所有组件注册到容器中</li><li><code>@ComponentScan</code>: 自动扫描启动类所在包及其子包下的所有组件。</li></ul><p><strong><code>@Value</code></strong>，配置文件读取值</p><p><strong><code>@Bean</code></strong>，作用方法上</p><p><strong><code>@Configuration</code></strong>，表明配置类</p><h2 id="4-Bean"><a href="#4-Bean" class="headerlink" title="4.@Bean"></a>4.@Bean</h2><p>创建-&gt;实例化-&gt;填充属性-&gt;初始化-&gt;可用和销毁</p><p>实例化：当客户端请求一个Bean，或者在容器启动时，Spring容器会查找Bean的定义。利用java的反射机制或者工厂方法创建一个原始的bean</p><p>填充属性，IOC容器识别bean的依赖关系，比如@Autowired@Resource。从容器中查找对应的bean，通过反射将依赖注入到bean的属性中</p><p>初始化，最重要的点，扩展点最多的。</p><p><strong>执行Aware接口的方法</strong>，实现了特定的<code>Aware</code>接口，比如BeanNameAware<code>,</code>BeanFactoryAware<code>,</code>ApplicationContextAware</p><p><strong>执行<code>BeanPostProcessor</code>的前置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法。</p><p><strong>执行<code>@PostConstruct</code>注解的方法</strong>，调用使用了@postConstruct的方法</p><p><strong>执行<code>InitializingBean</code>接口的方法</strong>，实现了<code>InitializingBean</code>接口，Spring会调用它的<code>afterPropertiesSet()</code>方法。</p><p><strong>执行自定义的<code>init-method</code></strong>，如果在XML配置或<code>@Bean</code>注解中指定了<code>init-method</code>，Spring会调用这个自定义的初始化方法。</p><p><strong>执行<code>BeanPostProcessor</code>的后置处理</strong>，调用所有<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法。</p><p>Spring的<strong>AOP（动态代理）</strong>就是在这个阶段通过包装原始Bean实例，并返回一个代理对象来实现的。我们平时拿到的Bean，很多时候其实是这一步处理后的代理对象。</p><p>可用和销毁，当Spring容器关闭时（或者对于非<code>singleton</code>作用域的Bean，当其作用域结束时）。按照顺序执行</p><ul><li><strong>执行<code>@PreDestroy</code>注解的方法</strong>：如果Bean的方法上使用了<code>@PreDestroy</code>注解，Spring会调用这个方法。这也是<strong>推荐</strong>的销毁回调方式。</li><li><strong>执行<code>DisposableBean</code>接口的方法</strong>：如果Bean实现了<code>DisposableBean</code>接口，Spring会调用它的<code>destroy()</code>方法。</li><li><strong>执行自定义的<code>destroy-method</code></strong>：如果在XML配置或<code>@Bean</code>注解中指定了<code>destroy-method</code>，Spring会调用这个方法。</li></ul><p>扩展点</p><p><strong><code>BeanFactoryPostProcessor</code></strong></p><ul><li><strong>作用时机</strong>：在Spring容器<strong>加载了所有Bean的定义信息（BeanDefinition），但尚未创建任何Bean实例之前</strong>。</li><li><strong>能力</strong>：允许你<strong>读取并修改Bean的定义元数据</strong>。例如，你可以动态地修改某个Bean的属性值，甚至更改它的作用域。</li><li><p><strong>通俗理解</strong>：给你一个机会在“蓝图”阶段修改设计图纸，而不是等房子建好了再去敲墙。</p><p>比如是在<code>application.properties</code>中使用占位符 <code>$&#123;...&#125;</code> 的功能(<code>PropertySourcesPlaceholderConfigurer</code>)。MyBatis的<code>MapperScannerConfigurer</code>，它会扫描接口并将其注册为Bean定义。</p></li></ul><p><strong><code>BeanPostProcessor</code></strong></p><ul><li><p><strong>作用时机</strong>：在Bean<strong>实例化和属性填充之后，初始化方法（<code>init-method</code>, <code>@PostConstruct</code>）的前后</strong>。</p></li><li><p>能力</p><p>：包含两个方法：</p><ul><li><code>postProcessBeforeInitialization</code>: 在初始化之前干预。</li><li><code>postProcessAfterInitialization</code>: 在初始化之后干预。<strong>Spring的AOP就是通过它实现的</strong>，在此处返回Bean的代理对象。</li></ul></li><li><p><strong>通俗理解</strong>：在房子建好（实例化）并装修完（填充属性）之后，在主人入住（可用）前后，给你机会对房子进行“精装修”或“改造”（如加装监控系统-AOP）。</p></li></ul><p><strong><code>Aware</code>系列接口</strong>:</p><ul><li><strong>作用时机</strong>：在Bean的初始化阶段，<code>BeanPostProcessor</code>之前。</li><li><strong>能力</strong>：让Bean能“感知”并获取到Spring容器自身的资源，如<code>ApplicationContext</code>、<code>BeanFactory</code>、<code>BeanName</code>等。</li><li><strong>通俗理解</strong>：让Bean知道自己“身在何处”以及“叫什么名字”。</li></ul><p><strong><code>InitializingBean</code>和<code>DisposableBean</code></strong>:</p><ul><li><strong>作用时机</strong>：初始化和销毁阶段的特定回调。</li><li><strong>能力</strong>：提供<code>afterPropertiesSet()</code>和<code>destroy()</code>方法，用于自定义初始化和销毁逻辑。</li><li><strong>通俗理解</strong>：Bean的“出生仪式”和“临终遗言”的固定写法。（现在更推荐使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，因为无代码侵入）</li></ul><h2 id="5-spring事务"><a href="#5-spring事务" class="headerlink" title="5.spring事务"></a>5.spring事务</h2><p>事务分为声明型事务和编程型事务</p><p>声明型事务，通过注解<strong><code>@Transactional</code></strong>来声明，他的底层是基于AOP实现的</p><ul><li><ol><li>Spring容器在启动时，会为标记了<code>@Transactional</code>的Bean创建一个<strong>代理对象 (Proxy)</strong>。</li><li>当外部调用这个代理对象的方法时，代理逻辑会先被触发。</li><li><strong>事务开始</strong>：代理逻辑会负责开启事务（例如，禁用数据库连接的自动提交 <code>connection.setAutoCommit(false)</code>）。</li><li><strong>执行业务</strong>：然后，代理对象再调用你编写的原始业务方法。</li><li>事务提交/回滚：<ul><li>如果业务方法正常执行完毕，代理逻辑会<strong>提交</strong>事务。</li><li>如果业务方法抛出<strong>运行时异常 (RuntimeException)</strong> 或 <strong>Error</strong>，代理逻辑会<strong>回滚</strong>事务。</li></ul></li></ol></li><li><strong>优点</strong>：对业务代码<strong>无侵入</strong>，将事务管理代码与业务逻辑彻底解耦，使得代码非常清晰。</li></ul><p>编程型事务，在业务代码中，通过手动调用<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>的API来精确地控制事务的边界。</p><p>然后调用方法，自己进行手动的提交和手动的回滚</p><p>提供了极高的灵活性，可以实现非常精细的事务控制，比如在一个方法内实现多次提交或回滚。但是高耦合</p><p>事务的隔离级别跟mysql的事务的隔离级别相同。多了一个<strong><code>DEFAULT</code></strong>：这是<code>@Transactional</code>注解的<strong>默认值</strong>。它表示使用数据库本身设置的默认隔离级别。一般数据库的事务的隔离级别就是rr</p><p>或者rc?</p><p>但是事务会失效的，事务失效的场景如下：</p><p>AOP代理有关的</p><ol><li><strong>方法不是<code>public</code>的</strong><ul><li><strong>原因</strong>：Spring AOP的代理机制在为类创建代理时，只会代理其<code>public</code>方法。如果你将<code>@Transactional</code>注解用在<code>protected</code>、<code>private</code>或<code>package-private</code>方法上，事务不会生效，也不会有任何报错。</li><li><strong>一句话总结</strong>：<strong>代理对象无法覆盖非公有方法</strong>。</li></ul></li><li><strong>方法被<code>final</code>修饰</strong><ul><li><strong>原因</strong>：被<code>final</code>修饰的方法无法被子类重写（Override）。Spring的CGLIB动态代理是通过创建目标类的子类来实现的，因此无法代理<code>final</code>方法。</li><li><strong>一句话总结</strong>：<strong>final方法无法被代理</strong>。</li></ul></li><li><strong>同一个类中的方法调用（<code>this</code>调用）</strong><ul><li><strong>原因</strong>：这是最常见也最隐蔽的失效场景。当你在一个Bean的<code>methodA</code>中调用同一个类中的<code>methodB</code>（<code>methodB</code>有<code>@Transactional</code>注解）时，这个调用是通过<code>this</code>指针直接发生的，<strong>绕过了代理对象</strong>。事务增强逻辑是存在于代理对象中的，所以事务会失效。</li></ul></li></ol><p>跟运行时异常有关的</p><ol><li><strong>异常被<code>try-catch</code>捕获了</strong><ul><li><strong>原因</strong>：Spring声明式事务默认只在遇到<strong>RuntimeException或Error</strong>时才会回滚。如果你在事务方法内部用<code>try-catch</code>捕获了异常，并且没有在<code>catch</code>块中重新抛出，那么Spring的事务代理就无法感知到异常的发生，从而会正常提交事务。</li><li><strong>一句话总结</strong>：<strong>异常没有传播到代理层，代理以为一切正常</strong>。</li></ul></li><li><strong>指定了不回滚的异常类型</strong><ul><li><strong>原因</strong>：在<code>@Transactional(noRollbackFor = ...)</code>中指定了某个异常类，那么当这个异常发生时，事务将不会回滚。</li><li><strong>示例</strong>：<code>@Transactional(noRollbackFor = NullPointerException.class)</code></li></ul></li></ol><p>事务有关的</p><ol><li><strong>数据库引擎不支持事务</strong><ul><li><strong>原因</strong>：例如，MySQL的MyISAM引擎就不支持事务。如果表使用了不支持事务的引擎，所有事务相关的操作都会被静默忽略。</li><li><strong>一句话总结</strong>：<strong>底层基础不支持，上层框架无能为力</strong>。</li></ul></li><li>事务的传播类型设置的不对，比如不支持事务never</li></ol><p>事务的传播机制：</p><ol><li><strong><code>REQUIRED</code> (需要)</strong><ul><li><strong>描述</strong>：这是<strong>默认</strong>的传播特性。如果当前存在一个事务，那么新方法就<strong>加入</strong>到这个事务中。如果当前没有事务，就<strong>新建</strong>一个事务。</li><li><strong>场景</strong>：绝大多数情况下的选择。</li></ul></li><li><strong><code>SUPPORTS</code> (支持)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就加入。如果当前没有事务，就以<strong>非事务</strong>的方式执行。</li><li><strong>场景</strong>：用于那些“可有可无”的事务方法，比如一些只读查询操作。</li></ul></li><li><strong><code>MANDATORY</code> (强制)</strong><ul><li><strong>描述</strong>：<strong>强制</strong>要求当前必须存在一个事务。如果当前没有事务，就会抛出异常。它不会自己创建事务。</li><li><strong>场景</strong>：用于那些必须在事务环境下执行的核心操作，起到一种校验作用。</li></ul></li><li><strong><code>REQUIRES_NEW</code> (需要新的)</strong><ul><li><strong>描述</strong>：<strong>总是创建一个全新的、独立的事务</strong>。如果当前已经存在一个事务，会把当前事务<strong>挂起</strong>，然后执行新事务。新事务执行完毕后，再恢复被挂起的事务。</li><li><strong>场景</strong>：希望某些操作的事务结果独立于外部事务，不受其影响。比如，在一个大的下单流程中，记录操作日志，无论下单成功与否，日志都必须成功入库。</li></ul></li><li><strong><code>NOT_SUPPORTED</code> (不支持)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，会把当前事务<strong>挂起</strong>。</li><li><strong>场景</strong>：用于那些明确不希望在事务中运行的方法。</li></ul></li><li><strong><code>NEVER</code> (从不)</strong><ul><li><strong>描述</strong>：以<strong>非事务</strong>的方式执行。如果当前存在一个事务，就会抛出异常。</li><li><strong>场景</strong>：用于和<code>MANDATORY</code>相对的校验场景。</li></ul></li><li><strong><code>NESTED</code> (嵌套)</strong><ul><li><strong>描述</strong>：如果当前存在一个事务，就在这个事务中创建一个<strong>嵌套事务（保存点 Savepoint）</strong>。嵌套事务独立于外部事务进行提交或回滚。如果外部事务回滚，嵌套事务也会回滚。但嵌套事务的回滚不影响外部事务。如果当前没有事务，行为等同于<code>REQUIRED</code>。</li><li><strong>注意</strong>：这是一个部分数据库才支持的特性（如Oracle），需要底层JDBC驱动和数据库的支持。</li></ul></li></ol><h2 id="6-spring-MVC"><a href="#6-spring-MVC" class="headerlink" title="6.spring MVC"></a>6.spring MVC</h2><p>MVC 设计模式：</p><p>model-&gt;view-&gt;controller</p><p>作用：</p><ol><li><strong>实现MVC模式的解耦</strong>：它提供了一套清晰的架构，将处理请求的控制器、业务逻辑的模型和展示用的视图分离开来，极大地提高了代码的可维护性、可扩展性和可测试性。</li><li><strong>简化Web开发</strong>：它基于Servlet API构建，但极大地简化了底层的Servlet、Request、Response等对象的直接操作。开发者可以用简单的注解（如<code>@GetMapping</code>, <code>@PostMapping</code>）来处理复杂的HTTP请求。</li><li><strong>与Spring生态无缝集成</strong>：它可以非常方便地使用Spring核心的IoC和AOP功能，轻松整合Service层、DAO层以及事务管理等。</li><li><strong>提供强大的功能</strong>：内置了强大的参数绑定、数据校验、RESTful风格支持、拦截器、国际化、文件上传等一系列Web开发所需的核心功能。</li></ol><p>springmvc核心组件&amp;&amp;执行过程c</p><p>常用注解，那几个mappring 参数绑定的那几个</p><p>深入知识：</p><p>1.<strong>统一异常处理 (<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>)</strong></p><ul><li><strong>作用</strong>：通过创建一个带有<code>@ControllerAdvice</code>注解的类，可以在其中定义多个<code>@ExceptionHandler</code>方法，来集中处理整个应用中由Controller抛出的特定异常。这避免了在每个Controller中都写<code>try-catch</code>，实现了优雅的全局异常处理。</li><li><strong>示例</strong>：捕获所有<code>NullPointerException</code>，并返回一个自定义的错误JSON。</li></ul><p>2.<strong>拦截器 (<code>HandlerInterceptor</code>)</strong></p><ul><li><p><strong>作用</strong>：提供了在请求处理的生命周期中（<strong>Controller方法执行前后</strong>）织入自定义逻辑的能力。它比Servlet Filter更精细，因为它能访问到即将执行的<code>Handler</code>信息。</p></li><li><p>三大方法</p><p>：</p><ul><li><code>preHandle</code>: 在Controller方法执行<strong>之前</strong>调用。可以进行权限验证、日志记录等。返回<code>false</code>则中断后续流程。</li><li><code>postHandle</code>: 在Controller方法执行<strong>之后</strong>，视图渲染<strong>之前</strong>调用。可以修改<code>ModelAndView</code>中的数据。</li><li><code>afterCompletion</code>: 在整个请求处理完成（包括视图渲染）<strong>之后</strong>调用。主要用于资源清理。</li></ul></li><li><p><strong>与Filter的区别</strong>：Filter是Servlet规范的一部分，作用范围更广，能处理所有HTTP请求；Interceptor是Spring MVC的一部分，只能处理经过<code>DispatcherServlet</code>的请求，但能获取到Spring MVC的上下文信息。</p></li></ul><p>3.<strong>数据绑定与类型转换 (<code>DataBinder</code>, <code>Converter</code>)</strong></p><p>Spring MVC能自动将请求参数（都是字符串）转换为Controller方法参数所需的类型（如<code>Integer</code>, <code>Date</code>）。这个过程就是数据绑定。我们可以通过实现<code>Converter</code>接口，并将其注册到Spring中，来定义自定义的类型转换逻辑（例如，将”2023-01-01”字符串转换为<code>LocalDate</code>对象）。</p><p>4.<strong>跨域请求处理 (<code>@CrossOrigin</code>)</strong></p><ul><li><strong>作用</strong>：简单方便地解决Web开发中常见的跨域资源共享（CORS）问题。可以直接在<code>Controller</code>类或方法上使用<code>@CrossOrigin</code>注解，来允许来自特定域的跨域请求。</li></ul><h2 id="7-springboot"><a href="#7-springboot" class="headerlink" title="7.springboot"></a>7.springboot</h2><p>springboot是啥，四大特性（自动配置，starter，内嵌web服务器，无需xml配置）</p><p>常用的starter，Starter本质上是一个<strong>Maven依赖描述符 (pom)</strong>。它的作用是将实现某一特定功能所需的所有依赖项打包在一起，并触发与该功能相关的自动配置。</p><p>启动springboot，</p><p>spring-boot-devtools热部署工作原理：</p><p>当<code>devtools</code>检测到classpath下的文件发生变化时，它会触发应用<strong>快速重启</strong>（不是完全重启，速度很快）。它通过维护两个类加载器（一个加载不变的第三方库，一个加载你自己的代码）来实现这一点，只重新加载你自己写的代码，从而大大加快了速度。</p><p> <strong>Spring Boot JAR 与 普通JAR的区别</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><strong>普通JAR (Thin JAR)</strong></th><th style="text-align:left"><strong>Spring Boot JAR (Fat JAR / Executable JAR)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>内容</strong></td><td style="text-align:left">只包含你项目自己编译的<code>.class</code>文件和资源文件。</td><td style="text-align:left"><strong>包含所有内容</strong>：你的代码、资源文件，以及项目所需的所有第三方依赖库的JAR包。</td></tr><tr><td style="text-align:left"><strong>大小</strong></td><td style="text-align:left">非常小。</td><td style="text-align:left">非常大，因此也叫“胖JAR”。</td></tr><tr><td style="text-align:left"><strong>运行方式</strong></td><td style="text-align:left">不能直接<code>java -jar</code>运行（除非配置了<code>Main-Class</code>且无外部依赖）。通常是作为其他项目的库被引用。</td><td style="text-align:left">可以通过<code>java -jar</code>命令<strong>直接运行</strong>，因为它内置了所有依赖和启动逻辑。</td></tr><tr><td style="text-align:left"><strong>结构</strong></td><td style="text-align:left">标准JAR结构。</td><td style="text-align:left">特殊的结构。解压后会看到一个<code>BOOT-INF</code>目录，里面包含了<code>classes</code>（你的代码）和<code>lib</code>（所有依赖的JAR包）。还有一个<code>org/springframework/boot/loader</code>目录，这是Spring Boot的启动加载器。</td></tr></tbody></table></div><p>自动装配原理，Spring Boot的自动装配核心在于<code>@SpringBootApplication</code>注解，而这个注解又是一个组合注解，其中最关键的是<code>@EnableAutoConfiguration</code>。</p><ol><li><strong><code>@EnableAutoConfiguration</code></strong>：这个注解是自动配置的开关。</li><li><strong><code>@Import(AutoConfigurationImportSelector.class)</code></strong>：<code>@EnableAutoConfiguration</code>内部通过<code>@Import</code>注解导入了<code>AutoConfigurationImportSelector</code>这个类。</li><li><strong><code>AutoConfigurationImportSelector</code></strong>：这个类的核心作用是去<strong>加载和筛选</strong>需要被激活的自动配置类。</li><li><strong>扫描<code>META-INF/spring.factories</code></strong>：它会扫描项目中所有JAR包的<code>META-INF/spring.factories</code>文件。这个文件中定义了所有可能的自动配置类（key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>）。</li><li><strong>按需加载</strong>：<code>Selector</code>会根据<strong>条件注解 (<code>@ConditionalOnClass</code>, <code>@ConditionalOnBean</code>等)</strong> 来判断这些自动配置类是否满足生效条件（比如<code>DataSourceAutoConfiguration</code>只有在classpath下存在<code>DataSource.class</code>时才会生效）。</li><li><strong>注入Bean</strong>：最终，满足条件的自动配置类被加载到Spring容器中，它们内部定义的各种Bean（如<code>DataSource</code>, <code>RestTemplate</code>）就被创建并注入了。</li></ol><p>@Import注解：</p><p><code>@Import</code>是Spring框架提供的基础注解，它比<code>@Bean</code>更强大，通常用于<strong>批量导入Bean</strong>或者<strong>导入配置类</strong>。它有三种主要使用方式，而Spring Boot的自动配置正是利用了第三种：</p><ol><li><strong>导入普通的类</strong>：<code>@Import(MyService.class)</code>，Spring会将<code>MyService</code>注册为一个Bean。</li><li><strong>导入配置类</strong>：<code>@Import(MyConfig.class)</code>，Spring会加载<code>MyConfig</code>这个配置类以及它内部定义的所有<code>@Bean</code>。</li><li><strong>导入<code>ImportSelector</code>实现类</strong>：<strong>这是最关键的用法</strong>。<code>@Import(MyImportSelector.class)</code>，Spring会实例化<code>MyImportSelector</code>，并调用它的<code>selectImports()</code>方法，该方法返回一个字符串数组，数组里的每一个类名都会被Spring注册为Bean。<strong>Spring Boot的自动配置就是通过这种方式，动态地、可选择地加载了大量的配置类。</strong></li></ol><h1 id="spring源码分析"><a href="#spring源码分析" class="headerlink" title="spring源码分析"></a>spring源码分析</h1><h2 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h2><p>凡是可以存放数据的具体数据结构实现，都可以称之为容器，在 Spring Bean 容器的场景下，我们需要一种可以用于存放和名称索引式的数据结构，所以选择 HashMap 是最合适不过的。</p><p>HashMap 是一种基于扰动函数、负载因子、红黑树转换等技术内容，形成的拉链寻址的数据结构，它能让数据更加散列的分布在哈希桶以及碰撞时形成的链表和红黑树上。它的数据结构会尽可能最大限度的让整个数据读取的复杂度在 O(1) ~ O(Logn) ~O(n)之间，当然在极端情况下也会有 O(n) 链表查找数据较多的情况。不过我们经过10万数据的扰动函数再寻址验证测试，数据会均匀的散列在各个哈希桶索引上，所以 HashMap 非常适合用在 Spring Bean 的容器实现上。但是我们实际上应用的是concurrenthashmap，因为他是线程安全的。我们的bean不可能只是单线程进行操作的。他是一个弱一致性迭代器，避免了并发的修改异常。</p><p>一个简单的 Spring Bean 容器实现，还需 Bean 的定义、注册、获取三个基本步骤</p><ul><li>定义：BeanDefinition，可能这是你在查阅 Spring 源码时经常看到的一个类，例如它会包括 singleton、prototype、BeanClassName 等。</li><li>注册：这个过程就相当于我们把数据存放到 HashMap 中，只不过现在 HashMap 。在我们注册阶段Map里面存储的是beanDefintion</li><li>获取：最后就是获取对象，Bean 的名字就是key，Spring 容器初始化好 Bean 以后，就可以直接获取了。</li><li>实例化完成之后里面存储的才是bean实例</li></ul><p>我们解决循环依赖的三级缓存就是这么设计的，key是bean的名字，value是bean的实例。</p><hr><p>Spring Bean 容器的整个实现内容非常简单，也仅仅是包括了一个简单的 BeanFactory 和 BeanDefinition</p><ol><li><p>BeanDefinition，用于定义 Bean 实例化信息，现在的实现是以一个 Object 存放对象，可以继续添加属性，比如:SCOPE_SINGLETON、SCOPE_PROTOTYPE、ROLE_APPLICATION、ROLE_SUPPORT、ROLE_INFRASTRUCTURE 以及 Bean Class 信息。</p></li><li><p>BeanFactory，代表了 Bean 对象的工厂，可以存放 Bean 定义到 Map 中以及获取。</p></li></ol><p>在 Bean 工厂的实现中，包括了 Bean 的注册，这里注册的是 Bean 的定义信息。同时在这个类中还包括了获取 Bean 的操作。</p><p>然后我们使用的时候，是先初始化beanfactory容器，然后通过beanDefinition来创建一个bean。</p><p>然后去通过beanfactory去获取我们注册的bean，然后去使用bean里面封装的方法。这个时候才会实例化</p><p>然后实际我们使用的spring容器比如说是<strong>DefaultListableBeanFactory</strong>，他是继承了AbstractAutowireCapableBeanFactory，然后实现了ConfigurableListableBeanFactory, BeanDefinitionRegistry </p><p>里面包括存储BeanDefinition的容器，存储bean定义名词的列表，一级缓存，已经完成初始化的单例bean,二级缓存，早期bean的引用。三级缓存，单例工厂</p><p>我们注册bean的时候bean并没有实例化，直到获取bean的时候才会实例化，这就是懒加载</p><p>获取的时候先从一级缓存获取，缓存没有才创建bean</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>职责分清，一个接口只关注一个核心的职责，通过组合来实现多种能力。这样的话，方便我们的后续扩展和维护</p><p>比如我们的BeanFactory只负责获取bean,SingletonBeanRegistry只负责单例bean的管理，BeanDefinitionRegistry 只负责定义注册</p><p>模板方法模式，所有子类都遵循相同的Bean获取流程，子类只需实现特定的抽象方法，通用逻辑在父类中实现</p><p>比如一个抽象的基类AbstractBeanFactory定义了获取bean的标准流程，先去看一级缓存中有没有，没有的话，获取一个beandefinition，然后创建实例化这个bean</p><p>然后剩下的方法只是定义完，具体的逻辑留给子类实现</p><p>分层架构，每一层都该干属于自己的事情，比如接口层定义契约和规范，然后抽象类层，实现通用的逻辑和模板方法，实现类层，实现具体的业务逻辑实现</p><p>然后在我们的项目中，比如说实现一个支付的实现的话，我们可以先创建一个支付接口，定义一个执行方法。</p><p>然后创建一个所有的支付类共同的抽象类，实现支付的基本逻辑，先检验参数，然后执行，获取执行结果，返回执行结果</p><p>然后子类具体的去实现这个执行的逻辑，比如支付宝的具体的实现逻辑</p><p>比如说我们在项目中可以根据我们的类型来选择我们要实例化bean的模式，一般就是普通的jdk代理或者是cglib代理，可以在bean属性中class里面设定，然后我们根据属性的设定来选择我们具体是选择哪一种策略。</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>jdk实例化，首先通过 beanDefinition 获取 Class 信息，这个 Class 信息是在 Bean 定义的时候传递进去的。然后看我们获取的class信息是不是空的，空的就是无构造函数实例化，不是空的就是有构造函数实例化。这里我们重点关注有构造函数的实例化，实例化方式为 <code>clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</code>，把入参信息传递给 newInstance 进行实例化。比较简单，适用于简单的pojo对象。</p><p>cglib实例化,先是构建enhancer，设置目标为父类。设置回溯，使用noop就是说明不需要额外的处理。可以设置<code>MethodInterceptor</code>等其他回调来实现AOP功能</p><p>如果class信息为空，就enhacers默认的创建，不为空的话，就创建我们指定的构造器的类型。</p><p>支持动态代理，适用于需要进行增强的对象。运行的时候动态的生成新的class文件，比如需要事务代理，需要缓存代理的</p><div class="table-container"><table><thead><tr><th>特性</th><th>JDK反射</th><th>Cglib动态代理</th></tr></thead><tbody><tr><td><strong>实现原理</strong></td><td>Java原生反射API</td><td>字节码动态生成</td></tr><tr><td><strong>性能表现</strong></td><td>反射调用开销较小</td><td>首次创建开销大，后续调用快</td></tr><tr><td><strong>功能扩展</strong></td><td>仅支持实例化</td><td>支持方法拦截、AOP增强</td></tr><tr><td><strong>依赖要求</strong></td><td>无额外依赖</td><td>需要cglib和asm库</td></tr><tr><td><strong>代理限制</strong></td><td>无法代理final类/方法</td><td>无法代理final类/方法</td></tr></tbody></table></div><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>属性填充的时机，实在对象创建后立刻进行。<strong>. PropertyValue - 属性值载体**</strong>，PropertyValues - 属性集合管理<strong> </strong>BeanReference - 对象依赖标识**</p><ul><li><strong>延迟解析</strong>：不是直接存储Bean对象，而是存储Bean名称</li><li><strong>递归创建</strong>：在属性填充时才真正创建依赖的Bean</li><li><strong>循环依赖预留</strong>：为后续处理循环依赖留下接口</li></ul><p>属性填充方法，内部使用递归，检测到<code>BeanReference</code>类型，调用<code>getBean(beanReference.getBeanName())</code>获取他的依赖的名字</p><p>使用递归获取，被依赖的Bean创建完成后返回，用创建好的Bean对象填充当前Bean的属性</p><p>框架自动处理依赖关系，开发者无需关心创建顺序，只有真正需要这个bean的时候才会创建，提高了性能。然后我们创建后的Bean会被缓存，避免重复创建。这是缓存的思想</p><p>处理循环依赖：使用三级缓存架构来解决，一级缓存，完整的bean。二级缓存，实例化，没有进行属性的填充。三级缓存，bean的工厂对象，用于解决aop代理的问题</p><div class="table-container"><table><thead><tr><th>缓存级别</th><th>存储内容</th><th>作用</th><th>时机</th></tr></thead><tbody><tr><td><strong>一级缓存</strong></td><td>完整的Bean对象</td><td>存放完全初始化好的Bean</td><td>Bean创建完成后</td></tr><tr><td><strong>二级缓存</strong></td><td>早期Bean对象</td><td>存放实例化但未填充属性的Bean</td><td>解决循环依赖时</td></tr><tr><td><strong>三级缓存</strong></td><td>ObjectFactory</td><td>用于创建代理对象</td><td>Bean实例化后立即放入</td></tr></tbody></table></div><p>扩展支持private boolean allowCircularReference = true;</p><p><strong>DefaultSingletonBeanRegistry</strong>：</p><p>一级一级的调用，先去找一次缓存没有，标记为正在创建，然后再找二级缓存，允许早期引用。没有就从三级缓存中获取，还没有的话，<em>通过ObjectFactory创建Bean</em></p><p>然后放入二级缓存，从三级缓存中删除。</p><p>实体类方法：</p><p>实例化后立刻放入三级缓存，然后进行填充属性。然后初始化bean，成功之后放入一级缓存，标记为完成</p><p>流程：</p><p><strong>创建UserService</strong></p><ol><li>doGetBean(“userService”)</li><li>getSingleton(“userService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“userService”) → 标记正在创建</li><li>createBeanInstance() → 实例化UserService对象</li><li>addSingletonFactory(“userService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充orderService属性</li><li>getBean(“orderService”) → 触发OrderService创建</li></ol><p>创建orderService</p><ol><li>doGetBean(“orderService”)  </li><li>getSingleton(“orderService”) → null（一级缓存为空）</li><li>beforeSingletonCreation(“orderService”) → 标记正在创建</li><li>createBeanInstance() → 实例化OrderService对象</li><li>addSingletonFactory(“orderService”, ObjectFactory) → 添加到三级缓存</li><li>applyPropertyValues() → 开始填充userService属性</li><li>getBean(“userService”) → 再次请求UserService</li></ol><p>循环依赖解析</p><ol><li>doGetBean(“userService”)</li><li>getSingleton(“userService”, true) → 执行三级缓存查找<ul><li>一级缓存：null</li><li>isSingletonCurrentlyInCreation(“userService”) → true</li><li>二级缓存：null  </li><li>三级缓存：找到ObjectFactory</li><li>factory.getObject() → 返回早期UserService对象</li><li>放入二级缓存，移除三级缓存</li></ul></li><li>返回早期UserService对象给OrderService</li><li>OrderService属性填充完成</li><li>OrderService初始化完成，添加到一级缓存</li><li>返回OrderService给UserService</li><li>UserService属性填充完成</li><li>UserService初始化完成，添加到一级缓存</li></ol><p>这就是我们所说的提前暴露的问题</p><h2 id="bean管理"><a href="#bean管理" class="headerlink" title="bean管理"></a>bean管理</h2><p>使用配置文件来管理我们的bean,添加一个资源解释器，也就是能读取classpath、本地文件和云文件的配置内容</p><p>里面会包括 Bean 对象的描述和属性信息。在读取配置文件信息后，接下来就是对配置文件中的 Bean 描述信息解析后进行注册操作，把 Bean 对象注册到 Spring 容器中。</p><p>从配置文件层-&gt;资源加载层-&gt;解析注册层-&gt;bean容器层</p><hr><p>资源加载：定义 Resource 接口，提供获取 InputStream 流的方法</p><p>然后策略实现类，多种的实现策略。</p><p><strong>ClassPath资源加载</strong>：</p><p>通过 <code>ClassLoader</code> 读取<code>ClassPath</code> 下的文件信息，具体的读取过程主要是：<code>classLoader.getResourceAsStream(path)</code></p><ul><li><strong>打包后的配置文件</strong>：JAR包内的spring.xml</li><li><strong>测试资源</strong>：src/test/resources下的配置文件</li><li><strong>类路径资源</strong>：与class文件同目录的配置文件</li></ul><p><strong>文件系统资源加载</strong>：</p><p>通过指定文件路径的方式读取文件信息</p><ul><li><strong>外部配置文件</strong>：/etc/app/config.xml</li><li><strong>用户自定义配置</strong>：~/app/custom.properties</li><li><strong>绝对路径资源</strong>：D:/config/spring.xml</li></ul><p><strong>URL资源加载</strong>：</p><p>通过 HTTP 的方式读取云服务的文件，我们也可以把配置文件放到 GitHub 或者 Gitee 上，使用URLConnection</p><ul><li><strong>远程配置中心</strong>：<a href="http://config-server/app.xml">http://config-server/app.xml</a></li><li><strong>云端配置文件</strong>：<a href="https://github.com/user/repo/config.xml">https://github.com/user/repo/config.xml</a></li><li><strong>动态配置</strong>：从配置中心实时拉取</li></ul><hr><p>智能资源定位器，<strong>DefaultResourceLoader</strong></p><p>按照资源加载的不同方式，资源加载器可以把这些方式集中到统一的类服务下进行处理，外部用户只需要传递资源地址即可</p><p>使用的顺序是先去从classpath进行获取，然后再去获取url资源。都没有的话采取获取默认的文件系统资源</p><p>Bean定义读取器，BeanDefinitionReader</p><p>通过这个抽象类的具体实现就可以把解析后的 XML 文件中的 Bean 信息，注册到 Spring 容器去了。<em>以前我们是通过单元测试使用，调用 BeanDefinitionRegistry 完成Bean的注册，现在可以放到 XMl 中操作了</em></p><p>解析xml处理bean注册，<strong>XmlBeanDefinitionReader</strong> 基础自抽象类</p><p>将xml文件映射为我们需要的代码，然后进行在spring容器中的注册</p><h2 id="bean组件的扩展"><a href="#bean组件的扩展" class="headerlink" title="bean组件的扩展"></a>bean组件的扩展</h2><p>在实际工作中，当我们开发基于Spring的技术组件（如中间件、SpringBoot Starter等）时，经常需要：</p><ul><li>修改Bean的信息</li><li>添加日志打印、监控</li><li>处理数据库路由和数据源切换</li><li>给RPC服务连接注册中心</li><li>实现AOP切面功能</li></ul><p>这些都需要在Bean的生命周期中插入自定义逻辑，这就是Spring扩展机制的核心价值。</p><p><strong>BeanFactoryPostProcessor - Bean定义后置处理器</strong></p><p>在beandefinition加载完之后，bean实例化之前，可以去修改beandefinition的属性信息。相当于我们去建筑的蓝图。用于配置属性修改、Bean定义动态调整</p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 场景1：动态修改Bean的属性值</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">userServiceDef</span> <span class="operator">=</span> beanFactory.getBeanDefinition(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        <span class="type">PropertyValues</span> <span class="variable">pv</span> <span class="operator">=</span> userServiceDef.getPropertyValues();</span><br><span class="line">        pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;environment&quot;</span>, <span class="string">&quot;production&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景2：根据环境调整Bean配置</span></span><br><span class="line">        <span class="keyword">if</span> (isProductionEnvironment()) &#123;</span><br><span class="line">            pv.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;timeout&quot;</span>, <span class="string">&quot;30000&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景3：添加额外的Bean定义</span></span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;dynamicBean&quot;</span>, createDynamicBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanPostProcessor - Bean实例后置处理器</strong></p><p><em>Bean实例化和属性注入后，初始化方法调用前执行</em>,他有前置和后置的类型，我们一般在后置进行增加的更多，比如AOP代理，Bean增强，属性修改。依赖检查，权限校验和监控</p><p>ApplicationContext应用上下文架构</p><p>为了避免繁琐的操作，他是我们最常用的一个IOC容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简洁的上下文操作</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">UserService userService = context.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接口体系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 接口层次结构</span><br><span class="line">BeanFactory                           // 基础Bean工厂</span><br><span class="line">└── ListableBeanFactory              // 可列举Bean的工厂</span><br><span class="line">    └── ApplicationContext           // 应用上下文接口</span><br><span class="line">        └── ConfigurableApplicationContext  // 可配置的应用上下文</span><br><span class="line"></span><br><span class="line">// 实现层次结构  </span><br><span class="line">DefaultResourceLoader                 // 资源加载能力</span><br><span class="line">└── AbstractApplicationContext       // 上下文抽象实现</span><br><span class="line">    └── AbstractRefreshableApplicationContext     // 可刷新的上下文</span><br><span class="line">        └── AbstractXmlApplicationContext         // XML配置支持</span><br><span class="line">            └── ClassPathXmlApplicationContext    // 类路径XML上下文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在applicationcontext里面最重要的方法就是refresh方法</p><p>创建beanfactory然后加载beandefinnition</p><p>然后我们去获取beanfactory，执行<em>BeanFactoryPost</em>processor修改beandefinition</p><p>然后注册beanpostprocessor,为后续的处理进行准备</p><p>然后提前实例化单例的bean。</p><p>完整的生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. BeanDefinition注册</span><br><span class="line">        ↓</span><br><span class="line">2. BeanFactoryPostProcessor执行 ← 修改BeanDefinition</span><br><span class="line">        ↓</span><br><span class="line">3. Bean实例化（Constructor）</span><br><span class="line">        ↓</span><br><span class="line">4. 属性注入（Setter）</span><br><span class="line">        ↓</span><br><span class="line">5. BeanPostProcessor.postProcessBeforeInitialization ← Bean增强</span><br><span class="line">        ↓</span><br><span class="line">6. 初始化方法执行（@PostConstruct, InitializingBean, init-method）</span><br><span class="line">        ↓</span><br><span class="line">7. BeanPostProcessor.postProcessAfterInitialization ← AOP代理创建</span><br><span class="line">        ↓</span><br><span class="line">8. Bean就绪，放入容器</span><br><span class="line">        ↓</span><br><span class="line">9. 应用运行</span><br><span class="line">        ↓</span><br><span class="line">10. 容器关闭时执行销毁方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>BeanFactoryPostProcessor应用场景</strong>：</p><ol><li><strong>配置中心集成</strong>：动态读取远程配置修改Bean属性</li><li><strong>环境相关配置</strong>：根据环境（dev/test/prod）调整Bean配置</li><li><strong>属性占位符解析</strong>：解析${property}占位符</li><li><strong>条件化Bean注册</strong>：根据条件动态注册Bean</li></ol><p><strong>BeanPostProcessor应用场景</strong>：</p><ol><li><strong>AOP实现</strong>：Spring AOP就是通过此接口创建代理对象</li><li><strong>中间件集成</strong>：如MyBatis的MapperScannerConfigurer</li><li><strong>监控和日志</strong>：自动添加监控、日志功能</li><li><strong>依赖注入增强</strong>：如@Autowired注解的实现</li><li><strong>数据源路由</strong>：动态数据源切换</li></ol><p><strong>Spring中哪些功能使用了这些扩展机制</strong></p><p><strong>BeanFactoryPostProcessor的应用</strong>：</p><ul><li><code>PropertyPlaceholderConfigurer</code>：属性占位符解析</li><li><code>PropertySourcesPlaceholderConfigurer</code>：Spring 3.1+的属性解析</li><li><code>ConfigurationClassPostProcessor</code>：@Configuration类处理</li></ul><p><strong>BeanPostProcessor的应用</strong>：</p><ul><li><code>AutowiredAnnotationBeanPostProcessor</code>：@Autowired注解处理</li><li><code>CommonAnnotationBeanPostProcessor</code>：@Resource等注解处理</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>：AOP代理创建</li></ul><h2 id="bean的初始化和销毁"><a href="#bean的初始化和销毁" class="headerlink" title="bean的初始化和销毁"></a>bean的初始化和销毁</h2><p>完整的生命周期：</p><p>Bean定义注册<br>    ↓<br>BeanFactoryPostProcessor执行<br>    ↓<br>Bean实例化（Constructor）<br>    ↓<br>属性注入（Setter/Field）<br>    ↓<br>BeanPostProcessor.postProcessBeforeInitialization<br>    ↓<br>InitializingBean.afterPropertiesSet() ← 接口方式初始化<br>    ↓<br>init-method执行 ← XML配置方式初始化<br>    ↓<br>BeanPostProcessor.postProcessAfterInitialization<br>    ↓<br>Bean就绪状态<br>    ↓<br>容器关闭触发<br>    ↓<br>DisposableBean.destroy() ← 接口方式销毁<br>    ↓<br>destroy-method执行 ← XML配置方式销毁</p><p>在这个里面,init-method和destory-method他们也是要xml配置来进行的。所以也要通过 XmlBeanDefinitionReader 加载 spring.xml 配置信息到 BeanDefinition 中。</p><ul><li>InitializingBean、DisposableBean，两个接口方法还是比较常用的，在一些需要结合 Spring 实现的组件中，经常会使用这两个方法来做一些参数的初始化和销毁操作。比如接口暴漏、数据库数据读取、配置文件加载等等。</li><li>在方法 invokeInitMethods 中，主要分为两块来执行实现了 InitializingBean 接口的操作，处理 afterPropertiesSet 方法。另外一个是判断配置信息 init-method 是否存在，执行反射调用 initMethod.invoke(bean)。这两种方式都可以在 Bean 对象初始化过程中进行处理加载 Bean 对象中的初始化操作，让使用者可以额外新增加自己想要的动作。先执行接口方式，再执行配置方式，通过反射避免重复执行同名方法</li><li>方法destory跟上面的invokeinitMethods差不多，都是先实现接口，然后<em>配置信息 destroy-method {判断是为了避免二次执行销毁}</em></li></ul><p>虚拟机关闭钩子：</p><ul><li>首先我们需要在 ConfigurableApplicationContext 接口中定义注册虚拟机钩子的方法 <code>registerShutdownHook</code> 和手动执行关闭的方法 <code>close</code>。</li><li>在抽象实现类里面进行实现，注册JVM关闭构造的时候，是Runtime.getRuntime().addShutdownHook</li></ul><p>1.<strong>初始化方法和构造函数的区别？</strong></p><p>主要的区别在于执行的实际和功能定位，构造函数执行的时候，依赖注入还没完成，无法进行初始化</p><p>初始化方法执行的时候，所有属性已经完成。可以使用依赖对象进行初始化。比如建立数据库连接池，缓存预热，注册到注册中心</p><p>然后构造函数主要用于对象创建、基本属性设置，初始化方法主要使用依赖就绪后的业务初始化</p><p>2.<strong>为什么需要销毁方法？不能依赖GC吗</strong></p><p>GC只能回收内存，不能处理资源的释放</p><p>比如，socket,http连接，文件流，数据库连接等。比如线程池，定时器。还有注册中心，Mbean</p><p>3.<strong>Spring中哪些组件使用了初始化/销毁机制？</strong></p><p><strong>几乎所有核心组件都有应用</strong>，比如数据源组件，初始化连接池，销毁连接池</p><p>缓存组件，初始化缓存预热，关闭redis连接</p><p><strong>消息队列</strong>，启动监听消息队列，停止监听关闭消息队列</p><p>4.<strong>如何保证初始化方法的执行顺序？</strong></p><p>使用<em>@DependsOn</em>注解，就是一个前置条件，<em>确保configService和cacheService先初始化</em></p><p><strong>@Order注解配合ApplicationListener</strong>，数字越小，约先执行。</p><p><em>实现Ordered接口</em>，然后确定高优先级的初始化</p><p>5.<strong>如何处理初始化方法的异常？</strong></p><ol><li><strong>快速失败</strong>：关键资源初始化失败时立即抛异常</li><li><strong>优雅降级</strong>：非关键失败时使用备用方案</li><li><strong>延迟重试</strong>：网络等临时性失败可以重试</li></ol><h2 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h2><p>Aware是Spring提供的一种<strong>容器感知机制</strong>，让Bean能够获取Spring容器中的各种资源和服务。它是一个<strong>标记接口</strong>，通过实现不同的Aware子接口，Bean可以感知到：</p><ul><li>BeanFactory</li><li>ApplicationContext</li><li>ClassLoader</li><li>Bean名称</li><li>以及其他容器资源</li></ul><p>继承 Aware 的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware</p><p>在具体的接口实现过程中你可以看到，一部分(<em>BeanFactoryAware、BeanClassLoaderAware、BeanNameAware</em>)在 factory 的 support 文件夹下，另外 ApplicationContextAware 是在 context 的 support 中，这是因为不同的内容获取需要在不同的包下提供。所以，在 AbstractApplicationContext 的具体实现中会用到向 beanFactory 添加 BeanPostProcessor 内容的 <code>ApplicationContextAwareProcessor</code> 操作，最后由 AbstractAutowireCapableBeanFactory 创建 createBean 时处理相应的调用操作。</p><p>Aware接口</p><ul><li><p>在 Spring 中有特别多类似这样的标记接口的设计方式，它们的存在就像是一种标签一样，可以方便统一摘取出属于此类接口的实现类，通常会有 instanceof 一起判断使用。</p></li><li><p><strong>标记模式</strong>：类似于<code>Serializable</code>接口，用于标识具有某种特性的类</p></li><li><strong>instanceof判断</strong>：通过<code>bean instanceof Aware</code>统一识别和处理</li><li><strong>统一管理</strong>：将所有感知接口归类到一个体系下</li></ul><p>四大核心感知接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 感知BeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 感知ClassLoader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanClassLoaderAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 感知Bean名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 感知ApplicationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用感知：</p><ul><li>首先在 initializeBean 中，通过判断 <code>bean instanceof Aware</code>，调用了三个接口方法，<code>BeanFactoryAware.setBeanFactory(this)</code>、<code>BeanClassLoaderAware.setBeanClassLoader(getBeanClassLoader())</code>、<code>BeanNameAware.setBeanName(beanName)</code>，这样就能通知到已经实现了此接口的类。</li><li><p>另外我们还向 BeanPostProcessor 中添加了 <code>ApplicationContextAwareProcessor</code>，此时在这个方法中也会被调用到具体的类实现，得到一个 ApplicationContex 属性。</p></li><li><p>确保Bean获得感知能力后再进行业务初始化</p></li></ul><p><strong>ApplicationContext</strong>比较特殊他要单独去执行在refresh方法中进行，ApplicationContext在<code>AbstractAutowireCapableBeanFactory</code>中不可直接获取，需要在容器启动时注册专门的处理器，体现了<strong>分层架构</strong>的设计思想。ApplicationContextAwareProcessor在ApplicationContext，其他的他们在<em>BeanFactory层</em> 。</p><p>实现：</p><ol><li>在ApplicationContext层创建<code>ApplicationContextAwareProcessor</code></li><li>将processor注册到BeanFactory中</li><li>利用BeanPostProcessor机制在Bean初始化时注入ApplicationContext</li></ol><p>题目：</p><p>1.<strong>Aware接口的作用是什么？</strong></p><p><strong>Aware接口提供了Bean获取Spring容器资源的标准机制：</strong></p><ol><li><strong>容器感知</strong>：让Bean能够感知到Spring容器的存在</li><li><strong>资源获取</strong>：提供获取容器内部资源的标准方式</li><li><strong>扩展能力</strong>：为开发中间件和框架提供扩展点</li><li><strong>解耦设计</strong>：通过接口回调而非静态方法获取资源</li></ol><p>比如setApplicationContext方法，可以获取容器中的其他的bean，发布应用事件，可以获取环境配置</p><p>setBeanFactory方法，可以动态获取bean，检查bean是不是存在</p><p>2.<strong>不同Aware接口的执行顺序是什么？</strong></p><p>\1. BeanNameAware.setBeanName()</p><p>\2. BeanClassLoaderAware.setBeanClassLoader()  </p><p>\3. BeanFactoryAware.setBeanFactory()</p><p>\4. EnvironmentAware.setEnvironment() (如果实现)</p><p>\5. EmbeddedValueResolverAware.setEmbeddedValueResolver() (如果实现)</p><p>\6. ResourceLoaderAware.setResourceLoader() (如果在ApplicationContext中)</p><p>\7. ApplicationEventPublisherAware.setApplicationEventPublisher() (如果在ApplicationContext中)</p><p>\8. MessageSourceAware.setMessageSource() (如果在ApplicationContext中)</p><p>\9. ApplicationContextAware.setApplicationContext() (如果在ApplicationContext中)</p><ul><li><strong>Bean自身信息</strong>先设置（Name、ClassLoader、Factory）</li><li><strong>容器环境信息</strong>后设置（Context、Environment等）</li><li><strong>应用层面信息</strong>最后设置（Event、Message等）</li><li>最后是我们的context</li></ul><p>3.<strong>Aware机制与@Autowired的区别？</strong></p><div class="table-container"><table><thead><tr><th>对比维度</th><th>Aware接口</th><th>@Autowired</th></tr></thead><tbody><tr><td><strong>注入对象</strong></td><td>Spring容器内部资源</td><td>业务Bean对象</td></tr><tr><td><strong>执行时机</strong></td><td>Bean初始化阶段</td><td>属性注入阶段</td></tr><tr><td><strong>耦合度</strong></td><td>与Spring框架耦合</td><td>相对解耦</td></tr><tr><td><strong>使用场景</strong></td><td>框架扩展、中间件开发</td><td>业务依赖注入</td></tr><tr><td><strong>灵活性</strong></td><td>可以获取容器的动态能力</td><td>静态依赖关系</td></tr></tbody></table></div><h2 id="FactoryBean-amp-Bean的作用域"><a href="#FactoryBean-amp-Bean的作用域" class="headerlink" title="FactoryBean&amp;Bean的作用域"></a>FactoryBean&amp;Bean的作用域</h2><p>FactoryBean是Spring提供的一种<strong>创建复杂Bean对象的工厂接口</strong>，它允许我们自定义Bean的创建逻辑，特别适用于：</p><ul><li><strong>代理对象创建</strong>（如MyBatis的Mapper代理）</li><li><strong>复杂对象初始化</strong>（需要多步骤构建的对象）</li><li><strong>第三方框架集成</strong>（将外部框架的对象纳入Spring管理）</li></ul><p><strong>Bean作用域（Scope）机制</strong></p><p>Spring支持多种Bean作用域：</p><ul><li><strong>singleton</strong>：单例模式（默认），容器中只有一个实例</li><li><strong>prototype</strong>：原型模式，每次获取都创建新实例</li><li><strong>request/session/application</strong>：Web环境中的作用域</li></ul><p>单例模式和原型模式的区别就在于是否存放到内存中，如果是原型模式那么就不会存放到内存中，每次获取都重新创建对象</p><p>这就是我们常说的五大作用域</p><p>FactoryBean设计：获取对象、对象类型，以及是否是单例对象</p><p>比如我们的<strong>MyBatis Mapper代理创建</strong>就是我们自定义的一个FactoryBean， 使用 <code>MapperFactoryBean</code> 将<strong>接口注册为代理对象</strong>，启动时会把接口方法解析成 <code>MappedStatement</code> 存入 Configuration 中，运行时由 <code>MapperProxy</code> 通过反射动态执行 SQL。</p><p>还有数据源代理等等。</p><p>作用域就是我们定义在BeanDefinition中的一个常量，然后我们通过指定scpore字段来定义</p><p>然后xml解析回去xml里获取作用域，然后设置beandefinition的信息</p><p>1.<strong>FactoryBean和BeanFactory的区别？</strong></p><div class="table-container"><table><thead><tr><th>对比维度</th><th>BeanFactory</th><th>FactoryBean</th></tr></thead><tbody><tr><td><strong>性质</strong></td><td>Spring容器的根接口</td><td>用户可实现的工厂接口</td></tr><tr><td><strong>作用</strong></td><td>管理Bean的生命周期</td><td>创建复杂的Bean对象</td></tr><tr><td><strong>使用者</strong></td><td>Spring框架内部使用</td><td>开发者实现和使用</td></tr><tr><td><strong>获取方式</strong></td><td>通过ApplicationContext</td><td>通过getBean()获取其产品</td></tr></tbody></table></div><p>2.<strong>如何获取FactoryBean本身而不是它创建的对象</strong></p><p>使用&amp;的前缀符表示我们需要的是FactoryBean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyFactoryBean factoryBean = (MyFactoryBean) applicationContext.getBean(&quot;&amp;myFactoryBean&quot;);</span><br></pre></td></tr></table></figure><p>然后内部处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;&amp;&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 去掉&amp;前缀，获取FactoryBean本身</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">factoryBeanName</span> <span class="operator">=</span> name.substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getFactoryBean(factoryBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常获取FactoryBean创建的对象</span></span><br><span class="line">        <span class="keyword">return</span> getObjectForBeanInstance(getSingleton(name), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.<strong>FactoryBean在什么场景下使用？</strong></p><p>代理对象的创建，<strong>复杂对象初始化</strong>， <strong>第三方框架集成</strong>（比如redis中设置redis的运行的参数和序列化方式）</p><p>4.<strong>FactoryBean的生命周期是怎样的？</strong></p><p><strong>FactoryBean有双重生命周期</strong>，一个是他本身的生命周期，一个是他产品对象的生命周期</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Event机制</p><p>在复杂的业务系统中，直接调用会导致<strong>紧耦合</strong>问题：</p><ul><li><strong>用户注册</strong> → 直接调用发送邮件、赠送积分、风控检查等服务</li><li><strong>订单支付</strong> → 直接调用库存扣减、物流发货、积分计算等服务</li><li><strong>文章发布</strong> → 直接调用消息推送、索引更新、缓存刷新等服务</li></ul><p>这种方式会导致：</p><ol><li><strong>代码耦合度高</strong>：核心业务逻辑与辅助功能混杂</li><li><strong>扩展性差</strong>：新增功能需要修改核心代码</li><li><strong>维护困难</strong>：一个环节出错影响整个流程</li><li><strong>性能问题</strong>：同步执行所有操作，响应慢</li></ol><p>我们可以通过观察者模式进行解耦</p><p>用户注册成功 → 发布UserRegisteredEvent → 多个监听器异步处理</p><p>├── EmailListener: 发送欢迎邮件</p><p>├── CouponListener: 赠送新人礼包  </p><p>├── RiskListener: 风控分析</p><p>└── StatisticsListener: 数据统计</p><p>spring event</p><p>定义出事件类、事件监听、事件发布 事件广播器</p><p>applicationevent-&gt;applicationlistener-&gt;applicationeventpublisher-&gt;applicaitoneventmulticaster</p><p>我们事件类是构建一个基本的抽象类，然后其他的具体事件继承这个抽象类</p><p>事件广播器定义了添加监听和删除监听的方法，和添加广播的方法。<code>multicastEvent</code> 最终推送时间消息也会经过这个接口方法来处理谁该接收事件。</p><p>那我们怎么处理事件广播的并发处理呢？</p><ul><li><strong>监听器隔离</strong>：一个监听器异常不影响其他监听器</li><li><strong>异步执行</strong>：可配置同步或异步处理</li><li><strong>顺序控制</strong>：支持监听器执行顺序</li></ul><p>然后我们怎么去确定某个事件如何被监听器处理？我们使用泛型参数匹配来实现</p><p>我们先去获取监听的class，然后如果存在GCLIB代理的话，我们处理CGLIB代理。spring中Bean可能被代理，需要获取真实类型，就是他的父类。</p><p>然后获取泛型接口，提取泛型参数，获取事件的类型。</p><p>然后判断事件是否匹配，就是判断ParameterizedType 和eventClassName是不是子类和父类的关系</p><p>事件发布器，初始化事件发布者(initApplicationEventMulticaster)，</p><ul><li><p>主要用于实例化一个 SimpleApplicationEventMulticaster，这是一个事件广播器。</p></li><li><p>注册事件监听器(registerListeners)，通过 getBeansOfType 方法获取到所有从 spring.xml 中加载到的事件配置 Bean 对象。</p></li><li>发布容器刷新完成事件(finishRefresh)，发布了第一个服务器启动完成后的事件，这个事件通过 publishEvent 发布出去，其实也就是调用了 applicationEventMulticaster.multicastEvent(event); 方法。</li></ul><p>问题</p><p>1.spring event事件执行的流程：</p><ol><li><strong>事件定义</strong>：继承<code>ApplicationEvent</code>创建事件类</li><li><strong>监听器注册</strong>：实现<code>ApplicationListener</code>并注册到容器</li><li><strong>事件发布</strong>：通过<code>ApplicationEventPublisher.publishEvent()</code>发布</li><li><strong>事件广播</strong>：<code>ApplicationEventMulticaster</code>接收事件</li><li><strong>监听器匹配</strong>：根据泛型参数匹配感兴趣的监听器</li><li><strong>事件处理</strong>：调用匹配监听器的<code>onApplicationEvent()</code>方法</li></ol><p>2.<strong>如何保证Event处理的事务一致性？</strong></p><p>使用事件同步机制，事务提交后执行事务监听器，发送邮件通知等，然后事务回滚的时候发送清理操作</p><p>通过@TransactionalEventListener的状态来确定</p><p>然后失败之后通过补偿机制。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是我们spring的AOP的</p><p>AOP主要就是解耦，他将跟核心业务没关系的业务比如权限，日志等业务的抽离出来，一般都是以注释的形式。然后方法只执行业务核心方法</p><p>动态代理分为JDK动态代理和CGLIB动态代理</p><p>JDK动态代理基于接口，代理实现了接口的类，在运行时动态生成代理类的字节码。速度较快，不需要生成新的字节码</p><p>JdkDynamicAopProxy实现了AopProxy, InvocationHandler</p><p>获取代理方式，获取当前线程的context类加载器，然后通知通知添加目标接口。然后执行<em>InvocationHandler实现</em></p><p>然后使用Invoke方法，执行代理。检查方法是不是匹配切点表达式，匹配成功后执行方法拦截器，拦截，然后换取我们自己实现的bean。如果不匹配的话，我们就执行原来的方法</p><p>CGLIB动态是基于继承目标类生成子类代理，使用了使用ASM字节码技术。除了final都可以代理，速度较慢，需要生成字节码。但是性能较好</p><p>get方法是通过设置我们的需要代理的类，然后设置接口，设置回调处理器</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/spring/">spring</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/spring3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试总结</title>
      <link>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/</link>
      <guid>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/</guid>
      <pubDate>Fri, 18 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;面试题目类型&quot;&gt;&lt;a href=&quot;#面试题目类型&quot; class=&quot;headerlink&quot; title=&quot;面试题目类型&quot;&gt;&lt;/a&gt;面试题目类型&lt;/h1&gt;&lt;h2 id=&quot;双指针&quot;&gt;&lt;a href=&quot;#双指针&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="面试题目类型"><a href="#面试题目类型" class="headerlink" title="面试题目类型"></a>面试题目类型</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>76题目，最小覆盖字串。</p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p>我们可以用滑动窗口，因为他是只是覆盖，不需要我们要求顺序一样。每个字母的出现次数一样就可以。那么我们可以使用一个数组来统计字母和出现的次数</p><p>然后使用滑动窗口涵盖字串，进-&gt;统计次数-&gt;减少次数</p><p>当最小次数为0的时候，这个时候如果滑动窗口的长度小于结果的长度的时候</p><p>更新节点位置</p><p>然后出左节点，如果需要出现的为0了</p><p>那么最少字母次数++</p><p>然后左端点对应的字母需要次数++，左端点移动</p><p>最后需要的是结果左端点和右端点之间的</p><p>也就是我们常说的right-left+1</p><h2 id="堆-amp-栈"><a href="#堆-amp-栈" class="headerlink" title="堆&amp;栈"></a>堆&amp;栈</h2>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/19/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodetotal2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 基础知识</title>
      <link>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;普通概念&quot;&gt;&lt;a href=&quot;#普通概念&quot; class=&quot;headerlink&quot; title=&quot;普通概念&quot;&gt;&lt;/a&gt;普通概念&lt;/h1&gt;&lt;h2 id=&quot;Model&quot;&gt;&lt;a href=&quot;#Model&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="普通概念"><a href="#普通概念" class="headerlink" title="普通概念"></a>普通概念</h1><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><ul><li><strong>ChatModel</strong>: 基于<strong>自回归语言模型</strong>，其核心是 <strong>Transformer Decoder</strong> 架构。它通过“逐字生成”的方式工作：接收一段文本（Prompt），预测下一个最可能的词（Token），然后将新生成的词加入输入，再次预测下一个，如此循环，直到生成完整的回答。这种机制保证了生成文本的上下文连贯性和逻辑性。</li><li><strong>EmbeddingModel</strong>: <code>EmbeddingModel</code>（如text-embedding-ada-002、text2vec-chinese）基于<strong>双向编码器</strong>，其核心是 <strong>Transformer Encoder</strong> 架构。与ChatModel不同，它会同时分析整个输入文本的上下文，然后将文本的深层语义信息<strong>映射</strong>到一个高维、密集的数字向量（Vector）中。在这个向量空间里，语义上相似的文本在空间距离上会更接近。</li></ul><p>EmbeddingModel负责检索阶段：就是我们常说的嵌入模型</p><p>- 将查询和文档转换为向量表示</p><p>- 通过余弦相似度计算相关性</p><p>- 检索最相关的K个文档片段</p><p>ChatModel负责生成阶段：就是我们常用的聊天的那种模型</p><p>- 接收检索到的上下文+用户查询</p><p>- 基于上下文生成回答</p><p>- 保证回答的连贯性和准确性</p><p>那么我们如何选择模型呢？</p><ol><li><p>维度大小：向量的维度。维度越高，通常能编码更丰富的语义信息，但也会增加存储和计算开销。</p><ul><li><strong>示例</strong>：<code>BERT-base</code> 通常是768维，而OpenAI的 <code>text-embedding-ada-002</code> 是1536维。</li></ul></li><li><p>语言支持：模型是否针对特定语言（如中文）进行过优化。对于中文场景，使用专门的中文Embedding模型（如 <code>text2vec-chinese</code>）效果远超通用模型。</p></li><li><p>领域适配：通用模型在开放域表现良好，但在专业领域（如法律、医疗），使用经过该领域数据微调过的模型能显著提升准确性。</p></li><li><p>性能指标：</p><p>检索准确率 (Recall/Precision)：衡量Embedding模型检索到的相关文档的准确度。</p><p>推理延迟 (Latency)：模型处理一次请求所需的时间，直接影响用户体验。</p></li></ol><p>比如我自定义知识库使用的就是Embedding v2 ada</p><p>重排模型:</p><h2 id="VectorStore"><a href="#VectorStore" class="headerlink" title="VectorStore"></a>VectorStore</h2><p><code>VectorStore</code> 负责存储<code>EmbeddingModel</code>生成的向量，并提供高效的相似度检索能力。</p><div class="table-container"><table><thead><tr><th>特性</th><th>Redis Vector</th><th>Pinecone</th><th>Weaviate</th></tr></thead><tbody><tr><td><strong>架构</strong></td><td>内存+持久化</td><td>云原生分布式</td><td>图数据库+向量</td></tr><tr><td><strong>索引算法</strong></td><td>HNSW/IVF</td><td>专有优化算法</td><td>HNSW</td></tr><tr><td><strong>存储成本</strong></td><td>中等(内存占用高)</td><td>高(按量计费)</td><td>低(开源版免费)</td></tr><tr><td><strong>检索延迟</strong></td><td>&lt;10ms</td><td>10-50ms</td><td>20-100ms</td></tr><tr><td><strong>扩展性</strong></td><td>水平扩展复杂</td><td>自动扩缩容</td><td>手动扩展</td></tr></tbody></table></div><ul><li><strong>小规模验证 (&lt;10万文档)</strong>：<strong>Redis Vector</strong> 是绝佳选择。部署简单，延迟极低，与现有Java生态无缝集成。</li><li><strong>中等规模生产 (10万-1000万)</strong>：<strong>Pinecone</strong> 提供完全托管的服务，免去运维烦恼，让你专注于业务逻辑。</li><li><strong>大规模或定制化场景 (&gt;1000万)</strong>：<strong>Weaviate</strong> 的开源和分布式特性提供了极高的灵活性和成本优势，但需要投入运维资源。</li><li><strong>成本敏感场景</strong>：<strong>Weaviate 开源版</strong> 自建部署是理想选择。</li></ul><h2 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h2><p>RAG就是检索增强，是一种让LLM访问外部知识库以回答问题的框架，极大地减少了模型幻觉，提高了回答的准确性。</p><p>我们使用嵌入模型的时候是需要对我们传入的文档进行切分的</p><p>切分策略：</p><p>一般的切分策略就是按照大小进行切分的，一般就是多少个字就切分。这样的话比较简答，但是可能破坏语句的完整性。适用于API，代码等</p><p>还有就是按照语义进行切分，这样就是按照句子边界，标点符号进行切分。这样保证了语句的完整性，但是我们切分的效率比较慢。适用于文章报告等</p><p>我们切分的时候要去按照场景进行选择</p><ul><li><p><strong>检索准确率</strong>：语义切分通常能确保每个Chunk包含完整的答案片段，从而提升准确率。</p></li><li><p><strong>上下文利用率</strong>：合适的Chunk大小可以最大化利用模型的上下文窗口，不多也不少。</p></li><li><p><strong>重叠比例 (Overlap)</strong>：设置一部分重叠内容（如10%）可以防止重要信息在切分边界处丢失。</p><p>在Spring AI中，通常通过实现<code>DocumentTransformer</code>接口来定义切分逻辑。</p></li></ul><hr><p>检索策略：</p><p>密集检索，就是使用模型调用embed方法，然后调用向量库进行密集搜索。这样的话语义理解强，但是对罕见词汇搜索较差</p><p>bm25检索，传统的关键词匹配算法，对罕见词、专业术语友好，但缺乏语义理解。</p><p>混合检索，就待用密集检索和bm25检索，然后分析文档。结合了两种检索，但是复杂度增加了</p><h2 id="上下文构建"><a href="#上下文构建" class="headerlink" title="上下文构建"></a>上下文构建</h2><p>检索到的文档片段不能直接丢给LLM，需要精心组织成“上下文”（Context），以避免噪声干扰。</p><p> 1.如何避免<strong>上下文噪声干扰</strong>？</p><ul><li><strong>重排序 (Reranking)</strong>：使用更轻量、但更精确的模型（如Cross-Encoder）对初步检索到的Top-K结果进行二次排序，将最相关的文档排在最前面。</li><li><strong>上下文压缩 (Context Compression)</strong>：从检索到的文档中提取与用户问题最相关的句子或摘要，丢弃无关信息，减少噪声。</li><li><strong>分层检索 (Hierarchical Retrieval)</strong>：对于结构化的长文档，可以先检索到相关的章节标题，再在章节内部进行精确检索。</li><li><strong>动态上下文长度 (Dynamic Context Length)</strong>：根据问题的复杂度和模型上下文窗口的限制，动态调整送入模型的文档数量。</li></ul><p>在Spring AI中，这些策略通常在调用<code>ChatModel</code>之前，通过自定义逻辑实现。</p><h2 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h2><p> 函数调用允许LLM将自然语言指令转化为对外部工具（API、数据库查询等）的结构化调用。</p><ul><li><p><strong>参数校验</strong>：这是安全的第一道防线。可以使用<strong>JSON Schema</strong>来定义函数期望的参数格式、类型和范围，在执行前进行严格校验。</p></li><li><p>安全机制</p><ul><li><strong>参数沙箱</strong>：绝不直接将用户输入用于代码执行或数据库查询，进行严格的无害化处理。</li><li><strong>权限控制</strong>：根据用户身份，限制其能调用的函数集合。</li><li><strong>执行隔离/超时</strong>：在独立、受限的环境中执行函数，并设置超时，防止恶意调用消耗系统资源。</li><li><strong>审计日志</strong>：记录所有函数调用，便于追踪和分析。</li></ul></li><li><p><strong>错误处理</strong>：健壮的错误处理至关重要。需要明确处理参数验证失败（<code>ParameterValidationException</code>）、执行超时（<code>ExecutionTimeoutException</code>）、资源超限（<code>ResourceLimitException</code>）等情况，并设计合理的<strong>重试策略</strong>（如使用<code>@Retryable</code>）</p><p>先捕捉ParameterValidationException，参数验证</p><p>再捕捉ExecutionTimeoutException，执行超时</p><p>再捕捉ResourceLimitException，资源限制</p><p>然后再执行重试策略，加上重试注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))</span><br></pre></td></tr></table></figure></li></ul><p>在Spring AI中，你可以定义一个<code>@Bean</code>，通过<code>@Description</code>注解描述其功能，Spring AI会自动将其注册为可供LLM调用的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionParameterValidator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ValidationResult <span class="title function_">validate</span><span class="params">(FunctionCall call)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ValidationResult.builder()</span><br><span class="line">            .typeValidation(validateTypes(call.getParameters()))</span><br><span class="line">            .rangeValidation(validateRanges(call.getParameters()))</span><br><span class="line">            .formatValidation(validateFormats(call.getParameters()))</span><br><span class="line">            .businessValidation(validateBusinessRules(call.getParameters()))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validateTypes</span><span class="params">(Map&lt;String, Object&gt; params)</span> &#123;</span><br><span class="line">        <span class="comment">// JSON Schema验证</span></span><br><span class="line">        <span class="comment">// 类型强制转换</span></span><br><span class="line">        <span class="comment">// null值处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>Agent是什么，是一个自主决策的智能体</p><p><strong>如何设计多Agent协作的通信机制？</strong></p><p>消息总线模式：</p><p>   - 使用Redis/RabbitMQ作为消息中介</p><p>   - Agent间异步通信</p><p>   - 支持广播和点对点通信</p><p>协调者模式：</p><p>   - 中央协调器管理任务分配</p><p>   - Agent向协调器汇报状态</p><p>   - 协调器负责冲突解决</p><p>契约式协作：</p><p>   - 定义Agent间的服务契约</p><p>   - 使用OpenAPI规范描述接口</p><p>   - 支持版本管理和向后兼容</p><p>状态同步机制：</p><p>   - 共享状态存储(Redis Cluster)</p><p>   - 乐观锁处理并发冲突</p><p>   - 事件溯源记录状态变更</p><p>决策树/状态机实现：</p><ul><li>可以使用<strong>状态机</strong>来定义Agent的行为逻辑。例如，一个Agent的状态可以流转于：<code>IDLE</code> -&gt; <code>PLANNING</code> -&gt; <code>EXECUTING_TOOL</code> -&gt; <code>WAITING_FOR_RESULT</code> -&gt; <code>COMPLETED/ERROR</code>。每个状态转移都由特定的事件触发。这种方式使得Agent的行为清晰、可控、易于调试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentStateMachine</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgentState</span> &#123;</span><br><span class="line">        IDLE, PLANNING, EXECUTING, WAITING_INPUT, COMPLETED, ERROR</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AgentState <span class="title function_">transition</span><span class="params">(AgentState current, AgentEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">            <span class="keyword">case</span> IDLE -&gt; event == START ? PLANNING : IDLE;</span><br><span class="line">            <span class="keyword">case</span> PLANNING -&gt; event == PLAN_READY ? EXECUTING : </span><br><span class="line">                           event == NEED_INPUT ? WAITING_INPUT : PLANNING;</span><br><span class="line">            <span class="keyword">case</span> EXECUTING -&gt; event == SUCCESS ? COMPLETED :</span><br><span class="line">                            event == FAILURE ? ERROR : EXECUTING;</span><br><span class="line">            <span class="keyword">default</span> -&gt; current;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h2><p>MCP是一个由Anthropic、OpenAI、Google等行业巨头共同支持的<strong>开放标准</strong>。你可以把它理解为<strong>AI世界的JDBC或JMS</strong>——它旨在标准化AI模型与外部工具、数据源进行交互的方式。</p><ul><li><strong>MCP服务器 (MCP Server)</strong>：任何外部工具、API或数据源（比如你的Spring Boot应用提供的服务）都可以通过实现MCP协议，将自己暴露为一个MCP服务器。它会“宣告”自己能提供哪些能力（如<code>查询订单</code>、<code>读取文件</code>）。</li><li><strong>MCP客户端 (MCP Client)</strong>：AI模型或代理（Agent）作为客户端，可以<strong>发现</strong>并<strong>连接</strong>到这些MCP服务器，使用标准化的请求/响应格式与之交互，而无需关心服务器底层的具体实现。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">传统函数调用 (Function Calling)</th><th style="text-align:left">模型上下文协议 (MCP)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>本质</strong></td><td style="text-align:left"><strong>模型特定的API</strong></td><td style="text-align:left"><strong>开放的、通用的通信协议</strong></td></tr><tr><td style="text-align:left"><strong>耦合度</strong></td><td style="text-align:left">高度耦合（与特定LLM提供商绑定）</td><td style="text-align:left"><strong>松耦合</strong>（与任何支持MCP的LLM兼容）</td></tr><tr><td style="text-align:left"><strong>互操作性</strong></td><td style="text-align:left">弱（切换模型成本高）</td><td style="text-align:left"><strong>强</strong>（工具可被不同模型复用）</td></tr><tr><td style="text-align:left"><strong>生态</strong></td><td style="text-align:left">封闭（各厂商各自为政）</td><td style="text-align:left"><strong>开放</strong>（促进工具和服务的生态系统）</td></tr></tbody></table></div><p> <strong>作为MCP客户端（消费工具）</strong></p><ol><li>在<code>application.yml</code>中配置需要连接的外部MCP服务器的地址。</li><li>Spring AI将提供一个统一的<code>McpTemplate</code>或类似的客户端Bean。</li><li>我们的Agent通过这个<code>McpTemplate</code>来发现并调用外部工具。</li><li><code>McpTemplate</code>会将调用转化为标准的MCP请求，并发送给目标服务器。</li></ol><p>我们如何去导入一个mcp呢在我的项目中？</p><p>如果是内部的，我直接写一个mcp工具即可，实现mcptool接口，继承抽象mcp基类</p><p>外部的我先导入依赖，中添加<code>spring-ai-mistralai-spring-boot-starter</code>依赖</p><p>然后配置mcp服务器，在里面指定mcp的json配置</p><p>然后再spring ai中配置我们chatmodel的apikey</p><p>然后我们就可以使用注册好mcp的chatmodel，来完成使用mcp完成</p><h2 id="Dify"><a href="#Dify" class="headerlink" title="Dify"></a>Dify</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>核心能力：</p><ol><li><strong>可视化的提示词编排 (Prompt Studio)</strong>：提供一个图形界面，让开发者可以像填表格一样设计和调试Prompt，管理变量、上下文和模型输出。</li><li><strong>内置的RAG引擎</strong>：允许用户直接上传文档（PDF, TXT, Markdown等），Dify会自动处理数据清洗、分块、向量化和索引，快速构建起一个可供检索的知识库。</li><li><strong>Agent能力</strong>：支持应用集成“工具 (Tools)”，让大模型可以调用外部API（如查询天气、搜索、计算等），完成更复杂的任务，而不仅仅是文本生成。</li><li><strong>统一的API服务</strong>：一旦你在Dify上构建好应用，它会自动生成一套标准的API。你的前端或业务后端可以直接调用这个API，无需关心背后的大模型是哪个、RAG流程如何运作。</li><li><strong>监控与分析</strong>：内置日志和数据分析功能，可以让你监控应用的调用情况、用户反馈、Token消耗等，方便持续运营和优化。</li></ol><p>那么我们怎么构建一个dify，比如n8n工作流</p><p>1.创建新的应用</p><p>2.编排提示词，加入变量</p><p>3.构建RAG知识库，选择嵌入模型</p><p>4.调试程序问题</p><p>5.发布</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring-AI 面试题目</title>
      <link>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/</link>
      <guid>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/</guid>
      <pubDate>Thu, 17 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;model类型面试题目&quot;&gt;&lt;a href=&quot;#model类型面试题目&quot; class=&quot;headerlink&quot; title=&quot;model类型面试题目&quot;&gt;&lt;/a&gt;model类型面试题目&lt;/h1&gt;&lt;h2 id=&quot;1-如何实现大模型的连续对话？&quot;&gt;&lt;a</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="model类型面试题目"><a href="#model类型面试题目" class="headerlink" title="model类型面试题目"></a>model类型面试题目</h1><h2 id="1-如何实现大模型的连续对话？"><a href="#1-如何实现大模型的连续对话？" class="headerlink" title="1.如何实现大模型的连续对话？"></a>1.如何实现大模型的连续对话？</h2><p>所有的大模型本身是不进行信息存储的，也不提供连续对话功能，<strong>所以想要实现连续对话功能需要开发者自己写代码才能实现</strong></p><p>所以呢我们需要将当前用户的提问与<strong>经过管理的对话历史</strong>一同作为输入，提交给模型。</p><p>我们需要维护一个session，</p><p>通常是<code>List&lt;Message&gt;</code>结构。<code>Message</code>对象至少包含两个关键字段：</p><ul><li><code>role</code>: 角色（<code>system</code>、<code>user</code>、<code>assistant</code>）</li><li><code>content</code>: 消息内容</li></ul><p>然后进入交互循环</p><ul><li><strong>用户输入</strong>：接收用户的新消息（<code>user</code> role）。</li><li><strong>上下文构建</strong>：从存储中获取该会话的历史消息列表，并将新消息追加到列表末尾。</li><li><strong>API调用</strong>：将完整的消息列表提交给大模型。</li><li><strong>获取响应</strong>：接收模型的回复（<code>assistant</code> role）。</li><li><strong>上下文持久化</strong>：将模型的回复也追加到历史消息列表中，并更新存储（如Redis、数据库等），为下一次交互做准备。</li></ul><p>在这里面最重要的就是上下文是有窗口限制的，超出模型的Token限制（如4K, 8K, 32K, 128K）。这不仅会导致API调用失败，还会增加成本和响应延迟。</p><p>1.截断策略：</p><ul><li><strong>简单滑动窗口</strong>：只保留最近的 N 轮对话。实现最简单，但会丢失早期的重要信息。</li><li><strong>保留首轮+滑动窗口</strong>：保留系统提示（<code>system</code> prompt）和第一轮对话，然后截取最近的 N-2 轮对话。适用于需要固定初始设定的场景。</li></ul><p>2.摘要策略：</p><ul><li><strong>滚动摘要</strong>：当对话长度达到一定阈值时，使用另一个LLM调用将较早的对话内容进行总结，用这个摘要替换掉原始的多轮对话。</li><li><strong>优点</strong>：保留了长期记忆的精华。</li><li><strong>缺点</strong>：摘要过程会丢失细节，并产生额外的API开销和延迟。</li></ul><p>3.RAG策略：</p><ol><li><strong>存储</strong>：将每一轮完整的对话历史（或其要点）向量化后存入向量数据库 (VectorDB)。</li><li><strong>检索</strong>：当用户提出新问题时，先将问题向量化，然后去向量数据库中检索最相关的 N 条历史对话记录。</li><li><strong>注入</strong>：将这些检索出的、最相关的历史记录，连同当前问题，一起注入到提示词中，提交给大模型。</li></ol><ul><li><ul><li><strong>突破长度限制</strong>：理论上可以维护无限的对话历史。</li><li><strong>高相关性</strong>：只提供与当前问题最相关的上下文，效率高。</li></ul></li><li><strong>挑战</strong>：需要引入向量数据库（如Milvus, Pinecone）和embedding模型，系统复杂度更高。</li></ul><p>这是我们自己需要配置的，但是Spring AI Alibaba 因为内置了连续对话的多种实现,比如mysql,redis</p><p>只需要简单配置就ok，我们注入注入 RedisChatMemoryRepository 对象。</p><p>然后配置 ChatClient 实现连续对话。</p><p>直接调用先prompt，然后advisors,最好call.context发送给模型</p><h2 id="2-AI项目的执行流程"><a href="#2-AI项目的执行流程" class="headerlink" title="2.AI项目的执行流程"></a>2.AI项目的执行流程</h2><p>我习惯上分为<strong>离线数据处理（Data Preparation）</strong> 和 <strong>在线请求处理（Real-time Inference）</strong></p><p>1.离线数据处理：</p><p>这个阶段的目标是将原始、异构的数据处理成AI模型可以高效检索的结构化知识库。它是一次性的或周期性执行的。</p><ol><li><strong>多源数据抽取 (Extraction)</strong>：<ul><li>首先，需要从多个来源抽取数据，这些数据就是我们常说的“知识”。来源可能包括：<ul><li><strong>结构化数据</strong>：如MySQL, PostgreSQL里的业务数据。</li><li><strong>半结构化数据</strong>：如网页HTML, Markdown文档。</li><li><strong>非结构化数据</strong>：如PDF, Word文档, 纯文本。</li><li><strong>API数据</strong>：通过调用内部或外部API获取的动态信息。</li></ul></li></ul></li><li><strong>数据清洗与分块 (Cleaning &amp; Chunking)</strong>：<ul><li>原始数据是“脏”的，必须清洗。这包括去除无关信息（如HTML标签、广告、页眉页脚）、处理格式错误、统一编码等。</li><li>清洗后，将长文本（如一篇长文档）切分成有意义的、大小适中的“文本块 (Chunks)”。这一步至关重要，因为文本块是后续向量检索的基本单位。分块的好坏直接影响检索质量。</li></ul></li><li><strong>向量化与索引 (Embedding &amp; Indexing)</strong>：<ul><li>这是将文本语言转换为数学语言的核心步骤。</li><li>我们使用一个特定的<strong>Embedding模型</strong>，将每一个“文本块”计算成一个高维向量（Embedding）。这个向量可以被认为是该文本块在语义空间中的“坐标”。</li><li>然后，将这些文本块原文连同它们的向量索引，存入一个或多个<strong>向量数据库</strong>（如Milvus, Pinecone）中。同时，也可能将关键词、元数据等存入传统检索引擎（如Elasticsearch）。</li></ul></li></ol><p>2.在线请求处理：</p><p>这个阶段是用户与系统实时交互的过程，追求低延迟和高精度。</p><ol><li><strong>意图分析 (Intention Analysis)</strong>：<ul><li>请求的入口。当用户输入一句话，系统首先要理解“他想干什么”。</li><li>这不仅仅是关键词识别，更深层次会判断用户意图，例如：是闲聊（Chitchat）？是问答（FAQ）？还是需要执行一个任务（Task-oriented）？</li><li>意图分析的结果会决定后续调用哪些检索路径。比如，闲聊意图可能直接交给大语言模型，而问答意图则会触发后续的召回和排序流程。</li></ul></li><li><strong>多路召回 (Multi-path Recall)</strong>：<ul><li>这是为了“宁可错杀，不可放过”，尽可能多地从不同渠道找回所有相关的候选答案。各路召回并行执行，以保证效率。</li><li><strong>向量召回（语义召回）</strong>：将用户的查询也进行向量化，然后去向量数据库里进行相似度检索，找出语义上最接近的N个文本块。这是您提到的“向量检索”的应用环节。</li><li><strong>关键词召回（词法召回）</strong>：使用传统搜索引擎（如Elasticsearch）根据关键词匹配，找出包含查询词的文本块。这能弥补向量召回在精确匹配上的不足。</li><li><strong>其他召回</strong>：还可能包括基于知识图谱的召回、基于数据库精确查询的召回等。</li></ul></li><li><strong>混合排序 (Hybrid Ranking/Re-ranking)</strong>：<ul><li>多路召回会返回大量候选结果，质量良莠不齐，甚至有重复。排序阶段就是优中选优的过程。</li><li><strong>粗排 (Coarse Ranking)</strong>：首先，通过一些简单的规则和模型，对召回的上百个结果进行快速排序和去重，筛选出Top K（比如Top 50）个候选结果。</li><li><strong>精排 (Fine-grained Ranking / Re-ranking)</strong>：然后，使用一个更复杂、更强大的排序模型（通常是Cross-Encoder或专门的排序大模型），对这Top K个结果进行精准打分。这个模型会综合考虑查询与候选答案的语义相关性、业务重要性、时效性等多种特征，给出最终的、最合理的排序。</li></ul></li><li><strong>答案生成与整合 (Answer Generation &amp; Synthesis)</strong>：<ul><li>最后，系统会将排序最高的一个或几个结果，作为核心上下文，连同用户的原始问题，一起组织成一个精炼的提示词（Prompt）。</li><li>将这个Prompt提交给一个强大的生成式大语言模型（如GPT-4），由它基于给定的上下文，生成最终的、通顺自然的回答，并呈现给用户。</li></ul></li></ol><h2 id="3-Dify是什么？怎么使用？"><a href="#3-Dify是什么？怎么使用？" class="headerlink" title="3.Dify是什么？怎么使用？"></a>3.Dify是什么？怎么使用？</h2><p>Dify是一个<strong>开源的、一站式的LLM应用开发平台</strong>，<strong>极大降低构建和管理生产级生成式AI应用的门槛</strong>，让开发者可以更专注于业务逻辑，而不是费力地搭建和维护复杂的AI基础设施。</p><p>过去我们需要自己手动管理Prompt、对接不同的大模型、搭建RAG（检索增强生成）流程、处理对话历史等，而Dify将这些复杂繁琐的工作<strong>产品化、可视化</strong>了。</p><p>1.为什么选择Dify?</p><ul><li><strong>从效率和速度角度看：</strong> 对于需要快速验证原型（MVP）或业务逻辑不那么极端的项目，我会首选Dify。因为它将RAG、多模型支持、API封装等通用能力产品化了，可以让我们在几天甚至几小时内就搭建起一个可用的AI应用，极大地缩短了Time-to-Market（产品上市时间）。</li><li><strong>从维护成本角度看：</strong> Dify提供了一个完整的后台管理界面，包括日志、监控和用户反馈。这意味着运营人员或产品经理也可以参与到应用的优化中来，例如更新知识库、标注数据等。如果自研，这部分工作都需要开发人员投入精力去构建和维护，长期成本更高。</li><li><strong>对于自定义和灵活性：</strong> 当然，如果项目需求非常特殊，比如需要一个高度定制化的RAG策略（例如复杂的混合检索和重排逻辑），或者对系统性能有极致要求，那么基于LangChain或LlamaIndex自研会提供更高的灵活性和控制力。</li></ul><p>2.Dify的Agent和Tool（工具）能力是如何工作的？它与传统的API调用有什么不同？</p><p>Dify的Agent和Tool能力，是实现<strong>Language Model as a Reasoning Engine（将语言模型作为推理引擎）</strong>的关键。它和传统API调用的核心区别在于<strong>‘决策者’不同</strong>。</p><ul><li><strong>传统API调用</strong>：是我们开发者在代码里<strong>提前写好逻辑</strong>。比如，<code>if</code>用户想查天气，<code>then</code>调用天气API。这个决策逻辑是<strong>由人预先编码</strong>的。</li><li><strong>Dify中的Agent/Tool工作流</strong>:</li></ul><ol><li><strong>工具注册</strong>：我们首先向Dify注册一个或多个工具，比如“天气查询API”、“计算器API”。关键在于，我们需要用自然语言<strong>向模型清晰地描述这个工具是做什么的、需要哪些参数</strong>（比如，天气查询API需要一个<code>city</code>参数）。</li><li><strong>模型决策 (Reasoning)</strong>：当用户提出一个模糊的需求，比如“帮我查查明天北京会不会下雨，适合穿什么？”，Agent接收到请求后，大模型会进行“思考”。</li><li><strong>工具选择与调用</strong>：模型会分析用户的意图，并根据我们提供的工具描述，<strong>自主决定</strong>需要使用“天气查询API”。然后，它会从用户问题中<strong>提取出参数</strong><code>city: &quot;北京&quot;</code>，并生成一个调用该API的请求。</li><li><strong>结果整合与响应</strong>：模型获取到API返回的天气数据后（比如“晴天”），会将其作为新的信息，结合它自己的知识（晴天适合穿什么），最终生成一段通顺的、完整的回答给用户。</li></ol><p>Dify的Agent模式，把<strong>‘决定调用哪个API’以及‘如何组织参数’的权力，从开发者交给了大模型</strong>，实现了更高层次的自动化和智能化。”</p><p>3.如果让你来设计一个类似Dify的平台，你会如何规划它的技术架构？</p><p>设计一个类似Dify的平台，我会将其拆分为几个核心模块，并采用微服务的思想来构建，确保可扩展性和可维护性</p><ol><li><strong>前端 (Frontend)</strong>：<ul><li>使用React或Vue等现代前端框架，负责提供所有可视化的操作界面，包括应用管理、Prompt Studio、知识库上传和运营后台等。</li></ul></li><li><strong>API网关 (API Gateway)</strong>：<ul><li>作为所有服务的统一入口，处理用户认证、请求路由、速率限制等。这是外部应用（比如用户的前端）与我们平台交互的门户。</li></ul></li><li><strong>应用编排服务 (Orchestration Service)</strong>：<ul><li>这是平台的大脑。它负责解释在Studio中保存的应用配置。当一个API请求进来时，这个服务会根据应用定义，决定是走简单的LLM对话流程，还是需要执行RAG或Agent流程。它会编排并调用下游的各个服务。</li></ul></li><li><strong>模型管理服务 (Model Management Service)</strong>：<ul><li>用于统一管理和对接不同的大模型提供商（OpenAI, Anthropic, Google Gemini, 以及开源模型）。它会封装好各家API的差异，对上层提供一个统一的调用接口。</li></ul></li><li><strong>RAG服务 (RAG Service)</strong>：<ul><li>这是一个独立的模块，负责知识库的全生命周期管理。</li><li><strong>写入路径</strong>：接收文档 -&gt; 文本解析 -&gt; 分块 (Chunking) -&gt; 调用Embedding模型 -&gt; 存入向量数据库。</li><li><strong>读取路径</strong>：接收查询 -&gt; 向量化 -&gt; 在向量数据库中进行相似性搜索 -&gt; 返回相关文本块。</li><li><strong>技术选型</strong>：会用到向量数据库（如Milvus/Weaviate）和Embedding模型。</li></ul></li><li><strong>日志与监控服务 (Logging &amp; Monitoring Service)</strong>：<ul><li>专门收集所有API调用的日志、Token消耗、用户反馈等数据。</li><li>将数据存入专门的数据库（如ClickHouse或Elasticsearch），并提供数据可视化界面，用于运营分析和应用优化。</li></ul></li></ol><h2 id="4-那么怎么区分使用简单模型还是使用agent呢？"><a href="#4-那么怎么区分使用简单模型还是使用agent呢？" class="headerlink" title="4.那么怎么区分使用简单模型还是使用agent呢？"></a>4.那么怎么区分使用简单模型还是使用agent呢？</h2><p>可以使用前置规则与关键词匹配 ，比如系统会维护一个“触发词”列表。当用户的输入包含这些特定的动词或名词时，系统会<strong>绕过复杂的判断</strong>，直接将其路由到Agent流程。</p><p>或者是利用大语言模型进行意图分类 ，我们设计一个专门用于“路由”的<strong>元提示 (Meta-Prompt)</strong>。这个Prompt会包含以下内容：</p><ol><li><strong>用户的原始问题</strong>。</li><li><strong>一个“选项列表”</strong>，这个列表描述了所有可用的“路径”。每个路径就是一个Agent或工具，外加一个“默认闲聊”的选项。</li><li><strong>一个明确的指令</strong>，要求LLM根据用户问题，从列表中选择一个最合适的路径。</li></ol><p>非常智能和灵活，能理解深层语义。这是目前最主流和最有效的方法。现代LLM的“Function Calling”或“Tool Use”功能，本质上就是这种机制的高度优化和内置实现。</p><p>或者是结合上下文进行动态判断，系统在做意图判断时，不仅考虑当前这一句，还会<strong>附加上下文（最近的几轮对话历史）</strong>。</p><p>我在这个项目中主要用的是，<strong>分层漏斗模型</strong></p><ol><li><strong>首先，通过一个‘快速通道’进行前置判断</strong>。我们会用关键词和规则匹配，快速识别出那些意图非常明确的请求，比如包含‘查询’、‘计算’、‘预订’等词语的指令，直接将它们路由给相应的Agent。这能覆盖掉一部分简单明确的任务，且成本最低。</li><li><strong>其次，对于无法被快速通道处理的请求，我们会启用一个‘智能路由’层</strong>。这一层的核心是利用大语言模型自身的理解能力。我们会设计一个专门的‘路由Prompt’，把用户的请求和所有可用的‘工具’（Agents）以及一个‘闲聊’选项一起发给LLM，让模型来判断用户最可能的意图是什么。比如，模型需要从‘查询天气’、‘检查订单’和‘普通聊天’这几个选项里做出选择。这是目前最主流也最可靠的方式。</li><li><strong>最后，在多轮对话中，我们会引入上下文进行动态判断</strong>。用户的意图可能不会在第一句话就完全暴露。因此，在做意图识别时，系统会结合最近的对话历史。比如用户先说了‘我想去北京’，接着问‘那边天气如何？’，系统就能结合上下文，准确地将这个模糊的问题路由到‘天气查询Agent’。</li></ol>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/SpringAI/">SpringAI</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/springai2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>开源项目经历</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/kaiyuan/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/kaiyuan/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;&lt;strong&gt;issue计划已同步到飞书管理，此文档暂时作废&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;Github&quot;&gt;&lt;a href=&quot;#Github&quot; class=&quot;headerlink&quot; title=&quot;Github&quot;&gt;&lt;/a&gt;Github&lt;/h1&gt;&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p><strong>issue计划已同步到飞书管理，此文档暂时作废</strong></p><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>1.</p><p>2025.7.15晚上十点，提交了我人生中的第一个PR，</p><p>是阿里巴巴的<a href="https://github.com/alibaba/fastjson2/项目。">https://github.com/alibaba/fastjson2/项目。</a></p><p>看到一个issue没有人哈哈，我直接在vscode跑了一下，然后发现是</p><p>在 Android 10 的系统中，<br>com.alibaba.fastjson2.util.IOUtils.isNULL(IOUtils.java:2)<br>会产生一个 native 侧的 crash，Signal 7(SIGBUS), Code 1(BUS_ADRALN)出现了问题</p><p>我发现是内存对齐问题: 在 Android 10 ARM 架构上，IOUtils.getLongUnaligned(char[] buf, int offset) 方法直接使用 UNSAFE.getLong() 访问 char 数组内存，ARM 处理器要求 8 字节 long 读取必须在 8 字节对齐的地址上进行，当计算出的内存地址 ARRAY_CHAR_BASE_OFFSET + ((long) offset &lt;&lt; 1) 不是 8 字节对齐时，触发 Signal 7(SIGBUS), Code 1(BUS_ADRALN) 崩溃<br>我已经提交PR<a href="https://github.com/[/pull/3639](https://github.com/alibaba/fastjson2/pull/3639">https://github.com/[/pull/3639](https://github.com/alibaba/fastjson2/pull/3639</a>)</p><p>然后直接进行测试，测试的三个类全部通过。overall</p><p>看看对不对，能不能给我合并了吧哈哈，好了睡觉舒服了，该PR已经解决</p><p>然后后来根据我的代码发布了一个快照，然后我测试完之后发现成功！他采纳了我的建议</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>1.</p><p>2025.7.16八点左右</p><p>提交了我的第三个PR，是rocketMQ的。也是到知名中间件的issue了哈哈</p><p>这个问题是一个时序问题，一个topic被创建的时候，队列为null,最大偏移量为0<br>然后生产者发送第一条消息的时候，最大偏移量为1。<br>消费者启动的时候，查询最大偏移量为-1，然后调用maxoffset(mq),就会返回1.这样我们为0的消息就被跳过了。<br>可以在发送消息前，可以先启动 Consumer 实例，或者在 Consumer 启动后等待一段时间再发送消息。<br>然后在配置的时候，设置从ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET开始消费。<br>也可以在代码方面更改再前面加一层校验，如果maxoffset&lt;=1的话，就返回0L</p><p>然后else就返回maxoffset</p><p>maxoffset=this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</p><p><a href="https://github.com/apache/rocketmq/pull/9552">https://github.com/apache/rocketmq/pull/9552</a></p><p>然后发现这个issue很久没解决了哈哈，看看我的能不能被通过吧</p><h2 id="merged"><a href="#merged" class="headerlink" title="merged"></a>merged</h2><p>1.</p><p>2025.7.16中午头，提交了我的第二个PR</p><p>这个PR是<a href="https://github.com/alibaba/spring-ai-alibaba/">https://github.com/alibaba/spring-ai-alibaba/</a> 仓库的， <a href="https://github.com/alibaba/spring-ai-alibaba/pull/1645">https://github.com/alibaba/spring-ai-alibaba/pull/1645</a></p><p>是解决了一个人的issue，node枚举字段里面没有template-transform他非要调用，肯定是失败的啊</p><p>然后我就在枚举类里添加了template-transform节点，然后写了一个NodeData类和一个NodeDataConverter类</p><p>NodeData就设置一下setter和getter，然后Conventer就是一个<strong>模板转换节点数据转换器</strong> 的 Java 类，属于阿里云 AI 服务中工作流 DSL 处理模块</p><p>实现了实现了<code>TemplateTransformNodeDataConverter</code>转换器类</p><ul><li>继承抽象Converter类</li><li><strong>DIFY方言</strong>: 完整的解析和导出逻辑</li><li><strong>CUSTOM方言</strong>: 使用默认自定义方言转换器</li><li><strong>输入处理</strong>: 变量选择器解析</li><li><strong>输出管理</strong>: 固定string类型结果</li><li><strong>变量命名</strong>: <code>templateTransformNode&#123;count&#125;</code>格式</li><li><strong>后处理</strong>: 自动设置输出键名</li></ul><p>然后添加其node节点的具体实现， 实现了完整的模板转换功能:</p><ul><li><strong>占位符模式</strong>: 支持<code>&#123;&#123;key&#125;&#125;</code>语法</li><li><strong>正则引擎</strong>: 使用<code>\\&#123;\\&#123;\\s*(.+?)\\s*\\&#125;\\&#125;</code>匹配</li><li><strong>高效处理</strong>: StringBuffer + Matcher进行字符串替换</li><li><strong>安全机制</strong>: 自动转义特殊字符防止正则注入</li><li><strong>容错设计</strong>: 缺失变量时保留原占位符，不中断执行</li><li><strong>状态管理</strong>: 正确使用<code>state.data().containsKey(key)</code>检查变量存在性</li></ul><p>在代码生成层实现了nodesection</p><ul><li>实现了<code>TemplateTransformNodeSection</code>代码生成器</li><li>完整的Builder模式实现，支持流式配置</li><li>提供了完善的错误处理和SLF4J日志记录</li></ul><p>然后通过了他的CI测试，其中代码格转为spring的格式和头信息,java格式化卡了我一点时间，没注意格式的问题。</p><p>然后通过全部的lint测试</p><p>2.</p><p>2025.7.22完事八点，继续干spring ai alibaba</p><p>这次主要是修复了一个空指针异常，DashScope API返回数据质量问题，ToolCall对象的function.name字段为null。在buildGeneration方法中，Toolcall对象的时候，这里如果toolCall.function().name()返回null，就会导致后续Spring AI框架在DefaultToolCallingManager.executeToolCall中执行toolName.equals()(时出现NPE。导致streaming 和 non-streaming 聊天调用都受影响。可以添加null过滤器，然后记录日志。这是防御性编程的经典模式，添加空值过滤。</p><p>然后我们就添加了两个null的校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ToolCall&gt; validToolCalls = toolCalls.stream()</span><br><span class="line">    .filter(toolCall -&gt; toolCall.function() != <span class="literal">null</span> &amp;&amp; </span><br><span class="line">                        toolCall.function().name() != <span class="literal">null</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>解决了一个issue <a href="https://github.com/alibaba/spring-ai-alibaba/pull/1766">https://github.com/alibaba/spring-ai-alibaba/pull/1766</a></p><p>3.</p><p>2025.7.23 下午</p><p>今天修复了还是我们熟悉的fastjson2的一个小issue</p><p>因为他jsonfactory设定的内存的最大阈值时2048.然后我看他们反馈实际应用的是比这要打的</p><p>那么我们就可以去自己去设定这一个max值。但是这样内存太大的话，又会出现oom问题。不知道怎么处理</p><p><a href="https://github.com/alibaba/fastjson2/pull/3658">https://github.com/alibaba/fastjson2/pull/3658</a></p><p>4.</p><p>fastjson2的一个版本兼容的问题，但是他的checkstyle格式实在是改不过来我吐。我就用的main函数来直接测试了</p><p>添加了判断方法和set方法，<strong>字段默认值类型转换</strong> </p><p>然后默认值的实际类型与目标字段类型不匹配开始，当启用兼容模式时，对于 <code>String → Date</code> 的转换进行特殊处理</p><ul><li><code>isJSONFieldDefaultValueCompatMode()</code>: 检查是否启用 FastJSON 1.x 兼容模式</li><li><code>defaultValue instanceof String</code>: 默认值是字符串类型</li><li><code>Date.class.isAssignableFrom(fieldClass)</code>: 目标字段是 Date 类型或其子类</li></ul><p><a href="https://github.com/alibaba/fastjson2/pull/3661">https://github.com/alibaba/fastjson2/pull/3661</a></p><p>算了，不做了我吐</p><p>5.</p><p>又是一个fastjson2的项目的pr,这次主要是修复了fastjson2在处理set list等集合的解析的问题，他们在反序列化的时候会出现问题。然后不同编码使用不同的读取方式</p><p>让他们在操作的时候直接进行byte的操作，如果是set的化就进行特殊处理+去重</p><p><a href="https://github.com/alibaba/fastjson2/pull/3701">https://github.com/alibaba/fastjson2/pull/3701</a></p><p>7.</p><p>2025.7.28</p><p>这次还是springaialibaba</p><p>调用mcp工具，调用了能有全链路的traceid，串联不了链路</p><ul><li>实现了 <code>McpTraceExchangeFilterFunction</code>，用于在 HTTP 请求中自动注入 traceId、spanId 等分布式链路追踪相关 header，支持 Micrometer Tracing。</li><li>通过 Spring Boot 自动配置（<code>McpTracingAutoConfiguration</code>），自动装配 tracing filter，无需手动配置，提升易用性。</li><li><strong>客户端传输层支持 tracing filter 注入</strong></li><li>让 MCP 客户端具备分布式链路追踪能力，方便排查问题和性能分析。</li></ul><p><a href="https://github.com/alibaba/spring-ai-alibaba/pull/1837">https://github.com/alibaba/spring-ai-alibaba/pull/1837</a></p><p>8.</p><p>还是spring ai alibaba</p><p>Spring AI Alibaba Graph模块中<strong>Tool节点</strong>与<strong>Dify平台</strong>集成时的<strong>属性映射问题</strong>。原有的ToolNodeData只支持基础的tool相关属性，无法完整支持Dify平台的丰富工具配置。</p><p>添加更多的属性的setter 和getter和处理属性的数组，和属性映射之间的关系</p><p><a href="https://github.com/alibaba/spring-ai-alibaba/pull/1948">https://github.com/alibaba/spring-ai-alibaba/pull/1948</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/Github/">Github</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/kaiyuan/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BUG收集</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;配置bug&quot;&gt;&lt;a href=&quot;#配置bug&quot; class=&quot;headerlink&quot; title=&quot;配置bug&quot;&gt;&lt;/a&gt;配置bug&lt;/h1&gt;&lt;h2 id=&quot;MyBatis-bug&quot;&gt;&lt;a href=&quot;#MyBatis-bug&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="配置bug"><a href="#配置bug" class="headerlink" title="配置bug"></a>配置bug</h1><h2 id="MyBatis-bug"><a href="#MyBatis-bug" class="headerlink" title="MyBatis bug"></a><strong>MyBatis bug</strong></h2><ul><li style="list-style: none"><input type="checkbox" checked></input> factoryBeanObjectType的兼容性问题</li></ul><p>Spring Boot 在 3.2 版本中更新了 <code>FactoryBeanRegistrySupport#getTypeForFactoryBeanFromAttributes</code> 方法，它要求 <code>factoryBeanObjectType</code> 必须是 <code>Class&lt;?&gt;</code> 或 <code>ResolvableType</code>，绝不接受 <code>String</code></p><p>旧版本的 MyBatis-Spring 在 <code>ClassPathMapperScanner.processBeanDefinitions()</code> 中将 <code>beanClassName</code>（一个 <code>String</code>）赋给了 <code>factoryBeanObjectType</code></p><p>slove:</p><p>我们使用MyBatis-Plus starter3.5.5。然后现在基本都要升级成springboot3，因为springaialibaba等框架也是需要3的</p><p>然后我们分模块的时候，为了避免@MapperScan重复扫描，我们只在业务模块进行mybatisplus的导入，然后common模块就只导入一个annotion。不到人core</p><p>防止出现重复扫描的问题。</p><h1 id="nacos配置bug"><a href="#nacos配置bug" class="headerlink" title="nacos配置bug"></a>nacos配置bug</h1><ul><li style="list-style: none"><input type="checkbox" checked></input> 缺少NacosShutdownHook，然后导致nacos-clint无法运行，添加nacos钩子然后让其更美观的关闭</li></ul><p>关闭通知中心，然后强制关闭所有的后台线程</p><p>reason:</p><p>Spring 会先销毁 Bean，然后执行注册的 <code>ShutdownHook</code>，如果 Nacos 没有注册自己的钩子，那它的后台线程就会存活到 JVM 强制退出。</p><p>Nacos 客户端（<code>nacos-client</code>）在正常退出时会通过 <code>ShutdownHook</code> 释放 HttpClient、长连接、定时任务等资源。<br> 如果没有这个钩子，<code>DefaultHttpClientFactory</code> 之类的类无法加载或初始化不完整，就会出现 <code>NoClassDefFoundError</code>，或者后台线程挂起不退出。</p><p>slove:</p><p>所以我们需要在应用的时候手动注册一个nacos的关闭的钩子，通知中心 → 释放 HttpClient → 停止定时任务</p><p>然后为了防止还有存活，再强制关闭所有的后台线程</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/BUG/">BUG</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E5%B7%A5%E4%BD%9C/doc/bug1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis面试hot-高并发/高级玩法部分</title>
      <link>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/</link>
      <guid>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/</guid>
      <pubDate>Mon, 14 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;redis的高并发和高可用&quot;&gt;&lt;a href=&quot;#redis的高并发和高可用&quot; class=&quot;headerlink&quot; title=&quot;redis的高并发和高可用&quot;&gt;&lt;/a&gt;redis的高并发和高可用&lt;/h1&gt;&lt;p&gt;如何用 redis 来加多台机器，保证 redis</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="redis的高并发和高可用"><a href="#redis的高并发和高可用" class="headerlink" title="redis的高并发和高可用"></a>redis的高并发和高可用</h1><p>如何用 redis 来加多台机器，保证 redis 是高并发的，还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，即 redis 高可用。</p><p>redis 实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><p>redis的主从架构就是读写分离，一主多从。</p><p>主节点负责写，其他的从节点负责读</p><p>其中重要的就是数据的一致性的问题，就是数据的replication。我们采用了主从架构的时候，必须开启持久化</p><ul><li>Redis 采用<strong>异步方式</strong>复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li><li>slave并不会过期key，master的key过期了，会模拟一条del命令发送给slave</li><li>无磁盘复制，master 在内存中直接创建 <code>RDB</code> ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 <code>repl-diskless-sync yes</code> 即可。</li></ul><hr><p>主从复制的核心：就是增量复制和全量复制</p><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。这个就是增量复制。</p><p>那么我们怎么确定是增量复制还是全量复制呢，如果复制的过程中中断了怎么办？</p><p>Redis2.8 开始就支持断点传输了。</p><p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> 。</p><p>那么我们增量复制的时候，主节点的backlog_buffer里面存储我们最近的数据，然后跟从节点的slave_reolica_buffer进行对比，根据差值来进行全量复制还是增量复制。</p><p>但是这个缓冲区默认的是1M，我们可以增大这个缓冲区</p><p>打开 <code>redis.conf</code> 文件，找到repl-backlog-size，然后修改值即可。</p><hr><p>复制的流程：</p><p>slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 <code>host</code> 和 <code>ip</code> ，但是复制流程没开始。</p><p>slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 <code>ping</code> 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node <strong>第一次执行全量复制</strong>，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。</p><p>全量复制：</p><ul><li>master 执行 bgsave ，在本地生成一份 rdb 快照文件。</li><li>master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)</li><li>master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。</li><li>如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave 256MB 64MB 60</span><br></pre></td></tr></table></figure><ul><li>slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中。注意，在清空旧数据之前，slave node 依然会<strong>基于旧的数据版本</strong>对外提供服务。</li><li>如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。</li></ul><p>增量复制：</p><ul><li>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</li><li>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。</li><li>master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。</li></ul><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>一般的我们的持久化机制就是</p><p>RDB，AOF ，RDB-AOF</p><p>持久化主要是做灾难恢复、数据恢复，也可以归类到高可用的一个环节中去，比如你 Redis 整个挂了，然后 Redis 就不可用了，你要做的事情就是让 Redis 变得可用，尽快变得可用。</p><ul><li>RDB：RDB 持久化机制，是对 Redis 中的数据执行<strong>周期性</strong>的持久化。</li><li>AOF：AOF 机制对每条写入命令作为日志，以 <code>append-only</code> 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据集。</li></ul><p>RDB:</p><ul><li>RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 Redis 中的数据。</li><li>RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis <strong>保持高性能</strong>，因为 Redis 主进程只需要 fork 一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</li><li>相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 Redis 进程，更加快速。</li><li>如果想要在 Redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟（甚至更长时间）的数据。</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><p>AOF:</p><ul><li>AOF 可以更好的保护数据不丢失，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 <code>fsync</code> 操作，最多丢失 1 秒钟的数据。</li><li>AOF 日志文件以 <code>append-only</code> 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</li><li>AOF 日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在 <code>rewrite</code> log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。在创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。</li><li>AOF 日志文件的命令通过可读较强的方式进行记录，这个特性非常<strong>适合做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 <code>flushall</code> 命令清空了所有数据，只要这个时候后台 <code>rewrite</code> 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 <code>flushall</code> 命令给删了，然后再将该 <code>AOF</code> 文件放回去，就可以通过恢复机制，自动恢复所有数据。</li><li>对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大。</li><li>AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 <code>fsync</code> 一次日志文件，当然，每秒一次 <code>fsync</code> ，性能也还是很高的。（如果实时写入，那么 QPS 会大降，Redis 性能会大大降低）</li><li>以前 AOF 发生过 bug，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志 <code>merge</code> 回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug。不过 AOF 就是为了避免 rewrite 过程导致的 bug，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是<strong>基于当时内存中的数据进行指令的重新构建</strong>，这样健壮性会好很多。</li></ul><p>他们都是有优缺点的，我们可以使用RDB-AOF混合的模式</p><p>当然appendonly yes也是要启动AOF的，然后一般我们选择<strong><code>appendfsync everysec</code></strong> 配置 AOF 的同步策略为每秒一次</p><p> 在 <code>redis.conf</code> 文件中，找到aof-use-rdb-preamble yes</p><p>这意味着当 AOF 进行 <code>rewrite</code> （重写）时，会使用 RDB 格式的数据作为 AOF 文件的前置内容，然后才是增量的 AOF 命令。  这能大大缩短 Redis 重启时加载 AOF 文件的速度。</p><p>然后重启redis，使配置生效</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li><p>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</p></li><li><p>哨兵至少需要 3 个实例，来保证自己的健壮性。按照需求设置配置 <code>quorum=</code></p></li></ul><hr><p>哨兵在让redis node进行主备切换的时候可能会出现数据丢失的问题</p><p>异步复制导致的数据丢失：</p><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。</p><p>脑裂问题导致的数据丢失:</p><p>脑裂，也就是说，某个 master 所在机器突然<strong>脱离了正常的网络</strong>，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会<strong>认为</strong> master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的<strong>脑裂</strong>。</p><p>此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p><p>解决：：</p><p>进行如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure><p>表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。</p><p>如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。</p><ul><li>减少异步复制数据的丢失</li></ul><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。</p><ul><li>减少脑裂的数据丢失</li></ul><p>如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p><hr><p>自动发现机制：</p><p>哨兵互相之间的发现，是通过 Redis 的 <code>pub/sub</code> 系统实现的，每个哨兵都会往 <code>__sentinel__:hello</code> 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p><p>每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 <code>__sentinel__:hello</code> channel 里<strong>发送一个消息</strong>，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。</p><p>每个哨兵也会去<strong>监听</strong>自己监控的每个 master+slaves 对应的 <code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。</p><p>每个哨兵还会跟其他哨兵交换对 <code>master</code> 的监控配置，互相进行监控配置的同步。</p><p>选举算法：</p><p>如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></table></figure><p>接下来会对 slave 进行排序：</p><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><p>configuration epoch：</p><p>哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。</p><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。</p><p>哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 <code>pub/sub</code> 消息机制。</p><p>这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>一般我们使用的使redis原生的集群，Redis cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><p>介绍：</p><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><p>节点之间的通信：</p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 <code>storm</code> 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。</p><p>Redis 维护集群元数据采用另一个方式， <code>gossip</code> 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><p><strong>集中式</strong>的<strong>好处</strong>在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；<strong>不好</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p><p>gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p><ul><li>10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 <code>ping</code> 消息，同时其它几个节点接收到 <code>ping</code> 之后返回 <code>pong</code> 。</li><li>交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。</li></ul><hr><p>gossip协议：</p><p>gossip 协议包含多种消息，包含 <code>ping</code> , <code>pong</code> , <code>meet</code> , <code>fail</code> 等等。</p><ul><li>meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis-trib.rb add-node</span><br></pre></td></tr></table></figure><p>其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。</p><ul><li>ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。</li><li>pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。</li><li>fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。</li></ul><p>ping:</p><p>ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。</p><p>每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 <code>cluster_node_timeout / 2</code> ，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 <code>cluster_node_timeout</code> 可以调节，如果调得比较大，那么会降低 ping 的频率。</p><p>每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 <code>3</code> 个其它节点的信息，最多包含 <code>总节点数减 2</code> 个其它节点的信息。</p><hr><p>分布式寻址算法：</p><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul><p>hash：</p><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><p>一致性hash：</p><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。</p><p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><p>Redis cluster 的 hash slot 算法:</p><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/redis/">redis</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/15/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/java-stack/redis3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cache缓存</title>
      <link>https://blog.tokenlen.top/2025/07/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cache1/</link>
      <guid>https://blog.tokenlen.top/2025/07/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cache1/</guid>
      <pubDate>Sun, 13 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>1.为什么要用缓存？</p><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p><p>就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。</p><p>缓存功能简单，说白了就是 <code>key-value</code> 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p><hr><p>如果按照我们存储的位置来分的话，缓存分为：</p><p>本地缓存，访问速度最快的，一般我们查数据的时候，首先查的就是本地缓存，比如Caffeine, Guava Cache, Ehcache </p><p>分布式缓存，容量更大，多个应用之间可以i将那些共享数据，比如Redis, Memcached, Hazelcast</p><p>客户端缓存，缓存数据存储在客户端，比如浏览器缓存，app缓存等等</p><p>CDN缓存，缓存静态资源在离用户较近的 CDN 节点上，常用于加速访问的速度</p><p>数据库缓存，数据库自身提供的缓存机制, 用于缓存查询结果，比如mysql就有缓存机制</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>1.Redis 和 Memcached 有啥区别？</p><ol><li>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， Redis 会是不错的选择。</li><li>在 Redis3.x 版本中，便能支持 cluster 模式，而 Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li><li>由于 Redis 只使用<strong>单核</strong>，而 Memcached 可以使用<strong>多核</strong>，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li></ol><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">50万写入:耗时:ms</th><th style="text-align:left">50写+50读(读全命中):耗时:ms</th><th style="text-align:left">50万写+50万读(全命中)+50万读(未命中)：耗时:ms</th><th style="text-align:left">50万读+50万未命中</th></tr></thead><tbody><tr><td style="text-align:left">Guava</td><td style="text-align:left">329/340/326/328/328</td><td style="text-align:left">536/518/546/525/558</td><td style="text-align:left">647/646/638/668/641</td><td style="text-align:left">490/501/482/485/492</td></tr><tr><td style="text-align:left">Caffeine</td><td style="text-align:left">292/284/270/279/267</td><td style="text-align:left">414/382/353/385/361</td><td style="text-align:left">479/513/460/487/481</td><td style="text-align:left">343/326/333/336/369</td></tr><tr><td style="text-align:left">Ohc</td><td style="text-align:left">448/433/430/446/442</td><td style="text-align:left">763/748/765/741/705</td><td style="text-align:left">918/947/901/964/903</td><td style="text-align:left">653/676/607/639/704</td></tr><tr><td style="text-align:left">Ohc-Obj</td><td style="text-align:left">1343/1315/1217/1249/1193</td><td style="text-align:left">1910/1830/1849/1803/1786</td><td style="text-align:left">1979/1965/1947/1968/1946</td><td style="text-align:left">1487/1573/1499/1491/1483</td></tr></tbody></table></div><p>我们一般使用的时候就使用Caffeine就足够了</p><p>Caffeine 的核心设计目标是提供具有高命中率和低延迟的缓存。 其架构主要由以下几个关键组件组成：</p><ul><li><strong>ConcurrentMap:</strong>  Caffeine 实现了 <code>ConcurrentMap</code> 接口，这意味着它是线程安全的。 底层使用分段锁或无锁数据结构来支持并发访问。</li><li><strong>CacheLoader (可选):</strong> 用于在缓存未命中时自动加载值。 可以自定义实现 <code>CacheLoader</code> 接口， 定义加载数据的逻辑.</li><li><strong>CacheWriter (可选):</strong>  用于处理缓存的写入和删除操作。 可以自定义实现 <code>CacheWriter</code> 接口，定义写入和移除缓存条目的逻辑。</li><li><strong>驱逐策略 (Eviction Policies):</strong>  Caffeine 采用基于 <em>最逼近最优</em>  (Approaching Optimal) 的驱逐算法，包括TinyLFU 和 Window-TinyLFU。<ul><li><strong>TinyLFU (Tiny Least Frequently Used):</strong> 一个频率sketch， 用于估算每个条目的访问频率。 占用了极小的内存空间，但能提供接近最佳的频率估算。</li><li><strong>Window-TinyLFU:</strong> 一个结合了最近访问（Windowed LFU）和频率信息（TinyLFU）的二级缓存结构。最近访问的数据保存在一个小的”窗口”中，而更长时间内的数据则通过TinyLFU来估算访问频率.</li></ul></li><li><strong>刷新策略 (Refresh):</strong> 支持异步地刷新缓存条目，从而保持缓存数据的新鲜度。</li><li><strong>写入策略 (Write):</strong> 支持同步或异步地将缓存条目写入到持久层（例如数据库）。</li><li><strong>监听器 (Listeners):</strong> 允许注册监听器，以便在缓存条目被添加、更新或移除时执行自定义的逻辑。</li></ul><p>优点：</p><ul><li><strong>接近最优的命中率：</strong> Caffeine 使用了非常先进的驱逐算法，能够更好地保留热点数据，从而提高命中率。</li><li><strong>低延迟：</strong> Caffeine 针对低延迟进行了优化，尽可能减少锁竞争，提高并发访问性能。</li><li><strong>自动加载：</strong> 通过 <code>CacheLoader</code> 可以在缓存未命中时自动加载数据，简化了缓存的使用。</li><li><strong>异步刷新：</strong> 异步刷新能够保持缓存数据的新鲜度，同时避免阻塞主线程。</li><li><strong>灵活的配置：</strong> Caffeine 提供了丰富的配置选项，可以根据不同的需求进行定制。</li><li><strong>轻量级：</strong> Caffeine 依赖少，体积小，易于集成到项目中。</li></ul><hr><p>使用</p><p>手动加载:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; manualCache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>))  <span class="comment">// 10 秒后过期</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)                         <span class="comment">// 最大容量 100</span></span><br><span class="line">                .removalListener((String key, String value, com.github.benmanes.caffeine.cache.RemovalCause cause) -&gt;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause)) <span class="comment">//移除监听器</span></span><br><span class="line">                .build();</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>自动加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; loadingCache = Caffeine.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               .expireAfterWrite(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">               .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)  <span class="comment">// 定时刷新</span></span><br><span class="line">               .build(key -&gt; &#123;</span><br><span class="line">                   <span class="comment">// 在这里实现加载数据的逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Loading value for key: &quot;</span> + key);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&quot;value for &quot;</span> + key;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>异步加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String,String&gt; asyncLoadingCache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                .expireAfterWrite(<span class="number">5</span>,TimeUnit.MINUTES)</span><br><span class="line">                .buildAsync(key -&gt; &#123;</span><br><span class="line">                    <span class="comment">//在这里实现异步加载数据的逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Async Loading value for key :&quot;</span> + key);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Async value for &quot;</span> + key;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><h1 id="使用缓存会导致的问题"><a href="#使用缓存会导致的问题" class="headerlink" title="使用缓存会导致的问题"></a>使用缓存会导致的问题</h1><h2 id="数据的一致性问题"><a href="#数据的一致性问题" class="headerlink" title="数据的一致性问题"></a>数据的一致性问题</h2><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><p>为什么是删除缓存？</p><p>在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。可能是一个多表查询的运算的结果。其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><p>1.先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><ul><li>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</li><li>延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。</li></ul><p>2.数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><p>设计：</p><ul><li><strong>读请求:</strong> 优先从缓存读取。 如果缓存未命中，则发起缓存更新请求（放入队列），并同步等待一段时间。 如果等待超时，则直接读取数据库（返回旧数据）。</li><li><strong>写请求:</strong> 首先删除缓存，然后更新数据库。 更新数据库的操作也放入队列中串行执行。</li><li><strong>队列:</strong> 每个数据项（例如商品 ID）维护一个专属的 JVM 内部队列。</li><li><strong>工作线程:</strong> 每个队列对应一个工作线程，负责串行执行队列中的更新操作（先更新数据库，后更新缓存）。</li><li><strong>路由:</strong> 基于数据唯一标识（例如商品 ID）进行路由，确保对同一数据项的读写请求都会路由到相同的队列和工作线程。</li></ul><p>问题：</p><p>1.队列积压：<em>务必设置读请求的超时时间，保证请求及时返回。**加队列的数量，将数据分散到不同的队列中，减少每个队列的积压。</em></p><p>或者是如果是热点数据搞得，我们可以拆分热点数据和普通数据</p><p>2.单个热点数据过热，<em>预先识别热点数据，并将其分散到不同的队列中。 可以采用更精细的哈希算法，或者人工配置的方式。</em>，人工限流降级，在服务器内部使用二级缓存。</p><p>3.路由实例间得路由不一致，<em>使用一致性哈希算法，确保对同一数据项的请求始终路由到相同的服务实例。</em>或者使用nginx进行代理</p><p>一看这样我们可以直接引入kafka来解决啊</p><div class="table-container"><table><thead><tr><th>特性</th><th>JVM 内部队列</th><th>Kafka</th></tr></thead><tbody><tr><td>解耦程度</td><td>有限，读写服务在同一 JVM 中</td><td>更彻底，读写服务完全解耦</td></tr><tr><td>扩展性</td><td>受单机 JVM 限制</td><td>高，可以通过增加分区和消费者实例来提高吞吐量</td></tr><tr><td>可靠性</td><td>较低，消息容易丢失</td><td>高，消息持久化和消息重放机制</td></tr><tr><td>容错性</td><td>差，单点故障</td><td>好，集群容错</td></tr><tr><td>复杂度</td><td>低，易于实现</td><td>高，需要配置和维护 Kafka 集群</td></tr><tr><td>延迟</td><td>低，JVM 内部通信</td><td>较高，消息需要经过网络传输</td></tr><tr><td>一致性保证</td><td>容易实现简单的一致性</td><td>需要考虑事务和消息顺序性</td></tr></tbody></table></div><h2 id="缓存三兄弟"><a href="#缓存三兄弟" class="headerlink" title="缓存三兄弟"></a>缓存三兄弟</h2><p>缓存三兄弟就是我们常说的的缓存击穿，缓存穿透，缓存雪崩。</p><hr><p>缓存雪崩，是指短时间内有大量key过期，然后一下子压力全到数据库上面去了。</p><p>预防：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。</p><p>处理：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p><p>事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p><p>在代码上的话，我们可以使用互斥锁，只有获得了锁才能去访问。如果是过期时间的问题，采取热点数据永不过期，设置随机的过期时间等等。</p><p>如果是太多请求的话，我们可以限流，或者降级。</p><p>缓存穿透：</p><p>就是很多个缓存查不到的请求，数据库也查不到的请求发过来了</p><p>我们可以采用空值的方式,每次系统  从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code> 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><p>或者是我们使用布隆过滤器，过滤我们数据库没有的请求。</p><p>缓存击穿:</p><p>就是一瞬间热点key直接失效了，大量的请求就击穿了缓存，直接请求数据库。</p><ul><li>若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。</li><li>若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。</li><li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li></ul><h2 id="缓存并发竞争"><a href="#缓存并发竞争" class="headerlink" title="缓存并发竞争"></a>缓存并发竞争</h2><p>Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？</p><p>就是<strong>多客户端同时并发写</strong>一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</p><p>比如：</p><ul><li><strong>库存扣减：</strong> 多个客户端同时购买同一商品，导致库存超卖。</li><li><strong>计数器更新：</strong> 多个客户端同时增加计数器的值，导致计数器结果不准确。</li><li><strong>排行榜更新：</strong> 多个客户端同时更新排行榜数据，导致排行榜数据不一致。</li></ul><p>1.单线程架构,Redis 本身是单线程架构，这意味着 Redis 命令是顺序执行的，避免了多线程并发问题。 但是，单线程架构并不能完全解决并发竞争问题。 例如，多个客户端同时发送 <code>INCR</code> 命令来增加计数器的值，Redis 仍然可能因为网络延迟等原因导致计数器结果不准确。</p><p>2.原子操作，Redis 提供了许多原子操作，例如 <code>INCR</code>、<code>DECR</code>、<code>SETNX</code> 等。 原子操作可以保证操作的完整性，避免并发竞争问题。 例如，可以使用 <code>INCR</code> 命令来原子地增加计数器的值。</p><p>3.Lua脚本，可以将多个 Redis 命令组合成一个 Lua 脚本，然后使用 <code>EVAL</code> 命令来原子地执行该脚本。 Lua 脚本可以保证多个命令的原子性，避免并发竞争问题。 例如，可以使用 Lua 脚本来实现原子性的库存扣减操作。</p><p>4.CAS，Redis 提供了 <code>WATCH</code> 命令来实现乐观锁。 乐观锁允许多个客户端同时读取同一个 Key 的值，但是在更新 Key 的值之前，需要先检查该 Key 的值是否被其他客户端修改过。 如果被修改过，则更新失败，需要重新尝试。</p><ul><li>如果被 <code>WATCH</code> 监视的 Key 在事务执行期间被其他客户端修改过，那么 <code>EXEC</code> 命令会返回 <code>nil</code>，表示事务执行失败。</li><li>如果被 <code>WATCH</code> 监视的 Key 在事务执行期间没有被其他客户端修改过，那么 <code>EXEC</code> 命令会执行事务中的所有命令，并返回执行结果。</li></ul><p>5.分布式锁，redission?保证同一时间只有一个客户端可以访问共享资源。</p><p>可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。</p><p>你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。</p><p>每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/Cache/">Cache</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/cache1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode HOT面试题目2</title>
      <link>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodehot2/</link>
      <guid>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodehot2/</guid>
      <pubDate>Sat, 05 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;面试二轮&quot;&gt;&lt;a href=&quot;#面试二轮&quot; class=&quot;headerlink&quot; title=&quot;面试二轮&quot;&gt;&lt;/a&gt;面试二轮&lt;/h1&gt;&lt;h2 id=&quot;76-最小覆盖子串-x&quot;&gt;&lt;a href=&quot;#76-最小覆盖子串-x&quot; class=&quot;headerlink&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="面试二轮"><a href="#面试二轮" class="headerlink" title="面试二轮"></a>面试二轮</h1><h2 id="76-最小覆盖子串-x"><a href="#76-最小覆盖子串-x" class="headerlink" title="76. 最小覆盖子串(x)"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>(x)</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">minWindow</span>(<span class="params"><span class="built_in">String</span> S, <span class="built_in">String</span> t</span>) &#123;</span><br><span class="line">        int[] cnt = <span class="keyword">new</span> int[<span class="number">128</span>];</span><br><span class="line">        int less = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (char <span class="attr">c</span>:t.<span class="title function_">toCharArray</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                less++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] s = S.<span class="title function_">toCharArray</span>();</span><br><span class="line">        int m  = s.<span class="property">length</span>;</span><br><span class="line">        int ansleft  = -<span class="number">1</span>;</span><br><span class="line">        int ansRight = m;</span><br><span class="line">        </span><br><span class="line">        int left =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (int right = <span class="number">0</span>;right&lt;m;right++)&#123;</span><br><span class="line">            char c =s[right];</span><br><span class="line">            cnt[c]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c]==<span class="number">0</span>)&#123;</span><br><span class="line">                less--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (right-left&lt;ansRight-ansleft)&#123;</span><br><span class="line">                    ansleft = left;</span><br><span class="line">                    ansRight = right;</span><br><span class="line">                &#125;</span><br><span class="line">                char x = s[left];</span><br><span class="line">                <span class="keyword">if</span> (cnt[x]==<span class="number">0</span>)&#123;</span><br><span class="line">                    less++;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[x]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansleft&lt;<span class="number">0</span>?<span class="string">&quot;&quot;</span>:S.<span class="title function_">substring</span>(ansleft,ansRight+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码使用了滑动窗口的方法，一看他是个window就是滑动窗口</p><p>解决思路是进-改-出</p><p>先区遍历元素，然后确定要出现的最少的次数</p><p>然后进右端端点，需要的出现次数—</p><p>然后最少字母次数—</p><p>当最小次数为0的时候，这个时候如果滑动窗口的长度小于结果的长度的时候</p><p>更新节点位置</p><p>然后出左节点，如果需要出现的为0了</p><p>那么最少字母次数++</p><p>然后左端点对应的字母需要次数++，左端点移动</p><p>最后需要的是结果左端点和右端点之间的</p><p>也就是我们常说的right-left+1</p><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>就是一个贪心算法，我们每一步都选dfs的最优解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution124A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lval</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rval</span>  <span class="operator">=</span>dfs(root.right);</span><br><span class="line">        ans  = Math.max(ans,lval+rval+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(lval,rval)+ root.val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选左还是选右的问题</p><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><p><strong><a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p>前缀树就是记录字符串用的，一个放孩子孩子节点的字母表，一个放是不是结束的标志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Node[] son = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:word.toCharArray())&#123;</span><br><span class="line">            c -=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.son[c]==<span class="literal">null</span>)&#123;</span><br><span class="line">                cur.son[c] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(word)==<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(prefix)!=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:word.toCharArray())&#123;</span><br><span class="line">            c-=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.son[c]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end?<span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder()</code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code> 以内的答案将被接受。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-105 &lt;= num &lt;= 105</code></li><li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素</li><li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.size()==right.size())&#123;</span><br><span class="line">            right.offer(num);</span><br><span class="line">            left.offer(right.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left.offer(num);</span><br><span class="line">            right.offer(left.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left.size()&gt;right.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> left.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left.peek()+right.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们维护一个最大堆left和一个最小堆right</p><p>加元素的时候，如果当前左右数量相等的话，那么优先加入最小堆，然后把最小堆的栈顶给左堆</p><p>不想等的话，一般是最大堆需要，然后小的栈顶给最小堆</p><p>取中位数的时候，如果是偶数，那么是最大堆和最小堆顶的平均值</p><p>不是的话就是最大堆的顶</p><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>看到这种括号题目，第一个想到就是使用栈来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution32AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> vaild[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;(&#x27;</span>) stack.push(i);</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">&#x27;)&#x27;</span>&amp;&amp;!stack.isEmpty())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                vaild[i] = <span class="literal">true</span>;</span><br><span class="line">                vaild[index]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;vaild.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vaild[i])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max(res,count);</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,count);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用栈，记录一个有效值的数字。</p><p>然后遍历字符找到有效括号</p><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution141A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常easy的环形链表</p><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution72A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String text1, String text2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] t=  text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[] f= <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            f[j+<span class="number">1</span>] = j+<span class="number">1</span>;<span class="comment">//text2 的前 j + 1 个字符所需的操作数为 j + 1 (即插入 j + 1 个字符)。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> f[<span class="number">0</span>];</span><br><span class="line">            f[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span>f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x ==t[j]?pre:Math.min(Math.min(f[j+<span class="number">1</span>],f[j]),pre)+<span class="number">1</span>;</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>text1</code> 的当前字符 <code>x</code> 与 <code>text2</code> 的当前字符 <code>t[j]</code> 相同，那么不需要任何操作</p><ul><li></li><li><code>f[j + 1]</code>: 表示删除 <code>text1</code> 的当前字符 <code>x</code>。对应于操作”删除”。</li><li><p><code>f[j]</code>: 表示在 <code>text1</code> 中插入一个字符，使得 <code>text1</code> 的当前字符等于 <code>t[j]</code>。对应于操作”插入”。</p></li><li><p><code>pre</code>: 表示将 <code>text1</code> 的当前字符 <code>x</code> 替换为 <code>t[j]</code>。对应于操作”替换”。 由于需要经过一次编辑(删除/插入/替换)才能让<code>text1</code>前<code>i</code>个字符匹配<code>text2</code>前<code>j+1</code>个字符，所以操作总数要+1。</p></li></ul><h2 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前K个高频单词</a></h2><p>给定一个单词列表 <code>words</code> 和一个整数 <code>k</code> ，返回前 <code>k</code> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p><p>一看到这个题，我就想到用hashmap来做，然后我看又需要顺序，那我直接使用linkedhashmap不久得了。发现并不是的</p><p>可以使用优先队列，或者是规定compare的List，这里直接用优先队列吧</p><p>然后挑出前k个</p><p>放入list即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution692</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (w1,w2)-&gt;map.get(w1).equals(map.get(w2))?w2.compareTo(w1):map.get(w1)-map.get(w2)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String word:map.keySet())&#123;</span><br><span class="line">            queue.offer(word);</span><br><span class="line">            <span class="keyword">if</span> (queue.size()&gt;k)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            res.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p>又是不重复，直接上hashset,一开始想这样做来，但发现不对，这样做的是字符串的数量</p><p>然后就想使用滑动窗口，更新值。如果含有就更新左端点，</p><p>不含有就更新最大值，然后放入右端点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(right))) &#123;</span><br><span class="line">                left = Math.max(left, map.get(s.charAt(right)));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(right), right);</span><br><span class="line">            maxlen = Math.max(maxlen, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution394A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span>  <span class="variable">curSting</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack_multi=  <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character c:s.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span> (Character.isDigit(c))&#123;</span><br><span class="line">                    num = num*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    stack_multi.push(num);</span><br><span class="line">                    stack.push(curSting);</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    curSting = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">longnum</span> <span class="operator">=</span> stack_multi.pop();</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack.pop());</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;longnum;i++)&#123;</span><br><span class="line">                        temp.append(curSting);</span><br><span class="line">                    &#125;</span><br><span class="line">                    curSting=  temp.toString();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    curSting +=c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> curSting;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经典的括号和栈的问题</p><p>一个放之前的字符，一个放数字。当变成】结束的时候。将里面的字符遍历数字遍</p><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution82AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur.next!=<span class="literal">null</span>&amp;&amp;cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.next.val == val)&#123;</span><br><span class="line">                <span class="keyword">while</span> (cur.next!=<span class="literal">null</span>&amp;&amp;cur.next.val == val)&#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是去检测cur.next和cur和cur.next之后的值是不是想到，想到就只留cur，然后其他的跳过</p><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p>可以使用hash表+定长的滑动窗口试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//简单去重</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//最小的都大，直接抛弃</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[n - <span class="number">3</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//最大的都小直接抛弃</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="comment">//简单去重</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="comment">//最小的三个都大，抛弃</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span>) nums[i] + nums[j] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="comment">//最大的三个都小抛弃</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;<span class="comment">//找出左右边界</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution40A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,target,candidates,ans,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> left,<span class="type">int</span>[] candidates,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;candidates.length&amp;&amp;candidates[j]&lt;=left;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;i&amp;&amp;candidates.length==candidates[j-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[j]);</span><br><span class="line">            dfs(j+<span class="number">1</span>,left-candidates[j],candidates,ans,path);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选与不选的问题，如果j&gt;i且等与j的数都不选</p><p>记得回溯哈</p><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p>就是类似于一个加法的计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStringsA</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        String ans= <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(turn(num1)+turn(num2));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">turn</span><span class="params">(String nums)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=nums.length();i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans +=(i-<span class="number">1</span>)*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span>&#123;</span><br><span class="line">        StringBuilder res= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length()-<span class="number">1</span>,j=num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span>  <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            res.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a><a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></h2><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution946</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;stack.peek()==popped[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的模拟栈运行的操作</p><p>当前栈的栈顶的数，如果是pop序列中的第i个的话，就说明这次成功，然后i++;</p><p>最后如果栈为空了，也就是所有的都符合，返回true</p><h2 id="146-LRU-缓存-x"><a href="#146-LRU-缓存-x" class="headerlink" title="146. LRU 缓存(x)"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a>(x)</h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCacheAA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key,vaule;</span><br><span class="line">        Node prev,next;</span><br><span class="line">        Node(<span class="type">int</span> k,<span class="type">int</span> v)&#123;</span><br><span class="line">            key = k;</span><br><span class="line">            vaule = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 哨兵节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, Node&gt; keyToNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCacheAA</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        dummy.prev = dummy;</span><br><span class="line">        dummy.next = dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(key);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="literal">null</span>?node.vaule:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> getNode(key);</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            node.vaule = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(key,value);</span><br><span class="line">        keyToNode.put(key,node);</span><br><span class="line">        pushFront(node);</span><br><span class="line">        <span class="keyword">if</span> (keyToNode.size()&gt;capacity)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">backNode</span> <span class="operator">=</span> dummy.prev;</span><br><span class="line">            keyToNode.remove(backNode.key);</span><br><span class="line">            remove(backNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushFront</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        x.prev = dummy;</span><br><span class="line">        x.next = dummy.next;</span><br><span class="line">        x.prev.next = x;</span><br><span class="line">        x.next.prev = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyToNode.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> keyToNode.get(key);</span><br><span class="line">        remove(node);</span><br><span class="line">        pushFront(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是实现了按LRU缓存的策略，主要使用的双向链表和hash表来解决的</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">。</span><br></pre></td></tr></table></figure><p>快速的时候hashmap来进行查询</p><p>如果是更多的话，可以参考固定一个，然后移动另外一个</p><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution88AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> m-<span class="number">1</span>,len2=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len1&gt;=<span class="number">0</span>&amp;&amp;len2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[len--] = nums1[len1]&gt;nums2[len2]?nums1[len1--]:nums2[len2--];</span><br><span class="line">        &#125;</span><br><span class="line">       System.arraycopy(nums2,<span class="number">0</span>,nums1,<span class="number">0</span>,len2+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的排序，就是从后面开始遍历，看谁大就行了</p><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>这里就用到了反转链表的知识，我们先找到链表的中点，然后将链表一分为二，然后反转后面的链表，然后再合并两个链表即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution143B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> middle(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> reverseList(mid);</span><br><span class="line">        <span class="keyword">while</span> (head2.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next2</span> <span class="operator">=</span> head2.next;</span><br><span class="line">            head.next = head2;</span><br><span class="line">            head2.next = next;</span><br><span class="line">            head = next;</span><br><span class="line">            head2 = next2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre=  cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span>head,fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow  = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h2><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1&quot; -&gt; &#x27;A&#x27; &quot;2&quot; -&gt; &#x27;B&#x27; ... &quot;25&quot; -&gt; &#x27;Y&#x27; &quot;26&quot; -&gt; &#x27;Z&#x27;</span><br></pre></td></tr></table></figure><p>然而，在 <strong>解码</strong> 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（<code>&quot;2&quot;</code> 和 <code>&quot;5&quot;</code> 与 <code>&quot;25&quot;</code>）。</p><p>例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1, 1, 10, 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11, 10, 6)</code></li><li>消息不能分组为 <code>(1, 11, 06)</code> ，因为 <code>&quot;06&quot;</code> 不是一个合法编码（只有 “6” 是合法的）。</li></ul><p>注意，可能存在无法解码的字符串。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。如果没有合法的方式解码整个字符串，返回 <code>0</code>。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution91AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s=  <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i] = f[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i]+=f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个简单的动态规划</p><p>就只有俩选择，如果是1-9之内的就说明是a,也就是选择前面的一个就够了</p><p>如果是10-26之内，就说明要前面的两个才行</p><p>如果都可以的话，这俩都要。所以是+=f[i-2]</p><p>转移 <code>f[i]</code> 时只依赖 <code>f[i-1]</code> 和 <code>f[i-2]</code> 两个状态。</p><p>可以采用与「滚动数组」类似的思路，只创建长度为 3 的数组，通过取余的方式来复用不再需要的下标。进行一波优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution91AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s=  <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i] = f[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i]+=f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodingsA</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        s = <span class="string">&quot; &quot;</span>+s;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[]f = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>]  =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i%<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cs[i]-<span class="string">&#x27;0&#x27;</span>,b = (cs[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(cs[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>) f[i%<span class="number">3</span>] = f[(i-<span class="number">1</span>)%<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>) f[i%<span class="number">3</span>] +=f[(i-<span class="number">2</span>)%<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution215</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈哈两行直接解决，虽然不是最合适的。</p><h2 id="25-K-个一组翻转链表（x暂时有点懵逼啊）"><a href="#25-K-个一组翻转链表（x暂时有点懵逼啊）" class="headerlink" title="25. K 个一组翻转链表（x暂时有点懵逼啊）"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>（x暂时有点懵逼啊）</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution215</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution25AAa</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//统计节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;cur!=<span class="literal">null</span>;cur = cur.next)&#123;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span>  <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;n&gt;=k;n-=k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span>cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> p0.next;</span><br><span class="line">            p0.next.next = cur;</span><br><span class="line">            p0.next = pre;</span><br><span class="line">            p0 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先按k个数字分开好几组，然后k个数字的内部就是简单的交换</p><p>然后外部的话，p0=dummy</p><p>ListNode next = p0.next;下一部分的起始节点</p><p>p0.next.next = cur，下一部分的起点。</p><p>p0.next = pre;真起点</p><p>p0 = next往下移动，将 <code>p0</code> 移动到下一组待翻转节点的前面。</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution15AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>;k&lt;nums.length-<span class="number">2</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> i=k+<span class="number">1</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[k]+nums[i]+nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[++i]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[--j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums[k],nums[i],nums[j])));</span><br><span class="line">                    i++;j--;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟前面的四个组合是用的一样的方法，就是双指针，从头开始，然后去遍历，确定最大的和最小的，然后在里面去寻找。</p><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution53B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minpresum</span> <span class="operator">=</span> <span class="number">0</span>,presum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            presum +=x;</span><br><span class="line">            ans = Math.max(ans,presum-minpresum);</span><br><span class="line">            minpresum = Math.min(minpresum,presum);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维护一个最大值和一个最小值，最大值就是和-小的。</p><p>可以扩展为乘法，最大值可能就是最小值乘出来的</p><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution21B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list2==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">           list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">           <span class="keyword">return</span> list1;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">           <span class="keyword">return</span> list2;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁的使用递归直接完成</p><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution5B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (s==<span class="literal">null</span>||s.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">strlen</span> <span class="operator">=</span> s.length();</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxStart</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="type">boolean</span>[][] dp  =<span class="keyword">new</span> <span class="title class_">boolean</span>[strlen][strlen];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> r= <span class="number">1</span>;r&lt;strlen;r++)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l&lt;r;l++)&#123;</span><br><span class="line">             <span class="keyword">if</span> (s.charAt(l)==s.charAt(r)&amp;&amp;(r-l&lt;=<span class="number">2</span>||dp[l+<span class="number">1</span>][r-<span class="number">1</span>]))&#123;</span><br><span class="line">                 dp[l][r] = <span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">if</span> (r-l+<span class="number">1</span>&gt;maxLen)&#123;</span><br><span class="line">                     maxLen = r-l+<span class="number">1</span>;</span><br><span class="line">                     maxStart = l;</span><br><span class="line">                     maxEnd = r;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> s.substring(maxStart,maxEnd+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用 动态规划来完成，</p><p>(r-1&lt;=2||dp l+1 r-1这个很好玩成了这个</p><p>如果r-l&lt;=2的话，就说明就一个数 了，肯定是回文。就是基数的时候</p><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution102B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为他是层序遍历，遍历完这一层才进行下一次遍历。所以我们要把这一层的节点全都放进队列。</p><p>然后一个一个取出来，记录值。然后再左右的去遍历</p><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution33B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[n-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span>  <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target&lt;=end&amp;&amp;nums[mid]&gt;end)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target&gt;end&amp;&amp;nums[mid]&lt;=end)&#123;</span><br><span class="line">                right =mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left]!=target?-<span class="number">1</span>:left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一看到这个时间复杂度，我们第一时间想到的就是我们最喜欢的二分查找哈哈。</p><p>然后一看到这个旋转数组，我们肯定要关注最后一个数字，因为就是从他这旋转的</p><p>然后有三种大情况</p><p>目标值小于最后一个数，中位大于最后一个数，也就是说目标值在右边，中位在左。我们移动left指针到mid+1</p><p>然后都在一遍的话，就是普通的二分查找了</p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>看到这个题，一个矩阵，直接进行遍历，就可以了。如果是求最大面积的话，再加上动态规划即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution200B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid ,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=grid.length||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] =<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>看到这种排列的题目，首先想到的就是回溯法+dfs哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution46</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="built_in">this</span>.nums.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span>  <span class="operator">=</span> nums.get(a);</span><br><span class="line">        nums.set(a,nums.get(b));</span><br><span class="line">        nums.set(b,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x== nums.size()-<span class="number">1</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;nums.size();i++)&#123;</span><br><span class="line">            swap(i,x);</span><br><span class="line">            dfs(x+<span class="number">1</span>);</span><br><span class="line">            swap(i,x);<span class="comment">//这就是回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是固定一位，然后去移动他后面的位置。</p><p>然后移动完，再给他恢复。这就是回溯算法的所在</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution20AB</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>||c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;)&#x27;</span>||c==<span class="string">&#x27;]&#x27;</span>||c==<span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) || (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看到这个题目我就知道要使用栈，之前的哪些题都是差不多的</p><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution121B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE,profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price:prices)&#123;</span><br><span class="line">            cost = Math.min(cost,price);</span><br><span class="line">            profit = Math.max(profit,price-cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较easy的一道题目了</p><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution236B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span>lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是比较简单的一道递归题目</p><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution103B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp  =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) queue.add(node.right); </span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是一个达到锯齿状层序遍历的目的，普通的层序遍历直接使用一个队列就ok</p><p>现在的如果现在比如我们里面的是奇数的话，就说明当前是偶数层，从右到左开始遍历，就是往前面加，</p><p>如果是偶数的话，就从左往右开始遍历，就是往后面开始加</p><p>一个层一个List<Interger></p><h2 id="手撕快速排序-x"><a href="#手撕快速排序-x" class="headerlink" title="手撕快速排序(x)"></a>手撕快速排序(x)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">OptimizedQuickSort</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] sortArry(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (right-left+<span class="number">1</span>&lt;=INSERTION_SORT_THRESHOLD)&#123;</span><br><span class="line">            insertionSort(nums,left,right);<span class="comment">//小数字使用插入排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pivots = partition3Way(nums,left,right);</span><br><span class="line">        quickSort(nums,left,pivots[<span class="number">0</span>]-<span class="number">1</span>);<span class="comment">//只递归小于的部分</span></span><br><span class="line">        quickSort(nums,pivots[<span class="number">1</span>]+<span class="number">1</span>,right);<span class="comment">//只递归大于的部分</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i!=j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j]  = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span>  <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=left&amp;&amp;nums[j]&gt;key)&#123;</span><br><span class="line">                nums[j+<span class="number">1</span>]  = nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] partition3Way(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left+random.nextInt(right-left+<span class="number">1</span>);</span><br><span class="line">        swap(nums,left,randomIndex);<span class="comment">//一个随机值，交换left和随机值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span>right +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;gt)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;pivot)&#123;<span class="comment">//小于pivot放入左区域</span></span><br><span class="line">                swap(nums,++lt,i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&gt;pivot)&#123;<span class="comment">//放入右区域</span></span><br><span class="line">                swap(nums,--gt,i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;<span class="comment">//只需要移动指针即可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,left,lt);<span class="comment">//最后交换回来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;lt,gt-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p>使用头插法真的得劲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution92B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">g</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;step&lt;left-<span class="number">1</span>;step++)&#123;</span><br><span class="line">            g = g.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">removed</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line"></span><br><span class="line">            removed.next  = g.next;</span><br><span class="line">            g.next =removed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先设一个虚拟节点，这样的话，就不用考虑边界值的问题了</p><p>然后g指针式left前面的</p><p>p指针指向left节点</p><p>然后我们这样把指针移动到该有的位置</p><p>然后反转的时候要反转的是right-left个节点</p><p>然后我们从把他们使用头插相继的插入到g节点的后面，因为g节点不动，动的是p节点。头插的话，先插的就在后面了。实现 了反转的效果</p><p>这样的就完成了。</p><h2 id="141-环形链表-1"><a href="#141-环形链表-1" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution141B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span>  <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是经典快慢节点完成哈哈</p><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution54B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        Integer[] ans = <span class="keyword">new</span> <span class="title class_">Integer</span>[(r+<span class="number">1</span>)*(b+<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=l;i&lt;=r;i++) ans[x++]  = matrix[t][i];</span><br><span class="line">            <span class="keyword">if</span>(++t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=t;i&lt;=b;i++) ans[x++] = matrix[i][r];</span><br><span class="line">            <span class="keyword">if</span> (l&gt;--r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r;i&gt;=l;i--) ans[x++] = matrix[b][i];</span><br><span class="line">            <span class="keyword">if</span> (t&gt;--b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=b;i&gt;=t;i--) ans[x++]  = matrix[i][l];</span><br><span class="line">            <span class="keyword">if</span> (++l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是设定好边界值只会然后进行遍历即可</p><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution300B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是简单的动态规划，如果相等就+1，然后统计数量</p><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution23B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.val-b.val);</span><br><span class="line">        <span class="keyword">for</span> (ListNode head:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(head);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是使用最小堆，因为每个链表之中的head肯定是最小的</p><p>那我们就一直遍历里面的head，然后放入最小堆，然后将最小堆里面的取出来，放进我们的新的链表</p><p>可以加上dummy哨兵节点</p><h2 id="415-字符串相加-1"><a href="#415-字符串相加-1" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>）， 也不能直接将输入的字符串转换为整数形式。</p><p>经典计算器类型的题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution415B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> i=num1.length()-<span class="number">1</span>,j = num2.length()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i&gt;=<span class="number">0</span>?num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j&gt;=<span class="number">0</span>?num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1+n2+carry;</span><br><span class="line">            carry = tmp/<span class="number">10</span>;</span><br><span class="line">            sb.append(tmp%<span class="number">10</span>);</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry==<span class="number">1</span>) sb.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这种的题目都要使用StringBuilder这一个单线程的</p><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution56B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals,(p,q)-&gt;p[<span class="number">0</span>]-q[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p:intervals)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span>ans.size();</span><br><span class="line">            <span class="keyword">if</span> (m&gt;<span class="number">0</span>&amp;&amp;p[<span class="number">0</span>]&lt;=ans.get(m-<span class="number">1</span>)[<span class="number">1</span>])&#123;</span><br><span class="line">                ans.get(m-<span class="number">1</span>)[<span class="number">1</span>] = Math.max(ans.get(m-<span class="number">1</span>)[<span class="number">1</span>],p[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是按头上第一个排序之后，然后看最后面1的位置的数，是不是小于下一个的头上的数，小于的话，就可以合并</p><p>然后更新新的值</p><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution160B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        ListNode pA= headA;</span><br><span class="line">        ListNode pB=  headB;</span><br><span class="line">        <span class="keyword">while</span> (pA!=pB)&#123;</span><br><span class="line">            pA = (pA==<span class="literal">null</span>)?headB:pA.next;</span><br><span class="line">            pB = (pB==<span class="literal">null</span>) ?headA:pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是有公共部分的，如果我们其中一个遍历完之后，再从另一个链表的起点继续遍历</p><p>等他们相遇的时候，就是我们需要的那个交点</p><h2 id="42-接雨水-x"><a href="#42-接雨水-x" class="headerlink" title="42. 接雨水(x)"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>(x)</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left= <span class="number">0</span>,right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> <span class="number">0</span>,sufMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            preMax = Math.max(preMax,height[left]);</span><br><span class="line">            sufMax = Math.max(sufMax,height[right]);</span><br><span class="line">            ans +=preMax&lt;sufMax?preMax-height[left++]:sufMax-height[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双指针谁小就移动谁，算是1D接雨水的最优解</p><p>2D接雨水</p><p>转换为了矩阵，但还是之前使用的木桶效应。</p><p>我们可以从这个最矮的方块出发，向其内部（上下左右）相邻的、未访问过的方块进行探索：</p><ul><li>如果相邻的方块 <code>(nr, nc)</code> 比 <code>h</code> 还矮，说明水可以把它淹没。这个方块能接的水量就是 <code>h - height[nr][nc]</code>。然后将这个方块也视为新的海岸线（因为它现在是水能到达的边界了），其有效高度是<code>h</code>（因为水是从<code>h</code>处漫灌过来的），把它加入我们的“海岸线”集合。</li><li>如果相邻的方块比 <code>h</code> 高，它自己就成了一堵新墙，无法积水。但它也成为了新的边界，需要加入“海岸线”集合。</li></ul><p>看到这个我们就要用我们的优先队列，也就是最小堆了，不断更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution407</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] DIRS = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapRainWater</span><span class="params">(<span class="type">int</span>[][] heightMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (heightMap==<span class="literal">null</span>||heightMap.length&lt;=<span class="number">2</span>||heightMap[<span class="number">0</span>].length&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> heightMap.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span>  <span class="operator">=</span> heightMap[<span class="number">0</span>].length;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;(a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>||i==rows-<span class="number">1</span>||j==<span class="number">0</span>||j==cols-<span class="number">1</span>)&#123;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;heightMap[i][j],i,j&#125;);</span><br><span class="line">                    heightMap[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] t = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span> t[<span class="number">0</span>],i=t[<span class="number">1</span>],j=t[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] d:DIRS)&#123;</span><br><span class="line">                <span class="type">int</span> x= i+d[<span class="number">0</span>],y = j+d[<span class="number">1</span>];<span class="comment">//i,j的邻居</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; rows &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; cols &amp;&amp; heightMap[x][y] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    ans +=Math.max(minHeight-heightMap[x][y],<span class="number">0</span>);</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Math.max(minHeight, heightMap[x][y]), x, y&#125;);</span><br><span class="line">                    heightMap[x][y] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列-x"><a href="#1143-最长公共子序列-x" class="headerlink" title="1143. 最长公共子序列(x)"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a>(x)</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1143B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] t = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[]f = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x:text1.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> f[j+<span class="number">1</span>];</span><br><span class="line">                f[j+<span class="number">1</span>] = x==t[j]?pre+<span class="number">1</span>:Math.max(f[j+<span class="number">1</span>],f[j]);</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用动态规划，这种的题目一般都是使用动态规划或者使用滑动窗口进行解决的</p><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution93B&#123;</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        int n  = s.length();</span><br><span class="line">        List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i =1;i&lt;n&amp;&amp;isvalid(s,0,i);i++)&#123;</span><br><span class="line">            for (int j=i+1;j&lt;n&amp;&amp;isvalid(s,i,j);j++)&#123;</span><br><span class="line">                for (int k =j+1;k&lt;n&amp;&amp;isvalid(s,j,k);k++)&#123;</span><br><span class="line">                    if (isvalid(s,k,n))&#123;</span><br><span class="line">                        ans.add(String.format(&quot;%s.%s.%s.%s&quot;,s.substring(0,i),s.substring(i,j),s.substring(j,k),s.substring(k)</span><br><span class="line">                                ));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isvalid(String s,int i,int j)&#123;</span><br><span class="line">        if (j-i&gt;3||j-i&gt;1&amp;&amp;s.charAt(i)==&#x27;0&#x27;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return Integer.parseInt(s.substring(i,j))&lt;=255;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是相当于将这一串数分割成4段，我们需要切三次，然后这里面的每一个都要符合ip的定义就可以</p><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution142A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head,slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast==slow)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="literal">null</span>||fast.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是我们第一次循环之后，如果这个适合fast节点空了，就说明是没有环了</p><p>然后我们进行第二次循环，fast从头开始，然后继续遍历。我们下一次fast和slow相遇的节点就是我们需要的环的开始的节点</p><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution19AA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> dummy,right = dummy;</span><br><span class="line">        <span class="keyword">while</span> (n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = left.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法非常的巧妙，就是一把尺子，右节点先走n步，然后两个节点一块走，右节点走到头的适合，左节点就是我们需要的倒数第n个节点的前一个节点。</p><p>然后跳过该节点就Ok</p><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p>一看到 这个熟悉的时间复杂度，就知道了我们应该使用二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">        <span class="comment">//确保num1是较短的数组</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length&gt;nums2.length)&#123;</span><br><span class="line">            <span class="type">int</span>[] tmp  = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">//哨兵值</span></span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">0</span>] = b[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        a[m+<span class="number">1</span>] = b[n+<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        System.arraycopy(nums1,<span class="number">0</span>,a,<span class="number">1</span>,m);</span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,b,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = m;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m+n+<span class="number">1</span>)/<span class="number">2</span>-i;<span class="comment">//总的</span></span><br><span class="line">            <span class="keyword">if</span> (a[i]&lt;=b[j+<span class="number">1</span>]&amp;&amp;b[j]&lt;=a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> Math.max(a[i],b[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">min2</span> <span class="operator">=</span>Math.min(a[i+<span class="number">1</span>],b[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> (m+n)%<span class="number">2</span>&gt;<span class="number">0</span>?max1:(max1+min2)/<span class="number">2.0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a[i]&gt;b[j+<span class="number">1</span>])&#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i是我们变得，j是我们合起来得中间的数</p><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution199A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans  = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> depth,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth==ans.size())&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,depth+<span class="number">1</span>,ans);</span><br><span class="line">        dfs(root.left,depth+<span class="number">1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右视图就是我们当前的深度等于我们的ans里面的数目的时候就是。</p><p>然后递归即可</p><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution94B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,ans);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        dfs(root.right,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归中序遍历</p><h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><p>给你两个 <strong>版本号字符串</strong> <code>version1</code> 和 <code>version2</code> ，请你比较它们。版本号由被点 <code>&#39;.&#39;</code> 分开的修订号组成。<strong>修订号的值</strong> 是它 <strong>转换为整数</strong> 并忽略前导零。</p><p>比较版本号时，请按 <strong>从左到右的顺序</strong> 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 <code>0</code>。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution165A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> version1.length(),m = version2.length();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n||j&lt;m)&#123;</span><br><span class="line">            <span class="type">int</span> num1=<span class="number">0</span>,num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;n&amp;&amp;version1.charAt(i)!=<span class="string">&#x27;.&#x27;</span>) num1 = num1*<span class="number">10</span>+version1.charAt(i++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&lt;m&amp;&amp;version2.charAt(j)!=<span class="string">&#x27;.&#x27;</span>) num2 =num2*<span class="number">10</span>+version2.charAt(j++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num1&lt;num2)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            i++;j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把字符串转换为数字然后进行比较。.前面是一部分，后面是一部分</p><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果 <code>target</code> 存在返回下标，否则返回 <code>-1</code>。</p><p>你必须编写一个具有 <code>O(log n)</code> 时间复杂度的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution704B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right  = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意边界的问题</p><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueueAB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; A;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueueAB</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> peek();</span><br><span class="line">        B.pop();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.peek();</span><br><span class="line">        <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!A.isEmpty())&#123;</span><br><span class="line">            B.push(A.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.isEmpty()&amp;&amp;B.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单的一道题目，就是我们使用两个栈来完成队列的先进先出的实现</p><p>一个栈A，一个栈B</p><p>我们进队列的时候先进入A栈，然后将A栈的元素，逐个放入B栈，我们从B栈里面pop元素，这样的话，就是按照顺序出栈的</p><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution148AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> middle(head);</span><br><span class="line">        head = sortList(head);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line">        <span class="keyword">return</span> mergeTowLists(head,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head )</span>&#123;</span><br><span class="line">        ListNode pre=  head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTowLists</span><span class="params">(ListNode list1,ListNode list2)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (list1!=<span class="literal">null</span>&amp;&amp;list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val&lt;list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1  = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1!=<span class="literal">null</span>?list1:list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个题目类似于第k个反转链表的那个题目。都是先找中点，这个只不过是直接排序了</p><p>那个还有一个反转的操作</p><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution22B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] path = <span class="keyword">new</span> <span class="title class_">char</span>[n*<span class="number">2</span>];</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,n,path,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> n,<span class="type">char</span>[] path,List&lt;String&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right==n)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;n)&#123;</span><br><span class="line">            path[left+right] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(left+<span class="number">1</span>,right,n,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right&lt;left)&#123;</span><br><span class="line">            path[left+right] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(left,right+<span class="number">1</span>,n,path,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>left代表左括号的，right代表右括号。使用选与不选的方法</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/java/">java</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      <category domain="https://blog.tokenlen.top/tags/java/">java</category>
      
      <category domain="https://blog.tokenlen.top/tags/leetcode/">leetcode</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/leetcode/leetcodehot2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MQ面试场景题</title>
      <link>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/MQ2/</link>
      <guid>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/MQ2/</guid>
      <pubDate>Sat, 05 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;场景题&quot;&gt;&lt;a href=&quot;#场景题&quot; class=&quot;headerlink&quot; title=&quot;场景题&quot;&gt;&lt;/a&gt;场景题&lt;/h1&gt;&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="1-如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#1-如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="1.如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>1.如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h2><p>问题分析：</p><p>1.大量的消息在MQ里积压了</p><p>2.MQ中的消息过期失效了</p><p>3.MQ的队列快满了</p><p>第一个问题：</p><p>消息在MQ大量积压是消费者和生成者生产消费的速度差距过大</p><p>消费者消费的少，生产者生产的多</p><p>那么我们就先修复消费者的问题，确保消费者都能使用</p><p>然后紧急扩容，新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</p><p>写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</p><p>临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</p><p>然后恢复原先的架构</p><p>或者是业务支持批量发送的时候，使用批量发送</p><p>或者是跳过非重要的消息，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">            ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> msgs.get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxOffset</span> <span class="operator">=</span></span><br><span class="line">            msgs.get(<span class="number">0</span>).getProperty(Message.PROPERTY_MAX_OFFSET);</span><br><span class="line">    <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> Long.parseLong(maxOffset) - offset;</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="comment">// TODO 消息堆积情况的特殊处理</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 正常消费过程</span></span><br><span class="line">    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者优化消息的处理步骤，比如需要查两次，写两次，可以合并为查/写一次完成</p><p>第二个问题：</p><p>RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。</p><p>我们丢了大量的数据，没办法，我们只能等队列比较少的时候。人工的去找出少了哪些数据，然后人工恢复数据</p><p>我们可以先访问RabbitMQ 自带的管理界面提供队列长度、消息速率等基本监控信息</p><p>默认端口15672，查看目标队列的 “Messages ready” (就绪消息数量) 和 “Messages unacknowledged” (未确认消息数量)。 如果 “Messages ready” 持续增长，说明队列存在积压。</p><p>第三个问题：</p><p>mq快写满了，我们可以直接丢弃，然后再补数据了只能</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/MQ2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Elasticsearch</title>
      <link>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/es1/</link>
      <guid>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/es1/</guid>
      <pubDate>Sat, 05 Jul 2025 16:00:00 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。&lt;/p&gt;
&lt;p&gt;单个</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p><p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p><p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p><p>下面的命令可以查看当前节点的所有 Index。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &#x27;http://localhost:9200/_cat/indices?v&#x27;</span><br></pre></td></tr></table></figure><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p><p>Document 使用 JSON 格式表示，下面是一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">  <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p><p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p><p>下面的命令可以列出每个 Index 所包含的 Type。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/_mapping?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p><p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫<code>weather</code>的 Index。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>服务器返回一个 JSON 对象，里面的<code>acknowledged</code>字段表示操作成功。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;acknowledged&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;shards_acknowledged&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>然后，我们发出 DELETE 请求，删除这个 Index。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/weather&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>需要指定中文分词器，不能使用默认的英文分词器。</p><p>Elastic 的分词器称为 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html">analyzer</a>。我们对每个字段指定分词器。</p><hr><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>新增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &#x27;localhost:9200/accounts/person/1&#x27; -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;数据库管理&quot;</span><br><span class="line">&#125;&#x27; </span><br></pre></td></tr></table></figure><p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ curl -X POST &#x27;localhost:9200/accounts/person&#x27; -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;李四&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;系统管理&quot;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><p>不进行指定的话<code>_id</code>字段就是一个随机字符串。</p><p>查询：</p><p>向<code>/Index/Type/Id</code>发出 GET 请求，就可以查看这条记录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/1?pretty=true&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>删除：</p><p>删除记录就是发出 DELETE 请求。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>这里先不要删除这条记录，后面还要用到。</p><p>更新：</p><p>更新记录就是使用 PUT 请求，重新发送一次数据。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT <span class="string">&#x27;localhost:9200/accounts/person/1&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;user&quot; : &quot;张三&quot;,</span></span><br><span class="line"><span class="string">    &quot;title&quot; : &quot;工程师&quot;,</span></span><br><span class="line"><span class="string">    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;accounts&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span>:2,</span><br><span class="line">  <span class="string">&quot;result&quot;</span>:<span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>:&#123;<span class="string">&quot;total&quot;</span>:2,<span class="string">&quot;successful&quot;</span>:1,<span class="string">&quot;failed&quot;</span>:0&#125;,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>返回所有记录：</p><p>使用 GET 方法，直接请求<code>/Index/Type/_search</code>，就会返回所有记录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>全文搜索：</p><p>Elastic 的查询非常特别，使用自己的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html">查询语法</a>，要求 GET 请求带有数据体。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>指定的匹配条件是<code>desc</code>字段里面包含”软件”这个词。返回结果如下。</p><p>Elastic 默认一次返回10条结果，可以通过<code>size</code>字段改变这个设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>还可以通过<code>from</code>字段，指定位移。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span></span><br><span class="line"><span class="string">  &quot;from&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;size&quot;: 1</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p><p>如果有多个搜索关键字， Elastic 认为它们是<code>or</code>关系。</p><p>如果要执行多个关键词的<code>and</code>搜索，必须使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-bool-query.html">布尔查询</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&#x27;localhost:9200/accounts/person/_search&#x27;</span>  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;bool&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;must&quot;: [</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;,</span></span><br><span class="line"><span class="string">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Java中使用"><a href="#Java中使用" class="headerlink" title="Java中使用"></a>Java中使用</h1><p>首先需要在 <code>pom.xml</code> 文件中添加 Elasticsearch 和 Jackson 的依赖：</p><p>创建客户端，在Config类里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestClient</span> <span class="variable">restClient</span> <span class="operator">=</span> RestClient</span><br><span class="line">  .builder(HttpHost.create(<span class="string">&quot;http://localhost:9200&quot;</span>))</span><br><span class="line">  .build();</span><br><span class="line"><span class="type">ElasticsearchTransport</span> <span class="variable">transport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestClientTransport</span>(restClient, <span class="keyword">new</span> <span class="title class_">JacksonJsonpMapper</span>());</span><br><span class="line"><span class="type">ElasticsearchClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElasticsearchClient</span>(transport);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>索引文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>, <span class="string">&quot;Mark Doe&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1471466076564L</span>));</span><br><span class="line"><span class="type">IndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.index(i -&gt; i</span><br><span class="line">  .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">  .id(person.getFullName())</span><br><span class="line">  .document(person));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">searchText</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">SearchResponse&lt;Person&gt; searchResponse = client.search(s -&gt; s</span><br><span class="line">  .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">  .query(q -&gt; q</span><br><span class="line">    .match(t -&gt; t</span><br><span class="line">      .field(<span class="string">&quot;fullName&quot;</span>)</span><br><span class="line">      .query(searchText))), Person.class);</span><br><span class="line"></span><br><span class="line">List&lt;Hit&lt;Person&gt;&gt; hits = searchResponse.hits().hits();</span><br><span class="line">assertEquals(<span class="number">1</span>, hits.size());</span><br><span class="line">assertEquals(<span class="string">&quot;John Doe&quot;</span>, hits.get(<span class="number">0</span>).source().getFullName());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模糊匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">fuzzyQuery</span> <span class="operator">=</span> FuzzyQuery.of(f -&gt; f</span><br><span class="line">    .field(<span class="string">&quot;fullName&quot;</span>)</span><br><span class="line">    .value(searchText)</span><br><span class="line">    .fuzziness(<span class="string">&quot;AUTO&quot;</span>))._toQuery();</span><br><span class="line"></span><br><span class="line">SearchResponse&lt;Person&gt; searchResponse = client.search(s -&gt; s</span><br><span class="line">    .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .query(q -&gt; q.bool(b -&gt; b.must(fuzzyQuery))), Person.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>fuzziness</code> 参数控制允许的编辑距离，可以设置为整数值或者 “AUTO”，后者会根据搜索词的长度自动调整</p><p>布尔查询:组合 <code>match</code> 查询（用于精确匹配）和 <code>fuzzy</code> 查询（用于模糊匹配）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">matchQuery</span> <span class="operator">=</span> MatchQuery.of(m -&gt; m.field(<span class="string">&quot;fullName&quot;</span>).query(searchText))._toQuery();</span><br><span class="line"><span class="type">Query</span> <span class="variable">fuzzyQuery</span> <span class="operator">=</span> FuzzyQuery.of(f -&gt; f</span><br><span class="line">    .field(<span class="string">&quot;fullName&quot;</span>)</span><br><span class="line">    .value(searchText)</span><br><span class="line">    .fuzziness(<span class="string">&quot;AUTO&quot;</span>))._toQuery();</span><br><span class="line"></span><br><span class="line">SearchResponse&lt;Person&gt; searchResponse = client.search(s -&gt; s</span><br><span class="line">    .index(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .query(q -&gt; q.bool(b -&gt; b.should(matchQuery).should(fuzzyQuery))), Person.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用 N-Grams 提高模糊匹配</strong>，通过索引文本的 n-gram 来提高模糊匹配的性能和准确性的技术</p><p>可以使用 Lucene 查询解析器语法构建更复杂的查询，包括通配符、布尔运算符等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">simpleStringQuery</span> <span class="operator">=</span> SimpleQueryStringQuery.of(q -&gt; q.query(<span class="string">&quot;*Doe&quot;</span>))._toQuery();</span><br><span class="line">SearchResponse&lt;Person&gt; response3 = client.search(s -&gt; s.query(q -&gt; q.bool(b -&gt; b</span><br><span class="line">  .must(simpleStringQuery))), Person.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li><strong>恰当的索引配置</strong>：合理配置分片数量和副本数量是提高查询性能的关键。分片数量应根据数据量和查询负载合理配置，副本数量则可以提高数据的可用性和查询性能。</li><li><strong>合理的分词器选择</strong>：选择合适的分词器和分析器可以显著提高搜索精确度和性能。</li><li><strong>高效的缓存使用</strong>：合理配置和使用不同层级的缓存，可以显著提高查询性能，减少响应时间。定期监控和调优缓存配置，确保缓存的高效利用和系统的健康运行。</li><li><strong>查询语句优化</strong>：根据具体的查询需求，选择合适的分页查询策略，如 from-size、Scroll、Search_after 和 Search_after (PIT)。不同的分页查询策略有各自的优缺点，合理选择可以提高查询性能和用户体验。同时自定义评分函数，可调整搜索结果的相关性评分，确保返回的结果更符合业务需求。</li><li><strong>慢查询瓶颈分析</strong>：需关注的CPU 使用率，内存使用率以及磁盘IO，当其中一项达到瓶颈，查询性能就可能上不去了。</li></ul><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="1-ES-的分布式架构原理能说一下么"><a href="#1-ES-的分布式架构原理能说一下么" class="headerlink" title="1.ES 的分布式架构原理能说一下么"></a>1.ES 的分布式架构原理能说一下么</h2><p>ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 lucene 的。核心思想就是在多台机器上启动多个 ES 进程实例，组成了一个 ES 集群。</p><p>ES 中存储数据的<strong>基本单位是索引</strong>，比如说你现在要在 ES 中存储一些订单数据，你就应该在 ES 中创建一个索引 <code>order_idx</code> ，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一个数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index -&gt; type -&gt; mapping -&gt; document -&gt; field</span><br></pre></td></tr></table></figure><p>一个 index 里可以有多个 type，每个 type 的字段都是差不多的</p><p>差不多是这么个对应关系</p><p>index-&gt;一类表</p><p>type-&gt;表</p><p>mapping-&gt;表结构</p><p>ducument-&gt;行</p><p>field-&gt;值</p><p>你搞一个索引，这个索引可以拆分成多个 <code>shard</code> ，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是<strong>支持横向扩展</strong>，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是<strong>提高性能</strong>，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p><p>接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 <code>primary shard</code> ，负责写入数据，但是还有几个 <code>replica shard</code> 。 <code>primary shard</code> 写入数据之后，会将数据同步到其他几个 <code>replica shard</code> 上去。</p><p>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</p><p>ES 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</p><p>如果是非 master 节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p><p>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p><p>其实上述就是 ElasticSearch 作为分布式搜索引擎最基本的一个架构设计。</p><p>其实都是差不多的，这些分布式的构建</p><h2 id="2-ES-写入数据的工作原理是什么啊？ES-查询数据的工作原理是什么啊？底层的-Lucene-介绍一下呗？倒排索引了解吗？"><a href="#2-ES-写入数据的工作原理是什么啊？ES-查询数据的工作原理是什么啊？底层的-Lucene-介绍一下呗？倒排索引了解吗？" class="headerlink" title="2.ES 写入数据的工作原理是什么啊？ES 查询数据的工作原理是什么啊？底层的 Lucene 介绍一下呗？倒排索引了解吗？"></a>2.ES 写入数据的工作原理是什么啊？ES 查询数据的工作原理是什么啊？底层的 Lucene 介绍一下呗？倒排索引了解吗？</h2><p>写数据：</p><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code> （协调节点）。</li><li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code> 。</li><li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li></ul><p>读数据：</p><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code> 。</li><li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 <code>coordinate node</code> 。</li><li><code>coordinate node</code> 返回 document 给客户端。</li></ul><p>搜索数据：</p><p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code> 的 <code>document</code> 给搜索出来。es 就会给你返回：java 真好玩儿啊，java 好难学啊。</p><ul><li>客户端发送请求到一个 <code>coordinate node</code> 。</li><li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code> ，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code> ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li></ul><p>底层lucene:</p><p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p><p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构</p><p>倒叙索引：</p><p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p><p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p><p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p><p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code> ，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p><ul><li>倒排索引中的所有词项对应一个或多个文档；</li><li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li></ul><p>底层实现：</p><h2 id="3-ES-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"><a href="#3-ES-生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？" class="headerlink" title="3.ES 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？"></a>3.ES 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</h2><ul><li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li><li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li><li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li></ul><h2 id="4-ES-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"><a href="#4-ES-在数据量很大的情况下（数十亿级别）如何提高查询效率啊？" class="headerlink" title="4.ES 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？"></a>4.ES 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</h2><p><strong>使用filesystem cache</strong></p><p>往 es 里写的数据，实际上都写到磁盘文件里去了，<strong>查询的时候</strong>，操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去。</p><p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code> ，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code>索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p><p>最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p><p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。</p><p><strong>数据预热</strong></p><p>最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p><p><strong>冷热分离</strong></p><p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让他们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p><p><strong>document模型设计</strong></p><p>最好是先在 <strong>Java 系统里就完成关联，将关联好的数据直接写入 es 中</strong>。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p><p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p><p><strong>分页性能优化</strong></p><p>假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><p>前面的几页速度挺快，后面的就不行了。</p><p>解决办法：</p><p>1.不允许深度分页</p><p>2.类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code></p><p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p><p>但是他<strong>不能随意跳到任何一页的场景</strong>。</p><p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p><p>除了用 <code>scroll api</code> ，你也可以用 <code>search_after</code> 来做， <code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>]]></content:encoded>
      
      
      <category domain="https://blog.tokenlen.top/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/">技术栈</category>
      
      
      <category domain="https://blog.tokenlen.top/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      <category domain="https://blog.tokenlen.top/tags/Elasticsearch/">Elasticsearch</category>
      
      
      <comments>https://blog.tokenlen.top/2025/07/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/new-stack/es1/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
